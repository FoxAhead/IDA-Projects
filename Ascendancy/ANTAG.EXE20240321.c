/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Watcom C++
*/

#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn sub_10000(); // weak
int __fastcall sub_10010(T_Type5 *a1, int a2, int a3, int a4);
int __fastcall sub_10668(_DWORD *, char *, int, int);
int __fastcall sub_10878(_DWORD *, int, int, int);
int __fastcall sub_10A14(int a1, int a2);
void __fastcall __spoils<> sub_10A3C(P_TypeA8 a1);
int __fastcall sub_10A80(int a1, char a2);
void __fastcall __spoils<> sub_10AC4(P_TypeA8 result);
int __fastcall sub_10B24(int, unsigned __int16, int, int *);
void __fastcall sub_11870(int, int edx0);
int __fastcall sub_11BA4(int a1);
int __fastcall sub_12140(int a1);
int __fastcall sub_12238(int a1, int a2);
void __fastcall sub_1229C(int a1, int a2);
unsigned int __fastcall sub_12368(int a1, int a2);
unsigned int __fastcall sub_1240C(int a1, int a2);
char *__fastcall sub_12440(int a1);
int __fastcall sub_12480(float *, float *, int, int, float);
unsigned int __fastcall sub_12618(int a1);
void __fastcall sub_12674(int a1);
// int __usercall sub_126F8@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebp>);
int __fastcall sub_12AE4(int a1, int a2);
void __fastcall sub_12B4C(int, int);
unsigned int __fastcall sub_12C98(int a1, int a2, int a3);
unsigned int __fastcall sub_12E88(int a1);
// int __usercall sub_12F7C@<eax>(int a1@<eax>, int *a2@<ecx>, int a3@<ebp>);
unsigned int __fastcall sub_13370(int a1, int a2, int a3);
unsigned int __fastcall sub_136C4(int a1);
unsigned int __fastcall sub_1380C(int a1);
int *__fastcall sub_139E0(int a1, int a2);
int *__fastcall sub_13A28(int a1, int a2);
unsigned int __fastcall sub_13AD8(int a1, int a2);
_DWORD *__fastcall sub_13BC0(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_13BF0(_DWORD *result);
unsigned int __fastcall sub_13C10(int a1);
unsigned int __fastcall sub_14224(int a1);
int __fastcall sub_142D8(int);
int __fastcall sub_14490(int);
unsigned int __fastcall sub_145C0(int);
unsigned int __fastcall sub_147CC(int a1);
unsigned int __fastcall sub_14B18(int a1, int a2, int a3);
unsigned int __fastcall sub_15078(int a1);
unsigned int __fastcall sub_15164(int a1);
unsigned int __fastcall sub_152E4(int a1, int a2, int a3, int a4);
int *__fastcall sub_15630(int a1, int a2);
int __fastcall sub_156C0(int a1, int a2, unsigned __int16 a3);
int __fastcall sub_1577C(int a1);
int __fastcall sub_15788(int result);
int __fastcall sub_15794(int result, int a2);
int __fastcall sub_157B4(const void *, const void *); // idb
void __fastcall sub_157EC(size_t *a1);
char *__fastcall sub_15808(int a1, int a2, int a3);
int __fastcall sub_15948(int a1, int a2);
int __fastcall sub_15D20(int a1);
int __fastcall sub_15D2C(int result);
int __fastcall sub_15D38(int result, const void *a2);
int __fastcall sub_15D74(int result, int a2);
int __fastcall sub_15DA4(int result, int a2, unsigned __int16 a3);
void __fastcall sub_15E1C(int *a1, int a2);
int __fastcall sub_15ED4(T_TypeA2 *a1);
void *__fastcall sub_1604C(int a1, char a2);
int __fastcall sub_16120(int a1);
int __fastcall sub_16348(int, unsigned __int16, int, signed int);
void __fastcall sub_16D6C(int a1, int a2, int a3, int a4);
int __fastcall sub_16FC0(int a1, int a2, int a3, int a4);
int __fastcall sub_171D0(int a1, int a2, int a3);
char *__fastcall sub_17204(int a1, int a2, int a3);
void __fastcall sub_17260(int result);
void __fastcall sub_172B0(int a1);
int __fastcall sub_173F4(int a1, int a2, int a3, int a4);
int __fastcall sub_17430(int a1);
void __fastcall sub_17E50(int a1, int a2, int a3, int a4);
float *__fastcall sub_17E88(int a1, int a2);
void __fastcall sub_17F54(int a1);
void __fastcall sub_17FF0(int a1, int a2, int a3, int a4);
void __fastcall sub_181F0(int a1);
int __fastcall sub_1826C(int a1, int a2, unsigned __int16 a3, unsigned __int16 a4);
void __fastcall sub_182B8(int a1, int a2);
unsigned int __fastcall sub_18370(int);
int __fastcall sub_185CC(int a1);
void __fastcall sub_186B8(int a1, int a2, int a3);
int __fastcall sub_187EC(int a1);
void __fastcall sub_18C2C(int a1, int a2);
void __fastcall sub_18CA8(int, int);
void __fastcall sub_1936C(int a1);
int __fastcall sub_19AE8(int a1);
__int64 __fastcall sub_19E2C(int a1, unsigned int a2, int a3);
int __fastcall sub_1A9C0(int a1);
int __fastcall sub_1A9E0(int a1);
int __fastcall sub_1AA00(int a1);
_DWORD *__fastcall sub_1AA40(float *a1, float *a2);
__int64 __fastcall sub_1AA90(int a1);
_DWORD *__fastcall sub_1AAC0(int a1);
_DWORD *__fastcall sub_1ABE0(_DWORD *a1);
float *__fastcall sub_1AC70(float *result, int a2, int a3, int a4);
_DWORD *__fastcall sub_1ACA0(_DWORD *result);
int __fastcall sub_1ACC0(int a1, int a2, int a3);
int __fastcall sub_1ACE8(int result);
int __fastcall sub_1ACF4(int a1);
_DWORD *__fastcall sub_1AD1C(int, int);
int __fastcall sub_1ADAC(int a1, const char *a2);
int __fastcall sub_1AEB0(unsigned int a1, unsigned __int16 a2, const char *a3);
int __fastcall sub_1B000(unsigned int a1, unsigned __int16 a2);
int __fastcall sub_1B084(unsigned int a1, int a2);
int __fastcall sub_1B270(int a1, const char *a2, int a3);
int __fastcall sub_1B2DC(unsigned int a1, int a2);
int __fastcall sub_1B354(unsigned int a1, unsigned __int16 a2);
_DWORD *__fastcall sub_1B498(_DWORD *result);
_DWORD *__fastcall sub_1B4D0(_DWORD *a1);
_DWORD *__fastcall sub_1B4F0(_DWORD *a1);
void __fastcall sub_1B808(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __fastcall sub_1B834(int a1, int a2);
float *__fastcall sub_1B864(int a1, int a2, int a3, int a4);
float *__fastcall sub_1B958(int a1, float *a2, int a3, int a4);
void __fastcall sub_1BAF0(float *a1, int a2, int a3, int a4, int a5);
FILE *__fastcall sub_1BB10(const char *aFName, fpos_t *pos);
void __fastcall __spoils<> Q_InitFileInfo_sub_1BB78(P_Type1 a1);
void __fastcall __spoils<> Q_CloseFileAndDelete_sub_1BBC8(P_Type1 a1);
BOOL __fastcall Q_CfilePreload_sub_1BBFC(P_Type1 a1, const char *aFName, int aOFlags, int a4);
BOOL __fastcall sub_1BCA8(T_Type1 *, const char *);
BOOL __fastcall Q_CFILE_CPP_sub_1BCBC(T_Type1 *a1, int aOFlags);
int __fastcall Q_CloseFile_sub_1BE00(P_Type1 a1);
int __fastcall sub_1BE28(P_Type1 a1);
int __fastcall sub_1BEA0(int *a1);
int __fastcall sub_1BECC(int *a1, int offset, int a3);
int __fastcall sub_1BF0C(int *a1, int a2);
void *__fastcall sub_1BF1C(T_Type1 *, void *);
int __fastcall sub_1BF94(P_Type1 a1, void *aBuf, unsigned int aLen);
unsigned int __fastcall sub_1BFD4(int *a1, void *buf, unsigned int a3, unsigned int a4, int a5);
unsigned int __fastcall sub_1C098(unsigned int count, int a2, unsigned int a3);
void __fastcall Q_CFILE_CPP_IndexOneCob_sub_1C278(P_CobFilesIndex a1, char *CobFileName);
void __fastcall Q_CobCfgLoad_sub_1C3C4(P_CobFilesIndex a1);
void func(void); // idb
int __fastcall main(int argc, char *argv[]);
void sub_1CC94();
int Q_CORN_CPP_StaticTxtLoad_sub_1CD3C();
char *__fastcall Q_CORN_CPP_StaticTxtRead_sub_1CEA8(int aTextIndex);
int sub_1CEF0();
unsigned __int8 __fastcall sub_1CF14(unsigned __int8 result);
_DWORD *__fastcall sub_1CF40(_DWORD *result);
int __fastcall sub_1CF68(int a1, int a2);
__int16 __fastcall sub_1D234(int a1, int a2, __int16 a3);
unsigned int __fastcall sub_1D3E8(int a1, int a2, int a3);
unsigned int __fastcall sub_1D538(int a1, int a2);
int __fastcall sub_1D654(__int16 *a1, int a2, int a3);
void __fastcall sub_1D734(int a1, int a2);
int __fastcall sub_1D794(__int16 *a1, _DWORD *a2);
unsigned int __fastcall sub_1D834(int a1, __int16 a2);
int *__fastcall sub_1D920(int a1, unsigned int count, int a3);
int __fastcall sub_1DA04(int a1, int a2);
int __fastcall sub_1DA4C(int a1, __int16 a2, int a3, int a4);
int __fastcall sub_1DB70(int a1, __int16 a2, int a3, int a4);
int __fastcall sub_1DE64(int a1);
int __fastcall sub_1E03C(int a1);
char __fastcall sub_1E094(int);
void __fastcall sub_1E10C(int a1, __int16 a2, __int16 a3, __int16 a4);
int __fastcall sub_1E150(int a1, __int16 a2);
int __fastcall sub_1E2A0(int a1, __int16 a2);
void __fastcall sub_1E70C(int a1, __int16 a2, unsigned __int8 a3);
char __fastcall sub_1EE08(int a1, char a2);
__int16 __fastcall sub_1EEA4(int);
void __fastcall sub_1EFC0(int a1);
unsigned int __fastcall sub_1F038(int a1);
int __fastcall sub_1F404(int);
int sub_1F91C();
int __fastcall sub_1FB34(int a1);
void __fastcall sub_1FD18(int a1, int a2);
int __fastcall sub_1FD90(int a1, int a2, int a3);
int __fastcall sub_1FDF0(int a1, int a2, int a3, int a4);
int __fastcall sub_1FFE0(int a1, int a2);
int __fastcall sub_2016C(int a1, int a2, __int16 a3);
int __fastcall sub_201D8(int a1);
int __fastcall sub_205A0(int a1, int a2, int a3);
char *__fastcall sub_20684(int a1, __int16 a2);
__int16 __fastcall sub_20720(int a1, int a2);
char __fastcall sub_207A0(int a1);
int __fastcall sub_20B3C(int a1);
char __fastcall sub_20C94(int a1, int a2, int a3, int a4);
int __fastcall sub_2106C(int result);
unsigned __int8 __fastcall sub_21170(int a1);
int __fastcall sub_211EC(int a1, int a2, int a3);
void __fastcall sub_21314(int a1);
int __fastcall sub_21374(int, unsigned int count); // idb
__int16 __fastcall sub_21AA0(int a1, unsigned int count);
__int16 __fastcall sub_220CC(int a1);
int __fastcall sub_22260(int a1);
int __fastcall sub_22280(int a1);
int __fastcall sub_222A0(int a1);
int __fastcall sub_222C0(int a1);
int __fastcall sub_222E0(int a1);
int __fastcall sub_22300(int a1);
int __fastcall sub_22320(int a1);
_DWORD *__fastcall sub_22360(int a1);
char *__fastcall sub_223B0(int a1);
char *__fastcall sub_223E0(int a1);
int __fastcall sub_22400(int result);
int __fastcall sub_22430(const void *, const void *); // idb
int sub_22468();
char *__fastcall sub_224A4(int a1);
char *__fastcall sub_22588(char *a1, char a2);
unsigned int __fastcall Q_COSWND_CPP_sub_22644(int, const char *, const char *);
_DWORD *__fastcall sub_2280C(int a1, int a2, int a3, int a4);
void __fastcall sub_23BF0(unsigned int a1, int a2);
int __fastcall sub_23FD4(int a1);
void __fastcall sub_24154(int a1, int a2, int a3, int a4, float a5);
void __fastcall sub_24198(int a1, int a2, int a3, int a4);
void __fastcall sub_2422C(int a1, int a2, int a3, int a4);
int __fastcall sub_24948(int result, int a2, int a3);
int __fastcall sub_24BE0(int a1);
int __fastcall sub_24D30(int a1, int a2, int a3, int a4);
__int64 __fastcall sub_24FCC(int a1, T_Type1 *a2, int a3);
int __fastcall sub_254A4(int a1);
int __fastcall sub_254B0(int result);
int __fastcall sub_254BC(int result, int a2);
void __fastcall sub_254DC(size_t *a1);
unsigned int __fastcall sub_254F8(unsigned int a1, unsigned int a2);
P_TypeA2 __fastcall sub_25BF8(P_TypeA2 a1);
int __fastcall sub_25C08(int a1, char a2);
void __fastcall sub_25C4C(unsigned int a1, int a2);
int __fastcall sub_25CB8(int result);
int __fastcall sub_25CD4(int a1, char a2);
void __fastcall sub_25D18(int result, int);
int __fastcall sub_25FB4(int result);
unsigned int __fastcall sub_26000(int a1, __int16 a2, __int16 a3, int a4);
int __fastcall sub_26140(int a1);
char *__fastcall sub_26150(int a1);
int sub_26160();
void Q_debugbreak_sub_26194();
void __fastcall __spoils<> Q_AssertLogBreakExit_sub_26198(int assert, const char *sourcefile, int line);
void __fastcall __spoils<> Q_AssertLogBreakExit_sub_261A8(int assert, const char *sourcefile, int line);
int __fastcall sub_261B8(int result, const char *a2, int a3);
int __cdecl sub_2620C(char *format, char); // idb
void __noreturn Q_debugbreak_exit_sub_2624C();
void *__fastcall sub_2625C(void *aData, int a2, char *a3);
void __fastcall sub_2627C(void *);
void *__fastcall sub_2628C(size_t a1, int a2, char *s2);
void *__fastcall sub_262B0(size_t, size_t, int, char *);
void __fastcall sub_262CC(void *ptr);
void sub_262F0();
void sub_26314();
void sub_2631C();
void sub_26328();
void sub_2632C();
int sub_2633C();
__int16 __fastcall __spoils<> sub_26360(__int16 a1);
unsigned int sub_264B4();
int __fastcall sub_2656C(__int16 a1);
void __fastcall sub_265A8(int a1);
void __fastcall __spoils<> sub_267A0(P_TypeA5 a1);
int __fastcall sub_267BC(int a1, char a2);
void __fastcall __spoils<> sub_26800(P_TypeA5 result);
char __fastcall sub_26874(int a1, __int16 *a2);
unsigned int __fastcall sub_270F4(int a1, __int16 a2, int a3, int a4);
void __fastcall __spoils<> sub_2712C(T_TypeA2 *a1);
int __fastcall sub_2713C(int a1, char a2);
unsigned int __fastcall sub_27184(int a1, __int16 a2, int a3, int a4);
__int64 __fastcall sub_271FC(int);
void __fastcall __spoils<> sub_27BF8(P_TypeA2 a1);
int __fastcall sub_27C08(int a1, char a2);
unsigned int __fastcall sub_27C50(int a1, __int16 a2, int a3, int a4);
void __fastcall sub_27D18(int, int, int, int);
void sub_28C40();
int __fastcall sub_28C4C(__int16 *a1, __int16 *a2);
void __fastcall __spoils<> sub_28C74(P_Type2 a1);
__int64 __fastcall sub_28DA4(int a1);
unsigned int __fastcall sub_28EB4(int a1, const char *a2, int a3, int a4, int a5);
int __fastcall sub_29038(int, size_t, unsigned int, int, int, int);
unsigned int __fastcall sub_296B4(int, int, int, int);
void __fastcall sub_29B24(_DWORD *a1, int a2, int a3, int a4);
unsigned __int16 __fastcall sub_29C6C(int, _WORD *);
int __fastcall sub_29D54(int, unsigned __int8 *);
void __fastcall sub_29F58(int a1, const void *a2);
FILE *__fastcall sub_2A1DC(int, const char *);
void __fastcall sub_2AA88(int a1);
int __fastcall sub_2AC84(int a1, ULONG hertz);
void __fastcall sub_2AD08(int a1);
__int16 __cdecl sub_2AD40(unsigned __int16 *a1, int a2, LONG y);
void __fastcall __spoils<> sub_2AE80(P_TypeA9 a1);
void *__fastcall sub_2AEB0(int a1, char a2);
unsigned int __fastcall sub_2AF04(int a1, const char *a2);
int __fastcall sub_2AF3C(int a1);
unsigned int __fastcall sub_2AFF0(int a1, __int16 a2, int a3, int a4);
void __fastcall __spoils<> sub_2B2C0(_DWORD *);
void **__fastcall sub_2B2E0(void **a1);
unsigned int __fastcall sub_2B2FC(int a1, const char *aFName);
unsigned int __fastcall sub_2B360(void **a1, const char *aFName);
_DWORD *__fastcall sub_2B3E0(_DWORD *result, int a2, int a3, int a4, int a5);
int __fastcall sub_2B3F4(int, char *s2, char *s1, int);
int __fastcall sub_2B4F4(_DWORD *, char *string);
int __fastcall sub_2B594(int *a1);
int __fastcall sub_2B5BC(int *a1, char *a2);
void __fastcall sub_2B610(_DWORD *, int, int, char *, int, int, __int16);
int __fastcall sub_2B8A8(int, int, int, const char *, __int16, __int16, __int16, int);
int sub_2BB50();
unsigned int __fastcall sub_2BB74(int **a1, int *a2, int *a3, int *a4, int *a5, unsigned __int8 a6, int a7);
int __fastcall sub_2BC40(_DWORD *, int, int, int *, int *);
int __fastcall sub_2BCF4(int a1, unsigned __int8 a2);
__int64 __fastcall sub_2BD04(int a1, char a2, char *a3);
int __fastcall sub_2BD4C(int result);
T_Type6 *__fastcall sub_2BD7C(T_Type6 *a1);
unsigned int __fastcall sub_2BD88(P_Type6 a1, const char *a2, const char *a3);
unsigned int __fastcall sub_2BFDC(P_Type6 a1, int a2, int a3, int a4);
void *__fastcall sub_2C08C(int, unsigned __int16);
int __fastcall sub_2C0C0(int a1, const char *a2, unsigned __int16 a3);
unsigned int __fastcall sub_2C158(P_Type6 a1, const char *aFName, int a3, unsigned __int16 a4);
int __fastcall sub_2C1E0(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned int a4);
int __fastcall sub_2C224(P_Type6 a1, unsigned __int16 a2, __int16 a3, RGB *a4);
int __fastcall sub_2C2B0(int, unsigned __int16, __int16, int);
void __fastcall sub_2C2F8(int a1, char *a2);
void __fastcall sub_2C418(int, int, __int16);
void __fastcall sub_2C4C0(int a1, int a2, int a3);
__int64 __fastcall sub_2C5E4(int a1, char a2);
void __fastcall sub_2C670(int a1, int a2, int a3, char *a4);
void __fastcall sub_2C6CC(P_Type6 a1);
void __fastcall sub_2C744(P_Type6 a1, int a2, int a3, int a4);
void __fastcall Q_GSYSTEM_CPP_sub_2C7D0(T_Type6 *a1, int a2, int a3);
void __fastcall __spoils<> sub_2C830(P_TypeA2 a1);
int __fastcall sub_2C848(int, char);
void __fastcall __spoils<> sub_2C8E4(P_TypeA1 result);
int __fastcall sub_2C978(P_TypeA1 a1);
unsigned int __fastcall sub_2C990(int a1, int a2);
unsigned int __fastcall sub_2CA0C(int a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_2CA78(_DWORD *result, __int16 a2, __int16 a3);
void __fastcall sub_2CD24(unsigned int a1, int a2);
void __fastcall sub_2CF28(unsigned int a1);
unsigned int __fastcall sub_2D0F4(unsigned int a1, int a2);
void __fastcall sub_2D218(_DWORD *a1);
int __fastcall sub_2D258(int result, __int16 a2);
int __fastcall sub_2D2CC(int a1, int a2, int a3, int a4);
int __fastcall sub_2D334(const char *a1);
char *__fastcall sub_2D3D0(int a1);
unsigned int __fastcall sub_2D400(int a1, int a2);
void __fastcall __spoils<> sub_2D464(P_TypeA4 a1);
int __fastcall sub_2D480(int a1, char a2);
void __fastcall __spoils<> sub_2D4C4(P_TypeA4 result);
unsigned int __fastcall sub_2D4D0(_DWORD *a1, __int16 a2, int a3, int a4);
void __fastcall sub_2D528(int a1, int a2);
void __fastcall sub_2D79C(int a1);
int __fastcall sub_2D99C(int a1, unsigned int count, int a3);
int __fastcall sub_2D9C4(int a1);
int __fastcall sub_2D9FC(int a1, char a2);
int __fastcall sub_2DA60(int result);
int __fastcall sub_2DA68(T_TypeA1 *a1);
void *__fastcall sub_2DA80(int a1, __int16 a2);
unsigned int __fastcall sub_2DAC8(int a1, __int16 a2, __int16 a3, int a4);
int __fastcall sub_2DB54(int result, __int16 a2, __int16 a3);
unsigned int __fastcall sub_2DBE4(int a1, int a2, int a3);
int __fastcall sub_2DCA0(int result, __int16 a2);
int __fastcall sub_2DD70(int a1);
unsigned int __fastcall sub_2DDB8(int a1, __int16 a2);
unsigned int __fastcall sub_2DE68(int a1, __int16 a2, int a3, int a4);
// void __usercall sub_2E084(int a1@<eax>, __int16 a2@<si>);
int __fastcall sub_2E1B4(int a1, unsigned int count, int a3);
int sub_2E208(); // weak
T_TypeA2 *__fastcall sub_2E248(T_TypeA2 *a1);
int __fastcall sub_2E264(int a1, char a2);
int __fastcall sub_2E2B8(int a1);
int __fastcall sub_2E3BC(T_TypeA1 *a1);
unsigned int __fastcall sub_2E3D4(int a1, __int16 a2, signed int a3, signed int a4);
void __fastcall sub_2E6C0(int);
void __fastcall sub_2E868(int a1, int a2);
int __fastcall sub_2E9CC(int a1, char a2);
int __fastcall sub_2EA8C(int a1, const char *a2, __int16 a3, int a4);
unsigned int __fastcall sub_2EC50(int a1, unsigned __int16 a2, int a3);
int __fastcall sub_2ECA4(int a1, unsigned __int16 a2);
int __fastcall sub_2ECDC(int result, unsigned __int16 a2);
int __fastcall sub_2ED14(int a1, unsigned __int16 a2);
int __fastcall sub_2ED4C(int a1);
void __fastcall sub_2EDC8(int, unsigned int, unsigned int);
void __fastcall sub_2F090(int a1, unsigned int a2, unsigned int a3, __int16 a4);
int __fastcall sub_2F1C8(int result, int a2);
int __fastcall sub_2F1D8(int result, int a2);
void __fastcall sub_2F1E0(int a1);
int __fastcall sub_2F228(int a1, size_t a2, int a3);
void __fastcall sub_2F2B4(int a1);
T_TypeA2 *__fastcall sub_2F2F4(T_TypeA2 *result);
int __fastcall sub_2F30C(int a1, char a2);
void __fastcall sub_2F354(int);
int __fastcall sub_2F414(int a1);
int __fastcall sub_2F420(int a1, __int16 a2, int a3, int a4);
unsigned int __fastcall sub_2F424(int a1, __int16 a2, int a3, int a4);
int __fastcall sub_2F478(int a1, __int16 a2, int a3, int a4);
T_TypeA2 *__fastcall sub_2F48C(T_TypeA2 *a1);
int __fastcall sub_2F4A8(int a1, char a2);
int __fastcall sub_2F4EC(int result);
void __fastcall sub_2F540(int);
unsigned int __fastcall sub_2F6B0(int a1, __int16 a2, char a3, unsigned int a4);
int __fastcall sub_2F8A4(int a1, int a2);
// char __usercall sub_2F8F8@<al>(int a1@<eax>, __int16 a2@<dx>, char a3@<bl>, int a4@<edi>);
int __fastcall sub_2F9A4(int a1, const char *a2, __int16 a3);
void __fastcall __spoils<> sub_2FA18(P_TypeA3 a1);
int __fastcall sub_2FA34(int a1, char a2);
void __fastcall __spoils<> sub_2FA78(P_TypeA3 result);
void __fastcall sub_2FA98(int);
void __fastcall sub_2FBA4(int, int);
int __fastcall sub_2FC3C(int a1);
void __fastcall __spoils<> sub_2FC50(P_TypeA2 a1);
int __fastcall sub_2FC68(int a1, char a2);
int __fastcall sub_2FCB0(_DWORD *a1, char *a2, char *a3);
unsigned int __fastcall sub_2FD68(int a1, __int16 a2, int a3, int a4);
void __fastcall Q_HELPWIN_CPP_FgetsLine_sub_2FE58(FILE *fp, char *line);
int sub_3067B(); // weak
int sub_306F0(); // weak
void __fastcall sub_30774(int a1);
int __fastcall sub_30A90(T_Type5 *a1, int edx0, int a3, int a4);
int __fastcall sub_31158(_DWORD *a1, int a2, int a3, int a4);
T_TypeA2 *__fastcall sub_31200(T_TypeA2 *result);
int __fastcall sub_3121C(int a1, char a2);
unsigned int __fastcall sub_31268(int a1, unsigned __int16 a2, int a3, int a4);
void __fastcall sub_3160C(int a1);
T_Type1 *__fastcall sub_316A8(int a1, int a2);
int __fastcall sub_317D0(int a1);
int __fastcall sub_318A0(unsigned __int16 a1, unsigned __int8 a2);
unsigned __int8 __fastcall sub_31934(int a1);
int __fastcall sub_31A34(unsigned __int16 a1, char a2);
int __spoils<> sub_31B08();
int __fastcall sub_31C18(int result, int);
char __fastcall sub_31E60(const char *a1, int a2);
int __fastcall sub_31FB0(_DWORD *a1, const char *a2, int a3, int a4);
void __fastcall __spoils<> sub_3201C(P_TypeA7 a1);
int __fastcall sub_32038(int a1, char a2);
void __fastcall __spoils<> sub_3207C(P_TypeA7 result);
unsigned int __fastcall sub_320B8(int a1, __int16 a2, int a3, int a4);
void __fastcall sub_32414(int a1);
void *__fastcall sub_32658(int a1);
int __fastcall sub_32714(int a1, int a2, __int16 a3);
int __fastcall sub_32800(int a1, int a2);
int __fastcall sub_32A1C(int a1);
__int64 __fastcall sub_32A48(int a1, int a2, __int16 a3, int a4, int a5);
__int64 __fastcall sub_32B44(int a1, int a2, __int16 a3);
__int64 __fastcall sub_32BDC(int a1, char a2);
__int64 __fastcall sub_32C14(int a1, char a2);
int __fastcall sub_32E84(int a1, int a2, int a3, int a4);
int __fastcall sub_32FD8(int, FILE *, int);
unsigned int __fastcall sub_330DC(T_Type5 *a1, unsigned __int8 *a2);
void __fastcall __spoils<> sub_33598(P_TypeA4 a1);
int __fastcall sub_335B4(int a1, char a2);
void __fastcall __spoils<> sub_335F8(P_TypeA4 result);
unsigned int __fastcall sub_33604(int a1, __int16 a2, int a3, int a4);
void __fastcall sub_33674(int a1);
void __fastcall __spoils<> sub_33830(P_TypeA6 a1);
int __fastcall sub_33840(int a1, char a2);
int __fastcall sub_33884(_DWORD *a1, int a2, int a3, int a4);
unsigned int __fastcall sub_338DC(int a1, __int16 a2, int a3, int a4);
unsigned int __fastcall sub_33A68(int a1);
__int16 __fastcall sub_33AF0(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4);
FILE *sub_33D30();
int __fastcall sub_3407C(int a1);
void __fastcall sub_3420C(int a1);
unsigned int __fastcall sub_34368(int a1, unsigned __int8 a2, unsigned __int16 a3);
int __fastcall sub_34774(int result, unsigned __int8 a2, int a3, int a4);
int __fastcall sub_347CC(int a1, unsigned __int8 a2);
unsigned __int16 __fastcall sub_34A44(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __fastcall sub_34AE4(int a1, unsigned __int8 a2, int a3);
unsigned int __fastcall sub_34B0C(int a1, int a2, unsigned __int8 a3, unsigned __int8 a4);
unsigned __int16 __fastcall sub_34E70(int);
int __fastcall sub_352E0(int);
__int16 __fastcall sub_3583C(int a1, unsigned __int16 a2, unsigned __int8 a3);
int __fastcall sub_358BC(int a1);
int __fastcall sub_358F0(int a1);
int __fastcall sub_35930(int a1, char a2);
int __fastcall sub_35968(int a1, int a2, int a3);
unsigned int __fastcall sub_35A00(int a1, unsigned __int16 a2);
char *__fastcall sub_35A70(int a1, unsigned __int16 a2);
unsigned __int16 __fastcall sub_35B04(int a1, unsigned __int16 a2, int a3);
unsigned int __fastcall sub_35BB4(int a1, int a2);
unsigned int __fastcall sub_35C38(int a1, int a2);
char __fastcall sub_35DA4(int a1);
char __fastcall __spoils<ah> sub_35E24(int a1);
int __fastcall sub_35ED8(int a1);
int __fastcall sub_35FE0(int a1);
void __fastcall sub_36050(int a1);
void __fastcall sub_360D8(int a1);
void __fastcall sub_36158(int a1);
unsigned int __fastcall sub_361B8(int a1);
unsigned int __fastcall sub_3623C(int a1);
int __fastcall sub_362C8(int a1, _DWORD *a2);
unsigned int __fastcall sub_362E0(int a1);
void __fastcall sub_3636C(int a1, int a2);
int __fastcall sub_363B0(int a1);
int __fastcall sub_364B4(int a1, __int16 a2);
int __fastcall sub_366C8(int a1, char a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
int __fastcall sub_3676C(int a1, int a2);
__int16 __fastcall sub_36A5C(int a1, int a2, __int16 a3);
unsigned int __fastcall sub_36CD4(int a1, unsigned __int16 a2, int *a3);
unsigned __int16 __fastcall sub_37040(int a1);
unsigned int __fastcall sub_370B8(int a1, unsigned int count, int a3);
T_TypeA2 *__fastcall sub_372B0(T_TypeA2 *a1, int a2, int a3, int a4);
int __fastcall sub_372CC(int a1, char a2);
int __fastcall sub_37310(int a1, int a2, int a3, int a4);
int __fastcall sub_37380(int a1, int a2);
int __fastcall sub_373E0(int a1, int a2);
int __fastcall sub_3745C(T_Type5 *a1, unsigned __int8 *a2, int a3, int a4);
unsigned int __fastcall sub_37568(int a1, unsigned __int16 a2, int a3, unsigned int a4);
void __fastcall sub_384B0(int a1);
char __fastcall sub_39390(int a1, unsigned __int8 a2, __int16 *a3, _WORD *a4);
__int16 __fastcall sub_393F4(int a1, unsigned __int16 a2, _WORD *a3, _WORD *a4);
char *__fastcall sub_394BC(int a1);
int __fastcall sub_395C4(int a1, unsigned int count, int a3);
void __fastcall __spoils<> sub_395EC(P_TypeA2 result);
int __fastcall sub_395FC(int a1, char a2);
unsigned int __fastcall sub_39644(int a1, __int16 a2, int a3, int a4);
void __fastcall sub_396F0(int, int);
T_TypeA2 *__fastcall sub_39D80(T_TypeA2 *a1);
int __fastcall sub_39D9C(int a1, char a2);
char *sub_39DE0();
unsigned int __fastcall sub_39E3C(int a1, __int16 dx0, int a3, int a4);
void __fastcall sub_3A6BC(int a1);
int __fastcall sub_3B120(int);
int __fastcall sub_3B188(int result);
int __fastcall sub_3B1FC(_BYTE *a1, char a2, __int16 a3);
char __fastcall sub_3B220(int a1, int a2, int a3, int a4);
int __fastcall sub_3B56C(unsigned __int8 *a1, __int16 *a2);
void __fastcall sub_3B5B8(unsigned __int8 *a1);
unsigned int __fastcall sub_3C12C(unsigned __int8 *a1, _DWORD *a2);
char __fastcall sub_3C1C0(unsigned __int8 *a1, int *a2, int a3);
int __fastcall sub_3C2E8(unsigned __int8 *a1, int a2, int a3);
char __fastcall sub_3C670(_BYTE *a1);
int __fastcall sub_3C968(int a1);
int __fastcall sub_3CB60(unsigned __int8 *a1, int a2, unsigned __int8 a3);
unsigned int __fastcall sub_3CCE4(_BYTE *a1, int a2);
// char __usercall sub_3D8F0@<al>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<edi>);
unsigned int __fastcall sub_3E020(int a1, int a2, unsigned __int8 a3);
int __fastcall sub_3E1CC(int a1, int a2);
unsigned int __fastcall sub_3E520(int a1, int a2);
int __fastcall sub_3E800(_BYTE *a1, unsigned __int16 *a2);
__int16 __fastcall sub_3EA7C(_BYTE *a1);
char __fastcall sub_3EBDC(int a1, int a2);
size_t __fastcall sub_3EFE0(int a1);
__int16 __fastcall sub_3F060(unsigned __int8 *a1, _DWORD *a2, int a3, unsigned __int8 a4);
unsigned int __fastcall sub_3F324(int a1, char a2, char a3, char a4, int a5, char a6, _DWORD *a7, unsigned __int8 a8);
unsigned int __fastcall sub_3F3F8(unsigned __int8 *a1, char a2, char a3, char a4, char a5, char a6, _DWORD *a7, unsigned __int8 a8);
unsigned int __fastcall sub_3F784(int a1, char a2, char a3, char a4, char a5, char a6, _DWORD *a7, unsigned __int8 a8);
unsigned int __fastcall sub_3FBAC(int a1, char a2, char a3, char a4, char a5, char a6, _DWORD *a7, unsigned __int8 a8);
int __fastcall sub_40084(int a1, _DWORD *a2, int a3, char a4);
char *__fastcall sub_40144(unsigned __int8 *a1, int a2);
int __fastcall compar(const void *, const void *); // idb
size_t __fastcall sub_40224(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_402E0(_BYTE *a1);
int __fastcall sub_403C0(unsigned __int8 *a1, int a2);
int __fastcall sub_40590(_BYTE *a1);
unsigned int __fastcall sub_405F4(_BYTE *a1);
int __fastcall sub_40664(_BYTE *a1);
int __fastcall sub_406C4(unsigned __int8 *a1, __int16 *a2, int a3);
// int __userpurge sub_41268@<eax>(unsigned __int8 *a1@<eax>, __int16 a2@<dx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6, __int16 a7, int a8, int a9, int a10, int a11, int a12);
unsigned int __fastcall sub_43184(int a1, int a2, int a3);
char __fastcall sub_43374(unsigned __int8 *a1, int a2);
unsigned int __fastcall sub_433E0(int a1, __int16 a2, int a3);
int __fastcall sub_434E4(char *a1, int a2);
int __fastcall sub_43B7C(int a1, __int16 a2);
__int64 __fastcall sub_43BDC(int a1, unsigned int a2, int a3);
int __fastcall sub_43C80(int a1, int a2, int a3, int a4);
unsigned int __fastcall sub_44024(_BYTE *a1, char a2);
char *__fastcall sub_44080(unsigned __int8 *a1);
int __fastcall sub_44238(int a1, __int16 a2, _BYTE *a3, __int16 a4);
char __fastcall sub_44434(unsigned __int8 *a1, __int16 a2, _DWORD *a3);
int __fastcall sub_44A2C(_BYTE *a1, int a2, char a3, _BYTE *a4);
char __fastcall sub_44BCC(int a1, __int16 *a2, char a3, int a4, int *a5);
char __fastcall sub_450B0(unsigned __int8 *a1, __int16 a2, char a3, char a4, int a5, int a6);
// int __usercall sub_45848@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>, int a3@<ebx>, __int16 *a4@<edi>);
int __fastcall sub_45958(unsigned __int8 *a1, char a2, __int16 *a3, _DWORD *a4);
int __fastcall sub_45A0C(_BYTE *a1, int a2, int a3, __int16 a4);
unsigned int __fastcall sub_45A54(unsigned __int8 *a1, int a2, int a3);
unsigned int __fastcall sub_45D50(unsigned __int8 *a1, int a2, int a3);
unsigned int __fastcall sub_45E64(_BYTE *a1, __int16 a2);
void __fastcall sub_45F60(_BYTE *a1, __int16 a2, int a3);
unsigned int __fastcall sub_46034(_BYTE *a1, __int16 a2);
void __fastcall sub_46130(_BYTE *a1, __int16 a2, int a3);
unsigned int __fastcall sub_46208(_BYTE *a1, __int16 a2);
int __fastcall sub_46304(_BYTE *a1, __int16 a2, int a3);
_WORD *sub_46470();
_WORD *__fastcall sub_46480(int a1, const char *a2);
int __fastcall sub_466FC(unsigned int a1);
unsigned int __fastcall sub_468BC(unsigned int result);
unsigned int __fastcall sub_46900(char *a1, char a2);
unsigned int __fastcall sub_4694C(int a1, unsigned __int16 a2, __int16 a3);
int __fastcall sub_469F0(int a1, unsigned __int16 a2);
__int16 __fastcall sub_46A94(unsigned __int16 *a1, unsigned __int16 a2, int a3);
int __fastcall sub_46BB0(_WORD *a1, unsigned int count, int a3);
int __fastcall sub_46C10(int);
int __fastcall sub_46C20(int a1, int a2, int a3);
void *__fastcall sub_46C48(int a1, char a2);
int __fastcall sub_46CAC(int a1, int a2, int a3, int a4);
int __fastcall sub_47088(int a1);
unsigned int __fastcall sub_47224(int a1, unsigned __int16 a2, int a3, unsigned int a4);
int __fastcall sub_47A64(const void *, const void *); // idb
__int16 __fastcall sub_47ABC(int);
int __fastcall sub_48B14(int a1, unsigned int count, int a3);
int __fastcall sub_48B40(T_TypeA2 *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_48B90(_DWORD *a1);
int __cdecl sub_48C58(_DWORD); // weak
int __fastcall sub_48C5C(int a1, char a2);
FILE *sub_48C84();
int __fastcall sub_48EAC(int result);
int __fastcall sub_49148(int a1, char a2);
unsigned int __fastcall sub_492AC(_DWORD *a1, char a2, int a3);
unsigned int __fastcall sub_492F8(_DWORD *a1, int a2);
unsigned int __fastcall sub_49328(int a1, char a2);
unsigned int __fastcall sub_4937C(int a1, char a2);
void __fastcall sub_493BC(int a1, char a2);
int __fastcall sub_49494(int a1, float *a2);
unsigned int __fastcall sub_4960C(int a1, int a2);
unsigned int __fastcall sub_49648(int a1, __int16 **a2);
int __fastcall sub_496BC(int a1, _DWORD *a2);
void __fastcall sub_496E0(_DWORD *a1);
int __fastcall sub_49828(int a1);
__int16 __fastcall sub_49940(int a1);
int __fastcall sub_49A40(int a1, int a2);
char *__fastcall sub_49A8C(int a1, char *a2);
int __fastcall sub_49B3C(int a1, int a2);
int __fastcall sub_49B68(int a1, int a2);
int __fastcall sub_49CC4(int a1, int a2);
int __fastcall sub_4A0D0(int a1, int a2);
int __fastcall sub_4A144(int a1);
int __fastcall sub_4A18C(int a1);
int __fastcall sub_4A1CC(int a1, __int16 a2);
char __fastcall sub_4A36C(int a1, char a2, __int16 a3);
int __fastcall sub_4A404(int a1, char a2);
_BYTE *__fastcall sub_4A480(int a1, unsigned __int16 a2, int a3);
unsigned int __fastcall sub_4A534(int a1, char a2);
unsigned int __fastcall sub_4A564(int a1);
int __fastcall sub_4A5B8(int result);
int __fastcall sub_4A6AC(int a1, int a2, int a3, int a4);
int __fastcall __spoils<> sub_4A8CC(int a1);
int __fastcall sub_4A8FC(int a1);
int __fastcall sub_4A988(int a1);
int __fastcall sub_4AA78(int a1, int a2);
int __fastcall sub_4AAEC(int a1, int a2);
__int64 __fastcall sub_4AE8C(int a1, unsigned int a2, int a3);
int __fastcall sub_4B5C0(int result, int a2);
int __fastcall sub_4B5E0(_DWORD *a1, int a2);
int __fastcall sub_4B780(int result, int a2);
int __fastcall sub_4B7A0(int a1, int a2, int a3, __int16 a4);
int __fastcall sub_4B944(int a1, int a2);
int __fastcall sub_4C7FC(int a1, int a2);
int __fastcall sub_4CAB8(int a1, int a2);
int __fastcall sub_4CDF8(int a1, int a2);
_DWORD *sub_4D700();
int __fastcall sub_4D724(T_Type5 *a1, int a2, int a3, int a4);
unsigned int __fastcall sub_4D7A8(int a1, int a2, int a3);
char *__fastcall sub_4D92C(int a1);
void *__fastcall sub_4DA08(int a1, char a2, int a3, int a4);
int __fastcall sub_4DA5C(int result);
int __fastcall sub_4DA7C(int a1, int a2, int a3, int a4);
char __fastcall sub_4DD14(int a1);
unsigned int __fastcall sub_4DDB0(int a1, __int16 a2, int a3, int a4);
int __fastcall sub_4E644(int result, char a2, int a3, int a4);
unsigned int __fastcall sub_4E69C(int a1);
void __fastcall sub_4E758(_DWORD *a1);
int __fastcall sub_4EE00(int a1);
char *sub_4EE50();
char *__fastcall sub_4EE74(int a1);
int __fastcall sub_4EF94(int a1);
LONG __fastcall Q_StartSoundSystem_sub_4EFB0(int a1, int aDIG, int aMID);
HMDIDRIVER __fastcall sub_4F088(char *path, char *a2, char *a3, char *a4);
int __fastcall sub_4F184(int, int);
void __fastcall sub_4F32C(int a1, __int16 a2, int a3);
void __fastcall sub_4F45C(int a1, __int16 a2);
void __fastcall sub_4F4D4(int a1, __int16 a2);
HDIGDRIVER __fastcall sub_4F534(_DWORD *a1, char *a2, char *a3);
int __fastcall sub_4F5E8(int, int);
int __fastcall sub_4F65C(int, const char *);
unsigned int __fastcall sub_4F8CC(int a1, __int16 a2, int a3);
int __fastcall sub_4FA1C(int result);
void __fastcall sub_4FAB4(int a1);
int __fastcall sub_4FB90(int result, __int16 a2);
void __fastcall sub_4FE8C(int result);
void __fastcall __spoils<> sub_4FF08(int a1);
void __fastcall __spoils<> sub_4FF1C(int result);
void __fastcall __spoils<> sub_4FF28(int result);
void __fastcall sub_4FF4C(int a1, char a2);
int __fastcall sub_4FF94(_DWORD *a1);
int __fastcall sub_50140(int a1, __int16 a2);
unsigned __int16 __fastcall sub_50530(T_Type5 *a1, int a2, int a3, int a4);
unsigned int __fastcall sub_50D70(_DWORD *, int, int, int);
unsigned int __fastcall sub_51610(T_Type5 *a1, int a2, int a3, int a4);
T_TypeA2 *__fastcall sub_51674(T_TypeA2 *a1);
int __fastcall sub_51690(int a1, char a2);
int __fastcall sub_516D4(int result);
void __fastcall sub_516E0(_DWORD *a1);
unsigned int __fastcall sub_51894(int a1, __int16 a2, __int16 a3, int a4);
T_TypeA2 *__fastcall sub_51B64(T_TypeA2 *a1);
int __fastcall sub_51B80(int a1, char a2);
void __fastcall sub_51BC4(_DWORD *a1);
unsigned int __fastcall sub_51D24(int a1, __int16 a2, int a3, int a4);
T_TypeA2 *__fastcall sub_520EC(T_TypeA2 *a1);
int __fastcall sub_52108(int a1, char a2);
int __fastcall sub_5214C(int result);
int __fastcall sub_52174(int a1);
void __fastcall sub_521C0(int a1, int edx0);
unsigned int sub_526D8();
int __fastcall sub_52714(int a1);
unsigned int __fastcall sub_5294C(int a1, __int16 dx0, int a3, int a4);
void __fastcall sub_53000(float *a1);
void __fastcall sub_53054(float *a1, float a2);
unsigned int __fastcall sub_53078(_DWORD *a1);
double __fastcall sub_5309C(float *, float *);
float *__fastcall sub_53114(float *result, float *a2);
int __fastcall sub_5323C(int result, float);
float *__fastcall sub_532AC(float *result, float a2);
float *__fastcall sub_53318(float *result, float a2);
float *__fastcall sub_53384(float *result, float *a2, float *a3);
int __fastcall sub_533D4(float *a1, float a2, int a3, int a4, int a5, int a6);
int __fastcall sub_53440(float *a1);
void __fastcall sub_5353C(float *a1, int a2, int a3, int a4, int a5);
void __fastcall sub_53564(float *a1, int a2, int a3, int a4, int a5);
void __fastcall sub_5358C(float *a1, int a2, int a3, int a4, int a5);
void __fastcall sub_535B4(float *a1, int a2, int a3, int a4, int a5);
void __fastcall sub_535E4(float *a1, int a2, int a3, int a4, int a5);
void __fastcall sub_53644(float *a1, int a2, int a3, int a4);
void __fastcall sub_53754(float *a1, int a2, int a3, int a4);
void __fastcall sub_53864(float *a1, int a2, int a3, int a4);
float *__fastcall sub_53B08(float *result, float *a2, float *a3, float *a4);
// __int16 __usercall sub_53D22@<ax>(char _CF@<cf>, bool _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<edx>, __int16 a6);
int __fastcall sub_53DC0(int a1, int a2, int a3);
void sub_53DE4();
int Q_CheckFreeMemory_sub_53DEC();
unsigned int __fastcall sub_53E38(P_Type5 a1, int a2, int a3, __int16 a4);
unsigned int __fastcall sub_53EB8(P_Type5 a1, int a2, int a3, int a4, int a5, __int16 a6);
unsigned int __fastcall sub_53F40(T_Type5 *a1, int a2, int a3, int a4, int a5, char a6);
T_Type1 *__fastcall sub_53FB0(const char *a1, int a2, int a3, int a4);
void __fastcall sub_54048(const char *, int, int, int);
unsigned int __fastcall sub_54208(int a1, int a2, int a3, int a4);
unsigned int __fastcall sub_542B0(_DWORD *a1, int a2, int a3, int *a4);
int __fastcall sub_54344(int a1, int a2, int a3);
char *__fastcall sub_54374(int a1);
void *__fastcall sub_54448(int a1);
unsigned int __fastcall sub_545EC(P_Type3 a1);
void __fastcall sub_54664(int a1);
int __fastcall sub_5469C(P_Type3 a1, int a2, int a3, int a4);
unsigned int __fastcall sub_54D64(int a1, int a2, int a3);
unsigned int __fastcall sub_5508C(P_Type3 a1);
void __fastcall sub_55214(int eax0, int a2, int a3, int a4, int a5);
void __fastcall sub_55274(P_Type3 a1, int x1, int y1, int x2, int y2);
void __fastcall sub_552CC(P_Type3 a1, P_Type5 a2);
int __fastcall sub_552F8(unsigned int a1, int a2, int a3);
unsigned int __fastcall sub_55618(unsigned int result, const char *a2);
int __fastcall sub_556CC(int, int);
const char *__fastcall sub_557D4(T_Type3 *eax0, char *s2, const char *a3, __int16 a4);
unsigned int __fastcall sub_55AEC(int a1, __int16 a2, int a3, int a4);
char __fastcall sub_55B74(int a1);
__int16 __fastcall sub_55E80(int a1);
void __fastcall sub_56400(T_Type3 *, int, __int16, int, int, int);
void __fastcall sub_564C0(T_Type3 *, int, __int16);
int __fastcall sub_56528(int a1, int a2, __int16 a3);
unsigned int __fastcall sub_56564(int a1, int a2, __int16 a3, int a4);
int __fastcall sub_56694(int a1);
void __fastcall sub_56728(int a1, int a2, int a3, __int16 a4, int a5, int a6);
void __fastcall sub_567BC(int a1, int a2, __int16 a3);
void __fastcall sub_56824(int a1);
int __fastcall sub_5691C(int result);
int __fastcall sub_56B60(int a1, __int16 a2, int a3, int a4);
int __fastcall sub_56BE8(int result, __int16 a2, int a3, int a4, int a5);
int __fastcall sub_56D30(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_56D70(int a1, char *a2, __int16 a3, int a4, int a5);
int __fastcall sub_56DA8(int, char *s1, _WORD *);
int __fastcall sub_56E18(int a1, char *s1, __int16 a3, _WORD *a4);
P_Type3 __fastcall sub_56E9C(P_Type3 a1, __int16 a2, int a3);
int __fastcall sub_570AC(int a1, int a2);
int __fastcall sub_571B8(P_Type3 a1, P_TypeA1 a2);
unsigned int __fastcall sub_57220(int a1, int a2, __int16 a3);
unsigned int __fastcall sub_57310(int a1, int a2, __int16 a3, int a4);
unsigned int __fastcall sub_5748C(int a1, __int16 a2, __int16 a3);
int __fastcall sub_574F0(P_Type3 a1, __int16 a2, int a3);
int __fastcall sub_57510(int a1, __int16 a2, int a3);
int __fastcall sub_57530(int result, int a2, int a3);
FILE *__fastcall sub_575BC(P_Type3);
FILE *__fastcall Q_WINMGR_CPP_sub_57670(P_Type3 a1, const char *a2);
T_Type1 *__fastcall sub_59828(int a1, int a2, int a3, int a4);
void __fastcall sub_5989C(P_Type3 a1, int a2, int a3, int a4);
int __fastcall sub_59908(int result);
void __fastcall sub_59934(T_Type3 *a1, int a2, int a3);
unsigned int __fastcall sub_59988(P_Type3 a1, char *a2, int a3);
int __fastcall sub_59A54(int result);
void __fastcall sub_59B80(int a1);
void __fastcall sub_59C80(T_Type3 *, int, __int16, __int16, int, int, int);
unsigned int __fastcall sub_59CFC(int a1, const char *a2);
void __fastcall sub_59DE0(int, int, int, int);
char *__fastcall sub_59E88(T_Type3 *a1, char *a2, char *filename);
void __fastcall Q_WINMGR_CPP_sub_5A094(T_Type3 *a1, void *aData, int a3, char *a4);
void __fastcall Q_WINMGR_CPP_sub_5A144(P_Type3 a1, void *a2);
char *__fastcall sub_5A194(int a1, int a2, _DWORD *a3, _DWORD *a4);
void __fastcall sub_5A270(T_Type3 *a1, int a2, int a3, int a4);
void __fastcall sub_5A294(_DWORD *a1);
unsigned int __fastcall sub_5A320(__int16 a1);
int __fastcall sub_5A47C(T_Type5 *a1, const char *a2, int a3, int a4);
unsigned int __fastcall sub_5A4E4(_DWORD *a1, int a2, int a3, int a4);
T_TypeA2 *__fastcall sub_5A594(T_TypeA2 *result);
int __fastcall sub_5A5AC(int a1, char a2);
int __fastcall sub_5A5F4(T_TypeA1 *a1);
unsigned int __fastcall sub_5A60C(int a1, __int16 a2, __int16 a3, int a4);
void __fastcall sub_5AA08(int a1);
int __fastcall sub_5AB04(const char **a1, const char **a2);
void __fastcall sub_5AB2C(int a1, int a2);
int __fastcall sub_5AE68(int a1, int a2);
unsigned int __fastcall sub_5AF30(int a1, int a2);
int __fastcall sub_5B200(int a1, int a2);
int __fastcall sub_5B244(int result, int a2);
int __fastcall sub_5B2B0(int a1, char a2);
T_TypeA2 *__fastcall sub_5B2F0(T_TypeA2 *result);
int __fastcall sub_5B300(int a1, char a2);
T_TypeA2 *__fastcall sub_5B340(T_TypeA2 *result);
BOOL __fastcall sub_5B50C(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_5B617(size_t a1);
unsigned int __fastcall sub_5B71C(int);
unsigned int __fastcall sub_5B7C2(_DWORD *a1, int a2, int x1, int y1, int x2, int y2);
unsigned int __fastcall sub_5BA38(_DWORD *a1);
int __fastcall sub_5BAC0(_DWORD *a1, int a2);
char *__fastcall sub_5BBE4(void **, char *, int);
void __fastcall sub_5BDDC(void *);
const char *__cdecl sub_5BE08(int (**)(void));
LONG __cdecl VFX_register_driver(void *DLLbase);
unsigned int __cdecl sub_5BE50(int **a1, int a2, int a3, char a4);
unsigned int __cdecl sub_5BF2B(int **a1, int a2, int a3);
unsigned int __cdecl sub_5C001(int **, int, int, int, int, int, void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD));
unsigned int __cdecl sub_5CB3C(P_Type5 a1, int a2, int a3, int a4, int a5);
int __cdecl sub_5CF40(P_Type5 a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_5D007(const void *a1);
unsigned int __cdecl sub_5D026(P_Type5 a1, int a2, int a3, int a4, int a5);
int __cdecl sub_5D4FE(P_Type5 a1, _DWORD *a2, int a3, int a4);
int *__cdecl sub_5D631(P_Type5 a1, int a2, int a3, int a4, int a5, int a6, int a7, void (__noreturn *a8)(), void (__noreturn *a9)(), char a10);
int __cdecl sub_5E1DD(int a1, int a2, int a3, int a4, char a5, int *a6);
void __cdecl sub_5E66A(int a1, char a2, int a3);
void __cdecl __spoils<edx> sub_5E7F3(int a1, int a2, int a3);
unsigned int __cdecl sub_5E9D0(P_Type5 a1, char a2);
unsigned int __cdecl sub_5EAAF(int **a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7);
unsigned int __cdecl sub_5F048(int a1, int a2, int a3, int a4, int a5, void (__fastcall *a6)(_DWORD, _DWORD, _DWORD, _DWORD));
unsigned int __cdecl sub_5F389(int a1, int a2, int a3, int a4, int a5, void (__fastcall *a6)(_DWORD, _DWORD, _DWORD, _DWORD));
int __cdecl sub_6049B(int a1, int *a2, int *a3);
int __cdecl sub_60579(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6);
int __cdecl sub_60640(int a1);
int __cdecl sub_60653(int a1, int a2);
unsigned int __cdecl sub_60673(_DWORD *a1, int a2, int a3, int a4, int a5, int a6);
unsigned int __cdecl sub_60806(_DWORD *a1, int a2, int a3, int a4, _BYTE *a5, int a6);
int __cdecl sub_6083D(PANE *a1, int a2, char *a3, int a4);
int __cdecl sub_60940(int a1, int a2);
_BYTE *__cdecl sub_6094C(_WORD *a1, int a2);
// int __usercall sub_60C87@<eax>(int a1@<ecx>, _DWORD *a2@<edi>);
// int __usercall sub_60CCF@<eax>(int a1@<edi>, unsigned __int8 *a2@<esi>);
// int __usercall sub_60CE8@<eax>(int a1@<edx>, int a2@<edi>, unsigned __int8 *a3@<esi>);
// int __usercall sub_60D2E@<eax>(int a1@<ecx>, _DWORD *a2@<edi>);
// int __usercall sub_60D74@<eax>(int result@<eax>, int@<edi>);
int __cdecl sub_60DF1(PANE *, int, int);
__int16 __cdecl sub_610E8(int a1, int a2);
__int16 __cdecl sub_6111C(int a1, int a2);
int __cdecl sub_61223(int a1);
void __cdecl sub_615ED(P_Type6 a1, int a2, unsigned int a3);
int __cdecl sub_61800(_DWORD *a1, int a2, int a3);
int __cdecl sub_62DA5(_DWORD *a1, int a2, int a3, int a4);
void sub_648EC();
void sub_64B6E();
int __fastcall sub_64BC4(int a1, int a2, int a3, int a4);
int sub_64C01();
int sub_64D00();
void sub_64D91();
void sub_64DAC();
void sub_64DC8();
void sub_64DE3();
int __fastcall sub_64DFF(_DWORD *);
BOOL __fastcall sub_64E59(_DWORD *);
void sub_64ECA();
void sub_64F06();
void __fastcall sub_64F39(int a1, int a2);
void __fastcall sub_64FFE(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
void __fastcall sub_6507C(int a1, int a2);
int (__cdecl *__fastcall sub_6515A(int (__cdecl *result)(_DWORD)))(_DWORD);
void callback_fn();
void __fastcall sub_65832(P_Type6 *a1, LONG a2, LONG a3, LONG a4, int y1);
unsigned int __fastcall sub_65E2B(_DWORD *a1);
int __fastcall sub_65EA4(int, int);
int sub_660FF();
void *__cdecl static DLL_read(ULONG src, ULONG srcoff, ULONG flags, void *dest, ULONG length);
void *__cdecl sub_661DE(size_t size);
int __cdecl sub_661FF(void *ptr);
int __cdecl sub_66220(unsigned int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_662A5(int a1, int a2, unsigned __int16 a3);
BOOL __cdecl sub_662D1(unsigned int a1, unsigned int a2);
void sub_6633A();
BOOL __cdecl sub_6635F(unsigned int a1, int a2);
void sub_66376();
ULONG __cdecl DLL_size(void *source, ULONG flags);
void *__cdecl DLL_load(void *source, ULONG flags, void *dll);
int __cdecl sub_6694A(char *path); // idb
void *__cdecl sub_66996(char *path, int);
BOOL sub_66B05();
int sub_66BAD();
int sub_66C19();
void __cdecl AIL_startup();
void __cdecl AIL_shutdown();
LONG __cdecl AIL_set_preference(ULONG number, LONG value);
int __cdecl sub_66FC8();
int __fastcall sub_66FCD(int);
REALFAR __cdecl AIL_get_real_vect(ULONG vectnum);
void __cdecl AIL_set_real_vect(ULONG vectnum, REALFAR real_ptr);
void __cdecl AIL_set_USE16_ISR(LONG IRQ, REALFAR real_base, ULONG ISR_offset);
void __cdecl AIL_restore_USE16_ISR(LONG IRQ);
unsigned int sub_67234();
void __cdecl sub_67239(unsigned int a1);
LONG __cdecl AIL_call_driver(AIL_DRIVER *drvr, LONG fn, VDI_CALL *in, VDI_CALL *out);
void __cdecl AIL_delay(LONG intervals);
int sub_673CA(void); // weak
LONG __cdecl AIL_read_INI(AIL_INI *INI, BYTE *filename);
HTIMER __cdecl AIL_register_timer(CALLBACK callback_fn);
ULONG __cdecl AIL_set_timer_user(HTIMER timer, ULONG user);
void __cdecl AIL_set_timer_period(HTIMER timer, ULONG microseconds);
void __cdecl AIL_set_timer_frequency(HTIMER timer, ULONG hertz);
void __cdecl AIL_set_timer_divisor(HTIMER timer, ULONG PIT_divisor);
ULONG __cdecl AIL_interrupt_divisor();
void __cdecl AIL_start_timer(HTIMER timer);
void __cdecl AIL_start_all_timers();
void __cdecl AIL_stop_timer(HTIMER timer);
void __cdecl AIL_stop_all_timers();
void __cdecl AIL_release_timer_handle(HTIMER timer);
void __cdecl AIL_release_all_timers();
IO_PARMS *__cdecl AIL_get_IO_environment(AIL_DRIVER *drvr);
AIL_DRIVER *__cdecl AIL_install_driver(UBYTE *driver_image, ULONG n_bytes);
void __cdecl AIL_uninstall_driver(AIL_DRIVER *drvr);
LONG __cdecl AIL_install_DIG_INI();
HDIGDRIVER __cdecl AIL_install_DIG_driver_file(BYTE *filename, IO_PARMS *IO);
void __cdecl AIL_uninstall_DIG_driver(HDIGDRIVER dig);
HSAMPLE __cdecl AIL_allocate_sample_handle(HDIGDRIVER dig);
HSAMPLE __cdecl AIL_allocate_file_sample(HDIGDRIVER dig, void *file_image, LONG block);
void __cdecl AIL_release_sample_handle(HSAMPLE S);
void __cdecl AIL_init_sample(HSAMPLE S);
LONG __cdecl AIL_set_sample_file(HSAMPLE S, void *file_image, LONG block);
void __cdecl AIL_set_sample_address(HSAMPLE S, void *start, ULONG len);
void __cdecl AIL_set_sample_type(HSAMPLE S, LONG format, ULONG flags);
void __cdecl AIL_start_sample(HSAMPLE S);
void __cdecl AIL_stop_sample(HSAMPLE S);
void __cdecl AIL_resume_sample(HSAMPLE S);
void __cdecl AIL_end_sample(HSAMPLE S);
void __cdecl AIL_set_sample_playback_rate(HSAMPLE S, LONG playback_rate);
void __cdecl AIL_set_sample_volume(HSAMPLE S, LONG volume);
void __cdecl AIL_set_sample_pan(HSAMPLE S, LONG pan);
void __cdecl AIL_set_sample_loop_count(HSAMPLE S, LONG loop_count);
ULONG __cdecl AIL_sample_status(HSAMPLE S);
LONG __cdecl AIL_sample_playback_rate(HSAMPLE S);
LONG __cdecl AIL_sample_volume(HSAMPLE S);
LONG __cdecl AIL_sample_pan(HSAMPLE S);
LONG __cdecl AIL_sample_loop_count(HSAMPLE S);
HDIGDRIVER __cdecl AIL_install_DIG_driver_image(void *driver_image, ULONG size, IO_PARMS *IO);
LONG __cdecl AIL_minimum_sample_buffer_size(HDIGDRIVER dig, LONG playback_rate, LONG format);
LONG __cdecl AIL_sample_buffer_ready(HSAMPLE S);
void __cdecl AIL_load_sample_buffer(HSAMPLE S, ULONG buff_num, void *buffer, ULONG len);
void __cdecl AIL_set_sample_position(HSAMPLE S, ULONG pos);
ULONG __cdecl AIL_sample_position(HSAMPLE S);
CALLBACK __cdecl AIL_register_SOB_callback(HSAMPLE S, CALLBACK SOB);
CALLBACK __cdecl AIL_register_EOB_callback(HSAMPLE S, CALLBACK EOB);
CALLBACK __cdecl AIL_register_EOS_callback(HSAMPLE S, CALLBACK EOS);
CALLBACK __cdecl AIL_register_EOF_callback(HSAMPLE S, CALLBACK EOFILE);
void __cdecl AIL_set_sample_user_data(HSAMPLE S, ULONG index, LONG value);
LONG __cdecl AIL_sample_user_data(HSAMPLE S, ULONG index);
LONG __cdecl AIL_active_sample_count(HDIGDRIVER dig);
LONG __cdecl AIL_install_MDI_INI();
HMDIDRIVER __cdecl AIL_install_MDI_driver_file(BYTE *filename, IO_PARMS *IO);
void __cdecl AIL_uninstall_MDI_driver(HMDIDRIVER mdi);
HSEQUENCE __cdecl AIL_allocate_sequence_handle(HMDIDRIVER mdi);
void __cdecl AIL_release_sequence_handle(HSEQUENCE S);
LONG __cdecl AIL_init_sequence(HSEQUENCE S, void *start, LONG sequence_num);
void __cdecl AIL_start_sequence(HSEQUENCE S);
void __cdecl AIL_stop_sequence(HSEQUENCE S);
void __cdecl AIL_resume_sequence(HSEQUENCE S);
void __cdecl AIL_end_sequence(HSEQUENCE S);
void __cdecl AIL_set_sequence_tempo(HSEQUENCE S, LONG tempo, LONG milliseconds);
void __cdecl AIL_set_sequence_volume(HSEQUENCE S, LONG volume, LONG milliseconds);
void __cdecl AIL_set_sequence_loop_count(HSEQUENCE S, LONG loop_count);
ULONG __cdecl AIL_sequence_status(HSEQUENCE S);
LONG __cdecl AIL_sequence_tempo(HSEQUENCE S);
LONG __cdecl AIL_sequence_volume(HSEQUENCE S);
LONG __cdecl AIL_sequence_loop_count(HSEQUENCE S);
HMDIDRIVER __cdecl AIL_install_MDI_driver_image(void *driver_image, ULONG size, IO_PARMS *IO);
void __cdecl AIL_set_GTL_filename_prefix(BYTE *prefix);
LONG __cdecl AIL_timbre_status(HMDIDRIVER mdi, LONG bank, LONG patch);
LONG __cdecl AIL_install_timbre(HMDIDRIVER mdi, LONG bank, LONG patch);
void __cdecl AIL_protect_timbre(HMDIDRIVER mdi, LONG bank, LONG patch);
void __cdecl AIL_unprotect_timbre(HMDIDRIVER mdi, LONG bank, LONG patch);
LONG __cdecl AIL_active_sequence_count(HMDIDRIVER mdi);
LONG __cdecl AIL_controller_value(HSEQUENCE S, LONG channel, LONG controller_num);
LONG __cdecl AIL_channel_notes(HSEQUENCE S, LONG channel);
void __cdecl AIL_sequence_position(HSEQUENCE S, LONG *beat, LONG *measure);
void __cdecl AIL_branch_index(HSEQUENCE S, ULONG marker);
CALLBACK __cdecl AIL_register_prefix_callback(HSEQUENCE S, CALLBACK callback);
CALLBACK __cdecl AIL_register_trigger_callback(HSEQUENCE S, CALLBACK callback);
CALLBACK __cdecl AIL_register_sequence_callback(HSEQUENCE S, CALLBACK callback);
CALLBACK __cdecl AIL_register_event_callback(HMDIDRIVER mdi, CALLBACK callback);
CALLBACK __cdecl AIL_register_timbre_callback(HMDIDRIVER mdi, CALLBACK callback);
void __cdecl AIL_set_sequence_user_data(HSEQUENCE S, ULONG index, LONG value);
LONG __cdecl AIL_sequence_user_data(HSEQUENCE S, ULONG index);
void __cdecl AIL_register_ICA_array(HSEQUENCE S, BYTE *array);
LONG __cdecl AIL_lock_channel(HMDIDRIVER mdi);
void __cdecl AIL_release_channel(HMDIDRIVER mdi, LONG channel);
void __cdecl AIL_map_sequence_channel(HSEQUENCE S, LONG seq_channel, LONG new_channel);
LONG __cdecl AIL_true_sequence_channel(HSEQUENCE S, LONG seq_channel);
void __cdecl AIL_send_channel_voice_message(HMDIDRIVER mdi, HSEQUENCE S, LONG status, LONG data_1, LONG data_2);
void __cdecl AIL_send_sysex_message(HMDIDRIVER mdi, void *buffer);
HWAVE __cdecl AIL_create_wave_synthesizer(HDIGDRIVER dig, HMDIDRIVER mdi, void *wave_lib, LONG polyphony);
void __cdecl AIL_destroy_wave_synthesizer(HWAVE W);
void sub_6B984();
BOOL sub_6BBAE();
_DWORD *__cdecl sub_6BBDA(int a1, char a2, unsigned int a3, unsigned __int8 a4);
_DWORD *__fastcall sub_6BD8F(_DWORD *result, int a2, int a3);
void __fastcall sub_6BDB8(int a1, int a2);
void __fastcall sub_6BE24(int a1, int a2);
int sub_6BF2E(); // weak
int sub_6BF53(); // weak
_DWORD *__cdecl sub_6C347(int a1, HMDIDRIVER mdi, int a3, int a4);
int __cdecl sub_6C4BF(void *ptr); // idb
void sub_6C513();
BOOL sub_6C53D();
int __cdecl sub_6C569(_DWORD *a1);
void __cdecl sub_6C573(HSAMPLE S);
void __cdecl sub_6C5D1(HSAMPLE S, int a2);
void __cdecl sub_6C83E(SAMPLE *a1);
void __cdecl sub_6C84E(int a1, HSAMPLE S);
SAMPLE *__cdecl sub_6C938(int dig, char *s1, int a3);
int __cdecl sub_6CA63(int, char *s1, int); // idb
int __cdecl sub_6CB3B(int a1, int a2);
void sub_6CB57();
BOOL sub_6CB90();
int *__cdecl sub_6CCD0(int a1);
void __cdecl sub_6CF50(int a1);
// int __usercall sub_6D140@<eax>(int a1@<edi>, int a2);
LONG __cdecl sub_6D5C0(AIL_DRIVER **a1, const void *a2);
int __cdecl sub_6D6C0(AIL_DRIVER **ptr);
AIL_DRIVER **__cdecl sub_6D770(AIL_DRIVER *drvr, const void *);
UBYTE *__cdecl sub_6DD80(char *path, int);
AIL_DRIVER *__cdecl sub_6DE00(void *s2, size_t n, int);
HDIGDRIVER sub_6DE40();
void __cdecl sub_6DEA0(AIL_DRIVER **a1);
int __cdecl sub_6DEB0(int a1);
SAMPLE *__cdecl sub_6DEE0(int a1);
int __cdecl sub_6DF50(int a1);
int *__cdecl sub_6DF60(int *a1);
int __cdecl sub_6E010(int a1);
_DWORD *__cdecl sub_6E020(_DWORD *a1, int a2, int a3);
int *__cdecl sub_6E050(int a1, int a2, int a3);
int __cdecl sub_6E080(int a1);
int __cdecl sub_6E090(int a1, int a2);
int __cdecl sub_6E0A0(int a1);
int *__cdecl sub_6E0B0(int a1, int a2);
int __cdecl sub_6E0D0(int a1);
int *__cdecl sub_6E0E0(int a1, int a2);
int __cdecl sub_6E100(int a1);
int __cdecl sub_6E120(int a1, int a2);
unsigned int __cdecl sub_6E140(int a1);
int __cdecl sub_6E160(int a1, int a2);
void __cdecl sub_6E170(_DWORD *a1);
int __cdecl sub_6E1F0(int a1);
int __cdecl sub_6E210(int a1);
int __cdecl sub_6E230(int a1);
int __cdecl sub_6E280(int a1, int a2);
int __cdecl sub_6E2A0(int a1, int a2);
int __cdecl sub_6E2C0(int a1, int a2);
int __cdecl sub_6E2E0(int a1, int a2, int a3);
int __cdecl sub_6E300(int a1, int a2);
// int __usercall sub_6E330@<eax>(int a1@<edx>, _DWORD *a2, int a3, int a4);
_DWORD *__cdecl sub_6E3D0(_DWORD *, int, int, int);
char __cdecl sub_6E460(_DWORD *a1);
void sub_6E4C0();
BOOL sub_6E580();
LONG __cdecl sub_6E6E0(int a1);
int __cdecl sub_6E730(int a1, char a2, char a3, char a4);
int __cdecl sub_6E910(_DWORD *a1);
int __cdecl sub_6E980(int a1, int a2);
int __cdecl sub_6EAA0(int a1, char a2, unsigned int a3);
unsigned int __cdecl sub_6EC20(int a1, char a2, unsigned int a3, unsigned __int8 a4);
void __cdecl sub_6EDE0(HSEQUENCE S, char a2, unsigned int a3, ULONG marker, int a5);
void __cdecl sub_6F230(SEQUENCE *a1);
LONG __cdecl sub_6F300(SEQUENCE *a1, int a2);
void __cdecl sub_6F3B0(SEQUENCE *a1, int a2);
_DWORD *__cdecl sub_6F5C0(_DWORD *a1);
void __cdecl sub_6F690(SEQUENCE *a1);
HSEQUENCE __cdecl sub_6F6D0(int a1);
LONG __cdecl sub_6FE00(AIL_DRIVER **a1, const void *a2);
int __cdecl sub_6FED0(void *ptr);
_DWORD *__cdecl sub_6FF30(int, const void *);
UBYTE *__cdecl sub_705D0(char *path, int);
AIL_DRIVER *__cdecl sub_70650(void *s2, size_t n, int);
HMDIDRIVER sub_70690();
void __cdecl sub_706F0(AIL_DRIVER **a1);
int __cdecl sub_70700(char *a1);
_DWORD *__cdecl sub_70780(int a1);
void __cdecl sub_70800(HSEQUENCE S);
int __cdecl sub_70820(AIL_DRIVER ***a1, int a2, int a3);
UBYTE *__cdecl sub_70BD0(HSEQUENCE S);
void __cdecl sub_70C10(SEQUENCE *a1);
void __cdecl sub_70CE0(SEQUENCE *a1);
void __cdecl sub_70D70(HSEQUENCE S);
int __cdecl sub_70DA0(int a1, int a2);
int __cdecl sub_70DB0(_DWORD *a1, int a2, int a3);
struct _MDI_DRIVER *__cdecl sub_70E20(SEQUENCE *a1, LONG a2, int a3);
int __cdecl sub_70EA0(int a1);
unsigned int __cdecl sub_70EB0(int a1);
int __cdecl sub_70ED0(int a1);
int __cdecl sub_70EE0(int a1);
LONG __cdecl sub_70EF0(AIL_DRIVER **a1, __int16 a2, __int16 a3);
int __cdecl sub_70F30(int a1, int a2, int a3);
LONG __cdecl sub_71030(AIL_DRIVER **a1, __int16 a2, __int16 a3);
LONG __cdecl sub_71070(AIL_DRIVER **a1, __int16 a2, __int16 a3);
int __cdecl sub_710B0(int a1);
int __cdecl sub_710E0(int a1, char a2, unsigned int a3);
int __cdecl sub_71110(int a1, int a2);
void __cdecl sub_71150(_DWORD *a1, _DWORD *a2, int *a3);
void __cdecl sub_711C0(_DWORD *a1, int a2);
int __cdecl sub_71250(int a1, int a2);
int __cdecl sub_71270(int a1, int a2);
int __cdecl sub_71290(int a1, int a2);
int __cdecl sub_712B0(int a1, int a2);
int __cdecl sub_712D0(int a1, int a2);
int __cdecl sub_712F0(int a1, int a2, int a3);
int __cdecl sub_71310(int a1, int a2);
int __cdecl sub_71330(int a1, int a2);
unsigned int __cdecl sub_71340(_DWORD *a1);
_DWORD *__cdecl sub_714E0(_DWORD *a1, int a2);
_DWORD *__cdecl sub_71610(_DWORD *a1, int a2, int a3);
int __cdecl sub_71650(int a1, int a2);
void __cdecl sub_71670(int a1, SEQUENCE *a2, int a3, unsigned int a4, ULONG a5);
LONG __cdecl sub_71720(_DWORD *a1, void *a2);
void sub_717B0();
BOOL sub_718A4();
void __cdecl sub_7192D(AIL_DRIVER *drvr);
int __cdecl sub_7197C(char *s, int, int); // idb
int __cdecl sub_71A1D(int, char *filename); // idb
int __cdecl sub_71CE5(int a1, ULONG a2);
AIL_DRIVER *__cdecl sub_71CFE(void *s2, size_t n);
int __cdecl sub_71F2E(void *ptr); // idb
char *__cdecl sub_71FD1(int);
void __fastcall sub_72042(int a1, unsigned __int16 a2);
int sub_72148();
void sub_72175();
// int __usercall sub_725FC@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_7260D@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72619@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72638@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_7264C@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_7266B@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_7267F@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_7269C@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_726AE@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_726CB@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_726DD@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_726F1@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_72700@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_72716@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72727@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72748@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_7275E@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_7277F@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72795@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_727BA@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_727D4@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_727F9@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72813@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72836@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_7284E@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72871@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72889@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_728B0@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_728CC@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_728F3@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_7290F@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_7293C@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72964@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_729BD@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_72A0B@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// char __usercall sub_72A64@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72AB2@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72B09@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72B55@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72BAC@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72BF8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72C28@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_72C53@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_72C85@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72CB2@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72D0D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72D5D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72DB8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72E08@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_72E67@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72EBB@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// __int16 __usercall sub_72F1A@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>);
// int __usercall sub_72F6E@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_72FCB@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_7301D@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_7307A@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_730CC@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// __int16 __usercall sub_7312D@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_73183@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// __int16 __usercall sub_731E4@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>);
// int __usercall sub_7323A@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// int __usercall sub_7325B@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// int __usercall sub_7327F@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// int __usercall sub_732AB@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_732DD@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>);
// int __usercall sub_73309@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_7333B@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_7335F@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_73386@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_733B4@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_733E8@<ax>(_DWORD *a1@<edi>, unsigned int a2@<esi>);
// __int16 __usercall sub_73416@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>);
// __int16 __usercall sub_7344A@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// __int16 __usercall sub_73466@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// __int16 __usercall sub_73485@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>);
// __int16 __usercall sub_734A6@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_734CD@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, unsigned int a3@<esi>);
// __int16 __usercall sub_734EE@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_73515@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_73534@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_73556@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_73579@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// __int16 __usercall sub_735A2@<ax>(_DWORD *a1@<edi>, unsigned int a2@<esi>);
// __int16 __usercall sub_735C5@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>);
// int __usercall sub_735EE@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_7361A@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_73649@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// int __usercall sub_73683@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// int __usercall sub_736C3@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, unsigned int a4@<esi>);
// int __usercall sub_736FD@<eax>(int result@<eax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_7373D@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_7376F@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_737A4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_737E0@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_73822@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, unsigned int a3@<esi>);
// __int16 __usercall sub_7385E@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>);
// __int16 __usercall sub_738A0@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_738C7@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_738F1@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// __int16 __usercall sub_73920@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_73955@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, unsigned int a4@<esi>);
// __int16 __usercall sub_73984@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, __int16 a3@<bx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// __int16 __usercall sub_739B9@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_739E6@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_73A16@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_73A47@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// __int16 __usercall sub_73A7E@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, unsigned int a3@<esi>);
// __int16 __usercall sub_73AAF@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>);
// char __usercall sub_73AE6@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// char __usercall sub_73B02@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// char __usercall sub_73B28@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>);
// char __usercall sub_73B49@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_73B74@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>);
// char __usercall sub_73B95@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_73BC0@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>);
// char __usercall sub_73BDF@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>);
// char __usercall sub_73C08@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>);
// char __usercall sub_73C2A@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, unsigned int a5@<esi>);
// char __usercall sub_73C56@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>);
// char __usercall sub_73C78@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, unsigned int a5@<esi>);
// char __usercall sub_73CA4@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_73CCB@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_73CFC@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>);
// char __usercall sub_73D2B@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_73D64@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, unsigned int a5@<esi>);
// char __usercall sub_73D93@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, _BYTE *a6@<esi>);
// char __usercall sub_73DCC@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, unsigned int a5@<esi>);
// char __usercall sub_73DF9@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, unsigned int a5@<esi>);
// char __usercall sub_73E30@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, unsigned int a5@<esi>);
// char __usercall sub_73E60@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, unsigned int a6@<esi>);
// char __usercall sub_73E9A@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, unsigned int a5@<esi>);
// char __usercall sub_73ECA@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4@<ebx>, _DWORD *a5@<edi>, unsigned int a6@<esi>);
int __cdecl sub_73F04(int a1);
int __cdecl sub_74105(_DWORD *a1, int a2);
int __cdecl sub_74197(int a1);
BOOL sub_741C3();
void sub_741F4();
void sub_74201();
// int __usercall sub_7420E@<eax>(__int32 a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, __int32 a6@<edi>, __int32 a7@<esi>);
char __cdecl sub_74334(int a1);
char __cdecl sub_74364(unsigned int a1);
int sub_74397();
void __fastcall sub_743FC(int a1, unsigned __int16 a2);
int sub_744EA();
int __fastcall sub_74525(int a1, __int16 a2, int a3, int a4);
int sub_74551();
int __cdecl sub_745CD(int a1, int a2, __int16 a3);
int __cdecl sub_747E3(int a1);
void __cdecl sub_7482C(unsigned int a1);
int __cdecl sub_74893(int a1, __int16 a2, _WORD *a3, _WORD *a4);
unsigned __int8 __cdecl sub_7496D(int a1);
int __fastcall sub_749AA();
unsigned int __cdecl sub_749B6(int a1);
int __cdecl sub_749FD(int a1, __int32 a2);
int __cdecl sub_74A25(int);
int sub_74A4C();
int __cdecl sub_74A70(int a1);
int sub_74AA0();
int __cdecl sub_74AC4(int a1);
int sub_74AF4();
int __cdecl sub_74B18(int a1, int a2);
int __cdecl sub_74B48(HTIMER timer, unsigned int a2);
int __cdecl sub_74B78(HTIMER timer, unsigned int a2);
int sub_74BBA();
BOOL sub_74BC6();
int __fastcall sub_74BF0(FILE *a1);
__int16 __fastcall sub_74C28(unsigned __int16 *a1, _WORD *a2, unsigned int a3);
_WORD *__fastcall sub_74CBC(int a1, int a2, int a3, int a4);
int __fastcall sub_74E4C(int, int, int, int);
void __noreturn sub_74F2C(void); // weak
BOOL __fastcall sub_74FAC(char a1, int a2, int a3, int a4);
__int16 sub_7501C();
void __fastcall sub_75034(int a1);
// FILE *__usercall sub_75098@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, char *a5, int a6);
char *sub_75500();
void *sub_75508();
void *sub_75510();
char *sub_75518();
// int __usercall sub_75520@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);
void sub_756E9();
// void __usercall sub_75748(__int16 a1@<ax>, __int16 a2@<di>);
int sub_757C1();
int sub_75860(); // weak
void sub_758F4();
int __cdecl sub_759A8(int a1, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD));
__int32 sub_759D4();
int __cdecl sub_75A08(char a1, int a2);
__int32 __cdecl sub_75A44(char a1, int a2);
__int32 __cdecl sub_75A8C(char a1, int a2, __int16 a3);
int *__fastcall sub_75AC4(char a1, int a2, int *a3);
__int32 __fastcall sub_75AE8(char a1, int a2, int a3, int a4, int a5, __int16 a6, int a7);
__int32 __fastcall sub_75B18(char a1, int a2);
BOOL __cdecl sub_75E48(int a1, int a2);
BOOL __cdecl sub_75E9C(int a1, int a2);
BOOL __cdecl sub_75EF0(int a1, int a2);
char __cdecl sub_75F20(__int16 a1, int a2);
__int16 __cdecl sub_75F32(__int16 a1, int a2);
int __cdecl sub_75F45(__int16 a1, int a2);
__int16 __cdecl sub_75F6C(__int16 a1, int a2, __int16 a3);
__int16 __cdecl sub_75F98(_WORD *a1, __int16 a2, char *a3, unsigned int a4);
__int16 __cdecl sub_75FBE(__int16 a1, char *a2, _WORD *a3, unsigned int a4);
_WORD *__cdecl sub_75FE4(_WORD *a1);
__int32 __cdecl sub_76404(int a1);
__int32 __cdecl sub_7641A(int a1, _DWORD *a2, __int32 *a3, _WORD *a4);
void sub_764AD();
int sub_764C0();
int sub_76520();
int sub_7654C();
int sub_76578();
__int32 __cdecl sub_765A4(int a1, _DWORD *a2, __int32 *a3);
int *__cdecl sub_765D4(char a1, int *a2);
__int16 __cdecl sub_76618(char a1, int a2);
int __fastcall sub_76658(int a1, int a2);
BOOL __fastcall sub_766B8(__int16 a1, int a2);
int __fastcall sub_76700(__int16 a1);
BOOL __fastcall sub_76740(__int16 a1, int a2);
int __fastcall sub_76788(int a1, int a2);
unsigned int __fastcall sub_767D4(unsigned int a1, int a2);
__int32 __fastcall sub_76874(__int16 a1);
_DWORD *__cdecl sub_76A04(_DWORD *a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_76A40(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
__int32 __cdecl sub_76AAC(__int16 a1);
__int16 __cdecl sub_76AD8(char a1, unsigned __int16 *a2, _WORD *a3);
__int16 __cdecl sub_76BB0(char a1, unsigned __int16 *a2, _WORD *a3, __int16 *a4);
unsigned int __cdecl sub_76CB4(unsigned int a1, int a2);
// int sprintf(char *s, const char *format, ...);
// int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD); weak
// void __fastcall operator delete[](void *); weak
// void __fastcall operator delete(void *); weak
// int __fastcall strcmp(const char *s1, const char *s2);
// double __fastcall sqrt(double x);
// void _CHP();
// void *__fastcall memset(void *s, int c, size_t n);
// void __fastcall qsort(void *base, size_t nmemb, size_t size, int (__fastcall *compar)(const void *, const void *));
// int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD); weak
// int sscanf(const char *s, const char *format, ...);
// int __fastcall fclose(FILE *fp);
// double __fastcall cos(double x);
// double __fastcall sin(double x);
// double __fastcall tan(double x);
// void *__fastcall operator new[](size_t size);
// int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD); weak
// int __fastcall stricmp(const char *s1, const char *s2);
// FILE *__fastcall fdopen(int handle, const char *mode);
// int __fastcall fgetpos(FILE *fp, fpos_t *pos);
// char *__fastcall strncpy(char *s1, const char *s2, size_t n);
// int __fastcall filelength(int handle);
// int open(const char *path, int oflag, ...);
// int __fastcall lseek(int handle, int offset, int origin);
// int __fastcall close(int handle);
// int __fastcall tell(int handle);
// volatile int *__fastcall _get_errno_ptr();
// int __fastcall read(int handle, void *buf, unsigned int len);
// unsigned int __fastcall dos_write(int handle, const void far *buf, unsigned int count, unsigned int *bytes);
// void __fastcall _assert(int, char *, char *, int);
// int __fastcall write(int handle, const void *buf, unsigned int len);
// FILE *__fastcall fopen(const char *filename, const char *mode);
// int fscanf(FILE *fp, const char *format, ...);
// clock_t clock(void);
// int printf(const char *format, ...);
// int __fastcall atexit(void (*func)(void));
// int getch(void);
// void __fastcall exit(int status);
// int heapchk(void);
// time_t __fastcall time(time_t *timer);
// int rand(void);
// void __fastcall srand(unsigned int seed);
// int __fastcall access(const char *path, int mode);
// char *__fastcall fgets(char *s, int n, FILE *fp);
// int __fastcall _wcpp_2_mod_register_(_DWORD); weak
// int fprintf(FILE *fp, const char *format, ...);
// int __fastcall vsprintf(char *s, const char *format, __va_list arg);
// void *__fastcall malloc(size_t size);
// void *__fastcall calloc(size_t n, size_t size);
// void __fastcall free(void *ptr);
// int __fastcall strnicmp(const char *s1, const char *s2, size_t n);
// int __fastcall atoi(const char *nptr);
// char *__fastcall strdup(const char *string);
// void __fastcall delay(unsigned int milliseconds);
// unsigned int __fastcall dos_getftime(int handle, unsigned __int16 *date, unsigned __int16 *time);
// int __fastcall strncmp(const char *s1, const char *s2, size_t n);
// double __fastcall pow(double x, double y);
// _DWORD __stdcall _wcpp_2_assign_array_(_DWORD); weak
// int __fastcall _wcpp_2_copy_array_(_DWORD, _DWORD, _DWORD, _DWORD); weak
// double __fastcall acos(double x);
// void *__fastcall operator new(size_t size);
// char *__fastcall strupr(char *string);
// int __fastcall heapwalk(struct _heapinfo *entry);
// void *__fastcall memmove(void *s1, const void *s2, size_t n);
// int __fastcall int386(int, union REGS *, union REGS *);
// int __fastcall int386x(int, union REGS *, union REGS *, struct SREGS *);
// void *__fastcall memcpy(void *s1, const void *s2, size_t n);
// char *__fastcall getenv(const char *name);
// int __fastcall isatty(int handle);
// void __fastcall setbuf(FILE *fp, char *buf);
// struct tm *__fastcall localtime(const time_t *timer);
// char *__fastcall asctime(const struct tm *timeptr);
// char *__fastcall strcpy(char *s1, const char *s2);
// int __fastcall toupper(_DWORD, _DWORD, _DWORD); weak
// size_t __fastcall strlen(const char *s);
// int __fastcall ftell(FILE *fp);
// int __fastcall fseek(FILE *fp, int offset, int whence);
// size_t __fastcall fread(void *ptr, size_t size, size_t n, FILE *fp);
// _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16); weak
// int sub_7D908(); weak
// int sub_7D944(); weak
// int __usercall sub_7D9E4@<eax>(int result@<eax>, int a2@<ecx>, _BYTE *a3@<ebp>);
void sub_7DA32();
void sub_7DA38();
void sub_7DA3E();
void sub_7DA44();
void sub_7DA4A();
void sub_7DA52();
void sub_7DA58();
void sub_7DA5E();
void sub_7DA64();
void sub_7DA6C();
void sub_7DA74();
void sub_7DA7C();
void sub_7DA84();
void sub_7DA8E();
void sub_7DA98();
void sub_7DAA0();
void sub_7DAA8();
void sub_7DAB1();
void sub_7DABA();
void sub_7DAC3();
void sub_7DACC();
void sub_7DAD7();
void sub_7DAE2();
void sub_7DAEB();
// char __usercall sub_7DAF4@<al>(unsigned __int8 a1@<ah>, int a2@<ebx>, _BYTE *a3@<esi>);
// int __usercall sub_7DB31@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_7DB50@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_7DB6F@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DB8B@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DBA7@<eax>(int a1@<ebp>, signed int *a2@<esi>);
// int __usercall sub_7DBC6@<eax>(int a1@<ebp>, signed int *a2@<esi>);
// int __usercall sub_7DBE5@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_7DC04@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>);
// int __usercall sub_7DC23@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DC5D@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// void __usercall sub_7DC6E(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_7DC7F@<eax>(void *a1@<ebp>, const void *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_7DC9D@<eax>(int a1@<ebp>, __int16 *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_7DCDD@<eax>(const void *a1@<ebp>, void *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_7DCF1@<eax>(_WORD *a1@<ebp>, _WORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_7DCFF@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_7DD1E@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_7DD3D@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DD59@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DD75@<eax>(int a1@<ebp>, int *a2@<esi>);
// int __usercall sub_7DD94@<eax>(int a1@<ebp>, int *a2@<esi>);
// int __usercall sub_7DDB3@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_7DDD2@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>);
// int __usercall sub_7DDF1@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DE2B@<eax>(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// void __usercall sub_7DE67(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>);
// int __usercall sub_7DE8B@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_7DEAE@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_7DED1@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DEF1@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DF11@<eax>(int a1@<ebp>, __int64 *a2@<esi>);
// int __usercall sub_7DF34@<eax>(int a1@<ebp>, __int64 *a2@<esi>);
// int __usercall sub_7DF57@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_7DF7A@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>);
// int __usercall sub_7DF9D@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7DFE4@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E022@<eax>(int a1@<edx>, _BYTE *a2@<ebp>, int a3@<edi>, int *a4@<esi>, int a5, __int16 a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, __int16 a19);
// void __usercall sub_7E037(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// void __usercall sub_7E055(int a1@<edx>, _BYTE *a2@<ebp>, int a3@<edi>, int *a4@<esi>);
// int __usercall sub_7E06A@<eax>(_DWORD *a1@<ebp>, _DWORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// void __usercall sub_7E0B1(char *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>);
// int __usercall sub_7E0DC@<eax>(int a1@<ebp>, _WORD *a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_7E0EA@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_7E10B@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_7E12C@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E14A@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E168@<eax>(int a1@<ebp>, __int16 *a2@<esi>);
// int __usercall sub_7E189@<eax>(int a1@<ebp>, __int16 *a2@<esi>);
// int __usercall sub_7E1AA@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_7E1CB@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>);
// int __usercall sub_7E1EC@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E228@<eax>(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// void __usercall sub_7E270(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>);
// int __usercall sub_7E2A5@<eax>(int a1@<ebp>, int a2@<edi>, unsigned int *a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// void __usercall sub_7E2E4(_WORD *a1@<ebp>, int a2@<edi>, int *a3@<esi>);
int sub_7E308(void); // weak
// int __usercall sub_7E30D@<eax>(int a1@<ebx>, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, __int16 a16);
// int __usercall sub_7E33A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7E34F@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7E364@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E376@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E388@<eax>(int a1@<ebp>);
// int __usercall sub_7E39D@<eax>(int a1@<ebp>);
// int __usercall sub_7E3B2@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7E3C7@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7E3DC@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E424@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E44C@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E4CD@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7E6E8@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4@<ebp>, int a5@<edi>, int a6@<esi>, int a7, __int16 a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, __int16 a21);
_DWORD sub_7E7F2(); // weak
int __fastcall sub_7E90A(int a1, int a2, int a3);
// int __usercall sub_7E993@<eax>(int a1@<ebx>, int a2@<ebp>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_7E9ED@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7EA02@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7EA17@<eax>(int a1@<ebp>);
// int __usercall sub_7EA2C@<eax>(int a1@<ebp>);
// int __usercall sub_7EA41@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7EA56@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7EA6B@<eax>(int a1@<ebp>, int a2@<esi>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
// int __usercall sub_7EA8A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7EAB6@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// int __usercall sub_7EAC8@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4, __int16 a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, __int16 a18);
// void __usercall sub_7EADA(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7EB06@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7EB51@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
int __fastcall sub_7EB9C(int a1, int a2, int a3);
// int __usercall sub_7EC25@<eax>(int a1@<ebp>, int a2@<edi>);
// int __usercall sub_7EC70@<eax>(int a1@<ebp>, int a2@<edi>);
// int __usercall sub_7ECBB@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7ED06@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>);
// int __usercall sub_7ED51@<eax>(int a1@<ebx>, int a2@<ebp>, int a3, __int16 a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17);
void sub_7EEEA();
// int __usercall sub_7EEF8@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __userpurge sub_7EF22@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4, __int16 a5);
// int __usercall sub_7EF52@<eax>(__int64 a1@<edx:eax>, int a2@<ecx>, int a3@<ebx>, int a4@<esi>);
int __fastcall sub_7F0BE(unsigned int a1, int a2);
// int __usercall sub_7F157@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>);
// int __usercall sub_7F181@<eax>(unsigned __int64 a1@<edx:eax>, int a2@<ecx>, unsigned int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>);
// int __usercall sub_7F32C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __usercall sub_7F356@<eax>(unsigned __int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, int a4@<esi>);
void sub_7F4A7();
int __fastcall sub_7F4AC(int *a1);
int __fastcall sub_7F516(int a1);
int __fastcall sub_7F527(unsigned int a1, int a2);
// int __usercall sub_7F55C@<eax>(__int64 a1@<edx:eax>, int a2@<ebx>, _BYTE *a3@<ebp>);
int __fastcall sub_7F5DC(int a1);
// int __usercall sub_7F65B@<eax>(__int64 *a1@<eax>, _BYTE *a2@<ebp>);
signed int __fastcall sub_7F722(signed int result, int a2);
unsigned int __fastcall sub_7F7E7(unsigned int result, __int16 a2);
// __int16 __usercall sub_7F974@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>);
// __int16 __usercall __spoils<> sub_7FA2A@<ax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>);
// int __usercall sub_7FB8D@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>);
// int __usercall sub_7FBF3@<eax>(__int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, __int16 a4@<di>, __int16 a5@<si>);
// char __usercall sub_7FC6E@<al>(int a1@<eax>, int a2@<ebp>, int a3@<edi>);
// int __usercall sub_7FD5C@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>);
// int __usercall sub_7FD75@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>);
// int __usercall sub_7FDB8@<eax>(int a1@<eax>, _BYTE *a2@<ebp>);
// int __usercall sub_80050@<eax>(int a1@<eax>, int a2@<esi>);
int __fastcall sub_80247(int a1);
int __fastcall sub_80251(int a1);
int __fastcall sub_8025E(int a1);
int sub_8026C(); // weak
int __fastcall sub_80294(int a1, int a2, int a3, int a4);
int __fastcall sub_80468(unsigned __int64 a1);
// void __usercall sub_80554(int a1@<ecx>, int a2@<esi>);
// int __usercall sub_805A6@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_18241; // weak
_UNKNOWN loc_18247; // weak
_UNKNOWN loc_18253; // weak
_UNKNOWN loc_1825F; // weak
_UNKNOWN loc_1829D; // weak
_UNKNOWN loc_18696; // weak
_UNKNOWN locret_1B66C; // weak
_UNKNOWN loc_21D46; // weak
_UNKNOWN loc_21D90; // weak
_UNKNOWN loc_21D96; // weak
_UNKNOWN loc_21DB2; // weak
_UNKNOWN loc_24D98; // weak
_UNKNOWN loc_24D9B; // weak
_UNKNOWN loc_24D9E; // weak
_UNKNOWN loc_24DA4; // weak
_UNKNOWN loc_24DAA; // weak
_UNKNOWN loc_24DAD; // weak
_UNKNOWN loc_27100; // weak
_UNKNOWN loc_27281; // weak
_UNKNOWN loc_272D8; // weak
_UNKNOWN loc_27C93; // weak
_UNKNOWN loc_2FEB8; // weak
_UNKNOWN loc_3067E; // weak
_UNKNOWN loc_306F3; // weak
_UNKNOWN loc_306F7; // weak
_UNKNOWN loc_306F9; // weak
char byte_30700[] = { '\xE8' }; // weak
void *off_30701 = &loc_46F35; // weak
_UNKNOWN loc_32C48; // weak
_UNKNOWN loc_32DCD; // weak
_UNKNOWN loc_32DD2; // weak
_UNKNOWN loc_32DD4; // weak
char byte_32DDA[] = { '\x8B' }; // weak
char byte_32DDB[] = { '5' }; // weak
_UNKNOWN loc_493DC; // weak
__int16 word_53CEA = 0; // weak
__int16 word_53D02 = 0; // weak
__int16 word_53D06 = 0; // weak
__int16 word_53D0A = 0; // weak
__int16 word_53D0C = 0; // weak
__int16 word_53D0E = 0; // weak
int dword_53D1C = 0; // weak
void (__noreturn *off_5F687[3])() = { &sub_10000, &sub_10000, &sub_10000 }; // weak
int dword_60497[] = { 0 }; // weak
int dword_6B9AE[] = { 8 }; // weak
int (*funcs_74189[2])() = { &sub_725FC, &sub_7260D }; // weak
int (*funcs_74040[4])() = { &sub_7323A, &sub_7325B, &sub_7327F, &sub_732AB }; // weak
int dword_74578 = 1397753374; // weak
__int16 word_7457F = -26215; // weak
__int16 word_7458E = -26215; // weak
int dword_74594 = -1717986919; // weak
__int16 word_745AA = -26215; // weak
__int16 word_745B4 = -26215; // weak
__int16 word_745BB = -26215; // weak
int dword_76004[256] =
{
  -1866268467,
  -1866268211,
  -1866267955,
  -1866267699,
  -1866267443,
  -1866267187,
  -1866266931,
  -1866266675,
  -1866266419,
  -1866266163,
  -1866265907,
  -1866265651,
  -1866265395,
  -1866265139,
  -1866264883,
  -1866264627,
  -1866264371,
  -1866264115,
  -1866263859,
  -1866263603,
  -1866263347,
  -1866263091,
  -1866262835,
  -1866262579,
  -1866262323,
  -1866262067,
  -1866261811,
  -1866261555,
  -1866261299,
  -1866261043,
  -1866260787,
  -1866260531,
  -1866260275,
  -1866260019,
  -1866259763,
  -1866259507,
  -1866259251,
  -1866258995,
  -1866258739,
  -1866258483,
  -1866258227,
  -1866257971,
  -1866257715,
  -1866257459,
  -1866257203,
  -1866256947,
  -1866256691,
  -1866256435,
  -1866256179,
  -1866255923,
  -1866255667,
  -1866255411,
  -1866255155,
  -1866254899,
  -1866254643,
  -1866254387,
  -1866254131,
  -1866253875,
  -1866253619,
  -1866253363,
  -1866253107,
  -1866252851,
  -1866252595,
  -1866252339,
  -1866252083,
  -1866251827,
  -1866251571,
  -1866251315,
  -1866251059,
  -1866250803,
  -1866250547,
  -1866250291,
  -1866250035,
  -1866249779,
  -1866249523,
  -1866249267,
  -1866249011,
  -1866248755,
  -1866248499,
  -1866248243,
  -1866247987,
  -1866247731,
  -1866247475,
  -1866247219,
  -1866246963,
  -1866246707,
  -1866246451,
  -1866246195,
  -1866245939,
  -1866245683,
  -1866245427,
  -1866245171,
  -1866244915,
  -1866244659,
  -1866244403,
  -1866244147,
  -1866243891,
  -1866243635,
  -1866243379,
  -1866243123,
  -1866242867,
  -1866242611,
  -1866242355,
  -1866242099,
  -1866241843,
  -1866241587,
  -1866241331,
  -1866241075,
  -1866240819,
  -1866240563,
  -1866240307,
  -1866240051,
  -1866239795,
  -1866239539,
  -1866239283,
  -1866239027,
  -1866238771,
  -1866238515,
  -1866238259,
  -1866238003,
  -1866237747,
  -1866237491,
  -1866237235,
  -1866236979,
  -1866236723,
  -1866236467,
  -1866236211,
  -1866235955,
  -1866235699,
  -1866235443,
  -1866235187,
  -1866234931,
  -1866234675,
  -1866234419,
  -1866234163,
  -1866233907,
  -1866233651,
  -1866233395,
  -1866233139,
  -1866232883,
  -1866232627,
  -1866232371,
  -1866232115,
  -1866231859,
  -1866231603,
  -1866231347,
  -1866231091,
  -1866230835,
  -1866230579,
  -1866230323,
  -1866230067,
  -1866229811,
  -1866229555,
  -1866229299,
  -1866229043,
  -1866228787,
  -1866228531,
  -1866228275,
  -1866228019,
  -1866227763,
  -1866227507,
  -1866227251,
  -1866226995,
  -1866226739,
  -1866226483,
  -1866226227,
  -1866225971,
  -1866225715,
  -1866225459,
  -1866225203,
  -1866224947,
  -1866224691,
  -1866224435,
  -1866224179,
  -1866223923,
  -1866223667,
  -1866223411,
  -1866223155,
  -1866222899,
  -1866222643,
  -1866222387,
  -1866222131,
  -1866221875,
  -1866221619,
  -1866221363,
  -1866221107,
  -1866220851,
  -1866220595,
  -1866220339,
  -1866220083,
  -1866219827,
  -1866219571,
  -1866219315,
  -1866219059,
  -1866218803,
  -1866218547,
  -1866218291,
  -1866218035,
  -1866217779,
  -1866217523,
  -1866217267,
  -1866217011,
  -1866216755,
  -1866216499,
  -1866216243,
  -1866215987,
  -1866215731,
  -1866215475,
  -1866215219,
  -1866214963,
  -1866214707,
  -1866214451,
  -1866214195,
  -1866213939,
  -1866213683,
  -1866213427,
  -1866213171,
  -1866212915,
  -1866212659,
  -1866212403,
  -1866212147,
  -1866211891,
  -1866211635,
  -1866211379,
  -1866211123,
  -1866210867,
  -1866210611,
  -1866210355,
  -1866210099,
  -1866209843,
  -1866209587,
  -1866209331,
  -1866209075,
  -1866208819,
  -1866208563,
  -1866208307,
  -1866208051,
  -1866207795,
  -1866207539,
  -1866207283,
  -1866207027,
  -1866206771,
  -1866206515,
  -1866206259,
  -1866206003,
  -1866205747,
  -1866205491,
  -1866205235,
  -1866204979,
  -1866204723,
  -1866204467,
  -1866204211,
  -1866203955,
  -1866203699,
  -1866203443,
  -1866203187
}; // weak
void *off_7D3D0 = (void *)0xA0000; // weak
int dword_7D3D4[2] = { 70, 0 }; // weak
int dword_7D3DC[41] =
{
  20,
  67584,
  1966080,
  268435466,
  2,
  1310760,
  202752,
  3276800,
  536870942,
  4,
  2621500,
  337920,
  4587520,
  805306418,
  6,
  3932160,
  473088,
  -262144,
  1,
  196610,
  327667,
  524288,
  -3211252,
  16,
  3145760,
  4259647,
  8388608,
  -50396992,
  256,
  50332160,
  67171327,
  134217728,
  -805368832,
  4096,
  805314560,
  1073758207,
  2147483648,
  1073856512,
  33572096,
  50414144,
  -611892415
}; // weak
int (*funcs_7DB07[24])() =
{
  &sub_7DA32,
  &sub_7DA38,
  &sub_7DA3E,
  &sub_7DA44,
  &sub_7DA4A,
  &sub_7DA52,
  &sub_7DA58,
  &sub_7DA5E,
  &sub_7DA64,
  &sub_7DA6C,
  &sub_7DA74,
  &sub_7DA7C,
  &sub_7DA84,
  &sub_7DA8E,
  &sub_7DA98,
  &sub_7DAA0,
  &sub_7DAA8,
  &sub_7DAB1,
  &sub_7DABA,
  &sub_7DAC3,
  &sub_7DACC,
  &sub_7DAD7,
  &sub_7DAE2,
  &sub_7DAEB
}; // weak
int (*funcs_7E90A[8])() =
{
  &sub_7E308,
  &loc_7E932,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308
}; // weak
int (*funcs_7EB9C[8])() =
{
  &sub_7E308,
  &loc_7EBC4,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308,
  &sub_7E308
}; // weak
int dword_7F767[] = { 2147483647 }; // weak
__int16 word_7F91A = 6222; // weak
__int16 word_7FD16 = 18153; // weak
int dword_7FD34 = 0; // weak
__int16 word_7FF8A[] = { 21337 }; // weak
int dword_7FFE4[19] =
{
  -1648297841,
  -683696327,
  -385531950,
  -1522138140,
  -1076180533,
  -960184918,
  -1888041089,
  -476626974,
  2109457658,
  -1075211278,
  218157069,
  -804454192,
  -1240776721,
  1622543200,
  -1074416117,
  -1431655766,
  -1431655766,
  16378,
  0
}; // weak
__int16 word_8003E[] = { 0 }; // weak
double dbl_9017F = 0.0000152587890625; // weak
double dbl_901BB = 0.3333333333333333; // weak
float flt_901C3 = 0.015625; // weak
float flt_901C7 = 20.0; // weak
float flt_901E5 = 1280.0; // weak
double dbl_9022A = -20.0; // weak
double dbl_90232 = 0.05; // weak
double dbl_9023A = 20.0; // weak
double dbl_90242 = 0.0000152587890625; // weak
float flt_9024A = 0.050000001; // weak
float flt_9026C = -0.039999999; // weak
double dbl_90270 = 0.2; // weak
float flt_90278 = 0.039999999; // weak
float flt_9027C = 2.0; // weak
float flt_90280 = 32.0; // weak
float flt_902A0 = 96.0; // weak
double dbl_902A4 = 3.2; // weak
double dbl_902C8 = 3.2; // weak
float flt_90308 = 0.050000001; // weak
double dbl_9030C = 3.2; // weak
float flt_90314 = 50.0; // weak
float flt_90334 = 0.2; // weak
float flt_90338 = 0.03125; // weak
float flt_9033C = 32.0; // weak
float flt_9034E = -0.039999999; // weak
double dbl_90352 = 0.04; // weak
float flt_903A5 = 0.000015258789; // weak
float flt_903A9 = 0.000015258789; // weak
float flt_903AD = 2.5; // weak
double dbl_903B1 = 0.5; // weak
float flt_903B9 = 2.0; // weak
float flt_90432 = 10.0; // weak
double dbl_90436 = 1.25; // weak
double dbl_9043E = 0.1; // weak
double dbl_90446 = 0.8; // weak
float flt_9045D = 0.00125; // weak
float flt_90461 = 0.0020000001; // weak
float flt_90465 = 0.00125; // weak
float flt_9049E = 0.5; // weak
float flt_904A2 = 16384.0; // weak
float flt_904A6 = 0.125; // weak
float flt_904AA = -1.0; // weak
float flt_904AE = 131072.0; // weak
float flt_904C1 = 0.5; // weak
float flt_904C5 = 0.33333334; // weak
float flt_904C9 = 0.5; // weak
float flt_904CD = 2.0; // weak
float flt_904E0 = 50.0; // weak
float flt_904E4 = -50.0; // weak
float flt_904E8 = 0.0099999998; // weak
float flt_905FA = 32.0; // weak
float flt_90646 = 0.5; // weak
float flt_9064A = 0.03125; // weak
float flt_9064E = 0.0062500001; // weak
float flt_90652 = 960.0; // weak
float flt_90656 = 0.125; // weak
float flt_9065A = -32.0; // weak
float flt_9066D = -440.0; // weak
float flt_907F4 = 0.5; // weak
float flt_90A84 = 0.0011363636; // weak
float flt_90A88 = 1000.0; // weak
float flt_90A8C = 2000.0; // weak
float flt_90AF2 = -200.0; // weak
float flt_90B90 = 4.0; // weak
float flt_90B94 = 0.0099999998; // weak
float flt_90BC8 = -75.0; // weak
float flt_90BCC = 50.0; // weak
float flt_90C86 = 2000.0; // weak
float flt_90C8A = 0.011111111; // weak
double dbl_90D6E = 1.5; // weak
double dbl_90D76 = 1.25; // weak
float flt_9103C = 20.0; // weak
float flt_91040 = 60.0; // weak
float flt_91060 = 0.5; // weak
float flt_910EA = -1500.0; // weak
double dbl_91DB5 = 1.3; // weak
double dbl_91DD9 = 4000000.0; // weak
double dbl_91E43 = 0.95; // weak
float flt_91E91 = -3200.0; // weak
float flt_91E95 = 1280.0; // weak
_UNKNOWN unk_920AA; // weak
float flt_920F0 = 0.050000001; // weak
double dbl_920F4 = 0.6666666666666666; // weak
double dbl_92150 = 6.28318530716; // weak
float flt_92158 = 0.5; // weak
float flt_9215C = 2.0; // weak
float flt_92160 = -0.5; // weak
float flt_92164 = -2.0; // weak
float flt_92168 = -4.0; // weak
float flt_9216C = -6.0; // weak
double dbl_9232C = 1.2; // weak
float flt_92334 = 1440.0; // weak
float flt_92338 = 10000.0; // weak
float flt_9233C = 600.0; // weak
double dbl_9259A = 0.9; // weak
double dbl_925A2 = 2.0; // weak
double dbl_925AA = 0.9; // weak
double dbl_925B2 = 1.6; // weak
double dbl_925BA = 0.85; // weak
double dbl_925C2 = 1.7; // weak
float flt_92658 = 10.0; // weak
double dbl_9265C = 1.25; // weak
double dbl_92664 = 0.1; // weak
double dbl_9266C = 0.8; // weak
_UNKNOWN unk_92696; // weak
float flt_92697 = 0.25; // weak
float flt_9269B = 0.5; // weak
float flt_926DB = -1.0; // weak
double dbl_926EB = 10.0; // weak
double dbl_926F3 = 20.0; // weak
double dbl_9275B = 0.95; // weak
double dbl_92763 = 0.825; // weak
float flt_92777 = 0.0062500001; // weak
float flt_9277B = 32.0; // weak
float flt_9277F = 5.0; // weak
float flt_927BF = 0.33333334; // weak
float flt_927C3 = 2.0; // weak
float flt_927C7 = 0.1; // weak
float flt_927CB = 2.0; // weak
float flt_927E7 = 1600.0; // weak
float flt_928C7 = 2.0; // weak
double dbl_928CB = 0.75; // weak
float flt_928D3 = 64.0; // weak
float flt_928E6 = 2.0; // weak
double dbl_928EA = 0.75; // weak
float flt_92C3A = 0.33333334; // weak
float flt_92C3E = 2.0; // weak
_UNKNOWN unk_92C97; // weak
float flt_92D77 = -1500.0; // weak
double dbl_92DD4 = 0.5; // weak
char byte_93C9D = '\xFA'; // idb
char byte_94F88[] = { '0' }; // weak
char off_95504[] = { '%', 's', '\n', '\0' }; // idb
_UNKNOWN unk_959A4; // weak
int (*off_959B8[5])() = { &sub_10A80, &sub_2CA78, &sub_10B24, &sub_11870, &sub_2CF28 }; // weak
_UNKNOWN unk_959D8; // weak
float flt_959F4 = 0.017453292; // weak
_UNKNOWN unk_95A28; // weak
_UNKNOWN unk_95A3C; // weak
int (*off_95A50[6])() = { &sub_1604C, &sub_2CA78, &sub_16348, &sub_18CA8, &sub_2CF28, &sub_19E2C }; // weak
float flt_95A68 = 0.017453292; // weak
_UNKNOWN unk_95A8C; // weak
_UNKNOWN unk_95AA0; // weak
_UNKNOWN unk_95AB4; // weak
_UNKNOWN unk_95AC8; // weak
_UNKNOWN unk_95ADC; // weak
_UNKNOWN unk_95AF0; // weak
_UNKNOWN unk_95B04; // weak
_UNKNOWN unk_95B34; // weak
_UNKNOWN unk_95B48; // weak
_UNKNOWN unk_95B70; // weak
int (*off_95B84[5])() = { &sub_25CD4, &sub_2CA78, &sub_26000, &sub_25D18, &sub_25FB4 }; // weak
int (*off_95B9C[5])() = { &sub_25C08, &sub_2CA78, &sub_2F424, &sub_25C4C, &sub_2CF28 }; // weak
int (*off_95BB4[2])() = { &sub_22588, &sub_2CA78 }; // weak
_UNKNOWN unk_95C04; // weak
_UNKNOWN unk_95C18; // weak
_UNKNOWN unk_95C2C; // weak
int (*off_95C40[5])() = { &sub_27C08, &sub_2CA78, &sub_27C50, &sub_27D18, &sub_2CF28 }; // weak
int (*off_95C58[5])() = { &sub_2713C, &sub_2CA78, &sub_27184, &sub_271FC, &sub_2CF28 }; // weak
int (*off_95C70[5])() = { &sub_267BC, &sub_2CA78, &sub_270F4, &sub_27124, &sub_2CF28 }; // weak
_UNKNOWN unk_95CA0; // weak
int (*off_95CB4[3])() = { &sub_2AEB0, &sub_2CA78, &sub_2AFF0 }; // weak
_UNKNOWN unk_95D04; // weak
_UNKNOWN unk_95D18; // weak
_UNKNOWN unk_95D2C; // weak
_UNKNOWN unk_95D40; // weak
_UNKNOWN unk_95D54; // weak
_UNKNOWN unk_95D68; // weak
_UNKNOWN unk_95D7C; // weak
int (*off_95D90[5])() = { &sub_2FA34, &sub_2CA78, &sub_2F420, &sub_2FA98, &sub_2CF28 }; // weak
int (*off_95DA8[4])() = { &sub_2F4A8, &sub_2CA78, &sub_2F6B0, &sub_2F540 }; // weak
int (*off_95DC0[5])() = { &sub_2F30C, &sub_2CA78, &sub_2F478, &sub_2F354, &sub_2F414 }; // weak
int (*off_95DD8[5])() = { &sub_2E264, &sub_2CA78, &sub_2E3D4, &sub_2E6C0, &sub_2CF28 }; // weak
int (*off_95DF0[5])() = { &sub_2D9FC, &sub_2DB54, &sub_2DE68, &sub_2E084, &sub_2CF28 }; // weak
int (*off_95E08[5])() = { &sub_2D480, &sub_2CA78, &sub_2D4D0, &sub_2D528, &sub_2D79C }; // weak
int (*off_95E20[5])() = { &sub_2C848, &sub_2CA78, &sub_2F424, &sub_2CD24, &sub_2CF28 }; // weak
_UNKNOWN unk_95E40; // weak
int (*off_95E54[5])() = { &sub_2FC68, &sub_2CA78, &sub_2FD68, &sub_30774, &sub_2CF28 }; // weak
_UNKNOWN unk_95E74; // weak
int (*off_95E88[5])() = { &sub_3121C, &sub_2CA78, &sub_31268, &sub_3160C, &sub_2CF28 }; // weak
_UNKNOWN unk_95EB0; // weak
_UNKNOWN unk_95EC4; // weak
_UNKNOWN unk_95ED8; // weak
int (*off_95EEC[5])() = { &sub_33840, &sub_2CA78, &sub_338DC, &sub_33A68, &sub_2CF28 }; // weak
int (*off_95F04[5])() = { &sub_335B4, &sub_2CA78, &sub_33604, &sub_33674, &sub_2CF28 }; // weak
int (*off_95F1C[5])() = { &sub_32038, &sub_2CA78, &sub_320B8, &sub_32414, &sub_2CF28 }; // weak
_UNKNOWN unk_95F44; // weak
_UNKNOWN unk_95F58; // weak
int (*off_95F6C[5])() = { &sub_395FC, &sub_2CA78, &sub_39644, &sub_396F0, &sub_2CF28 }; // weak
int (*off_95F84[5])() = { &sub_372CC, &sub_2CA78, &sub_37568, &sub_384B0, &sub_2CF28 }; // weak
_UNKNOWN unk_95FA4; // weak
int (*off_95FB8[5])() = { &sub_39D9C, &sub_2CA78, &sub_39E3C, &sub_3A6BC, &sub_2CF28 }; // weak
_UNKNOWN unk_96004; // weak
int (*off_96018[5])() = { &sub_46C48, &sub_2CA78, &sub_47224, &sub_47ABC, &sub_2CF28 }; // weak
_UNKNOWN unk_96038; // weak
_UNKNOWN unk_96068; // weak
int (*off_9607C[5])() = { &sub_4DA08, &sub_2CA78, &sub_4DDB0, &sub_4E758, &sub_2CF28 }; // weak
_UNKNOWN unk_960BC; // weak
_UNKNOWN unk_960D0; // weak
_UNKNOWN unk_960E4; // weak
int (*off_960F8[5])() = { &sub_52108, &sub_2CA78, &sub_5294C, &sub_521C0, &sub_2CF28 }; // weak
int (*off_96110[5])() = { &sub_51B80, &sub_2CA78, &sub_51D24, &sub_51BC4, &sub_2CF28 }; // weak
int (*off_96128[5])() = { &sub_51690, &sub_2CA78, &sub_51894, &sub_516E0, &sub_2CF28 }; // weak
float flt_96140 = 0.017453292; // weak
float flt_96144 = 57.29578; // weak
_UNKNOWN unk_9615C; // weak
_UNKNOWN unk_96184; // weak
_UNKNOWN unk_96198; // weak
int (*off_961AC[5])() = { &sub_5A5AC, &sub_2CA78, &sub_5A60C, &sub_5AA08, &sub_2CF28 }; // weak
int (*off_961C4[5])() = { &sub_5B2B0, &sub_2CA78, &sub_2F424, &sub_1240C, &sub_2FC3C }; // weak
int (*off_961DC[5])() = { &sub_5B300, &sub_2CA78, &sub_2F424, &sub_2FBA4, &sub_2FC3C }; // weak
char byte_96230[260] =
{
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\n',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '8',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  'X',
  'X',
  'X',
  'X',
  'X',
  'X',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  'H',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x98',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\x88',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char aDataRacea03Haz[17] = "DATA\\RACEA03.HAZ"; // weak
int off_964E0 = 592479; // idb
_UNKNOWN unk_964E4; // weak
int dword_964EC = 0; // weak
__int16 word_964F0[] = { 10 }; // weak
__int16 word_964FA[12] = { 30, 30, 30, 30, 20, 20, 20, 20, 20, 20, 15, 15 }; // weak
void *off_96512 = &unk_10000F; // weak
_UNKNOWN unk_9652C; // weak
__int16 word_9652E[] = { 6 }; // weak
_UNKNOWN unk_96548; // weak
_UNKNOWN unk_9659C; // weak
char aCosdip[7] = "cosdip"; // weak
_UNKNOWN unk_965F8; // weak
int dword_965FD = -33549042; // weak
_DWORD dword_96654[5] = { 0, 0, 0, 0, 0 }; // weak
char s[] = "Thank you for playing Ascendancy."; // idb
_UNKNOWN unk_96768; // weak
int dword_96770 = 0; // weak
int dword_96774 = -1; // weak
char byte_96778 = '\xF3'; // weak
char byte_96779[7] = { '\x13', '\x17', '\x1B', '\x1F', '#', '\'', '+' }; // weak
_UNKNOWN unk_96780; // weak
int dword_96788 = 0; // weak
_UNKNOWN unk_9678C; // weak
_UNKNOWN unk_967BE; // weak
_UNKNOWN unk_967F0; // weak
__int16 word_9682E[5] = { 207, 297, 252, 207, 297 }; // weak
__int16 word_96838[4] = { 358, 358, 403, 442 }; // weak
int dword_96840 = -65094; // weak
int dword_9684C = 100; // weak
char *off_96850[5] = { "PLRES", "PLIND", "PLPRO", "PLPOP", "PLBUILD" }; // weak
_DWORD dword_96864[2] = { 50397184, 33686273 }; // weak
_UNKNOWN unk_9686C; // weak
_UNKNOWN unk_968A8; // weak
char byte_968DC = '\x01'; // weak
char byte_968DD = '\xFF'; // weak
__int16 word_968E8[21] =
{
  0,
  0,
  0,
  0,
  0,
  60,
  100,
  62,
  77,
  90,
  150,
  140,
  63,
  66,
  72,
  0,
  92,
  100,
  0,
  89,
  68
}; // weak
_UNKNOWN unk_96912; // weak
_UNKNOWN unk_96918; // weak
_UNKNOWN unk_9691E; // weak
_UNKNOWN unk_9696C; // weak
_UNKNOWN unk_96994; // weak
void *off_9699E = (void *)0x50000; // weak
char byte_969A8[] = { '\0' }; // weak
char byte_969B8[16] =
{
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x03',
  '\x01',
  '\0',
  '\0'
}; // weak
char byte_969C8[16] =
{
  '\x03',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\x0F',
  '\x1F',
  '\x1F',
  '\x1F',
  '\x1F',
  '\a',
  '\x01',
  '\0',
  '\0'
}; // weak
_DWORD dword_969D8[4] = { 70, 170, 240, 410 }; // weak
_UNKNOWN unk_96AC0; // weak
int dword_96AC8 = 0; // weak
int dword_96ACC = -1; // weak
int dword_96AD0 = -1; // weak
_UNKNOWN unk_96AD4; // weak
_UNKNOWN unk_96B08; // weak
int dword_96B10 = 0; // weak
__int16 word_96B2A = -1; // weak
__int16 word_96B2C = -1; // weak
_UNKNOWN unk_96B30; // weak
__int16 word_96B6C = 6166; // weak
__int16 word_96B6E = -1; // weak
__int16 word_96B70 = -1; // weak
__int16 word_96B72 = -1; // weak
_DWORD dword_96B74[5] = { 15, 25, 50, 75, 100 }; // weak
int dword_96B88 = 5; // weak
_UNKNOWN unk_96B8C; // weak
int dword_96B94 = 0; // weak
int dword_96BAC = -1; // weak
__int16 word_96BB0 = -1; // weak
int dword_96BB4 = -1; // weak
int dword_96BB8 = -1; // weak
int dword_96BBC = 1065353216; // weak
int dword_96BC0 = -1; // weak
__int16 word_96BC4[8] = { 243, 19, 27, 31, 23, 39, 35, 15 }; // weak
VFX_DESC *(__cdecl *VFX_describe_driver)() = NULL;
void (__cdecl *VFX_init_driver)() = NULL;
void (__cdecl *VFX_shutdown_driver)() = NULL;
void (__cdecl *VFX_area_wipe)(LONG x0, LONG y0, LONG x1, LONG y1, LONG color) = NULL;
void (__cdecl *VFX_wait_vblank_leading)() = NULL;
void (__cdecl *VFX_window_refresh)(WINDOW *target, LONG x0, LONG y0, LONG x1, LONG y1) = NULL;
void (__cdecl *VFX_window_read)(WINDOW *destination, LONG x0, LONG y0, LONG x1, LONG y1) = NULL;
void (__cdecl *VFX_DAC_read)(LONG color_number, RGB *triplet) = NULL;
void (__cdecl *VFX_DAC_write)(LONG color_number, RGB *triplet) = NULL;
void (__cdecl *VFX_pane_refresh)(PANE *target, LONG x0, LONG y0, LONG x1, LONG y1) = NULL;
void (__cdecl *VFX_line_address)(LONG x, LONG y, UBYTE **addr, ULONG *nbytes) = NULL;
int dword_96C15 = 0; // weak
int dword_96C19 = 0; // weak
int dword_96C1D = 0; // weak
int dword_96C21 = 0; // weak
int dword_96C25 = 0; // weak
int dword_96C29 = 0; // weak
int dword_96C3D = 0; // weak
int dword_96C45 = 0; // weak
char byte_9714D[768] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_9744D[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_9754D[768] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_97E4D[768] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_9814D[768] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_9844D[9] = { '\0', '\x01', '\x03', '\a', '\x0F', '\x1F', '?', '\x7F', '\xFF' }; // weak
char byte_98456[5] = { '\b', '\b', '\x04', '\x02', '\0' }; // weak
char byte_9845B[5] = { '\0', '\x04', '\x02', '\x01', '\0' }; // weak
PANE *dword_98460 = NULL;
char byte_98464[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_98564 = 0; // weak
int dword_98568 = 0; // weak
int dword_98570 = 0; // weak
int dword_98574 = 0; // weak
int dword_98578 = 0; // weak
int dword_9857C = 0; // weak
int dword_98584 = 0; // weak
int dword_98588 = 0; // weak
int dword_9858C = 0; // weak
int dword_98590 = 0; // weak
int dword_98598 = 0; // weak
int dword_9859C = 0; // weak
int dword_985A0 = 0; // weak
int dword_985A4 = 0; // weak
int dword_985AC = 0; // weak
int dword_985B0 = 0; // weak
int dword_985B4[] = { 0 }; // weak
int dword_985B8 = 0; // weak
int dword_985BC = 0; // weak
int dword_985C0 = 0; // weak
int dword_985C4 = 0; // weak
int dword_985C8 = 0; // weak
int dword_985CC = 0; // weak
int dword_985D0 = 0; // weak
int dword_985DC = 0; // weak
int dword_985E0 = 0; // weak
int dword_985E4 = 0; // weak
int dword_985E8 = 0; // weak
int dword_985EC = 0; // weak
int dword_985F0 = 0; // weak
int dword_985F4 = 0; // weak
int dword_985F8 = 0; // weak
int dword_985FC = 0; // weak
int dword_98600 = 0; // weak
int dword_98604 = 0; // weak
int dword_98608 = 0; // weak
int dword_9860C = 0; // weak
int dword_98610 = 0; // weak
int dword_98614 = 0; // weak
int dword_98618 = 0; // weak
int dword_98634 = 0; // weak
int dword_98638 = 0; // weak
int dword_98654 = 0; // weak
int dword_98658 = 0; // weak
int dword_9866C = 0; // weak
_UNKNOWN unk_98794; // weak
int dword_987A8 = 0; // weak
void *(__fastcall *malloc)(size_t size) = &malloc;
int (__fastcall *off_987B0)(_DWORD) = &free; // weak
int dword_987B4 = 0; // weak
int dword_987B8 = 0; // weak
int dword_987BC = 0; // weak
char byte_987C0[128] =
{
  '\0',
  '\x02',
  '\x04',
  '\x06',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\x10',
  '\x12',
  '\x14',
  '\x16',
  '\x18',
  '\x1A',
  '\x1C',
  '\x1E',
  ' ',
  '\"',
  '$',
  '&',
  '(',
  '*',
  ',',
  '.',
  '0',
  '2',
  '4',
  '6',
  '8',
  ':',
  '<',
  '>',
  '@',
  'B',
  'D',
  'F',
  'H',
  'J',
  'L',
  'N',
  'P',
  'R',
  'T',
  'V',
  'X',
  'Z',
  '\\',
  '^',
  '`',
  'b',
  'd',
  'f',
  'h',
  'j',
  'l',
  'n',
  'p',
  'r',
  't',
  'v',
  'x',
  'z',
  '|',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80',
  '\x80'
}; // weak
int dword_98840 = 0; // weak
int dword_98844 = 0; // weak
char aSample[7] = "SAMPLE"; // weak
int dword_988C8 = 0; // weak
int dword_988CC = 0; // weak
char byte_988DA = '\xFF'; // weak
char byte_988DB = '\xFF'; // weak
int dword_988DC = 0; // weak
int dword_988E0 = 0; // weak
int dword_988E4 = 0; // weak
int dword_988E8 = 0; // weak
int dword_988EC = 0; // weak
int dword_988F0 = 0; // weak
int dword_988F4 = 0; // weak
__int64 qword_988F8 = 0i64; // weak
int dword_98900 = 0; // weak
int dword_98904[] = { 0 }; // weak
int dword_98944[] = { 0 }; // weak
int dword_98980 = 0; // weak
int dword_98984[] = { 0 }; // weak
int dword_989C4[] = { 0 }; // weak
int dword_98A04[] = { 0 }; // weak
int dword_98A40 = 0; // weak
int dword_98A44[] = { 0 }; // weak
int dword_98A84 = 0; // weak
__int16 word_98A88 = 0; // weak
int dword_98A8A = 0; // weak
int dword_98A8E = 0; // weak
int dword_98A92 = 0; // weak
int dword_98A96 = 0; // weak
int dword_98A9A = 0; // weak
__int16 word_98A9E = 0; // weak
int dword_98AA0 = 0; // weak
int dword_98AA4 = 0; // weak
int dword_98AA8 = 0; // weak
_UNKNOWN unk_98AAC; // weak
__int16 word_994AC = 0; // weak
int dword_994B0 = 0; // weak
int dword_994B4 = 0; // weak
int dword_994B8 = 0; // weak
int dword_994BC = 0; // weak
int dword_994C0 = 0; // weak
int dword_994C4 = 0; // weak
char *off_994C8 = "Copyright (C) 1993-95 SciTech Software, All Rights Reserved."; // weak
void *off_994CC = &unk_950B8; // weak
void *off_994D0 = &unk_950BC; // weak
char *off_994D4 = "May 02 1995"; // weak
_UNKNOWN unk_994D8; // weak
__int16 word_995D8 = 0; // weak
int dword_995DA = 0; // weak
int dword_997F0 = 0; // weak
int (__cdecl *dword_997F8)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_9982C = 0; // weak
__int16 word_99850 = 0; // weak
int dword_99858 = 0; // weak
int dword_9985C = 0; // weak
int dword_99860 = 0; // weak
int dword_99864 = 0; // weak
int dword_99878 = 0; // weak
int (__fastcall *__FPE_handler)(_DWORD) = &_null_FPE_rtn; // weak
int dword_9A234 = 0; // weak
int dword_9A238 = 0; // weak
_UNKNOWN unk_9A23C; // weak
int dword_9A240 = 0; // weak
int dword_9A244 = 0; // weak
int dword_9A248 = 0; // weak
int dword_9A24C = 0; // weak
int V_CobCfgLoaded_dword_9A250 = 0; // weak
T_CobFilesIndex V_CobFilesIndex_stru_9A254 =
{
  {
    {
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0'
    },
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    {  }
  }
};
int dword_A0CF8; // weak
int dword_A0CFC; // weak
int dword_A0D00; // weak
T_StaticStrings V_StaticStrings_dword_A0D04;
int dword_A2F6C[]; // weak
char byte_A2F72[]; // weak
int byte_A2F73; // idb
char byte_A2F74[]; // weak
int dword_A2F75; // weak
int dword_A2F79; // weak
char byte_A310F[]; // weak
_UNKNOWN unk_A3122; // weak
__int16 word_A3124[5]; // weak
_UNKNOWN unk_A312F; // weak
char byte_A3132[9]; // weak
int dword_A313B; // weak
_UNKNOWN unk_A3141; // weak
__int16 word_A3143[]; // weak
__int16 word_A3147[]; // weak
char byte_A315B[]; // weak
int dword_A315C; // weak
int dword_A3CF2; // weak
__int16 word_A3CF6[]; // weak
int dword_A3CF8; // weak
char byte_A3D20; // weak
__int16 word_A3D21[]; // weak
int dword_A3D67[]; // weak
__int16 word_A3D7B[]; // weak
__int16 word_A62A1; // weak
_UNKNOWN unk_A62A3; // weak
__int16 word_A792F; // weak
_UNKNOWN unk_B0000; // weak
_UNKNOWN unk_B8000; // weak
_UNKNOWN unk_BB1B3; // weak
char byte_BB20A[19958]; // weak
int dword_CA1ED; // weak
_UNKNOWN unk_CA1F1; // weak
int dword_CA245; // weak
int dword_CA24A; // weak
int dword_D35E5; // weak
char byte_D35E9[117]; // weak
__int16 word_D365E; // weak
int dword_D3660; // weak
int dword_D3664; // idb
int dword_D3668; // weak
char byte_D366C; // weak
char byte_D5D47[10000]; // weak
int dword_D8457; // weak
__int16 word_D845C; // weak
char byte_D8460[100]; // weak
char byte_D84C4[258]; // weak
int dword_D85C6[]; // weak
_UNKNOWN unk_D85E4; // weak
int dword_D85E8; // weak
int dword_D85EC; // weak
_UNKNOWN unk_D85F8; // weak
int dword_D85FC; // weak
int dword_D8600; // weak
int dword_D8604; // weak
int a3; // idb
int dword_D860C; // weak
int dword_D8610; // weak
int dword_D8614; // weak
int dword_D8618; // weak
__int16 word_D8620; // weak
int dword_D8622; // weak
int dword_D8628; // weak
int dword_D862C; // weak
int dword_D8630; // weak
int dword_D8638; // weak
int dword_D863C; // weak
int dword_D8644; // weak
int dword_D8648; // weak
int dword_D864C; // weak
int dword_D8650; // weak
T_Type6 V_Type6_stru_D8654;
int dword_D8D8F; // weak
char byte_D8DA0[94816]; // weak
_UNKNOWN unk_F0000; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_FF000; // weak
__int16 word_FFE9E[]; // weak
__int16 word_FFEA0[7]; // weak
__int16 word_FFEAE[7]; // weak
__int16 word_FFEBC[7]; // weak
__int16 word_FFECA[7]; // weak
__int16 word_FFED8; // weak
__int16 word_FFEDA; // weak
__int16 word_FFEDC; // weak
__int16 word_FFEDE; // weak
__int16 word_FFEE0; // weak
__int16 word_FFEE2; // weak
__int16 word_FFEE6; // weak
__int16 word_FFEE8; // weak
__int16 word_FFEEA; // weak
__int16 word_FFEEC; // weak
__int16 word_FFEEE; // weak
__int16 word_FFEF0; // weak
__int16 word_FFEF2; // weak
__int16 word_FFEF4; // weak
__int16 word_FFEF6; // weak
__int16 word_FFEF8; // weak
_UNKNOWN unk_FFF04; // weak
_UNKNOWN unk_FFFFF; // weak
_UNKNOWN unk_100000; // weak
int dword_100302; // weak
int dword_100308; // weak
WINDOW V_Window1; // idb
void *buf; // idb
int dword_100324; // weak
int dword_100328; // weak
void *dword_10032C; // idb
__int16 word_100330; // weak
__int16 word_100332; // weak
char byte_100334; // weak
char byte_100335; // weak
int dword_100338; // weak
int dword_10033C; // weak
_UNKNOWN unk_100340; // weak
__int16 word_100350; // weak
_UNKNOWN unk_100744; // weak
_UNKNOWN unk_100EC4; // weak
char byte_101DC4[16]; // weak
_UNKNOWN unk_101DD4; // weak
_UNKNOWN unk_102554; // weak
__int16 word_103F94; // weak
__int16 word_103F98[]; // weak
int dword_103F9A[]; // weak
char byte_103F9E[]; // weak
char byte_103F9F[]; // weak
char byte_103FA0[]; // weak
char byte_103FA1[]; // weak
__int16 word_103FA2[]; // weak
__int16 word_103FA4[]; // weak
char byte_103FA6[755]; // weak
char byte_104299; // weak
char byte_104311; // weak
char byte_104338; // weak
char byte_1043B1; // weak
char byte_1043D9; // weak
char byte_104401; // weak
char byte_104429; // weak
char byte_104451; // weak
int dword_104515; // weak
char byte_104541; // weak
int dword_1045B4; // weak
char byte_1045B8[68]; // weak
int dword_1045FC[]; // weak
char byte_104603[]; // weak
char byte_104604[75]; // weak
char byte_10464F[]; // weak
_UNKNOWN unk_104650; // weak
int dword_10467C; // weak
char *dword_104680; // idb
int dword_104684[]; // weak
int dword_104688[4]; // weak
int dword_104698[]; // weak
int dword_10469C[10]; // weak
int dword_1046C4[]; // weak
int dword_1046E8[100]; // weak
int dword_104878[100]; // weak
int dword_104A08[100]; // weak
int dword_104B98[]; // weak
int dword_104BC0[9]; // weak
__int16 word_104BE8; // weak
int byte_104BEA; // idb
int dword_104BEC[100]; // weak
int dword_104D7C[99]; // weak
int dword_104F09; // weak
int dword_104F6D; // weak
int dword_104FD1; // weak
int dword_105035; // weak
int dword_10509C; // weak
int dword_1050A0; // weak
char byte_1050A4[420]; // weak
int dword_105248; // weak
int dword_10524C; // weak
int dword_105250; // weak
int dword_105254; // weak
size_t word_105258; // idb
char byte_10525A[60]; // weak
__int16 word_105296; // weak
char byte_105298[7]; // weak
int dword_10529F; // weak
char byte_1052A3[71]; // weak
int dword_1052EA; // weak
int dword_105416; // weak
int dword_105830; // weak
int dword_105BB4; // weak
__int16 word_106FA6[7]; // weak
__int16 word_106FB4[7]; // weak
int dword_106FC2; // weak
int dword_106FCC; // weak
int dword_106FD0; // weak
int dword_106FD4; // weak
int dword_106FD8; // weak
int dword_106FDC; // weak
char byte_106FE0[56]; // weak
__int16 word_107018; // weak
int dword_10701C; // weak
_UNKNOWN unk_107020; // weak
char byte_107052[]; // weak
__int16 word_107053[]; // weak
char byte_107055[5]; // weak
int dword_10705A; // weak
int dword_10705E; // weak
int dword_107062; // weak
int dword_107066; // weak
int dword_10706A; // weak
int dword_10706E; // weak
int dword_107072; // weak
int dword_107082; // weak
char byte_107F3D; // weak
int dword_1085F2; // weak
int dword_108A80; // weak
int dword_108C28; // weak
_UNKNOWN unk_108F98; // weak
int dword_108FE8; // weak
int dword_108FEC; // weak
int dword_108FF0; // weak
int dword_108FF4; // weak
int dword_108FF8; // weak
int dword_108FFC; // weak
int dword_109000; // weak
int dword_109004; // weak
int dword_109008; // weak
int dword_10900C; // weak
int dword_109010; // weak
int dword_109014; // weak
int dword_109018; // weak
_UNKNOWN unk_10901C; // weak
int dword_10903A; // weak
__int16 word_10903E; // weak
char byte_109040; // weak
int dword_109041; // weak
char byte_109045; // weak
int dword_109046; // weak
char byte_10904A; // weak
int dword_10904B; // weak
char byte_10904F; // weak
int dword_109050; // weak
float flt_109054; // weak
int dword_109058; // weak
float flt_10905C; // weak
float flt_109060; // weak
int dword_109064; // weak
float flt_109068; // weak
int dword_10906C; // weak
int dword_109070; // weak
int dword_109074; // weak
int dword_109078; // weak
int dword_10907C; // weak
int dword_109080; // weak
__int16 word_109084; // weak
float flt_109086; // weak
int dword_10908A; // weak
float flt_10908E; // weak
char byte_109092; // weak
int dword_109142; // weak
int dword_109146; // weak
_UNKNOWN unk_10914C; // weak
int dword_109357; // weak
int dword_10935F; // weak
int dword_10936F; // weak
int dword_109373; // weak
int dword_109377; // weak
_UNKNOWN unk_1094C6; // weak
int dword_1094DE[218]; // weak
__int16 word_109846; // weak
_UNKNOWN unk_109DF8; // weak
int dword_10AE60; // weak
int dword_10AE64; // weak
int dword_10AE68; // weak
int dword_10AE6C; // weak
T_Type3 V_Type3_stru_10AE70;
int dword_12FC10; // weak
int dword_12FC14; // weak
float flt_12FC1C; // weak
_DWORD dword_12FC20[248]; // weak
int dword_132B04; // idb
int dword_132B08; // idb
int dword_132B10; // weak
int dword_132B14; // weak
int dword_132B18; // weak
int dword_132B1C; // weak
char byte_132B20[20]; // weak
int dword_132B34; // weak
char byte_132B38[32]; // weak
int dword_132B58; // weak
int dword_132B5C; // weak
int dword_132B60; // weak
int dword_132B64; // weak
int dword_132B68; // weak
int dword_132B6C; // weak
int dword_132B70; // weak
int dword_132B74; // weak
LONG x0; // idb
LONG y0; // idb
LONG x1; // idb
LONG y1; // idb
int dword_132B88; // weak
T_Type5 V_Type5_stru_132B8C;
int dword_132BA0; // weak
int dword_132BA4; // weak
int (__cdecl *dword_132BA8)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_132BAC)(_DWORD, _DWORD); // weak
int (__cdecl *dword_132BB0)(_DWORD); // weak
size_t n; // idb
int dword_132BB8; // weak
int dword_132BBC; // weak
int dword_132BC0; // weak
int dword_132BC4; // weak
int dword_132BC8; // weak
WINDOW V_Window2; // idb
int dword_132BE0; // weak
WINDOW V_Window3; // idb
int dword_132BF8; // weak
int dword_132BFC; // weak
int dword_132C00; // weak
int dword_132C04; // weak
int dword_132C08; // weak
int dword_132C0C; // weak
HTIMER timer; // idb
int dword_132C14; // weak
int dword_132C18; // weak
int dword_132C1C; // weak
int dword_132C20; // weak
int dword_132C24; // weak
int dword_132C28; // weak
int dword_132C2C; // weak
int dword_132C30; // weak
int dword_132C34; // weak
_UNKNOWN unk_132C38; // weak
int dword_132C50; // weak
int dword_132C54; // weak
__int16 word_132C5A; // weak
_UNKNOWN unk_132C6A; // weak
int dword_132C82; // weak
int dword_132C86; // weak
__int16 word_132C8C; // weak
int dword_132C9C; // weak
int dword_132CA0; // weak
int dword_132CA4; // weak
int dword_132CA8; // weak
int dword_132CAC; // weak
int dword_132CB0; // weak
FILE *fp; // idb
int dword_132CB8; // weak
int dword_132CBC; // weak
char byte_132CC0[24]; // idb
char byte_132CD8; // weak
VDI_CALL in; // idb
int dword_132CEC; // weak
int dword_132CF0; // weak
int dword_132CF4; // weak
int dword_132CF8; // weak
int dword_132CFC; // weak
int dword_132D00; // weak
int dword_132D04; // weak
int dword_132D08; // weak
HSEQUENCE S; // idb
int dword_132D10; // weak
int dword_132D14; // weak
int dword_132D18; // weak
int dword_132D1C; // weak
int dword_132D20; // weak
int dword_132D24; // weak
int dword_132D28; // weak
int dword_132D2C; // weak
_UNKNOWN unk_132D30; // weak
AIL_DRIVER *drvr; // idb
char byte_132F70; // idb
ULONG hertz; // idb
int dword_133074; // weak
int dword_133078; // weak
int dword_13307C; // weak
int dword_133080; // weak
int dword_133084; // weak
int dword_133088; // weak
int dword_13308C; // weak
int dword_133090; // weak
int dword_133094; // weak
ULONG dword_133098; // idb
int dword_13309C; // weak
int dword_1330A0; // weak
int dword_1330A4; // weak
int dword_1330A8; // weak
int dword_1330AC; // weak
int dword_1330B0; // weak
int dword_1330B4; // weak
_UNKNOWN unk_1330B8; // weak
int dword_1330D0; // weak
_UNKNOWN unk_1330D4; // weak
_DWORD dword_1330EC; // weak
int dword_1330F0; // weak
int dword_1330F4; // weak
int dword_1330F8; // weak
__int16 word_1330FC; // weak
_WORD word_133100[122]; // weak
int dword_133204; // weak
int dword_13320C; // weak
int dword_133210; // weak
int dword_133218; // weak
int dword_133220; // weak


//----- (00010000) --------------------------------------------------------
void __noreturn sub_10000()
{
  while ( 1 )
  {
    __debugbreak();
  }
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00010010) --------------------------------------------------------
int __fastcall sub_10010(T_Type5 *a1, int a2, int a3, int a4)
{
  int v5; // eax
  int v6; // ebp
  int v7; // edi
  int v8; // ecx
  const char *v9; // ecx
  T_Rect *p_rect; // esi
  int result; // eax
  unsigned __int16 v12; // dx
  int v13; // esi
  int v14; // eax
  T_Type5 *v15; // esi
  const char *v16; // ecx
  int v17; // ebp
  int v18; // ecx
  int v19; // esi
  int v20; // edi
  int v21; // eax
  int v22; // esi
  int v23; // edi
  int v24; // esi
  int v25; // edi
  __int16 v26; // si
  int v27; // edx
  int v28; // ebx
  __int16 v29; // [esp-Ch] [ebp-98h]
  int v30; // [esp-8h] [ebp-94h]
  int v31; // [esp-4h] [ebp-90h]
  T_Type5 v32; // [esp+0h] [ebp-8Ch] BYREF
  int v33[5]; // [esp+14h] [ebp-78h]
  int v34[2]; // [esp+28h] [ebp-64h]
  int v35[2]; // [esp+30h] [ebp-5Ch]
  int v36[2]; // [esp+38h] [ebp-54h]
  int v37; // [esp+40h] [ebp-4Ch] BYREF
  int v38; // [esp+44h] [ebp-48h] BYREF
  int v39; // [esp+48h] [ebp-44h]
  int v40; // [esp+4Ch] [ebp-40h]
  int v41; // [esp+50h] [ebp-3Ch]
  int v42; // [esp+54h] [ebp-38h]
  int v43; // [esp+58h] [ebp-34h]
  int v44; // [esp+5Ch] [ebp-30h]
  int v45; // [esp+60h] [ebp-2Ch]
  unsigned int v46; // [esp+64h] [ebp-28h]
  int v47; // [esp+68h] [ebp-24h]
  unsigned int v48; // [esp+6Ch] [ebp-20h]
  int v49; // [esp+70h] [ebp-1Ch]
  int v50; // [esp+74h] [ebp-18h]
  T_Type5 *v51; // [esp+78h] [ebp-14h]
  unsigned int v52; // [esp+7Ch] [ebp-10h]

  v51 = a1;
  v43 = 0;
  if ( a4 )
  {
    sub_5E9D0(a1, 0x96);
    v43 = 0x96;
  }
  if ( a3 < 0 )
  {
    v5 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEDA);
    v6 = v5;
    if ( !v5 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x46);
    }
    v7 = 5 * *(unsigned __int16 *)(a2 + 0x16) + *(unsigned __int16 *)(a2 + 0x14);
    sub_2BC40(v51, v5, v7, &v37, &v38);
    v39 = a2;
    sub_5CB3C(v51, v6, v7, v37, v38);
    v8 = *(unsigned __int8 *)(a2 + 0x57);
    v40 = 0xF3;
    if ( v8 != 0xFF )
    {
      sub_53E38(v51, 2, 4, v8);
      v40 = 4 * (unsigned __int8)byte_A2F74[0x1EE * *(unsigned __int8 *)(a2 + 0x57)] + 0x13;
    }
    v29 = v40;
    v9 = (const char *)(v39 + 0x24);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v51->a;
    p_rect = &v51->rect;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v51->rect.x1;
    p_rect = (T_Rect *)((char *)p_rect + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = p_rect->x1;
    p_rect = (T_Rect *)((char *)p_rect + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = p_rect->x1;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = p_rect->y1;
    return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x12, 7, v9, 0, v29, 0xFF, 0);
  }
  v12 = word_FFEBC[*(__int16 *)(a2 + 0x56)];
  v44 = a2;
  v13 = sub_1B084((unsigned int)&unk_12FC20, v12);
  if ( !v13 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x5C);
  }
  v14 = *(__int16 *)(v44 + 0x56);
  v41 = 0;
  if ( v14 == (unsigned __int8)byte_104BEA || sub_4AAEC(v44, (unsigned __int8)byte_104BEA) > 0 )
  {
    v41 = 0xFFFFFFFF;
  }
  sub_2BC40(v51, v13, *(char *)(v44 + 0xAA), &v37, &v38);
  if ( v41 != 0xFFFFFFFF )
  {
    goto LABEL_25;
  }
  if ( *(int *)(v44 + 0x88) > 0 )
  {
    if ( 4 * *(_DWORD *)(v44 + 0x8C) < *(_DWORD *)(v44 + 0x98) || *(int *)(v44 + 0x8C) < 5 )
    {
      sub_5D007((const void *)(dword_D8D8F + 0x800));
      sub_5D026(v51, v13, *(char *)(v44 + 0xAA), v37, v38);
      goto LABEL_26;
    }
    if ( !*((_BYTE *)&byte_A2F73 + 0x1EE * *(__int16 *)(v44 + 0x56)) )
    {
      sub_5D007((const void *)(dword_D8D8F + 0x300));
      sub_5D026(v51, v13, *(char *)(v44 + 0xAA), v37, v38);
      goto LABEL_26;
    }
    if ( *((_BYTE *)&byte_A2F73 + 0x1EE * *(__int16 *)(v44 + 0x56)) != 0xD )
    {
      sub_5D007((const void *)(dword_D8D8F + 0x600));
      sub_5D026(v51, v13, *(char *)(v44 + 0xAA), v37, v38);
      goto LABEL_26;
    }
LABEL_25:
    sub_5CB3C(v51, v13, *(char *)(v44 + 0xAA), v37, v38);
    goto LABEL_26;
  }
  sub_5D007((const void *)(dword_D8D8F + 0x1600));
  sub_5D026(v51, v13, *(char *)(v44 + 0xAA), v37, v38);
LABEL_26:
  v15 = v51;
  sub_53E38(v51, 2, 4, *(_WORD *)(v44 + 0x56));
  v16 = (const char *)(v44 + 0x34);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v15->a;
  v15 = (T_Type5 *)((char *)v15 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v15->a;
  v15 = (T_Type5 *)((char *)v15 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = v15->a;
  v15 = (T_Type5 *)((char *)v15 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = v15->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v15->rect.x1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x12, 7, v16, 0, 0xF, 0xFF, 0);
  result = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEE6);
  v17 = result;
  if ( !result )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0xA4);
  }
  if ( v41 == 0xFFFFFFFF )
  {
    v20 = 0x12;
    v19 = 0;
    v42 = sub_4A8CC(v44);
    do
    {
      if ( v19 >= v42 )
      {
        break;
      }
      v18 = v20;
      ++v19;
      v20 += 5;
      sub_53EB8(v51, v17, 0, v18, 0x11, *(_WORD *)(v44 + 0x56));
    }
    while ( v19 < 0xA );
    v33[0] = *(_DWORD *)v44;
    v33[1] = *(_DWORD *)(v44 + 4);
    v33[2] = *(_DWORD *)(v44 + 0x10);
    v33[3] = *(_DWORD *)(v44 + 0x20);
    v50 = 0x1F;
    v21 = *(_DWORD *)(v44 + 0x18);
    v47 = 0;
    v33[4] = v21;
    v46 = 0;
    v32 = *v51;
    do
    {
      v32.rect.x2 = v32.rect.x1 + 1;
      v22 = v33[v46 / 4];
      v23 = 2;
      if ( v22 > 0 )
      {
        v32.rect.x2 += (8 * v22 - (__CFSHL__((8 * v22) >> 0x1F, 2) + 4 * ((8 * v22) >> 0x1F))) >> 2;
      }
      v24 = 0;
      v49 = v47 + 1;
      do
      {
        v30 = v23;
        ++v24;
        v23 += 8;
        sub_5CB3C(&v32, v17, v49, v30, v50);
      }
      while ( v24 < 0xF );
      v50 += 9;
      v46 += 4;
      ++v47;
    }
    while ( v47 < 5 );
    v34[0] = *(_DWORD *)(v44 + 0x8C);
    v34[1] = *(_DWORD *)(v44 + 0x88);
    v25 = 0x7C;
    v36[0] = *(_DWORD *)(v44 + 0x98);
    v48 = 0;
    v36[1] = sub_4A8FC(v44);
    v35[0] = 2;
    v35[1] = 5;
    v45 = 0x82;
    do
    {
      result = v48;
      v27 = v36[v48 / 4];
      if ( v27 > 0 )
      {
        v28 = v34[v48 / 4];
        if ( v28 >= 0 )
        {
          if ( v28 > v27 )
          {
            v34[v48 / 4] = v36[v48 / 4];
          }
          v26 = 0;
          v52 = v48;
        }
        else
        {
          v34[v48 / 4] = 0;
          v26 = 0;
          v52 = v48;
        }
        while ( v26 < 9 )
        {
          v31 = 8 * v26++ + 9;
          sub_5CB3C(v51, v17, *(int *)((char *)v35 + v52), v25, v31);
        }
        result = sub_2BB74(
                   (int **)v51,
                   (int *)v25,
                   (int *)8,
                   (int *)v45,
                   (int *)(0x50 - 0x48 * *(int *)((char *)v34 + v52) / *(int *)((char *)v36 + v52)),
                   v43,
                   0xFFFFFFFF);
      }
      v25 += 8;
      v45 += 8;
      v48 += 4;
    }
    while ( v48 != 8 );
  }
  return result;
}
// D8D8F: using guessed type int dword_D8D8F;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDA: using guessed type __int16 word_FFEDA;
// FFEE6: using guessed type __int16 word_FFEE6;

//----- (00010668) --------------------------------------------------------
int __fastcall sub_10668(_DWORD *a1, char *a2, int a3, int a4)
{
  int v5; // edi
  char *v6; // esi
  unsigned __int8 v7; // al
  int result; // eax
  int v9; // eax
  char *sub_1CEA8; // eax
  char s[80]; // [esp+0h] [ebp-6Ch] BYREF
  int v12; // [esp+50h] [ebp-1Ch] BYREF
  int v13; // [esp+54h] [ebp-18h] BYREF
  int v14; // [esp+58h] [ebp-14h]
  char *v15; // [esp+5Ch] [ebp-10h]

  v15 = a2;
  v14 = a3;
  v5 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFED8);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0xEA);
  }
  v6 = v15;
  if ( a4 && !v14 && (word_107053[0x35 * *v15] & 0x80) == 0 )
  {
    sub_5E9D0((P_Type5)a1, 0x96);
  }
  if ( *v15 == (char)0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0xFB);
  }
  sub_2BC40(a1, v5, *v15, &v13, &v12);
  if ( v14 == 2 || v14 == 3 )
  {
    sub_5D007((const void *)(dword_D8D8F + 0x700));
    sub_5D026((P_Type5)a1, v5, *v6, v13, v12);
  }
  else
  {
    sub_5CB3C((P_Type5)a1, v5, *v6, v13, v12);
  }
  if ( *(_DWORD *)(v6 + 3) )
  {
    if ( (word_107053[0x35 * *v6] & 0x20) != 0 )
    {
      sub_2BB74(
        (int **)a1,
        (int *)1,
        (int *)1,
        (int *)(a1[3] - a1[1] - 1),
        (int *)(a1[4] - a1[2] - 1),
        4 * byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13,
        0);
    }
  }
  sprintf(s, "%s", (const char *)&unk_107020 + 0x6A * *v6);
  v7 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  result = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 2, s, 0, 4 * v7 + 0x13, 0xFF, 0);
  if ( v14 == 2 )
  {
    v9 = 0;
  }
  else
  {
    if ( v14 != 3 )
    {
      return result;
    }
    v9 = 1;
  }
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v9);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 0xC, sub_1CEA8, 0, 0xF, 0xFF, 0);
}
// D8D8F: using guessed type int dword_D8D8F;
// FFED8: using guessed type __int16 word_FFED8;
// 107053: using guessed type __int16 word_107053[];

//----- (00010878) --------------------------------------------------------
int __fastcall sub_10878(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // edi
  unsigned __int8 v6; // al
  int result; // eax
  __int16 v8; // dx
  char *sub_1CEA8; // eax
  char s[80]; // [esp+0h] [ebp-68h] BYREF
  int v11; // [esp+50h] [ebp-18h] BYREF
  int v12; // [esp+54h] [ebp-14h] BYREF
  int v13; // [esp+58h] [ebp-10h]

  v13 = a3;
  v5 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEDC);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x122);
  }
  if ( a4 && !v13 )
  {
    sub_5E9D0((P_Type5)a1, 0x96);
  }
  sub_2BC40(a1, v5, *(unsigned __int8 *)(a2 + 1), &v11, &v12);
  if ( v13 == 1 )
  {
    sub_5D007((const void *)(dword_D8D8F + 0x700));
    sub_5D026((P_Type5)a1, v5, *(unsigned __int8 *)(a2 + 1), v11, v12);
  }
  else
  {
    sub_5CB3C((P_Type5)a1, v5, *(unsigned __int8 *)(a2 + 1), v11, v12);
  }
  sprintf(s, "%s", (const char *)&dword_103F9A[0xA * *(unsigned __int8 *)(a2 + 1) + 3]);
  v6 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  result = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 2, s, 0, 4 * v6 + 0x13, 0xFF, 0);
  if ( v13 == 1 )
  {
    v8 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
    return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 0xC, sub_1CEA8, 0, v8 + 0x13, 0xFF, 0);
  }
  return result;
}
// D8D8F: using guessed type int dword_D8D8F;
// FFEDC: using guessed type __int16 word_FFEDC;
// 103F9A: using guessed type int dword_103F9A[];

//----- (00010A14) --------------------------------------------------------
int __fastcall sub_10A14(int a1, int a2)
{
  int v2; // ecx
  int v3; // esi
  int result; // eax

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  result = 0xFFFFFFFF;
  if ( v2 > v3 )
  {
    return 1;
  }
  if ( v2 == v3 )
  {
    return 0;
  }
  return result;
}

//----- (00010A3C) --------------------------------------------------------
void __fastcall __spoils<> sub_10A3C(P_TypeA8 a1)
{
  sub_2C830(&a1->a);
  a1->j2 = 0;
  a1->j3 = 0;
  a1->j4 = 0;
  a1->a.b = (int)off_959B8;
  sub_10AC4(a1);
}
// 959B8: using guessed type int (*off_959B8[5])();

//----- (00010A80) --------------------------------------------------------
int __fastcall sub_10A80(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_959A4);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_959B8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 959B8: using guessed type int (*off_959B8[5])();

//----- (00010AC4) --------------------------------------------------------
void __fastcall __spoils<> sub_10AC4(P_TypeA8 result)
{
  result->b = 0;
  result->c = 0;
  result->d = 0;
  result->e = 0;
  result->f = 0;
  result->g = 0;
  result->i = 0;
}

//----- (00010B24) --------------------------------------------------------
int __fastcall sub_10B24(int a1, unsigned __int16 a2, int a3, int *a4)
{
  int result; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  __int16 i; // ax
  int v13; // edx
  int v14; // edx
  int v15; // eax
  char v16; // al
  unsigned __int8 v17; // al
  int v18; // ecx
  char v19; // bh
  int v20; // edx
  int **v21; // edi
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // ebx
  char v26; // al
  int v27; // eax
  int v28; // edx
  int v29; // eax
  int v30; // eax
  char *v31; // eax
  char v32; // cl
  char *v33; // esi
  char *v34; // eax
  int v35; // edx
  int v36; // edx
  int v37; // eax
  int v38; // edx
  char *v39; // eax
  int v40; // ebx
  char v41; // cl
  int *v42; // ecx
  int v43; // [esp-4h] [ebp-9Ch]
  char v44; // [esp+0h] [ebp-98h] BYREF
  int v45; // [esp+1h] [ebp-97h]
  char v46; // [esp+5h] [ebp-93h]
  int *v47; // [esp+6h] [ebp-92h]
  int v48; // [esp+Ah] [ebp-8Eh]
  int v49; // [esp+Eh] [ebp-8Ah]
  int v50; // [esp+12h] [ebp-86h]
  int v51; // [esp+16h] [ebp-82h]
  int v52; // [esp+1Ah] [ebp-7Eh]
  int v53; // [esp+1Eh] [ebp-7Ah]
  int v54; // [esp+22h] [ebp-76h]
  char v55; // [esp+28h] [ebp-70h]
  int v56; // [esp+29h] [ebp-6Fh]
  char v57; // [esp+2Dh] [ebp-6Bh]
  int v58; // [esp+2Eh] [ebp-6Ah]
  int v59; // [esp+32h] [ebp-66h]
  int v60; // [esp+36h] [ebp-62h]
  int v61; // [esp+3Ah] [ebp-5Eh]
  int v62; // [esp+3Eh] [ebp-5Ah]
  int v63; // [esp+42h] [ebp-56h]
  int v64; // [esp+46h] [ebp-52h]
  int v65; // [esp+4Ah] [ebp-4Eh]
  char v66; // [esp+50h] [ebp-48h]
  int v67; // [esp+51h] [ebp-47h]
  char v68; // [esp+55h] [ebp-43h]
  int *v69; // [esp+56h] [ebp-42h]
  int v70; // [esp+5Ah] [ebp-3Eh]
  int v71; // [esp+5Eh] [ebp-3Ah]
  int v72; // [esp+62h] [ebp-36h]
  int v73; // [esp+66h] [ebp-32h]
  int v74; // [esp+6Ah] [ebp-2Eh]
  int v75; // [esp+6Eh] [ebp-2Ah]
  int v76; // [esp+72h] [ebp-26h]
  int *v77; // [esp+78h] [ebp-20h]
  int *v78; // [esp+7Ch] [ebp-1Ch]
  int *v79; // [esp+80h] [ebp-18h]
  int v80; // [esp+84h] [ebp-14h]
  char v81; // [esp+88h] [ebp-10h]

  v80 = a3;
  if ( a2 < 0x327u )
  {
    if ( a2 >= 0x322u )
    {
      if ( a2 > 0x322u )
      {
        if ( a2 < 0x325u )
        {
          if ( a2 != 0x324 )
          {
            return sub_2F424(a1, a2, v80, (int)a4);
          }
          if ( *(_BYTE *)(a1 + 0xB9) != 1 )
          {
            *(_BYTE *)(a1 + 0xB9) = 1;
            sub_12140(a1);
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
          }
          return 0xFFFFFFFF;
        }
        else if ( a2 <= 0x325u )
        {
          if ( *(_BYTE *)(a1 + 0xB9) != 4 )
          {
            *(_BYTE *)(a1 + 0xB9) = 4;
            sub_12140(a1);
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
          }
          return 0xFFFFFFFF;
        }
        else
        {
          *(_DWORD *)(a1 + 0xBF) = 0;
          if ( !a3 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x2E1);
          }
          if ( !a4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x2E2);
          }
          if ( *(_WORD *)(a1 + 0xD4) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x2E4);
          }
          v41 = *(_BYTE *)(a1 + 0xAB);
          if ( v41 == 3 )
          {
            v48 = 0;
            v49 = 0;
            v50 = 0;
            v52 = 0;
            v53 = 0;
            v51 = 0;
            v44 = 2;
            *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 0;
            v42 = a4;
            if ( *(_BYTE *)(a1 + 0xB0) )
            {
              v44 = 1;
              v45 = *(_DWORD *)(a1 + 0xB1);
              v46 = 0;
              v47 = *(int **)(a1 + 0xAC);
            }
            else
            {
              v44 = 0;
              v81 = v80;
              switch ( (_BYTE)v80 )
              {
                case 5:
                  v46 = 3;
                  v48 = *a4;
                  v49 = a4[1];
                  v50 = a4[2];
                  *(_DWORD *)(a1 + 0xC8) = *a4;
                  v42 = (int *)(a1 + 0xC8);
                  *(_DWORD *)(a1 + 0xCC) = a4[1];
                  *(_DWORD *)(a1 + 0xD0) = a4[2];
                  *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 7;
                  *(_DWORD *)(*(_DWORD *)(a1 + 0xAC) + 0x5E) = 0;
                  break;
                case 2:
                  v47 = a4;
                  v46 = 1;
                  *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 3;
                  *(_DWORD *)(*(_DWORD *)(a1 + 0xAC) + 0x5E) = a4;
                  break;
                case 4:
                  v46 = 2;
                  v47 = a4;
                  *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 1;
                  v22 = *a4;
                  if ( *a4 == dword_D3660 )
                  {
                    v22 = a4[1];
                  }
                  *(_DWORD *)(*(_DWORD *)(a1 + 0xAC) + 0x5E) = v22;
                  break;
              }
              v23 = *(_DWORD *)(a1 + 0xAC);
              *(_BYTE *)(v23 + 0x62) = v44;
              *(_DWORD *)(v23 + 0x63) = v45;
              *(_BYTE *)(v23 + 0x67) = v46;
              v23 += 0x62;
              *(_DWORD *)(v23 + 6) = v47;
              *(_DWORD *)(v23 + 0xA) = v48;
              *(_DWORD *)(v23 + 0xE) = v49;
              *(_DWORD *)(v23 + 0x12) = v50;
              *(_DWORD *)(v23 + 0x16) = v51;
              *(_DWORD *)(v23 + 0x1A) = v52;
              *(_DWORD *)(v23 + 0x1E) = v53;
              *(_DWORD *)(v23 + 0x22) = v54;
              sub_49B3C(*(_DWORD *)(a1 + 0xAC), 0);
              v24 = *(_DWORD *)(a1 + 0xAC);
              if ( (*(_BYTE *)(v24 + 0x84) & 8) == 0 )
              {
                *(_DWORD *)(a1 + 0xBF) = v24;
                *(_DWORD *)(a1 + 0xC4) = v42;
                *(_BYTE *)(a1 + 0xC3) = v81;
              }
            }
          }
          else if ( v41 == 2 )
          {
            if ( *(_BYTE *)(a1 + 0xB0) != 2 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x33B);
            }
            if ( (_BYTE)v80 != 3 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x33C);
            }
          }
          *(_BYTE *)(a1 + 0xB9) = 1;
          sub_12140(a1);
          *(_BYTE *)(a1 + 0xB0) = 0;
          v25 = *(_DWORD *)(a1 + 0xA7);
          *(_DWORD *)(a1 + 0xB1) = 0;
          (*(void (__fastcall **)(int, _DWORD))(v25 + 0xC))(a1, 0);
          sub_12674(*(_DWORD *)(a1 + 0xBB));
          return 0;
        }
      }
      v18 = 0;
      v19 = *(_BYTE *)(a1 + 0xAB);
      *(_DWORD *)(a1 + 0xBF) = 0;
      if ( v19 == 3 && (_BYTE)v80 )
      {
        v70 = 0;
        v71 = 0;
        v72 = 0;
        *(_DWORD *)(&v44 + 0xFFFFFFF6 + 0x70) = 0;
        *(_DWORD *)(&v44 + 0xFFFFFFF6 + 0x74) = 0;
        *(_DWORD *)(&v44 + 0xFFFFFFF6 + 0x78) = 0;
        v66 = 1;
        v67 = *(_DWORD *)(a1 + 0xB1);
        v68 = 5;
        if ( (unsigned __int8)v80 < 3u )
        {
          if ( (_BYTE)v80 == 2 )
          {
            v68 = 1;
            v69 = a4;
          }
        }
        else if ( (unsigned __int8)v80 <= 3u )
        {
          v69 = a4;
          v68 = 0;
        }
        else if ( (_BYTE)v80 == 4 && *(_BYTE *)(a1 + 0xB0) == 1 )
        {
          v69 = a4;
          v68 = 2;
        }
        v20 = *(_DWORD *)(a1 + 0xAC);
        *(_BYTE *)(v20 + 0x62) = v66;
        *(_DWORD *)(v20 + 0x63) = v67;
        *(_BYTE *)(v20 + 0x67) = v68;
        v20 += 0x62;
        *(_DWORD *)(v20 + 6) = v69;
        *(_DWORD *)(v20 + 0xA) = v70;
        *(_DWORD *)(v20 + 0xE) = v71;
        *(_DWORD *)(v20 + 0x12) = v72;
        *(_DWORD *)(v20 + 0x16) = v73;
        *(_DWORD *)(v20 + 0x1A) = v74;
        *(_DWORD *)(v20 + 0x1E) = v75;
        *(_DWORD *)(v20 + 0x22) = v76;
        sub_49B3C(*(_DWORD *)(a1 + 0xAC), 0);
        if ( (*(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x84) & 1) == 0 )
        {
          return v18;
        }
      }
      else
      {
        if ( *(_BYTE *)(a1 + 0xAB) != 2 )
        {
          return v18;
        }
        if ( (_BYTE)v80 != 3 )
        {
          return v18;
        }
        v78 = a4;
        v21 = (int **)(*(_DWORD *)(a1 + 0xAC) + 0x6B);
        v77 = *(int **)(a1 + 0xB1);
        *v21++ = v77;
        *v21 = v78;
        v21[1] = v79;
        sub_3676C(*(_DWORD *)(a1 + 0xAC), 0);
        if ( (*(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x73) & 1) == 0 )
        {
          return v18;
        }
      }
      return 0xFFFFFFFF;
    }
    if ( a2 < 0xDu )
    {
      if ( a2 != 1 )
      {
        return sub_2F424(a1, a2, v80, (int)a4);
      }
      v8 = sub_56DA8((int)&V_Type3_stru_10AE70, "BatModeWnd", 0);
      *(_DWORD *)(a1 + 0xBB) = v8;
      if ( !v8 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x184);
      }
      v9 = sub_56DA8((int)&V_Type3_stru_10AE70, "BatListWnd", 0);
      *(_DWORD *)(a1 + 0xB5) = v9;
      if ( !v9 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x187);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xB5) + 0xAB) = 0;
      sub_2E9CC(*(_DWORD *)(a1 + 0xB5), 0);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xB5) + 0xC5) = 0;
      sub_2ED4C(*(_DWORD *)(a1 + 0xB5));
      *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
      v10 = dword_D3660;
      *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
      *(_DWORD *)(a1 + 0xBF) = 0;
      sub_1D734(v10, a1 + 0xDA);
      *(_WORD *)(a1 + 0xD4) = 0;
      *(_DWORD *)(a1 + 0x104) = 0;
      *(_DWORD *)(a1 + 0xD6) = v11;
      if ( ((1 << byte_104BEA) & (*(unsigned __int8 *)(v10 + 0x15) | *(unsigned __int8 *)(v10 + 0x14))) != 0 )
      {
        *(_BYTE *)(a1 + 0xB9) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 0xB9) = 4;
      }
      *(_BYTE *)(a1 + 0xBA) = 0;
      for ( i = 0; ; ++i )
      {
        v13 = i;
        if ( i >= *(_DWORD *)(a1 + 0xD6) )
        {
          break;
        }
        *(_DWORD *)(a1 + 4 * v13 + 0xE8) = 0xFFFFFFFF;
      }
      sub_2D258(a1, a2);
      sub_12140(a1);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      return 0;
    }
    if ( a2 <= 0xDu )
    {
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      return 0;
    }
    if ( a2 != 0x320 )
    {
      return sub_2F424(a1, a2, v80, (int)a4);
    }
    *(_BYTE *)(a1 + 0xB0) = 0;
    v16 = v80;
    *(_DWORD *)(a1 + 0xB1) = 0;
    *(_BYTE *)(a1 + 0xAB) = v16;
    v17 = *(_BYTE *)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xAC) = a4;
    if ( v17 < 2u )
    {
      if ( !v17 )
      {
        *(_BYTE *)(a1 + 0xB9) = 1;
        goto LABEL_55;
      }
    }
    else
    {
      if ( v17 <= 2u )
      {
        *(_BYTE *)(a1 + 0xB9) = 3;
        goto LABEL_55;
      }
      if ( v17 == 3 )
      {
        *(_BYTE *)(a1 + 0xB9) = 2;
        goto LABEL_55;
      }
    }
    Q_AssertLogBreakExit_sub_261A8(0, "..\\batcon.cpp", 0x263);
LABEL_55:
    sub_12140(a1);
    (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
    return 0xFFFFFFFF;
  }
  if ( a2 <= 0x327u )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4
      && ((1 << byte_104BEA) & (*(unsigned __int8 *)(dword_D3660 + 0x14) | *(unsigned __int8 *)(dword_D3660 + 0x15))) != 0
      && !*(_DWORD *)(a1 + 0x104)
      && !*(_WORD *)(a1 + 0xD4) )
    {
      sub_1229C(a1, 0xFFFFFFFF);
      return 0;
    }
    return 0;
  }
  if ( a2 < 0x32Bu )
  {
    if ( a2 < 0x329u )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4
        && ((1 << byte_104BEA) & (*(unsigned __int8 *)(dword_D3660 + 0x15) | *(unsigned __int8 *)(dword_D3660 + 0x14))) != 0
        && !*(_DWORD *)(a1 + 0x104)
        && !*(_WORD *)(a1 + 0xD4) )
      {
        *(_WORD *)(a1 + 0xD4) = 0xFFFF;
        *(_DWORD *)(a1 + 0x104) = 0xFFFFFFFF;
        sub_1229C(a1, 0xFFFFFFFF);
        return 0;
      }
    }
    else
    {
      if ( a2 > 0x329u )
      {
        if ( *(_BYTE *)(a1 + 0xBA) )
        {
          *(_BYTE *)(a1 + 0xBA) = 0;
          sub_11BA4(a1);
        }
        return 0xFFFFFFFF;
      }
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4 )
      {
        v14 = *(_DWORD *)(a1 + 0xBF);
        if ( v14 )
        {
          if ( *(_BYTE *)(v14 + 0x58) == 4 && dword_D3660 == *(_DWORD *)(*(_DWORD *)(a1 + 0xBF) + 0x59) )
          {
            *(_BYTE *)(a1 + 0xAB) = 3;
            *(_BYTE *)(a1 + 0xB0) = 0;
            v15 = *(_DWORD *)(a1 + 0xBF);
            *(_DWORD *)(a1 + 0xB1) = 0;
            *(_DWORD *)(a1 + 0xAC) = v15;
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 8))();
            return 0;
          }
        }
      }
    }
    return 0;
  }
  if ( a2 <= 0x32Bu )
  {
    if ( *(_BYTE *)(a1 + 0xBA) != 1 )
    {
      *(_BYTE *)(a1 + 0xBA) = 1;
      sub_11BA4(a1);
    }
    return 0xFFFFFFFF;
  }
  if ( a2 < 0x32Du )
  {
    if ( *(_BYTE *)(a1 + 0xBA) != 4 )
    {
      *(_BYTE *)(a1 + 0xBA) = 4;
      sub_11BA4(a1);
    }
    return 0xFFFFFFFF;
  }
  if ( a2 <= 0x32Du )
  {
    if ( *(_BYTE *)(a1 + 0xBA) != 5 )
    {
      *(_BYTE *)(a1 + 0xBA) = 5;
      sub_11BA4(a1);
    }
    return 0xFFFFFFFF;
  }
  if ( a2 < 0x1C01u )
  {
    return sub_2F424(a1, a2, v80, (int)a4);
  }
  if ( a2 <= 0x1C01u )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4 )
    {
      v26 = *(_BYTE *)(a1 + 0xB9) - 1;
      *(_DWORD *)(a1 + 0xBF) = 0;
      switch ( v26 )
      {
        case 0:
        case 3:
          if ( a4 == (int *)4 )
          {
            if ( sub_2ECA4(*(_DWORD *)(a1 + 0xB5), v80) >= 0 )
            {
              *(_BYTE *)(a1 + 0xAB) = 3;
              *(_BYTE *)(a1 + 0xB9) = 2;
            }
            else
            {
              *(_BYTE *)(a1 + 0xAB) = 2;
              *(_BYTE *)(a1 + 0xB9) = 3;
            }
            sub_12140(a1);
            v27 = sub_2ED14(*(_DWORD *)(a1 + 0xB5), v80);
            v43 = 0;
            v28 = *(_DWORD *)(a1 + 0xBB);
            *(_DWORD *)(a1 + 0xAC) = v27;
            sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v28 + 0x41), 0x53, 0, v43);
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
            result = 0xFFFFFFFF;
          }
          else
          {
            v29 = sub_2ED14(*(_DWORD *)(a1 + 0xB5), v80);
            v30 = sub_12AE4(*(_DWORD *)(a1 + 0xBB), v29);
            if ( !v30 )
            {
              return 0xFFFFFFFF;
            }
            sub_17E88(*(_DWORD *)(a1 + 0xBB), v30);
            sub_18C2C(*(_DWORD *)(a1 + 0xBB), 0);
            result = 0xFFFFFFFF;
          }
          break;
        case 1:
          if ( sub_2ECA4(*(_DWORD *)(a1 + 0xB5), v80) )
          {
            return 0xFFFFFFFF;
          }
          v31 = (char *)sub_2ED14(*(_DWORD *)(a1 + 0xB5), v80);
          v32 = *v31;
          v33 = v31;
          if ( *v31 == (char)0xFF )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x39C);
          }
          v34 = (char *)&unk_107020 + 0x6A * v32;
          if ( (*(_WORD *)(v34 + 0x33) & 0x80) != 0 )
          {
            return 0xFFFFFFFF;
          }
          v35 = *(_WORD *)(v34 + 0x33) & 0x20;
          if ( (_BYTE)v35 )
          {
            sub_49A8C(*(_DWORD *)(a1 + 0xAC), v33);
          }
          else
          {
            *(_BYTE *)(a1 + 0xB0) = 1;
            *(_DWORD *)(a1 + 0xB1) = v33;
            if ( (*(_WORD *)(v34 + 0x33) & 0x40) != 0 )
            {
              v59 = v35;
              v60 = v35;
              v61 = v35;
              v62 = v35;
              v63 = v35;
              v64 = v35;
              v55 = 1;
              v56 = *(_DWORD *)(a1 + 0xB1);
              v57 = 5;
              v36 = *(_DWORD *)(a1 + 0xAC) + 0x62;
              *(_BYTE *)v36 = 1;
              *(_DWORD *)(v36 + 1) = v56;
              *(_BYTE *)(v36 + 5) = v57;
              *(_DWORD *)(v36 + 6) = v58;
              *(_DWORD *)(v36 + 0xA) = v59;
              *(_DWORD *)(v36 + 0xE) = v60;
              *(_DWORD *)(v36 + 0x12) = v61;
              *(_DWORD *)(v36 + 0x16) = v62;
              *(_DWORD *)(v36 + 0x1A) = v63;
              *(_DWORD *)(v36 + 0x1E) = v64;
              *(_DWORD *)(v36 + 0x22) = v65;
              *(_BYTE *)(a1 + 0xB0) = 0;
              *(_DWORD *)(a1 + 0xB1) = 0;
              *(_BYTE *)(a1 + 0xB9) = 1;
              sub_12140(a1);
              sub_12674(*(_DWORD *)(a1 + 0xBB));
            }
            else
            {
              sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(*(_DWORD *)(a1 + 0xBB) + 0x41), 0x51, 0, v35);
            }
          }
          (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
          return 0xFFFFFFFF;
        case 2:
          if ( sub_2ECA4(*(_DWORD *)(a1 + 0xB5), v80) )
          {
            return 0xFFFFFFFF;
          }
          v37 = sub_2ED14(*(_DWORD *)(a1 + 0xB5), v80);
          v43 = 0;
          *(_BYTE *)(a1 + 0xB0) = 2;
          v38 = *(_DWORD *)(a1 + 0xBB);
          *(_DWORD *)(a1 + 0xB1) = v37;
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v38 + 0x41), 0x51, 0, v43);
          return 0xFFFFFFFF;
        default:
          return 0xFFFFFFFF;
      }
      return result;
    }
    return 0;
  }
  if ( a2 != 0x1C02 )
  {
    return sub_2F424(a1, a2, v80, (int)a4);
  }
  switch ( *(_BYTE *)(a1 + 0xB9) )
  {
    case 2:
      v39 = (char *)sub_2ED14(*(_DWORD *)(a1 + 0xB5), v80);
      sub_56B60((int)&V_Type3_stru_10AE70, 5, *v39, 4);
      result = 0xFFFFFFFF;
      break;
    case 3:
      v40 = *(unsigned __int8 *)(sub_2ED14(*(_DWORD *)(a1 + 0xB5), v80) + 1);
      sub_56B60((int)&V_Type3_stru_10AE70, 5, v40, 5);
      goto LABEL_122;
    default:
LABEL_122:
      result = 0xFFFFFFFF;
      break;
  }
  return result;
}
// 10C71: variable 'v11' is possibly undefined
// D3660: using guessed type int dword_D3660;

//----- (00011870) --------------------------------------------------------
void __fastcall sub_11870(int a1, int edx0)
{
  int v3; // esi
  char v4; // ah
  int v5; // esi
  int v6; // edx
  int v7; // ebx
  int v8; // eax
  char v9; // bl
  int v10; // eax
  __int16 v11; // ax
  unsigned __int8 v12; // cl
  int v13; // [esp-20h] [ebp-A0h]
  char s[40]; // [esp+0h] [ebp-80h] BYREF
  T_Type5 v15; // [esp+28h] [ebp-58h] BYREF
  T_Type5 v16; // [esp+3Ch] [ebp-44h] BYREF
  T_Type5 a2; // [esp+50h] [ebp-30h] BYREF
  __int16 v18; // [esp+64h] [ebp-1Ch]
  __int16 v19; // [esp+68h] [ebp-18h]

  if ( edx0 != 0x1C01 )
  {
    sub_11BA4(a1);
  }
  a2.a = *(P_Type6 *)(a1 + 4);
  a2.rect.x1 = 0x1D2;
  a2.rect.y1 = 0;
  a2.rect.x2 = 0x27F;
  a2.rect.y2 = 0x8D;
  sub_5E9D0(&a2, 0);
  v3 = 0xA;
  v4 = *(_BYTE *)(a1 + 0xB9);
  if ( v4 == 2 || v4 == 3 )
  {
    v5 = *(_DWORD *)(a1 + 0xB5) + 4;
    v15.a = *(P_Type6 *)v5;
    v5 += 4;
    v15.rect.x1 = *(_DWORD *)v5;
    v5 += 4;
    v15.rect.y1 = *(_DWORD *)v5;
    v5 += 4;
    v15.rect.x2 = *(_DWORD *)v5;
    v15.rect.y2 = *(_DWORD *)(v5 + 4);
    v15.rect.y1 = 7;
    v15.rect.y2 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) + 8;
    if ( *(_BYTE *)(a1 + 0xB9) == 2 )
    {
      v6 = *(_DWORD *)(a1 + 0xAC);
      v7 = 0;
      v3 = 0xB;
    }
    else
    {
      v7 = 0xFFFFFFFF;
      v6 = *(_DWORD *)(a1 + 0xAC);
      v3 = 0x13;
    }
    sub_10010(&v15, v6, v7, 0);
  }
  v8 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  sub_5CB3C(&a2, v8, v3, 0, 0);
  sub_2D218((_DWORD *)a1);
  sub_552CC(&V_Type3_stru_10AE70, &a2);
  v9 = *(_BYTE *)(a1 + 0xB9);
  if ( v9 == 1 || v9 == 4 )
  {
    v16.a = *(P_Type6 *)(a1 + 4);
    v16.rect.x1 = 0x1DA;
    v16.rect.y1 = 7;
    v16.rect.x2 = 0x278;
    v16.rect.y2 = 0x25;
    v13 = *(_DWORD *)dword_D3660;
    v10 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(*(_DWORD *)(a1 + 0xBB) + 0x19C8));
    sub_5D631(
      &v16,
      v10,
      v13,
      0xF,
      0xF,
      (int)byte_D8DA0,
      0,
      (void (__noreturn *)())0x3333,
      (void (__noreturn *)())0x3333,
      0);
    v11 = 0;
    v19 = 0xF3;
    v18 = 0xFFFF;
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      while ( 1 )
      {
        if ( *(int *)((char *)&dword_A2F75 + 0x1EE * v11) != 0xFFFFFFFF )
        {
          v12 = *(_BYTE *)(dword_D3660 + 0x14);
          if ( v12 )
          {
            if ( ((1 << v11) | v12) == 1 << v11
              || dword_D3660 == *(int *)((char *)&dword_A2F79 + 0x1EE * v11) && ((1 << v11) & v12) != 0 )
            {
              break;
            }
          }
        }
        if ( ++v11 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_20;
        }
      }
      v18 = v11;
    }
LABEL_20:
    if ( v18 != 0xFFFFFFFF )
    {
      v19 = 4 * (unsigned __int8)byte_A2F74[0x1EE * v11] + 0x13;
      sub_53E38(&v16, 0x8D, 3, v11);
    }
    sprintf(s, "%s", (const char *)(dword_D3660 + 0x1C));
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v16;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x28, 5, s, 0, v19, 0xFF, 0x6C);
    sprintf(s, "%s", &byte_D84C4[0x14 * *(_DWORD *)dword_D3660]);
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x302E] = v16;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x28, 0x12, s, 0, 0xF3, 0xFF, 0x6C);
    sub_552CC(&V_Type3_stru_10AE70, &v16);
  }
}
// A2F75: using guessed type int dword_A2F75;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// D3660: using guessed type int dword_D3660;
// 11870: using guessed type _DWORD var_58[2];

//----- (00011BA4) --------------------------------------------------------
int __fastcall sub_11BA4(int a1)
{
  int v2; // ebp
  int v3; // edi
  unsigned __int16 v4; // ax
  __int16 i; // di
  int v6; // edx
  unsigned __int16 v7; // ax
  char *v9; // edi
  int v10; // ebx
  char v11; // ah
  int v12; // ebp
  char v13; // al
  char *v14; // ebp
  unsigned __int16 v15; // dx
  int v16; // edi
  int v17; // edx
  int v18; // ebp
  __int16 v19; // di
  int v20; // ebp
  int v21; // edx
  unsigned __int16 v22; // ax
  __int16 k; // di
  int v24; // edx
  unsigned __int16 v25; // ax
  int v26[107]; // [esp+0h] [ebp-39Ch] BYREF
  int v27[107]; // [esp+1ACh] [ebp-1F0h] BYREF
  int v28; // [esp+358h] [ebp-44h]
  int v29; // [esp+35Ch] [ebp-40h]
  int v30; // [esp+360h] [ebp-3Ch] BYREF
  int v31; // [esp+364h] [ebp-38h] BYREF
  int v32; // [esp+368h] [ebp-34h] BYREF
  int v33; // [esp+36Ch] [ebp-30h]
  int v34; // [esp+370h] [ebp-2Ch]
  int v35; // [esp+374h] [ebp-28h]
  int v36; // [esp+378h] [ebp-24h]
  __int16 v37; // [esp+37Ch] [ebp-20h]
  __int16 j; // [esp+380h] [ebp-1Ch]

  sub_2ED4C(*(_DWORD *)(a1 + 0xB5));
  switch ( *(_BYTE *)(a1 + 0xB9) )
  {
    case 1:
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10010);
      v37 = 0;
      v2 = sub_1D794((__int16 *)dword_D3660, v26);
      while ( v37 < v2 )
      {
        v3 = v26[v37];
        if ( *(_BYTE *)(v3 + 0x58) == 4 )
        {
          if ( *(__int16 *)(v3 + 0x56) >= 7 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x4AC);
          }
          if ( *(_WORD *)(v3 + 0x56) == (unsigned __int8)byte_104BEA )
          {
            v4 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v3, 0xFFFFFFFF, 0);
            sub_2EC50(*(_DWORD *)(a1 + 0xB5), v4, v37);
          }
        }
        ++v37;
      }
      for ( i = 0; i < *(__int16 *)(dword_D3660 + 0x5A); ++i )
      {
        v6 = *(_DWORD *)(dword_D3660 + 4 * i + 0x46);
        if ( *(_BYTE *)(v6 + 0x57) == (_BYTE)byte_104BEA )
        {
          v7 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v6, 0xFFFFFFFF, 0);
          sub_2EC50(*(_DWORD *)(a1 + 0xB5), v7, i | 0x80000000);
        }
      }
      goto LABEL_15;
    case 2:
      if ( *(_BYTE *)(a1 + 0xAB) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x4D8);
      }
      if ( !*(_DWORD *)(a1 + 0xAC) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x4D9);
      }
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10668);
      v33 = *(_DWORD *)(a1 + 0xAC);
      v29 = *(_DWORD *)(v33 + 0x88);
      if ( *(_WORD *)(v33 + 0x56) == (unsigned __int8)byte_104BEA || sub_4AAEC(v33, (unsigned __int8)byte_104BEA) == 2 )
      {
        v9 = (char *)(v33 + 0xAB);
        LOWORD(v36) = 0;
        while ( (__int16)v36 < *(_DWORD *)(v33 + 0x15A) )
        {
          if ( *v9 != (char)0xFF )
          {
            if ( (v12 = 0x6A * *v9, v13 = byte_107052[v12],
                                    v14 = (char *)&unk_107020 + v12,
                                    v13 == *(_BYTE *)(a1 + 0xBA))
              && (*(_WORD *)(v14 + 0x33) & 0x80) == 0
              || *(_BYTE *)(a1 + 0xBA) == 4 && (*(_WORD *)(v14 + 0x33) & 0x80) != 0 )
            {
              v15 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), v9, 0xFFFFFFFF, 0);
              v28 = *(__int16 *)(v33 + 0x56);
              v10 = 0;
              if ( (unsigned __int8)byte_104BEA == v28 )
              {
                if ( (*(_WORD *)(v14 + 0x33) & 0x20) == 0 )
                {
                  if ( !*(_DWORD *)(v14 + 0x42) || *(_WORD *)(v9 + 1) )
                  {
                    if ( v29 < *(_DWORD *)(v14 + 0x36) )
                    {
                      v10 = 3;
                    }
                  }
                  else
                  {
                    v10 = 2;
                  }
                }
              }
              else
              {
                v10 = 1;
              }
              if ( (*(_WORD *)(v14 + 0x33) & 0x80) != 0 )
              {
                v10 = *v9 + 0x1F4;
              }
              v11 = v14[0x32];
              if ( v11 == 2 )
              {
                v10 = *v9 + 0x258;
              }
              else if ( v11 == 4 )
              {
                v10 = *v9 + 0x2BC;
              }
              sub_2EC50(*(_DWORD *)(a1 + 0xB5), v15, v10);
            }
          }
          v9 += 7;
          LOWORD(v36) = v36 + 1;
        }
      }
      goto LABEL_15;
    case 3:
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10878);
      v16 = *(_DWORD *)(a1 + 0xAC);
      if ( *(_BYTE *)(a1 + 0xAB) != 2 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x51F);
      }
      if ( !v16 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x520);
      }
      if ( (_BYTE)byte_104BEA == *(_BYTE *)(v16 + 0x57) )
      {
        for ( j = 0; j < (int)*(unsigned __int16 *)(v16 + 0x1A); ++j )
        {
          v17 = 4 * j + *(_DWORD *)(v16 + 0x10);
          v34 = 4 * j;
          v18 = 0;
          if ( (*(_WORD *)(v17 + 2) & 1) != 0 && (word_103FA2[0x14 * *(unsigned __int8 *)(v17 + 1)] & 4) != 0 )
          {
            v35 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v17, 0xFFFFFFFF, 0);
            sub_366C8(v16, *(_BYTE *)(v34 + *(_DWORD *)(v16 + 0x10) + 1), &v30, &v31, &v32);
            if ( v32 && !((int)*(unsigned __int16 *)(v34 + *(_DWORD *)(v16 + 0x10) + 2) >> 8) )
            {
              v18 = 1;
            }
            sub_2EC50(*(_DWORD *)(a1 + 0xB5), v35, v18);
          }
        }
      }
      goto LABEL_15;
    case 4:
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10010);
      v19 = 0;
      v20 = sub_1D794((__int16 *)dword_D3660, v27);
      while ( v19 < v20 )
      {
        v21 = v27[v19];
        if ( *(_BYTE *)(v21 + 0x58) == 4 && *(_WORD *)(v21 + 0x56) != (unsigned __int8)byte_104BEA )
        {
          v22 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v21, 0xFFFFFFFF, 0);
          sub_2EC50(*(_DWORD *)(a1 + 0xB5), v22, v19);
        }
        ++v19;
      }
      for ( k = 0; k < *(__int16 *)(dword_D3660 + 0x5A); ++k )
      {
        v24 = *(_DWORD *)(dword_D3660 + 4 * k + 0x46);
        if ( (_BYTE)byte_104BEA != *(_BYTE *)(v24 + 0x57) )
        {
          v25 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v24, 0xFFFFFFFF, 0);
          sub_2EC50(*(_DWORD *)(a1 + 0xB5), v25, k | 0x80000000);
        }
      }
LABEL_15:
      sub_2F1D8(*(_DWORD *)(a1 + 0xB5), (int)sub_10A14);
      sub_2F1E0(*(_DWORD *)(a1 + 0xB5));
      break;
    default:
      return (*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xB5) + 0xA7) + 0xC))();
  }
  return (*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xB5) + 0xA7) + 0xC))();
}
// D3660: using guessed type int dword_D3660;
// 103FA2: using guessed type __int16 word_103FA2[];
// 11BA4: using guessed type int var_39C[107];
// 11BA4: using guessed type int var_1F0[107];

//----- (00012140) --------------------------------------------------------
int __fastcall sub_12140(int a1)
{
  __int16 i; // si
  unsigned int v3; // edx
  char v4; // ah
  __int16 j; // bx
  int v6; // eax
  int result; // eax
  int v8; // eax
  unsigned int v9; // [esp+4h] [ebp-1Ch]

  for ( i = 0; i < *(__int16 *)(a1 + 0x6B); ++i )
  {
    if ( !strcmp((const char *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * i) + 0x20), "My^Items") )
    {
      break;
    }
  }
  if ( i >= *(__int16 *)(a1 + 0x6B) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x58C);
  }
  v3 = 0xFFFFFFFF;
  v4 = *(_BYTE *)(a1 + 0xB9);
  v9 = 0;
  if ( v4 == 2 )
  {
    v3 = 0;
  }
  else if ( v4 == 3 )
  {
    v9 = 0xFFFFFFFF;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= 9 )
    {
      break;
    }
    if ( v9 )
    {
      v6 = i + j;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v6) + 0x35) = 0;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v6) + 0x39) = 0;
    }
    else
    {
      v8 = i + j;
      if ( j >= 5 )
      {
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x35) = ~v3;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x39) = ~v3;
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x35) = v3;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x39) = v3;
      }
    }
  }
  return result;
}

//----- (00012238) --------------------------------------------------------
int __fastcall sub_12238(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 0xAB) == 3 )
  {
    sub_49B3C(*(_DWORD *)(a1 + 0xAC), 1);
  }
  else if ( *(_BYTE *)(a1 + 0xAB) == 2 )
  {
    sub_3676C(*(_DWORD *)(a1 + 0xAC), 1);
  }
  *(_BYTE *)(a1 + 0xAB) = 0;
  *(_DWORD *)(a1 + 0xAC) = 0;
  if ( a2 == 0xFFFFFFFF )
  {
    sub_11BA4(a1);
  }
  return sub_1229C(a1, a2);
}
// 1229C: using guessed type int __fastcall sub_1229C(_DWORD, _DWORD);

//----- (0001229C) --------------------------------------------------------
void __fastcall sub_1229C(int a1, int a2)
{
  __int16 *v3; // esi
  _BYTE v4[5]; // [esp+0h] [ebp-1Ch] BYREF

  v3 = (__int16 *)dword_D3660;
  while ( (__int16)++*(_WORD *)(a1 + 0xD4) < *(_DWORD *)(a1 + 0xD6) || sub_12368(a1, a2) )
  {
    v4[0] = 0;
    *(_DWORD *)(a1 + 4 * *(__int16 *)(a1 + 0xD4) + 0xE8) = sub_406C4(
                                                             (unsigned __int8 *)&byte_A2F72[0x1EE
                                                                                          * *(__int16 *)(a1 + 2 * *(__int16 *)(a1 + 0xD4) + 0xDA)],
                                                             v3,
                                                             (int)v4);
    if ( v4[0] )
    {
      *(_DWORD *)(a1 + 0xAB) = *(_DWORD *)v4;
      *(_BYTE *)(a1 + 0xAF) = v4[4];
      if ( v4[0] == 3 )
      {
        sub_49B3C(*(int *)&v4[1], 0);
      }
      else
      {
        sub_3676C(*(int *)&v4[1], 0);
      }
      if ( a2 == 0xFFFFFFFF )
      {
        sub_12674(*(_DWORD *)(a1 + 0xBB));
      }
      else
      {
        sub_12238(a1, a2);
      }
      return;
    }
  }
}
// D3660: using guessed type int dword_D3660;

//----- (00012368) --------------------------------------------------------
unsigned int __fastcall sub_12368(int a1, int a2)
{
  __int16 *v3; // esi
  unsigned int v4; // edi
  __int16 i; // ax
  int v6; // eax
  __int16 v7; // cx
  int v8; // eax
  unsigned __int8 *v9; // eax

  v3 = (__int16 *)dword_D3660;
  v4 = 0;
  if ( *(_DWORD *)(a1 + 0x104) == 0xFFFFFFFF )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 0xD6); ++i )
    {
      if ( *(_DWORD *)(a1 + 4 * i + 0xE8) == 0xFFFFFFFF )
      {
        v4 = 0xFFFFFFFF;
        break;
      }
    }
  }
  v6 = dword_D3660;
  *(_DWORD *)(a1 + 0x104) = v4;
  sub_1D734(v6, a1 + 0xDA);
  *(_WORD *)(a1 + 0xD4) = 0;
  v7 = 0;
  *(_DWORD *)(a1 + 0xD6) = v8;
  while ( v7 < *(_DWORD *)(a1 + 0xD6) )
  {
    v9 = (unsigned __int8 *)&byte_A2F72[0x1EE * *(__int16 *)(a1 + 2 * v7++ + 0xDA)];
    sub_3B56C(v9, v3);
  }
  if ( a2 == 0xFFFFFFFF )
  {
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
  }
  return v4;
}
// 123C0: variable 'v8' is possibly undefined
// D3660: using guessed type int dword_D3660;

//----- (0001240C) --------------------------------------------------------
unsigned int __fastcall sub_1240C(int a1, int a2)
{
  sub_2FBA4(a1, a2);
  return sub_53E38((P_Type5)(a1 + 4), 3, 3, (unsigned __int8)byte_104BEA);
}

//----- (00012440) --------------------------------------------------------
char *__fastcall sub_12440(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 0xA);
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return (char *)v1 + 0xFFFFFFEA;
}

//----- (00012480) --------------------------------------------------------
int __fastcall sub_12480(float *a1, float *a2, int a3, int a4, float a5)
{
  double v6; // st7
  double v7; // st7
  float v9; // [esp+8h] [ebp-80h] BYREF
  float v10; // [esp+Ch] [ebp-7Ch]
  float v11; // [esp+10h] [ebp-78h]
  float v12; // [esp+14h] [ebp-74h] BYREF
  float v13; // [esp+18h] [ebp-70h]
  float v14; // [esp+1Ch] [ebp-6Ch]
  int v15[3]; // [esp+20h] [ebp-68h] BYREF
  float v16; // [esp+2Ch] [ebp-5Ch]
  int v17; // [esp+30h] [ebp-58h]
  int v18; // [esp+34h] [ebp-54h]
  float v19; // [esp+38h] [ebp-50h]
  float v20; // [esp+3Ch] [ebp-4Ch]
  float v21; // [esp+40h] [ebp-48h]
  int v22[3]; // [esp+44h] [ebp-44h] BYREF
  float v23; // [esp+50h] [ebp-38h]
  float v24; // [esp+54h] [ebp-34h]
  float v25; // [esp+58h] [ebp-30h]
  float v26; // [esp+5Ch] [ebp-2Ch]
  int v27; // [esp+60h] [ebp-28h]
  int v28; // [esp+64h] [ebp-24h]
  int *v29; // [esp+68h] [ebp-20h]
  float *v30; // [esp+6Ch] [ebp-1Ch]
  int *v31; // [esp+70h] [ebp-18h]
  float *v32; // [esp+74h] [ebp-14h]
  float v33; // [esp+7Ch] [ebp-Ch]
  int v34; // [esp+80h] [ebp-8h]

  v34 = a4;
  v30 = &v12;
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v23 = *a2 - *a1;
  v24 = a2[1] - a1[1];
  v25 = a2[2] - a1[2];
  v12 = v23;
  v13 = v24;
  v14 = v25;
  v33 = sqrt(v24 * v24 + v23 * v23 + v25 * v25);
  if ( a5 >= (double)v33 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
    a1[2] = a2[2];
    return 0xFFFFFFFF;
  }
  else
  {
    v26 = v12 * a5;
    *(float *)&v27 = v13 * a5;
    *(float *)&v28 = a5 * v14;
    v6 = 1.0 / v33;
    v29 = v22;
    *(float *)v22 = v26;
    v22[1] = v27;
    v22[2] = v28;
    v16 = v26 * v6;
    v31 = v15;
    *(float *)&v17 = *(float *)&v27 * v6;
    *(float *)v15 = v16;
    v19 = 0.0;
    v15[1] = v17;
    *(float *)&v18 = v6 * *(float *)&v28;
    v20 = 0.0;
    v15[2] = v18;
    v21 = 0.0;
    v32 = &v9;
    v19 = *a1 + v16;
    v20 = a1[1] + *(float *)&v17;
    v7 = a1[2];
    v9 = v19;
    v21 = v7 + *(float *)&v18;
    v10 = v20;
    v11 = v21;
    *a1 = v19;
    a1[1] = v10;
    a1[2] = v11;
    return 0;
  }
}

//----- (00012618) --------------------------------------------------------
unsigned int __fastcall sub_12618(int a1)
{
  int v2; // esi
  int v3; // eax
  unsigned int v4; // ebp
  int v5; // esi
  unsigned __int16 v7; // [esp+0h] [ebp-1Ch]

  v7 = *(_WORD *)(a1 + 5);
  v2 = *(_DWORD *)(a1 + 7);
  v3 = sub_1B084((unsigned int)&unk_12FC20, v7);
  v4 = 0;
  v5 = v2 + 1;
  if ( v5 >= sub_61223(v3) )
  {
    v4 = 0xFFFFFFFF;
    LOWORD(v5) = 0;
  }
  sub_156C0(a1, v7, v5);
  return v4;
}

//----- (00012674) --------------------------------------------------------
void __fastcall sub_12674(int a1)
{
  *(_BYTE *)(a1 + 0x4F37) = 0xFF;
  *(_DWORD *)(a1 + 0xB3) = 0;
  *(_WORD *)(a1 + 0x5034) = 0;
  *(_BYTE *)(a1 + 0xB7) = 4;
  sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x52, 0, 0, 0);
}

//----- (000126F8) --------------------------------------------------------
int __usercall sub_126F8@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebp>)
{
  unsigned int v4; // edi
  int v5; // edx
  char v6; // al
  char v7; // bl
  int v8; // edx
  int v9; // edx
  int v10; // edx
  __int16 *v11; // ebx
  int v12; // esi
  int i; // ebx
  int v14; // esi
  int j; // ebx
  __int64 v16; // rax
  int v17; // edx
  int v18; // esi

  v4 = 0;
  if ( *(_BYTE *)(a1 + 0x4F37) != 0xFF )
  {
    goto LABEL_42;
  }
  sub_187EC(a1);
  sub_18C2C(a1, 0);
  v5 = *(_DWORD *)(a1 + 0xAB);
  *(_DWORD *)(a1 + 0x4F38) = 0;
  v6 = 0;
  v7 = *(_BYTE *)(v5 + 0xAB);
  v8 = v5 + 0xAB;
  if ( v7 != 3 )
  {
    if ( v7 != 2 )
    {
      goto LABEL_41;
    }
    v6 = 0x34;
    if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v8 + 1) + 0x6B) + 1) == 0x11 )
    {
      *(_BYTE *)(a1 + 0x4F37) = 3;
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  v9 = *(_DWORD *)(v8 + 1);
  v7 = *(_BYTE *)(v9 + 0x62);
  v10 = v9 + 0x62;
  if ( v7 )
  {
    if ( v7 != 1 )
    {
      goto LABEL_41;
    }
    v6 = **(_BYTE **)(v10 + 1);
    switch ( v6 )
    {
      case '4':
        *(_BYTE *)(a1 + 0x4F37) = 3;
        goto LABEL_41;
      case '7':
        *(_BYTE *)(a1 + 0x4F37) = 4;
        goto LABEL_41;
      case ' ':
        *(_BYTE *)(a1 + 0x4F37) = 5;
        goto LABEL_41;
      case '8':
      case 'J':
        *(_BYTE *)(a1 + 0x4F37) = 6;
        goto LABEL_41;
      case ':':
        *(_BYTE *)(a1 + 0x4F37) = 7;
        goto LABEL_41;
      case '.':
        *(_BYTE *)(a1 + 0x4F37) = 8;
        goto LABEL_41;
      case '<':
        *(_BYTE *)(a1 + 0x4F37) = 9;
        goto LABEL_41;
      case ';':
      case 'D':
        *(_BYTE *)(a1 + 0x4F37) = 0xA;
        goto LABEL_41;
      case '-':
        *(_BYTE *)(a1 + 0x4F37) = 0xB;
        goto LABEL_41;
      case '(':
      case '\'':
        *(_BYTE *)(a1 + 0x4F37) = 0xC;
        goto LABEL_41;
      case '$':
        *(_BYTE *)(a1 + 0x4F37) = 0xD;
        goto LABEL_41;
      case 'H':
        *(_BYTE *)(a1 + 0x4F37) = 0xE;
        goto LABEL_41;
      case '&':
        *(_BYTE *)(a1 + 0x4F37) = 0xF;
        goto LABEL_41;
    }
    if ( (word_107053[0x35 * v6] & 0x40) == 0 )
    {
      *(_BYTE *)(a1 + 0x4F37) = 2;
      goto LABEL_41;
    }
LABEL_40:
    *(_BYTE *)(a1 + 0x4F37) = v7;
    goto LABEL_41;
  }
  *(_BYTE *)(a1 + 0x4F37) = 0;
LABEL_41:
  v11 = (__int16 *)(a1 + 4 * v6);
  sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a1 + 2 * v11[0xD49] + 0x19C6));
  sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a1 + 2 * v11[0xD4A] + 0x19C6));
  sub_50140((int)&unk_10914C, v11[0xDE7]);
  a2 = v11[0xDE8];
  sub_50140((int)&unk_10914C, a2);
LABEL_42:
  v12 = a1;
  for ( i = 0; i < *(__int16 *)(a1 + 0x5034); ++i )
  {
    a2 = *(_DWORD *)(v12 + 0x4F44);
    sub_12B4C(a1, a2);
    v12 += 4;
  }
  switch ( *(_BYTE *)(a1 + 0x4F37) )
  {
    case 0xFF:
      v4 = 0xFFFFFFFF;
      break;
    case 0:
      v4 = sub_12C98(a1, a2, i);
      break;
    case 1:
      v4 = sub_12E88(a1);
      break;
    case 2:
      v4 = sub_12F7C(a1, (int *)a1, a3);
      break;
    case 3:
      v4 = sub_13370(a1, a2, i);
      break;
    case 4:
      v4 = sub_136C4(a1);
      break;
    case 5:
      v4 = sub_1380C(a1);
      break;
    case 6:
      v4 = sub_13C10(a1);
      break;
    case 7:
      v4 = sub_14224(a1);
      break;
    case 8:
      v4 = sub_142D8(a1);
      break;
    case 9:
      v4 = sub_14490(a1);
      break;
    case 0xA:
      v4 = sub_145C0(a1);
      break;
    case 0xB:
      v4 = sub_147CC(a1);
      break;
    case 0xC:
      v4 = sub_14B18(a1, a2, i);
      break;
    case 0xD:
      v4 = sub_15078(a1);
      break;
    case 0xE:
      v4 = sub_15164(a1);
      break;
    case 0xF:
      v4 = sub_152E4(a1, a2, i, a1);
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0xF8);
      break;
  }
  if ( *(_DWORD *)(a1 + 0x5036) == 0xFFFFFFFF )
  {
    v4 = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x5036) = 0;
  }
  sub_18C2C(a1, 1);
  v14 = a1;
  for ( j = 0; j < *(__int16 *)(a1 + 0x5034); ++j )
  {
    sub_12B4C(a1, *(_DWORD *)(v14 + 0x4F44));
    v14 += 4;
  }
  LODWORD(v16) = (*(int (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 1);
  ++*(_DWORD *)(a1 + 0x4F38);
  if ( v4 == 0xFFFFFFFF )
  {
    v17 = *(_DWORD *)(a1 + 0x41);
    *(_BYTE *)(a1 + 0xB7) = 0;
    sub_564C0(&V_Type3_stru_10AE70, v17, 0x52);
    sub_12238(*(_DWORD *)(a1 + 0xAB), 0xFFFFFFFF);
    sub_187EC(a1);
    sub_18C2C(a1, 0);
    *(_BYTE *)(a1 + 0x4F37) = 0xFF;
    v16 = (unsigned int)a1;
    while ( SHIDWORD(v16) < *(__int16 *)(a1 + 0x5034) )
    {
      v18 = *(_DWORD *)(v16 + 0x4F44);
      LODWORD(v16) = v16 + 4;
      ++HIDWORD(v16);
      *(_BYTE *)(v18 + 0x33) &= 1u;
    }
  }
  return v16;
}
// 107053: using guessed type __int16 word_107053[];

//----- (00012AE4) --------------------------------------------------------
int __fastcall sub_12AE4(int a1, int a2)
{
  int v4; // edi
  int v5; // edx
  int v6; // eax

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x122);
  }
  v4 = 0;
  v5 = 0;
  if ( *(int *)(a1 + 0x1D32) > 0 )
  {
    v6 = *(_DWORD *)(a1 + 0x1D2A);
    while ( a2 != *(_DWORD *)(v6 + 1) )
    {
      ++v5;
      v6 += 0x35;
      if ( v5 >= *(_DWORD *)(a1 + 0x1D32) )
      {
        goto LABEL_10;
      }
    }
    v4 = v6;
  }
LABEL_10:
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x12F);
  }
  return v4;
}

//----- (00012B4C) --------------------------------------------------------
void __fastcall sub_12B4C(int a1, int a2)
{
  int v2; // ebx
  int v3; // esi
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  double v8; // st7
  double v9; // st6
  double v10; // st5
  int v11; // [esp+Ch] [ebp-18h]

  if ( *(_BYTE *)a2 == 8 )
  {
    v2 = *(_DWORD *)(a2 + 1);
    if ( *(_WORD *)(a2 + 0x27) >= *(_WORD *)(v2 + 0x27) )
    {
      v3 = *(_DWORD *)(a1 + 8);
      dword_9A240 = v3 + *(__int16 *)(v2 + 0x27);
      v4 = *(__int16 *)(a2 + 0x27);
    }
    else
    {
      v3 = *(__int16 *)(v2 + 0x27);
      dword_9A240 = *(_DWORD *)(a1 + 8) + *(__int16 *)(a2 + 0x27);
      v4 = *(_DWORD *)(a1 + 8);
    }
    dword_9A248 = v3 + v4;
    if ( *(_WORD *)(a2 + 0x29) >= *(_WORD *)(v2 + 0x29) )
    {
      v6 = *(_DWORD *)(a1 + 0xC);
      v7 = *(__int16 *)(v2 + 0x29) + v6;
      v5 = *(__int16 *)(a2 + 0x29) + v6;
      dword_9A244 = v7;
    }
    else
    {
      dword_9A244 = *(__int16 *)(a2 + 0x29) + *(_DWORD *)(a1 + 0xC);
      v5 = *(__int16 *)(v2 + 0x29) + *(_DWORD *)(a1 + 0xC);
    }
    dword_9A24C = v5;
  }
  else
  {
    v11 = *(__int16 *)(a2 + 0x29) + *(_DWORD *)(a1 + 0xC);
    v8 = (double)*(unsigned int *)(a2 + 0xF) * dbl_9017F;
    v9 = (double)(*(__int16 *)(a2 + 0x27) + *(_DWORD *)(a1 + 8));
    dword_9A240 = (int)((double)*(__int16 *)(a2 + 0x13) * v8 + v9);
    v10 = (double)v11;
    dword_9A244 = (int)((double)*(__int16 *)(a2 + 0x15) * v8 + v10);
    dword_9A248 = (int)(v9 + (double)*(__int16 *)(a2 + 0x17) * v8);
    dword_9A24C = (int)(v8 * (double)*(__int16 *)(a2 + 0x19) + v10);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&unk_9A23C);
}
// 9017F: using guessed type double dbl_9017F;
// 9A240: using guessed type int dword_9A240;
// 9A244: using guessed type int dword_9A244;
// 9A248: using guessed type int dword_9A248;
// 9A24C: using guessed type int dword_9A24C;

//----- (00012C98) --------------------------------------------------------
unsigned int __fastcall sub_12C98(int a1, int a2, int a3)
{
  int v4; // edi
  unsigned int v5; // ebp
  char v6; // ah
  int v7; // edi
  int v8; // edi
  char v9; // dl
  int v10; // eax
  int v11; // eax
  int v13; // edi
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  unsigned __int16 v17; // [esp+0h] [ebp-1Ch]

  v4 = *(_DWORD *)(a1 + 0xAB);
  v5 = 0;
  v6 = *(_BYTE *)(v4 + 0xAB);
  v7 = v4 + 0xAB;
  if ( v6 != 3 )
  {
    a3 = 0x16B;
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x16B);
  }
  v8 = *(_DWORD *)(v7 + 1);
  v9 = *(_BYTE *)(v8 + 0x67);
  if ( v9 != 3 && v9 != 1 && v9 != 2 )
  {
    a3 = 0x171;
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x171);
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v10 = sub_12AE4(a1, v8);
    *(_DWORD *)(a1 + 0x4F44) = v10;
    *(_BYTE *)(v10 + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)(v8 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v8 + 0xA2);
    a3 = *(_DWORD *)(v8 + 0xA6);
    *(_DWORD *)(a1 + 0x4F88) = a3;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    if ( *(_DWORD *)(v8 + 0x94) )
    {
      if ( *(_DWORD *)(v8 + 0x88) )
      {
        sub_4FB90((int)&unk_10914C, 7);
      }
    }
  }
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    v17 = 7;
    if ( (*(_BYTE *)(*(_DWORD *)(v8 + 0x68) + 0x23) & 1) != 0 )
    {
      v17 = 8;
    }
    v13 = *(_DWORD *)(a1 + 0x4F3C);
    v14 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a1 + 2 * v17 + 0x19C6));
    v15 = v13 >> 2;
    v16 = sub_61223(v14) - 1;
    if ( v15 <= v16 || v15 > 2 * v16 )
    {
      if ( v15 > 2 * v16 )
      {
        v5 = 0xFFFFFFFF;
        LOWORD(v15) = 0;
      }
    }
    else
    {
      LOWORD(v15) = 2 * v16 - v15;
    }
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), v17, v15);
    ++*(_DWORD *)(a1 + 0x4F3C);
  }
  else if ( sub_12480((float *)(a1 + 0x4F80), (float *)(v8 + 0x78), a3, v8 + 0x62, 20.0) == 0xFFFFFFFF )
  {
    if ( (*(_BYTE *)(v8 + 0x84) & 8) == 0
      || *(_BYTE *)(v8 + 0x67) != 2
      || sub_4960C(v8, *(_DWORD *)(v8 + 0x68)) != 0xFFFFFFFF )
    {
      return 0xFFFFFFFF;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
    *(_WORD *)(a1 + 0x5034) = 2;
    v11 = sub_12AE4(a1, *(_DWORD *)(v8 + 0x68));
    *(_DWORD *)(a1 + 0x4F3C) = 1;
    *(_DWORD *)(a1 + 0x4F48) = v11;
  }
  return v5;
}

//----- (00012E88) --------------------------------------------------------
unsigned int __fastcall sub_12E88(int a1)
{
  int v2; // ebp
  int v3; // edi
  char v4; // ah
  int v5; // ebp
  int v6; // eax
  char v7; // bl
  _BYTE *v8; // edx
  int v9; // eax
  int v10; // ebp

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x1BA);
  }
  v6 = *(_DWORD *)(v5 + 1);
  v7 = **(_BYTE **)(v6 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v8 = *(_BYTE **)(a1 + 0x1D2A);
    *(_WORD *)(a1 + 0x5034) = 1;
    v8 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *v8 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) = 0x12;
    v9 = v6 + 0x9E;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)v9;
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v9 + 4);
    v10 = a1 + 4 * v7;
    *(float *)(a1 + 0x4F88) = *(float *)(v9 + 8);
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), *(_WORD *)(v10 + 0x1A92), 0);
    sub_4FB90((int)&unk_10914C, *(_WORD *)(v10 + 0x1BCE));
  }
  if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618(*(_DWORD *)(a1 + 0x4F44)) == 0xFFFFFFFF )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}

//----- (00012F7C) --------------------------------------------------------
int __usercall sub_12F7C@<eax>(int a1@<eax>, int *a2@<ecx>, int a3@<ebp>)
{
  unsigned __int8 *v4; // edx
  int v5; // ebx
  int v6; // ebp
  int *v7; // ebp
  _DWORD *v8; // edi
  int v9; // ebp
  char v10; // al
  _BYTE *v11; // eax
  int v12; // edi
  __int16 v14; // di
  unsigned __int16 v15; // ax
  _BYTE *v16; // eax
  char v17; // bl
  int v18; // eax
  float x_4; // [esp+4h] [ebp-7Ch]
  float v20; // [esp+8h] [ebp-78h] BYREF
  float v21; // [esp+Ch] [ebp-74h]
  float v22; // [esp+10h] [ebp-70h]
  float v23; // [esp+14h] [ebp-6Ch]
  float v24; // [esp+18h] [ebp-68h]
  float v25; // [esp+1Ch] [ebp-64h]
  int v26[3]; // [esp+20h] [ebp-60h] BYREF
  float v27; // [esp+2Ch] [ebp-54h]
  int v28; // [esp+30h] [ebp-50h]
  int v29; // [esp+34h] [ebp-4Ch]
  int v30; // [esp+38h] [ebp-48h] BYREF
  int v31; // [esp+3Ch] [ebp-44h] BYREF
  int v32; // [esp+40h] [ebp-40h]
  int v33[2]; // [esp+48h] [ebp-38h] BYREF
  int v34; // [esp+50h] [ebp-30h]
  float v35; // [esp+54h] [ebp-2Ch]
  int v36; // [esp+58h] [ebp-28h]
  int v37; // [esp+5Ch] [ebp-24h]
  _BYTE *v38; // [esp+60h] [ebp-20h]
  char v39; // [esp+64h] [ebp-1Ch]

  v34 = 0;
  v4 = (unsigned __int8 *)(*(_DWORD *)(a1 + 0xAB) + 0xAB);
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v20 = 0.0;
  v21 = 0.0;
  v22 = 0.0;
  v33[0] = 0;
  v5 = *v4;
  v39 = 0;
  if ( (_BYTE)v5 == 3 )
  {
    v6 = *(_DWORD *)(v4 + 1);
    v23 = *(float *)(v6 + 0x9E);
    v24 = *(float *)(v6 + 0xA2);
    v25 = *(float *)(v6 + 0xA6);
    v20 = *(float *)(v6 + 0x78);
    v21 = *(float *)(v6 + 0x7C);
    v22 = *(float *)(v6 + 0x80);
    v37 = **(char **)(v6 + 0x63);
    v36 = *(_DWORD *)(v6 + 0x84);
    a2 = (int *)v37;
    v39 = *(_BYTE *)(v6 + 0x67);
    a3 = *(_DWORD *)(v6 + 0x68);
    v33[0] = *(int *)((char *)&dword_10705A + 0x6A * v37);
  }
  else if ( (_BYTE)v5 == 2 )
  {
    v7 = *(int **)(v4 + 1);
    v23 = *(float *)v7;
    v24 = *((float *)v7 + 1);
    v8 = (int *)((char *)v7 + 0x6B);
    v25 = *((float *)v7 + 2);
    v9 = *(int *)((char *)v7 + 0x6F);
    v20 = *(float *)(v9 + 0x9E);
    v21 = *(float *)(v9 + 0xA2);
    v22 = *(float *)(v9 + 0xA6);
    v36 = v8[2];
    a3 = v8[1];
    a2 = &v30;
    v5 = (int)v33;
    v10 = *(_BYTE *)(*v8 + 1);
    v32 = *(_DWORD *)(v4 + 1);
    sub_366C8(v32, v10, v33, &v30, &v31);
    LOBYTE(a2) = *(_BYTE *)(*v8 + 1);
    switch ( (_BYTE)a2 )
    {
      case 0x1C:
        v37 = 0x4C;
        break;
      case 0x1D:
        v37 = 0x4D;
        break;
      case 0x1E:
        v37 = 0x4E;
        break;
    }
  }
  else
  {
    v5 = 0x20E;
    Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0x20E);
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v11 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v11 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v11;
    *v11 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(float *)(a1 + 0x4F80) = v23;
    *(float *)(a1 + 0x4F84) = v24;
    HIWORD(v5) = 0;
    v12 = v37;
    *(float *)(a1 + 0x4F88) = v25;
    a2 = 0;
    LOWORD(v5) = *(_WORD *)(a1 + 4 * v12 + 0x1A92);
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v5, 0);
    *(_DWORD *)(a1 + 0x4F48) = sub_12AE4(a1, a3);
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v12 + 0x1BCE));
  }
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    v14 = 1;
    v35 = 1.0;
    v15 = 4;
    if ( (v36 & 4) != 0 || v37 == 0x3D )
    {
      v16 = *(_BYTE **)(a1 + 0x4F48);
      if ( *v16 == 2 )
      {
        LOWORD(v16) = *(char *)(a3 + 0xAA);
        v38 = v16;
        v35 = (double)(__int16)v16 * dbl_901BB + 1.0;
      }
      v14 = 5;
      v17 = v37;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
      v15 = (char)(((v17 & 1) == 0) + 5);
      if ( v37 != 0x3D )
      {
        goto LABEL_29;
      }
      v18 = 0x3D;
    }
    else
    {
      if ( (v36 & 2) == 0 && (v36 & 0x10) == 0 && v39 != 1 && v39 != 2 )
      {
        goto LABEL_29;
      }
      v18 = v37;
    }
    v14 = *(_WORD *)(a1 + 4 * v18 + 0x1BD0);
    v15 = *(_WORD *)(a1 + 4 * v18 + 0x1A94);
LABEL_29:
    if ( *(_DWORD *)(a1 + 0x4F3C) == 1 )
    {
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v15, 0);
      sub_4FB90((int)&unk_10914C, v14);
      *(_DWORD *)(a1 + 0x4F3C) = 2;
    }
    if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618(*(_DWORD *)(a1 + 0x4F44)) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
      v34 = 0xFFFFFFFF;
    }
    *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = v35;
    return v34;
  }
  v27 = v20 - v23;
  v33[1] = (int)v26;
  *(float *)&v28 = v21 - v24;
  *(float *)&v29 = v22 - v25;
  *(float *)v26 = v27;
  v26[1] = v28;
  v26[2] = v29;
  x_4 = sqrt(*(float *)&v28 * *(float *)&v28 + v27 * v27 + *(float *)&v29 * *(float *)&v29) * flt_901C3 + flt_901C7;
  if ( sub_12480((float *)(a1 + 0x4F80), &v20, v5, (int)a2, x_4) != 0xFFFFFFFF )
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F44));
    return v34;
  }
  *(_DWORD *)(a1 + 0x4F3C) = 1;
  return v34;
}
// 901BB: using guessed type double dbl_901BB;
// 901C3: using guessed type float flt_901C3;
// 901C7: using guessed type float flt_901C7;
// 10705A: using guessed type int dword_10705A;

//----- (00013370) --------------------------------------------------------
unsigned int __fastcall sub_13370(int a1, int a2, int a3)
{
  int v4; // ebp
  int v5; // eax
  int v6; // esi
  char v7; // dl
  int v8; // edi
  int *v9; // ebx
  float v10; // eax
  _BYTE *v11; // eax
  int v12; // eax
  int v13; // eax
  double v14; // st7
  double v15; // st7
  float v17; // [esp+8h] [ebp-6Ch] BYREF
  float v18; // [esp+Ch] [ebp-68h]
  float v19; // [esp+10h] [ebp-64h]
  float v20; // [esp+14h] [ebp-60h]
  float v21; // [esp+18h] [ebp-5Ch]
  float v22; // [esp+1Ch] [ebp-58h]
  float v23; // [esp+20h] [ebp-54h] BYREF
  float v24; // [esp+24h] [ebp-50h]
  float v25; // [esp+28h] [ebp-4Ch]
  float v26; // [esp+2Ch] [ebp-48h]
  float v27; // [esp+30h] [ebp-44h]
  float v28; // [esp+34h] [ebp-40h]
  float v29; // [esp+38h] [ebp-3Ch]
  float v30; // [esp+3Ch] [ebp-38h]
  float v31; // [esp+40h] [ebp-34h]
  int v32; // [esp+44h] [ebp-30h]
  float *v33; // [esp+48h] [ebp-2Ch]
  float *v34; // [esp+4Ch] [ebp-28h]
  float v35; // [esp+50h] [ebp-24h]
  int v36; // [esp+54h] [ebp-20h]
  float v37; // [esp+58h] [ebp-1Ch]

  v4 = 0;
  v5 = *(_DWORD *)(a1 + 0xAB) + 0xAB;
  v26 = 0.0;
  v27 = 0.0;
  v28 = 0.0;
  v6 = 0;
  v7 = *(_BYTE *)v5;
  v36 = 0;
  if ( v7 == 3 )
  {
    v8 = *(_DWORD *)(v5 + 1);
    if ( *(_BYTE *)(v8 + 0x67) )
    {
      a3 = 0x27D;
      Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x27D);
    }
    v6 = *(_DWORD *)(v8 + 0x68);
    v36 = sub_12AE4(a1, v8);
    v26 = *(float *)(v8 + 0x9E);
    v27 = *(float *)(v8 + 0xA2);
    v28 = *(float *)(v8 + 0xA6);
    v32 = 0x20 * dword_1085F2;
    v35 = (float)(0x20 * dword_1085F2);
  }
  else if ( v7 == 2 )
  {
    v9 = *(int **)(v5 + 1);
    v6 = *(int *)((char *)v9 + 0x6F);
    v36 = sub_12AE4(a1, (int)v9);
    v26 = *(float *)v9;
    v27 = *((float *)v9 + 1);
    v10 = *((float *)v9 + 2);
    a3 = 0x45480000;
    v28 = v10;
    v35 = 3200.0;
  }
  else
  {
    a3 = 0x28E;
    Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0x28E);
  }
  sub_12AE4(a1, v6);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v11 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v11 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v11;
    *v11 = 8;
    *(_DWORD *)(*(_DWORD *)(a1 + 0x4F44) + 1) = v36;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(float *)(a1 + 0x4F80) = v26;
    *(float *)(a1 + 0x4F84) = v27;
    *(float *)(a1 + 0x4F88) = v28;
    v12 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F48) = v12;
    *(_BYTE *)(v12 + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(v6 + 0x9E);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v6 + 0xA2);
    a3 = *(_DWORD *)(v6 + 0xA6);
    *(_DWORD *)(a1 + 0x4F94) = a3;
    sub_4FB90((int)&unk_10914C, 1);
  }
  v13 = *(_DWORD *)(a1 + 0x4F3C);
  if ( !v13 )
  {
    if ( sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), a3, a1, 40.0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 2u;
      v20 = 0.0;
      v21 = 0.0;
      v22 = 0.0;
      v33 = &v23;
      v20 = *(float *)(a1 + 0x4F8C) - v26;
      v21 = *(float *)(a1 + 0x4F90) - v27;
      v22 = *(float *)(a1 + 0x4F94) - v28;
      v23 = v20;
      v24 = v21;
      v25 = v22;
      v14 = sqrt(v21 * v21 + v20 * v20 + v22 * v22);
      v15 = v14 - v35;
      v37 = v15;
      if ( v15 < flt_901E5 )
      {
        v37 = 1280.0;
      }
      sub_53054(&v23, v37);
      v34 = &v17;
      v29 = v26 + v23;
      v17 = v29;
      v30 = v27 + v24;
      v18 = v30;
      v31 = v28 + v25;
      v19 = v31;
      *(float *)(a1 + 0x4F98) = v29;
      *(float *)(a1 + 0x4F9C) = v18;
      *(float *)(a1 + 0x4FA0) = v19;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
      return 0;
    }
    return v4;
  }
  if ( v13 != 1 )
  {
    return 0xFFFFFFFF;
  }
  if ( sub_12480((float *)(a1 + 0x4F8C), (float *)(a1 + 0x4F98), a3, a1, 4.0) == 0xFFFFFFFF )
  {
    *(_DWORD *)(a1 + 0x4F3C) = 2;
  }
  *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)(a1 + 0x4F8C);
  *(float *)(a1 + 0x4F84) = *(float *)(a1 + 0x4F90);
  *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)(a1 + 0x4F94);
  return 0;
}
// 901E5: using guessed type float flt_901E5;
// 1085F2: using guessed type int dword_1085F2;

//----- (000136C4) --------------------------------------------------------
unsigned int __fastcall sub_136C4(int a1)
{
  int v2; // edi
  int v3; // esi
  char v4; // ah
  int v5; // edi
  _DWORD *v6; // ebx
  int v7; // edi
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+4h] [ebp-20h]
  int v14; // [esp+8h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x2D8);
  }
  v6 = *(_DWORD **)(v5 + 1);
  v7 = v6[0x1A];
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v8 = sub_12AE4(a1, (int)v6);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) = 0x14;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)((char *)v6 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)((char *)v6 + 0xA2);
    *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)((char *)v6 + 0xA6);
    v9 = sub_12AE4(a1, v7);
    *(_DWORD *)(a1 + 0x4F48) = v9;
    *(_BYTE *)(v9 + 0x33) = 0x14;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(v7 + 0x9E);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v7 + 0xA2);
    *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v7 + 0xA6);
  }
  v10 = *(_DWORD *)(a1 + 0x4F38);
  if ( v10 == 0x14 )
  {
    v12 = *(_DWORD *)(a1 + 0x4F8C);
    v13 = *(_DWORD *)(a1 + 0x4F90);
    v14 = *(_DWORD *)(a1 + 0x4F94);
    *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(a1 + 0x4F80);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(a1 + 0x4F84);
    *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(a1 + 0x4F88);
    *(_DWORD *)(a1 + 0x4F80) = v12;
    *(_DWORD *)(a1 + 0x4F84) = v13;
    *(_DWORD *)(a1 + 0x4F88) = v14;
  }
  else if ( v10 == 0x29 )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}

//----- (0001380C) --------------------------------------------------------
unsigned int __fastcall sub_1380C(int a1)
{
  int v2; // ecx
  int v3; // edi
  char v4; // ah
  int v5; // ecx
  int v6; // ecx
  int v7; // ebp
  int v8; // edx
  _BYTE *v9; // eax
  int v10; // eax
  double v11; // st7
  int v12; // eax
  int v13; // edx
  int v14; // ebx
  _BYTE *v15; // eax
  int v17[3]; // [esp+0h] [ebp-30h] BYREF
  int v18; // [esp+Ch] [ebp-24h]
  int v19; // [esp+10h] [ebp-20h]
  char v20; // [esp+14h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x30D);
  }
  v19 = *(_DWORD *)(v5 + 1);
  v6 = v19 + 0x62;
  if ( *(_BYTE *)(v19 + 0x67) != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x312);
  }
  v7 = *(_DWORD *)(v19 + 0x68);
  v17[0] = *(_DWORD *)(v19 + 0x78);
  v17[1] = *(_DWORD *)(v19 + 0x7C);
  v17[2] = *(_DWORD *)(v19 + 0x80);
  v8 = *(_DWORD *)(a1 + 0x4F38);
  v20 = **(_BYTE **)(v19 + 0x63);
  if ( !v8 )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v9 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v9 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v9;
    *v9 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    v10 = v19 + 0x9E;
    *(float *)(a1 + 0x4F80) = *(float *)(v19 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v10 + 4);
    v11 = *(float *)(v10 + 8);
    v12 = 4 * v20;
    *(float *)(a1 + 0x4F88) = v11;
    v6 = 0;
    v18 = a1 + v12;
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), *(_WORD *)(a1 + v12 + 0x1A92), 0);
    v13 = v18;
    *(_DWORD *)(a1 + 0x4F48) = sub_12AE4(a1, v7);
    sub_4FB90((int)&unk_10914C, *(_WORD *)(v13 + 0x1BCE));
  }
  v14 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v14 )
  {
    *(_DWORD *)(a1 + 0x4F3C) = v14 + 1;
    if ( v14 + 1 > 0x14 )
    {
      return 0xFFFFFFFF;
    }
  }
  else if ( sub_12480((float *)(a1 + 0x4F80), (float *)v17, 0, v6, 40.0) == 0xFFFFFFFF )
  {
    v15 = *(_BYTE **)(a1 + 0x4F44);
    *(_DWORD *)(a1 + 0x4F3C) = 1;
    *v15 = 0xFF;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 4u;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v20 + 0x1BD0));
  }
  return v3;
}

//----- (000139E0) --------------------------------------------------------
int *__fastcall sub_139E0(int a1, int a2)
{
  int *result; // eax

  switch ( *(_BYTE *)(a1 + 0x4F37) )
  {
    case 4:
      result = sub_13A28(a1, a2);
      break;
    case 5:
      result = (int *)sub_13AD8(a1, a2);
      break;
    case 7:
    case 0xA:
    case 0xC:
    case 0xD:
    case 0xE:
      result = sub_15630(a1, a2);
      break;
    default:
      result = 0;
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0x362);
      break;
  }
  return result;
}

//----- (00013A28) --------------------------------------------------------
int *__fastcall sub_13A28(int a1, int a2)
{
  double v3; // st7
  int v4; // eax
  int v6; // [esp-20h] [ebp-3Ch]
  int v7; // [esp-1Ch] [ebp-38h]
  int v8; // [esp-18h] [ebp-34h]
  void (__noreturn *v9)(); // [esp-Ch] [ebp-28h]
  float v10; // [esp+8h] [ebp-14h]

  if ( *(_BYTE *)a2 != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x36B);
  }
  if ( *(int *)(a1 + 0x4F38) >= 0x14 )
  {
    v3 = (double)*(int *)(a1 + 0x4F38) + dbl_9022A;
  }
  else
  {
    v3 = dbl_9023A - (double)*(int *)(a1 + 0x4F38);
  }
  v10 = v3 * dbl_90232;
  v9 = (void (__noreturn *)())(int)((double)*(int *)(a2 + 0xF) * v10);
  v8 = *(__int16 *)(a2 + 0x29);
  v7 = *(__int16 *)(a2 + 0x27);
  v6 = *(_DWORD *)(a2 + 7);
  v4 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a2 + 5));
  return sub_5D631((P_Type5)(a1 + 4), v4, v6, v7, v8, (int)byte_D8DA0, 0, v9, v9, 0);
}
// 9022A: using guessed type double dbl_9022A;
// 90232: using guessed type double dbl_90232;
// 9023A: using guessed type double dbl_9023A;

//----- (00013AD8) --------------------------------------------------------
unsigned int __fastcall sub_13AD8(int a1, int a2)
{
  int v3; // eax
  T_Type5 *v4; // edi
  int v6; // [esp-20h] [ebp-44h]
  int v7; // [esp-1Ch] [ebp-40h]
  int v8; // [esp-18h] [ebp-3Ch]
  void (__noreturn *v9)(); // [esp-8h] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-14h]
  int v11; // [esp+10h] [ebp-14h]

  v10 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v10 > 0xA )
  {
    v10 = 0x14 - v10;
    sub_1826C(a1, a2, *(_WORD *)(a1 + 0x1B14), 2u);
  }
  v9 = *(void (__noreturn **)())(a2 + 0xF);
  v8 = *(__int16 *)(a2 + 0x29);
  v7 = *(__int16 *)(a2 + 0x27);
  v6 = *(_DWORD *)(a2 + 7);
  v3 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a2 + 5));
  v4 = (T_Type5 *)(a1 + 4);
  sub_5D631(v4, v3, v6, v7, v8, (int)byte_D8DA0, 0, v9, v9, 0);
  v11 = (int)((double)*(unsigned int *)(a2 + 0xF)
            * dbl_90242
            * (double)((*(__int16 *)(a2 + 0x17) - *(__int16 *)(a2 + 0x13)) * v10)
            * flt_9024A);
  return sub_5F389(
           (int)v4,
           *(__int16 *)(a2 + 0x27),
           *(__int16 *)(a2 + 0x29),
           v11,
           v11,
           (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x96);
}
// 90242: using guessed type double dbl_90242;
// 9024A: using guessed type float flt_9024A;

//----- (00013BC0) --------------------------------------------------------
_DWORD *__fastcall sub_13BC0(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  return result;
}

//----- (00013BF0) --------------------------------------------------------
_DWORD *__fastcall sub_13BF0(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (00013C10) --------------------------------------------------------
unsigned int __fastcall sub_13C10(int a1)
{
  int v2; // ecx
  char v3; // ah
  int v4; // ecx
  int v5; // ecx
  int v6; // ebx
  int v7; // ebp
  char v8; // al
  int v9; // edi
  _BYTE *v10; // eax
  _DWORD *v11; // ecx
  int v12; // edx
  int v13; // eax
  float *v14; // ecx
  float *v15; // edx
  double v16; // st7
  int v17; // eax
  float *v18; // edx
  int v19; // ebp
  int v20; // eax
  int v22; // eax
  double v23; // st7
  double v24; // st7
  int v25; // edi
  int v26; // ebx
  int v27; // ecx
  int v28; // edx
  int v29; // edx
  double v30; // st7
  double v31; // st7
  int v32; // edx
  int v33[107]; // [esp+8h] [ebp-238h] BYREF
  float v34; // [esp+1B4h] [ebp-8Ch]
  float v35; // [esp+1B8h] [ebp-88h]
  float v36; // [esp+1BCh] [ebp-84h]
  float v37; // [esp+1C0h] [ebp-80h]
  float v38; // [esp+1C4h] [ebp-7Ch]
  float v39; // [esp+1C8h] [ebp-78h]
  float v40; // [esp+1CCh] [ebp-74h] BYREF
  float v41; // [esp+1D0h] [ebp-70h]
  float v42; // [esp+1D4h] [ebp-6Ch]
  float v43; // [esp+1D8h] [ebp-68h] BYREF
  float v44; // [esp+1DCh] [ebp-64h]
  float v45; // [esp+1E0h] [ebp-60h]
  float v46; // [esp+1E4h] [ebp-5Ch]
  float v47; // [esp+1E8h] [ebp-58h]
  float v48; // [esp+1ECh] [ebp-54h]
  float *v49; // [esp+1F0h] [ebp-50h]
  int v50; // [esp+1F4h] [ebp-4Ch]
  float v51; // [esp+1F8h] [ebp-48h]
  float *v52; // [esp+1FCh] [ebp-44h]
  int v53; // [esp+200h] [ebp-40h]
  float v54; // [esp+204h] [ebp-3Ch]
  int v55; // [esp+208h] [ebp-38h]
  int v56; // [esp+20Ch] [ebp-34h]
  int v57; // [esp+210h] [ebp-30h]
  float v58; // [esp+214h] [ebp-2Ch]
  float v59; // [esp+218h] [ebp-28h]
  float v60; // [esp+21Ch] [ebp-24h]
  int v61; // [esp+220h] [ebp-20h]
  char v62; // [esp+224h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v53 = 0;
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x31);
  }
  v5 = *(_DWORD *)(v4 + 1);
  v6 = 1;
  v7 = 0;
  v8 = **(_BYTE **)(v5 + 0x63);
  v55 = 1;
  v62 = v8;
  if ( v8 == 0x4A )
  {
    if ( *(_BYTE *)(v5 + 0x67) )
    {
      v6 = 0x3A;
      Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x3A);
    }
    v7 = *(_DWORD *)(v5 + 0x68);
    v55 = 2;
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    LOBYTE(v6) = v62;
    v9 = sub_1D794(*(__int16 **)(v5 + 0x59), v33);
    *(_WORD *)(a1 + 0x5034) = 1;
    if ( (_BYTE)v6 == 0x4A )
    {
      *(_WORD *)(a1 + 0x5034) = 2;
      *(_DWORD *)(a1 + 0x4F44) = sub_12AE4(a1, v7);
      v10 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
      *(_DWORD *)(a1 + 0x4F48) = v10;
      *v10 = 7;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) = 0x12;
      v11 = (_DWORD *)(v5 + 0x9E);
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
      *(_DWORD *)(a1 + 0x4F8C) = *v11;
      *(_DWORD *)(a1 + 0x4F90) = v11[1];
      *(_DWORD *)(a1 + 0x4F94) = v11[2];
      v5 = 0;
      v6 = *(unsigned __int16 *)(a1 + 4 * v62 + 0x1A92);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), v6, 0);
      if ( v9 <= 0 )
      {
        goto LABEL_18;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 0x4F44) = sub_12AE4(a1, *(_DWORD *)(v5 + 0x59));
      if ( v9 <= 0 )
      {
LABEL_18:
        v17 = v62;
        *(_DWORD *)(a1 + 0x4F3C) = 0;
        sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v17 + 0x1BCE));
        goto LABEL_19;
      }
    }
    v6 = 0;
    v56 = a1 + 0x4F80;
    v57 = 4 * v9;
    do
    {
      if ( *(__int16 *)(a1 + 0x5034) >= 0xF )
      {
        break;
      }
      v12 = *(int *)((char *)v33 + v6);
      if ( *(_BYTE *)(v12 + 0x58) == 4 && v12 != v7 )
      {
        v13 = sub_12AE4(a1, v12);
        *(_BYTE *)(v13 + 0x33) |= 0x12u;
        *(_BYTE *)(v13 + 0x34) = *(_BYTE *)(a1 + 0x5034);
        v14 = *(float **)((char *)v33 + v6);
        v15 = (float *)(a1 + 0x4F80 + 0xC * *(char *)(v13 + 0x34));
        v16 = *(float *)((char *)v14 + 0x9E);
        v14 = (float *)((char *)v14 + 0x9E);
        *v15 = v16;
        v15[1] = v14[1];
        v15[2] = v14[2];
        LOWORD(v15) = *(_WORD *)(a1 + 0x5034);
        v5 = (__int16)v15;
        *(_WORD *)(a1 + 0x5034) = (_WORD)v15 + 1;
        *(_DWORD *)(a1 + 4 * (__int16)v15 + 0x4F44) = v13;
      }
      v6 += 4;
    }
    while ( v6 < v57 );
    goto LABEL_18;
  }
LABEL_19:
  v18 = (float *)(v7 + 0x9E);
  v19 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v19 )
  {
    if ( v19 == 1 )
    {
      *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) + flt_90278;
      v20 = *(_DWORD *)(a1 + 0x4F44);
      dword_9A234 = 0;
      if ( *(float *)(v20 + 0xB) >= (double)flt_9027C )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 2;
        return v53;
      }
    }
    else if ( v19 == 2 )
    {
      v46 = 0.0;
      v47 = 0.0;
      v48 = 0.0;
      if ( v62 == 0x4A )
      {
        v46 = *v18;
        v47 = v18[1];
        v48 = v18[2];
      }
      v22 = 0x6A * v62;
      v23 = (double)*(int *)((char *)&dword_10706A + v22);
      v61 = 0x20 * *(int *)((char *)&dword_10706E + v22);
      v54 = v23;
      v51 = (float)v61;
      v24 = v54 - *(float *)&dword_9A234;
      v58 = v24;
      if ( v24 > dbl_90270 )
      {
        v58 = 0.2;
      }
      v25 = a1 + 0x4F80;
      v50 = 0xFFFFFFFF;
      v26 = v55;
      *(float *)&dword_9A234 = *(float *)&dword_9A234 + v58;
      v27 = a1 + 4 * v55;
      while ( v26 < *(__int16 *)(a1 + 0x5034) )
      {
        v29 = *(char *)(*(_DWORD *)(v27 + 0x4F44) + 0x34);
        v49 = &v40;
        v34 = 0.0;
        v35 = 0.0;
        v36 = 0.0;
        v34 = *(float *)(v25 + 0xC * v29) - v46;
        v35 = *(float *)(v25 + 0xC * v29 + 4) - v47;
        v36 = *(float *)(v25 + 0xC * v29 + 8) - v48;
        v40 = v34;
        v41 = v35;
        v42 = v36;
        v30 = sqrt(v35 * v35 + v34 * v34 + v36 * v36);
        v59 = v30;
        if ( v30 > v51 )
        {
          v31 = v59 - v58 * flt_90280;
          v60 = v31;
          if ( v31 >= v51 )
          {
            v50 = 0;
          }
          else
          {
            v60 = v51;
          }
          v28 = 0xC * v29;
          sub_53054(&v40, v60);
          v52 = &v43;
          v37 = v46 + v40;
          v43 = v37;
          v38 = v47 + v41;
          v44 = v38;
          v39 = v48 + v42;
          v45 = v39;
          *(float *)(v28 + v25) = v37;
          *(float *)(v28 + v25 + 4) = v44;
          *(float *)(v28 + v25 + 8) = v45;
        }
        v27 += 4;
        ++v26;
      }
      if ( *(float *)&dword_9A234 >= (double)v54 || v50 == 0xFFFFFFFF )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 3;
        return v53;
      }
    }
    else
    {
      *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) + flt_9026C;
      v32 = *(_DWORD *)(a1 + 0x4F44);
      if ( *(float *)(v32 + 0xB) <= 1.0 )
      {
        *(_DWORD *)(v32 + 0xB) = 0x3F800000;
        return 0xFFFFFFFF;
      }
    }
  }
  else
  {
    if ( v62 == 0x4A )
    {
      if ( sub_12480((float *)(a1 + 0x4F8C), v18, v6, v5, 10.0) != 0xFFFFFFFF )
      {
        sub_12618(*(_DWORD *)(a1 + 0x4F48));
        return v53;
      }
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
    }
    *(_DWORD *)(a1 + 0x4F3C) = 1;
  }
  return v53;
}
// 9026C: using guessed type float flt_9026C;
// 90270: using guessed type double dbl_90270;
// 90278: using guessed type float flt_90278;
// 9027C: using guessed type float flt_9027C;
// 90280: using guessed type float flt_90280;
// 9A234: using guessed type int dword_9A234;
// 10706A: using guessed type int dword_10706A;
// 10706E: using guessed type int dword_10706E;

//----- (00014224) --------------------------------------------------------
unsigned int __fastcall sub_14224(int a1)
{
  int v2; // edi
  int v3; // esi
  char v4; // ah
  int v5; // edi
  int v6; // edx
  char v7; // bl
  int v8; // eax
  int v9; // eax

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0xCC);
  }
  v6 = *(_DWORD *)(v5 + 1);
  v7 = **(_BYTE **)(v6 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v8 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) |= 4u;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v7 + 0x1BCE));
  }
  v9 = *(_DWORD *)(a1 + 0x4F38);
  *(_DWORD *)(a1 + 0x4F40) += v9 & 1;
  if ( v9 == 0x24 )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}

//----- (000142D8) --------------------------------------------------------
int __fastcall sub_142D8(int a1)
{
  int v2; // esi
  char v3; // ah
  int v4; // esi
  int v5; // ebx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  double v9; // st7
  double v10; // st7
  int v11; // edx
  double v12; // st7
  double v13; // st6
  float v15; // [esp+8h] [ebp-40h] BYREF
  float v16; // [esp+Ch] [ebp-3Ch]
  float v17; // [esp+10h] [ebp-38h]
  float v18; // [esp+14h] [ebp-34h]
  float v19; // [esp+18h] [ebp-30h]
  float v20; // [esp+1Ch] [ebp-2Ch]
  float *v21; // [esp+20h] [ebp-28h]
  float v22; // [esp+24h] [ebp-24h]
  float v23; // [esp+28h] [ebp-20h]
  float v24; // [esp+2Ch] [ebp-1Ch]
  char v25; // [esp+30h] [ebp-18h]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0xF5);
  }
  v5 = *(_DWORD *)(v4 + 1);
  v6 = *(_DWORD *)(a1 + 0x4F38);
  v25 = **(_BYTE **)(v5 + 0x63);
  if ( !v6 )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v7 = sub_12AE4(a1, v5);
    *(_DWORD *)(a1 + 0x4F44) = v7;
    *(_BYTE *)(v7 + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    v8 = v5 + 0x9E;
    v9 = *(float *)(v5 + 0x9E);
    v5 = 0;
    *(float *)(a1 + 0x4F80) = v9;
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)(v8 + 8);
    v18 = 0.0;
    v19 = 0.0;
    v20 = 0.0;
    v21 = &v15;
    v18 = -*(float *)v8;
    v19 = -*(float *)(v8 + 4);
    v10 = -*(float *)(v8 + 8);
    v15 = v18;
    v20 = v10;
    v16 = v19;
    v17 = v20;
    *(float *)(a1 + 0x4F8C) = v18;
    *(float *)(a1 + 0x4F90) = v16;
    *(float *)(a1 + 0x4F94) = v17;
    v11 = v25;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v11 + 0x1BCE));
  }
  v12 = *(float *)(a1 + 0x4F90) * *(float *)(a1 + 0x4F90) + *(float *)(a1 + 0x4F8C) * *(float *)(a1 + 0x4F8C);
  v13 = *(float *)(a1 + 0x4F94) * *(float *)(a1 + 0x4F94);
  v24 = 0.0;
  v23 = sqrt(v12 + v13);
  v22 = sqrt(
          *(float *)(a1 + 0x4F84) * *(float *)(a1 + 0x4F84)
        + *(float *)(a1 + 0x4F80) * *(float *)(a1 + 0x4F80)
        + *(float *)(a1 + 0x4F88) * *(float *)(a1 + 0x4F88));
  if ( v23 > 1.0 )
  {
    v24 = (v23 - v22) * flt_902A0 / v23;
  }
  if ( v24 < dbl_902A4 )
  {
    v24 = 3.2;
  }
  return sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), v5, a1, v24);
}
// 902A0: using guessed type float flt_902A0;
// 902A4: using guessed type double dbl_902A4;

//----- (00014490) --------------------------------------------------------
int __fastcall sub_14490(int a1)
{
  int v2; // esi
  char v3; // ah
  int v4; // esi
  int v5; // esi
  _DWORD *v6; // ebx
  int v7; // eax
  float v9; // [esp+0h] [ebp-1Ch]
  char v10; // [esp+4h] [ebp-18h]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x127);
  }
  v5 = *(_DWORD *)(v4 + 1);
  if ( *(_BYTE *)(v5 + 0x67) != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x12B);
  }
  v6 = *(_DWORD **)(v5 + 0x68);
  v10 = **(_BYTE **)(v5 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v7 = sub_12AE4(a1, v5);
    *(_DWORD *)(a1 + 0x4F44) = v7;
    *(_BYTE *)(v7 + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)(v5 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v5 + 0xA2);
    *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)(v5 + 0xA6);
    *(_DWORD *)(a1 + 0x4F8C) = v6[5];
    *(_DWORD *)(a1 + 0x4F90) = v6[6];
    *(_DWORD *)(a1 + 0x4F94) = v6[7];
    if ( *(_DWORD *)(v5 + 0x59) == *v6 )
    {
      *(_DWORD *)(a1 + 0x4F8C) = v6[2];
      *(_DWORD *)(a1 + 0x4F90) = v6[3];
      v6 = (_DWORD *)v6[4];
      *(_DWORD *)(a1 + 0x4F94) = v6;
    }
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v10 + 0x1BCE));
  }
  v9 = (double)*(int *)(a1 + 0x4F38) * dbl_902C8;
  return sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), (int)v6, a1, v9);
}
// 902C8: using guessed type double dbl_902C8;

//----- (000145C0) --------------------------------------------------------
unsigned int __fastcall sub_145C0(int a1)
{
  int v2; // ecx
  char v3; // ah
  int v4; // ecx
  int v5; // ecx
  int v6; // edi
  int v7; // ebx
  int v8; // eax
  _BYTE *v9; // eax
  _DWORD *v10; // ecx
  int v11; // ebp
  int v12; // eax
  int v13; // eax
  int v14; // edi
  int v16; // ebx
  int v17; // [esp+0h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v17 = 0;
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x158);
  }
  v5 = *(_DWORD *)(v4 + 1);
  if ( *(_BYTE *)(v5 + 0x67) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x15C);
  }
  v7 = *(_DWORD *)(v5 + 0x63);
  v6 = *(_DWORD *)(v5 + 0x68);
  LOBYTE(v7) = *(_BYTE *)v7;
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 3;
    v8 = sub_12AE4(a1, v5);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) |= 4u;
    v9 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
    *(_DWORD *)(a1 + 0x4F48) = v9;
    *v9 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) = 0x1A;
    v10 = (_DWORD *)(v5 + 0x9E);
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    *(_DWORD *)(a1 + 0x4F8C) = *v10;
    *(_DWORD *)(a1 + 0x4F90) = v10[1];
    *(_DWORD *)(a1 + 0x4F94) = v10[2];
    v11 = (char)v7;
    v5 = 0;
    v7 = *(unsigned __int16 *)(a1 + 4 * (char)v7 + 0x1A92);
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), v7, 0);
    v12 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    *(_DWORD *)(a1 + 0x4F4C) = v12;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v11 + 0x1BCE));
  }
  v13 = *(_DWORD *)(a1 + 0x4F3C);
  if ( !v13 )
  {
    v14 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
    *(_DWORD *)(a1 + 0x4F40) = v14;
    if ( v14 == 0x12 )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) &= ~4u;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) &= ~8u;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
      *(_DWORD *)(a1 + 0x4F40) = 0;
    }
    return v17;
  }
  if ( v13 != 1 )
  {
    v16 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
    *(_DWORD *)(a1 + 0x4F40) = v16;
    if ( v16 == 0x12 )
    {
      return 0xFFFFFFFF;
    }
    return v17;
  }
  if ( sub_12480((float *)(a1 + 0x4F8C), (float *)(v6 + 0x9E), v7, v5, 20.0) == 0xFFFFFFFF )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F4C) + 0x33) |= 4u;
    *(_DWORD *)(a1 + 0x4F3C) = 2;
  }
  else
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F48));
  }
  return 0;
}

//----- (000147CC) --------------------------------------------------------
unsigned int __fastcall sub_147CC(int a1)
{
  int v2; // edi
  char v3; // ah
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // ebp
  _BYTE *v9; // eax
  int v10; // eax
  double v11; // st7
  double v12; // st7
  int v13; // edx
  float *v14; // edx
  double v15; // st7
  float v17; // [esp+4h] [ebp-84h]
  int v18[3]; // [esp+8h] [ebp-80h] BYREF
  float v19; // [esp+14h] [ebp-74h] BYREF
  float v20; // [esp+18h] [ebp-70h]
  float v21; // [esp+1Ch] [ebp-6Ch]
  float v22; // [esp+20h] [ebp-68h] BYREF
  float v23; // [esp+24h] [ebp-64h]
  float v24; // [esp+28h] [ebp-60h]
  float v25; // [esp+2Ch] [ebp-5Ch]
  float v26; // [esp+30h] [ebp-58h]
  float v27; // [esp+34h] [ebp-54h]
  float v28; // [esp+38h] [ebp-50h]
  float v29; // [esp+3Ch] [ebp-4Ch]
  float v30; // [esp+40h] [ebp-48h]
  float v31; // [esp+44h] [ebp-44h]
  float v32; // [esp+48h] [ebp-40h]
  float v33; // [esp+4Ch] [ebp-3Ch]
  float *v34; // [esp+50h] [ebp-38h]
  int *v35; // [esp+54h] [ebp-34h]
  int v36; // [esp+58h] [ebp-30h]
  int v37; // [esp+5Ch] [ebp-2Ch]
  int v38; // [esp+60h] [ebp-28h]
  float v39; // [esp+64h] [ebp-24h]
  float *v40; // [esp+68h] [ebp-20h]
  int v41; // [esp+6Ch] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v38 = 0;
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x1AC);
  }
  v5 = *(_DWORD *)(v4 + 1);
  if ( *(_BYTE *)(v5 + 0x67) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x1B0);
  }
  v6 = **(char **)(v5 + 0x63);
  v36 = (int)&unk_107020 + 0x6A * v6;
  v7 = *(_DWORD *)(a1 + 0x4F38);
  v8 = *(_DWORD *)(v5 + 0x68);
  if ( !v7 )
  {
    v9 = *(_BYTE **)(a1 + 0x1D2A);
    *(_WORD *)(a1 + 0x5034) = 2;
    v9 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v9;
    *v9 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(float *)(a1 + 0x4F80) = *(float *)(v5 + 0x9E);
    *(float *)(a1 + 0x4F84) = *(float *)(v5 + 0xA2);
    *(float *)(a1 + 0x4F88) = *(float *)(v5 + 0xA6);
    v37 = a1 + 4 * v6;
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), *(_WORD *)(v37 + 0x1A92), 0);
    v10 = sub_12AE4(a1, v8);
    *(_DWORD *)(a1 + 0x4F48) = v10;
    *(_BYTE *)(v10 + 0x33) |= 0x12u;
    v5 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    v7 = a1 + 0x4F8C;
    *(float *)(a1 + 0x4F8C) = *(float *)(v8 + 0x9E);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v8 + 0xA2);
    *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v8 + 0xA6);
    v40 = &v19;
    v31 = 0.0;
    v32 = 0.0;
    v33 = 0.0;
    v31 = *(float *)(a1 + 0x4F8C) - *(float *)(a1 + 0x4F80);
    v32 = *(float *)(a1 + 0x4F90) - *(float *)(a1 + 0x4F84);
    v11 = *(float *)(a1 + 0x4F94) - *(float *)(a1 + 0x4F88);
    v19 = v31;
    v33 = v11;
    v20 = v32;
    v21 = v33;
    *(float *)(a1 + 0x4F98) = v31;
    *(float *)(a1 + 0x4F9C) = v20;
    *(float *)(a1 + 0x4FA0) = v21;
    v41 = 0x20 * *(_DWORD *)(v36 + 0x4A);
    v17 = (float)v41;
    sub_53054((float *)(a1 + 0x4F98), v17);
    v25 = 0.0;
    v26 = 0.0;
    v27 = 0.0;
    v34 = &v22;
    v25 = *(float *)(a1 + 0x4F8C) + *(float *)(a1 + 0x4F98);
    v26 = *(float *)(a1 + 0x4F90) + *(float *)(a1 + 0x4F9C);
    v12 = *(float *)(a1 + 0x4F94) + *(float *)(a1 + 0x4FA0);
    v22 = v25;
    v27 = v12;
    v23 = v26;
    v24 = v27;
    *(float *)(a1 + 0x4F98) = v25;
    *(float *)(a1 + 0x4F9C) = v23;
    *(float *)(a1 + 0x4FA0) = v24;
    v13 = v37;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(v13 + 0x1BCE));
  }
  v14 = (float *)(a1 + 0x4F8C);
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    v35 = v18;
    v28 = 0.0;
    v29 = 0.0;
    v30 = 0.0;
    v28 = *(float *)(a1 + 0x4F98) - *v14;
    v29 = *(float *)(a1 + 0x4F9C) - *(float *)(a1 + 0x4F90);
    v30 = *(float *)(a1 + 0x4FA0) - *(float *)(a1 + 0x4F94);
    *(float *)v18 = v28;
    *(float *)&v18[1] = v29;
    *(float *)&v18[2] = v30;
    v15 = sqrt(v29 * v29 + v28 * v28 + v30 * v30) * flt_90308;
    v39 = v15;
    if ( v15 >= dbl_9030C )
    {
      if ( v39 > (double)flt_90314 )
      {
        v39 = 50.0;
      }
    }
    else
    {
      v39 = 3.2;
    }
    if ( sub_12480((float *)(a1 + 0x4F8C), (float *)(a1 + 0x4F98), 0, v5, v39) == 0xFFFFFFFF )
    {
      return 0xFFFFFFFF;
    }
  }
  else
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F44));
    if ( sub_12480((float *)(a1 + 0x4F80), v14, v7, v5, 50.0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
    }
  }
  return v38;
}
// 90308: using guessed type float flt_90308;
// 9030C: using guessed type double dbl_9030C;
// 90314: using guessed type float flt_90314;

//----- (00014B18) --------------------------------------------------------
unsigned int __fastcall sub_14B18(int a1, int a2, int a3)
{
  int v4; // ecx
  char v5; // ah
  int v6; // ecx
  int v7; // ecx
  int v8; // ebp
  int v9; // edi
  _BYTE *v10; // eax
  _DWORD *v11; // ecx
  int v12; // edx
  int v13; // eax
  float *v14; // ecx
  float *v15; // edx
  double v16; // st7
  int v17; // eax
  float *v18; // edx
  int v19; // ebp
  int v20; // eax
  int v22; // edi
  int v23; // ecx
  int v24; // ebx
  int v25; // edx
  int v26; // edx
  double v27; // st7
  int v28; // ecx
  float v29; // [esp+4h] [ebp-228h]
  int v30[107]; // [esp+8h] [ebp-224h] BYREF
  float v31; // [esp+1B4h] [ebp-78h]
  float v32; // [esp+1B8h] [ebp-74h]
  float v33; // [esp+1BCh] [ebp-70h]
  float v34; // [esp+1C0h] [ebp-6Ch]
  float v35; // [esp+1C4h] [ebp-68h]
  float v36; // [esp+1C8h] [ebp-64h]
  float v37; // [esp+1CCh] [ebp-60h] BYREF
  float v38; // [esp+1D0h] [ebp-5Ch]
  float v39; // [esp+1D4h] [ebp-58h]
  float v40; // [esp+1D8h] [ebp-54h] BYREF
  float v41; // [esp+1DCh] [ebp-50h]
  float v42; // [esp+1E0h] [ebp-4Ch]
  float v43; // [esp+1E4h] [ebp-48h]
  float v44; // [esp+1E8h] [ebp-44h]
  float v45; // [esp+1ECh] [ebp-40h]
  int v46; // [esp+1F0h] [ebp-3Ch]
  float *v47; // [esp+1F4h] [ebp-38h]
  float v48; // [esp+1F8h] [ebp-34h]
  float *v49; // [esp+1FCh] [ebp-30h]
  int v50; // [esp+200h] [ebp-2Ch]
  int v51; // [esp+204h] [ebp-28h]
  int v52; // [esp+208h] [ebp-24h]
  float v53; // [esp+20Ch] [ebp-20h]
  char v54; // [esp+210h] [ebp-1Ch]

  v4 = *(_DWORD *)(a1 + 0xAB);
  v50 = 0;
  v5 = *(_BYTE *)(v4 + 0xAB);
  v6 = v4 + 0xAB;
  if ( v5 != 3 )
  {
    a3 = 0x1F9;
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x1F9);
  }
  v7 = *(_DWORD *)(v6 + 1);
  v8 = v7;
  v54 = **(_BYTE **)(v7 + 0x63);
  if ( v54 == 0x28 )
  {
    if ( *(_BYTE *)(v7 + 0x67) )
    {
      a3 = 0x201;
      Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x201);
    }
    v8 = *(_DWORD *)(v7 + 0x68);
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    v9 = sub_1D794(*(__int16 **)(v7 + 0x59), v30);
    *(_WORD *)(a1 + 0x5034) = 2;
    *(_DWORD *)(a1 + 0x4F44) = sub_12AE4(a1, v8);
    v10 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
    *(_DWORD *)(a1 + 0x4F48) = v10;
    LOBYTE(a3) = v54;
    *v10 = 0xFF;
    if ( (_BYTE)a3 == 0x28 )
    {
      **(_BYTE **)(a1 + 0x4F48) = 7;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) = 0x12;
      v11 = (_DWORD *)(v7 + 0x9E);
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
      *(_DWORD *)(a1 + 0x4F8C) = *v11;
      *(_DWORD *)(a1 + 0x4F90) = v11[1];
      *(_DWORD *)(a1 + 0x4F94) = v11[2];
      v7 = 0;
      a3 = *(unsigned __int16 *)(a1 + 4 * v54 + 0x1A92);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), a3, 0);
    }
    if ( v9 > 0 )
    {
      a3 = 0;
      v46 = a1 + 0x4F80;
      v52 = 4 * v9;
      do
      {
        if ( *(__int16 *)(a1 + 0x5034) >= 0xF )
        {
          break;
        }
        v12 = *(int *)((char *)v30 + a3);
        if ( *(_BYTE *)(v12 + 0x58) == 4 && v12 != v8 )
        {
          v13 = sub_12AE4(a1, v12);
          *(_BYTE *)(v13 + 0x33) |= 0x12u;
          *(_BYTE *)(v13 + 0x34) = *(_BYTE *)(a1 + 0x5034);
          v14 = *(float **)((char *)v30 + a3);
          v15 = (float *)(a1 + 0x4F80 + 0xC * *(char *)(v13 + 0x34));
          v16 = *(float *)((char *)v14 + 0x9E);
          v14 = (float *)((char *)v14 + 0x9E);
          *v15 = v16;
          v15[1] = v14[1];
          v15[2] = v14[2];
          LOWORD(v15) = *(_WORD *)(a1 + 0x5034);
          *(_WORD *)(a1 + 0x5034) = (_WORD)v15 + 1;
          *(_DWORD *)(a1 + 4 * (__int16)v15 + 0x4F44) = v13;
        }
        v7 = v52;
        a3 += 4;
      }
      while ( a3 < v52 );
    }
    BYTE1(a3) = v54;
    *(_DWORD *)(a1 + 0x4F3C) = 1;
    if ( BYTE1(a3) == 0x28 )
    {
      *(_DWORD *)(a1 + 0x4F3C) = 0;
    }
    v17 = v54;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v17 + 0x1BCE));
    dword_9A238 = 0;
  }
  v18 = (float *)(v8 + 0x9E);
  v19 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v19 )
  {
    if ( v19 == 1 )
    {
      v20 = *(_DWORD *)(a1 + 0x4F44);
      *(_DWORD *)(a1 + 0x4F40) += *(_DWORD *)(a1 + 0x4F38) & 1;
      *(_BYTE *)(v20 + 0x33) |= 4u;
      if ( *(_DWORD *)(a1 + 0x4F40) == 9 )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 2;
        return v50;
      }
    }
    else if ( v19 == 2 )
    {
      v43 = *v18;
      v44 = v18[1];
      v45 = v18[2];
      v22 = a1 + 0x4F80;
      v23 = 2;
      v24 = a1 + 8;
      v48 = (float)*(int *)((char *)&dword_10706A + 0x6A * v54);
      v51 = 0xFFFFFFFF;
      *(float *)&dword_9A238 = *(float *)&dword_9A238 + flt_90334;
      while ( v23 < *(__int16 *)(a1 + 0x5034) )
      {
        v26 = *(char *)(*(_DWORD *)(v24 + 0x4F44) + 0x34);
        v47 = &v37;
        v31 = 0.0;
        v32 = 0.0;
        v33 = 0.0;
        v31 = *(float *)(v22 + 0xC * v26) - v43;
        v32 = *(float *)(v22 + 0xC * v26 + 4) - v44;
        v33 = *(float *)(v22 + 0xC * v26 + 8) - v45;
        v37 = v31;
        v38 = v32;
        v39 = v33;
        v27 = sqrt(v32 * v32 + v31 * v31 + v33 * v33) * flt_90338 + flt_90334;
        v53 = v27;
        if ( v27 < v48 )
        {
          v51 = 0;
        }
        else
        {
          v53 = v48;
        }
        v25 = 0xC * v26;
        v29 = v53 * flt_9033C;
        sub_53054(&v37, v29);
        v49 = &v40;
        v34 = v43 + v37;
        v40 = v34;
        v35 = v44 + v38;
        v41 = v35;
        v36 = v45 + v39;
        v42 = v36;
        *(float *)(v25 + v22) = v34;
        *(float *)(v25 + v22 + 4) = v41;
        v24 += 4;
        ++v23;
        *(float *)(v25 + v22 + 8) = v42;
      }
      if ( *(float *)&dword_9A238 >= (double)v48 || v51 == 0xFFFFFFFF )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 3;
        return v50;
      }
    }
    else
    {
      v28 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
      *(_DWORD *)(a1 + 0x4F40) = v28;
      if ( v28 == 0x12 )
      {
        return 0xFFFFFFFF;
      }
    }
  }
  else
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F48));
    if ( sub_12480((float *)(a1 + 0x4F8C), v18, a3, v7, 10.0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
    }
  }
  return v50;
}
// 90334: using guessed type float flt_90334;
// 90338: using guessed type float flt_90338;
// 9033C: using guessed type float flt_9033C;
// 9A238: using guessed type int dword_9A238;
// 10706A: using guessed type int dword_10706A;

//----- (00015078) --------------------------------------------------------
unsigned int __fastcall sub_15078(int a1)
{
  int v2; // edi
  int v3; // esi
  char v4; // ah
  int v5; // edi
  int v6; // edx
  char v7; // bl
  int v8; // eax

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x283);
  }
  v6 = *(_DWORD *)(v5 + 1);
  v7 = **(_BYTE **)(v6 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v8 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) |= 4u;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v7 + 0x1BCE));
  }
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) + flt_9034E;
    if ( *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) < dbl_90352 )
    {
      return 0xFFFFFFFF;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 0x4F40) += (*(_BYTE *)(a1 + 0x4F38) & 3) == 0;
    if ( *(_DWORD *)(a1 + 0x4F40) == 9 )
    {
      *(_DWORD *)(a1 + 0x4F3C) = 1;
    }
  }
  return v3;
}
// 9034E: using guessed type float flt_9034E;
// 90352: using guessed type double dbl_90352;

//----- (00015164) --------------------------------------------------------
unsigned int __fastcall sub_15164(int a1)
{
  int v2; // ecx
  unsigned int v3; // edi
  char v4; // ah
  int v5; // ecx
  int v6; // ebx
  int v7; // eax
  _BYTE *v8; // eax
  int v9; // ebp
  int v10; // edx

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x2B5);
  }
  v6 = *(_DWORD *)(v5 + 1);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v7 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F44) = v7;
    *(_BYTE *)(v7 + 0x33) |= 4u;
    v8 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
    *(_DWORD *)(a1 + 0x4F48) = v8;
    *v8 = 0xFF;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 0x1CEE));
  }
  v9 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618(*(_DWORD *)(a1 + 0x4F48)) == 0xFFFFFFFF )
      {
        v3 = 0xFFFFFFFF;
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0x4F48) + 0xB) = 0x40A00000;
    }
  }
  else
  {
    v10 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
    *(_DWORD *)(a1 + 0x4F40) = v10;
    if ( v10 == 9 )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
      **(_BYTE **)(a1 + 0x4F48) = 7;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 0x10u;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
      *(float *)(a1 + 0x4F8C) = *(float *)(v6 + 0x9E);
      *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v6 + 0xA2);
      *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v6 + 0xA6);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), *(_WORD *)(a1 + 0x1BB2), 0);
      *(_DWORD *)(*(_DWORD *)(a1 + 0x4F48) + 0xB) = 0x40A00000;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
      return 0;
    }
  }
  return v3;
}

//----- (000152E4) --------------------------------------------------------
unsigned int __fastcall sub_152E4(int a1, int a2, int a3, int a4)
{
  int v5; // esi
  char v6; // ah
  int v7; // esi
  int v8; // ebx
  _BYTE *v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // esi
  int v13; // edx
  unsigned int v14; // eax
  int v15; // ebp
  int v16; // edx
  int v17; // ebx
  _BYTE *v18; // eax
  int v20; // eax
  unsigned __int16 v21; // si
  char v22; // al
  int v23; // eax
  int v24[107]; // [esp+0h] [ebp-1DCh] BYREF
  int v25; // [esp+1ACh] [ebp-30h]
  int v26; // [esp+1B0h] [ebp-2Ch]
  int v27; // [esp+1B4h] [ebp-28h]
  int v28; // [esp+1B8h] [ebp-24h]
  int v29; // [esp+1BCh] [ebp-20h]
  char v30; // [esp+1C0h] [ebp-1Ch]

  v5 = *(_DWORD *)(a1 + 0xAB);
  v26 = 0;
  v6 = *(_BYTE *)(v5 + 0xAB);
  v7 = v5 + 0xAB;
  if ( v6 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x2FA);
  }
  v27 = *(_DWORD *)(v7 + 1);
  v8 = *(_DWORD *)(a1 + 0x4F38);
  v30 = 0x26;
  v25 = (int)&unk_107020 + 0xFBC;
  if ( !v8 )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v9 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F44) = v9;
    *v9 = 0xFF;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 0x12u;
    v10 = v27 + 0x9E;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)v10;
    a4 = *(_DWORD *)(v10 + 4);
    *(_DWORD *)(a1 + 0x4F84) = a4;
    *(float *)(a1 + 0x4F88) = *(float *)(v10 + 8);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 0x1C66));
  }
  if ( **(_BYTE **)(a1 + 0x4F44) == 0xFF )
  {
    v11 = sub_1D794(*(__int16 **)(v27 + 0x59), v24);
    v12 = (unsigned __int8)*(_DWORD *)(a1 + 0x4F3C);
    v13 = v11;
    if ( v12 < v11 )
    {
      v14 = 4 * v12;
      v15 = *(__int16 *)(v27 + 0x56);
      v28 = 4 * v13;
      while ( 1 )
      {
        v16 = v24[v14 / 4];
        v8 = *(__int16 *)(v16 + 0x56);
        if ( *(_BYTE *)(v16 + 0x58) == 4 && v15 != v8 && byte_A3132[0x1EE * v15 + v8] == 2 )
        {
          break;
        }
        a4 = v28;
        v14 += 4;
        ++v12;
        if ( (int)v14 >= v28 )
        {
          goto LABEL_15;
        }
      }
      *(_WORD *)(a1 + 0x5034) = 2;
      v17 = v24[v14 / 4];
      *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(v17 + 0x9E);
      *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v17 + 0xA2);
      *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v17 + 0xA6);
      **(_BYTE **)(a1 + 0x4F44) = 7;
      a4 = 0;
      *(_DWORD *)(a1 + 0x4F48) = sub_12AE4(a1, v24[v14 / 4]);
      v8 = *(unsigned __int16 *)(a1 + 4 * v30 + 0x1A92);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v8, 0);
      *(_DWORD *)(a1 + 0x4F3C) = v12 + 1;
    }
LABEL_15:
    if ( **(_BYTE **)(a1 + 0x4F44) == 0xFF )
    {
      v26 = 0xFFFFFFFF;
    }
  }
  v18 = *(_BYTE **)(a1 + 0x4F44);
  if ( *v18 == 0xFF )
  {
    return 0xFFFFFFFF;
  }
  if ( (*(_BYTE *)(a1 + 0x4F3D) & 1) != 0 )
  {
    if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618((int)v18) == 0xFFFFFFFF )
    {
      **(_BYTE **)(a1 + 0x4F44) = 0xFF;
      *(_DWORD *)(a1 + 0x4F3C) = (unsigned __int8)*(_DWORD *)(a1 + 0x4F3C);
      return v26;
    }
  }
  else
  {
    sub_12618((int)v18);
    if ( sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), v8, a4, 50.0) == 0xFFFFFFFF )
    {
      v20 = *(_DWORD *)(a1 + 0x4F48);
      LOWORD(v29) = 1;
      v21 = 4;
      v22 = sub_4B7A0(*(_DWORD *)(v20 + 1), 0, *(_DWORD *)(v25 + 0x4A), *(_WORD *)(v27 + 0x56));
      if ( (v22 & 4) != 0 )
      {
        v23 = *(_DWORD *)(a1 + 0x4F48);
        LOWORD(v29) = 5;
        v21 = 5;
        *(_BYTE *)(v23 + 0x33) |= 8u;
      }
      else if ( (v22 & 2) != 0 )
      {
        v21 = *(_WORD *)(a1 + 4 * v30 + 0x1A94);
        LOWORD(v29) = *(_WORD *)(a1 + 4 * v30 + 0x1BD0);
      }
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v21, 0);
      sub_4FB90((int)&unk_10914C, v29);
      *(_BYTE *)(a1 + 0x4F3D) |= 1u;
    }
  }
  return v26;
}

//----- (00015630) --------------------------------------------------------
int *__fastcall sub_15630(int a1, int a2)
{
  int v3; // eax
  int v4; // eax
  int v6; // [esp-20h] [ebp-30h]
  int v7; // [esp-1Ch] [ebp-2Ch]
  int v8; // [esp-18h] [ebp-28h]
  void (__noreturn *v9)(); // [esp-8h] [ebp-18h]

  v3 = *(_DWORD *)(a1 + 0x4F40);
  if ( v3 > 9 )
  {
    v3 = 0x12 - v3;
  }
  if ( v3 >= 0 )
  {
    if ( v3 > 9 )
    {
      v3 = 9;
    }
  }
  else
  {
    v3 = 0;
  }
  sub_5D007((const void *)((v3 << 8) + 0xB00 + dword_D8D8F));
  v9 = *(void (__noreturn **)())(a2 + 0xF);
  v8 = *(__int16 *)(a2 + 0x29);
  v7 = *(__int16 *)(a2 + 0x27);
  v6 = *(_DWORD *)(a2 + 7);
  v4 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a2 + 5));
  return sub_5D631((P_Type5)(a1 + 4), v4, v6, v7, v8, (int)byte_D8DA0, 0, v9, v9, 1);
}
// D8D8F: using guessed type int dword_D8D8F;

//----- (000156C0) --------------------------------------------------------
int __fastcall sub_156C0(int a1, int a2, unsigned __int16 a3)
{
  int v4; // ebp
  int result; // eax
  int v6; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+4h] [ebp-20h]
  int v8; // [esp+8h] [ebp-1Ch]
  int v9; // [esp+Ch] [ebp-18h]
  int v10; // [esp+10h] [ebp-14h]

  v10 = a2;
  *(_DWORD *)(a1 + 0xB) = 0x3F800000;
  v4 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)v10);
  if ( a3 >= sub_61223(v4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x38);
  }
  sub_5E1DD(v4, a3, 0, 0, 0, &v6);
  if ( v6 > (int)&unk_F4240 || v6 < (int)0xFFF0BDC0 )
  {
    memset(&v6, 0, 0x10u);
  }
  *(_WORD *)(a1 + 0x13) = v6;
  *(_WORD *)(a1 + 0x15) = v7;
  *(_WORD *)(a1 + 0x17) = v8;
  *(_WORD *)(a1 + 0x19) = v9;
  *(_WORD *)(a1 + 5) = v10;
  result = a3;
  *(_DWORD *)(a1 + 7) = a3;
  return result;
}

//----- (0001577C) --------------------------------------------------------
int __fastcall sub_1577C(int a1)
{
  sub_15788(a1);
  return a1;
}

//----- (00015788) --------------------------------------------------------
int __fastcall sub_15788(int result)
{
  *(_DWORD *)(result + 0x800) = 0;
  return result;
}

//----- (00015794) --------------------------------------------------------
int __fastcall sub_15794(int result, int a2)
{
  int v2; // ebx

  v2 = *(_DWORD *)(result + 0x800);
  if ( v2 < 0x200 )
  {
    if ( a2 )
    {
      *(_DWORD *)(result + 4 * v2) = a2;
      ++*(_DWORD *)(result + 0x800);
    }
  }
  return result;
}

//----- (000157B4) --------------------------------------------------------
int __fastcall sub_157B4(const void *a1, const void *a2)
{
  int v2; // edx
  float v4; // [esp+0h] [ebp-8h]
  float v5; // [esp+4h] [ebp-4h]

  v5 = *(float *)(*(_DWORD *)a1 + 0x2F);
  v4 = *(float *)(*(_DWORD *)a2 + 0x2F);
  v2 = 0;
  if ( v5 > (double)v4 )
  {
    return 0xFFFFFFFF;
  }
  if ( v5 < (double)v4 )
  {
    return 1;
  }
  return v2;
}

//----- (000157EC) --------------------------------------------------------
void __fastcall sub_157EC(size_t *a1)
{
  qsort(a1, a1[0x200], 4u, sub_157B4);
}

//----- (00015808) --------------------------------------------------------
char *__fastcall sub_15808(int a1, int a2, int a3)
{
  int v3; // edi
  char **v4; // esi
  char *v5; // ecx
  float v7; // [esp+Ch] [ebp-24h]
  float v8; // [esp+10h] [ebp-20h]
  float v9; // [esp+18h] [ebp-18h]
  float v10; // [esp+1Ch] [ebp-14h]
  float v11; // [esp+20h] [ebp-10h]

  v3 = *(_DWORD *)(a1 + 0x800) - 1;
  v4 = (char **)(a1 + 4 * v3);
  while ( (v3 & 0x8000u) == 0 )
  {
    if ( !v4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x9E);
    }
    v5 = *v4;
    if ( **v4 >= 9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0xA2);
    }
    if ( *v5 == 5 )
    {
      if ( (*(__int16 *)(v5 + 0x27) - a2) * (*(__int16 *)(v5 + 0x27) - a2)
         + (*(__int16 *)(v5 + 0x29) - a3) * (*(__int16 *)(v5 + 0x29) - a3) < 0x50 )
      {
        return v5;
      }
    }
    else if ( *v5 != 4 )
    {
      v8 = (double)*(unsigned int *)(v5 + 0xF) * flt_903A5;
      v7 = (float)*(__int16 *)(v5 + 0x27);
      v9 = (float)a2;
      if ( (double)*(__int16 *)(v5 + 0x13) * v8 + v7 <= v9 )
      {
        v11 = (float)*(__int16 *)(v5 + 0x29);
        v10 = (float)a3;
        if ( (double)*(__int16 *)(v5 + 0x15) * v8 + v11 <= v10
          && (double)*(__int16 *)(v5 + 0x17) * v8 + v7 >= v9
          && (double)*(__int16 *)(v5 + 0x19) * v8 + v11 >= v10 )
        {
          return v5;
        }
      }
    }
    LOWORD(v3) = v3 - 1;
    v4 += 0xFFFFFFFF;
  }
  return 0;
}
// 903A5: using guessed type float flt_903A5;

//----- (00015948) --------------------------------------------------------
int __fastcall sub_15948(int a1, int a2)
{
  int **v2; // ebp
  unsigned int v3; // eax
  int v4; // eax
  int v5; // edx
  int v6; // edi
  __int64 v7; // rax
  double v8; // st7
  int v9; // eax
  double v10; // st6
  int result; // eax
  _BYTE *v12; // esi
  int v13; // [esp-20h] [ebp-88h]
  int v14; // [esp-1Ch] [ebp-84h]
  int v15; // [esp-18h] [ebp-80h]
  void (__noreturn *v16)(); // [esp-8h] [ebp-70h]
  char v17; // [esp-4h] [ebp-6Ch]
  int v19; // [esp+Ch] [ebp-5Ch]
  int v20; // [esp+18h] [ebp-50h]
  float v22; // [esp+20h] [ebp-48h]
  int v23; // [esp+24h] [ebp-44h]
  _BYTE **v24; // [esp+2Ch] [ebp-3Ch]
  int v25; // [esp+30h] [ebp-38h]
  __int16 v26; // [esp+40h] [ebp-28h]
  int v27; // [esp+4Ah] [ebp-1Eh]

  v24 = (_BYTE **)a1;
  v26 = 0;
  v2 = (int **)(a2 + 4);
  while ( 1 )
  {
    result = v26;
    if ( v26 >= *(_DWORD *)(a1 + 0x800) )
    {
      break;
    }
    v12 = *v24;
    if ( (**v24 != 4 || *(_DWORD *)(a2 + 0x504A)) && *v12 != 0xFF )
    {
      if ( *(_DWORD *)(v12 + 0x23) && (*(_DWORD *)(a2 + 0x5042) || *v12 == 6) && (v12[0x33] & 2) == 0 )
      {
        v3 = 0xFFFFFFFF;
      }
      else
      {
        v3 = 0;
      }
      if ( v3 )
      {
        v4 = 0x72;
        if ( *(_DWORD *)(v12 + 0x1F) )
        {
          v4 = 0x90;
        }
        if ( *v12 == 6 && *(_BYTE *)(a2 + 0xB7) == 3 )
        {
          v4 = 0xF3;
        }
        sub_5C001(
          v2,
          *(__int16 *)(v12 + 0x2B),
          *(__int16 *)(v12 + 0x2D),
          *(__int16 *)(v12 + 0x27),
          *(__int16 *)(v12 + 0x29),
          0,
          (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v4);
      }
      if ( (v12[0x33] & 8) == 0 )
      {
        if ( (v12[0x33] & 4) != 0 )
        {
          sub_139E0(a2, (int)v12);
        }
        else
        {
          v5 = *(unsigned __int16 *)(v12 + 5);
          if ( (unsigned __int16)v5 != 0xFFFF )
          {
            if ( *v12 == 8 )
            {
              v25 = v12[0x33] & 4;
              v6 = *(_DWORD *)(v12 + 1);
              v23 = v25;
              v7 = *(__int16 *)(v12 + 0x27) - *(__int16 *)(v6 + 0x27);
              v19 = (HIDWORD(v7) ^ v7) - HIDWORD(v7);
              if ( 2 * v19 )
              {
                v8 = flt_903AD / (double)(2 * v19);
                v25 = (int)((double)v19 * v8 + dbl_903B1);
                v23 = (int)(v8 * (double)v19 + dbl_903B1);
              }
              sub_5C001(
                v2,
                v25 + *(__int16 *)(v12 + 0x27),
                v23 + *(__int16 *)(v12 + 0x29),
                v25 + *(__int16 *)(v6 + 0x27),
                v23 + *(__int16 *)(v6 + 0x29),
                0,
                (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x6A);
              sub_5C001(
                v2,
                *(__int16 *)(v12 + 0x27) - v25,
                *(__int16 *)(v12 + 0x29) - v23,
                *(__int16 *)(v6 + 0x27) - v25,
                *(__int16 *)(v6 + 0x29) - v23,
                0,
                (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x6A);
              sub_5C001(
                v2,
                *(__int16 *)(v12 + 0x27),
                *(__int16 *)(v12 + 0x29),
                *(__int16 *)(v6 + 0x27),
                *(__int16 *)(v6 + 0x29),
                0,
                (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x6D);
            }
            else
            {
              v17 = v12[0x33] & 4;
              v16 = *(void (__noreturn **)())(v12 + 0xF);
              v15 = *(__int16 *)(v12 + 0x29);
              v14 = *(__int16 *)(v12 + 0x27);
              v13 = *(_DWORD *)(v12 + 7);
              v9 = sub_1B084((unsigned int)&unk_12FC20, v5);
              sub_5D631((P_Type5)v2, v9, v13, v14, v15, (int)byte_D8DA0, v17, v16, v16, v17);
            }
          }
        }
      }
      v22 = (double)*(unsigned int *)(v12 + 0xF) * flt_903A9;
      if ( *v12 == 1 && sub_361B8(*(_DWORD *)(v12 + 1)) == 0xFFFFFFFF )
      {
        v20 = (int)((double)*(__int16 *)(v12 + 0x17) * v22 + flt_903B9);
        sub_5F048(
          (int)v2,
          *(__int16 *)(v12 + 0x27),
          *(__int16 *)(v12 + 0x29),
          (__int16)v20,
          (__int16)v20,
          (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(4
                                                              * (unsigned __int8)byte_A2F74[0x1EE
                                                                                          * *(unsigned __int8 *)(*(_DWORD *)(v12 + 1) + 0x57)]
                                                              + 0x13));
      }
      if ( v12 == *(_BYTE **)(a2 + 0xB3) )
      {
        v10 = (double)*(__int16 *)(v12 + 0x27);
        HIWORD(v27) = (int)((double)*(__int16 *)(v12 + 0x13) * v22 + v10);
        sub_2BB74(
          v2,
          (int *)(v27 >> 0x10),
          (int *)(__int16)(int)((double)*(__int16 *)(v12 + 0x15) * v22 + (double)*(__int16 *)(v12 + 0x29)),
          (int *)(__int16)(int)(v10 + (double)*(__int16 *)(v12 + 0x17) * v22),
          (int *)(__int16)(int)(v22 * (double)*(__int16 *)(v12 + 0x19) + (double)*(__int16 *)(v12 + 0x29)),
          0xF3u,
          0);
      }
    }
    ++v26;
    ++v24;
  }
  return result;
}
// 15C73: variable 'v27' is possibly undefined
// 903A9: using guessed type float flt_903A9;
// 903AD: using guessed type float flt_903AD;
// 903B1: using guessed type double dbl_903B1;
// 903B9: using guessed type float flt_903B9;

//----- (00015D20) --------------------------------------------------------
int __fastcall sub_15D20(int a1)
{
  sub_15D2C(a1);
  return a1;
}

//----- (00015D2C) --------------------------------------------------------
int __fastcall sub_15D2C(int result)
{
  *(_DWORD *)(result + 0x1900) = 0;
  return result;
}

//----- (00015D38) --------------------------------------------------------
int __fastcall sub_15D38(int result, const void *a2)
{
  int v2; // ebx
  int v4; // edx

  v2 = result;
  v4 = *(_DWORD *)(result + 0x1900);
  if ( v4 < 0x40 )
  {
    result = 0x64 * v4;
    qmemcpy((void *)(v2 + 0x64 * v4), a2, 0x64u);
    ++*(_DWORD *)(v2 + 0x1900);
  }
  return result;
}

//----- (00015D74) --------------------------------------------------------
int __fastcall sub_15D74(int result, int a2)
{
  int v2; // esi
  int i; // ecx

  v2 = result;
  for ( i = 0; i < *(_DWORD *)(v2 + 0x1900); ++i )
  {
    result = sub_15DA4(v2, a2, i);
  }
  return result;
}

//----- (00015DA4) --------------------------------------------------------
int __fastcall sub_15DA4(int result, int a2, unsigned __int16 a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // eax

  if ( a3 < *(int *)(result + 0x1900) )
  {
    v4 = result + 0x64 * a3;
    v5 = *(_DWORD *)(v4 + 0x60);
    if ( v5 < 0 || v5 >= 7 )
    {
      v6 = 0;
    }
    else
    {
      v6 = (unsigned __int8)byte_A2F74[0x1EE * v5] + 1;
    }
    return sub_62DA5((_DWORD *)(a2 + 4), 4, v4, (v6 << 8) + 0x1F00 + *(_DWORD *)(a2 + 0x19BE));
  }
  return result;
}

//----- (00015E1C) --------------------------------------------------------
void __fastcall sub_15E1C(int *a1, int a2)
{
  int *v2; // ebp
  int v3; // eax
  int *v4; // esi
  int j; // edi
  int v6; // [esp-18h] [ebp-3Ch]
  int v7; // [esp-14h] [ebp-38h]
  int i; // [esp+4h] [ebp-20h]
  int v10; // [esp+Ch] [ebp-18h]

  v2 = a1;
  for ( i = 0; i < a1[0x640]; ++i )
  {
    v3 = v2[0x18];
    if ( v3 < 0 || v3 >= 7 )
    {
      v10 = 0x6D;
    }
    else
    {
      v10 = 4 * (unsigned __int8)byte_A2F74[0x1EE * v3] + 0x13;
    }
    v4 = v2;
    for ( j = 0;
          j < 4;
          sub_5C001(
            (int **)(a2 + 4),
            v6,
            v7,
            v2[6 * (j & 3)],
            v2[6 * (j & 3) + 1],
            0,
            (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v10) )
    {
      ++j;
      v7 = v4[1];
      v6 = *v4;
      v4 += 6;
    }
    v2 += 0x19;
  }
  JUMPOUT(0x15ED0);
}
// 15ECF: control flows out of bounds to 15ED0

//----- (00015ED4) --------------------------------------------------------
int __fastcall sub_15ED4(T_TypeA2 *a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // edx

  sub_2C830(a1);
  v1 = _wcpp_2_ctor_array_(&a1[1].a.c[0xB], 0x64, &unk_959D8);
  v2 = _wcpp_2_ctor_array_(v1 + 0x4B0, 0x64, &unk_95A3C);
  v3 = (_DWORD *)(_wcpp_2_ctor_array_(v2 + 0xFA0, 0x64, &unk_959D8) + 0x7FC);
  *v3 = 0;
  v3 += 5;
  v3[0xFFFFFFFC] = 0;
  v3[0xFFFFFFFD] = 0;
  v3[1] = 0;
  v3[2] = 0;
  *v3 = 0;
  v4 = sub_1577C((int)(v3 + 6));
  v5 = sub_1577C(v4 + 0x804);
  v6 = sub_1577C(v5 + 0x804);
  v7 = sub_15D20(v6 + 0x804);
  v8 = sub_1B4F0((_DWORD *)(v7 + 0x1904)) + 0x26;
  *v8 = 0;
  v8 += 3;
  v8[0xFFFFFFFE] = 0;
  v8[0xFFFFFFFF] = 0;
  *v8 = 0;
  v8 += 3;
  v8[0xFFFFFFFE] = 0;
  v8[0xFFFFFFFF] = 0;
  *v8 = 0;
  v8 += 3;
  v8[0xFFFFFFFE] = 0;
  v8[0xFFFFFFFF] = 0;
  *v8 = 0;
  v8 += 0xFFFFFFFA;
  v8[7] = 0;
  v8[8] = 0;
  v8[1] = 0;
  v8[2] = 0;
  *v8 = 0x3F800000;
  v8[3] = 0;
  v8[4] = 0x3F800000;
  v8[5] = 0;
  v8[6] = 0;
  v8[7] = 0;
  v8[8] = 0x3F800000;
  v9 = _wcpp_2_ctor_array_((char *)v8 + 0x96, 0xF, &unk_959D8) - 0x4F80;
  *(_DWORD *)(v9 + 0xA7) = off_95A50;
  sub_16120(v9);
  return v9;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 95A50: using guessed type int (*off_95A50[6])();

//----- (0001604C) --------------------------------------------------------
void *__fastcall sub_1604C(int a1, char a2)
{
  void *v4; // eax
  void *v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  void *v16; // eax
  void *v17; // ebx

  if ( (a2 & 4) != 0 )
  {
    v4 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95A28);
    operator delete[](v4);
    return (void *)a1;
  }
  else
  {
    v6 = *(void **)(a1 + 0x19BE);
    *(_DWORD *)(a1 + 0xA7) = off_95A50;
    if ( v6 )
    {
      sub_2627C(v6);
    }
    operator delete[](*(void **)(a1 + 0x19BE));
    v7 = sub_1A9C0(a1 + 0x4F80);
    v8 = ((int (__fastcall *)(int, _DWORD))locret_1B66C)(v7 - 0x13A, 0);
    v9 = sub_15D2C(v8 - 0x1904);
    v10 = sub_15788(v9 - 0x804);
    v11 = sub_15788(v10 - 0x804);
    v12 = sub_15788(v11 - 0x804);
    v13 = sub_1A9E0(v12 - 0x828);
    v14 = sub_1AA00(v13 - 0xFA0);
    v15 = sub_1A9E0(v14 - 0x4B0);
    v16 = (void *)sub_2C848(v15 - 0xBE, 1);
    v17 = v16;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v16);
    }
    return v17;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95A50: using guessed type int (*off_95A50[6])();

//----- (00016120) --------------------------------------------------------
int __fastcall sub_16120(int a1)
{
  int v1; // ebp
  int v2; // edx
  FILE *v3; // eax
  FILE *v4; // ecx
  int v5; // eax
  int v6; // edi
  int v7; // esi
  _WORD *v8; // ebx
  char s[200]; // [esp+0h] [ebp-12Ch] BYREF
  char v11[60]; // [esp+C8h] [ebp-64h] BYREF
  int v12; // [esp+104h] [ebp-28h] BYREF
  int v13; // [esp+108h] [ebp-24h] BYREF
  int v14; // [esp+10Ch] [ebp-20h] BYREF
  int v15; // [esp+110h] [ebp-1Ch] BYREF

  v1 = a1;
  *(_DWORD *)(a1 + 0xAB) = 0;
  *(_DWORD *)(a1 + 0x1D2A) = 0;
  v2 = a1 + 0x190;
  *(_DWORD *)(a1 + 0x19BE) = 0;
  do
  {
    a1 += 4;
    *(_DWORD *)(a1 + 0x137A) = 0;
  }
  while ( a1 != v2 );
  *(_DWORD *)(v1 + 0x1D1E) = 0;
  *(_DWORD *)(v1 + 0x1D22) = 0;
  *(_DWORD *)(v1 + 0x1D26) = 0;
  *(_DWORD *)(v1 + 0xB3) = 0;
  *(_DWORD *)(v1 + 0xAF) = 0;
  *(_BYTE *)(v1 + 0xB7) = 0;
  *(_BYTE *)(v1 + 0x4F2E) = 0;
  *(_DWORD *)(v1 + 0xB8) = 2;
  *(_WORD *)(v1 + 0xBC) = 0xFFFF;
  *(_DWORD *)(v1 + 0x4F2F) = 0;
  *(_DWORD *)(v1 + 0x4F33) = 0;
  *(_DWORD *)(v1 + 0x503A) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0x5042) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0x5046) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0x504A) = 0xFFFFFFFF;
  v3 = sub_1BB10("batfx.txt", 0);
  v4 = v3;
  if ( !v3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x1E4);
  }
  Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v3, s);
  sscanf(s, "%d", &v12);
  v5 = v12;
  *(_DWORD *)(v1 + 0x1A8E) = v12;
  if ( v5 >= 0x64 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x1EA);
  }
  v6 = 0;
  if ( *(int *)(v1 + 0x1A8E) > 0 )
  {
    v7 = v1;
    do
    {
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v4, s);
      sscanf(s, "%s", v11);
      *(_WORD *)(v7 + 0x19C6) = sub_1B270((int)&unk_12FC20, v11, 0xFFFFFFFF);
      ++v6;
      v7 += 2;
    }
    while ( v6 < *(_DWORD *)(v1 + 0x1A8E) );
  }
  v8 = (_WORD *)v1;
  do
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v4, s);
    sscanf(s, "%d %d %d %d", &v12, &v13, &v14, &v15);
    v8[0xD49] = v12;
    v8[0xD4A] = v13;
    v8[0xDE7] = v14;
    v8 += 2;
    v8[0xDE6] = v15;
  }
  while ( v8 != (_WORD *)(v1 + 0x13C) );
  return fclose(v4);
}
// 16120: using guessed type char var_64[60];

//----- (00016348) --------------------------------------------------------
int __fastcall sub_16348(int a1, unsigned __int16 a2, int a3, signed int a4)
{
  int result; // eax
  int v7; // edx
  char v8; // ah
  int v9; // ebx
  int v10; // edx
  int v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // edx
  int v15; // eax
  int v16; // ebx
  signed int v17; // esi
  int v18; // edi
  int v19; // ecx
  char v20; // ah
  char *v21; // edx
  char v22; // bl
  char v23; // al
  int v24; // edi
  int v25; // eax
  char v26; // ah
  char v27; // ch
  char v28; // bl
  char v29; // dl
  int v30; // edx
  char v31; // cl
  int v32; // edx
  int v33; // ecx
  int v34; // eax
  int v35; // edx
  int v36; // ebx
  int v37; // eax
  int v38; // eax
  int v39; // [esp-4h] [ebp-24h]
  int v40; // [esp-4h] [ebp-24h]
  _BYTE v41[5]; // [esp+8h] [ebp-18h]
  int v42; // [esp+10h] [ebp-10h]

  v42 = a3;
  if ( a2 < 0x3Au )
  {
    if ( a2 >= 6u )
    {
      if ( a2 <= 6u )
      {
        sub_5A270(&V_Type3_stru_10AE70, 0, 0, 0);
        sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 8);
        return 0xFFFFFFFF;
      }
      if ( a2 < 0xDu )
      {
        if ( a2 <= 7u )
        {
          if ( !*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x3B7);
          }
          sub_17260(a1);
          sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
          return 0xFFFFFFFF;
        }
        if ( a2 != 8 )
        {
          return sub_2F424(a1, a2, a3, a4);
        }
        if ( *(_BYTE *)(a1 + 0xB7) != 4 )
        {
          v15 = a3;
          v16 = *(_DWORD *)(a1 + 8);
          if ( v15 < v16
            || v15 > *(_DWORD *)(a1 + 0x10)
            || (v17 = *(_DWORD *)(a1 + 0xC), a4 < v17)
            || a4 > *(_DWORD *)(a1 + 0x14) )
          {
            *(_DWORD *)(a1 + 0xAF) = 0;
            *(_DWORD *)(a1 + 0x1D0E) = 0x49742400;
            sub_18C2C(a1, 0);
            return 0;
          }
          if ( !*(_DWORD *)(a1 + 0x4F2F) )
          {
            v18 = a4 - v17;
            v19 = v42 - v16;
            sub_17204(a1, v42 - v16, v18);
            if ( !*(_DWORD *)(a1 + 0xAF) )
            {
              v20 = *(_BYTE *)(a1 + 0xB7);
              if ( v20 == 2 )
              {
                sub_16FC0(a1, v19, v18, v19);
              }
              else if ( v20 == 3 )
              {
                sub_171D0(a1, v19, v18);
              }
            }
            sub_18C2C(a1, 0);
            if ( *(_BYTE *)(a1 + 0xB7) == 1 )
            {
              v21 = *(char **)(a1 + 0xAF);
              if ( v21 )
              {
                v22 = *v21;
                v23 = 0;
                if ( *v21 == 2 )
                {
                  v23 = 3;
                }
                else if ( v22 == 3 )
                {
                  v23 = 4;
                }
                else if ( v22 == 1 )
                {
                  v23 = 2;
                }
                v24 = 0x6B;
                if ( sub_56D30(
                       (int)&V_Type3_stru_10AE70,
                       *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
                       0x322,
                       v23,
                       *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1)) == 0xFFFFFFFF )
                {
                  v24 = 0xF3;
                }
                sub_5C001(
                  (int **)(a1 + 4),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xB3) + 0x27),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xB3) + 0x29),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xAF) + 0x27),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xAF) + 0x29),
                  0,
                  (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v24);
                return 0;
              }
            }
          }
        }
      }
      else
      {
        if ( a2 > 0xDu )
        {
          if ( a2 < 0x32u || a2 > 0x33u && (a2 < 0x36u || a2 > 0x37u) )
          {
            return sub_2F424(a1, a2, a3, a4);
          }
          if ( *(_DWORD *)(a1 + 0x39) != 0xFFFFFFFF )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x2E5);
          }
          v25 = 0;
          if ( a2 == 0x32 )
          {
            v26 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v26 & 1) != 0 )
            {
              if ( (v26 & 2) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v26 & 0xFD;
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v26 & 0xFE;
                sub_18C2C(a1, 0);
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v26 & 0xFC | 1;
            }
            v25 = 3;
          }
          if ( a2 == 0x33 )
          {
            v27 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v27 & 1) != 0 )
            {
              if ( (v27 & 2) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v27 & 0xFE;
                sub_18C2C(a1, 0);
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v27 | 2;
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v27 | 3;
            }
            v25 = 3;
          }
          if ( a2 == 0x36 )
          {
            v28 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v28 & 4) != 0 )
            {
              if ( (v28 & 8) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v28 & 0xF7;
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v28 & 0xFB;
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v28 & 0xF3 | 4;
            }
            v25 = 0xC;
          }
          if ( a2 == 0x37 )
          {
            v29 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v29 & 4) != 0 )
            {
              if ( (v29 & 8) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v29 & 0xFB;
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v29 | 8;
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v29 | 0xC;
            }
            v25 = 0xC;
          }
          if ( v42 == 4 )
          {
            sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 1, 0x3B, v25, 0);
          }
          return 0xFFFFFFFF;
        }
        if ( *(_BYTE *)(a1 + 0xB7) != 4 )
        {
          sub_187EC(a1);
          sub_18C2C(a1, 0);
          return 0;
        }
      }
      return 0;
    }
    if ( a2 < 3u )
    {
      if ( !a2 )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      if ( a2 <= 1u )
      {
        *(_DWORD *)(a1 + 0xAB) = sub_56DA8((int)&V_Type3_stru_10AE70, "BatControlWnd", 0);
        v7 = *(_DWORD *)(a1 + 0x41);
        sub_56400(&V_Type3_stru_10AE70, v7, 0x3A, 0, 0, 0);
        sub_186B8(a1, v7, a3);
        sub_2F424(a1, a2, a3, a4);
        *(_DWORD *)(a1 + 0x4F2F) = 0;
        return 0;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 0xB7) == 4 )
        {
          sub_12238(*(_DWORD *)(a1 + 0xAB), 0);
        }
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        sub_185CC(a1);
        sub_2F424(a1, a2, a3, a4);
        return 0;
      }
    }
    if ( a2 <= 3u )
    {
      if ( (unsigned int)a4 < 0xD )
      {
        if ( a4 != 0xC )
        {
          return 0;
        }
        if ( flt_12FC1C > dbl_9043E )
        {
          flt_12FC1C = flt_12FC1C * dbl_90446;
          return 0;
        }
      }
      else if ( (unsigned int)a4 <= 0xD )
      {
        if ( flt_12FC1C < (double)flt_90432 )
        {
          flt_12FC1C = flt_12FC1C * dbl_90436;
          return 0;
        }
      }
      else if ( (unsigned int)a4 >= 0x1C )
      {
        if ( (unsigned int)a4 > 0x1C && a4 != 0x39 )
        {
          return 0;
        }
        if ( *(_BYTE *)(a1 + 0xB7) == 4 )
        {
          *(_DWORD *)(a1 + 0x5036) = 0xFFFFFFFF;
        }
      }
      return 0;
    }
    if ( a2 > 4u )
    {
      if ( *(_BYTE *)(a1 + 0xB7) == 4 )
      {
        result = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x5036) = 0xFFFFFFFF;
        return result;
      }
      if ( a3 >= *(_DWORD *)(a1 + 8)
        && a3 <= *(_DWORD *)(a1 + 0x10)
        && a4 >= *(_DWORD *)(a1 + 0xC)
        && a4 <= *(_DWORD *)(a1 + 0x14) )
      {
        sub_4FB90((int)&unk_10914C, 0);
        if ( *(_DWORD *)(a1 + 0xAF) )
        {
          sub_16D6C(a1, a3, a4, 0);
        }
        else if ( *(_DWORD *)(a1 + 0xB3) )
        {
          v40 = *(_DWORD *)(a1 + 0xAF);
          v14 = *(_DWORD *)(a1 + 0xAB);
          *(_DWORD *)(a1 + 0xB3) = 0;
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v14 + 0x41), 0x320, 0, v40);
          *(_BYTE *)(a1 + 0xB7) = 0;
        }
        sub_18C2C(a1, 0);
        sub_17260(a1);
        return 0xFFFFFFFF;
      }
      return 0;
    }
    if ( *(_BYTE *)(a1 + 0xB7) == 4 )
    {
      return 0xFFFFFFFF;
    }
    if ( a3 < *(_DWORD *)(a1 + 8)
      || a3 > *(_DWORD *)(a1 + 0x10)
      || a4 < *(_DWORD *)(a1 + 0xC)
      || a4 > *(_DWORD *)(a1 + 0x14) )
    {
      return 0;
    }
    sub_4FB90((int)&unk_10914C, 0);
    if ( *(_DWORD *)(a1 + 0xAF) )
    {
      sub_16D6C(a1, a3, a4, 1);
    }
    else
    {
      v8 = *(_BYTE *)(a1 + 0xB7);
      if ( v8 == 2 )
      {
        if ( *(unsigned __int16 *)(a1 + 0xBC) == 0xFFFF )
        {
          *(_BYTE *)(a1 + 0xB7) = 0;
        }
        else
        {
          v9 = a4 - *(_DWORD *)(a1 + 0xC);
          v10 = v42 - *(_DWORD *)(a1 + 8);
          *(_BYTE *)(a1 + 0xB7) = 3;
          sub_171D0(a1, v10, v9);
        }
      }
      else
      {
        if ( v8 == 3 )
        {
          v11 = *(_DWORD *)(a1 + 0xAB);
          *(_BYTE *)(a1 + 0xB7) = 0;
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v11 + 0x41), 0x326, 5, a1 + 0x1D0A);
          *(_DWORD *)(a1 + 0xB3) = 0;
          sub_187EC(a1);
          v12 = a1;
LABEL_43:
          sub_18C2C(v12, 0);
          return 0xFFFFFFFF;
        }
        if ( v8 )
        {
          return 0xFFFFFFFF;
        }
        v39 = *(_DWORD *)(a1 + 0xAF);
        v13 = *(_DWORD *)(a1 + 0xAB);
        *(_DWORD *)(a1 + 0xB3) = 0;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v13 + 0x41), 0x320, 0, v39);
      }
    }
    v12 = a1;
    goto LABEL_43;
  }
  if ( a2 <= 0x3Au )
  {
    LOBYTE(a3) = *(_BYTE *)(a1 + 0x4F2F);
    if ( (a3 & 1) != 0 )
    {
      if ( (a3 & 2) != 0 )
      {
        v30 = 2;
      }
      else
      {
        v30 = 0xFFFFFFFE;
      }
      sub_17E50(a1, v30, a3, a4);
    }
    v31 = *(_BYTE *)(a1 + 0x4F2F);
    if ( (v31 & 4) != 0 )
    {
      if ( (v31 & 8) != 0 )
      {
        v32 = 0xA;
      }
      else
      {
        v32 = 0xFFFFFFF6;
      }
      sub_182B8(a1, v32);
    }
    if ( (*(_BYTE *)(a1 + 0x4F2F) & 5) != 0 )
    {
      goto LABEL_123;
    }
    return 0;
  }
  if ( a2 < 0x4Cu )
  {
    if ( a2 >= 0x47u )
    {
      if ( a2 <= 0x47u )
      {
        *(_DWORD *)(a1 + 0x4F2F) = 0;
        sub_17F54(a1);
        sub_18C2C(a1, 0);
        return 0xFFFFFFFF;
      }
      else
      {
        if ( a2 < 0x4Au )
        {
          return sub_2F424(a1, a2, a3, a4);
        }
        if ( a2 <= 0x4Au )
        {
          *(_DWORD *)(a1 + 0x503A) = ~*(_DWORD *)(a1 + 0x503A);
          sub_18C2C(a1, 0);
        }
        return 0;
      }
    }
    if ( a2 <= 0x3Bu )
    {
      *(_DWORD *)(a1 + 0x4F2F) &= ~a3;
      if ( (a3 & 1) != 0 )
      {
        sub_18C2C(a1, 0);
      }
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x3B);
      return 0xFFFFFFFF;
    }
    if ( a2 != 0x46 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    return 0;
  }
  if ( a2 <= 0x4Cu )
  {
    v33 = ~*(_DWORD *)(a1 + 0x5042);
    *(_DWORD *)(a1 + 0x5046) = v33;
    *(_DWORD *)(a1 + 0x5042) = v33;
    sub_18C2C(a1, 0);
    return 0;
  }
  if ( a2 < 0x52u )
  {
    if ( a2 < 0x50u )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( a2 > 0x50u )
    {
      *(_BYTE *)(a1 + 0xB7) = 1;
      return 0;
    }
    if ( a3 >= 1 && *(__int16 *)(dword_D3660 + 0x5A) >= a3 )
    {
      dword_D3664 = *(_DWORD *)(dword_D3660 + 4 * a3 + 0x42);
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
      return 0;
    }
    return 0;
  }
  if ( a2 <= 0x52u )
  {
    sub_126F8(a1, a3, a1);
    return 0;
  }
  if ( a2 <= 0x53u )
  {
    *(_DWORD *)v41 = *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB);
    v41[4] = *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xAF);
    if ( !v41[0] )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x39A);
    }
    v34 = sub_12AE4(a1, *(int *)&v41[1]);
    *(_DWORD *)(a1 + 0xB3) = v34;
    v35 = *(__int16 *)(v34 + 0x27);
    if ( v35 < 0
      || (v36 = *(__int16 *)(v34 + 0x29), v36 < 0)
      || v35 > *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8)
      || v36 > *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) )
    {
      sub_17E88(a1, *(_DWORD *)(a1 + 0xB3));
    }
    v37 = *(_DWORD *)(a1 + 0xB3);
    if ( *(_BYTE *)v37 == 2 )
    {
      v38 = *(_DWORD *)(v37 + 1);
      if ( *(_WORD *)(v38 + 0x56) == (unsigned __int8)byte_104BEA && *(int *)(v38 + 0x88) > 0 )
      {
        *(_BYTE *)(a1 + 0xB7) = 2;
      }
    }
LABEL_123:
    sub_18C2C(a1, 0);
    return 0;
  }
  if ( a2 != 0x54 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  sub_172B0(a1);
  return 0;
}
// 90432: using guessed type float flt_90432;
// 90436: using guessed type double dbl_90436;
// 9043E: using guessed type double dbl_9043E;
// 90446: using guessed type double dbl_90446;
// 96BAC: using guessed type int dword_96BAC;
// D3660: using guessed type int dword_D3660;
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00016D6C) --------------------------------------------------------
void __fastcall sub_16D6C(int a1, int a2, int a3, int a4)
{
  unsigned int v5; // ebp
  char v6; // bh
  char v7; // al
  int v8; // edi
  char *v9; // eax
  char v10; // dl
  int v11; // eax
  char v12; // ch
  int v13; // ebx
  char v14; // bh
  int v15; // eax
  int v16; // edx
  char v17; // al
  char v18; // ah

  if ( !*(_DWORD *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x3D7);
  }
  v5 = 0;
  if ( !a4 )
  {
    sub_17E88(a1, *(_DWORD *)(a1 + 0xAF));
    goto LABEL_32;
  }
  if ( *(_BYTE *)(a1 + 0xB7) == 1 )
  {
    v6 = **(_BYTE **)(a1 + 0xAF);
    v7 = 0;
    switch ( v6 )
    {
      case 2:
        v7 = 3;
        break;
      case 1:
        v7 = 2;
        break;
      case 3:
        v7 = 4;
        break;
    }
    v8 = v7;
    if ( sub_56D30(
           (int)&V_Type3_stru_10AE70,
           *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
           0x322,
           v7,
           *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1)) == 0xFFFFFFFF )
    {
      *(_BYTE *)(a1 + 0xB7) = 0;
      sub_56D30(
        (int)&V_Type3_stru_10AE70,
        *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
        0x326,
        v8,
        *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1));
      *(_DWORD *)(a1 + 0xB3) = 0;
    }
  }
  else
  {
    v9 = *(char **)(a1 + 0xAF);
    v10 = *v9;
    if ( *v9 != 2 )
    {
      if ( v10 == 1 )
      {
        v12 = *(_BYTE *)(a1 + 0xB7);
        if ( v12 != 2 && v12 != 3 )
        {
          v13 = *(_DWORD *)(a1 + 0xB3);
          if ( v9 != (char *)v13 || v12 )
          {
            v5 = 0xFFFFFFFF;
            *(_DWORD *)(a1 + 0xB3) = *(_DWORD *)(a1 + 0xAF);
          }
          else
          {
            dword_D3664 = *(_DWORD *)(v13 + 1);
            *(_DWORD *)(a1 + 0xAF) = 0;
            sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
          }
          goto LABEL_32;
        }
        *(_BYTE *)(a1 + 0xB7) = 0;
        sub_56D30(
          (int)&V_Type3_stru_10AE70,
          *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
          0x326,
          2,
          *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1));
      }
      else
      {
        if ( v10 != 3 )
        {
          goto LABEL_32;
        }
        v14 = *(_BYTE *)(a1 + 0xB7);
        v15 = *(_DWORD *)(v9 + 1);
        if ( v14 != 2 && v14 != 3 )
        {
          goto LABEL_32;
        }
        v16 = *(_DWORD *)(a1 + 0xAB);
        *(_BYTE *)(a1 + 0xB7) = 0;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v16 + 0x41), 0x326, 4, v15);
      }
      sub_187EC(a1);
      sub_18C2C(a1, 0);
      goto LABEL_32;
    }
    if ( !*(_BYTE *)(a1 + 0xB7) )
    {
      *(_DWORD *)(a1 + 0xB3) = v9;
      v11 = *(_DWORD *)(v9 + 1);
      v5 = 0xFFFFFFFF;
      if ( *(_WORD *)(v11 + 0x56) == (unsigned __int8)byte_104BEA && *(int *)(v11 + 0x88) > 0 )
      {
        *(_BYTE *)(a1 + 0xB7) = 2;
      }
    }
  }
LABEL_32:
  if ( v5 == 0xFFFFFFFF )
  {
    v17 = 0;
    v18 = **(_BYTE **)(a1 + 0xB3);
    if ( v18 == 2 )
    {
      v17 = 3;
    }
    else if ( v18 == 1 )
    {
      v17 = 2;
    }
    sub_56D30(
      (int)&V_Type3_stru_10AE70,
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
      0x320,
      v17,
      *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 1));
  }
  sub_17260(a1);
}

//----- (00016FC0) --------------------------------------------------------
int __fastcall sub_16FC0(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  double v6; // st7
  float *v7; // ecx
  float v9; // [esp+0h] [ebp-90h]
  float v10; // [esp+4h] [ebp-8Ch]
  int v11; // [esp+8h] [ebp-88h]
  int v12; // [esp+Ch] [ebp-84h]
  float v13; // [esp+10h] [ebp-80h] BYREF
  float v14; // [esp+14h] [ebp-7Ch]
  float v15; // [esp+18h] [ebp-78h]
  float v16; // [esp+1Ch] [ebp-74h] BYREF
  float v17; // [esp+20h] [ebp-70h]
  float v18; // [esp+24h] [ebp-6Ch]
  float v19; // [esp+28h] [ebp-68h]
  int v20; // [esp+2Ch] [ebp-64h]
  int v21; // [esp+30h] [ebp-60h]
  float v22; // [esp+34h] [ebp-5Ch] BYREF
  float v23; // [esp+38h] [ebp-58h]
  float v24; // [esp+3Ch] [ebp-54h]
  float v25; // [esp+40h] [ebp-50h]
  float v26; // [esp+44h] [ebp-4Ch]
  float v27; // [esp+48h] [ebp-48h]
  int v28[3]; // [esp+4Ch] [ebp-44h] BYREF
  int v29[3]; // [esp+58h] [ebp-38h] BYREF
  float v30; // [esp+64h] [ebp-2Ch] BYREF
  float v31; // [esp+68h] [ebp-28h]
  float v32; // [esp+6Ch] [ebp-24h]
  int v33; // [esp+70h] [ebp-20h]
  int v34; // [esp+74h] [ebp-1Ch]
  int *v35; // [esp+78h] [ebp-18h]
  float v36; // [esp+7Ch] [ebp-14h]
  int *v37; // [esp+80h] [ebp-10h]
  float *v38; // [esp+84h] [ebp-Ch]
  float v39; // [esp+88h] [ebp-8h]
  int v40; // [esp+8Ch] [ebp-4h]

  v40 = a4;
  v33 = a2 - *(__int16 *)(a1 + 0x4F22);
  v5 = *(__int16 *)(a1 + 0x4F24);
  v22 = (float)v33;
  v35 = v28;
  v34 = v5 - a3;
  v23 = 0.0;
  v24 = (float)(v5 - a3);
  v36 = *(float *)(a1 + 0x4F16);
  v19 = v22 * v36;
  *(float *)&v20 = 0.0 * v36;
  *(float *)v28 = v19;
  *(float *)&v21 = v24 * v36;
  v28[1] = v20;
  v22 = v19 * flt_9045D;
  v28[2] = v21;
  v23 = *(float *)&v20;
  v24 = *(float *)&v21 * flt_90461;
  v13 = *(float *)(a1 + 0x4E5E);
  v14 = *(float *)(a1 + 0x4E62);
  v15 = *(float *)(a1 + 0x4E66);
  v14 = 0.0;
  v30 = 0.0;
  v32 = 1.0;
  v31 = 0.0;
  v39 = sub_5309C(&v13, &v30);
  v10 = v14 * v32 - v15 * v31;
  *(float *)&v11 = v15 * v30 - v13 * v32;
  v37 = v29;
  *(float *)v29 = v10;
  v29[1] = v11;
  *(float *)&v12 = v13 * v31 - v14 * v30;
  v29[2] = v12;
  if ( *(float *)&v11 >= 0.0 )
  {
    v9 = -v39;
    sub_532AC(&v22, v9);
  }
  else
  {
    sub_532AC(&v22, v39);
  }
  v38 = &v16;
  v25 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  v25 = v22 + *(float *)(a1 + 0x1D1E);
  v26 = v23 + *(float *)(a1 + 0x1D22);
  v6 = v24 + *(float *)(a1 + 0x1D26);
  v16 = v25;
  v27 = v6;
  v17 = v26;
  v18 = v27;
  *(float *)(a1 + 0x1D0A) = v25;
  *(float *)(a1 + 0x1D0E) = v17;
  v7 = (float *)(a1 + 0x1D0A);
  v7[2] = v18;
  return sub_53440(v7);
}
// 9045D: using guessed type float flt_9045D;
// 90461: using guessed type float flt_90461;

//----- (000171D0) --------------------------------------------------------
int __fastcall sub_171D0(int a1, int a2, int a3)
{
  double v3; // st7
  float *v4; // eax

  v3 = (double)(a3 - 0xF0) * *(float *)(a1 + 0x4F16) * flt_90465 + *(float *)(a1 + 0x1D22);
  v4 = (float *)(a1 + 0x1D0A);
  v4[1] = v3;
  return sub_53440(v4);
}
// 90465: using guessed type float flt_90465;

//----- (00017204) --------------------------------------------------------
char *__fastcall sub_17204(int a1, int a2, int a3)
{
  char *result; // eax

  result = sub_15808(a1 + 0x1D36, a2, a3);
  *(_DWORD *)(a1 + 0xAF) = result;
  if ( !result )
  {
    result = sub_15808(a1 + 0x253A, a2, a3);
    *(_DWORD *)(a1 + 0xAF) = result;
  }
  if ( !*(_DWORD *)(a1 + 0xAF) )
  {
    result = sub_15808(a1 + 0x2D3E, a2, a3);
    *(_DWORD *)(a1 + 0xAF) = result;
  }
  return result;
}

//----- (00017260) --------------------------------------------------------
void __fastcall sub_17260(int result)
{
  char v1; // bl
  int v2; // edx

  if ( *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(result + 0x41) )
  {
    v1 = *(_BYTE *)(result + 0xB7);
    v2 = *(_DWORD *)(result + 0xB8);
    if ( v1 == 1 )
    {
      v2 += 8;
    }
    else if ( v1 == 2 || v1 == 3 )
    {
      v2 += 6;
    }
    if ( *(_DWORD *)(result + 0xAF) )
    {
      ++v2;
    }
    sub_5A270(&V_Type3_stru_10AE70, v2, 0, 0);
  }
}

//----- (000172B0) --------------------------------------------------------
void __fastcall sub_172B0(int a1)
{
  _BYTE *v2; // edx
  int v3; // eax
  char *v4; // esi
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  int v14; // eax
  int v15; // edx
  char s[176]; // [esp+0h] [ebp-B0h] BYREF

  v2 = *(_BYTE **)(a1 + 0xB3);
  if ( v2 )
  {
    v3 = *(_DWORD *)(a1 + 0xB3);
    v4 = 0;
    v5 = 0;
    if ( *v2 == 2 && (v6 = *(_DWORD *)(v3 + 1), *(_WORD *)(v6 + 0x56) == (unsigned __int8)byte_104BEA) )
    {
      v4 = "abanship";
      v5 = v6 + 0x34;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 0xB3);
      if ( *(_BYTE *)v7 == 1 )
      {
        v8 = *(_DWORD *)(v7 + 1);
        if ( (_BYTE)byte_104BEA == *(_BYTE *)(v8 + 0x57) )
        {
          v4 = "abanplan";
          v5 = v8 + 0x24;
        }
      }
    }
    if ( v4 )
    {
      v9 = sub_56DA8((int)&V_Type3_stru_10AE70, "HELPWINDOW", 0);
      sub_2FCB0((_DWORD *)v9, "help.txt", v4);
      v10 = s;
      sprintf(s, *(const char **)(v9 + 0xC9A), v5);
      v11 = *(char **)(v9 + 0xC9A);
      do
      {
        v12 = *v10;
        *v11 = *v10;
        if ( !v12 )
        {
          break;
        }
        v13 = v10[1];
        v10 += 2;
        v11[1] = v13;
        v11 += 2;
      }
      while ( v13 );
      if ( sub_552F8((unsigned int)&V_Type3_stru_10AE70, v9, 0) )
      {
        v14 = *(_DWORD *)(a1 + 0xB3);
        if ( *(_BYTE *)v14 == 2 )
        {
          sub_49940(*(_DWORD *)(v14 + 1));
        }
        else
        {
          sub_37040(*(_DWORD *)(v14 + 1));
        }
        *(_DWORD *)(a1 + 0xB3) = 0;
        v15 = *(_DWORD *)(a1 + 0xAB);
        *(_BYTE *)(a1 + 0xB7) = 0;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v15 + 0x41), 0x320, 0, 0);
        sub_187EC(a1);
        sub_18C2C(a1, 0);
      }
    }
  }
}

//----- (000173F4) --------------------------------------------------------
int __fastcall sub_173F4(int a1, int a2, int a3, int a4)
{
  sub_1B958(a1 + 0x4E46, (float *)(a1 + 0x1D1E), a1, a4);
  return sub_17430(a1);
}

//----- (00017430) --------------------------------------------------------
int __fastcall sub_17430(int a1)
{
  int v2; // esi
  int *v3; // edi
  int result; // eax
  double v5; // st7
  int v6; // ebx
  char v7; // dl
  char v8; // bh
  int v9; // edx
  float v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // eax
  double v15; // st7
  char v16; // al
  double v17; // st7
  float *v18; // edx
  float v19; // eax
  int *v20; // edx
  int v21; // edx
  int v22; // eax
  float *v23; // ebx
  int v24; // edx
  double v25; // st7
  int v26; // eax
  int v27[3]; // [esp+0h] [ebp-180h]
  int v28[25]; // [esp+14h] [ebp-16Ch] BYREF
  int v29[12]; // [esp+78h] [ebp-108h] BYREF
  float v30; // [esp+A8h] [ebp-D8h] BYREF
  float v31; // [esp+ACh] [ebp-D4h]
  float v32; // [esp+B0h] [ebp-D0h]
  int v33[3]; // [esp+B4h] [ebp-CCh] BYREF
  float v34; // [esp+C0h] [ebp-C0h]
  float v35; // [esp+C4h] [ebp-BCh]
  float v36; // [esp+C8h] [ebp-B8h]
  float v37; // [esp+CCh] [ebp-B4h] BYREF
  float v38; // [esp+D0h] [ebp-B0h]
  float v39; // [esp+D4h] [ebp-ACh]
  float v40; // [esp+D8h] [ebp-A8h] BYREF
  float v41; // [esp+DCh] [ebp-A4h]
  float v42; // [esp+E0h] [ebp-A0h]
  float v43; // [esp+E4h] [ebp-9Ch]
  float v44; // [esp+E8h] [ebp-98h]
  float v45; // [esp+ECh] [ebp-94h]
  float v46; // [esp+F0h] [ebp-90h] BYREF
  float v47; // [esp+F4h] [ebp-8Ch]
  float v48; // [esp+F8h] [ebp-88h]
  int v49[3]; // [esp+FCh] [ebp-84h] BYREF
  float v50; // [esp+108h] [ebp-78h] BYREF
  float v51; // [esp+10Ch] [ebp-74h]
  float v52; // [esp+110h] [ebp-70h]
  __int64 v53; // [esp+114h] [ebp-6Ch]
  float v54; // [esp+11Ch] [ebp-64h]
  float *v55; // [esp+120h] [ebp-60h]
  int *v56; // [esp+124h] [ebp-5Ch]
  int v57; // [esp+128h] [ebp-58h]
  int *v58; // [esp+12Ch] [ebp-54h]
  int v59; // [esp+130h] [ebp-50h]
  float *v60; // [esp+134h] [ebp-4Ch]
  int v61; // [esp+138h] [ebp-48h]
  int v62; // [esp+13Ch] [ebp-44h]
  int v63; // [esp+140h] [ebp-40h]
  float *v64; // [esp+144h] [ebp-3Ch]
  int v65; // [esp+148h] [ebp-38h]
  float v66; // [esp+14Ch] [ebp-34h]
  int v67; // [esp+150h] [ebp-30h]
  float v68; // [esp+154h] [ebp-2Ch]
  float *v69; // [esp+158h] [ebp-28h]
  float v70; // [esp+15Ch] [ebp-24h]
  int v71; // [esp+160h] [ebp-20h] BYREF
  __int16 v72[14]; // [esp+164h] [ebp-1Ch] BYREF

  v2 = *(_DWORD *)(a1 + 0x1D2A);
  v40 = 0.0;
  v41 = 0.0;
  v42 = 0.0;
  v46 = 0.0;
  v47 = 0.0;
  v48 = 0.0;
  v37 = 0.0;
  v38 = 0.0;
  v39 = 0.0;
  _wcpp_2_ctor_array_(v29, 4, &unk_959D8);
  v46 = 0.0;
  v47 = 0.0;
  v48 = 0.0;
  sub_53384(&v46, (float *)(a1 + 0x4E86), &v40);
  v29[0] = 0x41800000;
  v29[2] = 0x41800000;
  v29[3] = 0x41800000;
  v46 = v40;
  v29[0xB] = 0x41800000;
  v47 = v41;
  v48 = v42;
  v3 = v29;
  v29[1] = 0;
  v29[4] = 0;
  v29[7] = 0;
  v29[5] = 0xC1800000;
  v29[6] = 0xC1800000;
  v29[8] = 0xC1800000;
  v29[9] = 0xC1800000;
  v29[0xA] = 0;
  v60 = &v30;
  do
  {
    sub_53384((float *)v3, (float *)(a1 + 0x4E86), &v40);
    v55 = &v50;
    v34 = v40 - v46;
    v50 = v34;
    v35 = v41 - v47;
    v51 = v35;
    v36 = v42 - v48;
    v52 = v36;
    *(float *)v3 = v34;
    *((float *)v3 + 1) = v51;
    v3 += 3;
    result = LODWORD(v52);
    *((float *)v3 + 0xFFFFFFFF) = v52;
  }
  while ( v3 != (int *)v60 );
  v5 = *(float *)(a1 + 0x4F2A) * flt_9049E;
  v6 = *(_DWORD *)(a1 + 0x1D32);
  v59 = 0;
  v66 = v5;
  if ( v6 > 0 )
  {
    v61 = a1 + 0x1D36;
    v63 = a1 + 0x253A;
    v67 = a1 + 0x3542;
    v65 = a1 + 0x2D3E;
    v64 = (float *)(a1 + 0x4E46);
    v69 = (float *)(a1 + 0x1D1E);
    v62 = a1 + 0x4F80;
    do
    {
      if ( *(_BYTE *)v2 != 6
        || ((v7 = *(_BYTE *)(a1 + 0xB7), v7 == 2) || v7 == 3)
        && !*(_DWORD *)(a1 + 0xAF)
        && *(_DWORD *)(a1 + 0x1D0E) != 0x49742400 )
      {
        if ( *(_BYTE *)v2 != 0xFF )
        {
          v8 = *(_BYTE *)v2;
          *(_DWORD *)(v2 + 0x1B) = 0xFFFFFFFF;
          if ( v8 == 4 )
          {
            v9 = *(_DWORD *)(v2 + 1);
            v40 = *(float *)(v9 + 1);
            v41 = *(float *)(v9 + 5);
            v42 = *(float *)(v9 + 9);
            sub_53114(&v40, v64);
            if ( v42 > 0.0 )
            {
              sub_533D4(
                &v40,
                *(float *)(a1 + 0x4E6E),
                *(__int16 *)(a1 + 0x4F22),
                *(__int16 *)(a1 + 0x4F24),
                (int)v72,
                (int)&v71);
              *(_WORD *)(v2 + 0x27) = v72[0];
              *(_WORD *)(v2 + 0x29) = v71;
              v10 = v42;
              *(_DWORD *)(v2 + 0x1B) = 0;
              *(_DWORD *)(v2 + 0x23) = 0;
              *(float *)(v2 + 0x2F) = v10;
              v11 = v65;
              *(_DWORD *)(v2 + 0xF) = sub_10000;
              sub_15794(v11, v2);
            }
          }
          else
          {
            v13 = *(_BYTE *)(v2 + 0x33) & 0x10;
            v57 = 0xFFFFFFFF;
            if ( v13 )
            {
              v14 = 0xC * *(char *)(v2 + 0x34);
              v37 = *(float *)(v14 + v62);
              v38 = *(float *)(v14 + v62 + 4);
              v39 = *(float *)(v14 + v62 + 8);
            }
            else
            {
              switch ( *(_BYTE *)v2 )
              {
                case 0:
                  v37 = 0.0;
                  v38 = 0.0;
                  v39 = 0.0;
                  break;
                case 1:
                  v20 = *(int **)(v2 + 1);
                  v37 = *(float *)v20;
                  v38 = *((float *)v20 + 1);
                  v39 = *((float *)v20 + 2);
                  break;
                case 2:
                  v21 = *(_DWORD *)(v2 + 1);
                  v37 = *(float *)(v21 + 0x9E);
                  v38 = *(float *)(v21 + 0xA2);
                  v39 = *(float *)(v21 + 0xA6);
                  v57 = *(__int16 *)(*(_DWORD *)(v2 + 1) + 0x56);
                  break;
                case 3:
                  v18 = *(float **)(v2 + 1);
                  if ( (*(_BYTE *)(v2 + 0x33) & 1) != 0 )
                  {
                    v37 = v18[2];
                    v38 = v18[3];
                    v19 = v18[4];
                  }
                  else
                  {
                    v37 = v18[5];
                    v38 = v18[6];
                    v19 = v18[7];
                  }
                  v39 = v19;
                  break;
                case 6:
                  v37 = *(float *)(a1 + 0x1D0A);
                  v38 = *(float *)(a1 + 0x1D0E);
                  v39 = *(float *)(a1 + 0x1D12);
                  sub_53440(&v37);
                  break;
                default:
                  Q_AssertLogBreakExit_sub_261A8(0, "..\\batmode.cpp", 0x53E);
                  break;
              }
            }
            v46 = v37;
            v47 = v38;
            v48 = v39;
            sub_53384(&v46, (float *)(a1 + 0x4E86), &v40);
            v47 = *(float *)(a1 + 0x1D22);
            v56 = v33;
            v43 = 0.0;
            v44 = 0.0;
            v45 = 0.0;
            v43 = v46 - *v69;
            v44 = v47 - v69[1];
            v45 = v48 - v69[2];
            *(float *)v33 = v43;
            *(float *)&v33[1] = v44;
            *(float *)&v33[2] = v45;
            v46 = v43;
            v47 = v44;
            v48 = v45;
            v15 = sqrt(v44 * v44 + v43 * v43 + v45 * v45);
            *(_DWORD *)(v2 + 0x23) = (v15 >= v66) - 1;
            if ( v42 > (double)*(float *)(a1 + 0x4E72) && v42 < (double)*(float *)(a1 + 0x4E76) )
            {
              sub_533D4(
                &v40,
                *(float *)(a1 + 0x4E6E),
                *(__int16 *)(a1 + 0x4F22),
                *(__int16 *)(a1 + 0x4F24),
                (int)v72,
                (int)&v71);
              *(_WORD *)(v2 + 0x27) = v72[0];
              *(_WORD *)(v2 + 0x29) = v71;
              *(float *)(v2 + 0x2F) = v42;
              v16 = *(_BYTE *)v2;
              *(_DWORD *)(v2 + 0x1B) = 0;
              if ( v16 == 7 )
              {
                *(float *)(v2 + 0x2F) = *(float *)(v2 + 0x2F) + flt_904AA;
              }
              v17 = *(float *)(a1 + 0x4F1A) * flt_904A2;
              v70 = 131072.0;
              v68 = v17;
              if ( *(float *)(v2 + 0x2F) >= (double)*(float *)(a1 + 0x4E72) )
              {
                v70 = v68 / *(float *)(v2 + 0x2F);
              }
              if ( v70 >= (double)flt_904A2 )
              {
                if ( v70 > (double)flt_904AE )
                {
                  v70 = 131072.0;
                }
              }
              else
              {
                v70 = 16384.0;
              }
              v53 = (__int64)(v70 * *(float *)(v2 + 0xB));
              *(_DWORD *)(v2 + 0xF) = v53;
              v22 = *(_DWORD *)(v2 + 0x23);
              v54 = *(float *)(a1 + 0x4F16) * flt_904A6 + *(float *)(a1 + 0x1D22);
              if ( v22 )
              {
                if ( (*(_BYTE *)(v2 + 0x33) & 2) == 0 )
                {
                  v46 = v37;
                  v48 = v39;
                  v47 = v54;
                  sub_53384(&v46, (float *)(a1 + 0x4E86), &v40);
                  v46 = v40;
                  v47 = v41;
                  v48 = v42;
                  sub_533D4(
                    &v40,
                    *(float *)(a1 + 0x4E6E),
                    *(__int16 *)(a1 + 0x4F22),
                    *(__int16 *)(a1 + 0x4F24),
                    (int)v72,
                    (int)&v71);
                  *(_WORD *)(v2 + 0x2B) = v72[0];
                  v23 = (float *)v29;
                  v24 = 0;
                  *(_WORD *)(v2 + 0x2D) = v71;
                  do
                  {
                    v58 = v49;
                    v30 = 0.0;
                    v31 = 0.0;
                    v32 = 0.0;
                    v30 = v46 + *v23;
                    v31 = v47 + v23[1];
                    v25 = v48 + v23[2];
                    *(float *)v49 = v30;
                    v32 = v25;
                    *(float *)&v49[1] = v31;
                    *(float *)&v49[2] = v32;
                    v40 = v30;
                    v41 = v31;
                    v42 = v32;
                    sub_533D4(
                      &v40,
                      *(float *)(a1 + 0x4E6E),
                      *(__int16 *)(a1 + 0x4F22),
                      *(__int16 *)(a1 + 0x4F24),
                      (int)v72,
                      (int)&v71);
                    v28[v24] = v72[0];
                    v24 += 6;
                    v23 += 3;
                    v27[v24] = (__int16)v71;
                  }
                  while ( v24 != 0x18 );
                  v28[0x18] = v57;
                  sub_15D38(v67, v28);
                  if ( *(_BYTE *)v2 == 6 )
                  {
                    *(_WORD *)(a1 + 0xBC) = *(_WORD *)(a1 + 0x4E42) - 1;
                  }
                }
              }
              if ( v38 - v54 > 0.0 )
              {
                v26 = v63;
                *(_DWORD *)(v2 + 0x1F) = 0;
              }
              else
              {
                v26 = v61;
                *(_DWORD *)(v2 + 0x1F) = 0xFFFFFFFF;
              }
              sub_15794(v26, v2);
            }
          }
        }
      }
      v2 += 0x35;
      result = v59 + 1;
      v12 = *(_DWORD *)(a1 + 0x1D32);
      v59 = result;
    }
    while ( result < v12 );
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 9049E: using guessed type float flt_9049E;
// 904A2: using guessed type float flt_904A2;
// 904A6: using guessed type float flt_904A6;
// 904AA: using guessed type float flt_904AA;
// 904AE: using guessed type float flt_904AE;
// 17430: using guessed type __int16 var_1C[14];

//----- (00017E50) --------------------------------------------------------
void __fastcall sub_17E50(int a1, int a2, int a3, int a4)
{
  int v4; // [esp+0h] [ebp-8h]

  *(float *)&v4 = (double)a2 * flt_12FC1C;
  sub_1BAF0((float *)(a1 + 0x4E46), a2, a3, a4, v4);
}
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00017E88) --------------------------------------------------------
float *__fastcall sub_17E88(int a1, int a2)
{
  float *result; // eax
  int v4; // ecx
  double v5; // st7
  float *v6; // ecx
  int v7; // ecx
  double v8; // st7
  int v9; // ecx

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x5BD);
  }
  result = (float *)(a1 + 0x1D1E);
  switch ( *(_BYTE *)a2 )
  {
    case 0:
      *result = 0.0;
      *(_DWORD *)(a1 + 0x1D22) = 0;
      *(_DWORD *)(a1 + 0x1D26) = 0;
      break;
    case 1:
      v6 = *(float **)(a2 + 1);
      *result = *v6;
      *(float *)(a1 + 0x1D22) = v6[1];
      *(float *)(a1 + 0x1D26) = v6[2];
      break;
    case 2:
      v4 = *(_DWORD *)(a2 + 1);
      v5 = *(float *)(v4 + 0x9E);
      v4 += 0x9E;
      *result = v5;
      *(_DWORD *)(a1 + 0x1D22) = *(_DWORD *)(v4 + 4);
      *(_DWORD *)(a1 + 0x1D26) = *(_DWORD *)(v4 + 8);
      break;
    case 3:
      v7 = *(_DWORD *)(a2 + 1);
      if ( dword_D3660 == *(_DWORD *)v7 )
      {
        v8 = *(float *)(v7 + 8);
        v9 = v7 + 8;
      }
      else
      {
        v8 = *(float *)(v7 + 0x14);
        v9 = v7 + 0x14;
      }
      *result = v8;
      *(_DWORD *)(a1 + 0x1D22) = *(_DWORD *)(v9 + 4);
      *(_DWORD *)(a1 + 0x1D26) = *(_DWORD *)(v9 + 8);
      break;
    default:
      return result;
  }
  return result;
}
// D3660: using guessed type int dword_D3660;

//----- (00017F54) --------------------------------------------------------
void __fastcall sub_17F54(int a1)
{
  *(_DWORD *)(a1 + 0x1D1E) = 0;
  *(_DWORD *)(a1 + 0x1D22) = 0;
  *(_DWORD *)(a1 + 0x1D26) = 0;
  *(float *)(a1 + 0x4F16) = *(float *)(a1 + 0x4F1A);
  *(_DWORD *)(a1 + 0x4E7A) = *(_DWORD *)(a1 + 0x4EDE);
  *(_DWORD *)(a1 + 0x4E7E) = *(_DWORD *)(a1 + 0x4EE2);
  *(_DWORD *)(a1 + 0x4E82) = *(_DWORD *)(a1 + 0x4EE6);
  *(float *)(a1 + 0x4E46) = *(float *)(a1 + 0x4EEA);
  *(float *)(a1 + 0x4E4A) = *(float *)(a1 + 0x4EEE);
  *(_DWORD *)(a1 + 0x4E4E) = *(_DWORD *)(a1 + 0x4EF2);
  *(_DWORD *)(a1 + 0x4E52) = *(_DWORD *)(a1 + 0x4EF6);
  *(_DWORD *)(a1 + 0x4E56) = *(_DWORD *)(a1 + 0x4EFA);
  *(_DWORD *)(a1 + 0x4E5A) = *(_DWORD *)(a1 + 0x4EFE);
  *(_DWORD *)(a1 + 0x4E5E) = *(_DWORD *)(a1 + 0x4F02);
  *(_DWORD *)(a1 + 0x4E62) = *(_DWORD *)(a1 + 0x4F06);
  *(_DWORD *)(a1 + 0x4E66) = *(_DWORD *)(a1 + 0x4F0A);
  sub_181F0(a1);
}

//----- (00017FF0) --------------------------------------------------------
void __fastcall sub_17FF0(int a1, int a2, int a3, int a4)
{
  double v5; // st6
  double x; // st6
  double v7; // st7
  int v8; // [esp+0h] [ebp-3Ch]
  int x_4; // [esp+Ch] [ebp-30h]
  float x_4a; // [esp+Ch] [ebp-30h]
  double v11; // [esp+10h] [ebp-2Ch]

  *(_DWORD *)(a1 + 0x1D1E) = 0;
  *(_DWORD *)(a1 + 0x4F26) = 0x23;
  v5 = (double)*(int *)(a1 + 0x4F26) * flt_959F4;
  *(_DWORD *)(a1 + 0x1D22) = 0;
  x = v5 * flt_904C1;
  *(_DWORD *)(a1 + 0x1D26) = 0;
  v11 = *(float *)(a1 + 0x4F1E);
  v7 = v11 / tan(x);
  x_4 = *(__int16 *)(a1 + 0x4F22);
  *(float *)(a1 + 0x4F16) = v7;
  *(float *)(a1 + 0x4F1A) = v7;
  *(float *)&v8 = (float)*(int *)(a1 + 0x4F26);
  sub_1B808((_DWORD *)(a1 + 0x4E46), a1, a1 + 0x4E46, a4, v8, 0x3F800000, 0x47C35000, x_4);
  *(_DWORD *)(a1 + 0x4EE6) = *(_DWORD *)(a1 + 0x4E6E);
  *(_BYTE *)(a1 + 0x4EE9) ^= 0x80u;
  *(float *)(a1 + 0x4EE2) = *(float *)(a1 + 0x4EE6) * flt_904C5;
  x_4a = *(float *)(a1 + 0x4F16);
  *(_DWORD *)(a1 + 0x4EDE) = 0;
  sub_53054((float *)(a1 + 0x4EDE), x_4a);
  *(_DWORD *)(a1 + 0x4E46) = 0x3F800000;
  *(_DWORD *)(a1 + 0x4E4A) = 0;
  *(_DWORD *)(a1 + 0x4E4E) = 0;
  *(_DWORD *)(a1 + 0x4E52) = 0;
  *(_DWORD *)(a1 + 0x4E56) = 0x3F800000;
  *(_DWORD *)(a1 + 0x4E5A) = 0;
  *(_DWORD *)(a1 + 0x4E5E) = 0;
  *(_DWORD *)(a1 + 0x4E62) = 0;
  *(_DWORD *)(a1 + 0x4E66) = 0x3F800000;
  *(float *)(a1 + 0x4EEA) = *(float *)(a1 + 0x4E46);
  *(float *)(a1 + 0x4EEE) = *(float *)(a1 + 0x4E4A);
  *(_DWORD *)(a1 + 0x4EF2) = *(_DWORD *)(a1 + 0x4E4E);
  *(_DWORD *)(a1 + 0x4EF6) = *(_DWORD *)(a1 + 0x4E52);
  *(_DWORD *)(a1 + 0x4EFA) = *(_DWORD *)(a1 + 0x4E56);
  *(_DWORD *)(a1 + 0x4EFE) = *(_DWORD *)(a1 + 0x4E5A);
  *(_DWORD *)(a1 + 0x4F02) = *(_DWORD *)(a1 + 0x4E5E);
  *(float *)(a1 + 0x4F06) = *(float *)(a1 + 0x4E62);
  *(float *)(a1 + 0x4F0A) = *(float *)(a1 + 0x4E66);
  *(float *)(a1 + 0x4F02) = -*(float *)(a1 + 0x4EDE);
  *(float *)(a1 + 0x4F06) = -*(float *)(a1 + 0x4EE2);
  *(float *)(a1 + 0x4F0A) = -*(float *)(a1 + 0x4EE6);
  sub_53864((float *)(a1 + 0x4EEA), a1, a1 + 0x4E46, a1 + 0x4EEA);
  *(_DWORD *)(a1 + 0x4E46) = *(_DWORD *)(a1 + 0x4EEA);
  *(_DWORD *)(a1 + 0x4E4A) = *(_DWORD *)(a1 + 0x4EEE);
  *(_DWORD *)(a1 + 0x4E4E) = *(_DWORD *)(a1 + 0x4EF2);
  *(_DWORD *)(a1 + 0x4E52) = *(_DWORD *)(a1 + 0x4EF6);
  *(_DWORD *)(a1 + 0x4E56) = *(_DWORD *)(a1 + 0x4EFA);
  *(_DWORD *)(a1 + 0x4E5A) = *(_DWORD *)(a1 + 0x4EFE);
  *(_DWORD *)(a1 + 0x4E5E) = *(_DWORD *)(a1 + 0x4F02);
  *(_DWORD *)(a1 + 0x4E62) = *(_DWORD *)(a1 + 0x4F06);
  *(_DWORD *)(a1 + 0x4E66) = *(_DWORD *)(a1 + 0x4F0A);
  *(_DWORD *)(a1 + 0x4E7A) = *(_DWORD *)(a1 + 0x4EDE);
  *(_DWORD *)(a1 + 0x4E7E) = *(_DWORD *)(a1 + 0x4EE2);
  *(_DWORD *)(a1 + 0x4E82) = *(_DWORD *)(a1 + 0x4EE6);
  sub_181F0(a1);
}
// 904C1: using guessed type float flt_904C1;
// 904C5: using guessed type float flt_904C5;
// 959F4: using guessed type float flt_959F4;

//----- (000181F0) --------------------------------------------------------
void __fastcall sub_181F0(int a1)
{
  *(float *)(a1 + 0x4F2A) = tan((double)*(int *)(a1 + 0x4F26) * flt_959F4 * flt_904C9);
  *(float *)(a1 + 0x4F2A) = *(float *)(a1 + 0x4F16) * *(float *)(a1 + 0x4F2A) * flt_904CD;
  *(float *)(a1 + 0x4F12) = *(float *)(a1 + 0x4F1A) * flt_904C9 + *(float *)(a1 + 0x4F16);
  *(float *)(a1 + 0x4F0E) = *(float *)(a1 + 0x4F16) - *(float *)(a1 + 0x4F2A) * flt_904C9;
}
// 904C9: using guessed type float flt_904C9;
// 904CD: using guessed type float flt_904CD;
// 959F4: using guessed type float flt_959F4;

//----- (0001826C) --------------------------------------------------------
int __fastcall sub_1826C(int a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  if ( a3 >= *(int *)(a1 + 0x1A8E) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x62B);
  }
  return sub_156C0(a2, *(unsigned __int16 *)(a1 + 2 * a3 + 0x19C6), a4);
}

//----- (000182B8) --------------------------------------------------------
void __fastcall sub_182B8(int a1, int a2)
{
  double v3; // st7
  double v4; // st7
  int v5; // eax
  float v6; // [esp+4h] [ebp-8h]
  float v7; // [esp+4h] [ebp-8h]
  float v8; // [esp+4h] [ebp-8h]

  v3 = (double)a2;
  v6 = v3;
  if ( v3 <= flt_904E0 )
  {
    if ( v6 < (double)flt_904E4 )
    {
      v6 = -50.0;
    }
  }
  else
  {
    v6 = 50.0;
  }
  v7 = v6 * flt_904E8 * flt_12FC1C;
  v8 = v7 + 1.0;
  v4 = *(float *)(a1 + 0x4F16) * v8;
  *(float *)(a1 + 0x4F16) = v4;
  if ( v4 < *(float *)(a1 + 0x4E6E) )
  {
    v5 = *(_DWORD *)(a1 + 0x4E6E);
LABEL_9:
    *(_DWORD *)(a1 + 0x4F16) = v5;
    goto LABEL_10;
  }
  if ( *(float *)(a1 + 0x4F16) > (double)*(float *)(a1 + 0x4F1A) )
  {
    v5 = *(_DWORD *)(a1 + 0x4F1A);
    goto LABEL_9;
  }
LABEL_10:
  sub_53054((float *)(a1 + 0x4E7A), *(float *)(a1 + 0x4F16));
  sub_181F0(a1);
}
// 904E0: using guessed type float flt_904E0;
// 904E4: using guessed type float flt_904E4;
// 904E8: using guessed type float flt_904E8;
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00018370) --------------------------------------------------------
unsigned int __fastcall sub_18370(int a1)
{
  __int16 v2; // ax
  __int16 v3; // cx
  __int16 v4; // bx
  __int16 v5; // ax
  void *v6; // eax
  void *v7; // eax
  void *v8; // eax
  void *v9; // eax
  char *v10; // ebp
  T_Type1 v12; // [esp+0h] [ebp-15Ch] BYREF
  char s[20]; // [esp+118h] [ebp-44h] BYREF
  _WORD v14[10]; // [esp+12Ch] [ebp-30h] BYREF
  int i; // [esp+140h] [ebp-1Ch]

  v2 = *(_WORD *)(a1 + 0x10) - *(_WORD *)(a1 + 8);
  v3 = *(_WORD *)(a1 + 0xC);
  *(_WORD *)(a1 + 0x4F22) = v2;
  v4 = v2;
  v5 = *(_WORD *)(a1 + 0x14);
  *(_WORD *)(a1 + 0x4F22) = v4 >> 1;
  *(_WORD *)(a1 + 0x4F24) = (__int16)(v5 - v3) >> 1;
  *(_DWORD *)(a1 + 0x1D1E) = 0;
  *(_DWORD *)(a1 + 0x1D22) = 0;
  *(_DWORD *)(a1 + 0x1D26) = 0;
  if ( *(_DWORD *)(a1 + 0x1D2A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x65E);
  }
  if ( *(_DWORD *)(a1 + 0x19BE) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x65F);
  }
  *(_DWORD *)(a1 + 0x1D2E) = 0x80;
  v6 = operator new[](0x35 * *(_DWORD *)(a1 + 0x1D2E));
  v7 = sub_2625C(v6, 1, "BATDISPLAYITEMS");
  *(_DWORD *)(a1 + 0x1D2A) = v7;
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x669);
  }
  *(_DWORD *)(a1 + 0x19C2) = 0x27;
  v8 = operator new[](*(_DWORD *)(a1 + 0x19C2) << 8);
  v9 = sub_2625C(v8, 1, "BATHAZE");
  *(_DWORD *)(a1 + 0x19BE) = v9;
  if ( !v9 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x66F);
  }
  v10 = *(char **)(a1 + 0x19BE);
  Q_InitFileInfo_sub_1BB78(&v12);
  for ( i = 0; i < 0x1F; ++i )
  {
    sprintf(s, "DATA\\BLACK%.2d.HAZ", i);
    if ( Q_CfilePreload_sub_1BBFC(&v12, s, 0x200, 0) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batmode.cpp", 0x67B);
    }
    sub_1BF1C(&v12, v10);
    v10 += 0x100;
  }
  if ( Q_CfilePreload_sub_1BBFC(&v12, "DATA\\SLANE03.HAZ", 0x200, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\batmode.cpp", 0x680);
  }
  sub_1BF1C(&v12, v10);
  i = 0x41;
  strcpy((char *)v14, "DATA\\RACEA03.HAZ");
  HIBYTE(v14[8]) = aDataRacea03Haz[0x11];
  v14[9] = *(_WORD *)&aDataRacea03Haz[0x12];
  do
  {
    HIBYTE(v14[4]) = i;
    v10 += 0x100;
    if ( Q_CfilePreload_sub_1BBFC(&v12, (const char *)v14, 0x200, 0) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x68A);
    }
    sub_1BF1C(&v12, v10);
    ++i;
  }
  while ( i < 0x48 );
  Q_CloseFileAndDelete_sub_1BBC8(&v12);
  return 0xFFFFFFFF;
}

//----- (000185CC) --------------------------------------------------------
int __fastcall sub_185CC(int a1)
{
  int v2; // esi
  int v3; // edx
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // edx
  int result; // eax

  v2 = *(__int16 *)(dword_D3660 + 4);
  if ( v2 >= 0x64 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x697);
  }
  v3 = a1 + 0xBE;
  v4 = 0xC * v2;
  *(_DWORD *)(v3 + v4) = *(_DWORD *)(a1 + 0x4E7A);
  *(_DWORD *)(v3 + v4 + 4) = *(_DWORD *)(a1 + 0x4E7E);
  *(_DWORD *)(v3 + v4 + 8) = *(_DWORD *)(a1 + 0x4E82);
  v5 = 0x24 * v2 + a1 + 0x56E;
  v6 = (_DWORD *)(v5 + 0xC);
  *(float *)v5 = *(float *)(a1 + 0x4E46);
  v5 += 0x18;
  *(float *)(v5 - 0x14) = *(float *)(a1 + 0x4E4A);
  *(_DWORD *)(v5 - 0x10) = *(_DWORD *)(a1 + 0x4E4E);
  *v6 = *(_DWORD *)(a1 + 0x4E52);
  v6[1] = *(_DWORD *)(a1 + 0x4E56);
  v6[2] = *(_DWORD *)(a1 + 0x4E5A);
  *(_DWORD *)v5 = *(_DWORD *)(a1 + 0x4E5E);
  *(_DWORD *)(v5 + 4) = *(_DWORD *)(a1 + 0x4E62);
  v7 = a1 + 0x150E;
  *(float *)(v5 + 8) = *(float *)(a1 + 0x4E66);
  result = a1 + 0x1D1E;
  *(_DWORD *)(v7 + v4) = *(_DWORD *)(a1 + 0x1D1E);
  *(_DWORD *)(v7 + v4 + 4) = *(_DWORD *)(a1 + 0x1D22);
  *(_DWORD *)(v7 + v4 + 8) = *(_DWORD *)(a1 + 0x1D26);
  *(_DWORD *)(a1 + 0x4F2F) = 0;
  *(_BYTE *)(a1 + 0xB7) = 0;
  *(_DWORD *)(a1 + 0xB3) = 0;
  return result;
}
// D3660: using guessed type int dword_D3660;

//----- (000186B8) --------------------------------------------------------
void __fastcall sub_186B8(int a1, int a2, int a3)
{
  int v4; // esi
  int v5; // edx
  int v6; // ebx
  float *v7; // edi
  double v8; // st7

  sub_187EC(a1);
  v4 = *(__int16 *)(dword_D3660 + 4);
  if ( v4 >= 0x64 )
  {
    a3 = 0x6AE;
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x6AE);
  }
  v5 = a1 + 4 * v4;
  if ( *(_DWORD *)(v5 + 0x137E) )
  {
    *(_DWORD *)(a1 + 0x4E7A) = *(_DWORD *)(a1 + 0xBE + 0xC * v4);
    *(_DWORD *)(a1 + 0x4E7E) = *(_DWORD *)(a1 + 0xBE + 0xC * v4 + 4);
    v6 = 0x24 * v4 + a1 + 0x56E;
    *(float *)(a1 + 0x4E82) = *(float *)(a1 + 0xBE + 0xC * v4 + 8);
    v7 = (float *)(v6 + 0xC);
    *(float *)(a1 + 0x4E46) = *(float *)v6;
    v8 = *(float *)(v6 + 4);
    v6 += 0x18;
    *(float *)(a1 + 0x4E4A) = v8;
    *(float *)(a1 + 0x4E4E) = *(float *)(v6 - 0x10);
    *(float *)(a1 + 0x4E52) = *v7;
    *(float *)(a1 + 0x4E56) = v7[1];
    *(float *)(a1 + 0x4E5A) = v7[2];
    *(_DWORD *)(a1 + 0x4E5E) = *(_DWORD *)v6;
    *(_DWORD *)(a1 + 0x4E62) = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(a1 + 0x4E66) = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(a1 + 0x1D1E) = *(_DWORD *)(a1 + 0x150E + 0xC * v4);
    *(_DWORD *)(a1 + 0x1D22) = *(_DWORD *)(a1 + 0x150E + 0xC * v4 + 4);
    *(_DWORD *)(a1 + 0x1D26) = *(_DWORD *)(a1 + 0x150E + 0xC * v4 + 8);
    *(float *)(a1 + 0x4F16) = sqrt(
                                *(float *)(a1 + 0x4E7E) * *(float *)(a1 + 0x4E7E)
                              + *(float *)(a1 + 0x4E7A) * *(float *)(a1 + 0x4E7A)
                              + *(float *)(a1 + 0x4E82) * *(float *)(a1 + 0x4E82));
    sub_181F0(a1);
  }
  else
  {
    sub_17FF0(a1, v5, a3, a1);
    *(_DWORD *)(v5 + 0x137E) = 0xFFFFFFFF;
  }
  sub_18C2C(a1, 0);
}
// D3660: using guessed type int dword_D3660;

//----- (000187EC) --------------------------------------------------------
int __fastcall sub_187EC(int a1)
{
  __int16 i; // si
  int v3; // eax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  unsigned __int16 *v7; // eax
  int v8; // ecx
  int v9; // ebx
  int v10; // eax
  signed __int16 v11; // cx
  float *v12; // eax
  float v13; // eax
  int v14; // ebp
  __int16 *v15; // eax
  int v16; // ebp
  unsigned __int16 v17; // ax
  __int16 v18; // cx
  int v19; // ebp
  int v20; // eax
  __int16 v21; // bx
  int result; // eax
  int v23; // ecx
  double x; // [esp+0h] [ebp-1ECh]
  int v25[107]; // [esp+8h] [ebp-1E4h] BYREF
  float v26; // [esp+1B4h] [ebp-38h]
  float v27; // [esp+1B8h] [ebp-34h]
  float v28; // [esp+1BCh] [ebp-30h]
  float v29; // [esp+1C0h] [ebp-2Ch]
  int v30; // [esp+1C4h] [ebp-28h]
  int v31; // [esp+1C8h] [ebp-24h]
  int v32; // [esp+1CCh] [ebp-20h]
  int v33; // [esp+1D0h] [ebp-1Ch]

  for ( i = 0; i < *(_DWORD *)(a1 + 0x1D2E); ++i )
  {
    v3 = 0x35 * i;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + v3 + 0x33) = 0;
  }
  v4 = *(_DWORD *)(a1 + 0x1D2A);
  *(_DWORD *)(a1 + 0x1D32) = 0;
  *(_BYTE *)v4 = 6;
  *(_DWORD *)(a1 + 0x1D16) = v4;
  *(_WORD *)(v4 + 5) = 0xFFFF;
  v5 = 0;
  v6 = v4 + 0x35;
  ++*(_DWORD *)(a1 + 0x1D32);
  while ( v5 < 1 )
  {
    *(_BYTE *)v6 = 0xFF;
    ++v5;
    v6 += 0x35;
    ++*(_DWORD *)(a1 + 0x1D32);
  }
  *(_BYTE *)v6 = 0;
  v7 = (unsigned __int16 *)dword_D3660;
  *(_DWORD *)(v6 + 1) = dword_D3660;
  sub_1826C(a1, v6, 1u, *v7);
  v8 = *(_DWORD *)(a1 + 0x1D32) + 1;
  LOWORD(v32) = 0;
  *(_DWORD *)(a1 + 0x1D32) = v8;
  while ( (__int16)v32 < *(__int16 *)(dword_D3660 + 0x5A) )
  {
    if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x6FC);
    }
    v6 += 0x35;
    v10 = *(_DWORD *)(dword_D3660 + 4 * (__int16)v32 + 0x46);
    *(_BYTE *)v6 = 1;
    *(_DWORD *)(v6 + 1) = v10;
    v11 = *(_WORD *)(v10 + 0x14) + 5 * *(_WORD *)(v10 + 0x16);
    if ( v11 >= 0x37 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x706);
    }
    sub_1826C(a1, v6, 0, v11);
    v9 = *(_DWORD *)(a1 + 0x1D32) + 1;
    LOWORD(v32) = v32 + 1;
    *(_DWORD *)(a1 + 0x1D32) = v9;
  }
  v12 = *(float **)(v6 + 1);
  x = v12[1] * v12[1] + *v12 * *v12 + v12[2] * v12[2];
  LOWORD(v33) = 0;
  *(float *)(a1 + 0x4F1E) = sqrt(x);
  while ( 1 )
  {
    v15 = (__int16 *)dword_D3660;
    if ( (__int16)v33 >= *(__int16 *)(dword_D3660 + 0x44) )
    {
      break;
    }
    if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x716);
    }
    v6 += 0x35;
    v16 = *(_DWORD *)(dword_D3660 + 4 * (__int16)v33 + 0x2C);
    *(_BYTE *)v6 = 3;
    *(_DWORD *)(v6 + 1) = v16;
    v17 = (*(_BYTE *)(v16 + 0x23) & 1) != 0;
    if ( (*(_BYTE *)(v16 + 0x23) & 2) != 0 )
    {
      v17 += 2;
    }
    sub_1826C(a1, v6, 2u, v17);
    v26 = 0.0;
    v27 = 0.0;
    v28 = 0.0;
    if ( dword_D3660 == *(_DWORD *)v16 )
    {
      *(_BYTE *)(v6 + 0x33) |= 1u;
      v26 = *(float *)(v16 + 8);
      v27 = *(float *)(v16 + 0xC);
      v13 = *(float *)(v16 + 0x10);
    }
    else
    {
      *(_BYTE *)(v6 + 0x33) &= ~1u;
      v26 = *(float *)(v16 + 0x14);
      v27 = *(float *)(v16 + 0x18);
      v13 = *(float *)(v16 + 0x1C);
    }
    v28 = v13;
    v29 = sqrt(v27 * v27 + v26 * v26 + v13 * v13);
    if ( *(float *)(a1 + 0x4F1E) < (double)v29 )
    {
      *(float *)(a1 + 0x4F1E) = v29;
    }
    v14 = *(_DWORD *)(a1 + 0x1D32) + 1;
    LOWORD(v33) = v33 + 1;
    *(_DWORD *)(a1 + 0x1D32) = v14;
  }
  v18 = 0;
  *(float *)(a1 + 0x4F1E) = *(float *)(a1 + 0x4F1E) + flt_905FA;
  v30 = sub_1D794(v15, v25);
  while ( v18 < v30 )
  {
    v19 = v25[v18];
    if ( *(_BYTE *)(v19 + 0x58) == 4 )
    {
      if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x750);
      }
      v6 += 0x35;
      *(_DWORD *)(v6 + 1) = v19;
      *(_BYTE *)v6 = 2;
      sub_156C0(v6, (unsigned __int16)word_FFEBC[*(__int16 *)(v19 + 0x56)], *(char *)(v19 + 0xAA));
      ++*(_DWORD *)(a1 + 0x1D32);
    }
    ++v18;
  }
  LOWORD(v31) = 0;
  if ( word_D365E > 0 )
  {
    do
    {
      if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x761);
      }
      v20 = 0xD * (__int16)v31;
      v6 += 0x35;
      *(_BYTE *)v6 = 4;
      *(_DWORD *)(v6 + 1) = &byte_D35E9[v20];
      sub_1826C(a1, v6, 3u, byte_D35E9[v20]);
      v21 = v31;
      ++*(_DWORD *)(a1 + 0x1D32);
      LOWORD(v31) = v21 + 1;
    }
    while ( (__int16)(v21 + 1) < word_D365E );
  }
  for ( result = 0; (__int16)result < *(_DWORD *)(a1 + 0x1D32); ++result )
  {
    v23 = 0x35 * (__int16)result;
    *(_BYTE *)(v23 + *(_DWORD *)(a1 + 0x1D2A) + 0x33) &= ~4u;
  }
  return result;
}
// 905FA: using guessed type float flt_905FA;
// D365E: using guessed type __int16 word_D365E;
// D3660: using guessed type int dword_D3660;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// 187EC: using guessed type int var_1E4[107];

//----- (00018C2C) --------------------------------------------------------
void __fastcall sub_18C2C(int a1, int a2)
{
  size_t *v4; // ecx
  int v5; // edx

  v4 = (size_t *)(a1 + 0x1D36);
  v5 = a1 + 0x253A;
  sub_15788(a1 + 0x1D36);
  sub_15788(a1 + 0x253A);
  sub_15788(a1 + 0x2D3E);
  sub_15D2C(a1 + 0x3542);
  sub_173F4(a1, v5, a1, (int)v4);
  sub_157EC(v4);
  sub_157EC((size_t *)(a1 + 0x253A));
  if ( !a2 )
  {
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
  }
}

//----- (00018CA8) --------------------------------------------------------
void __fastcall sub_18CA8(int a1, int a2)
{
  char v3; // ah
  int v4; // eax
  char *v5; // eax
  int v6; // ebx
  int v7; // edx
  int v8; // edx
  __int16 v9; // bx
  const char *v10; // esi
  char *v11; // edi
  int v12; // edx
  char v13; // al
  char v14; // al
  int v15; // edx
  char *v16; // ecx
  int v17; // ebx
  char *v18; // eax
  int v19; // eax
  char *v20; // eax
  char *v21; // esi
  int v22; // edx
  char *v23; // edi
  char v24; // al
  char v25; // al
  __int16 v26; // dx
  int v27; // ebx
  char *v28; // esi
  char *v29; // eax
  char *v30; // edi
  char v31; // al
  char v32; // al
  char *v33; // edi
  char *v34; // esi
  char v35; // al
  char v36; // al
  char *v37; // edi
  char *v38; // esi
  char v39; // al
  char v40; // al
  int v41; // eax
  int v42; // ebx
  char *v43; // esi
  char *v44; // edi
  char v45; // al
  char v46; // al
  char *v47; // esi
  char *v48; // edi
  char v49; // al
  char v50; // al
  char *v51; // edi
  char *sub_1CEA8; // esi
  char v53; // al
  char v54; // al
  int v55; // eax
  char v56; // dl
  const char *v57; // ecx
  __int16 v58; // [esp-Ch] [ebp-198h]
  int v59; // [esp-4h] [ebp-190h]
  char *v60; // [esp-4h] [ebp-190h]
  _DWORD v61[50]; // [esp+0h] [ebp-18Ch] BYREF
  char v62[80]; // [esp+C8h] [ebp-C4h] BYREF
  char s[60]; // [esp+118h] [ebp-74h] BYREF
  char v64[32]; // [esp+154h] [ebp-38h] BYREF
  int v65; // [esp+174h] [ebp-18h]

  if ( !a2 )
  {
    unk_9A23C = *(_DWORD *)(a1 + 4);
    *((_DWORD *)&unk_9A23C + 1) = *(_DWORD *)(a1 + 8);
    *((_DWORD *)&unk_9A23C + 2) = *(_DWORD *)(a1 + 0xC);
    *((_DWORD *)&unk_9A23C + 3) = *(_DWORD *)(a1 + 0x10);
    *((_DWORD *)&unk_9A23C + 4) = *(_DWORD *)(a1 + 0x14);
  }
  sub_5E9D0((P_Type5)(a1 + 4), *(_BYTE *)(a1 + 0x4F2E));
  sub_15948(a1 + 0x2D3E, a1);
  sub_19AE8(a1);
  sub_15948(a1 + 0x253A, a1);
  if ( *(_DWORD *)(a1 + 0x5046) )
  {
    sub_15D74(a1 + 0x3542, a1);
  }
  if ( !*(_DWORD *)(a1 + 0xAF) )
  {
    v3 = *(_BYTE *)(a1 + 0xB7);
    if ( v3 == 2 || v3 == 3 )
    {
      sub_15DA4(a1 + 0x3542, a1, *(_WORD *)(a1 + 0xBC));
    }
  }
  if ( *(_DWORD *)(a1 + 0x503A) && (*(_BYTE *)(a1 + 0x4F2F) & 1) == 0 )
  {
    sub_1936C(a1);
  }
  if ( *(_DWORD *)(a1 + 0x5046) )
  {
    sub_15E1C((int *)(a1 + 0x3542), a1);
  }
  sub_15948(a1 + 0x1D36, a1);
  sub_53E38((P_Type5)(a1 + 4), 3, 3, (unsigned __int8)byte_104BEA);
  if ( !*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x7AC);
  }
  v4 = *(_DWORD *)(a1 + 0xAF);
  v65 = 0;
  if ( v4 )
  {
    v51 = s;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(2); // 2: "Unknown"
    do
    {
      v53 = *sub_1CEA8;
      *v51 = *sub_1CEA8;
      if ( !v53 )
      {
        break;
      }
      v54 = sub_1CEA8[1];
      sub_1CEA8 += 2;
      v51[1] = v54;
      v51 += 2;
    }
    while ( v54 );
    v55 = *(_DWORD *)(a1 + 0xAF);
    v26 = 0xF3;
    switch ( *(_BYTE *)v55 )
    {
      case 0:
        v59 = *(_DWORD *)(v55 + 1) + 0x1C;
        v5 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(3);    // 3: "Sun %s"
        sprintf(s, v5, v59);
        break;
      case 1:
        v17 = *(_DWORD *)(v55 + 1);
        v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(4);   // 4: "Planet %s"
        sprintf(s, v18, v17 + 0x24);
        v19 = *(unsigned __int8 *)(v17 + 0x57);
        if ( v19 != 0xFF )
        {
          v60 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v19)];
          v20 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(5); // 5: "\nOwned by %s"
          v21 = v64;
          sprintf(v64, v20, v60);
          v22 = 0;
          v23 = &s[strlen(s)];
          do
          {
            v24 = *v21;
            *v23 = *v21;
            if ( !v24 )
            {
              break;
            }
            v25 = v21[1];
            v21 += 2;
            v23[1] = v25;
            v23 += 2;
          }
          while ( v25 );
          LOBYTE(v22) = *(_BYTE *)(v17 + 0x57);
          v26 = 4 * (unsigned __int8)byte_A2F74[0x1EE * v22] + 0x13;
        }
        break;
      case 2:
        v65 = *(_DWORD *)(v55 + 1);
        v27 = v65;
        sprintf(
          s,
          "%s %s",
          &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(__int16 *)(v65 + 0x56))],
          (const char *)(v65 + 0x34));
        if ( *(_WORD *)(v27 + 0x56) == (unsigned __int8)byte_104BEA && *(_BYTE *)(v27 + 0x5D) )
        {
          v28 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(6); // 6: "\nMoving to Star Lane"
          v29 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(7); // 7: "\nMoving to Planet"
          if ( *(_BYTE *)(v27 + 0x5D) != 1 )
          {
            v28 = v29;
          }
          v30 = &s[strlen(s)];
          do
          {
            v31 = *v28;
            *v30 = *v28;
            if ( !v31 )
            {
              break;
            }
            v32 = v28[1];
            v28 += 2;
            v30[1] = v32;
            v30 += 2;
          }
          while ( v32 );
        }
        v26 = 4 * (unsigned __int8)byte_A2F74[0x1EE * *(__int16 *)(v27 + 0x56)] + 0x13;
        break;
      case 3:
        v33 = s;
        v34 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(8);   // 8: "Star Lane"
        do
        {
          v35 = *v34;
          *v33 = *v34;
          if ( !v35 )
          {
            break;
          }
          v36 = v34[1];
          v34 += 2;
          v33[1] = v36;
          v33 += 2;
        }
        while ( v36 );
        if ( (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1) + 0x23) & 1) != 0 )
        {
          v37 = s;
          v38 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(9); // 9: "Red Link"
          do
          {
            v39 = *v38;
            *v37 = *v38;
            if ( !v39 )
            {
              break;
            }
            v40 = v38[1];
            v38 += 2;
            v37[1] = v40;
            v37 += 2;
          }
          while ( v40 );
        }
        v41 = *(_DWORD *)(a1 + 0xAF);
        if ( (*(_BYTE *)(v41 + 0x33) & 1) != 0 )
        {
          v42 = *(_DWORD *)(*(_DWORD *)(v41 + 1) + 4);
        }
        else
        {
          v42 = **(_DWORD **)(v41 + 1);
        }
        if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(v42 + 0x17)) != 0 )
        {
          v43 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xA);// 10: " to "
          v44 = &s[strlen(s)];
          do
          {
            v45 = *v43;
            *v44 = *v43;
            if ( !v45 )
            {
              break;
            }
            v46 = v43[1];
            v43 += 2;
            v44[1] = v46;
            v44 += 2;
          }
          while ( v46 );
          v47 = (char *)(v42 + 0x1C);
          v48 = &s[strlen(s)];
          do
          {
            v49 = *v47;
            *v48 = *v47;
            if ( !v49 )
            {
              break;
            }
            v50 = v47[1];
            v47 += 2;
            v48[1] = v50;
            v48 += 2;
          }
          while ( v50 );
        }
        break;
      default:
        break;
    }
    v58 = v26;
    v6 = *(_DWORD *)(a1 + 0x14) - 0x1E;
    v7 = *(_DWORD *)(a1 + 0x10) - 0xC8;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v7, v6, s, 0, v58, 0xFF, 0);
  }
  v8 = v65;
  sub_17260(a1);
  if ( v8 )
  {
    v9 = dword_A0CFC;
    if ( dword_A0CFC == 0xFFFFFFFF )
    {
      sprintf(
        v62,
        "%s %s",
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(__int16 *)(v8 + 0x56))],
        (const char *)(v8 + 0x34));
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xFA, 0xA, v62, 0, v9, v9, 0);
      sprintf(
        v62,
        "POWER %d MOVES %d INTEGRITY %d",
        *(_DWORD *)(v65 + 0x88),
        *(_DWORD *)(v65 + 0x94),
        *(_DWORD *)(v65 + 0x8C));
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xFA, 0x14, v62, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      qmemcpy(v61, "SONothing", sizeof(v61));
      v10 = "INVALID ORDER";
      v11 = v62;
      v12 = v65;
      do
      {
        v13 = *v10;
        *v11 = *v10;
        if ( !v13 )
        {
          break;
        }
        v14 = v10[1];
        v10 += 2;
        v11[1] = v14;
        v11 += 2;
      }
      while ( v14 );
      v15 = *(char *)(v12 + 0x5D);
      if ( v15 >= 0 && *(char *)(v65 + 0x5D) <= 7 )
      {
        v16 = (char *)&v61[5 * v15];
      }
      else
      {
        v16 = v62;
      }
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xFA, 0x1E, v16, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v56 = *(_BYTE *)(v65 + 0x5D);
      if ( v56 == 1 )
      {
        v57 = (const char *)(*(_DWORD *)(v65 + 0x5E) + 0x1C);
LABEL_68:
        *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x140, 0x1E, v57, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
        goto LABEL_69;
      }
      if ( v56 == 2 )
      {
        v57 = (const char *)(*(_DWORD *)(v65 + 0x5E) + 0x24);
        goto LABEL_68;
      }
    }
  }
LABEL_69:
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&unk_9A23C);
}
// 96BAC: using guessed type int dword_96BAC;
// A0CFC: using guessed type int dword_A0CFC;
// 18CA8: using guessed type char s[60];

//----- (0001936C) --------------------------------------------------------
void __fastcall sub_1936C(int a1)
{
  double v2; // st7
  int v3; // eax
  int v4; // edx
  double v5; // st7
  int v6; // ebp
  float *v7; // edi
  double v8; // st7
  double v9; // st7
  float *v10; // edx
  int v11; // ecx
  void (__fastcall *v12)(_DWORD, _DWORD, _DWORD, _DWORD); // ebx
  int v13; // ebp
  float *v14; // edi
  double v15; // st7
  double v16; // st7
  float *v17; // edx
  int v18; // ecx
  void (__fastcall *v19)(_DWORD, _DWORD, _DWORD, _DWORD); // ebx
  int v20[3]; // [esp+8h] [ebp-110h] BYREF
  float v21; // [esp+14h] [ebp-104h]
  float v22; // [esp+18h] [ebp-100h]
  float v23; // [esp+1Ch] [ebp-FCh]
  float v24; // [esp+20h] [ebp-F8h]
  float v25; // [esp+24h] [ebp-F4h]
  float v26; // [esp+28h] [ebp-F0h]
  float v27; // [esp+2Ch] [ebp-ECh]
  float v28; // [esp+30h] [ebp-E8h]
  float v29; // [esp+34h] [ebp-E4h]
  float v30[3]; // [esp+38h] [ebp-E0h] BYREF
  float v31; // [esp+44h] [ebp-D4h] BYREF
  float v32; // [esp+48h] [ebp-D0h]
  float v33; // [esp+4Ch] [ebp-CCh]
  float v34; // [esp+50h] [ebp-C8h] BYREF
  float v35; // [esp+54h] [ebp-C4h]
  float v36; // [esp+58h] [ebp-C0h]
  int v37[3]; // [esp+5Ch] [ebp-BCh] BYREF
  float v38; // [esp+68h] [ebp-B0h]
  float v39; // [esp+6Ch] [ebp-ACh]
  float v40; // [esp+70h] [ebp-A8h]
  int v41[3]; // [esp+74h] [ebp-A4h] BYREF
  int v42[3]; // [esp+80h] [ebp-98h] BYREF
  float v43; // [esp+8Ch] [ebp-8Ch]
  int *v44; // [esp+90h] [ebp-88h]
  int *v45; // [esp+94h] [ebp-84h]
  int v46; // [esp+98h] [ebp-80h]
  float v47; // [esp+9Ch] [ebp-7Ch]
  int *v48; // [esp+A0h] [ebp-78h]
  int *v49; // [esp+A4h] [ebp-74h]
  int v50; // [esp+A8h] [ebp-70h]
  int **v51; // [esp+ACh] [ebp-6Ch]
  int **v52; // [esp+B0h] [ebp-68h]
  int v53; // [esp+B4h] [ebp-64h]
  float *v54; // [esp+B8h] [ebp-60h]
  float *v55; // [esp+BCh] [ebp-5Ch]
  int v56; // [esp+C0h] [ebp-58h]
  int v57; // [esp+C4h] [ebp-54h]
  float v58; // [esp+C8h] [ebp-50h]
  int v59; // [esp+CCh] [ebp-4Ch]
  int v60; // [esp+D0h] [ebp-48h]
  int v61; // [esp+D4h] [ebp-44h]
  int v62; // [esp+D8h] [ebp-40h]
  float v63; // [esp+DCh] [ebp-3Ch]
  float v64; // [esp+E0h] [ebp-38h]
  float v65; // [esp+E4h] [ebp-34h]
  float v66; // [esp+E8h] [ebp-30h]
  float v67; // [esp+ECh] [ebp-2Ch]
  int v68; // [esp+F0h] [ebp-28h] BYREF
  int v69; // [esp+F4h] [ebp-24h] BYREF
  int v70; // [esp+F8h] [ebp-20h] BYREF
  __int16 v71[14]; // [esp+FCh] [ebp-1Ch] BYREF

  v31 = 0.0;
  v32 = 0.0;
  v33 = 0.0;
  v34 = 0.0;
  v35 = 0.0;
  v36 = 0.0;
  memset(v30, 0, sizeof(v30));
  v2 = *(float *)(a1 + 0x4F2A) * flt_90646;
  v58 = v2;
  v58 = v2 * v58;
  v46 = (int)(*(float *)(a1 + 0x4F2A) * flt_9064A);
  v59 = v46 + 2;
  v3 = 0x20 * ((v46 + 2) / 2);
  v46 = (int)(*(float *)(a1 + 0x4F2A) * flt_9064E);
  v50 = v3 + 0x10;
  v4 = (v46 + 2) / 2;
  v53 = 0x68;
  v56 = 0x61;
  v60 = 0xA0 * v4 + 0x10;
  if ( v60 > v3 + 0x10 )
  {
    v60 = 0xA0 * v4 - 0x90;
  }
  v5 = *(float *)(a1 + 0x4F2A);
  v61 = 0xFFFFFFFF;
  v57 = 0;
  if ( v5 < flt_90652 )
  {
    v57 = 0xFFFFFFFF;
  }
  v6 = 0;
  v65 = *(float *)(a1 + 0x4F16) * flt_90656;
  v67 = (float)v50;
  if ( v59 > 0 )
  {
    v7 = (float *)(a1 + 0x1D1E);
    v52 = (int **)(a1 + 4);
    v54 = (float *)(a1 + 0x4E86);
    do
    {
      if ( (double)v60 == v67 )
      {
        v61 = v6;
      }
      v63 = v58 - v67 * v67;
      if ( v63 > 0.0 )
      {
        v63 = sqrt(v63);
        v31 = v67;
        v32 = v65;
        v38 = 0.0;
        v33 = v63;
        v34 = v67;
        v43 = -v63;
        v35 = v65;
        v39 = 0.0;
        v36 = v43;
        v40 = 0.0;
        v45 = v37;
        v38 = v67 + *v7;
        v39 = v65 + *(float *)(a1 + 0x1D22);
        v8 = v63 + *(float *)(a1 + 0x1D26);
        *(float *)v37 = v38;
        v40 = v8;
        *(float *)&v37[1] = v39;
        *(float *)&v37[2] = v40;
        v31 = v38;
        v27 = 0.0;
        v32 = v39;
        v28 = 0.0;
        v33 = v40;
        v29 = 0.0;
        v44 = v41;
        v27 = v67 + *v7;
        v28 = v65 + *(float *)(a1 + 0x1D22);
        v9 = v43 + *(float *)(a1 + 0x1D26);
        *(float *)v41 = v27;
        v29 = v9;
        *(float *)&v41[1] = v28;
        *(float *)&v41[2] = v29;
        v34 = v27;
        v35 = v28;
        v36 = v29;
        sub_53384(&v31, v54, v30);
        v10 = v54;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)&v69,
          (int)&v70);
        sub_53384(&v34, v10, v30);
        v11 = v61;
        v12 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xFFFFFFFF;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)v71,
          (int)&v68);
        if ( v11 < 0 || (v6 - v11) % 5 )
        {
          if ( v57 )
          {
            v12 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v53;
          }
        }
        else
        {
          v12 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v56;
        }
        if ( v12 != (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xFFFFFFFF )
        {
          sub_5C001(v52, (__int16)v69, (__int16)v70, v71[0], (__int16)v68, 0, v12);
        }
      }
      ++v6;
      v67 = v67 + flt_9065A;
    }
    while ( v6 < v59 );
  }
  v66 = (float)v50;
  v13 = 0;
  v62 = 0xFFFFFFFF;
  if ( v59 > 0 )
  {
    v14 = (float *)(a1 + 0x1D1E);
    v51 = (int **)(a1 + 4);
    v55 = (float *)(a1 + 0x4E86);
    do
    {
      if ( (double)v60 == v66 )
      {
        v62 = v13;
      }
      v64 = v58 - v66 * v66;
      if ( v64 > 0.0 )
      {
        v64 = sqrt(v64);
        v31 = v64;
        v32 = v65;
        v47 = -v64;
        v33 = v66;
        v34 = v47;
        v35 = v65;
        v36 = v66;
        v48 = v42;
        v24 = 0.0;
        v25 = 0.0;
        v26 = 0.0;
        v24 = v64 + *v14;
        v25 = v65 + *(float *)(a1 + 0x1D22);
        v15 = v66 + *(float *)(a1 + 0x1D26);
        *(float *)v42 = v24;
        v26 = v15;
        *(float *)&v42[1] = v25;
        *(float *)&v42[2] = v26;
        v31 = v24;
        v21 = 0.0;
        v32 = v25;
        v22 = 0.0;
        v33 = v26;
        v23 = 0.0;
        v49 = v20;
        v21 = v47 + *v14;
        v22 = v65 + *(float *)(a1 + 0x1D22);
        v16 = v66 + *(float *)(a1 + 0x1D26);
        *(float *)v20 = v21;
        v23 = v16;
        *(float *)&v20[1] = v22;
        *(float *)&v20[2] = v23;
        v34 = v21;
        v35 = v22;
        v36 = v23;
        sub_53384(&v31, v55, v30);
        v17 = v55;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)&v69,
          (int)&v70);
        sub_53384(&v34, v17, v30);
        v18 = v62;
        v19 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xFFFFFFFF;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)v71,
          (int)&v68);
        if ( v18 < 0 || (v13 - v18) % 5 )
        {
          if ( v57 )
          {
            v19 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v53;
          }
        }
        else
        {
          v19 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v56;
        }
        if ( v19 != (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xFFFFFFFF )
        {
          sub_5C001(v51, (__int16)v69, (__int16)v70, v71[0], (__int16)v68, 0, v19);
        }
      }
      ++v13;
      v66 = v66 + flt_9065A;
    }
    while ( v13 < v59 );
  }
}
// 90646: using guessed type float flt_90646;
// 9064A: using guessed type float flt_9064A;
// 9064E: using guessed type float flt_9064E;
// 90652: using guessed type float flt_90652;
// 90656: using guessed type float flt_90656;
// 9065A: using guessed type float flt_9065A;
// 1936C: using guessed type __int16 var_1C[14];

//----- (00019AE8) --------------------------------------------------------
int __fastcall sub_19AE8(int a1)
{
  int v1; // ebp
  int v2; // edi
  int *v3; // esi
  __int16 v4; // ax
  int result; // eax
  double v6; // st7
  __int16 v7; // bx
  int v8[100]; // [esp+8h] [ebp-384h]
  char v9[200]; // [esp+198h] [ebp-1F4h] BYREF
  char v10[200]; // [esp+260h] [ebp-12Ch] BYREF
  float v11; // [esp+328h] [ebp-64h]
  float v12; // [esp+32Ch] [ebp-60h]
  float v13; // [esp+330h] [ebp-5Ch]
  int v14[3]; // [esp+334h] [ebp-58h] BYREF
  float v15; // [esp+340h] [ebp-4Ch] BYREF
  float v16; // [esp+344h] [ebp-48h]
  float v17; // [esp+348h] [ebp-44h]
  int *v18; // [esp+34Ch] [ebp-40h]
  float *v19; // [esp+350h] [ebp-3Ch]
  P_Type5 v20; // [esp+354h] [ebp-38h]
  int v21; // [esp+358h] [ebp-34h]
  int v22; // [esp+35Ch] [ebp-30h]
  int v23; // [esp+360h] [ebp-2Ch]
  int v24; // [esp+364h] [ebp-28h]
  int v25; // [esp+368h] [ebp-24h]
  int v26; // [esp+36Ch] [ebp-20h]
  __int16 v27; // [esp+370h] [ebp-1Ch]

  v24 = a1;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v21 = *(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC);
  if ( !v21 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x8E7);
  }
  v20 = (P_Type5)(v24 + 4);
  v1 = 0;
  v2 = 0;
  v19 = (float *)(v24 + 0x4E46);
  v3 = (int *)&word_A3D21[4];
  v23 = (int)v10;
  v25 = 0;
  v22 = (int)v9;
  while ( 1 )
  {
    result = word_A62A1;
    if ( v1 >= word_A62A1 )
    {
      break;
    }
    v15 = *(float *)v3;
    v16 = *((float *)v3 + 1);
    v17 = *((float *)v3 + 2);
    v18 = v14;
    v11 = 0.0;
    v12 = 0.0;
    v13 = 0.0;
    v11 = v15 - *(float *)(dword_D3660 + 8);
    v12 = v16 - *(float *)(dword_D3660 + 0xC);
    v6 = v17 - *(float *)(dword_D3660 + 0x10);
    *(float *)v14 = v11;
    v13 = v6;
    *(float *)&v14[1] = v12;
    *(float *)&v14[2] = v13;
    v15 = v11;
    v16 = v12;
    v17 = v13;
    v8[v2] = 0;
    if ( !sub_53078(&v15) )
    {
      sub_53114(&v15, v19);
      *(float *)&v8[v2] = v17;
      if ( *(float *)&v8[v2] > 0.0 )
      {
        sub_533D4(&v15, *(float *)(v24 + 0x4E6E), *(__int16 *)(v24 + 0x4F22), *(__int16 *)(v24 + 0x4F24), v23, v22);
        v7 = word_A3D21[0x30 * v1];
        v26 = (int)(sqrt(v16 * v16 + v15 * v15 + v17 * v17) + flt_9066D);
        v27 = v26;
        v4 = 3;
        if ( (__int16)v26 <= 0xDC )
        {
          if ( v27 <= 0 )
          {
            if ( v27 > (int)0xFFFFFF24 )
            {
              v4 = 2;
            }
          }
          else
          {
            v4 = 1;
          }
        }
        else
        {
          v4 = 0;
        }
        sub_5CB3C(v20, *(_DWORD *)(v21 + 0xAB), v4 + 4 * v7, *(__int16 *)&v10[v25], *(__int16 *)&v9[v25]);
      }
    }
    ++v2;
    v3 += 0x18;
    ++v1;
    v23 += 2;
    v22 += 2;
    v25 += 2;
  }
  return result;
}
// 9066D: using guessed type float flt_9066D;
// 96BAC: using guessed type int dword_96BAC;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// D3660: using guessed type int dword_D3660;

//----- (00019E2C) --------------------------------------------------------
__int64 __fastcall sub_19E2C(int a1, unsigned int a2, int a3)
{
  char *v4; // edi
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  int *v11; // edx
  _DWORD *v12; // edx
  _DWORD *v13; // edx
  _DWORD *v14; // edx
  _DWORD *v15; // edx
  _DWORD *v16; // edx
  _DWORD *v17; // edx
  _DWORD *v18; // edx
  _DWORD *v19; // edx
  _DWORD *v20; // edx
  _DWORD *v21; // edx
  _DWORD *v22; // edx
  _DWORD *v23; // edx
  _DWORD *v24; // edx
  int v26; // eax
  int v27; // eax
  _DWORD *v28; // eax
  _DWORD *v29; // eax
  _DWORD *v30; // esi
  _DWORD *v31; // eax
  _BYTE v32[1200]; // [esp+0h] [ebp-3460h] BYREF
  char v33[3600]; // [esp+4B0h] [ebp-2FB0h] BYREF
  char v34[400]; // [esp+12C0h] [ebp-21A0h] BYREF
  char v35[1200]; // [esp+1450h] [ebp-2010h] BYREF
  int v36; // [esp+1900h] [ebp-1B60h]
  int v37; // [esp+1904h] [ebp-1B5Ch]
  int v38; // [esp+1908h] [ebp-1B58h]
  int v39[55]; // [esp+190Ch] [ebp-1B54h] BYREF
  __int16 v40; // [esp+19E8h] [ebp-1A78h]
  __int16 v41; // [esp+19EAh] [ebp-1A76h]
  int v42; // [esp+19ECh] [ebp-1A74h]
  int v43; // [esp+19F0h] [ebp-1A70h]
  int v44; // [esp+19F4h] [ebp-1A6Ch]
  int v45; // [esp+19F8h] [ebp-1A68h]
  int v46; // [esp+19FCh] [ebp-1A64h]
  int v47; // [esp+1A00h] [ebp-1A60h]
  int v48; // [esp+1A04h] [ebp-1A5Ch]
  char v49[1200]; // [esp+1A08h] [ebp-1A58h] BYREF
  char v50[3600]; // [esp+1EB8h] [ebp-15A8h] BYREF
  char v51[400]; // [esp+2CC8h] [ebp-798h] BYREF
  char v52[1200]; // [esp+2E58h] [ebp-608h] BYREF
  int v53; // [esp+3308h] [ebp-158h]
  int v54; // [esp+330Ch] [ebp-154h]
  int v55; // [esp+3310h] [ebp-150h]
  int v56[63]; // [esp+3314h] [ebp-14Ch] BYREF
  unsigned int count; // [esp+3410h] [ebp-50h]
  char *v58; // [esp+3414h] [ebp-4Ch]
  char *v59; // [esp+3418h] [ebp-48h]
  char *v60; // [esp+341Ch] [ebp-44h]
  _DWORD *v61; // [esp+3420h] [ebp-40h]
  _DWORD *v62; // [esp+3424h] [ebp-3Ch]
  _DWORD *v63; // [esp+3428h] [ebp-38h]
  _DWORD *v64; // [esp+342Ch] [ebp-34h]
  _DWORD *v65; // [esp+3430h] [ebp-30h]
  _DWORD *v66; // [esp+3434h] [ebp-2Ch]
  _DWORD *v67; // [esp+3438h] [ebp-28h]
  _DWORD *v68; // [esp+343Ch] [ebp-24h]
  _DWORD *v69; // [esp+3440h] [ebp-20h]
  _DWORD *v70; // [esp+3444h] [ebp-1Ch]
  int *v71; // [esp+3448h] [ebp-18h]
  _DWORD *v72; // [esp+344Ch] [ebp-14h]

  count = a2;
  v68 = (_DWORD *)(a1 + 0x4EEA);
  v69 = (_DWORD *)(a1 + 0x4EDE);
  v72 = (_DWORD *)(a1 + 0x4E46);
  v71 = (int *)(a1 + 0x1D1E);
  v60 = (char *)(a1 + 0x150E);
  v59 = (char *)(a1 + 0x137E);
  v4 = (char *)(a1 + 0xBE);
  v58 = (char *)(a1 + 0x56E);
  v64 = (_DWORD *)(a1 + 0x4F02);
  v63 = (_DWORD *)(a1 + 0x4EF6);
  v70 = (_DWORD *)(a1 + 0x4EBA);
  v65 = (_DWORD *)(a1 + 0x4E7A);
  v66 = (_DWORD *)(a1 + 0x4E5E);
  v67 = (_DWORD *)(a1 + 0x4E52);
  v62 = (_DWORD *)(a1 + 0x4ED2);
  v61 = (_DWORD *)(a1 + 0x4EC6);
  if ( a3 == 0xFFFFFFFF )
  {
    v5 = _wcpp_2_ctor_array_(v49, 0x64, &unk_959D8);
    v6 = _wcpp_2_ctor_array_(v5 + 0x4B0, 0x64, &unk_95A3C);
    v7 = (_DWORD *)(_wcpp_2_ctor_array_(v6 + 0xFA0, 0x64, &unk_959D8) + 0x4B0);
    *v7 = 0;
    v7 += 3;
    v7[0xFFFFFFFE] = 0;
    v7[0xFFFFFFFF] = 0;
    v8 = sub_1B4F0(v7) + 0x26;
    v8[1] = 0;
    v8[2] = 0;
    *v8 = 0;
    v8 += 3;
    v9 = v8 + 3;
    sub_1ACA0(v8);
    sub_1ACA0(v9);
    v10 = v9 + 3;
    v9 += 0xFFFFFFFD;
    sub_1ACA0(v10);
    sub_1AC70((float *)v9, 1, 0, 0);
    sub_1AC70((float *)v9 + 3, 0, 1, 0);
    sub_1AC70((float *)v9 + 6, 0, 0, 1);
    sub_1BF94((P_Type1)count, v49, 0x1A08u);
    qmemcpy(v4, v49, 0x4B0u);
    qmemcpy(v58, v50, 0xE10u);
    qmemcpy(v59, v51, 0x190u);
    v11 = v71;
    qmemcpy(v60, v52, 0x4B0u);
    *v11 = v53;
    v11[1] = v54;
    v11[2] = v55;
    v12 = v72;
    *v72 = v56[0];
    v12[1] = v56[1];
    v12[2] = v56[2];
    v13 = v67;
    *v67 = v56[3];
    v13[1] = v56[4];
    v13[2] = v56[5];
    v14 = v66;
    *v66 = v56[6];
    v14[1] = v56[7];
    v14[2] = v56[8];
    v15 = v72;
    v72[9] = v56[9];
    v15[0xA] = v56[0xA];
    v15[0xB] = v56[0xB];
    v15[0xC] = v56[0xC];
    v16 = v65;
    *v65 = v56[0xD];
    v16[1] = v56[0xE];
    v16[2] = v56[0xF];
    v17 = v72;
    v72[0x10] = v56[0x10];
    v17[0x11] = v56[0x11];
    v17[0x12] = v56[0x12];
    v17[0x13] = v56[0x13];
    v17[0x14] = v56[0x14];
    v17[0x15] = v56[0x15];
    v17[0x16] = v56[0x16];
    v17[0x17] = v56[0x17];
    v17[0x18] = v56[0x18];
    v17[0x19] = v56[0x19];
    v17[0x1A] = v56[0x1A];
    v17[0x1B] = v56[0x1B];
    v17[0x1C] = v56[0x1C];
    v18 = v70;
    *v70 = v56[0x1D];
    v18[1] = v56[0x1E];
    v18[2] = v56[0x1F];
    v19 = v61;
    *v61 = v56[0x20];
    v19[1] = v56[0x21];
    v19[2] = v56[0x22];
    v20 = v62;
    *v62 = v56[0x23];
    v20[1] = v56[0x24];
    v20[2] = v56[0x25];
    v21 = v69;
    *v69 = v56[0x26];
    v21[1] = v56[0x27];
    v21[2] = v56[0x28];
    v22 = v68;
    *v68 = v56[0x29];
    v22[1] = v56[0x2A];
    v22[2] = v56[0x2B];
    v23 = v63;
    *v63 = v56[0x2C];
    v23[1] = v56[0x2D];
    v23[2] = v56[0x2E];
    v24 = v64;
    *v64 = v56[0x2F];
    v24[1] = v56[0x30];
    v24[2] = v56[0x31];
    *(_DWORD *)(a1 + 0x4F0E) = v56[0x32];
    *(_DWORD *)(a1 + 0x4F12) = v56[0x33];
    *(_DWORD *)(a1 + 0x4F16) = v56[0x34];
    *(_DWORD *)(a1 + 0x4F1A) = v56[0x35];
    *(_DWORD *)(a1 + 0x4F1E) = v56[0x36];
    *(_DWORD *)(a1 + 0x4F22) = v56[0x37];
    *(_DWORD *)(a1 + 0x4F26) = v56[0x38];
    *(_DWORD *)(a1 + 0x4F2A) = v56[0x39];
    *(_DWORD *)(a1 + 0x503A) = v56[0x3A];
    *(_DWORD *)(a1 + 0x503E) = v56[0x3B];
    *(_DWORD *)(a1 + 0x5042) = v56[0x3C];
    *(_DWORD *)(a1 + 0x5046) = v56[0x3D];
    *(_DWORD *)(a1 + 0x504A) = v56[0x3E];
    ((void (__fastcall *)(int *, _DWORD))locret_1B66C)(v56, 0);
    sub_1A9E0((int)v52);
    sub_1AA00((int)v50);
    return (unsigned int)sub_1A9E0((int)v49);
  }
  else
  {
    v26 = _wcpp_2_ctor_array_(v32, 0x64, &unk_959D8);
    v27 = _wcpp_2_ctor_array_(v26 + 0x4B0, 0x64, &unk_95A3C);
    v28 = (_DWORD *)(_wcpp_2_ctor_array_(v27 + 0xFA0, 0x64, &unk_959D8) + 0x4B0);
    *v28 = 0;
    v28 += 3;
    v28[0xFFFFFFFE] = 0;
    v28[0xFFFFFFFF] = 0;
    v29 = sub_1B4F0(v28) + 0x26;
    v29[1] = 0;
    v29[2] = 0;
    *v29 = 0;
    v29 += 3;
    v30 = v29 + 3;
    sub_1ACA0(v29);
    sub_1ACA0(v30);
    v31 = v30 + 3;
    v30 += 0xFFFFFFFD;
    sub_1ACA0(v31);
    sub_1AC70((float *)v30, 1, 0, 0);
    sub_1AC70((float *)v30 + 3, 0, 1, 0);
    sub_1AC70((float *)v30 + 6, 0, 0, 1);
    qmemcpy(v32, v4, sizeof(v32));
    qmemcpy(v33, v58, sizeof(v33));
    qmemcpy(v34, v59, sizeof(v34));
    qmemcpy(v35, v60, sizeof(v35));
    v36 = *v71;
    v37 = v71[1];
    v38 = v71[2];
    v39[0] = *v72;
    v39[1] = v72[1];
    v39[2] = v72[2];
    v39[3] = *v67;
    v39[4] = v67[1];
    v39[5] = v67[2];
    v39[6] = *v66;
    v39[7] = v66[1];
    v39[8] = v66[2];
    v39[9] = v72[9];
    v39[0xA] = v72[0xA];
    v39[0xB] = v72[0xB];
    v39[0xC] = v72[0xC];
    v39[0xD] = *v65;
    v39[0xE] = v65[1];
    v39[0xF] = v65[2];
    v39[0x10] = v72[0x10];
    v39[0x11] = v72[0x11];
    v39[0x12] = v72[0x12];
    v39[0x13] = v72[0x13];
    v39[0x14] = v72[0x14];
    v39[0x15] = v72[0x15];
    v39[0x16] = v72[0x16];
    v39[0x17] = v72[0x17];
    v39[0x18] = v72[0x18];
    v39[0x19] = v72[0x19];
    v39[0x1A] = v72[0x1A];
    v39[0x1B] = v72[0x1B];
    v39[0x1C] = v72[0x1C];
    v39[0x1D] = *v70;
    v39[0x1E] = v70[1];
    v39[0x1F] = v70[2];
    v39[0x20] = *v61;
    v39[0x21] = v61[1];
    v39[0x22] = v61[2];
    v39[0x23] = *v62;
    v39[0x24] = v62[1];
    v39[0x25] = v62[2];
    v39[0x26] = *v69;
    v39[0x27] = v69[1];
    v39[0x28] = v69[2];
    v39[0x29] = *v68;
    v39[0x2A] = v68[1];
    v39[0x2B] = v68[2];
    v39[0x2C] = *v63;
    v39[0x2D] = v63[1];
    v39[0x2E] = v63[2];
    v39[0x2F] = *v64;
    v39[0x30] = v64[1];
    v39[0x31] = v64[2];
    v39[0x32] = *(_DWORD *)(a1 + 0x4F0E);
    v39[0x33] = *(_DWORD *)(a1 + 0x4F12);
    v39[0x34] = *(_DWORD *)(a1 + 0x4F16);
    v39[0x35] = *(_DWORD *)(a1 + 0x4F1A);
    v39[0x36] = *(_DWORD *)(a1 + 0x4F1E);
    v40 = *(_WORD *)(a1 + 0x4F22);
    v41 = *(_WORD *)(a1 + 0x4F24);
    v42 = *(_DWORD *)(a1 + 0x4F26);
    v43 = *(_DWORD *)(a1 + 0x4F2A);
    v44 = *(_DWORD *)(a1 + 0x503A);
    v45 = *(_DWORD *)(a1 + 0x503E);
    v46 = *(_DWORD *)(a1 + 0x5042);
    v47 = *(_DWORD *)(a1 + 0x5046);
    v48 = *(_DWORD *)(a1 + 0x504A);
    sub_1C098(count, (int)v32, 0x1A08u);
    ((void (__fastcall *)(int *, _DWORD))locret_1B66C)(v39, 0);
    sub_1A9E0((int)v35);
    sub_1AA00((int)v33);
    return (unsigned int)sub_1A9E0((int)v32);
  }
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001A9C0) --------------------------------------------------------
int __fastcall sub_1A9C0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0xF, &unk_959D8);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001A9E0) --------------------------------------------------------
int __fastcall sub_1A9E0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x64, &unk_959D8);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001AA00) --------------------------------------------------------
int __fastcall sub_1AA00(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x64, &unk_95A3C);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001AA40) --------------------------------------------------------
_DWORD *__fastcall sub_1AA40(float *a1, float *a2)
{
  _DWORD *v2; // ebx
  float *v3; // eax
  double v4; // st7
  float *v5; // edx
  _DWORD *result; // eax

  v2 = a2 + 3;
  *a1 = *a2;
  v3 = a1 + 3;
  v4 = a2[1];
  v5 = a2 + 6;
  v3[0xFFFFFFFE] = v4;
  v3 += 3;
  v3[0xFFFFFFFC] = v5[0xFFFFFFFC];
  result = v3 + 0xFFFFFFFA;
  result[3] = *v2;
  result[4] = v2[1];
  result[5] = v2[2];
  result[6] = *(_DWORD *)v5;
  result[7] = *((_DWORD *)v5 + 1);
  result[8] = *((_DWORD *)v5 + 2);
  return result;
}

//----- (0001AA90) --------------------------------------------------------
__int64 __fastcall sub_1AA90(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax

  v1 = ((int (__fastcall *)(int, _DWORD))locret_1B66C)(a1 + 0x190C, 0);
  v2 = sub_1A9E0(v1 - 0x4BC);
  v3 = sub_1AA00(v2 - 0xFA0);
  return (unsigned int)sub_1A9E0(v3 - 0x4B0);
}

//----- (0001AAC0) --------------------------------------------------------
_DWORD *__fastcall sub_1AAC0(int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // edx
  _DWORD *result; // eax

  v1 = _wcpp_2_ctor_array_(a1, 0x64, &unk_959D8);
  v2 = _wcpp_2_ctor_array_(v1 + 0x4B0, 0x64, &unk_95A3C);
  v3 = (_DWORD *)(_wcpp_2_ctor_array_(v2 + 0xFA0, 0x64, &unk_959D8) + 0x4B0);
  *v3 = 0;
  v3 += 3;
  v3[0xFFFFFFFE] = 0;
  v3[0xFFFFFFFF] = 0;
  v4 = sub_1B4F0(v3) + 0x26;
  *v4 = 0;
  v4 += 3;
  v4[0xFFFFFFFE] = 0;
  v4[0xFFFFFFFF] = 0;
  *v4 = 0;
  v4 += 3;
  v4[0xFFFFFFFE] = 0;
  v4[0xFFFFFFFF] = 0;
  *v4 = 0;
  v4 += 3;
  v4[0xFFFFFFFE] = 0;
  v4[0xFFFFFFFF] = 0;
  *v4 = 0;
  v4 += 0xFFFFFFFA;
  v4[7] = 0;
  v4[8] = 0;
  v4[1] = 0;
  v4[2] = 0;
  *v4 = 0x3F800000;
  v4[3] = 0;
  v4[4] = 0x3F800000;
  v4[5] = 0;
  v5 = v4 + 6;
  v4[6] = 0;
  v4[7] = 0;
  result = v4 + 0xFFFFF994;
  v5[2] = 0x3F800000;
  return result;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001ABE0) --------------------------------------------------------
_DWORD *__fastcall sub_1ABE0(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD *result; // eax

  *a1 = 0;
  v1 = a1 + 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  result = v1 + 0xFFFFFFFA;
  result[7] = 0;
  result[8] = 0;
  result[1] = 0;
  result[2] = 0;
  *result = 0x3F800000;
  result[3] = 0;
  result[4] = 0x3F800000;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0x3F800000;
  return result;
}

//----- (0001AC70) --------------------------------------------------------
float *__fastcall sub_1AC70(float *result, int a2, int a3, int a4)
{
  *result = (float)a2;
  result[1] = (float)a3;
  result[2] = (float)a4;
  return result;
}

//----- (0001ACA0) --------------------------------------------------------
_DWORD *__fastcall sub_1ACA0(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (0001ACC0) --------------------------------------------------------
int __fastcall sub_1ACC0(int a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 0x2EE4) = 0;
  *(_DWORD *)(a1 + 0x2EE8) = 0;
  *(_WORD *)(a1 + 0x2EE0) = 0;
  *(_WORD *)(a1 + 0x2EE2) = 0;
  return sub_1ACE8(a1, a2, a3);
}
// 1ACE8: using guessed type int __fastcall sub_1ACE8(_DWORD, _DWORD, _DWORD);

//----- (0001ACE8) --------------------------------------------------------
int __fastcall sub_1ACE8(int result)
{
  *(_DWORD *)(result + 0x2EEC) = 0xFFFFFFFF;
  return result;
}

//----- (0001ACF4) --------------------------------------------------------
int __fastcall sub_1ACF4(int a1)
{
  int result; // eax

  sub_262CC(*(void **)(a1 + 0x2EE4));
  *(_DWORD *)(a1 + 0x2EE4) = 0;
  result = a1;
  *(_DWORD *)(a1 + 0x2EE8) = 0;
  return result;
}

//----- (0001AD1C) --------------------------------------------------------
_DWORD *__fastcall sub_1AD1C(int a1, int a2)
{
  void *v3; // eax
  void *v4; // eax
  int v5; // edx
  _DWORD *result; // eax
  size_t size; // [esp+0h] [ebp-Ch]

  size = a2 + 3;
  LOBYTE(size) = (a2 + 3) & 0xFC;
  v3 = operator new[](size);
  v4 = sub_2625C(v3, 5, "SHAPE CACHE");
  *(_DWORD *)(a1 + 0x2EE4) = v4;
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x41);
  }
  *(_WORD *)(a1 + 0x2EE0) = 0;
  *(_WORD *)(a1 + 0x2EE2) = 0;
  v5 = a1;
  *(_DWORD *)(a1 + 0x2EE8) = size;
  result = (_DWORD *)a1;
  do
  {
    *result++ = 0;
    *(_BYTE *)(v5 + 0x7D0) = 0;
    v5 += 0x32;
    result[0xC7] = 0;
  }
  while ( result != (_DWORD *)(a1 + 0x320) );
  return result;
}

//----- (0001ADAC) --------------------------------------------------------
int __fastcall sub_1ADAC(int a1, const char *a2)
{
  const char *v3; // esi
  unsigned int v4; // kr04_4
  int v5; // eax
  int v6; // edx
  char *v7; // edi
  char v8; // al
  char v9; // al

  v3 = a2;
  if ( !*(_DWORD *)(a1 + 0x2EE4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x53);
  }
  v4 = strlen(a2) + 1;
  if ( (int)(v4 - 1) <= 0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x59);
  }
  if ( (int)(v4 - 1) >= 0x32 )
  {
    sub_2620C("Cache filename too long: %s", (char)a2);
    sub_261B8(0, "..\\cache.cpp", 0x5B);
  }
  if ( *(__int16 *)(a1 + 0x2EE0) >= 0xC8 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x5C);
  }
  v5 = a1;
  v6 = 0;
  while ( *(_BYTE *)(v5 + 0x7D0) )
  {
    ++v6;
    v5 += 0x32;
    if ( v6 >= 0xC8 )
    {
      return 0xFFFF;
    }
  }
  v7 = (char *)(0x32 * v6 + a1 + 0x7D0);
  do
  {
    v8 = *v3;
    *v7 = *v3;
    if ( !v8 )
    {
      break;
    }
    v9 = v3[1];
    v3 += 2;
    v7[1] = v9;
    v7 += 2;
  }
  while ( v9 );
  ++*(_WORD *)(a1 + 0x2EE0);
  return v6;
}

//----- (0001AEB0) --------------------------------------------------------
int __fastcall sub_1AEB0(unsigned int a1, unsigned __int16 a2, const char *a3)
{
  const char *v4; // esi
  unsigned int v5; // kr04_4
  int v6; // eax
  int result; // eax
  char *v8; // edi
  char v9; // al
  char v10; // al

  v4 = a3;
  if ( !*(_DWORD *)(a1 + 0x2EE4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x70);
  }
  v5 = strlen(a3) + 1;
  if ( (int)(v5 - 1) <= 0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x74);
  }
  if ( (int)(v5 - 1) >= 0x32 )
  {
    sub_2620C("Cache filename too long: %s", (char)a3);
    sub_261B8(0, "..\\cache.cpp", 0x76);
  }
  if ( *(__int16 *)(a1 + 0x2EE0) >= 0xC8 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x77);
  }
  if ( a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x78);
  }
  v6 = 0x32 * a2;
  if ( *(_BYTE *)(v6 + a1 + 0x7D0) )
  {
    if ( !stricmp(a3, (const char *)(v6 + a1 + 0x7D0)) )
    {
      return 0xFFFFFFFF;
    }
    sub_1B000(a1, a2);
  }
  v8 = (char *)(0x32 * a2 + a1 + 0x7D0);
  do
  {
    v9 = *v4;
    *v8 = *v4;
    if ( !v9 )
    {
      break;
    }
    v10 = v4[1];
    v4 += 2;
    v8[1] = v10;
    v8 += 2;
  }
  while ( v10 );
  result = 0xFFFFFFFF;
  ++*(_WORD *)(a1 + 0x2EE0);
  return result;
}

//----- (0001B000) --------------------------------------------------------
int __fastcall sub_1B000(unsigned int a1, unsigned __int16 a2)
{
  int result; // eax

  if ( a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x95);
  }
  if ( !*(_BYTE *)(a1 + 0x32 * a2 + 0x7D0) )
  {
    Q_AssertLogBreakExit_sub_261A8(*(char *)(a1 + 0x32 * a2 + 0x7D0), "..\\cache.cpp", 0x96);
  }
  sub_1B354(a1, a2);
  result = 0x19 * a2;
  *(_BYTE *)(a1 + 0x32 * a2 + 0x7D0) = 0;
  --*(_WORD *)(a1 + 0x2EE0);
  return result;
}

//----- (0001B084) --------------------------------------------------------
int __fastcall sub_1B084(unsigned int a1, int a2)
{
  unsigned __int16 v3; // di
  int v4; // eax
  int v5; // ecx
  void *v6; // edx
  unsigned int v8; // edx
  int i; // eax
  unsigned int j; // edx
  int v11; // ebx
  T_Type1 v12; // [esp+0h] [ebp-12Ch] BYREF

  v3 = a2;
  if ( !*(_DWORD *)(a1 + 0x2EEC) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0xA2);
  }
  if ( (unsigned __int16)a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0xA6);
  }
  if ( !*(_BYTE *)(a1 + 0x32 * (unsigned __int16)a2 + 0x7D0) )
  {
    Q_AssertLogBreakExit_sub_261A8(*(char *)(a1 + 0x32 * (unsigned __int16)a2 + 0x7D0), "..\\cache.cpp", 0xA7);
  }
  HIWORD(a2) = 0;
  if ( *(_DWORD *)(a1 + 4 * (unsigned __int16)a2) )
  {
    v8 = a1;
    for ( i = 0; i < *(__int16 *)(a1 + 0x2EE2) && v3 != *(_WORD *)(v8 + 0x640); ++i )
    {
      v8 += 2;
    }
    for ( j = a1 + 2 * i; ; *(_WORD *)(j + 0x63E) = *(_WORD *)(j + 0x640) )
    {
      v11 = *(__int16 *)(a1 + 0x2EE2);
      if ( i >= v11 )
      {
        break;
      }
      j += 2;
      ++i;
    }
    *(_WORD *)(a1 + 2 * v11 + 0x63E) = v3;
    return *(_DWORD *)(a1 + 4 * v3);
  }
  else
  {
    Q_InitFileInfo_sub_1BB78(&v12);
    Q_CfilePreload_sub_1BBFC(&v12, (const char *)(0x32 * a2 + a1 + 0x7D0), 0x200, 0);
    v4 = sub_1BE28(&v12);
    v5 = v4 + 3;
    LOBYTE(v5) = (v4 + 3) & 0xFC;
    if ( v5 >= *(_DWORD *)(a1 + 0x2EE8) )
    {
      sub_2620C("Single item too big for cache: %s, %d", 0x32 * a2 + a1 - 0x30);
      sub_261B8(0, "..\\cache.cpp", 0xB8);
    }
    *(_DWORD *)(a1 + 4 * (unsigned __int16)a2) = sub_1B2DC(a1, v5);
    v6 = *(void **)(a1 + 4 * (unsigned __int16)a2);
    *(_DWORD *)(a1 + 4 * v3 + 0x320) = v5;
    if ( !sub_1BF1C(&v12, v6) )
    {
      sub_2620C("Cache unable to load file: %s", 0x32 * v3 + a1 - 0x30);
      sub_261B8(0, "..\\cache.cpp", 0xC0);
    }
    *(_WORD *)(a1 + 2 * (__int16)(*(_WORD *)(a1 + 0x2EE2))++ + 0x640) = v3;
    Q_CloseFileAndDelete_sub_1BBC8(&v12);
    return *(_DWORD *)(a1 + 4 * v3);
  }
}

//----- (0001B270) --------------------------------------------------------
int __fastcall sub_1B270(int a1, const char *a2, int a3)
{
  const char *v5; // ebx
  int v6; // ecx
  int v8; // [esp+0h] [ebp-14h]

  v5 = (const char *)(a1 + 0x7D0);
  v6 = 0;
  v8 = 0xFFFF;
  while ( v6 < *(__int16 *)(a1 + 0x2EE0) )
  {
    if ( !stricmp(a2, v5) )
    {
      v8 = v6;
      break;
    }
    v5 += 0x32;
    ++v6;
  }
  if ( a3 == 0xFFFFFFFF && (unsigned __int16)v8 == 0xFFFF )
  {
    return sub_1ADAC(a1, a2);
  }
  return v8;
}

//----- (0001B2DC) --------------------------------------------------------
int __fastcall sub_1B2DC(unsigned int a1, int a2)
{
  unsigned int v2; // ecx
  unsigned int v4; // edx
  int v5; // esi
  int v6; // ebx
  int v7; // edi
  int result; // eax
  int i; // esi
  unsigned __int16 v10; // dx

  v2 = a1;
  v4 = a1 + 0x320;
  v5 = 0;
  do
  {
    v6 = *(_DWORD *)(a1 + 0x320);
    a1 += 4;
    v5 += v6;
  }
  while ( a1 != v4 );
  v7 = 0;
  result = v5 + *(_DWORD *)(v2 + 0x2EE4);
  for ( i = *(_DWORD *)(v2 + 0x2EE8) - v5; i <= a2; result = sub_1B354(v2, v10) )
  {
    if ( v7 >= *(__int16 *)(v2 + 0x2EE0) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0xFF);
    }
    v10 = *(_WORD *)(v2 + 0x640);
    i += *(_DWORD *)(v2 + 4 * v10 + 0x320);
    ++v7;
  }
  return result;
}

//----- (0001B354) --------------------------------------------------------
int __fastcall sub_1B354(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // ebp
  int v4; // edx
  int v5; // ecx
  void *v6; // edx
  int v7; // ebx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // eax
  unsigned int i; // edx
  unsigned int v12; // edx
  unsigned int v13; // [esp+0h] [ebp-20h]
  int v14; // [esp+4h] [ebp-1Ch]
  int v15; // [esp+4h] [ebp-1Ch]

  v2 = a1;
  if ( a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x10D);
  }
  if ( !*(_DWORD *)(a1 + 4 * a2) )
  {
    return 0;
  }
  v4 = 0;
  do
  {
    v5 = *(_DWORD *)(a1 + 0x320);
    a1 += 4;
    v4 += v5;
  }
  while ( a1 != v2 + 0x320 );
  v14 = v4 + *(_DWORD *)(v2 + 0x2EE4);
  v13 = 4 * a2 + v2;
  v6 = *(void **)v13;
  v7 = *(_DWORD *)(v13 + 0x320);
  qmemcpy(*(void **)v13, (const void *)(*(_DWORD *)v13 + v7), v14 - (*(_DWORD *)v13 + v7));
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 0x320) = 0;
  v8 = v2;
  v9 = v2 + 0x320;
  do
  {
    if ( (unsigned int)v6 < *(_DWORD *)v8 )
    {
      *(_DWORD *)v8 -= v7;
    }
    v8 += 4;
  }
  while ( v8 != v9 );
  v10 = v9 ^ v8;
  v15 = v14 - v7;
  --*(_WORD *)(v2 + 0x2EE2);
  for ( i = v2; v10 < *(__int16 *)(v2 + 0x2EE2) && a2 != *(_WORD *)(i + 0x640); i += 2 )
  {
    ++v10;
  }
  v12 = v2 + 2 * v10;
  while ( v10 < *(__int16 *)(v2 + 0x2EE2) )
  {
    v12 += 2;
    ++v10;
    *(_WORD *)(v12 + 0x63E) = *(_WORD *)(v12 + 0x640);
  }
  return v15;
}

//----- (0001B498) --------------------------------------------------------
_DWORD *__fastcall sub_1B498(_DWORD *result)
{
  _DWORD *v1; // ecx
  int i; // edx

  v1 = result;
  for ( i = 0; i < *((__int16 *)v1 + 0x1770); ++i )
  {
    *result = 0;
    result[0xC8] = 0;
    ++result;
  }
  *((_WORD *)v1 + 0x1771) = 0;
  return result;
}

//----- (0001B4D0) --------------------------------------------------------
_DWORD *__fastcall sub_1B4D0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = sub_1B498(a1);
  a1[0xBBB] = 0;
  return result;
}

//----- (0001B4F0) --------------------------------------------------------
_DWORD *__fastcall sub_1B4F0(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx

  *a1 = 0;
  v1 = a1 + 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 0xFFFFFFFA;
  v1[7] = 0;
  v1[8] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0x3F800000;
  v1[3] = 0;
  v1[4] = 0x3F800000;
  v1[5] = 0;
  v2 = v1 + 6;
  v1[6] = 0;
  v1[7] = 0;
  v1 += 0xD;
  v2[2] = 0x3F800000;
  *v1 = 0;
  v1 += 0x10;
  v1[0xFFFFFFF1] = 0;
  v1[0xFFFFFFF2] = 0;
  v1[0xFFFFFFFD] = 0x3F800000;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFF8] = v1[0xFFFFFFFD];
  v1[0xFFFFFFF3] = v1[0xFFFFFFF8];
  v1[0xFFFFFFFC] = v1[0xFFFFFFFE];
  v1[0xFFFFFFFB] = v1[0xFFFFFFFC];
  v1[0xFFFFFFFA] = v1[0xFFFFFFFB];
  v1[0xFFFFFFF9] = v1[0xFFFFFFFA];
  v1[0xFFFFFFF7] = v1[0xFFFFFFF9];
  v1[0xFFFFFFF6] = v1[0xFFFFFFF7];
  v1[0xFFFFFFF5] = v1[0xFFFFFFF6];
  v1[0xFFFFFFF4] = v1[0xFFFFFFF5];
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  v1 += 0xFFFFFFFA;
  *v1 = 0x3F800000;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v1[4] = 0x3F800000;
  v1[5] = 0;
  v1[6] = 0;
  v1[7] = 0;
  v1[8] = 0x3F800000;
  return v1 + 0xFFFFFFE3;
}

//----- (0001B808) --------------------------------------------------------
void __fastcall sub_1B808(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  a1[9] = a5;
  a1[0xB] = a6;
  a1[0xC] = a7;
  a1[0x1C] = 0x3F800000;
  sub_1B834((int)a1, a8);
}

//----- (0001B834) --------------------------------------------------------
void __fastcall sub_1B834(int a1, int a2)
{
  *(float *)(a1 + 0x28) = (double)a2 / tan(*(float *)(a1 + 0x24) * flt_95A68 * flt_907F4);
}
// 907F4: using guessed type float flt_907F4;
// 95A68: using guessed type float flt_95A68;

//----- (0001B864) --------------------------------------------------------
float *__fastcall sub_1B864(int a1, int a2, int a3, int a4)
{
  float *v5; // eax
  double v6; // st7
  int v8[9]; // [esp+0h] [ebp-70h] BYREF
  int v9[9]; // [esp+24h] [ebp-4Ch] BYREF
  float v10; // [esp+48h] [ebp-28h]
  float v11; // [esp+4Ch] [ebp-24h]
  float v12; // [esp+50h] [ebp-20h]
  int v13[7]; // [esp+54h] [ebp-1Ch] BYREF

  v13[5] = a4;
  v13[3] = (int)v13;
  v5 = (float *)(a1 + 0x34);
  v10 = 0.0;
  v11 = 0.0;
  v12 = 0.0;
  v10 = -*v5;
  v11 = -v5[1];
  v6 = -v5[2];
  *(float *)v13 = v10;
  v12 = v6;
  *(float *)&v13[1] = v11;
  *(float *)&v13[2] = v12;
  v8[0] = *(_DWORD *)(a1 + 0x74);
  v8[1] = *(_DWORD *)(a1 + 0x78);
  v8[2] = *(_DWORD *)(a1 + 0x7C);
  v8[3] = *(_DWORD *)(a1 + 0x80);
  v8[4] = *(_DWORD *)(a1 + 0x84);
  v8[5] = *(_DWORD *)(a1 + 0x88);
  v8[6] = *(_DWORD *)(a1 + 0x8C);
  v8[7] = *(_DWORD *)(a1 + 0x90);
  v8[8] = *(_DWORD *)(a1 + 0x94);
  v9[0] = *(_DWORD *)a1;
  v9[1] = *(_DWORD *)(a1 + 4);
  v9[2] = *(_DWORD *)(a1 + 8);
  v9[3] = *(_DWORD *)(a1 + 0xC);
  v9[4] = *(_DWORD *)(a1 + 0x10);
  v9[5] = *(_DWORD *)(a1 + 0x14);
  v9[6] = *(_DWORD *)(a1 + 0x18);
  v9[7] = *(_DWORD *)(a1 + 0x1C);
  v9[8] = *(_DWORD *)(a1 + 0x20);
  return sub_53B08((float *)(a1 + 0x40), (float *)v9, (float *)v8, (float *)v13);
}

//----- (0001B958) --------------------------------------------------------
float *__fastcall sub_1B958(int a1, float *a2, int a3, int a4)
{
  int v5[9]; // [esp+0h] [ebp-88h] BYREF
  int v6[9]; // [esp+24h] [ebp-64h] BYREF
  int v7[3]; // [esp+48h] [ebp-40h] BYREF
  float v8; // [esp+54h] [ebp-34h]
  int v9; // [esp+58h] [ebp-30h]
  int v10; // [esp+5Ch] [ebp-2Ch]
  float v11; // [esp+60h] [ebp-28h]
  float v12; // [esp+64h] [ebp-24h]
  float v13; // [esp+68h] [ebp-20h]
  int v14[7]; // [esp+6Ch] [ebp-1Ch] BYREF

  v14[5] = a4;
  v14[3] = (int)v7;
  v11 = 0.0;
  v12 = 0.0;
  v13 = 0.0;
  v11 = *a2 + *(float *)(a1 + 0x34);
  v12 = a2[1] + *(float *)(a1 + 0x38);
  v13 = a2[2] + *(float *)(a1 + 0x3C);
  *(float *)v7 = v11;
  v8 = -v11;
  *(float *)&v7[1] = v12;
  *(float *)&v9 = -v12;
  *(float *)&v7[2] = v13;
  v14[4] = (int)v14;
  *(float *)v14 = v8;
  *(float *)&v10 = -v13;
  v14[1] = v9;
  v14[2] = v10;
  v6[0] = *(_DWORD *)(a1 + 0x74);
  v6[1] = *(_DWORD *)(a1 + 0x78);
  v6[2] = *(_DWORD *)(a1 + 0x7C);
  v6[3] = *(_DWORD *)(a1 + 0x80);
  v6[4] = *(_DWORD *)(a1 + 0x84);
  v6[5] = *(_DWORD *)(a1 + 0x88);
  v6[6] = *(_DWORD *)(a1 + 0x8C);
  v6[7] = *(_DWORD *)(a1 + 0x90);
  v6[8] = *(_DWORD *)(a1 + 0x94);
  v5[0] = *(_DWORD *)a1;
  v5[1] = *(_DWORD *)(a1 + 4);
  v5[2] = *(_DWORD *)(a1 + 8);
  v5[3] = *(_DWORD *)(a1 + 0xC);
  v5[4] = *(_DWORD *)(a1 + 0x10);
  v5[5] = *(_DWORD *)(a1 + 0x14);
  v5[6] = *(_DWORD *)(a1 + 0x18);
  v5[7] = *(_DWORD *)(a1 + 0x1C);
  v5[8] = *(_DWORD *)(a1 + 0x20);
  return sub_53B08((float *)(a1 + 0x40), (float *)v5, (float *)v6, (float *)v14);
}

//----- (0001BAF0) --------------------------------------------------------
void __fastcall sub_1BAF0(float *a1, int a2, int a3, int a4, int a5)
{
  sub_532AC(a1 + 0xD, *(float *)&a5);
  sub_535E4(a1, (int)a1, a3, a4, a5);
}

//----- (0001BB10) --------------------------------------------------------
FILE *__fastcall sub_1BB10(const char *aFName, fpos_t *pos)
{
  FILE *v2; // eax
  FILE *v3; // edi
  T_Type1 v1; // [esp+0h] [ebp-128h] BYREF

  Q_InitFileInfo_sub_1BB78(&v1);
  Q_CfilePreload_sub_1BBFC(&v1, aFName, O_TEXT, 0);
  v2 = fdopen(v1.fh, "r");
  v3 = v2;
  if ( pos )
  {
    fgetpos(v2, pos);
    *pos += sub_1BE28(&v1);
  }
  v1.fh = 0xFFFFFFFF;
  Q_CloseFileAndDelete_sub_1BBC8(&v1);
  return v3;
}
// 1BB10: using guessed type T_Type1 v1;

//----- (0001BB78) --------------------------------------------------------
void __fastcall __spoils<> Q_InitFileInfo_sub_1BB78(P_Type1 a1)
{
  if ( !V_CobCfgLoaded_dword_9A250 )
  {
    Q_CobCfgLoad_sub_1C3C4(&V_CobFilesIndex_stru_9A254);
    V_CobCfgLoaded_dword_9A250 = 0xFFFFFFFF;
  }
  a1->fh = 0xFFFFFFFF;
  a1->fname[0] = 0;
  a1->d = 0;
  a1->e = 0;
  a1->index = 0xFFFFFFFF;
}
// 9A250: using guessed type int V_CobCfgLoaded_dword_9A250;

//----- (0001BBC8) --------------------------------------------------------
void __fastcall __spoils<> Q_CloseFileAndDelete_sub_1BBC8(P_Type1 a1)
{
  Q_CloseFile_sub_1BE00(a1);
  if ( a1->e == 0xFFFFFFFF && a1->d )
  {
    sub_2627C(a1->d);
  }
  operator delete[](a1->d);
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0001BBFC) --------------------------------------------------------
BOOL __fastcall Q_CfilePreload_sub_1BBFC(P_Type1 a1, const char *aFName, int aOFlags, int a4)
{
  BOOL result; // eax
  int len; // eax
  unsigned int v7; // ecx
  void *pData; // eax
  void *v9; // eax

  if ( a1->fh != 0xFFFFFFFF )
  {
    Q_CloseFile_sub_1BE00(a1);
  }
  a1->e = 0;
  strncpy(a1->fname, aFName, 0x100u);
  a1->fname[0xFF] = 0;
  result = Q_CFILE_CPP_sub_1BCBC(a1, aOFlags);
  if ( !result )
  {
    if ( a4 == 0xFFFFFFFF )
    {
      len = filelength(a1->fh);
      v7 = len;
      if ( len > 0 )
      {
        pData = operator new[](len);
        v9 = sub_2625C(pData, 1, "CFILE PRELOAD");
        a1->d = v9;
        if ( v9 )
        {
          if ( !sub_1BF94(a1, v9, v7) )
          {
            a1->e = 0xFFFFFFFF;
            return 0;
          }
          sub_2627C(a1->d);
          operator delete[](a1->d);
          a1->d = 0;
        }
      }
    }
    return 0;
  }
  return result;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0001BCA8) --------------------------------------------------------
BOOL __fastcall sub_1BCA8(T_Type1 *a1, const char *a2)
{
  return Q_CfilePreload_sub_1BBFC(a1, a2, 0x21, 0);
}

//----- (0001BCBC) --------------------------------------------------------
BOOL __fastcall Q_CFILE_CPP_sub_1BCBC(T_Type1 *a1, int aOFlags)
{
  int v2; // eax
  int v3; // edi
  int v4; // ecx
  T_CobFilesIndex *v5; // ebx
  int v6; // esi
  int v7; // eax
  unsigned int v9; // [esp+0h] [ebp-20h]
  int oflag; // [esp+4h] [ebp-1Ch]

  oflag = aOFlags;
  if ( a1->fh != 0xFFFFFFFF )
  {
    Q_CloseFile_sub_1BE00(a1);
  }
  if ( (aOFlags & 0x20) != 0 )
  {
    LOWORD(oflag) = aOFlags | 0x240;
    v2 = open(a1->fname, oflag, 0x180);
LABEL_19:
    a1->fh = v2;
    goto LABEL_20;
  }
  v9 = 0;
  if ( (aOFlags & 3) == 0 )
  {
    v3 = 0;
    v4 = 0;
    if ( V_CobFilesIndex_stru_9A254.files > 0 )
    {
      v5 = &V_CobFilesIndex_stru_9A254;
      v6 = 0;
      while ( 1 )
      {
        if ( v4 == V_CobFilesIndex_stru_9A254.cobfiles[v6] )
        {
          ++v6;
          ++v3;
        }
        if ( !stricmp(a1->fname, (const char *)v5) )
        {
          break;
        }
        ++v4;
        v5 = (T_CobFilesIndex *)((char *)v5 + 0x32);
        if ( v4 >= V_CobFilesIndex_stru_9A254.files )
        {
          goto LABEL_17;
        }
      }
      a1->index = v4;
      v7 = open(V_CobFilesIndex_stru_9A254.cobnames[v3], aOFlags);
      a1->fh = v7;
      if ( v7 == 0xFFFFFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cfile.cpp", 0xC4);
      }
      lseek(a1->fh, V_CobFilesIndex_stru_9A254.flengths[v4], 0);
      v9 = 0xFFFFFFFF;
    }
  }
LABEL_17:
  if ( !v9 )
  {
    v2 = open(a1->fname, aOFlags);
    goto LABEL_19;
  }
LABEL_20:
  a1->d4 = oflag;
  return a1->fh == 0xFFFFFFFF;
}

//----- (0001BE00) --------------------------------------------------------
int __fastcall Q_CloseFile_sub_1BE00(P_Type1 a1)
{
  int result; // eax

  if ( a1->fh == 0xFFFFFFFF )
  {
    return 0;
  }
  result = close(a1->fh);
  if ( !result )
  {
    a1->fh = 0xFFFFFFFF;
  }
  return result;
}

//----- (0001BE28) --------------------------------------------------------
int __fastcall sub_1BE28(P_Type1 a1)
{
  int index; // ecx
  int v4; // esi
  int v5; // eax

  if ( a1->fh == 0xFFFFFFFF )
  {
    return 0xFFFFFFFF;
  }
  index = a1->index;
  if ( index == 0xFFFFFFFF )
  {
    return filelength(a1->fh);
  }
  v4 = V_CobFilesIndex_stru_9A254.flengths[index + 1];
  if ( V_CobFilesIndex_stru_9A254.cobindex > 0 )
  {
    v5 = 0;
    do
    {
      if ( V_CobFilesIndex_stru_9A254.cobfiles[v5] - 1 == a1->index )
      {
        v4 = V_CobFilesIndex_stru_9A254.coblengths[v5];
      }
      ++v5;
    }
    while ( v5 < V_CobFilesIndex_stru_9A254.cobindex );
  }
  return v4 - V_CobFilesIndex_stru_9A254.flengths[index];
}

//----- (0001BEA0) --------------------------------------------------------
int __fastcall sub_1BEA0(int *a1)
{
  int v2; // eax
  int v3; // ebx
  int v4; // ecx

  v2 = tell(*a1);
  v3 = v2;
  if ( v2 != 0xFFFFFFFF )
  {
    v4 = a1[0x42];
    if ( v4 != 0xFFFFFFFF )
    {
      return v2 - V_CobFilesIndex_stru_9A254.flengths[v4];
    }
  }
  return v3;
}

//----- (0001BECC) --------------------------------------------------------
int __fastcall sub_1BECC(int *a1, int offset, int a3)
{
  int v3; // esi
  int v4; // ecx

  if ( a1[0x44] && a3 != 0xFFFFFFFF )
  {
    return offset + a1[0x43];
  }
  v3 = a1[0x42];
  v4 = offset;
  if ( v3 != 0xFFFFFFFF )
  {
    v4 = offset + V_CobFilesIndex_stru_9A254.flengths[v3];
  }
  return lseek(*a1, v4, 0);
}

//----- (0001BF0C) --------------------------------------------------------
int __fastcall sub_1BF0C(int *a1, int a2)
{
  return lseek(*a1, a2, 1);
}

//----- (0001BF1C) --------------------------------------------------------
void *__fastcall sub_1BF1C(T_Type1 *a1, void *a2)
{
  void *v3; // ecx
  int v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // ebp
  void *v7; // eax
  void *result; // eax

  v3 = a2;
  if ( a1->fh != 0xFFFFFFFF )
  {
    v4 = sub_1BE28(a1);
    v5 = v4;
    v6 = 0;
    if ( v4 > 0 )
    {
      if ( !a2 )
      {
        v7 = operator new[](v4);
        result = sub_2625C(v7, 5, "CFILE LOAD");
        v3 = result;
        if ( !result )
        {
          return result;
        }
        v6 = 0xFFFFFFFF;
      }
      if ( sub_1BF94(a1, v3, v5) == v5 )
      {
        return v3;
      }
      if ( v6 == 0xFFFFFFFF )
      {
        sub_2627C(v3);
      }
      operator delete[](v3);
      _get_errno_ptr();
    }
  }
  return 0;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0001BF94) --------------------------------------------------------
int __fastcall sub_1BF94(P_Type1 a1, void *aBuf, unsigned int aLen)
{
  int index; // esi
  int v5; // esi
  unsigned int v6; // eax

  index = a1->index;
  if ( index != 0xFFFFFFFF )
  {
    v5 = tell(a1->fh) - V_CobFilesIndex_stru_9A254.flengths[index];
    v6 = sub_1BE28(a1);
    if ( v5 + aLen > v6 )
    {
      aLen = v6 - v5;
    }
  }
  return read(a1->fh, aBuf, aLen);
}

//----- (0001BFD4) --------------------------------------------------------
unsigned int __fastcall sub_1BFD4(int *a1, void *buf, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v7; // ebp
  void *v8; // ebx
  unsigned int v9; // edx
  unsigned int result; // eax
  unsigned int i; // ecx
  unsigned int v12; // edx
  unsigned int v14; // [esp+4h] [ebp-1Ch]
  unsigned int len; // [esp+Ch] [ebp-14h]
  int v17; // [esp+10h] [ebp-10h]

  v7 = 0;
  len = a3 / a4;
  v17 = 0;
  v14 = a4 - 1;
  if ( a4 == 1 )
  {
LABEL_9:
    result = read(*a1, buf, a3 - v17);
    if ( result != 0xFFFFFFFF )
    {
      v17 += result;
      ((void (*)(void))a5)();
      return v17;
    }
  }
  else
  {
    while ( 1 )
    {
      result = read(*a1, buf, len);
      if ( result == 0xFFFFFFFF )
      {
        break;
      }
      v17 += result;
      if ( result < len )
      {
        for ( i = v7; i < a4; ((void (__fastcall *)(unsigned int, unsigned int, _DWORD, unsigned int))a5)(a4, v12, 0, i) )
        {
          v12 = i++;
        }
        return v17;
      }
      v8 = buf;
      v9 = v7++;
      buf = (char *)buf + result;
      ((void (__fastcall *)(unsigned int, unsigned int, void *, unsigned int))a5)(a4, v9, v8, v14);
      if ( v7 >= v14 )
      {
        goto LABEL_9;
      }
    }
  }
  return result;
}

//----- (0001C098) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __fastcall sub_1C098(unsigned int count, int a2, unsigned int a3)
{
  unsigned int v4; // edi
  int v5; // esi
  int v6; // eax
  unsigned int result; // eax
  const void far *v8; // [esp-Ch] [ebp-30h] BYREF
  int *v9; // [esp-4h] [ebp-28h]
  unsigned int *v10; // [esp+0h] [ebp-24h]
  int v11; // [esp+4h] [ebp-20h]
  unsigned int v12; // [esp+Ch] [ebp-18h]
  int v13; // [esp+10h] [ebp-14h]

  v9 = (int *)count;
  v4 = a3;
  if ( !a3 )
  {
    return v12;
  }
  while ( 1 )
  {
    v5 = v4 <= 0xFFF0 ? v4 : 0xFFF0;
    LODWORD(v8) = (char *)&v8 + 4;
    v6 = *v9;
    v11 = v5;
    result = dos_write(v6, v8, (unsigned int)v9, v10);
    v12 = result;
    if ( result )
    {
      break;
    }
    if ( v5 != v11 )
    {
      _assert(0, "chunksize==byteswritten", "..\\cfile.cpp", 0x244);
    }
    a2 += v13;
    v4 -= v13;
    if ( !v4 )
    {
      return v12;
    }
  }
  return result;
}
// 1C10A: positive sp value C has been found

//----- (0001C278) --------------------------------------------------------
void __fastcall Q_CFILE_CPP_IndexOneCob_sub_1C278(P_CobFilesIndex a1, char *CobFileName)
{
  int cobindex; // ebx
  int fh; // edi MAPDST
  int files; // edx
  int files_new; // esi
  int buf[6]; // [esp+0h] [ebp-18h] BYREF

  if ( a1->cobindex >= 5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cfile.cpp", 0x28C);
  }
  cobindex = a1->cobindex;
  if ( cobindex < 5 )
  {
    strncpy(a1->cobnames[cobindex], CobFileName, 50u);
    fh = open(CobFileName, O_BINARY);
    if ( fh != 0xFFFFFFFF )
    {
      a1->coblengths[a1->cobindex] = filelength(fh);
      read(fh, buf, 4u);
      if ( 0x1F4 - a1->files < buf[0] )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cfile.cpp", 0x2A0);
      }
      files = a1->files;
      if ( 0x1F4 - files >= buf[0] )
      {
        read(fh, a1->fnames[files], 50 * buf[0]);
        read(fh, &a1->flengths[a1->files], 4 * buf[0]);
        close(fh);
        files_new = buf[0] + a1->files;
        a1->cobfiles[a1->cobindex] = files_new;
        a1->files = files_new;
        ++a1->cobindex;
      }
    }
  }
}

//----- (0001C3C4) --------------------------------------------------------
void __fastcall Q_CobCfgLoad_sub_1C3C4(P_CobFilesIndex a1)
{
  FILE *v2; // ecx
  char v3[100]; // [esp+0h] [ebp-64h] BYREF

  v2 = fopen("cob.cfg", "r");
  if ( v2 )
  {
    while ( fscanf(v2, "%s", v3) != 0xFFFFFFFF )
    {
      Q_CFILE_CPP_IndexOneCob_sub_1C278(a1, v3);
    }
    fclose(v2);
  }
}
// 1C3C4: using guessed type char anonymous_0[100];

//----- (0001C410) --------------------------------------------------------
void func(void)
{
  sub_26160();
  sub_7501C();
}

//----- (0001C424) --------------------------------------------------------
int __fastcall main(int argc, char *argv[])
{
  clock_t v3; // edx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char v6; // al
  char v7; // al
  char *v8; // eax
  int v9; // eax
  int v10; // edx
  char *v11; // eax
  char *v12; // eax
  BOOL v13; // edx
  char *v14; // edi
  char *v15; // esi
  char v16; // al
  char v17; // al
  char v18; // cf
  bool v19; // zf
  char v20; // sf
  char v21; // of
  int v22; // eax
  char *v23; // eax
  char *v24; // ebx
  int v25; // ebx
  FILE *v26; // eax
  const char *v27; // edx
  FILE *v28; // eax
  char *v29; // edi
  char *v30; // esi
  char v31; // al
  char v32; // al
  unsigned int v33; // eax
  FILE *v34; // eax
  FILE *v35; // edi
  int v36; // esi
  int v37; // edx
  int v38; // ebx
  char *v39; // edx
  int result; // eax
  int v41; // [esp-4h] [ebp-574h]
  int v42; // [esp-4h] [ebp-574h]
  RGB v43[256]; // [esp+0h] [ebp-570h] BYREF
  T_Type1 v1Type1; // [esp+300h] [ebp-270h] BYREF
  T_Type1 a1; // [esp+418h] [ebp-158h] BYREF
  char v46; // [esp+530h] [ebp-40h] BYREF
  int v47; // [esp+542h] [ebp-2Eh] BYREF
  char var28; // [esp+548h] [ebp-28h] BYREF
  _WORD v49[3]; // [esp+54Ah] [ebp-26h] BYREF
  unsigned int seed; // [esp+550h] [ebp-20h] BYREF
  int v51; // [esp+554h] [ebp-1Ch]
  char **__attribute__((__org_arrdim(0,0))) v48; // [esp+558h] [ebp-18h]

  v48 = argv;
  v3 = clock();
  printf("\nAscendancy\nCopyright (c) 1995 The Logic Factory, Inc.\nAll rights reserved\n");
  while ( clock() - v3 < 0xFA )
  {
    ;
  }
  v4 = "Thank you for playing Ascendancy.";
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAB);// 171: "Thank you for playing Ascendancy."
  do
  {
    v6 = *sub_1CEA8;
    *v4 = *sub_1CEA8;
    if ( !v6 )
    {
      break;
    }
    v7 = sub_1CEA8[1];
    sub_1CEA8 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  atexit(func);
  if ( argc > 1 && *v48[1] == 'v' )
  {
    v41 = off_964E0;
    v8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAC);     // 172: "\n\nAscendancy version %s\n\n"
    printf(v8, v41);
    getch();
  }
  v51 = 0;
  if ( argc > 1 && *v48[1] == 'u' )
  {
    v51 = 0xFFFFFFFF;
  }
  v9 = Q_CheckFreeMemory_sub_53DEC();
  v10 = v9;
  if ( argc > 1 && *v48[1] == 'm' )
  {
    v42 = v9;
    v11 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAD);    // 173: "\n\nFree memory: %ld\n\n"
    printf(v11, v42);
    getch();
  }
  if ( v10 < 0x300000 )
  {
    v12 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAE);    // 174: "Your computer does not have enough free extended memory to run\n
                                                       // Ascendancy.  You will need an additional %ldK bytes of free extended memory."
    sprintf(
      "Thank you for playing Ascendancy.",
      v12,
      ((0x300000 - v10 - (__CFSHL__((0x300000 - v10) >> 0x1F, 0xA) + ((0x300000 - v10) >> 0x1F << 0xA))) >> 0xA) + 1);
    exit(1);
  }
  Q_InitFileInfo_sub_1BB78(&v1Type1);
  v13 = Q_CfilePreload_sub_1BBFC(&v1Type1, "data\\theme00.raw", O_BINARY, 0);
  Q_CloseFile_sub_1BE00(&v1Type1);
  if ( v13 )
  {
    v14 = "Thank you for playing Ascendancy.";
    v15 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAF);    // 175: "Please place the Ascendancy CD in your CDROM drive."
    do
    {
      v16 = *v15;
      *v14 = *v15;
      if ( !v16 )
      {
        break;
      }
      v17 = v15[1];
      v15 += 2;
      v14[1] = v17;
      v14 += 2;
    }
    while ( v17 );
    exit(1);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v1Type1);
  LOWORD(v22) = sub_53D22(v18, v19, v20, v21, 0, 0x101);
  if ( (!v22 || v51 == 0xFFFFFFFF) && !sub_75098(v22, 0, 0, O_BINARY, ".\\", 1) )
  {
    v23 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xB0);    // 176: "\n\nAscendancy was unable to find VESA support for your\n
                                                       // video card.  To configure the VESA driver that comes with\n
                                                       // Ascendancy, run the UVCONFIG program in this directory, and\n
                                                       // then try running Ascendancy again.  If this solution does\n
                                                       // not work, you may have to install the VESA driver supplied\n
                                                       // with your video card.  Consult your video card documentation\n
                                                       // for further information."
    printf(v23);
    s[0] = 0;
    exit(1);
  }
  if ( !sub_2BD88(&V_Type6_stru_D8654, "DATA", "VESA480.DLL") )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\corn.cpp", 0x9B);
  }
  VFX_area_wipe(0, 0, 0x27F, 0x1DF, 0);
  sub_2C158(&V_Type6_stru_D8654, "data\\logo.pal", 0, 0x100u);
  memset(v43, 0, sizeof(v43));
  sub_2C224(&V_Type6_stru_D8654, 0, 0x100, v43);
  Q_InitFileInfo_sub_1BB78(&a1);
  Q_CfilePreload_sub_1BBFC(&a1, "data\\logo.gif", O_BINARY, 0);
  v24 = &byte_D8DA0[sub_1BE28(&a1)];
  sub_1BF1C(&a1, byte_D8DA0);
  sub_60DF1(&V_Type6_stru_D8654.pane, (int)byte_D8DA0, (int)v24);
  VFX_pane_refresh(&V_Type6_stru_D8654.pane, 0, 0, 0x27F, 0x1DF);
  sub_615ED(&V_Type6_stru_D8654, (int)&V_Type6_stru_D8654.z3[0x303], 0x19u);
  v25 = FALSE;
  if ( Q_StartSoundSystem_sub_4EFB0((int)&unk_10914C, TRUE, FALSE) )
  {
    if ( dword_109357 == 0xFFFFFFFF && !sub_4F65C((int)&unk_10914C, "music.txt") )
    {
      v25 = 0xBB;
      Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xBB);
    }
  }
  else
  {
    sub_4FF08((int)&unk_10914C);
  }
  v26 = fopen("nougat.lf", "r");
  if ( v26 )
  {
    dword_A0CFC = 0xFFFFFFFF;
    fclose(v26);
  }
  v27 = "r";
  v28 = fopen("flash.pop", "r");
  if ( v28 )
  {
    dword_A0D00 = 0xFFFFFFFF;
    fclose(v28);
  }
  if ( heapchk() )
  {
    v25 = 0xD8;
    v27 = "..\\corn.cpp";
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xD8);
  }
  if ( sub_545EC(&V_Type3_stru_10AE70) != 0xFFFFFFFF )
  {
    v25 = 0xE1;
    v27 = "..\\corn.cpp";
    Q_AssertLogBreakExit_sub_261A8(0, "..\\corn.cpp", 0xE1);
  }
  if ( heapchk() )
  {
    v25 = 0xE3;
    v27 = "..\\corn.cpp";
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xE3);
  }
  if ( !sub_2633C() )
  {
    v29 = "Thank you for playing Ascendancy.";
    v30 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xB1);    // 177: "Ascendancy could not find a mouse driver.  Please make sure your\n
                                                       // mouse driver is loaded, and then run Ascendancy again."
    do
    {
      v31 = *v30;
      *v29 = *v30;
      if ( !v31 )
      {
        break;
      }
      v32 = v30[1];
      v30 += 2;
      v29[1] = v32;
      v29 += 2;
    }
    while ( v32 );
    exit(1);
  }
  sub_2C744(&V_Type6_stru_D8654, (int)v27, v25, 0);
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xEE);
  }
  v33 = time(0);
  srand(v33);
  sub_1CF14(0);
  v34 = fopen("cosmos.txt", "r");
  v35 = v34;
  if ( v34 )
  {
    fscanf(v34, "%s %d %s %d %s %d", &v46, (char *)&v47 + 2, &v46, &v49[1], &v46, &seed);
    v36 = 0;
    if ( seed != 0xFFFFFFFF )
    {
      srand(seed);
    }
    sub_1E10C((int)dword_A2F6C, SHIWORD(v47), v49[1], 0);
    sub_1F404((int)dword_A2F6C);
    v37 = 0;
    while ( fscanf(v35, "%d", &var28) != 0xFFFFFFFF && v36 < *(int *)&v49[1] )
    {
      v37 += 0x1EE;
      ++v36;
      V_StaticStrings_dword_A0D04.buffer[v37 + 0x1D61] = var28;
    }
    fclose(v35);
  }
  else
  {
    sub_1E10C((int)dword_A2F6C, 0x32, 7, 0);
    sub_1F404((int)dword_A2F6C);
  }
  sub_1EE08((int)dword_A2F6C, 0);
  if ( access("resume.gam", 0) )
  {
    sub_1F038((int)dword_A2F6C);
  }
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x300A] = &V_Type6_stru_D8654;
  sub_575BC(&V_Type3_stru_10AE70);
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x11F);
  }
  sub_1EEA4((int)dword_A2F6C);
  sub_574F0(&V_Type3_stru_10AE70, 0, (int)sub_1CC94);
  sub_574F0(&V_Type3_stru_10AE70, 1, (int)sub_5A320);
  sub_57510((int)&V_Type3_stru_10AE70, 1, (int)sub_22468);
  sub_574F0(&V_Type3_stru_10AE70, 2, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 3, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 4, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 7, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 8, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 9, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xA, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xC, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xD, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xE, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xF, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0x10, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0x12, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0x14, (int)sub_5A320);
  sub_59828((int)&V_Type3_stru_10AE70, 0x14, (int)sub_5A320, 0);
  sub_615ED(&V_Type6_stru_D8654, (int)v43, 0x32u);
  dword_132B60 = 0xFFFFFFFF;
  VFX_area_wipe(0, 0, 0x27F, 0x1DF, 0);
  sub_2C158(&V_Type6_stru_D8654, "DATA\\game.pal", 0, 0x100u);
  sub_2C224(&V_Type6_stru_D8654, 0, 0x100, v43);
  v38 = 0xFFFFFFFF;
  v39 = 0;
  sub_56E9C(&V_Type3_stru_10AE70, 0, 0xFFFFFFFF);
  if ( heapchk() )
  {
    v38 = 0x146;
    v39 = "..\\corn.cpp";
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x146);
  }
  if ( argc == 4 )
  {
    v38 = 0;
    v39 = v48[3];
    if ( sub_59988(&V_Type3_stru_10AE70, v39, 0) != 0xFFFFFFFF )
    {
      v38 = 0x14C;
      v39 = "..\\corn.cpp";
      Q_AssertLogBreakExit_sub_261A8(0, "..\\corn.cpp", 0x14C);
    }
  }
  sub_64ECA();
  while ( dword_96774 == 0xFFFFFFFF )
  {
    if ( V_Type3_stru_10AE70.bbb == 0xFFFFFFFF )
    {
      sub_59B80((int)&V_Type3_stru_10AE70);
    }
    else
    {
      sub_2656C((__int16)&unk_D85F8);
    }
    sub_5469C(&V_Type3_stru_10AE70, (int)v39, v38, (int)v43);
    sub_5508C(&V_Type3_stru_10AE70);
    if ( V_Type3_stru_10AE70.bbb )
    {
      sub_59A54((int)&V_Type3_stru_10AE70);
    }
  }
  sub_5989C(&V_Type3_stru_10AE70, (int)v39, v38, (int)v43);
  sub_54048("resume.gam", 0, v38, (int)v43);
  result = (int)&a1;
  Q_CloseFileAndDelete_sub_1BBC8(&a1);
  return result;
}
// 1CC7C: returning address of temporary local variable '%a1'
// 1C5DC: variable 'v18' is possibly undefined
// 1C5DC: variable 'v19' is possibly undefined
// 1C5DC: variable 'v20' is possibly undefined
// 1C5DC: variable 'v21' is possibly undefined
// 1C5E6: variable 'v22' is possibly undefined
// 96774: using guessed type int dword_96774;
// A0CFC: using guessed type int dword_A0CFC;
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// 109357: using guessed type int dword_109357;
// 132B60: using guessed type int dword_132B60;

//----- (0001CC94) --------------------------------------------------------
void sub_1CC94()
{
  void *v0; // edi
  void *v1; // esi
  T_Type1 v2; // [esp+0h] [ebp-128h] BYREF

  v0 = sub_262B0(0x502Eu, 1u, 1, "GIF SCRATCH");
  Q_InitFileInfo_sub_1BB78(&v2);
  Q_CfilePreload_sub_1BBFC(&v2, "DATA\\0OPENING.GIF", O_BINARY, 0);
  v1 = sub_1BF1C(&v2, 0);
  if ( !v1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x180);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v2);
  if ( v1 && v0 )
  {
    sub_60DF1(&V_Type6_stru_D8654.pane, (int)v1, (int)v0);
    sub_552CC(&V_Type3_stru_10AE70, 0);
  }
  sub_2627C(v1);
  operator delete(v1);
  sub_262CC(v0);
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0001CD3C) --------------------------------------------------------
int Q_CORN_CPP_StaticTxtLoad_sub_1CD3C()
{
  FILE *fp; // edi
  char *pText; // esi
  char *pLetter; // ecx
  unsigned int v3; // ebp
  char letter; // dl
  int count; // eax
  char v6; // bh
  char line[201]; // [esp+1h] [ebp-E5h] BYREF
  int endOfFile; // [esp+CAh] [ebp-1Ch]

  fp = sub_1BB10("static.txt", 0);
  if ( !fp )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1A0);
  }
  pText = V_StaticStrings_dword_A0D04.buffer;
  V_StaticStrings_dword_A0D04.count = 0;
  endOfFile = 0;
  do
  {
    if ( V_StaticStrings_dword_A0D04.count >= 200 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1AE);
    }
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(fp, &line[1]);
    if ( !stricmp(&line[1], "end\n") )
    {
      endOfFile = 0xFFFFFFFF;
      continue;
    }
    if ( line[1] == '"' )
    {
      pLetter = &line[1];
      v3 = 0;
      V_StaticStrings_dword_A0D04.index[V_StaticStrings_dword_A0D04.count] = pText;
      do
      {
        ++pLetter;
        if ( pText - V_StaticStrings_dword_A0D04.buffer >= 8000 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1C6);
        }
        letter = *pLetter;
        if ( *pLetter == '"' )
        {
          v3 = 0xFFFFFFFF;
          count = V_StaticStrings_dword_A0D04.count;
          *pText++ = 0;
          V_StaticStrings_dword_A0D04.count = count + 1;
        }
        else if ( letter != '\n' )
        {
          if ( letter )
          {
            if ( letter != '\\' )
            {
              *pText++ = letter;
              continue;
            }
            v6 = *++pLetter;
            if ( v6 == 'n' )
            {
              *pText++ = '\n';
              continue;
            }
            if ( v6 )
            {
              *pText++ = v6;
              continue;
            }
          }
          pLetter = line;
          fgets(&line[1], 200, fp);
        }
      }
      while ( !v3 );
    }
  }
  while ( !endOfFile );
  V_StaticStrings_dword_A0D04.loaded = 0xFFFFFFFF;
  return fclose(fp);
}

//----- (0001CEA8) --------------------------------------------------------
char *__fastcall Q_CORN_CPP_StaticTxtRead_sub_1CEA8(int aTextIndex)
{
  if ( !V_StaticStrings_dword_A0D04.loaded )
  {
    Q_CORN_CPP_StaticTxtLoad_sub_1CD3C();
  }
  if ( aTextIndex < 0 || aTextIndex >= V_StaticStrings_dword_A0D04.count )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1F3);
  }
  return V_StaticStrings_dword_A0D04.index[aTextIndex];
}

//----- (0001CEF0) --------------------------------------------------------
int sub_1CEF0()
{
  int result; // eax

  _wcpp_2_mod_register_(&unk_964E4);
  result = sub_1DE64((int)dword_A2F6C);
  dword_964EC = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 964EC: using guessed type int dword_964EC;
// A2F6C: using guessed type int dword_A2F6C[];

//----- (0001CF14) --------------------------------------------------------
unsigned __int8 __fastcall sub_1CF14(unsigned __int8 result)
{
  unsigned __int8 v1; // dh
  char v2; // dl

  if ( result == 0xFF )
  {
    v1 = 0;
    v2 = 0xFF;
  }
  else
  {
    v1 = result;
    v2 = 1 << result;
  }
  LOBYTE(byte_104BEA) = v1;
  byte_968DC = v2;
  return result;
}
// 968DC: using guessed type char byte_968DC;

//----- (0001CF40) --------------------------------------------------------
_DWORD *__fastcall sub_1CF40(_DWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

//----- (0001CF68) --------------------------------------------------------
int __fastcall sub_1CF68(int a1, int a2)
{
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  float *v8; // edx
  double v9; // st7
  int v11[3]; // [esp+8h] [ebp-A4h] BYREF
  int v12[3]; // [esp+14h] [ebp-98h] BYREF
  float v13; // [esp+20h] [ebp-8Ch]
  float v14; // [esp+24h] [ebp-88h]
  float v15; // [esp+28h] [ebp-84h]
  float v16; // [esp+2Ch] [ebp-80h]
  int v17; // [esp+30h] [ebp-7Ch]
  int v18; // [esp+34h] [ebp-78h]
  float v19; // [esp+38h] [ebp-74h]
  float v20; // [esp+3Ch] [ebp-70h]
  float v21; // [esp+40h] [ebp-6Ch]
  float v22; // [esp+44h] [ebp-68h]
  float v23; // [esp+48h] [ebp-64h]
  float v24; // [esp+4Ch] [ebp-60h]
  float v25; // [esp+50h] [ebp-5Ch]
  float v26; // [esp+54h] [ebp-58h]
  float v27; // [esp+58h] [ebp-54h]
  float v28; // [esp+5Ch] [ebp-50h] BYREF
  float v29; // [esp+60h] [ebp-4Ch]
  float v30; // [esp+64h] [ebp-48h]
  int v31[3]; // [esp+68h] [ebp-44h] BYREF
  float v32; // [esp+74h] [ebp-38h]
  int v33; // [esp+78h] [ebp-34h]
  int v34; // [esp+7Ch] [ebp-30h]
  int *v35; // [esp+80h] [ebp-2Ch]
  int *v36; // [esp+88h] [ebp-24h]
  int *v37; // [esp+8Ch] [ebp-20h]
  int *v38; // [esp+90h] [ebp-1Ch]
  float v39; // [esp+98h] [ebp-14h]

  v4 = *(__int16 *)(a1 + 0x44);
  if ( v4 < 0 || v4 >= 6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7F);
  }
  v5 = *(__int16 *)(a2 + 0x44);
  if ( v5 < 0 || v5 >= 6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x81);
  }
  v6 = 0;
  if ( *(_WORD *)(a1 + 0x44) != word_9652E[*(_DWORD *)a1] && *(_WORD *)(a2 + 0x44) != word_9652E[*(_DWORD *)a2] )
  {
    v7 = sub_205A0((int)&dword_A2F6C, a1, a2);
    v8 = (float *)v7;
    v6 = v7;
    if ( v7 )
    {
      *(_DWORD *)(a1 + 4 * (__int16)(*(_WORD *)(a1 + 0x44))++ + 0x2C) = v7;
      *(_DWORD *)(a2 + 4 * (__int16)(*(_WORD *)(a2 + 0x44))++ + 0x2C) = v7;
      v19 = 0.0;
      v20 = 0.0;
      v21 = 0.0;
      v22 = *(float *)(a2 + 8);
      v23 = *(float *)(a2 + 0xC);
      v24 = *(float *)(a2 + 0x10);
      v13 = 0.0;
      v14 = 0.0;
      v15 = 0.0;
      v35 = v11;
      v13 = v22 - *(float *)(a1 + 8);
      v14 = v23 - *(float *)(a1 + 0xC);
      v15 = v24 - *(float *)(a1 + 0x10);
      *(float *)v11 = v13;
      *(float *)&v11[1] = v14;
      *(float *)&v11[2] = v15;
      v22 = v13;
      v23 = v14;
      v24 = v15;
      v9 = sqrt(v14 * v14 + v13 * v13 + v15 * v15);
      v36 = v12;
      v32 = v22 * (1.0 / v9);
      *(float *)v12 = v32;
      *(float *)&v33 = v23 * (1.0 / v9);
      v12[1] = v33;
      *(float *)&v34 = 1.0 / v9 * v24;
      v12[2] = v34;
      v39 = v9 * flt_90A84;
      v22 = v32;
      v23 = *(float *)&v33;
      v39 = v39 * flt_90A88 + flt_90A8C;
      v24 = *(float *)&v34;
      v16 = v32 * v39;
      v37 = v31;
      *(float *)&v17 = *(float *)&v33 * v39;
      *(float *)v31 = v16;
      *(float *)&v18 = *(float *)&v34 * v39;
      v31[1] = v17;
      v31[2] = v18;
      v19 = v16;
      v20 = *(float *)&v17;
      v21 = *(float *)&v18;
      v8[2] = v16;
      v8[3] = v20;
      v8[4] = v21;
      v25 = -v19;
      v38 = (int *)&v28;
      v26 = -v20;
      v28 = v25;
      v27 = -v21;
      v29 = v26;
      v30 = v27;
      v8[5] = v25;
      v8[6] = v29;
      v8[7] = v30;
    }
  }
  return v6;
}
// 90A84: using guessed type float flt_90A84;
// 90A88: using guessed type float flt_90A88;
// 90A8C: using guessed type float flt_90A8C;
// 9652E: using guessed type __int16 word_9652E[];
// A2F6C: using guessed type int dword_A2F6C;

//----- (0001D234) --------------------------------------------------------
__int16 __fastcall sub_1D234(int a1, int a2, __int16 a3)
{
  int v5; // eax
  __int16 v6; // bx
  __int16 v7; // ax
  int v8; // ebx
  int v9; // edx
  char v10; // bh
  char *v11; // ecx
  __int16 v13; // [esp+2h] [ebp-10h]

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB3);
  }
  if ( a3 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB4);
  }
  if ( *(unsigned __int8 *)(a2 + 0x57) == a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB5);
  }
  if ( *(unsigned __int8 *)(a2 + 0x57) == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB7);
  }
  v13 = *(unsigned __int8 *)(a2 + 0x57);
  v5 = *(unsigned __int8 *)(a2 + 0x57);
  if ( v5 != 0xFF )
  {
    if ( a3 == 0xFFFFFFFF )
    {
      *(_BYTE *)(a2 + 0x57) = 0xFF;
    }
    else
    {
      *(_BYTE *)(a2 + 0x57) = a3;
      *(_BYTE *)(a1 + 0x14) |= 1 << a3;
    }
    v6 = *(_WORD *)(a1 + 0x5A);
    v7 = 0;
    *(_BYTE *)(a1 + 0x14) &= ~(1 << v13);
    if ( v6 > 0 )
    {
      while ( *(unsigned __int8 *)(*(_DWORD *)(a1 + 4 * v7 + 0x46) + 0x57) != v13 )
      {
        if ( ++v7 >= *(__int16 *)(a1 + 0x5A) )
        {
          goto LABEL_18;
        }
      }
      *(_BYTE *)(a1 + 0x14) |= 1 << v13;
    }
LABEL_18:
    LOWORD(v5) = v13;
    v8 = *(int *)((char *)&dword_A2F79 + 0x1EE * v13);
    if ( a1 == v8 )
    {
      v9 = *(unsigned __int8 *)(v8 + 0x14);
      v5 = 1 << v13;
      if ( ((1 << v13) & v9) == 0 )
      {
        *(_BYTE *)(a1 + 0x14) = v9 & 0x7F;
      }
    }
  }
  v10 = *(_BYTE *)(a2 + 0x54);
  if ( v10 != (char)0xFF )
  {
    if ( v10 == 0x17 )
    {
      v11 = sub_35A70(a2, *(_WORD *)(a2 + 0x52));
      if ( v13 != *((_WORD *)v11 + 0x2B) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xE0);
      }
      sub_49940((int)v11);
    }
    v5 = *(unsigned __int16 *)(a2 + 0x52);
    if ( (unsigned __int16)v5 != 0xFFFF && *(_BYTE *)(a2 + 0x54) != 0x23 )
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 0x10) + 4 * v5 + 1) = 0xFF;
      v5 = *(unsigned __int16 *)(a2 + 0x52);
      *(_WORD *)(*(_DWORD *)(a2 + 0x10) + 4 * v5 + 2) = 0;
    }
    *(_BYTE *)(a2 + 0x54) = 0xFF;
    *(_WORD *)(a2 + 0x50) = 0;
    *(_WORD *)(a2 + 0x52) = 0xFFFF;
  }
  return v5;
}
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001D3E8) --------------------------------------------------------
unsigned int __fastcall sub_1D3E8(int a1, int a2, int a3)
{
  char v5; // ah
  float *v6; // eax
  int i; // edx
  int v8; // eax
  float v10; // [esp+0h] [ebp-1Ch] BYREF
  float v11; // [esp+4h] [ebp-18h]
  float v12; // [esp+8h] [ebp-14h]
  int v13; // [esp+Ch] [ebp-10h]

  if ( a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xFD);
  }
  v5 = *(_BYTE *)(a2 + 0x58);
  if ( v5 == 5 )
  {
    v6 = *(float **)(a2 + 0x59);
    v10 = 0.0;
    v11 = 0.0;
    v12 = 0.0;
    if ( a1 == *(_DWORD *)v6 )
    {
      v10 = v6[2];
      v11 = v6[3];
      v12 = v6[4];
    }
    else if ( a1 == *((_DWORD *)v6 + 1) )
    {
      v10 = v6[5];
      v11 = v6[6];
      v12 = v6[7];
    }
    else
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0x10A);
    }
    v11 = v11 + flt_90AF2;
    v12 = (double)(rand() % 0xC8) + v12;
    v13 = rand() % 0xC8;
    v10 = (double)v13 + v10;
    sub_496BC(a2, &v10);
    *(_BYTE *)(a2 + 0x58) = 4;
  }
  else if ( v5 != 4 )
  {
    goto LABEL_12;
  }
  *(_DWORD *)(a2 + 0x59) = a1;
LABEL_12:
  *(_BYTE *)(a1 + 0x15) |= 1 << *(_BYTE *)(a2 + 0x56);
  *(_BYTE *)(a1 + 0x17) |= 1 << *(_BYTE *)(a2 + 0x56);
  for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x44); ++i )
  {
    v8 = *(_DWORD *)(a1 + 4 * (__int16)i + 0x2C);
    *(_BYTE *)(v8 + 0x20) |= 1 << *(_BYTE *)(a2 + 0x56);
    *(_BYTE *)(*(_DWORD *)v8 + 0x16) |= 1 << *(_BYTE *)(a2 + 0x56);
    *(_BYTE *)(*(_DWORD *)(v8 + 4) + 0x16) |= 1 << *(_BYTE *)(a2 + 0x56);
  }
  return 0xFFFFFFFF;
}
// 90AF2: using guessed type float flt_90AF2;

//----- (0001D538) --------------------------------------------------------
unsigned int __fastcall sub_1D538(int a1, int a2)
{
  char v4; // ah
  int v5; // edx
  int v6; // esi
  unsigned int v7; // ebp
  __int16 i; // dx
  int v9; // eax
  int v11[107]; // [esp+0h] [ebp-1C4h] BYREF
  int v12; // [esp+1ACh] [ebp-18h]

  LOWORD(v12) = *(_WORD *)(a2 + 0x56);
  if ( (v12 & 0x8000u) != 0 || (__int16)v12 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x139);
  }
  v4 = *(_BYTE *)(a2 + 0x58);
  if ( (v4 == 3 || v4 == 1 || v4 == 2) && !sub_35C38(*(_DWORD *)(a2 + 0x59), a2) )
  {
    v5 = *(__int16 *)(*(_DWORD *)(a2 + 0x59) + 0xC);
    *(_BYTE *)(a2 + 0x58) = 4;
    *(_DWORD *)(a2 + 0x59) = &word_A3D21[0x30 * v5];
  }
  if ( *(_BYTE *)(a2 + 0x58) != 4 || a1 != *(_DWORD *)(a2 + 0x59) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x149);
  }
  v6 = sub_1D794((__int16 *)a1, v11);
  if ( v6 <= 0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0x14E);
  }
  v7 = 0xFFFFFFFF;
  for ( i = 0; i < v6; ++i )
  {
    v9 = v11[i];
    if ( *(_WORD *)(v9 + 0x56) == (_WORD)v12 && v9 != a2 && *(_BYTE *)(v9 + 0x58) != 1 )
    {
      v7 = 0;
      break;
    }
  }
  if ( v7 == 0xFFFFFFFF )
  {
    *(_BYTE *)(a1 + 0x15) &= ~(1 << v12);
  }
  return 0xFFFFFFFF;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// 1D538: using guessed type int var_1C4[107];

//----- (0001D654) --------------------------------------------------------
int __fastcall sub_1D654(__int16 *a1, int a2, int a3)
{
  int result; // eax
  __int16 v5; // si
  int v6; // ecx
  int v7[107]; // [esp+0h] [ebp-1C4h] BYREF
  int v8; // [esp+1ACh] [ebp-18h]
  int v9; // [esp+1B0h] [ebp-14h]

  v9 = a3;
  if ( !a2 || !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x16C);
  }
  result = sub_1D794(a1, v7);
  v5 = 0;
  v8 = result;
  while ( v5 < v8 )
  {
    v6 = v7[v5];
    result = *(__int16 *)(v6 + 0x56);
    if ( result == (unsigned __int8)byte_104BEA )
    {
      sub_1D538((int)a1, v6);
      *(_DWORD *)(v6 + 0x59) = v9;
      *(_BYTE *)(v6 + 0x58) = 5;
      result = sub_1D3E8(a2, v6, 0);
    }
    ++v5;
  }
  return result;
}
// 1D654: could not find valid save-restore pair for ebx
// 1D654: using guessed type int var_1C4[107];

//----- (0001D734) --------------------------------------------------------
void __fastcall sub_1D734(int a1, int a2)
{
  int v3; // ebx
  __int16 v4; // ax
  int v5; // edx
  int v6; // ecx
  unsigned __int8 v7; // [esp+0h] [ebp-14h]

  v3 = 0;
  v7 = *(_BYTE *)(a1 + 0x14) | *(_BYTE *)(a1 + 0x15);
  v4 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    v5 = 0;
    do
    {
      if ( (v7 & (unsigned __int8)(1 << v4)) != 0 )
      {
        v6 = v5;
        ++v3;
        v5 += 2;
        *(_WORD *)(v6 + a2) = v4;
      }
      ++v4;
    }
    while ( v4 < SHIWORD(dword_A3CF2) );
  }
  JUMPOUT(0x1D78B);
}
// 1D789: control flows out of bounds to 1D78B
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001D794) --------------------------------------------------------
int __fastcall sub_1D794(__int16 *a1, _DWORD *a2)
{
  char *v2; // eax
  _DWORD *v3; // ebx
  int v4; // edi
  int v5; // esi
  __int16 i; // dx
  char v7; // cl

  v2 = (char *)&unk_CA1F1;
  v3 = a2;
  v4 = 0;
  v5 = 0;
  for ( i = 0; i < 0x6B && v5 < SHIWORD(dword_D35E5); ++i )
  {
    if ( *((__int16 *)v2 + 0x2B) != 0xFFFFFFFF )
    {
      if ( ((v7 = v2[0x58], ++v5, v7 == 3) || v7 == 1 || v7 == 2)
        && &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(v2 + 0x59) + 0xC)] == a1
        || v2[0x58] == 4 && a1 == *(__int16 **)(v2 + 0x59) )
      {
        if ( a2 )
        {
          *v3 = v2;
        }
        ++v3;
        ++v4;
      }
    }
    v2 += 0x162;
  }
  return v4;
}
// A3D21: using guessed type __int16 word_A3D21[];
// D35E5: using guessed type int dword_D35E5;

//----- (0001D834) --------------------------------------------------------
unsigned int __fastcall sub_1D834(int a1, __int16 a2)
{
  __int16 *v3; // ecx
  __int16 v4; // di
  int v5; // eax
  __int16 v6; // dx
  int v7; // eax
  __int16 v10; // [esp+6h] [ebp-18h]

  v3 = (__int16 *)&unk_CA1F1;
  v4 = 0;
  v10 = 0;
  while ( 1 )
  {
    if ( v4 >= 0x6B || v10 >= SHIWORD(dword_D35E5) )
    {
      return 0;
    }
    v5 = v3[0x2B];
    if ( v5 != 0xFFFFFFFF )
    {
      ++v10;
      if ( *((_BYTE *)v3 + 0x58) == 5
        && (byte_A3132[0x1EE * a2 + v5] == 2 || v5 == (unsigned __int8)byte_104BEA || a2 == v3[0x2B]) )
      {
        v6 = 0;
        if ( *(__int16 *)(a1 + 0x44) > 0 )
        {
          break;
        }
      }
    }
LABEL_2:
    ++v4;
    v3 += 0xB1;
  }
  while ( 1 )
  {
    v7 = a1 + 4 * v6;
    if ( *(_DWORD *)((char *)v3 + 0x59) == *(_DWORD *)(v7 + 0x2C)
      && (a1 == **(_DWORD **)(v7 + 0x2C) && (*(_DWORD *)(v3 + 0x51) & 0x7FFFFFFF) == 0
       || a1 == *(_DWORD *)(*(_DWORD *)(a1 + 4 * v6 + 0x2C) + 4) && *(_DWORD *)(v3 + 0x51) == 0x3F800000) )
    {
      return 0xFFFFFFFF;
    }
    if ( ++v6 >= *(__int16 *)(a1 + 0x44) )
    {
      goto LABEL_2;
    }
  }
}
// D35E5: using guessed type int dword_D35E5;

//----- (0001D920) --------------------------------------------------------
int *__fastcall sub_1D920(int a1, unsigned int count, int a3)
{
  int v4; // eax
  int *result; // eax
  int v6[5]; // [esp+0h] [ebp-70h] BYREF
  char v7; // [esp+14h] [ebp-5Ch]
  char v8; // [esp+15h] [ebp-5Bh]
  char v9; // [esp+16h] [ebp-5Ah]
  char v10; // [esp+17h] [ebp-59h]
  int v11; // [esp+18h] [ebp-58h]
  int v12; // [esp+1Ch] [ebp-54h]
  int v13; // [esp+20h] [ebp-50h]
  int v14; // [esp+24h] [ebp-4Ch]
  int v15; // [esp+28h] [ebp-48h]
  char v16[24]; // [esp+2Ch] [ebp-44h] BYREF
  _WORD v17[3]; // [esp+44h] [ebp-2Ch]
  int v18; // [esp+4Ah] [ebp-26h]
  int v19; // [esp+4Eh] [ebp-22h]
  int v20; // [esp+52h] [ebp-1Eh]
  int v21; // [esp+56h] [ebp-1Ah]
  _WORD v22[11]; // [esp+5Ah] [ebp-16h]

  if ( a3 != 0xFFFFFFFF )
  {
    return (int *)sub_1C098(count, a1, 0x60u);
  }
  sub_1CF40(v6);
  sub_1BF94((P_Type1)count, v6, 0x60u);
  *(_DWORD *)a1 = v6[0];
  *(_DWORD *)(a1 + 4) = v6[1];
  *(_DWORD *)(a1 + 8) = v6[2];
  *(_DWORD *)(a1 + 0xC) = v6[3];
  *(_DWORD *)(a1 + 0x10) = v6[4];
  *(_BYTE *)(a1 + 0x14) = v7;
  *(_BYTE *)(a1 + 0x15) = v8;
  *(_BYTE *)(a1 + 0x16) = v9;
  *(_BYTE *)(a1 + 0x17) = v10;
  *(_DWORD *)(a1 + 0x18) = v11;
  *(_DWORD *)(a1 + 0x1C) = v12;
  *(_DWORD *)(a1 + 0x20) = v13;
  *(_DWORD *)(a1 + 0x24) = v14;
  *(_DWORD *)(a1 + 0x28) = v15;
  qmemcpy((void *)(a1 + 0x2C), v16, 0x18u);
  *(_WORD *)(a1 + 0x44) = v17[0];
  *(_DWORD *)(a1 + 0x46) = *(_DWORD *)&v17[1];
  *(_DWORD *)(a1 + 0x4A) = v18;
  *(_DWORD *)(a1 + 0x4E) = v19;
  *(_DWORD *)(a1 + 0x52) = v20;
  *(_DWORD *)(a1 + 0x56) = v21;
  *(_WORD *)(a1 + 0x5A) = v22[0];
  v4 = *(_DWORD *)&v22[1];
  *(_WORD *)(a1 + 0x44) = 0;
  *(_DWORD *)(a1 + 0x5C) = v4;
  result = v6;
  *(_WORD *)(a1 + 0x5A) = 0;
  return result;
}
// 1D920: using guessed type _WORD var_16[11];

//----- (0001DA04) --------------------------------------------------------
int __fastcall sub_1DA04(int a1, int a2)
{
  int result; // eax

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x21A);
  }
  result = *(__int16 *)(a2 + 4);
  LOWORD(result) = (unsigned __int8)byte_D5D47[0x64 * *(__int16 *)(a1 + 4) + result];
  return result;
}

//----- (0001DA4C) --------------------------------------------------------
int __fastcall sub_1DA4C(int a1, __int16 a2, int a3, int a4)
{
  int v5; // ebx
  int *v6; // ecx
  int i; // edi
  int v8; // eax
  int v9; // edx
  int v10; // ecx

  if ( a2 > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x248);
  }
  if ( a4 >= 0x6B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x249);
  }
  v5 = 0;
  if ( ((1 << a2) & *(unsigned __int8 *)(a1 + 0x16)) == 0 )
  {
    return 0x2BC;
  }
  v6 = (int *)(a1 + 0x46);
  for ( i = 0; i < *(__int16 *)(a1 + 0x5A); ++i )
  {
    if ( *(unsigned __int8 *)(*v6 + 0x57) != a2 )
    {
      v5 += sub_364B4(*v6, a2);
    }
    ++v6;
  }
  v8 = 0;
  v9 = 0;
  while ( v8 < SHIWORD(dword_A3CF2) )
  {
    if ( v8 != a2 )
    {
      v10 = *(int *)((char *)&dword_A2F79 + v9);
      if ( a1 == v10 && (*(_BYTE *)(v10 + 0x14) & 0x80) != 0 && byte_A3132[0x1EE * a2 + v8] == 2 )
      {
        v5 = 3 * v5 + 0xC8;
      }
    }
    v9 += 0x1EE;
    ++v8;
  }
  if ( !*(_BYTE *)(a1 + 0x14) )
  {
    v5 *= 2;
  }
  if ( v5 < 0 )
  {
    v5 = 0;
  }
  if ( ((1 << a2) & *(unsigned __int8 *)(a1 + 0x17)) == 0 )
  {
    return 4 * v5 + 0x12C;
  }
  return v5;
}
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001DB70) --------------------------------------------------------
int __fastcall sub_1DB70(int a1, __int16 a2, int a3, int a4)
{
  char v6; // al
  int v7; // eax
  int v8; // ebp
  int v9; // ecx
  int v10; // ebp
  int v11; // ecx
  int *v12; // ecx
  int i; // ebp
  int v14; // edx
  int v15; // edx
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  int v19; // eax
  int v21[107]; // [esp+0h] [ebp-1D4h] BYREF
  int *v22; // [esp+1ACh] [ebp-28h]
  int v23; // [esp+1B0h] [ebp-24h]
  int v24; // [esp+1B4h] [ebp-20h]
  int v25; // [esp+1B8h] [ebp-1Ch]
  int v26; // [esp+1BCh] [ebp-18h]
  int *v27; // [esp+1C0h] [ebp-14h]
  float v28; // [esp+1C4h] [ebp-10h]

  v27 = (int *)a3;
  v26 = a4;
  if ( a2 > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x2BD);
  }
  v23 = 0;
  if ( ((1 << a2) & *(unsigned __int8 *)(a1 + 0x16)) != 0 && ((1 << a2) & *(unsigned __int8 *)(a1 + 0x14)) != 0 )
  {
    v6 = *(_BYTE *)(a1 + 0x15);
    v28 = 0.0;
    if ( v6 )
    {
      if ( v27 && v26 >= 0 )
      {
        v10 = 0;
        if ( v26 > 0 )
        {
          v22 = v27;
          do
          {
            v11 = *v22;
            if ( !*v22 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x2F1);
            }
            if ( (*(_BYTE *)(v11 + 0x58) == 4 && a1 == *(_DWORD *)(v11 + 0x59)
               || *(_BYTE *)(v11 + 0x58) == 3 && *(_WORD *)(a1 + 4) == *(_WORD *)(*(_DWORD *)(v11 + 0x59) + 0xC))
              && a2 != *(_WORD *)(v11 + 0x56)
              && byte_A3132[0x1EE * a2 + *(__int16 *)(v11 + 0x56)] == 2 )
            {
              v24 = sub_4A988(v11);
              v28 = (double)v24 + v28;
            }
            ++v10;
            ++v22;
          }
          while ( v10 < v26 );
        }
      }
      else
      {
        v7 = sub_1D794((__int16 *)a1, v21);
        if ( v7 > 0 )
        {
          v8 = 0;
          v25 = 4 * v7;
          do
          {
            v9 = v21[v8 / 4u];
            if ( !v9 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x2D6);
            }
            if ( (*(_BYTE *)(v9 + 0x58) == 4 && a1 == *(_DWORD *)(v9 + 0x59)
               || *(_BYTE *)(v9 + 0x58) == 3 && *(_WORD *)(a1 + 4) == *(_WORD *)(*(_DWORD *)(v9 + 0x59) + 0xC))
              && a2 != *(_WORD *)(v9 + 0x56)
              && byte_A3132[0x1EE * a2 + *(__int16 *)(v9 + 0x56)] == 2 )
            {
              v24 = sub_4A988(v9);
              v28 = (double)v24 + v28;
            }
            v8 += 4;
          }
          while ( v8 < v25 );
        }
      }
      v28 = v28 * flt_90B90 * flt_90B94;
    }
    if ( v28 > 0.0 )
    {
      v12 = (int *)(a1 + 0x46);
      for ( i = 0; i < *(__int16 *)(a1 + 0x5A); ++i )
      {
        if ( *(unsigned __int8 *)(*v12 + 0x57) == a2 )
        {
          v14 = v23;
          v15 = sub_363B0(*v12) + v14;
          sub_360D8(*v12);
          v17 = v15 - 0xA * v16;
          v18 = *v12;
          v23 = v15;
          sub_36158(v18);
          v23 = v17 - 5 * v19;
        }
        ++v12;
      }
      if ( a1 == *(int *)((char *)&dword_A2F79 + 0x1EE * a2) )
      {
        v23 += 0x4E20;
      }
      v23 = (int)((double)v23 * v28);
    }
    if ( v23 < 0 )
    {
      v23 = 0;
    }
  }
  return 5 * v23;
}
// 1DDC9: variable 'v16' is possibly undefined
// 1DDE0: variable 'v19' is possibly undefined
// 90B90: using guessed type float flt_90B90;
// 90B94: using guessed type float flt_90B94;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001DE64) --------------------------------------------------------
int __fastcall sub_1DE64(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edx

  v1 = _wcpp_2_ctor_array_(a1 + 6, 7, &unk_95AF0);
  v2 = _wcpp_2_ctor_array_(v1 + 0xDAF, 0x64, &unk_95B04);
  v3 = _wcpp_2_ctor_array_(v2 + 0x2582, 0x94, &unk_95ADC);
  v4 = _wcpp_2_ctor_array_(v3 + 0x14F10, 0x1F4, &unk_95AC8);
  v5 = _wcpp_2_ctor_array_(v4 + 0xF03E, 0x6B, &unk_95AB4);
  v6 = _wcpp_2_ctor_array_(v5 + 0x93F8, 9, &unk_95AA0);
  v7 = _wcpp_2_ctor_array_(v6 + 0x84, 0x18, &unk_95A8C) - 0x30701;
  sub_1E094(v7);
  return v7;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001E03C) --------------------------------------------------------
int __fastcall sub_1E03C(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax

  v1 = sub_222C0((int)&off_30701 + a1);
  v2 = sub_222E0(v1 - 0x84);
  v3 = sub_222A0(v2 - 0x93F8);
  v4 = sub_22300(v3 - 0xF03E);
  v5 = sub_22320(v4 - 0x14F10);
  v6 = sub_22280(v5 - 0x2582);
  return sub_22260(v6 - 0xDAF) - 6;
}
// 30701: using guessed type void *off_30701;

//----- (0001E094) --------------------------------------------------------
char __fastcall sub_1E094(int a1)
{
  char *v2; // edx
  int v3; // ebx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char result; // al

  v2 = byte_D84C4;
  v3 = 0xB2;
  do
  {
    v4 = v2;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3);
    do
    {
      result = *sub_1CEA8;
      *v4 = *sub_1CEA8;
      if ( !result )
      {
        break;
      }
      result = sub_1CEA8[1];
      sub_1CEA8 += 2;
      v4[1] = result;
      v4 += 2;
    }
    while ( result );
    v2 += 0x14;
    ++v3;
  }
  while ( v2 != &byte_D84C4[0x104] );
  *(_WORD *)(a1 + 0x3335) = 0;
  *(_WORD *)(a1 + 0x49C3) = 0;
  *(_WORD *)(a1 + 0xD88) = 0;
  *(_WORD *)((char *)sub_3067B + a1) = 0;
  *(_BYTE *)(a1 + 0xDB4) = 1;
  return result;
}
// 3067B: using guessed type int sub_3067B();

//----- (0001E10C) --------------------------------------------------------
void __fastcall sub_1E10C(int a1, __int16 a2, __int16 a3, __int16 a4)
{
  *(_WORD *)(a1 + 4) = 0;
  dword_96B88 = 0x20;
  sub_1E2A0(a1, a2);
  sub_1E150(a1, 9);
  sub_1EFC0(a1);
  sub_1E70C(a1, a3, a4);
}
// 96B88: using guessed type int dword_96B88;

//----- (0001E150) --------------------------------------------------------
int __fastcall sub_1E150(int a1, __int16 a2)
{
  int v3; // ebx
  __int64 v4; // rax
  int v5; // ecx
  char *v6; // ebx
  int v7; // edi
  int v8; // esi
  int result; // eax
  float v10; // [esp+0h] [ebp-44h]
  int v11; // [esp+10h] [ebp-34h] BYREF
  float v12; // [esp+14h] [ebp-30h]
  int v13; // [esp+18h] [ebp-2Ch]
  int v14; // [esp+1Ch] [ebp-28h]
  int v15; // [esp+20h] [ebp-24h]
  int v16; // [esp+24h] [ebp-20h]
  _BYTE v17[6]; // [esp+28h] [ebp-1Ch]

  *(_WORD *)&v17[4] = a2;
  if ( a2 > 9 )
  {
    *(_WORD *)&v17[4] = 9;
  }
  v3 = *(_DWORD *)&v17[2];
  *(_WORD *)((char *)&loc_306F0 + a1 + 2) = 0;
  v11 = 0;
  v12 = 0.0;
  v13 = 0;
  v16 = 0x168 / (v3 >> 0x10);
  v4 = (3 * v16 - (__CFSHL__((3 * v16) >> 0x1F, 2) + 4 * ((3 * v16) >> 0x1F))) >> 2;
  v15 = v4;
  v5 = 0;
  v6 = (char *)&loc_3067E + a1;
  v7 = 0;
  v8 = a1;
  v14 = ((int)v4 - HIDWORD(v4)) >> 1;
  while ( 1 )
  {
    result = *(__int16 *)&v17[4];
    if ( v5 >= *(__int16 *)&v17[4] )
    {
      break;
    }
    *((_BYTE *)&loc_3067B + v8 + 2) = v5;
    v11 = 0x447A0000;
    v12 = 300.0;
    v13 = 0;
    *(_DWORD *)v17 = v7 + rand() % v15 - v14;
    v10 = (float)*(int *)v17;
    sub_532AC((float *)&v11, v10);
    *(_DWORD *)v17 = rand() % 0x258 - 0x12C;
    v12 = (double)*(int *)v17 + v12;
    *(_DWORD *)v6 = v11;
    *((float *)v6 + 1) = v12;
    v6 += 0xD;
    v8 += 0xD;
    *(_DWORD *)(v6 + 0xFFFFFFFB) = v13;
    ++v5;
    v7 += v16;
    ++*(_WORD *)((char *)&loc_306F0 + a1 + 2);
  }
  return result;
}

//----- (0001E2A0) --------------------------------------------------------
int __fastcall sub_1E2A0(int a1, __int16 a2)
{
  __int16 v2; // bx
  FILE *v3; // ebp
  __int16 i; // ax
  int v5; // edx
  int v6; // eax
  _DWORD *v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // ebp
  __int16 v11; // ax
  char *v12; // edx
  char *v13; // edi
  char *v14; // esi
  int v15; // ebx
  char v16; // al
  char v17; // al
  int v18; // ebx
  char *v19; // edi
  char *v20; // esi
  char v21; // al
  char v22; // al
  double v23; // st7
  __int64 v24; // rax
  __int16 v25; // bx
  __int16 v26; // si
  __int16 j; // dx
  int v28; // ebp
  __int16 v29; // cx
  int v30; // edx
  __int16 v31; // si
  char *v33; // [esp-4h] [ebp-840h]
  _DWORD v34[500]; // [esp+0h] [ebp-83Ch] BYREF
  int v35[3]; // [esp+7D0h] [ebp-6Ch] BYREF
  float v36; // [esp+7DCh] [ebp-60h]
  int v37; // [esp+7E0h] [ebp-5Ch]
  int v38; // [esp+7E4h] [ebp-58h]
  float v39; // [esp+7E8h] [ebp-54h] BYREF
  float v40; // [esp+7ECh] [ebp-50h]
  float v41; // [esp+7F0h] [ebp-4Ch]
  fpos_t v42; // [esp+7F4h] [ebp-48h] BYREF
  fpos_t pos; // [esp+7F8h] [ebp-44h] BYREF
  int v44; // [esp+7FCh] [ebp-40h]
  int v45; // [esp+800h] [ebp-3Ch]
  int *v46; // [esp+804h] [ebp-38h]
  FILE *fp; // [esp+808h] [ebp-34h]
  int v48; // [esp+80Ch] [ebp-30h]
  int v49; // [esp+810h] [ebp-2Ch]
  int v50; // [esp+814h] [ebp-28h]
  _DWORD *v51; // [esp+818h] [ebp-24h]
  int v52; // [esp+81Ch] [ebp-20h]
  float v53; // [esp+820h] [ebp-1Ch]
  int v54; // [esp+824h] [ebp-18h]

  v48 = a1;
  v39 = 0.0;
  v40 = 0.0;
  v41 = 0.0;
  v49 = 0;
  v2 = 0;
  fp = sub_1BB10("names.txt", &v42);
  v53 = 440.0;
  v3 = fp;
  while ( v2 < 0x64 )
  {
    fgetpos(fp, &pos);
    if ( v42 > pos )
    {
      fscanf(v3, "%s", &v34[5 * v2]);
    }
    else
    {
      sprintf((char *)&v34[5 * v2], "XM%02d", v2);
    }
    ++v2;
  }
  fclose(fp);
  v52 = 0x64;
  *(_WORD *)(v48 + 0x3335) = a2;
  v50 = a2 / 2;
  for ( i = 0; i < 0xD; ++i )
  {
    v5 = *(int *)((char *)&off_96512 + 2 * i) >> 0x10;
    v49 += v5;
  }
  v6 = v48;
  *(_WORD *)((char *)&loc_27281 + v48 + 2) = 0;
  v7 = (_DWORD *)v48;
  *(_WORD *)((char *)&loc_18241 + v6 + 4) = 0;
  v8 = v6 + 0xDB5;
  *v7 = 0;
  *(_DWORD *)((char *)v7 + (_DWORD)&loc_306F3 + 1) = v8;
  *(_DWORD *)((char *)v7 + (_DWORD)&loc_306F7 + 1) = (char *)&loc_18247 + (_DWORD)v7;
  LOWORD(v54) = 0;
  if ( *(__int16 *)(v48 + 0x3335) > 0 )
  {
    v44 = v8;
    v51 = &v34[5 * v52];
    do
    {
      v9 = (__int16)v54;
      v10 = v44 + 0x60 * (__int16)v54;
      *(_BYTE *)(v10 + 0x14) = 0;
      *(_BYTE *)(v10 + 0x15) = 0;
      *(_BYTE *)(v10 + 0x16) = 0;
      *(_BYTE *)(v10 + 0x17) = 0;
      *(_WORD *)(v10 + 0x44) = 0;
      *(_WORD *)(v10 + 6) = 0xFFFF;
      v11 = v54;
      *(_WORD *)(v10 + 0x5A) = 0;
      *(_WORD *)(v10 + 4) = v11;
      v12 = (char *)&v34[5 * (rand() % v52)];
      v13 = (char *)(v10 + 0x1C);
      v14 = v12;
      v15 = v52;
      v33 = (char *)(v10 + 0x1C);
      do
      {
        v16 = *v14;
        *v13 = *v14;
        if ( !v16 )
        {
          break;
        }
        v17 = v14[1];
        v14 += 2;
        v13[1] = v17;
        v13 += 2;
      }
      while ( v17 );
      v18 = v15 - 1;
      v19 = v12;
      v20 = (char *)(v51 + 0xFFFFFFFB);
      v51 += 0xFFFFFFFB;
      v33 = v12;
      do
      {
        v21 = *v20;
        *v19 = *v20;
        if ( !v21 )
        {
          break;
        }
        v22 = v20[1];
        v20 += 2;
        v19[1] = v22;
        v19 += 2;
      }
      while ( v22 );
      v52 = v18;
      if ( v9 > v50 )
      {
        v23 = v53 + flt_90BC8;
        v53 = v23;
        if ( v23 < flt_90BCC )
        {
          v53 = 50.0;
        }
        v24 = *(__int16 *)(v48 + 0x3335) - (__int16)v54;
        v50 += ((int)v24 - HIDWORD(v24)) >> 1;
      }
      *(_DWORD *)v10 = 0xC;
      v25 = 0;
      v26 = rand() % v49 + 1;
      for ( j = 0; j < 0xD; ++j )
      {
        v25 += *((_WORD *)&off_96512 + j + 1);
        if ( v26 <= v25 )
        {
          *(_DWORD *)v10 = j;
          break;
        }
      }
      v45 = rand() % 0x3E8 - 0x1F4;
      v39 = (float)v45;
      v45 = rand() % 0x3E8 - 0x1F4;
      v40 = (float)v45;
      v45 = rand() % 0x3E8 - 0x1F4;
      v41 = (float)v45;
      sub_53000(&v39);
      v46 = v35;
      v36 = v39 * v53;
      *(float *)v35 = v36;
      *(float *)&v37 = v40 * v53;
      v35[1] = v37;
      *(float *)&v38 = v53 * v41;
      v35[2] = v38;
      v39 = v36;
      v40 = *(float *)&v37;
      v41 = *(float *)&v38;
      *(float *)(v10 + 8) = v36;
      v28 = v10 + 8;
      *(float *)(v28 + 4) = v40;
      v29 = v54;
      v30 = v48;
      *(float *)(v28 + 8) = v41;
      v31 = *(_WORD *)(v30 + 0x3335);
      LOWORD(v54) = v29 + 1;
    }
    while ( (__int16)(v29 + 1) < v31 );
  }
  return fclose(fp);
}
// 90BC8: using guessed type float flt_90BC8;
// 90BCC: using guessed type float flt_90BCC;
// 96512: using guessed type void *off_96512;

//----- (0001E70C) --------------------------------------------------------
void __fastcall sub_1E70C(int a1, __int16 a2, unsigned __int8 a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // eax
  __int16 k; // di
  int v9; // eax
  __int16 m; // ax
  int *v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // ebx
  int v15; // edx
  int v16; // eax
  int v17; // edx
  char v18; // bl
  __int16 v19; // dx
  int *v20; // eax
  int v21; // ecx
  int v22; // eax
  int ii; // ecx
  unsigned __int8 v24; // bl
  char v25; // dl
  _BYTE *v26; // eax
  unsigned int v27; // edi
  __int16 v28; // ax
  int mm; // edx
  int v30; // eax
  int v31; // ecx
  int v32; // edi
  int jj; // edx
  int v34; // eax
  int v35; // ecx
  int v36; // edi
  int kk; // edx
  int v38; // eax
  int v39; // ecx
  int v40; // edi
  unsigned __int8 v41; // al
  int v42; // eax
  int v43; // eax
  int v44; // edx
  int v45; // ebx
  char v46; // ch
  int v47; // eax
  int v48; // edx
  char v49; // bl
  int v50; // ecx
  int v51; // eax
  int v52; // ebx
  int v53; // [esp+4h] [ebp-28h]
  int v54; // [esp+8h] [ebp-24h]
  __int16 v56; // [esp+10h] [ebp-1Ch]
  int v57; // [esp+14h] [ebp-18h]
  __int16 i; // [esp+14h] [ebp-18h]
  __int16 j; // [esp+14h] [ebp-18h]
  __int16 nn; // [esp+14h] [ebp-18h]
  __int16 i1; // [esp+14h] [ebp-18h]
  __int16 n; // [esp+18h] [ebp-14h]

  *(_DWORD *)((char *)&loc_306F9 + a1 + 3) = 0xFFFFFFFF;
  byte_30700[a1] = 0;
  *(_WORD *)(a1 + 0xD88) = a2;
  v54 = 0;
  for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
  {
    v4 = 0x60 * i;
    *(_BYTE *)(a1 + v4 + 0xDC9) = 0;
    *(_BYTE *)(a1 + v4 + 0xDCA) = 0;
    *(_BYTE *)(a1 + v4 + 0xDCB) = 0;
    *(_BYTE *)(a1 + v4 + 0xDCC) = 0;
  }
  for ( j = 0; j < *(__int16 *)(a1 + 0x49C3); ++j )
  {
    *(_BYTE *)(a1 + 0x27 * j + 0x3357) = 0;
  }
  v5 = 0;
  sub_46480((int)&word_105258, 0);
  while ( 1 )
  {
    LOWORD(v57) = v5;
    v6 = (__int16)v5;
    if ( (__int16)v5 >= 7 )
    {
      break;
    }
    word_106FA6[(__int16)v5] = 0xFFFF;
    v5 = v57 + 1;
    word_106FB4[v6] = 0;
  }
  v56 = 0x258;
  v7 = *(__int16 *)(a1 + 0x3335);
  *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = 0;
  if ( v7 < 0x19 )
  {
    v56 = 0x1C2;
  }
  while ( v56 > *(__int16 *)((char *)&loc_32DD2 + a1 + 1) )
  {
    if ( v54 )
    {
      for ( k = 0; k < *(__int16 *)(a1 + 0xD88); ++k )
      {
        v9 = 0x1EE * k;
        *(_BYTE *)(*(_DWORD *)(a1 + v9 + 0xD) + 0x14) = 0;
        *(_BYTE *)(*(_DWORD *)(a1 + v9 + 0xD) + 0x17) = 0;
        for ( m = 0; ; ++m )
        {
          v13 = *(_DWORD *)(0x1EE * k + a1 + 0xD);
          if ( m >= *(__int16 *)(v13 + 0x44) )
          {
            break;
          }
          v11 = *(int **)(v13 + 4 * m + 0x2C);
          v12 = *v11;
          *((_BYTE *)v11 + 0x20) = 0;
          *(_BYTE *)(v12 + 0x16) = 0;
          *(_BYTE *)(v11[1] + 0x16) = 0;
        }
      }
    }
    for ( n = 0; n < *(__int16 *)(a1 + 0xD88); ++n )
    {
      v14 = *(_DWORD *)(a1 + 0x3333);
      v15 = 0x60 * (rand() % (v14 >> 0x10));
      v16 = a1 + 0x1EE * n;
      v17 = a1 + 0xDB5 + v15;
      *(_DWORD *)(v16 + 0xD) = v17;
      if ( *(_BYTE *)(v17 + 0x14) )
      {
        --n;
      }
      else
      {
        *(_BYTE *)(v17 + 0x14) = 0x80;
        v18 = 1 << n;
        *(_BYTE *)(*(_DWORD *)(v16 + 0xD) + 0x14) |= 1 << n;
        *(_BYTE *)(v16 + 6) = n;
        v19 = 0;
        *(_BYTE *)(*(_DWORD *)(v16 + 0xD) + 0x17) |= 1 << n;
        while ( 1 )
        {
          v22 = *(_DWORD *)(a1 + 0x1EE * n + 0xD);
          if ( v19 >= *(__int16 *)(v22 + 0x44) )
          {
            break;
          }
          v20 = *(int **)(v22 + 4 * v19 + 0x2C);
          v21 = *v20;
          *((_BYTE *)v20 + 0x20) |= v18;
          *(_BYTE *)(v21 + 0x16) |= v18;
          ++v19;
          *(_BYTE *)(v20[1] + 0x16) |= v18;
        }
      }
    }
    v5 = v54 + 1;
    sub_220CC(a1);
    ++v54;
  }
  for ( ii = 0; (__int16)ii < *(__int16 *)(a1 + 0xD88); ++ii )
  {
    if ( (_WORD)ii )
    {
      do
      {
        v27 = 0;
        v24 = rand() % 0x15;
        v28 = 0;
        if ( (__int16)ii > 0 )
        {
          while ( v24 != *(_BYTE *)(0x1EE * v28 + a1 + 7) )
          {
            if ( ++v28 >= (__int16)ii )
            {
              goto LABEL_37;
            }
          }
          v27 = 0xFFFFFFFF;
        }
LABEL_37:
        ;
      }
      while ( v27 );
    }
    else
    {
      v24 = a3;
    }
    v25 = ii;
    HIWORD(v5) = (unsigned int)(a1 + 6) >> 0x10;
    v26 = (_BYTE *)(a1 + 6 + 0x1EE * (__int16)ii);
    sub_3B1FC(v26, v25, v24);
  }
  sub_1EE08(a1, *(_BYTE *)(a1 + 8));
  v41 = *(_BYTE *)(a1 + 0xDB4);
  if ( v41 )
  {
    if ( v41 <= 1u )
    {
      for ( jj = 0; (__int16)jj < *(__int16 *)(a1 + 0xD88); ++jj )
      {
        v34 = 0x1EE * (__int16)jj;
        LOWORD(ii) = *(_WORD *)(a1 + v34 + 0x1CF);
        v35 = ii + 0x1E;
        LOWORD(v5) = *(_WORD *)(a1 + v34 + 0x1D1);
        *(_WORD *)(a1 + v34 + 0x1CF) = v35;
        v36 = v5 + 0x1E;
        LOWORD(v35) = *(_WORD *)(a1 + v34 + 0x1D3);
        *(_WORD *)(a1 + v34 + 0x1D1) = v36;
        v35 += 0x1E;
        LOWORD(v36) = *(_WORD *)(a1 + v34 + 0x1D5);
        *(_WORD *)(a1 + v34 + 0x1D3) = v35;
        v36 += 0x1E;
        LOWORD(v35) = *(_WORD *)(a1 + v34 + 0x1D7);
        *(_WORD *)(a1 + v34 + 0x1D5) = v36;
        v35 += 0x1E;
        LOWORD(v36) = *(_WORD *)(a1 + v34 + 0x1D9);
        *(_WORD *)(a1 + v34 + 0x1D7) = v35;
        v5 = v36 + 0x28;
        LOWORD(v35) = *(_WORD *)(a1 + v34 + 0x1DB);
        *(_WORD *)(a1 + v34 + 0x1D9) = v5;
        ii = v35 - 0x1E;
        *(_WORD *)(a1 + v34 + 0x1DB) = ii;
      }
    }
    else if ( v41 == 2 )
    {
      for ( kk = 0; (__int16)kk < *(__int16 *)(a1 + 0xD88); ++kk )
      {
        v38 = 0x1EE * (__int16)kk;
        LOWORD(ii) = *(_WORD *)(a1 + v38 + 0x1CF);
        v39 = ii + 0x14;
        LOWORD(v5) = *(_WORD *)(a1 + v38 + 0x1D1);
        *(_WORD *)(a1 + v38 + 0x1CF) = v39;
        v40 = v5 + 0x14;
        LOWORD(v39) = *(_WORD *)(a1 + v38 + 0x1D3);
        *(_WORD *)(a1 + v38 + 0x1D1) = v40;
        v39 += 0x14;
        LOWORD(v40) = *(_WORD *)(a1 + v38 + 0x1D5);
        *(_WORD *)(a1 + v38 + 0x1D3) = v39;
        v40 += 0x14;
        LOWORD(v39) = *(_WORD *)(a1 + v38 + 0x1D7);
        *(_WORD *)(a1 + v38 + 0x1D5) = v40;
        v39 += 0x14;
        LOWORD(v40) = *(_WORD *)(a1 + v38 + 0x1D9);
        *(_WORD *)(a1 + v38 + 0x1D7) = v39;
        v5 = v40 + 0x1E;
        LOWORD(v39) = *(_WORD *)(a1 + v38 + 0x1DB);
        *(_WORD *)(a1 + v38 + 0x1D9) = v5;
        ii = v39 - 0x14;
        *(_WORD *)(a1 + v38 + 0x1DB) = ii;
      }
    }
  }
  else
  {
    for ( mm = 0; (__int16)mm < *(__int16 *)(a1 + 0xD88); ++mm )
    {
      v30 = 0x1EE * (__int16)mm;
      LOWORD(ii) = *(_WORD *)(a1 + v30 + 0x1CF);
      v31 = ii + 0x14;
      LOWORD(v5) = *(_WORD *)(a1 + v30 + 0x1D1);
      *(_WORD *)(a1 + v30 + 0x1CF) = v31;
      v32 = v5 + 0x14;
      LOWORD(v31) = *(_WORD *)(a1 + v30 + 0x1D3);
      *(_WORD *)(a1 + v30 + 0x1D1) = v32;
      v31 += 0x14;
      LOWORD(v32) = *(_WORD *)(a1 + v30 + 0x1D5);
      *(_WORD *)(a1 + v30 + 0x1D3) = v31;
      v32 += 0x14;
      LOWORD(v31) = *(_WORD *)(a1 + v30 + 0x1D7);
      *(_WORD *)(a1 + v30 + 0x1D5) = v32;
      v31 += 0x14;
      LOWORD(v32) = *(_WORD *)(a1 + v30 + 0x1D9);
      *(_WORD *)(a1 + v30 + 0x1D7) = v31;
      v5 = v32 + 0x1E;
      LOWORD(v31) = *(_WORD *)(a1 + v30 + 0x1DB);
      *(_WORD *)(a1 + v30 + 0x1D9) = v5;
      ii = v31 - 0x14;
      *(_WORD *)(a1 + v30 + 0x1DB) = ii;
    }
  }
  *(_DWORD *)((char *)&loc_306F3 + a1 + 1) = *(_DWORD *)(a1 + 0xD);
  *(_WORD *)((char *)&loc_3067B + a1) = 0;
  for ( nn = 0; nn < 0x6B; ++nn )
  {
    v42 = 0x162 * nn;
    *(_WORD *)((char *)&loc_272D8 + a1 + v42 + 3) = 0xFFFF;
    *((_BYTE *)&loc_272D8 + a1 + v42 + 5) = 0;
    *(_DWORD *)((char *)&loc_272D8 + a1 + v42 + 6) = 0;
  }
  for ( i1 = 0; i1 < *(__int16 *)(a1 + 0xD88); ++i1 )
  {
    if ( *(_BYTE *)(0x1EE * i1 + a1 + 0x1A3) == 3 && i1 == (unsigned __int8)byte_104BEA )
    {
      v43 = (unsigned __int8)byte_104BEA ^ i1;
      v44 = a1;
      while ( v43 < *(__int16 *)(a1 + 0xD88) )
      {
        v45 = *(_DWORD *)(v44 + 0xD);
        v44 += 0x1EE;
        ++v43;
        *(_BYTE *)(v45 + 0x17) |= 1 << i1;
      }
    }
    else
    {
      v46 = *(_BYTE *)(a1 + 0x1EE * i1 + 0x1A3);
      if ( v46 == 0xF )
      {
        v47 = 0;
        v48 = a1;
        while ( v47 < *(__int16 *)(a1 + 0x49C3) )
        {
          v49 = *(_BYTE *)(v48 + 0x3357);
          v48 += 0x27;
          ++v47;
          *(_BYTE *)(v48 + 0x3330) = (1 << i1) | v49;
        }
      }
      else if ( v46 == 4 )
      {
        v50 = 0;
        v51 = a1;
        v53 = 0;
        while ( v50 < *(__int16 *)(a1 + 0xD88) )
        {
          if ( i1 != v50 )
          {
            v52 = a1 + 0x1EE * i1;
            *(_WORD *)(v52 + v53 + 0x1B8) = *(_WORD *)(v52 + 0x1DB);
            *(_BYTE *)(v50 + v52 + 0x1C6) = 1;
            *(_WORD *)(v51 + 2 * i1 + 0x1B8) = *(_WORD *)(v51 + 0x1DB);
            *(_BYTE *)(i1 + v51 + 0x1C6) = 1;
          }
          v51 += 0x1EE;
          ++v50;
          v53 += 2;
        }
      }
    }
  }
  JUMPOUT(0x21299);
}
// 1ECC5: control flows out of bounds to 21299
// 1E7E7: variable 'v57' is possibly undefined
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];

//----- (0001EE08) --------------------------------------------------------
char __fastcall sub_1EE08(int a1, char a2)
{
  int v2; // esi
  __int16 v3; // cx
  unsigned int v4; // edi
  __int16 v5; // ax
  __int16 v7; // [esp+2h] [ebp-14h]

  v2 = a1;
  *(_BYTE *)(a1 + 8) = a2;
  v3 = 1;
  v4 = 0xFFFFFFFF;
  if ( *(__int16 *)(a1 + 0xD88) > 1 )
  {
    do
    {
LABEL_4:
      while ( v4 )
      {
        v4 = 0;
        v7 = rand() % 7;
        v5 = 0;
        if ( v3 > 0 )
        {
          while ( *(unsigned __int8 *)(0x1EE * v5 + v2 + 8) != v7 )
          {
            if ( ++v5 >= v3 )
            {
              goto LABEL_4;
            }
          }
          v4 = 0xFFFFFFFF;
        }
      }
      LOBYTE(a1) = v7;
      *(_BYTE *)(0x1EE * v3++ + v2 + 8) = v7;
      v4 = 0xFFFFFFFF;
    }
    while ( v3 < *(__int16 *)(v2 + 0xD88) );
  }
  return a1;
}
// 1EE39: variable 'v7' is possibly undefined

//----- (0001EEA4) --------------------------------------------------------
__int16 __fastcall sub_1EEA4(int a1)
{
  int v1; // ebp
  int v2; // ecx
  int v3; // edi
  int v4; // edx
  __int16 v5; // si
  int v6; // esi
  char s[24]; // [esp+0h] [ebp-38h] BYREF
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]

  v1 = a1;
  v2 = 0;
  if ( *(__int16 *)(a1 + 0xD88) > 0 )
  {
    v3 = 0xE;
    v10 = 0x15;
    v9 = 7;
    do
    {
      v4 = 0x1EE * (__int16)v2;
      v5 = *(unsigned __int8 *)(v4 + v1 + 7);
      sprintf(s, "DATA\\SMRACE%02d.SHP", *(unsigned __int8 *)(v4 + v1 + 7));
      sub_1AEB0((unsigned int)&unk_12FC20, v2, s);
      sprintf(s, "DATA\\LGRACE%02d.SHP", v5);
      sub_1AEB0((unsigned int)&unk_12FC20, v9, s);
      sprintf(s, "DATA\\SMSHIP%02d.SHP", v5);
      sub_1AEB0((unsigned int)&unk_12FC20, v3, s);
      ++v2;
      ++v3;
      sprintf(s, "DATA\\DKSHIP%02d.SHP", v5);
      v6 = v9;
      sub_1AEB0((unsigned int)&unk_12FC20, v10, s);
      LOWORD(a1) = *(_WORD *)(v1 + 0xD88);
      v9 = v6 + 1;
      ++v10;
    }
    while ( (__int16)v2 < (__int16)a1 );
  }
  return a1;
}

//----- (0001EFC0) --------------------------------------------------------
void __fastcall sub_1EFC0(int a1)
{
  int i; // eax

  memset((void *)(a1 + 0x3337), 0, 0x168Cu);
  *(_WORD *)(a1 + 0x49C3) = 0;
  sub_1F91C();
  *(_WORD *)((char *)&loc_32DCD + a1 + 4) = 2;
  while ( *(int *)((char *)&loc_32DCD + a1 + 2) >> 0x10 > 1 )
  {
    for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); ++i )
    {
      *(_WORD *)(a1 + 0x60 * (__int16)i + 0xDBB) = 0xFFFF;
    }
    sub_1FB34(a1);
    sub_201D8(a1);
  }
  JUMPOUT(0x1EFBA);
}
// 1EFFE: control flows out of bounds to 1EFBA

//----- (0001F038) --------------------------------------------------------
unsigned int __fastcall sub_1F038(int a1)
{
  int v2; // edi
  char *v3; // edx
  int i; // ecx
  int j; // eax
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // edi
  int k; // ecx
  unsigned __int8 v10; // bl
  int v11; // edx
  unsigned __int8 v12; // bh
  unsigned __int8 v13; // bh
  unsigned __int8 v14; // bh
  unsigned __int8 v15; // al
  char *v16; // eax
  char *v17; // edx
  unsigned int result; // eax
  char *v19; // ebp
  int v20; // ebx
  int v21; // edx
  char v22; // cl
  char *v23; // eax
  int v24; // edx
  char v25[1100]; // [esp+0h] [ebp-48Ch]
  int v26; // [esp+44Ch] [ebp-40h]
  char *v27; // [esp+450h] [ebp-3Ch]
  int v28; // [esp+454h] [ebp-38h]
  int v29; // [esp+458h] [ebp-34h]
  int v30; // [esp+45Ch] [ebp-30h]
  unsigned int v31; // [esp+460h] [ebp-2Ch]
  int v32; // [esp+464h] [ebp-28h]
  unsigned __int8 v33; // [esp+468h] [ebp-24h]
  unsigned __int8 v34; // [esp+46Ch] [ebp-20h]
  unsigned __int8 v35; // [esp+470h] [ebp-1Ch]

  if ( *(int *)((char *)&loc_32DCD + a1 + 2) >> 0x10 != 1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5BA);
  }
  v2 = (*(__int16 *)(a1 + 0x3335) - 1) * *(__int16 *)(a1 + 0x3335);
  v27 = byte_D8DA0;
  if ( !byte_D8DA0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5C2);
  }
  v3 = v27;
  for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
  {
    for ( j = i + 1; j < *(__int16 *)(a1 + 0x3335); ++j )
    {
      v3 += 2;
      v3[0xFFFFFFFF] = j;
      v3[0xFFFFFFFE] = i;
    }
  }
  if ( v3 - v27 != v2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5D1);
  }
  memset(&byte_32DDB[a1], 0xFF, 0x2710u);
  v6 = 0;
  v30 = v2 >> 1;
  v7 = a1;
  while ( v6 < *(__int16 *)(a1 + 0x3335) )
  {
    byte_32DDA[++v6 + v7] = 0;
    v7 += 0x64;
    v25[v6 + 0x3E7] = 0;
  }
  v8 = (_DWORD *)(a1 + 0x3337);
  for ( k = 0; k < *(__int16 *)(a1 + 0x49C3); ++k )
  {
    v10 = *(_BYTE *)(*v8 + 4);
    v35 = *(_BYTE *)(v8[1] + 4);
    v11 = v35;
    byte_32DDB[0x64 * v10 + v35 + a1] = 1;
    byte_32DDB[0x64 * v11 + v10 + a1] = 1;
    v12 = v25[v10 + 0x3E8];
    v28 = v12;
    v25[v10 + 0x3E8] = v12 + 1;
    v13 = v25[v11 + 0x3E8];
    v25[0xA * v10 + v28] = v11;
    v28 = v13;
    v14 = v13 + 1;
    v25[v11 + 0x3E8] = v14;
    v15 = v25[v10 + 0x3E8];
    v25[0xA * v11 + v28] = v10;
    if ( v15 >= 0xAu || v14 >= 0xAu )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5F3);
    }
    v8 = (_DWORD *)((char *)v8 + 0x27);
  }
  v16 = v27;
  v17 = &v27[2 * v30 - 2];
  if ( v17 >= v27 )
  {
    do
    {
      if ( byte_32DDB[0x64 * (unsigned __int8)*v16 + (unsigned __int8)v16[1] + a1] == 1 )
      {
        *v16 = *v17;
        v16[1] = v17[1];
        v17 += 0xFFFFFFFE;
        --v30;
      }
      else
      {
        v16 += 2;
      }
    }
    while ( v16 <= v17 );
  }
  result = v30;
  v26 = 2;
  if ( v30 > 0 )
  {
    v29 = 1;
    do
    {
      if ( *(__int16 *)(a1 + 0x3335) <= v26 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x610);
      }
      v19 = v27;
      result = (unsigned int)&v27[2 * v30 - 2];
      v31 = result;
      if ( (unsigned int)v27 <= result )
      {
        v32 = v29;
        do
        {
          v34 = *v19;
          v33 = v19[1];
          for ( result = 0; (__int16)result < (int)(unsigned __int8)v25[v34 + 0x3E8]; ++result )
          {
            v20 = v34;
            v21 = v33;
            if ( (unsigned __int8)byte_32DDB[0x64 * (unsigned __int8)v25[0xA * v34 + (__int16)result] + a1 + v33] == v32 )
            {
              v22 = v26;
              byte_32DDB[0x64 * v34 + v33 + a1] = v26;
              v23 = (char *)v31;
              byte_32DDB[0x64 * v21 + a1 + v20] = v22;
              *v19 = *v23;
              v19 += 0xFFFFFFFE;
              v24 = v30;
              v19[3] = *(_BYTE *)(v31 + 1);
              result = v31 - 2;
              v30 = v24 - 1;
              v31 -= 2;
              break;
            }
          }
          v19 += 2;
        }
        while ( (unsigned int)v19 <= v31 );
      }
      ++v29;
      ++v26;
    }
    while ( v30 > 0 );
  }
  return result;
}

//----- (0001F404) --------------------------------------------------------
int __fastcall sub_1F404(int a1)
{
  char *v1; // ebp
  int v2; // eax
  _DWORD *v3; // edx
  double v4; // st7
  int v5; // ebx
  int v6; // edx
  int v7; // edx
  __int16 v8; // ax
  int v9; // ecx
  __int16 v10; // ax
  int v11; // edx
  double v12; // st7
  int v13; // edx
  int result; // eax
  float v15; // [esp+0h] [ebp-134h]
  int v16[21]; // [esp+4h] [ebp-130h] BYREF
  int v17[22]; // [esp+58h] [ebp-DCh] BYREF
  int v18; // [esp+B0h] [ebp-84h]
  int v19; // [esp+B4h] [ebp-80h]
  int v20[3]; // [esp+B8h] [ebp-7Ch] BYREF
  int v21; // [esp+C4h] [ebp-70h] BYREF
  int v22; // [esp+C8h] [ebp-6Ch]
  int v23; // [esp+CCh] [ebp-68h]
  int v24; // [esp+D0h] [ebp-64h]
  int *v25; // [esp+D4h] [ebp-60h]
  const char *v26; // [esp+D8h] [ebp-5Ch]
  int v27; // [esp+DCh] [ebp-58h]
  const char *v28; // [esp+E0h] [ebp-54h]
  int v29; // [esp+E4h] [ebp-50h]
  int v30; // [esp+E8h] [ebp-4Ch]
  float v31; // [esp+ECh] [ebp-48h]
  int v32; // [esp+F0h] [ebp-44h]
  int v33; // [esp+F4h] [ebp-40h]
  int v34; // [esp+F8h] [ebp-3Ch]
  int v35; // [esp+FCh] [ebp-38h]
  int v36; // [esp+100h] [ebp-34h]
  int v37; // [esp+104h] [ebp-30h]
  unsigned int v38; // [esp+108h] [ebp-2Ch]
  int v39; // [esp+10Ch] [ebp-28h]
  char *s; // [esp+110h] [ebp-24h]
  int v41; // [esp+114h] [ebp-20h]
  int v42; // [esp+118h] [ebp-1Ch]

  v41 = a1;
  v33 = a1 + 0xDB5;
  v27 = a1 + 0x49C5;
  v1 = (char *)&loc_18247 + a1;
  v32 = 0;
  v26 = (const char *)(a1 + 0xDD1);
  while ( 1 )
  {
    result = *(__int16 *)(v41 + 0x3335);
    if ( result <= v32 )
    {
      return result;
    }
    v34 = rand() % 5 + 1;
    if ( v34 > 5 )
    {
      v34 = 5;
    }
    v39 = 0xFFFFFFFF;
    v42 = 0;
    v2 = v41;
    while ( *(__int16 *)(v41 + 0xD88) > v42 )
    {
      if ( v33 == *(_DWORD *)(v2 + 0xD) )
      {
        v39 = v42;
        break;
      }
      v2 += 0x1EE;
      ++v42;
    }
    if ( v39 >= 0 && !v34 )
    {
      v34 = 1;
    }
    v35 = 0;
    if ( v39 >= 0 )
    {
      v35 = rand() % v34;
    }
    v3 = (_DWORD *)v33;
    *(_WORD *)(v33 + 0x5A) = v34;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v4 = (double)word_964FA[*v3];
    v37 = 0;
    v42 = 0;
    v31 = v4;
    v29 = 0x168 / v34;
    if ( v34 > 0 )
    {
      v28 = v26;
      v38 = 0;
      v36 = v33;
      v30 = 0x1EE * v39 + v41;
      s = v1 + 0x24;
      do
      {
        *(_DWORD *)(v36 + 0x46) = v1;
        LOWORD(v5) = rand() % 5;
        LOWORD(v6) = rand() % 0xB;
        if ( v39 >= 0 && v35 == v42 )
        {
          qmemcpy(v16, &unk_96548, sizeof(v16));
          qmemcpy(v17, &unk_9659C, 0x54u);
          v7 = *(unsigned __int8 *)(v30 + 7);
          v5 = v16[v7];
          v6 = v17[v7];
        }
        *((_WORD *)v1 + 0xD) = 0;
        *((_DWORD *)v1 + 4) = 0;
        v8 = v32;
        *(_DWORD *)(v1 + 0x5A) = 0;
        *((_WORD *)v1 + 6) = v8;
        v9 = v41;
        *((_WORD *)v1 + 7) = v42;
        v10 = sub_33AF0((int)v1, v5, v6, v27 + 4 * (*(int *)((char *)&loc_18241 + v9 + 2) >> 0x10));
        v11 = v41;
        *(_WORD *)((char *)&loc_18241 + v41 + 4) += v10;
        if ( *(int *)((char *)&loc_18241 + v11 + 2) >> 0x10 > 0x4E20 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x67B);
        }
        sprintf(s, "%s ", v28);
        sub_31E60(s, v42 + 1);
        v12 = ((double)word_964F0[v38 / 2] + v31) * flt_90C86 * flt_90C8A;
        v25 = v20;
        *(float *)&v24 = v12;
        v17[0x15] = v24;
        *(float *)&v18 = 0.0 * *(float *)&v24;
        v19 = v18;
        v20[0] = v24;
        v20[1] = v18;
        v20[2] = v18;
        v21 = v24;
        v22 = v18;
        v23 = v18;
        v15 = (float)v37;
        sub_532AC((float *)&v21, v15);
        sub_362C8((int)v1, &v21);
        if ( v39 >= 0 && v35 == v42 )
        {
          v1[0x57] = v39;
          *((_WORD *)v1 + 0x21) = 2;
          sub_34AE4((int)v1, 5u, 0xFFFFFFFF);
        }
        v1 += 0x7B;
        v36 += 4;
        v38 += 2;
        ++v42;
        s += 0x7B;
        v37 += v29;
      }
      while ( v42 < v34 );
    }
    v13 = v41;
    *(_WORD *)((char *)&loc_27281 + v41 + 2) += HIWORD(v34);
    if ( *(int *)((char *)&loc_27281 + v13) >= 0x1F4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x697);
    }
    ++v32;
    v26 += 0x60;
    v33 += 0x60;
  }
}
// 90C86: using guessed type float flt_90C86;
// 90C8A: using guessed type float flt_90C8A;
// 964F0: using guessed type __int16 word_964F0[];
// 964FA: using guessed type __int16 word_964FA[12];
// 1F404: using guessed type int var_130[21];

//----- (0001F91C) --------------------------------------------------------
int sub_1F91C()
{
  int result; // eax
  __int16 v1; // di
  int v2; // edx
  int v3; // eax
  int v4; // esi
  __int16 v5; // ax
  __int16 v6; // dx
  float *v7; // ebx
  __int16 v8; // dx
  int v9; // eax
  double v10; // st7
  int v11[3]; // [esp+14h] [ebp-48h] BYREF
  float v12; // [esp+20h] [ebp-3Ch]
  float v13; // [esp+24h] [ebp-38h]
  float v14; // [esp+28h] [ebp-34h]
  int *v15; // [esp+2Ch] [ebp-30h]
  int v16; // [esp+30h] [ebp-2Ch]
  int v17; // [esp+34h] [ebp-28h]
  int v18; // [esp+38h] [ebp-24h]
  int v19; // [esp+3Ch] [ebp-20h]
  __int16 v20; // [esp+40h] [ebp-1Ch]

  memset(&byte_32DDB[(_DWORD)dword_A2F6C], 0, 0x2710u);
  result = 0;
  if ( word_A62A1 > 0 )
  {
    do
    {
      byte_32DDB[(_DWORD)&dword_A2F6C[0x19 * (__int16)result] + (__int16)result] = 1;
      ++result;
    }
    while ( (__int16)result < *(__int16 *)((char *)&dword_A2F6C[0xCCD] + 1) );
  }
  v1 = *(_WORD *)((char *)&dword_A2F6C[0xCCD] + 1);
  LOWORD(v19) = 0;
  if ( v1 > 0 )
  {
    v17 = (int)&dword_A2F6C[0x36D] + 1;
    do
    {
      v2 = 0x60 * (__int16)v19 + v17;
      v3 = *(_DWORD *)v2;
      v16 = v2;
      if ( *(_WORD *)(v2 + 0x44) != word_9652E[v3] )
      {
        v4 = 0x1388;
        v5 = *(_WORD *)((char *)&dword_A2F6C[0xCCD] + 1);
        v6 = 0;
        v20 = 0xFFFF;
        v7 = (float *)(v16 + 8);
        if ( v5 > 0 )
        {
          do
          {
            if ( !byte_32DDB[(_DWORD)&dword_A2F6C[0x19 * (__int16)v19] + v6] )
            {
              v9 = v17 + 0x60 * v6;
              if ( *(_WORD *)(v9 + 0x44) != word_9652E[*(_DWORD *)v9] )
              {
                v15 = v11;
                v12 = 0.0;
                v13 = 0.0;
                v14 = 0.0;
                v12 = *v7 - *(float *)(v9 + 8);
                v13 = v7[1] - *(float *)(v9 + 0xC);
                v14 = v7[2] - *(float *)(v9 + 0x10);
                *(float *)v11 = v12;
                *(float *)&v11[1] = v13;
                *(float *)&v11[2] = v14;
                v10 = sqrt(v13 * v13 + v12 * v12 + v14 * v14);
                v18 = (int)v10;
                if ( v4 > (int)v10 )
                {
                  v4 = (int)v10;
                  v20 = v6;
                }
              }
            }
            ++v6;
          }
          while ( v6 < *(__int16 *)((char *)&dword_A2F6C[0xCCD] + 1) );
        }
        if ( v20 != 0xFFFFFFFF && !sub_1CF68(v16, 0x60 * v20 + v17) )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x6D0);
        }
      }
      result = v19 + 1;
      v8 = *(_WORD *)((char *)&dword_A2F6C[0xCCD] + 1);
      LOWORD(v19) = result;
    }
    while ( (__int16)result < v8 );
  }
  return result;
}
// 9652E: using guessed type __int16 word_9652E[];
// A2F6C: using guessed type int dword_A2F6C[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (0001FB34) --------------------------------------------------------
int __fastcall sub_1FB34(int a1)
{
  _WORD *v2; // eax
  __int16 i; // bx
  int v4; // eax
  __int16 v5; // dx
  char *v6; // ecx
  int v7; // ebx
  float *j; // edx
  float *v9; // eax
  double v10; // st7
  double v11; // st7
  double v12; // st7
  __int16 v13; // bx
  __int16 v14; // ax
  __int16 v15; // dx
  __int16 v16; // cx
  int result; // eax
  float v18; // [esp+0h] [ebp-58h] BYREF
  float v19; // [esp+4h] [ebp-54h]
  float v20; // [esp+8h] [ebp-50h]
  float v21; // [esp+Ch] [ebp-4Ch]
  float v22; // [esp+10h] [ebp-48h]
  float v23; // [esp+14h] [ebp-44h]
  float v24; // [esp+18h] [ebp-40h] BYREF
  float v25; // [esp+1Ch] [ebp-3Ch]
  float v26; // [esp+20h] [ebp-38h]
  float v27; // [esp+24h] [ebp-34h]
  float v28; // [esp+28h] [ebp-30h]
  float v29; // [esp+2Ch] [ebp-2Ch]
  float *v30; // [esp+30h] [ebp-28h]
  float *v31; // [esp+34h] [ebp-24h]
  int v32; // [esp+38h] [ebp-20h]
  int v33; // [esp+3Ch] [ebp-1Ch]

  v2 = (_WORD *)((char *)&off_30701 + a1);
  v2[0x1368] = 0;
  memset(v2, 0, 0x26D0u);
  for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
  {
    v4 = 0x60 * i;
    if ( *(__int16 *)(a1 + v4 + 0xDBB) == 0xFFFFFFFF )
    {
      sub_1FD18(a1, a1 + 0xDB5 + v4);
      ++*(_WORD *)((char *)&loc_32DCD + a1 + 4);
    }
  }
  *(_WORD *)((char *)&loc_32DD4 + a1 + 1) = 0;
  v5 = *(_WORD *)((char *)&loc_32DCD + a1 + 4);
  LOWORD(v33) = 0;
  if ( v5 > 0 )
  {
    do
    {
      v6 = (char *)&off_30701 + 0x19E * (__int16)v33 + a1;
      v7 = 0;
      for ( j = (float *)(v6 + 0x192); (__int16)v7 < *((__int16 *)v6 + 0xC8); ++v7 )
      {
        v9 = *(float **)&v6[4 * (__int16)v7];
        v30 = &v18;
        v21 = 0.0;
        v22 = 0.0;
        v23 = 0.0;
        v21 = *j + v9[2];
        v22 = *(float *)(v6 + 0x196) + v9[3];
        v10 = *(float *)(v6 + 0x19A) + v9[4];
        v18 = v21;
        v23 = v10;
        v19 = v22;
        v20 = v23;
        *j = v21;
        *(float *)(v6 + 0x196) = v19;
        *(float *)(v6 + 0x19A) = v20;
      }
      v11 = 1.0 / (double)*((__int16 *)v6 + 0xC8);
      v31 = &v24;
      v27 = 0.0;
      v28 = 0.0;
      v29 = 0.0;
      v27 = *j * v11;
      v28 = *(float *)(v6 + 0x196) * v11;
      v12 = v11 * *(float *)(v6 + 0x19A);
      v24 = v27;
      v29 = v12;
      v25 = v28;
      v26 = v29;
      *j = v27;
      *(float *)(v6 + 0x196) = v25;
      v13 = v33;
      *(float *)(v6 + 0x19A) = v26;
      ++v13;
      v14 = *((_WORD *)v6 + 0xC8);
      v15 = *(_WORD *)((char *)&loc_32DD4 + a1 + 1);
      LOWORD(v33) = v13;
      v16 = *(_WORD *)((char *)&loc_32DCD + a1 + 4);
      *(_WORD *)((char *)&loc_32DD4 + a1 + 1) = v14 + v15;
    }
    while ( v13 < v16 );
  }
  v32 = (int)((double)*(__int16 *)((char *)&loc_32DD4 + a1 + 1) / (double)*(__int16 *)((char *)&loc_32DCD + a1 + 4));
  result = v32;
  *(_WORD *)((char *)&loc_32DD4 + a1 + 1) = v32;
  return result;
}
// 30701: using guessed type void *off_30701;

//----- (0001FD18) --------------------------------------------------------
void __fastcall sub_1FD18(int a1, int a2)
{
  __int16 i; // bx

  *(_WORD *)(a2 + 6) = *(_WORD *)((char *)&loc_32DCD + a1 + 4);
  sub_2016C(a1, a2, HIWORD(*(_DWORD *)((char *)&loc_32DCD + a1 + 2)));
  for ( i = 0; i < *(__int16 *)(a2 + 0x44); ++i )
  {
    if ( *(__int16 *)(**(_DWORD **)(a2 + 4 * i + 0x2C) + 6) == 0xFFFFFFFF )
    {
      sub_1FD18(a1);
    }
    if ( *(__int16 *)(*(_DWORD *)(*(_DWORD *)(a2 + 4 * i + 0x2C) + 4) + 6) == 0xFFFFFFFF )
    {
      sub_1FD18(a1);
    }
  }
  JUMPOUT(0x1E706);
}
// 1FD43: control flows out of bounds to 1E706

//----- (0001FD90) --------------------------------------------------------
int __fastcall sub_1FD90(int a1, int a2, int a3)
{
  int v6; // eax
  __int16 v7; // bx
  int v8; // edx

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x71E);
  }
  v6 = 0;
  if ( word_A62A1 > 0 )
  {
    do
    {
      v7 = word_A62A1;
      v8 = (__int16)v6++;
      *(_BYTE *)(v8 + a2) = 0;
    }
    while ( (__int16)v6 < v7 );
  }
  return sub_1FDF0(a1, *(_DWORD *)(a1 + 0x1EE * a3 + 0xD), a2, a3);
}
// A62A1: using guessed type __int16 word_A62A1;

//----- (0001FDF0) --------------------------------------------------------
int __fastcall sub_1FDF0(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  _BYTE *v6; // ebp
  __int16 v7; // dx
  __int16 j; // bx
  int v9; // eax
  int v11; // [esp+4h] [ebp-24h]
  __int16 i; // [esp+14h] [ebp-14h]
  __int16 v15; // [esp+14h] [ebp-14h]
  char v16; // [esp+18h] [ebp-10h]

  v16 = 0;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    if ( *(_BYTE *)(0x1EE * a4 + a1 + i + 0x1C6) == 3 )
    {
      v16 |= 1 << i;
    }
  }
  v15 = 0;
  result = a2;
  if ( *(__int16 *)(a2 + 0x44) > 0 )
  {
    v11 = 1 << a4;
    do
    {
      v5 = *(_DWORD *)(a2 + 4 * v15 + 0x2C);
      result = *(__int16 *)(v5 + 0x21);
      if ( result != a4 )
      {
        if ( *(_DWORD *)v5 == a2 )
        {
          v6 = *(_BYTE **)(v5 + 4);
        }
        else
        {
          v6 = *(_BYTE **)v5;
        }
        if ( ((unsigned __int8)v11 & v6[0x17]) != 0 )
        {
          if ( (~v11 & ((unsigned __int8)(v6[0x15] & ~v16) | (unsigned __int8)(~v16 & v6[0x14])) & 0x7F) != 0 )
          {
            result = a3 + *(__int16 *)(a2 + 4);
            ++*(_BYTE *)result;
          }
          else
          {
            v7 = 0;
            for ( j = 0; j < 0x6B; ++j )
            {
              if ( v7 >= SHIWORD(dword_D35E5) )
              {
                break;
              }
              v9 = *(int *)((char *)&dword_CA245 + 0x162 * j) >> 0x10;
              if ( v9 != 0xFFFFFFFF )
              {
                ++v7;
                if ( v5 == *(int *)((char *)&dword_CA24A + 0x162 * j)
                  && v9 != a4
                  && *(_BYTE *)(0x1EE * a4 + a1 + v9 + 0x1C6) != 3 )
                {
                  break;
                }
              }
            }
            if ( v7 < SHIWORD(dword_D35E5) )
            {
              result = a3 + *(__int16 *)(a2 + 4);
              ++*(_BYTE *)result;
            }
            else
            {
              *(_WORD *)(v5 + 0x21) = a4;
              result = sub_1FDF0(a1, v6, a3, a4);
            }
          }
        }
        else
        {
          result = a3 + *(__int16 *)(a2 + 4);
          ++*(_BYTE *)result;
        }
      }
      ++v15;
    }
    while ( v15 < *(__int16 *)(a2 + 0x44) );
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;
// CA245: using guessed type int dword_CA245;
// CA24A: using guessed type int dword_CA24A;
// D35E5: using guessed type int dword_D35E5;

//----- (0001FFE0) --------------------------------------------------------
int __fastcall sub_1FFE0(int a1, int a2)
{
  int result; // eax
  _BYTE *v4; // edi
  __int16 v5; // dx
  __int16 k; // bx
  int v7; // esi
  __int16 i; // [esp+4h] [ebp-1Ch]
  __int16 j; // [esp+4h] [ebp-1Ch]
  char v11; // [esp+8h] [ebp-18h]

  v11 = 0;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    if ( byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + i] == 3 )
    {
      v11 |= 1 << i;
    }
  }
  result = a2;
  for ( j = 0; j < *(__int16 *)(a2 + 0x44); ++j )
  {
    result = a2 + 4 * j;
    v7 = *(_DWORD *)(result + 0x2C);
    if ( !*(_WORD *)(v7 + 0x21) )
    {
      v4 = *(_DWORD *)v7 == a2 ? *(_BYTE **)(v7 + 4) : *(_BYTE **)v7;
      result = (unsigned __int8)v4[0x17];
      if ( ((1 << byte_104BEA) & result) != 0 )
      {
        result = ((unsigned __int8)(v4[0x15] & ~v11) | (unsigned __int8)(~v11 & v4[0x14])) & 0x7F;
        if ( (~(1 << byte_104BEA) & result) == 0 )
        {
          v5 = 0;
          for ( k = 0; ; ++k )
          {
            result = k;
            if ( k >= 0x6B )
            {
              break;
            }
            if ( v5 >= SHIWORD(dword_D35E5) )
            {
              break;
            }
            result = *(int *)((char *)&dword_CA245 + 0x162 * k) >> 0x10;
            if ( result != 0xFFFFFFFF )
            {
              ++v5;
              if ( v7 == *(int *)((char *)&dword_CA24A + 0x162 * k)
                && result != (unsigned __int8)byte_104BEA
                && byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + result] != 3 )
              {
                break;
              }
            }
          }
          if ( v5 >= SHIWORD(dword_D35E5) )
          {
            *(_WORD *)(v7 + 0x21) = 1;
            ++*(_DWORD *)(a1 + 0x354EB);
            result = sub_1FFE0(a1, v4);
          }
        }
      }
    }
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;
// CA245: using guessed type int dword_CA245;
// CA24A: using guessed type int dword_CA24A;
// D35E5: using guessed type int dword_D35E5;

//----- (0002016C) --------------------------------------------------------
int __fastcall sub_2016C(int a1, int a2, __int16 a3)
{
  int result; // eax
  char *v5; // ecx

  if ( a3 >= 0x18 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7BB);
  }
  result = 0x19E * a3;
  v5 = (char *)&off_30701 + a1 + result;
  if ( *((__int16 *)v5 + 0xC8) >= 0x64 )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7BE);
  }
  *(_DWORD *)&v5[4 * (__int16)(*((_WORD *)v5 + 0xC8))++] = a2;
  return result;
}
// 30701: using guessed type void *off_30701;

//----- (000201D8) --------------------------------------------------------
int __fastcall sub_201D8(int a1)
{
  int v1; // ecx
  int result; // eax
  __int16 v3; // si
  int v4; // esi
  __int16 v5; // dx
  __int16 v6; // ax
  int v7; // edi
  int v8; // eax
  int v9; // ebx
  __int16 i; // dx
  int v11; // ebx
  double v12; // st7
  __int16 j; // bx
  int v14; // edx
  double v15; // st7
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // edx
  float v20; // [esp+8h] [ebp-88h]
  int v21; // [esp+Ch] [ebp-84h]
  int v22; // [esp+10h] [ebp-80h]
  float v23; // [esp+14h] [ebp-7Ch]
  int v24; // [esp+18h] [ebp-78h]
  int v25; // [esp+1Ch] [ebp-74h]
  int v26[3]; // [esp+20h] [ebp-70h] BYREF
  int v27[3]; // [esp+2Ch] [ebp-64h] BYREF
  float v28; // [esp+38h] [ebp-58h]
  int v29; // [esp+3Ch] [ebp-54h]
  int v30; // [esp+40h] [ebp-50h]
  int v31; // [esp+44h] [ebp-4Ch]
  int *v32; // [esp+48h] [ebp-48h]
  int *v33; // [esp+4Ch] [ebp-44h]
  int v34; // [esp+50h] [ebp-40h]
  int assert; // [esp+54h] [ebp-3Ch]
  int v36; // [esp+58h] [ebp-38h]
  int v37; // [esp+5Ch] [ebp-34h]
  int v38; // [esp+60h] [ebp-30h]
  int v39; // [esp+64h] [ebp-2Ch]
  int v40; // [esp+68h] [ebp-28h]
  int v41; // [esp+6Ch] [ebp-24h]
  __int16 v42; // [esp+70h] [ebp-20h]
  int v43; // [esp+74h] [ebp-1Ch]

  v38 = a1;
  v1 = 0;
  v28 = 0.0;
  v29 = 0;
  v30 = 0;
  if ( !*(_WORD *)((char *)&loc_32DCD + a1 + 4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7DD);
  }
  result = *(_DWORD *)((char *)&loc_32DCD + SHIWORD(v38) + 2);
  if ( result != 1 )
  {
    result = v38;
    v3 = *(_WORD *)((char *)&loc_32DCD + v38 + 4);
    LOWORD(v43) = 0;
    if ( v3 > 0 )
    {
      v34 = (int)&off_30701 + v38;
      do
      {
        v4 = 0x19E * (__int16)v43 + v34;
        v5 = 0;
        v36 = (int)&loc_18696 + 9;
        v37 = (int)&loc_18696 + 9;
        assert = 0;
        v6 = *(_WORD *)(v4 + 0x190);
        v42 = 0;
        v7 = 0;
        if ( v6 > 0 )
        {
          do
          {
            v8 = *(_DWORD *)(v4 + 4 * v5);
            v9 = *(_DWORD *)v8;
            v31 = *(int *)((char *)&unk_9652C + v9 * 2) >> 0x10;
            v41 = *(__int16 *)(v8 + 0x44);
            v31 -= v41;
            v41 = v42;
            if ( v31 > v42 )
            {
              v7 = v8;
              v42 = word_9652E[v9] - *(_WORD *)(v8 + 0x44);
            }
            ++v5;
          }
          while ( v5 < *(__int16 *)(v4 + 0x190) );
        }
        if ( !v7 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7FF);
        }
        for ( i = 0; i < *(__int16 *)((char *)&loc_32DCD + v38 + 4); ++i )
        {
          if ( i != (_WORD)v43 )
          {
            v11 = v34 + 0x19E * i;
            v33 = v26;
            v20 = *(float *)(v7 + 8) - *(float *)(v11 + 0x192);
            *(float *)&v21 = *(float *)(v7 + 0xC) - *(float *)(v11 + 0x196);
            *(float *)&v22 = *(float *)(v7 + 0x10) - *(float *)(v11 + 0x19A);
            *(float *)v26 = v20;
            v26[1] = v21;
            v26[2] = v22;
            v28 = v20;
            v29 = v21;
            v30 = v22;
            v12 = sqrt(*(float *)&v21 * *(float *)&v21 + v20 * v20 + *(float *)&v22 * *(float *)&v22);
            v40 = (int)v12;
            if ( (int)v12 < v36 )
            {
              v1 = v11;
              v36 = (int)v12;
            }
          }
        }
        if ( !v1 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x813);
        }
        for ( j = 0; j < *(__int16 *)(v1 + 0x190); ++j )
        {
          v14 = *(_DWORD *)(v1 + 4 * j);
          if ( !byte_32DDB[0x64 * *(__int16 *)(v7 + 4) + v38 + *(__int16 *)(v14 + 4)] )
          {
            v32 = v27;
            v23 = *(float *)(v7 + 8) - *(float *)(v14 + 8);
            *(float *)&v24 = *(float *)(v7 + 0xC) - *(float *)(v14 + 0xC);
            *(float *)&v25 = *(float *)(v7 + 0x10) - *(float *)(v14 + 0x10);
            *(float *)v27 = v23;
            v27[1] = v24;
            v27[2] = v25;
            v28 = v23;
            v29 = v24;
            v30 = v25;
            v15 = sqrt(*(float *)&v24 * *(float *)&v24 + v23 * v23 + *(float *)&v25 * *(float *)&v25);
            v41 = *(int *)((char *)&unk_9652C + 2 * *(_DWORD *)v14) >> 0x10;
            v16 = *(__int16 *)(v14 + 0x44);
            v39 = (int)v15;
            if ( v41 != v16 && v39 < v37 )
            {
              assert = v14;
              v37 = v39;
            }
          }
        }
        if ( !assert )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x82C);
        }
        v17 = sub_1CF68(v7, assert);
        if ( !v17 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x832);
        }
        *(_BYTE *)(v17 + 0x23) |= 1u;
        v18 = assert;
        *(_BYTE *)(v7 + 0x18) |= 1u;
        *(_BYTE *)(v18 + 0x18) |= 1u;
        v19 = v43 + 1;
        LOWORD(v43) = v43 + 1;
        result = v19;
      }
      while ( (__int16)v19 < *(__int16 *)((char *)&loc_32DCD + v38 + 4) );
    }
  }
  return result;
}
// 30701: using guessed type void *off_30701;
// 9652E: using guessed type __int16 word_9652E[];

//----- (000205A0) --------------------------------------------------------
int __fastcall sub_205A0(int a1, int a2, int a3)
{
  int v5; // ebx
  int v6; // edx

  if ( !a2 || !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x83F);
  }
  v5 = *(__int16 *)(a1 + 0x49C3);
  if ( v5 == 0x94 || byte_32DDB[0x64 * *(__int16 *)(a2 + 4) + a1 + *(__int16 *)(a3 + 4)] )
  {
    return 0;
  }
  v6 = 0x27 * v5 + a1 + 0x3337;
  *(_BYTE *)(v6 + 0x20) = 0;
  *(_DWORD *)v6 = a2;
  *(_DWORD *)(v6 + 4) = a3;
  ++*(_WORD *)(a1 + 0x49C3);
  byte_32DDB[0x64 * *(__int16 *)(a2 + 4) + a1 + *(__int16 *)(a3 + 4)] = 1;
  byte_32DDB[0x64 * *(__int16 *)(a3 + 4) + a1 + *(__int16 *)(a2 + 4)] = 1;
  return v6;
}

//----- (00020684) --------------------------------------------------------
char *__fastcall sub_20684(int a1, __int16 a2)
{
  char *v4; // ebx
  __int16 i; // dx
  char *result; // eax

  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xD88) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x863);
  }
  if ( *(__int16 *)(a1 + 0x3067B) >= 0x6B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x864);
  }
  v4 = (char *)&loc_27281 + a1 + 4;
  for ( i = 0; i < 0x6B; ++i )
  {
    if ( *((__int16 *)v4 + 0x2B) == 0xFFFFFFFF )
    {
      sub_48C5C((int)v4, 0);
      *((_WORD *)v4 + 0x2B) = a2;
      result = v4;
      ++*(_WORD *)((char *)&loc_3067B + a1);
      return result;
    }
    v4 += 0x162;
  }
  Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0x873);
  return 0;
}

//----- (00020720) --------------------------------------------------------
__int16 __fastcall sub_20720(int a1, int a2)
{
  __int16 result; // ax

  if ( *(__int16 *)(a2 + 0x56) < 0 || (result = *(_WORD *)(a2 + 0x56), result >= *(__int16 *)(a1 + 0xD88)) )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x87E);
  }
  if ( !*(_BYTE *)(a2 + 0x58) )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x87F);
  }
  *(_WORD *)(a2 + 0x56) = 0xFFFF;
  *(_BYTE *)(a2 + 0x58) = 0;
  *(_BYTE *)(a2 + 0x34) = 0;
  --*(_WORD *)((char *)&loc_3067B + a1);
  if ( *(__int16 *)(a1 + 0x3067B) < 0 )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x887);
  }
  return result;
}

//----- (000207A0) --------------------------------------------------------
char __fastcall sub_207A0(int a1)
{
  int i; // eax
  int v3; // ebp
  int v4; // edx
  int v5; // edx
  int v6; // ebx
  int v7; // edx
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // ecx
  int j; // eax
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  int k; // eax
  char v18; // bl
  int v19; // edx
  int v20; // eax
  char v21; // ch
  double v22; // st6
  int v24; // [esp+8h] [ebp-24h]
  size_t v25; // [esp+8h] [ebp-24h]
  int v26; // [esp+8h] [ebp-24h]
  unsigned __int8 v27; // [esp+Ch] [ebp-20h]
  char v28; // [esp+10h] [ebp-1Ch]

  v28 = 0;
  i = 0x1EE * (unsigned __int8)byte_104BEA;
  v3 = i + a1 + 6;
  if ( *(_DWORD *)(v3 + 3) == 0xFFFFFFFF )
  {
    v28 = 1;
  }
  if ( !v28 )
  {
    v4 = a1;
    i = 0;
    v28 = 2;
    while ( i < *(__int16 *)(a1 + 0xD88) )
    {
      if ( i != (unsigned __int8)byte_104BEA && !*(_DWORD *)(v4 + 9) )
      {
        v28 = 0;
        break;
      }
      v4 += 0x1EE;
      ++i;
    }
  }
  if ( !v28 )
  {
    v5 = a1;
    i = 0;
    v28 = 3;
    while ( i < *(__int16 *)(a1 + 0xD88) )
    {
      if ( (*(_BYTE *)(*(_DWORD *)(v5 + 0xD) + 0x14) & 0x7F) != 1 << byte_104BEA )
      {
        LOBYTE(i) = 0;
        v28 = 0;
        break;
      }
      v5 += 0x1EE;
      ++i;
    }
  }
  if ( !v28 )
  {
    v27 = 0;
    v6 = v3;
    v28 = 4;
    i = 0;
    v7 = a1;
    while ( i < *(__int16 *)(a1 + 0xD88) )
    {
      if ( !*(_DWORD *)(v7 + 9) )
      {
        v27 |= 1 << i;
      }
      if ( i != (unsigned __int8)byte_104BEA && !*(_DWORD *)(v7 + 9) && *(_BYTE *)(v6 + 0x1C0) != 3 )
      {
        v28 = 0;
        break;
      }
      v7 += 0x1EE;
      ++v6;
      ++i;
    }
    if ( v28 == 4 )
    {
      v8 = a1;
      for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
      {
        if ( (v27 & *(_BYTE *)(v8 + 0xDCC)) == 0 )
        {
          v28 = 0;
          break;
        }
        v8 += 0x60;
      }
    }
  }
  if ( !v28 )
  {
    i = 2 * *(__int16 *)(a1 + 0x3335) / 3 + 1;
    if ( i <= *(_DWORD *)(a1 + 0x354EB) )
    {
      v28 = 5;
    }
  }
  if ( v28 )
  {
    v9 = 0;
    v10 = 0;
    v24 = 0;
    while ( v10 < (unsigned __int16)word_105258 )
    {
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + v9) >> 0x18)) != 0 )
      {
        ++v24;
      }
      v9 += 0x4B;
      ++v10;
    }
    v11 = a1;
    for ( j = 0; j < *(int *)((char *)&loc_27281 + a1) >> 0x10; ++j )
    {
      if ( (_BYTE)byte_104BEA == *((_BYTE *)&loc_1829D + v11 + 1) )
      {
        v24 += 2;
      }
      v11 += 0x7B;
    }
    v13 = 0;
    v25 = sub_40224((unsigned __int8 *)v3, 0, 0) + v24;
    v14 = a1;
    while ( v13 < *(__int16 *)(a1 + 0x3335) )
    {
      if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(v14 + 0xDCC)) != 0 )
      {
        ++v25;
      }
      v14 += 0x60;
      ++v13;
    }
    v15 = a1;
    v16 = v3;
    for ( k = 0; k < *(__int16 *)(a1 + 0xD88); ++k )
    {
      if ( k != (unsigned __int8)byte_104BEA && *(_DWORD *)(v15 + 9) != 0xFFFFFFFF )
      {
        v18 = *(_BYTE *)(v16 + 0x1C0);
        if ( v18 == 3 )
        {
          v25 += 0xF;
        }
        else if ( v18 == 2 )
        {
          v25 -= 0xA;
        }
      }
      v15 += 0x1EE;
      ++v16;
    }
    if ( v28 == 4 )
    {
      v25 += 0x32;
    }
    v19 = 0x64 - 0x4B * *(_DWORD *)a1 / 0xFA0;
    v20 = v19;
    if ( v19 >= 0x19 )
    {
      if ( v19 > 0x64 )
      {
        v20 = 0x64;
      }
    }
    else
    {
      v20 = 0x19;
    }
    v21 = *(_BYTE *)(a1 + 0xDB4);
    v26 = (int)(v20 * v25) / 0x64;
    if ( v21 == 1 )
    {
      v22 = (double)v26 * dbl_90D76;
    }
    else
    {
      if ( v21 != 2 )
      {
LABEL_71:
        if ( v26 < 0 )
        {
          v26 = 0;
        }
        byte_30700[a1] = v28;
        *(_DWORD *)(a1 + 0x306FC) = 0x64 * v26 / 0x258;
        *(_WORD *)&V_Type3_stru_10AE70.z2[0x14A] = 0;
        LOBYTE(i) = sub_56B60((int)&V_Type3_stru_10AE70, 1, 9, 1);
        return i;
      }
      v22 = (double)v26 * dbl_90D6E;
    }
    v26 = (int)v22;
    goto LABEL_71;
  }
  return i;
}
// 90D6E: using guessed type double dbl_90D6E;
// 90D76: using guessed type double dbl_90D76;
// 10529F: using guessed type int dword_10529F;

//----- (00020B3C) --------------------------------------------------------
int __fastcall sub_20B3C(int a1)
{
  int v2; // esi
  int i; // eax
  __int16 j; // di
  int v5; // ecx
  __int16 k; // ax
  int v7; // edx
  int v9[107]; // [esp+0h] [ebp-1CCh] BYREF
  unsigned __int8 v10; // [esp+1ACh] [ebp-20h]
  unsigned __int8 v11; // [esp+1B0h] [ebp-1Ch]

  v11 = 1 << byte_104BEA;
  v2 = a1 + 0xDB5;
  v10 = sub_43374((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], 0xFFFFFFFF);
  if ( !*(_WORD *)(a1 + 4) )
  {
    for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); ++i )
    {
      byte_D8460[(__int16)i] &= ~1u;
    }
  }
  for ( j = 0; j < *(__int16 *)(a1 + 0x3335); v2 += 0x60 )
  {
    if ( (byte_D8460[j] & 1) == 0 )
    {
      byte_D8460[j] |= 1u;
      if ( (v11 & *(_BYTE *)(v2 + 0x15)) != 0 && (v10 & *(_BYTE *)(v2 + 0x15)) != 0 )
      {
        v5 = sub_1D794((__int16 *)v2, v9);
        for ( k = 0; k < v5; ++k )
        {
          v7 = *(__int16 *)(v9[k] + 0x56);
          if ( (v7 == (unsigned __int8)byte_104BEA || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v7] == 2)
            && *(int *)(v9[k] + 0x88) > 0 )
          {
            ++*(_WORD *)(a1 + 4);
            return v2;
          }
        }
      }
    }
    ++j;
  }
  return 0;
}
// 20B3C: using guessed type int var_1CC[107];

//----- (00020C94) --------------------------------------------------------
char __fastcall sub_20C94(int a1, int a2, int a3, int a4)
{
  __int16 v5; // cx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  char *v11; // esi
  int v12; // edx
  int v13; // esi
  __int16 *v14; // esi
  int v15; // ebx
  __int16 v16; // dx
  __int16 i; // cx
  __int16 v18; // dx
  int v19; // eax
  int v20; // edx
  int j; // eax
  int v22; // eax
  char v23; // ch
  int v25; // [esp-10h] [ebp-1E8h]
  int v26; // [esp-Ch] [ebp-1E4h]
  int v27; // [esp-8h] [ebp-1E0h]
  int v28; // [esp-4h] [ebp-1DCh]
  int v29[107]; // [esp+0h] [ebp-1D8h] BYREF
  FILE *fp; // [esp+1ACh] [ebp-2Ch]
  const char *v31; // [esp+1B0h] [ebp-28h]
  const char *v32; // [esp+1B4h] [ebp-24h]
  const char *v33; // [esp+1B8h] [ebp-20h]
  int v34; // [esp+1BCh] [ebp-1Ch]

  if ( dword_A0D00 == 0xFFFFFFFF && *(int *)a1 >= 0x1388 )
  {
    v5 = rand() % 0x15;
    v6 = rand() % 5 + 3;
    v7 = rand();
    sub_1E10C(a1, v7 % 0x4C + 0x19, v6, v5);
    sub_1F038(a1);
    sub_1F404(a1);
    sub_1EEA4(a1);
    v8 = rand();
    sub_1EE08(a1, v8 % 6);
    *(_DWORD *)a1 = 0;
    v9 = sub_56E18((int)&V_Type3_stru_10AE70, "RACECONTROLS", 1, 0);
    a4 = v9;
    if ( !v9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x9B7);
    }
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v9 + 0xA7) + 0xC))(v9, 0);
  }
  *(_WORD *)(a1 + 4) = 0;
  memset(byte_D8460, 0, sizeof(byte_D8460));
  sub_21170(a1);
  sub_21314(a1);
  v10 = 0;
  sub_466FC((unsigned int)&word_105258);
  v11 = (char *)&loc_18247 + a1;
  while ( v10 < *(int *)((char *)&loc_27281 + a1) >> 0x10 )
  {
    sub_352E0((int)v11);
    ++v10;
    v11 += 0x7B;
  }
  sub_2106C(a1);
  v12 = 0;
  v13 = a1 + 6;
  while ( v12 < *(__int16 *)(a1 + 0xD88) )
  {
    if ( v12 != (unsigned __int8)byte_104BEA )
    {
      sub_3B220(v13, v12, 0x64, a4);
    }
    v13 += 0x1EE;
    ++v12;
  }
  sub_3B220((int)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], (unsigned __int8)byte_104BEA, 0x64, a4);
  if ( dword_A0CFC == 0xFFFFFFFF )
  {
    v14 = word_A3D21;
    fp = fopen("numships.dbg", "at");
    v34 = 0;
    if ( word_A62A1 > 0 )
    {
      v31 = (const char *)&word_A3D21[0xE];
      do
      {
        v15 = sub_1D794(v14, v29);
        v16 = 0;
        if ( SHIWORD(dword_A3CF2) > 0 )
        {
          v33 = v31;
          do
          {
            if ( ((1 << v16) & *((unsigned __int8 *)v14 + 0x15)) != 0 )
            {
              for ( i = 0; i < v15 && v16 != *(_WORD *)(v29[i] + 0x56); ++i )
              {
                ;
              }
              if ( i >= v15 )
              {
                v27 = *((unsigned __int8 *)v14 + 0x15);
                ++word_D845C;
                fprintf(fp, "T%04d: %s flags (%d) show R%d ship, but none found.\n", *(_DWORD *)a1 + 1, v33, v27, v16);
              }
            }
            ++v16;
          }
          while ( v16 < SHIWORD(dword_A3CF2) );
        }
        v18 = 0;
        v32 = v31;
        while ( v18 < v15 )
        {
          v19 = v29[v18];
          if ( *(_BYTE *)(v19 + 0x58) != 1 && ((1 << *(_WORD *)(v19 + 0x56)) & *((unsigned __int8 *)v14 + 0x15)) == 0 )
          {
            v28 = *((unsigned __int8 *)v14 + 0x15);
            v26 = *(__int16 *)(v19 + 0x56);
            v25 = *(_DWORD *)a1 + 1;
            ++word_D845C;
            fprintf(fp, "T%04d: R%d ship exists at %s, flags (%d) indicate otherwise.\n", v25, v26, v32, v28);
          }
          ++v18;
        }
        v14 += 0x30;
        v31 += 0x60;
        ++v34;
      }
      while ( (__int16)v34 < word_A62A1 );
    }
    fclose(fp);
  }
  v20 = a1 + 0x3337;
  for ( j = 0; (__int16)j < word_A792F; v20 += 0x27 )
  {
    *(_WORD *)(v20 + 0x21) = 0;
    ++j;
  }
  v22 = 0x1EE * (unsigned __int8)byte_104BEA;
  if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*(int *)((char *)&dword_A2F79 + v22) + 0x14)) != 0 )
  {
    *(_DWORD *)(a1 + 0x354EB) = 1;
    LOBYTE(v22) = sub_1FFE0(a1, *(int *)((char *)&dword_A2F79 + v22));
  }
  else
  {
    *(_DWORD *)(a1 + 0x354EB) = 0;
  }
  v23 = byte_30700[a1];
  ++*(_DWORD *)a1;
  if ( !v23 && !dword_A0D00 )
  {
    LOBYTE(v22) = sub_207A0(a1);
  }
  return v22;
}
// A0CFC: using guessed type int dword_A0CFC;
// A0D00: using guessed type int dword_A0D00;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// A792F: using guessed type __int16 word_A792F;
// D845C: using guessed type __int16 word_D845C;
// 20C94: using guessed type int var_1D8[107];

//----- (0002106C) --------------------------------------------------------
int __fastcall sub_2106C(int result)
{
  int v1; // edi
  __int16 i; // si
  int v3; // edx
  __int16 j; // si
  __int16 v5; // bx
  __int16 k; // ax
  size_t v7; // [esp+0h] [ebp-20h] BYREF
  __int16 v8; // [esp+4h] [ebp-1Ch]

  v1 = result;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    v3 = 6 * i;
    v7 = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * i], 0, &v7);
    *(_WORD *)(v3 + v1 + 0xD8C) = v7;
    result = sub_402E0(&byte_A2F72[0x1EE * i]);
    *(_WORD *)(v3 + v1 + 0xD8E) = result;
  }
  for ( j = 0; j < SHIWORD(dword_A3CF2); ++j )
  {
    v8 = *(_WORD *)(v1 + 6 * j + 0xD8E) + *(_WORD *)(v1 + 6 * j + 0xD8C);
    v5 = 0;
    for ( k = 0; k < SHIWORD(dword_A3CF2); ++k )
    {
      if ( j != k && *(__int16 *)(6 * k + v1 + 0xD8C) + *(__int16 *)(6 * k + v1 + 0xD8E) > v8 )
      {
        ++v5;
      }
    }
    result = 6 * j;
    *(_WORD *)(v1 + result + 0xD8A) = v5;
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;

//----- (00021170) --------------------------------------------------------
unsigned __int8 __fastcall sub_21170(int a1)
{
  int v2; // esi
  unsigned __int8 result; // al
  int i; // ecx
  unsigned __int8 v5; // [esp+0h] [ebp-18h]

  v2 = a1 + 0xDB5;
  result = 1 << byte_104BEA;
  v5 = 1 << byte_104BEA;
  for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); v2 += 0x60 )
  {
    result = *(_BYTE *)(v2 + 0x14) | *(_BYTE *)(v2 + 0x15);
    *(_DWORD *)(v2 + 0x5C) = 0;
    if ( (result & v5) == 0 )
    {
      if ( result )
      {
        result = sub_211EC(a1, v2, 0);
      }
      *(_DWORD *)(v2 + 0x5C) = 0xFFFFFFFF;
    }
    ++i;
  }
  return result;
}

//----- (000211EC) --------------------------------------------------------
int __fastcall sub_211EC(int a1, int a2, int a3)
{
  __int16 v6; // cx
  __int16 v7; // ax
  int v8; // ebx
  int result; // eax
  int v10; // ebp
  int v11; // edi
  __int16 v12; // cx
  __int16 v13[8]; // [esp+2h] [ebp-2Ch]
  unsigned __int8 v14; // [esp+12h] [ebp-1Ch] BYREF
  int v15; // [esp+13h] [ebp-1Bh]
  int v16; // [esp+1Ah] [ebp-14h]

  if ( dword_A0D00 == 0xFFFFFFFF )
  {
    a3 = dword_A0D00;
  }
  v6 = *(_WORD *)(a1 + 0xD88);
  v7 = 0;
  LOWORD(v16) = 0;
  if ( v6 > 0 )
  {
    do
    {
      if ( (a3 || v7 != (unsigned __int8)byte_104BEA)
        && ((unsigned __int8)(*(_BYTE *)(a2 + 0x15) | *(_BYTE *)(a2 + 0x14)) & (unsigned __int8)(1 << v7)) != 0 )
      {
        v8 = (__int16)v16;
        LOWORD(v16) = v16 + 1;
        v13[v8] = v7;
      }
      ++v7;
    }
    while ( v7 < *(__int16 *)(a1 + 0xD88) );
  }
  result = (__int16)v16;
  if ( (_WORD)v16 )
  {
    v10 = a1 + 6;
    while ( 1 )
    {
      result = v16;
      v11 = 0;
      v12 = 0;
      if ( (__int16)v16 > 0 )
      {
        break;
      }
LABEL_15:
      if ( !v11 )
      {
        return result;
      }
    }
    while ( 1 )
    {
      v14 = 0;
      result = sub_406C4((unsigned __int8 *)(v10 + 0x1EE * v13[v12]), (__int16 *)a2, (int)&v14);
      v11 |= result;
      BYTE1(result) = v14;
      if ( !v14 )
      {
        goto LABEL_14;
      }
      if ( v14 < 2u )
      {
        break;
      }
      if ( v14 <= 2u )
      {
        result = sub_3676C(v15, 1);
      }
      else
      {
        if ( v14 != 3 )
        {
          break;
        }
        result = sub_49B3C(v15, 1);
      }
LABEL_14:
      if ( ++v12 >= (__int16)v16 )
      {
        goto LABEL_15;
      }
    }
    result = 0;
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0xAE2);
    goto LABEL_14;
  }
  return result;
}
// A0D00: using guessed type int dword_A0D00;
// 211EC: using guessed type __int16 var_2C[8];

//----- (00021314) --------------------------------------------------------
void __fastcall sub_21314(int a1)
{
  int v2; // ecx
  int i; // edi

  v2 = a1 + 0xDB5;
  for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); v2 += 0x60 )
  {
    if ( *(_DWORD *)(v2 + 0x5C) != 0xFFFFFFFF )
    {
      if ( *(unsigned __int8 *)(v2 + 0x14) | *(unsigned __int8 *)(v2 + 0x15) )
      {
        sub_211EC(a1, v2, 0xFFFFFFFF);
      }
      *(_DWORD *)(v2 + 0x5C) = 0xFFFFFFFF;
    }
    ++i;
  }
  JUMPOUT(0x211E4);
}
// 2132D: control flows out of bounds to 211E4

//----- (00021374) --------------------------------------------------------
int __fastcall sub_21374(int a1, unsigned int count)
{
  __int16 v3; // cx
  int v4; // esi
  __int16 v5; // cx
  char *v6; // esi
  __int16 v7; // si
  __int16 v8; // cx
  char *v9; // edi
  int v10; // eax
  __int16 v11; // cx
  int v12; // esi
  __int16 v13; // cx
  int v14; // esi
  int v15; // edx
  __int16 v16; // si
  int i; // eax
  __int16 v18; // di
  __int16 v19; // bx
  int result; // eax
  __int16 v21; // cx
  int v22; // esi
  int v23[104]; // [esp+0h] [ebp-24Ch] BYREF
  int v24; // [esp+1A0h] [ebp-ACh] BYREF
  int v25; // [esp+1A4h] [ebp-A8h]
  int v26; // [esp+1A8h] [ebp-A4h]
  int v27; // [esp+1ACh] [ebp-A0h]
  int v28; // [esp+1B0h] [ebp-9Ch]
  int v29; // [esp+1B4h] [ebp-98h]
  int v30; // [esp+1B8h] [ebp-94h]
  int v31; // [esp+1BCh] [ebp-90h]
  char v32; // [esp+1C0h] [ebp-8Ch]
  __int16 v33; // [esp+1C1h] [ebp-8Bh]
  int v34; // [esp+1C3h] [ebp-89h]
  int v35[8]; // [esp+1C8h] [ebp-84h] BYREF
  int v36; // [esp+1E8h] [ebp-64h]
  int v37; // [esp+1ECh] [ebp-60h] BYREF
  int v38; // [esp+1F0h] [ebp-5Ch] BYREF
  int v39; // [esp+1F4h] [ebp-58h] BYREF
  int v40; // [esp+1F8h] [ebp-54h] BYREF
  int v41; // [esp+1FCh] [ebp-50h] BYREF
  int v42; // [esp+200h] [ebp-4Ch] BYREF
  int v43; // [esp+204h] [ebp-48h] BYREF
  int v44; // [esp+208h] [ebp-44h] BYREF
  int v45; // [esp+20Ch] [ebp-40h] BYREF
  int v46; // [esp+210h] [ebp-3Ch] BYREF
  int v47; // [esp+214h] [ebp-38h] BYREF
  int v48; // [esp+218h] [ebp-34h] BYREF
  int v49; // [esp+21Ch] [ebp-30h] BYREF
  int v50; // [esp+220h] [ebp-2Ch] BYREF
  int v51; // [esp+224h] [ebp-28h] BYREF
  int v52; // [esp+228h] [ebp-24h] BYREF
  int v53; // [esp+22Ch] [ebp-20h] BYREF
  int v54; // [esp+230h] [ebp-1Ch]
  int v55; // [esp+234h] [ebp-18h]

  v36 = a1;
  v35[0] = 0x1D72;
  v35[1] = 0x60;
  v35[2] = 0x7B;
  v35[3] = 0x1EE;
  v35[5] = 0x19E;
  v35[6] = 0xD;
  v35[7] = 0x354EF;
  v35[4] = 0x27;
  sub_1C098(count, (int)v35, 0x20u);
  v37 = *(_DWORD *)v36;
  sub_1C098(count, (int)&v37, 4u);
  v38 = *(__int16 *)(*(_DWORD *)(v36 + 0x306F4) + 4);
  sub_1C098(count, (int)&v38, 4u);
  v39 = (*(_DWORD *)(v36 + 0x306F8) - ((int)&loc_18247 + v36)) / 0x7B;
  sub_1C098(count, (int)&v39, 4u);
  v40 = *(char *)(v36 + 0x30700);
  sub_1C098(count, (int)&v40, 4u);
  v41 = *(_DWORD *)(v36 + 0x306FC);
  sub_1C098(count, (int)&v41, 4u);
  v42 = dword_105248;
  sub_1C098(count, (int)&v42, 4u);
  v43 = dword_10524C;
  sub_1C098(count, (int)&v43, 4u);
  v44 = dword_105250;
  sub_1C098(count, (int)&v44, 4u);
  sub_46BB0(&word_105258, count, 0);
  v45 = *(__int16 *)(v36 + 0x3335);
  sub_1C098(count, (int)&v45, 4u);
  v3 = 0;
  if ( *(__int16 *)(v36 + 0x3335) > 0 )
  {
    v4 = v36 + 0xDB5;
    do
    {
      sub_1D920(v4 + 0x60 * v3++, count, 0);
    }
    while ( v3 < *(__int16 *)(v36 + 0x3335) );
  }
  v46 = *(_DWORD *)((char *)&loc_18241 + SHIWORD(v36) + 2);
  sub_1C098(count, (int)&v46, 4u);
  sub_1C098(count, v36 + 0x49C5, 4 * *(_DWORD *)((char *)&loc_18241 + SHIWORD(v36) + 2));
  v47 = *(_DWORD *)((char *)&loc_27281 + SHIWORD(v36));
  sub_1C098(count, (int)&v47, 4u);
  v5 = 0;
  if ( *(__int16 *)((char *)&loc_27281 + v36 + 2) > 0 )
  {
    v6 = (char *)&loc_18247 + v36;
    do
    {
      sub_370B8((int)&v6[0x7B * v5++], count, 0);
    }
    while ( v5 < *(__int16 *)((char *)&loc_27281 + v36 + 2) );
  }
  v7 = 0;
  v8 = 0;
  v48 = *(__int16 *)(v36 + 0x3067B);
  v9 = (char *)&loc_27281 + v36 + 4;
  sub_1C098(count, (int)&v48, 4u);
  while ( v8 < 0x6B )
  {
    v10 = v36 + 0x162 * v8;
    if ( *(int *)((char *)&loc_272D8 + v10 + 1) >> 0x10 != 0xFFFFFFFF )
    {
      if ( !*((_BYTE *)&loc_272D8 + v10 + 5) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB57);
      }
      v49 = v8;
      sub_1C098(count, (int)&v49, 4u);
      ++v7;
      sub_4AE8C((int)&v9[0x162 * v8], count, 0);
    }
    ++v8;
  }
  if ( v7 != *(_WORD *)((char *)sub_3067B + v36) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB65);
  }
  v50 = *(__int16 *)(v36 + 0xD88);
  sub_1C098(count, (int)&v50, 4u);
  v11 = 0;
  if ( *(__int16 *)(v36 + 0xD88) > 0 )
  {
    v12 = v36 + 6;
    do
    {
      sub_43BDC(v12 + 0x1EE * v11++, count, 0);
    }
    while ( v11 < *(__int16 *)(v36 + 0xD88) );
  }
  v51 = *(__int16 *)(v36 + 0x49C3);
  sub_1C098(count, (int)&v51, 4u);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v30 = 0;
  v31 = 0;
  v29 = 0;
  v13 = 0;
  if ( *(__int16 *)(v36 + 0x49C3) > 0 )
  {
    v14 = v36 + 0x3337;
    do
    {
      v15 = v14 + 0x27 * v13;
      v24 = *(_DWORD *)v15;
      v25 = *(_DWORD *)(v15 + 4);
      v26 = *(_DWORD *)(v15 + 8);
      v27 = *(_DWORD *)(v15 + 0xC);
      v28 = *(_DWORD *)(v15 + 0x10);
      v29 = *(_DWORD *)(v15 + 0x14);
      v30 = *(_DWORD *)(v15 + 0x18);
      v31 = *(_DWORD *)(v15 + 0x1C);
      v32 = *(_BYTE *)(v15 + 0x20);
      v33 = *(_WORD *)(v15 + 0x21);
      v34 = *(_DWORD *)(v15 + 0x23);
      v24 = *(__int16 *)(v24 + 4);
      v25 = *(__int16 *)(v25 + 4);
      sub_1C098(count, (int)&v24, 0x27u);
      ++v13;
    }
    while ( v13 < *(__int16 *)(v36 + 0x49C3) );
  }
  sub_1C098(count, (int)&byte_32DDB[v36], 0x2710u);
  v52 = *(__int16 *)(v36 + 0x32DD1);
  sub_1C098(count, (int)&v52, 4u);
  *(int *)((char *)&v23[0x65] + 2) = 0;
  *(int *)((char *)&v23[0x66] + 2) = 0;
  *(int *)((char *)&v23[0x64] + 2) = 0;
  v16 = *(_WORD *)(v36 + 0x32DD1);
  LOWORD(v55) = 0;
  if ( v16 > 0 )
  {
    v54 = (int)&off_30701 + v36;
    do
    {
      qmemcpy(v23, (const void *)(v54 + 0x19E * (__int16)v55), 0x19Eu);
      for ( i = 0; (__int16)i < SLOWORD(v23[0x64]); ++i )
      {
        v23[(__int16)i] = *(__int16 *)(v23[(__int16)i] + 4);
      }
      v18 = v55;
      sub_1C098(count, (int)v23, 0x19Eu);
      v19 = *(_WORD *)(v36 + 0x32DD1);
      LOWORD(v55) = v18 + 1;
    }
    while ( (__int16)(v18 + 1) < v19 );
  }
  v53 = *(_DWORD *)((char *)sub_306F0 + SHIWORD(v36));
  sub_1C098(count, (int)&v53, 4u);
  result = v36;
  v21 = 0;
  if ( *(__int16 *)(v36 + 0x306F2) > 0 )
  {
    v22 = v36 + 0x3067D;
    do
    {
      sub_1C098(count, v22 + 0xD * v21, 0xDu);
      result = v36;
      ++v21;
    }
    while ( v21 < *(__int16 *)(v36 + 0x306F2) );
  }
  return result;
}
// 3067B: using guessed type int sub_3067B();
// 306F0: using guessed type int sub_306F0();
// 30701: using guessed type void *off_30701;
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00021AA0) --------------------------------------------------------
__int16 __fastcall sub_21AA0(int a1, unsigned int count)
{
  __int16 v4; // ax
  __int16 v5; // cx
  int v6; // eax
  int v7; // ebp
  __int16 v8; // ax
  __int16 v9; // cx
  int v10; // eax
  __int16 i; // ax
  int v12; // edx
  __int16 v13; // cx
  __int16 v14; // ax
  __int16 v15; // cx
  int v16; // eax
  __int16 v17; // ax
  int v18; // ebp
  int v19; // ecx
  int v20; // ebx
  int v21; // eax
  int v22; // edx
  int v23; // eax
  int v24; // ebp
  __int16 v25; // cx
  int j; // eax
  __int16 v27; // dx
  __int16 v28; // ax
  __int16 v29; // cx
  void *v30; // edx
  int v32[100]; // [esp+0h] [ebp-1F4h] BYREF
  _WORD v33[3]; // [esp+190h] [ebp-64h]
  int v34; // [esp+196h] [ebp-5Eh]
  int v35; // [esp+19Ah] [ebp-5Ah]
  int v36[8]; // [esp+1A0h] [ebp-54h] BYREF
  int v37; // [esp+1C0h] [ebp-34h] BYREF
  int v38; // [esp+1C4h] [ebp-30h]
  int v39; // [esp+1C8h] [ebp-2Ch]
  int v40; // [esp+1CCh] [ebp-28h]
  int v41; // [esp+1D0h] [ebp-24h]
  __int16 v42; // [esp+1D4h] [ebp-20h]
  int v43; // [esp+1D8h] [ebp-1Ch]
  int v44; // [esp+1DCh] [ebp-18h]

  sub_1BF94((P_Type1)count, v36, 0x20u);
  if ( v36[0] != 0x1D72 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAA);
  }
  if ( v36[1] != 0x60 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAB);
  }
  if ( v36[2] != 0x7B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAC);
  }
  if ( v36[3] != 0x1EE )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAD);
  }
  if ( v36[4] != 0x27 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAE);
  }
  if ( v36[5] != 0x19E )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAF);
  }
  if ( v36[6] != 0xD )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBB0);
  }
  if ( v36[7] != 0x354EF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBB1);
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)a1 = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)(a1 + 0x306F4) = 0x60 * v37 + a1 + 0xDB5;
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)(a1 + 0x306F8) = (char *)&loc_18247 + 0x7B * v37 + a1;
  sub_1BF94((P_Type1)count, &v37, 4u);
  byte_30700[a1] = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)(a1 + 0x306FC) = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  dword_105248 = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  dword_10524C = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  dword_105250 = v37;
  sub_46BB0(&word_105258, count, 0xFFFFFFFF);
  sub_1BF94((P_Type1)count, &v37, 4u);
  v4 = v37;
  v5 = 0;
  *(_WORD *)(a1 + 0x3335) = v37;
  if ( v4 > 0 )
  {
    do
    {
      v6 = a1 + 0xDB5 + 0x60 * v5++;
      sub_1D920(v6, count, 0xFFFFFFFF);
    }
    while ( v5 < *(__int16 *)(a1 + 0x3335) );
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_WORD *)((char *)&loc_18241 + a1 + 4) = v37;
  v7 = a1 + 0x49C5;
  sub_1BF94((P_Type1)count, (void *)(a1 + 0x49C5), 4 * (*(int *)((char *)&loc_18241 + a1 + 2) >> 0x10));
  sub_1BF94((P_Type1)count, &v37, 4u);
  v8 = v37;
  v9 = 0;
  *(_WORD *)((char *)&loc_27281 + a1 + 2) = v37;
  if ( v8 > 0 )
  {
    v40 = (int)&loc_18247 + a1;
    do
    {
      v38 = 0x7B * v9;
      sub_370B8(v38 + v40, count, 0xFFFFFFFF);
      v10 = v38;
      *(_DWORD *)((char *)&loc_18253 + a1 + v38 + 4) = v7;
      ++v9;
      v7 += 4 * *(unsigned __int16 *)((char *)&loc_1825F + a1 + v10 + 2);
    }
    while ( v9 < *(__int16 *)((char *)&loc_27281 + a1 + 2) );
  }
  for ( i = 0; i < 0x6B; ++i )
  {
    v12 = 0x162 * i;
    *(_WORD *)((char *)&loc_272D8 + v12 + a1 + 3) = 0xFFFF;
    *((_BYTE *)&loc_272D8 + v12 + a1 + 5) = 0;
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v13 = 0;
  *(_WORD *)((char *)&loc_3067B + a1) = v37;
  while ( v13 < 0x6B )
  {
    if ( v13 < *(__int16 *)((char *)&loc_3067B + a1) )
    {
      sub_1BF94((P_Type1)count, &v37, 4u);
      sub_4AE8C((int)&loc_27281 + 0x162 * v37 + a1 + 4, count, 0xFFFFFFFF);
    }
    ++v13;
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v14 = v37;
  v15 = 0;
  *(_WORD *)(a1 + 0xD88) = v37;
  if ( v14 > 0 )
  {
    do
    {
      v16 = a1 + 6 + 0x1EE * v15++;
      sub_43BDC(v16, count, 0xFFFFFFFF);
    }
    while ( v15 < *(__int16 *)(a1 + 0xD88) );
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v17 = v37;
  LOWORD(v43) = 0;
  *(_WORD *)(a1 + 0x49C3) = v37;
  if ( v17 > 0 )
  {
    v41 = a1 + 0x3337;
    v39 = a1 + 0xDB5;
    do
    {
      v18 = 0x27 * (__int16)v43;
      v19 = v18 + v41;
      sub_1BF94((P_Type1)count, (void *)(v18 + v41), 0x27u);
      v20 = v39 + 0x60 * *(_DWORD *)(a1 + v18 + 0x3337);
      v21 = 0x60 * *(_DWORD *)(a1 + v18 + 0x333B);
      v22 = v39;
      *(_DWORD *)(a1 + v18 + 0x3337) = v20;
      v23 = v22 + v21;
      *(_DWORD *)(a1 + v18 + 0x333B) = v23;
      v42 = *(_WORD *)(v20 + 0x44);
      v24 = v42;
      *(_WORD *)(v20 + 0x44) = v42 + 1;
      *(_DWORD *)(v20 + 4 * v24 + 0x2C) = v19;
      LOWORD(v22) = *(_WORD *)(v23 + 0x44);
      *(_WORD *)(v23 + 0x44) = v22 + 1;
      *(_DWORD *)(4 * (__int16)v22 + v23 + 0x2C) = v19;
      LOWORD(v22) = *(_WORD *)(a1 + 0x49C3);
      LOWORD(v43) = v43 + 1;
    }
    while ( (__int16)v43 < (__int16)v22 );
  }
  sub_1BF94((P_Type1)count, &byte_32DDB[a1], 0x2710u);
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_WORD *)(a1 + 0x32DD1) = v37;
  v34 = 0;
  v35 = 0;
  *(_DWORD *)&v33[1] = 0;
  v25 = *(_WORD *)(a1 + 0x32DD1);
  v44 = 0;
  if ( v25 > 0 )
  {
    do
    {
      sub_1BF94((P_Type1)count, v32, 0x19Eu);
      for ( j = 0; (__int16)j < v33[0]; ++j )
      {
        v32[(__int16)j] = a1 + 0xDB5 + 0x60 * v32[(__int16)j];
      }
      v27 = *(_WORD *)(a1 + 0x32DD1);
      ++v44;
    }
    while ( (__int16)v44 < v27 );
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v28 = v37;
  v29 = 0;
  *(_WORD *)(a1 + 0x306F2) = v37;
  if ( v28 > 0 )
  {
    do
    {
      v30 = (void *)(0xD * v29++ + a1 + 0x3067D);
      sub_1BF94((P_Type1)count, v30, 0xDu);
    }
    while ( v29 < *(__int16 *)(a1 + 0x306F2) );
  }
  return sub_1EEA4(a1);
}
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;
// 21AA0: using guessed type int var_1F4[100];

//----- (000220CC) --------------------------------------------------------
__int16 __fastcall sub_220CC(int a1)
{
  __int16 v2; // di
  __int16 v3; // dx
  double v4; // st6
  __int16 v5; // bx
  __int16 i; // dx
  float *v7; // ebx
  float *v8; // eax
  __int16 result; // ax
  double v10[7]; // [esp+8h] [ebp-84h] BYREF
  float v11; // [esp+40h] [ebp-4Ch]
  float v12; // [esp+44h] [ebp-48h]
  float v13; // [esp+48h] [ebp-44h]
  float v14; // [esp+4Ch] [ebp-40h]
  float v15; // [esp+50h] [ebp-3Ch]
  float v16; // [esp+54h] [ebp-38h]
  int v17[6]; // [esp+58h] [ebp-34h] BYREF
  int v18; // [esp+70h] [ebp-1Ch]

  v2 = 0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  memset(v10, 0, sizeof(v10));
  v3 = *(_WORD *)(a1 + 0xD88);
  *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = 0;
  if ( v3 > 0 )
  {
    do
    {
      for ( i = 0; i < *(__int16 *)(a1 + 0xD88); ++i )
      {
        if ( v2 != i )
        {
          v7 = *(float **)(a1 + 0x1EE * i + 0xD);
          v8 = *(float **)(a1 + 0x1EE * v2 + 0xD);
          v17[5] = (int)v17;
          v11 = 0.0;
          v12 = 0.0;
          v13 = 0.0;
          v11 = v8[2] - v7[2];
          v12 = v8[3] - v7[3];
          v13 = v8[4] - v7[4];
          *(float *)v17 = v11;
          *(float *)&v17[1] = v12;
          *(float *)&v17[2] = v13;
          v14 = v11;
          v15 = v12;
          v16 = v13;
          v10[v2] = sqrt(v12 * v12 + v11 * v11 + v13 * v13) + v10[v2];
        }
      }
      v18 = *(__int16 *)(a1 + 0xD88) - 1;
      v10[v2] = v10[v2] / (double)v18;
      v4 = (double)*(__int16 *)((char *)&loc_32DD2 + a1 + 1) + v10[v2++];
      v18 = (int)v4;
      v5 = *(_WORD *)(a1 + 0xD88);
      *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = (int)v4;
    }
    while ( v2 < v5 );
  }
  result = *(__int16 *)((char *)&loc_32DD2 + a1 + 1) / *(__int16 *)(a1 + 0xD88);
  *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = result;
  return result;
}
// 220CC: using guessed type double var_84[7];

//----- (00022260) --------------------------------------------------------
int __fastcall sub_22260(int a1)
{
  return _wcpp_2_dtor_array_(a1, 7, &unk_95AF0);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022280) --------------------------------------------------------
int __fastcall sub_22280(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x64, &unk_95B04);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (000222A0) --------------------------------------------------------
int __fastcall sub_222A0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x6B, &unk_95AB4);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (000222C0) --------------------------------------------------------
int __fastcall sub_222C0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x18, &unk_95A8C);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (000222E0) --------------------------------------------------------
int __fastcall sub_222E0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 9, &unk_95AA0);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022300) --------------------------------------------------------
int __fastcall sub_22300(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x1F4, &unk_95AC8);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022320) --------------------------------------------------------
int __fastcall sub_22320(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x94, &unk_95ADC);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022360) --------------------------------------------------------
_DWORD *__fastcall sub_22360(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 8);
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return v1 + 0xFFFFFFFB;
}

//----- (000223B0) --------------------------------------------------------
char *__fastcall sub_223B0(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 1);
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return (char *)v1 + 0xFFFFFFFF;
}

//----- (000223E0) --------------------------------------------------------
char *__fastcall sub_223E0(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 0x192);
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return (char *)v1 + 0xFFFFFE6E;
}

//----- (00022400) --------------------------------------------------------
int __fastcall sub_22400(int result)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_WORD *)(result + 0x1A) = 0;
  *(_DWORD *)(result + 0x10) = 0;
  *(_DWORD *)(result + 0x5A) = 0;
  return result;
}

//----- (00022430) --------------------------------------------------------
int __fastcall sub_22430(const void *a1, const void *a2)
{
  int v2; // edx
  float v4; // [esp+0h] [ebp-8h]
  float v5; // [esp+4h] [ebp-4h]

  v5 = *(float *)(*(_DWORD *)a1 + 0xD);
  v4 = *(float *)(*(_DWORD *)a2 + 0xD);
  v2 = 0;
  if ( v5 > (double)v4 )
  {
    return 0xFFFFFFFF;
  }
  if ( v5 < (double)v4 )
  {
    return 1;
  }
  return v2;
}

//----- (00022468) --------------------------------------------------------
int sub_22468()
{
  int result; // eax

  result = sub_56E18((int)&V_Type3_stru_10AE70, "NEXTTURNCONT", 1, 0);
  if ( !result )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x69);
  }
  *(_DWORD *)(result + 0xAB) = 0;
  return result;
}

//----- (000224A4) --------------------------------------------------------
char *__fastcall sub_224A4(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // eax
  char v3; // cl
  char *result; // eax

  sub_2C830((P_TypeA2)a1);
  v1 = sub_1B4F0((_DWORD *)(a1 + 0xDA));
  v2 = (_DWORD *)sub_254A4((int)(v1 + 0x26));
  *(_DWORD *)((char *)v2 + 0xFFFFFF35) = off_95BB4;
  *(_DWORD *)((char *)v2 + 0xFFFFFF39) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF3D) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF41) = 0;
  *(_WORD *)((char *)v2 + 0xFFFFFF45) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF49) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF4E) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF52) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF56) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF5A) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF5E) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF62) = 0;
  v2[0x108] = 0;
  *((_BYTE *)v2 + 0xFFFFFF66) = 0xFF;
  v2[0x103] = 2;
  v2[0x107] = 0;
  v2[0x106] = 0;
  v3 = byte_104BEA;
  v2[0x104] = 0;
  result = (char *)v2 + 0xFFFFFE8E;
  result[0xD9] = 1 << v3;
  return result;
}
// 95BB4: using guessed type int (*off_95BB4[2])();

//----- (00022588) --------------------------------------------------------
char *__fastcall sub_22588(char *a1, char a2)
{
  char *v2; // ebx
  void *v4; // eax
  void *v5; // edx
  int v6; // eax
  int v7; // eax
  char *v8; // eax

  v2 = a1;
  if ( (a2 & 4) != 0 )
  {
    v4 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95B70);
    operator delete[](v4);
  }
  else
  {
    v5 = *(void **)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xA7) = off_95BB4;
    if ( v5 )
    {
      sub_2627C(v5);
    }
    operator delete[](*(void **)(v2 + 0xAB));
    if ( *(_DWORD *)(v2 + 0xAF) )
    {
      sub_2627C(*(void **)(v2 + 0xAF));
    }
    operator delete[](*(void **)(v2 + 0xAF));
    if ( *(_DWORD *)(v2 + 0xB3) )
    {
      sub_2627C(*(void **)(v2 + 0xB3));
    }
    operator delete[](*(void **)(v2 + 0xB3));
    v6 = sub_254B0((int)(v2 + 0x172));
    v7 = ((int (__fastcall *)(int, _DWORD))locret_1B66C)(v6 - 0x98, 0);
    v8 = (char *)sub_2C848(v7 - 0xDA, 1);
    v2 = v8;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v8);
    }
  }
  return v2;
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95BB4: using guessed type int (*off_95BB4[2])();

//----- (00022644) --------------------------------------------------------
unsigned int __fastcall Q_COSWND_CPP_sub_22644(int a1, const char *a2, const char *a3)
{
  void *v4; // eax
  int v5; // ecx
  const char *v6; // edx
  void *v7; // eax
  int v8; // ebx
  __int16 v9; // ax
  void *v10; // eax
  void *v11; // eax
  T_Type1 v13; // [esp+0h] [ebp-128h] BYREF

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x9E);
  }
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x9F);
  }
  Q_InitFileInfo_sub_1BB78(&v13);
  if ( *(_DWORD *)(a1 + 0xAB) )
  {
    sub_2627C(*(void **)(a1 + 0xAB));
  }
  operator delete[](*(void **)(a1 + 0xAB));
  if ( Q_CfilePreload_sub_1BBFC(&v13, a2, O_BINARY, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0xAA);
  }
  v4 = sub_1BF1C(&v13, 0);
  *(_DWORD *)(a1 + 0xAB) = v4;
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0xAC);
  }
  if ( *(_DWORD *)(a1 + 0xAF) )
  {
    sub_2627C(*(void **)(a1 + 0xAF));
  }
  operator delete[](*(void **)(a1 + 0xAF));
  HIWORD(v5) = 0;
  if ( Q_CfilePreload_sub_1BBFC(&v13, a3, O_BINARY, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0xB5);
  }
  v6 = 0;
  v7 = sub_1BF1C(&v13, 0);
  *(_DWORD *)(a1 + 0xAF) = v7;
  if ( !v7 )
  {
    v6 = "..\\coswnd.cpp";
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0xB7);
  }
  LOWORD(v7) = *(_WORD *)(a1 + 0x10) - *(_WORD *)(a1 + 8);
  LOWORD(v5) = *(_WORD *)(a1 + 0xC);
  *(_WORD *)(a1 + 0x576) = (_WORD)v7;
  v8 = (int)v7;
  v9 = *(_WORD *)(a1 + 0x14);
  LOWORD(v8) = (__int16)v8 >> 1;
  *(_WORD *)(a1 + 0x576) = v8;
  *(_WORD *)(a1 + 0x578) = (__int16)(v9 - v5) >> 1;
  sub_2280C(a1, (int)v6, v8, v5);
  if ( *(_DWORD *)(a1 + 0xB3) )
  {
    sub_2627C(*(void **)(a1 + 0xB3));
  }
  operator delete[](*(void **)(a1 + 0xB3));
  v10 = operator new[](0x1D1Fu);
  v11 = sub_2625C(v10, 1, "CW DISPLAYITEMS");
  *(_DWORD *)(a1 + 0xB3) = v11;
  if ( !v11 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0xCC);
  }
  *(_WORD *)(a1 + 0xB7) = 0;
  *(_WORD *)(a1 + 0xB9) = 0x163;
  Q_CloseFileAndDelete_sub_1BBC8(&v13);
  return 0xFFFFFFFF;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0002280C) --------------------------------------------------------
_DWORD *__fastcall sub_2280C(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // edx
  char *v5; // eax
  _DWORD *result; // eax

  v4 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 0x57A) = 0x420C0000;
  sub_1B808(
    (_DWORD *)(a1 + 0xDA),
    (int)v4,
    a3,
    a4,
    *(_DWORD *)((char *)v4 + 0x57A),
    0x3F800000,
    0x47C35000,
    *(__int16 *)(a1 + 0x576));
  v5 = (char *)v4 + 0x10E;
  *(_DWORD *)((char *)v4 + 0x10E) = 0;
  *(_DWORD *)((char *)v4 + 0x112) = 0;
  v4 = (_DWORD *)((char *)v4 + 0x14E);
  *((_DWORD *)v5 + 2) = 0xC4BB8000;
  *v4 = 0x3F800000;
  v4[1] = 0;
  result = v4 + 3;
  v4[2] = 0;
  v4[3] = 0;
  v4[4] = 0x3F800000;
  v4 += 6;
  result[2] = 0;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0x3F800000;
  return result;
}

//----- (000228A4) --------------------------------------------------------
#error "228A4: function frame is wrong (funcsize=0)"

//----- (00023BF0) --------------------------------------------------------
void __fastcall sub_23BF0(unsigned int a1, int a2)
{
  int v3; // eax
  int v4; // eax
  char *v5; // edi
  char *v6; // esi
  char v7; // al
  char v8; // al
  __int16 i; // si
  char v10; // dl
  int v11; // ebx
  int v12; // edx
  int v13; // ebx
  int v14; // edx
  const char *v15; // ecx
  int *v16; // eax
  int v17; // ebx
  int v18; // edx
  __int16 v19; // dx
  char *v20; // esi
  char *v21; // edi
  char v22; // al
  char v23; // al
  int v24; // ebx
  int v25; // edx
  char s[128]; // [esp+0h] [ebp-F8h] BYREF
  char v27[40]; // [esp+80h] [ebp-78h] BYREF
  _DWORD v28[9]; // [esp+A8h] [ebp-50h] BYREF
  char v29[20]; // [esp+CCh] [ebp-2Ch] BYREF
  int v30; // [esp+E0h] [ebp-18h]

  v30 = a2;
  sub_254F8(a1 + 0x172, a1);
  if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 3 )
  {
    v3 = sub_56E18((int)&V_Type3_stru_10AE70, "NEWGAMEWND", 3, 0);
    if ( !v3 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x414);
    }
    (*(void (__fastcall **)(int, int))(*(_DWORD *)(v3 + 0xA7) + 0xC))(v3, 1);
  }
  if ( *(_DWORD *)(a1 + 0xD4) == 0xFFFFFFFF )
  {
    sub_23FD4(a1);
  }
  if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 3 )
  {
    sub_53E38((P_Type5)(a1 + 4), 3, 3, (unsigned __int8)byte_104BEA);
  }
  if ( *(_DWORD *)(a1 + 0xBB) )
  {
    s[0] = 0;
    v16 = *(int **)(a1 + 0xBB);
    v10 = 1;
    if ( !*((_BYTE *)v16 + 4) )
    {
      v4 = *v16;
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(v4 + 0x17)) != 0 )
      {
        v5 = s;
        v6 = (char *)(v4 + 0x1C);
        do
        {
          v7 = *v6;
          *v5 = *v6;
          if ( !v7 )
          {
            break;
          }
          v8 = v6[1];
          v6 += 2;
          v5[1] = v8;
          v5 += 2;
        }
        while ( v8 );
        for ( i = 0;
              i < 7
           && (*(_BYTE *)(**(_DWORD **)(a1 + 0xBB) + 0x14) & (unsigned __int8)(*(_BYTE *)(a1 + 0xD9) & v10)) == 0;
              ++i )
        {
          v10 *= 2;
        }
      }
      v11 = *(_DWORD *)(a1 + 0x14) - 0x1B;
      v12 = *(_DWORD *)(a1 + 0x10) - 0x82;
      *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v12, v11, s, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v13 = *(_DWORD *)(a1 + 0x14) - 0xC;
      v14 = *(_DWORD *)(a1 + 0x10) - 0x82;
      v15 = &byte_D84C4[0x14 * ***(_DWORD ***)(a1 + 0xBB)];
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], v14, v13, v15, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
    }
  }
  if ( v30 != 0xA )
  {
    unk_D85E4 = *(_DWORD *)(a1 + 4);
    *((_DWORD *)&unk_D85E4 + 1) = *(_DWORD *)(a1 + 8);
    *((_DWORD *)&unk_D85E4 + 2) = *(_DWORD *)(a1 + 0xC);
    *((_DWORD *)&unk_D85E4 + 3) = *(_DWORD *)(a1 + 0x10);
    *((_DWORD *)&unk_D85E4 + 4) = *(_DWORD *)(a1 + 0x14);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&unk_D85E4);
  if ( dword_A0CFC == 0xFFFFFFFF && dword_A0CFC == *(_DWORD *)(a1 + 0x58E) )
  {
    sprintf(s, "STARS CONTROLLED %d", dword_D8457);
    *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xA, 0x18C, s, 0, 0xFFFFFFFF, 0xFF, 0);
    sprintf(s, "PERCENT CONTROLLED %d", 0x64 * dword_D8457 / word_A62A1);
    qmemcpy(v28, "Peaceful", sizeof(v28));
    sprintf(s, "%d Biorythym (%s)\n", word_104BE8, &v28[3 * byte_A3D20]);
    v17 = *(_DWORD *)(a1 + 0xC) + 0x1E;
    v18 = *(_DWORD *)(a1 + 8) + 5;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v18, v17, s, 0, 0xFFFFFFFF, 0xFF, 0);
    v19 = 0;
    s[0] = 0;
    qmemcpy(v27, "Unknown", sizeof(v27));
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      do
      {
        sprintf(
          v29,
          "R%d %10s %d\n",
          v19,
          &v27[0xA * (*(int *)((char *)&unk_A312F + 0x1EE * (unsigned __int8)byte_104BEA + v19) >> 0x18)],
          *(int *)((char *)&unk_A3122 + 0x1EE * (unsigned __int8)byte_104BEA + 2 * v19) >> 0x10);
        v20 = v29;
        ++v19;
        v21 = &s[strlen(s)];
        do
        {
          v22 = *v20;
          *v21 = *v20;
          if ( !v22 )
          {
            break;
          }
          v23 = v20[1];
          v20 += 2;
          v21[1] = v23;
          v21 += 2;
        }
        while ( v23 );
      }
      while ( v19 < SHIWORD(dword_A3CF2) );
    }
    v24 = *(_DWORD *)(a1 + 0xC) + 0x37;
    v25 = *(_DWORD *)(a1 + 8) + 5;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v25, v24, s, 0, 0xFFFFFFFF, 0xFF, 0);
  }
}
// 968DC: using guessed type char byte_968DC;
// A0CFC: using guessed type int dword_A0CFC;
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;
// A62A1: using guessed type __int16 word_A62A1;
// D8457: using guessed type int dword_D8457;
// 104BE8: using guessed type __int16 word_104BE8;
// 23BF0: using guessed type char s[128];
// 23BF0: using guessed type char var_78[40];

//----- (00023FD4) --------------------------------------------------------
int __fastcall sub_23FD4(int a1)
{
  char *v1; // ebp
  int v2; // esi
  int v3; // edi
  int result; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp-Ch] [ebp-44h]
  int v8; // [esp+0h] [ebp-38h]
  T_Type5 *v10; // [esp+8h] [ebp-30h]
  int v11; // [esp+Ch] [ebp-2Ch]
  int v12; // [esp+10h] [ebp-28h]
  char v13; // [esp+14h] [ebp-24h]
  unsigned __int16 v14; // [esp+18h] [ebp-20h]
  char v15; // [esp+1Ch] [ebp-1Ch]

  v1 = byte_A2F72;
  v2 = 0;
  v15 = 1;
  v3 = 0;
  v8 = 0;
  v10 = (T_Type5 *)(a1 + 4);
  while ( 1 )
  {
    result = SHIWORD(dword_A3CF2);
    if ( v2 >= SHIWORD(dword_A3CF2) )
    {
      break;
    }
    v12 = dword_D85C6[v3] >> 0x10;
    v11 = *(int *)((char *)&dword_D85C6[v3] + 2) >> 0x10;
    if ( (*(unsigned __int8 *)(a1 + 0xD8) & v15) != 0
      && (byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v2] || v2 == (unsigned __int8)byte_104BEA) )
    {
      v13 = 0;
      v14 = word_FFEA0[v8];
      if ( *(_DWORD *)(v1 + 3) == 0xFFFFFFFF )
      {
        v13 = 1;
        sub_5D007((const void *)(dword_D8D8F + 0x1600));
      }
      v5 = sub_1B084((unsigned int)&unk_12FC20, v14);
      sub_5D631(v10, v5, 0, v12, v11, (int)byte_D8DA0, 0, sub_10000, sub_10000, v13);
    }
    if ( (*(unsigned __int8 *)(a1 + 0xD8) & v15) != 0 )
    {
      v7 = (unsigned __int8)v1[2];
      v6 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEE2);
      sub_5CB3C(v10, v6, v7, v12, v11);
    }
    ++v3;
    ++v2;
    v1 += 0x1EE;
    v15 *= 2;
    ++v8;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// A3CF2: using guessed type int dword_A3CF2;
// D85C6: using guessed type int dword_D85C6[];
// D8D8F: using guessed type int dword_D8D8F;
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEE2: using guessed type __int16 word_FFEE2;

//----- (00024154) --------------------------------------------------------
void __fastcall sub_24154(int a1, int a2, int a3, int a4, float a5)
{
  float *v6; // eax
  int v7; // [esp+0h] [ebp-8h]

  sub_254B0(a1 + 0x172);
  v6 = (float *)(a1 + 0x14E);
  *(float *)&v7 = a5 * flt_12FC1C;
  if ( a2 == 0xFFFFFFFF )
  {
    sub_535E4(v6, 0xFFFFFFFF, a1, a4, v7);
  }
  else
  {
    sub_535B4(v6, a2, a1, a4, v7);
  }
}
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00024198) --------------------------------------------------------
void __fastcall sub_24198(int a1, int a2, int a3, int a4)
{
  int v5; // [esp-4h] [ebp-10h]

  if ( (*(float *)(a1 + 0x57A) >= (double)flt_9103C || a2 >= 0)
    && (*(float *)(a1 + 0x57A) <= (double)flt_91040 || a2 <= 0) )
  {
    v5 = *(__int16 *)(a1 + 0x576);
    *(float *)(a1 + 0x57A) = (double)a2 * flt_12FC1C + *(float *)(a1 + 0x57A);
    sub_1B808((_DWORD *)(a1 + 0xDA), a2, a1, a4, *(_DWORD *)(a1 + 0x57A), 0x3F800000, 0x47C35000, v5);
    sub_254B0(a1 + 0x172);
  }
  else
  {
    *(_BYTE *)(a1 + 0xC0) &= ~0x10u;
  }
}
// 9103C: using guessed type float flt_9103C;
// 91040: using guessed type float flt_91040;
// 12FC1C: using guessed type float flt_12FC1C;

//----- (0002422C) --------------------------------------------------------
void __fastcall sub_2422C(int a1, int a2, int a3, int a4)
{
  size_t *v5; // edx
  int v6; // esi
  int v7; // eax
  size_t *v8; // eax
  int v9; // ebp
  double v10; // st7
  size_t *v11; // eax
  int v12; // edx
  int **v13; // ebx
  int *v14; // ebp
  int *v15; // ebx
  int *v16; // ebp
  double v17; // st7
  double v18; // st7
  float v19; // eax
  int v20; // ebp
  __int16 v21; // dx
  int v22; // ebp
  int v23; // ebx
  int i; // eax
  double v25; // st7
  unsigned __int8 v26; // al
  int v27[3]; // [esp+8h] [ebp-114h] BYREF
  int v28[3]; // [esp+14h] [ebp-108h] BYREF
  int v29[3]; // [esp+20h] [ebp-FCh] BYREF
  float v30; // [esp+2Ch] [ebp-F0h]
  int v31; // [esp+30h] [ebp-ECh]
  int v32; // [esp+34h] [ebp-E8h]
  int v33[2]; // [esp+38h] [ebp-E4h] BYREF
  float v34; // [esp+40h] [ebp-DCh]
  int v35[3]; // [esp+44h] [ebp-D8h] BYREF
  float v36; // [esp+50h] [ebp-CCh]
  float v37; // [esp+54h] [ebp-C8h]
  float v38; // [esp+58h] [ebp-C4h]
  float v39; // [esp+5Ch] [ebp-C0h]
  int v40; // [esp+60h] [ebp-BCh]
  int v41; // [esp+64h] [ebp-B8h]
  int v42[3]; // [esp+68h] [ebp-B4h] BYREF
  float v43; // [esp+74h] [ebp-A8h]
  int v44; // [esp+78h] [ebp-A4h]
  int v45; // [esp+7Ch] [ebp-A0h]
  float v46; // [esp+80h] [ebp-9Ch]
  int v47; // [esp+84h] [ebp-98h]
  int v48; // [esp+88h] [ebp-94h]
  float v49; // [esp+8Ch] [ebp-90h]
  float v50; // [esp+90h] [ebp-8Ch]
  float v51; // [esp+94h] [ebp-88h]
  float v52; // [esp+98h] [ebp-84h]
  int v53; // [esp+9Ch] [ebp-80h]
  int v54; // [esp+A0h] [ebp-7Ch]
  int v55[2]; // [esp+A4h] [ebp-78h] BYREF
  float v56; // [esp+ACh] [ebp-70h]
  int *v57; // [esp+B0h] [ebp-6Ch]
  int *v58; // [esp+B8h] [ebp-64h]
  int *v59; // [esp+BCh] [ebp-60h]
  float v60; // [esp+C0h] [ebp-5Ch]
  int *v61; // [esp+C4h] [ebp-58h]
  int *v62; // [esp+C8h] [ebp-54h]
  int v63; // [esp+D0h] [ebp-4Ch]
  size_t *v64; // [esp+D4h] [ebp-48h]
  int v65; // [esp+D8h] [ebp-44h]
  size_t *v66; // [esp+DCh] [ebp-40h]
  int v67; // [esp+E0h] [ebp-3Ch]
  float *v68; // [esp+E4h] [ebp-38h]
  int v69; // [esp+E8h] [ebp-34h]
  int v70; // [esp+ECh] [ebp-30h]
  int v71; // [esp+F0h] [ebp-2Ch]
  int v72; // [esp+F4h] [ebp-28h] BYREF
  int v73; // [esp+F8h] [ebp-24h] BYREF
  int v74; // [esp+FCh] [ebp-20h] BYREF
  _WORD v75[14]; // [esp+100h] [ebp-1Ch] BYREF

  v55[0] = 0;
  v55[1] = 0;
  v56 = 0.0;
  v33[0] = 0;
  v33[1] = 0;
  v34 = 0.0;
  v5 = (size_t *)(a1 + 0x172);
  v6 = *(_DWORD *)(a1 + 0xB3);
  sub_254B0(a1 + 0x172);
  sub_1B864(a1 + 0xDA, (int)v5, 0, a4);
  v63 = 0;
  v64 = v5;
  v68 = (float *)(a1 + 0x11A);
  v7 = v6 - 0x15;
  v66 = v5;
  while ( 1 )
  {
    v70 = v7;
    if ( *(__int16 *)(a1 + 0xB7) <= v63 )
    {
      break;
    }
    v26 = *(_BYTE *)(v6 + 4);
    if ( v26 )
    {
      if ( v26 <= 1u )
      {
        v9 = *(_DWORD *)v6;
        sub_53384((float *)(**(_DWORD **)v6 + 8), v68, (float *)v55);
        sub_53384((float *)(*(_DWORD *)(v9 + 4) + 8), v68, (float *)v33);
        *(_DWORD *)(v6 + 0x11) = 0xFFFFFFFF;
        if ( v56 > (double)*(float *)(a1 + 0x106)
          && v56 < (double)*(float *)(a1 + 0x10A)
          && v34 > (double)*(float *)(a1 + 0x106)
          && v34 < (double)*(float *)(a1 + 0x10A) )
        {
          sub_533D4(
            (float *)v55,
            *(float *)(a1 + 0x102),
            *(__int16 *)(a1 + 0x576),
            *(__int16 *)(a1 + 0x578),
            (int)v75,
            (int)&v74);
          sub_533D4(
            (float *)v33,
            *(float *)(a1 + 0x102),
            *(__int16 *)(a1 + 0x576),
            *(__int16 *)(a1 + 0x578),
            (int)&v73,
            (int)&v72);
          *(_WORD *)(v6 + 5) = v75[0];
          *(_WORD *)(v6 + 7) = v74;
          *(_WORD *)(v6 + 9) = v73;
          *(_WORD *)(v6 + 0xB) = v72;
          v10 = (v56 + v34) * flt_91060;
          *(_DWORD *)(v6 + 0x11) = 0;
          v11 = v66;
          *(float *)(v6 + 0xD) = v10;
          sub_254BC((int)v11, v6);
        }
      }
      else if ( v26 == 2 )
      {
        v12 = *(_DWORD *)v6;
        if ( *(_BYTE *)(*(_DWORD *)v6 + 0x58) == 5 )
        {
          v13 = *(int ***)(v12 + 0x59);
          v49 = 0.0;
          v50 = 0.0;
          v51 = 0.0;
          v36 = 0.0;
          v37 = 0.0;
          v38 = 0.0;
          if ( (*(_DWORD *)(v12 + 0xA2) & 0x7FFFFFFF) != 0 )
          {
            v16 = *v13;
            v49 = *((float *)*v13 + 2);
            v50 = *((float *)v16 + 3);
            v51 = *((float *)v16 + 4);
            v15 = v13[1];
          }
          else
          {
            v14 = v13[1];
            v49 = *((float *)v14 + 2);
            v50 = *((float *)v14 + 3);
            v51 = *((float *)v14 + 4);
            v15 = *v13;
          }
          v36 = *((float *)v15 + 2);
          v37 = *((float *)v15 + 3);
          v38 = *((float *)v15 + 4);
          v52 = v36 - v49;
          v57 = v27;
          *(float *)&v53 = v37 - v50;
          *(float *)&v54 = v38 - v51;
          *(float *)v27 = v52;
          v27[1] = v53;
          v27[2] = v54;
          v17 = sqrt(*(float *)&v53 * *(float *)&v53 + v52 * v52 + *(float *)&v54 * *(float *)&v54);
          v58 = v35;
          v43 = v36 - v49;
          *(float *)v35 = v43;
          *(float *)&v44 = v37 - v50;
          v35[1] = v44;
          *(float *)&v45 = v38 - v51;
          v35[2] = v45;
          v59 = v42;
          v60 = *(float *)(v12 + 0x9E);
          v46 = v43 * v60;
          *(float *)&v47 = *(float *)&v44 * v60;
          *(float *)&v48 = *(float *)&v45 * v60;
          v18 = 1.0 / v17;
          *(float *)v42 = v46;
          v42[1] = v47;
          v42[2] = v48;
          v30 = v46 * v18;
          v61 = v29;
          *(float *)&v31 = *(float *)&v47 * v18;
          *(float *)v29 = v30;
          v29[1] = v31;
          *(float *)&v32 = v18 * *(float *)&v48;
          v29[2] = v32;
          v39 = v49 + v30;
          v62 = v28;
          *(float *)&v40 = v50 + *(float *)&v31;
          *(float *)v28 = v39;
          *(float *)&v41 = v51 + *(float *)&v32;
          v28[1] = v40;
          v28[2] = v41;
          sub_53384((float *)v28, v68, (float *)v55);
          *(_DWORD *)(v6 + 0x11) = 0xFFFFFFFF;
          if ( v56 > (double)*(float *)(a1 + 0x106) && v56 < (double)*(float *)(a1 + 0x10A) )
          {
            sub_533D4(
              (float *)v55,
              *(float *)(a1 + 0x102),
              *(__int16 *)(a1 + 0x576),
              *(__int16 *)(a1 + 0x578),
              (int)v75,
              (int)&v74);
            *(_WORD *)(v6 + 5) = v75[0] + 3;
            *(_WORD *)(v6 + 7) = v74;
            v19 = v56;
            *(_DWORD *)(v6 + 0x11) = 0;
            *(float *)(v6 + 0xD) = v19;
            sub_254BC((int)v64, v6);
            goto LABEL_29;
          }
        }
        else
        {
          v20 = *(_DWORD *)(v70 + 0x11);
          v69 = v70;
          if ( !v20 )
          {
            if ( *(_BYTE *)(v70 + 4) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x56E);
            }
            v21 = 4;
            v22 = *(unsigned __int8 *)(v67 + 0x14);
            v23 = *(unsigned __int8 *)(a1 + 0xD8);
            v65 = *(_DWORD *)v69;
            v71 = v23;
            for ( i = 0; i < 7; ++i )
            {
              if ( (v71 & v22 & (1 << i)) != 0 )
              {
                v21 += 2;
              }
            }
            if ( v65 == dword_D3660 )
            {
              v21 += 2;
            }
            *(_WORD *)(v6 + 5) = v21 + *(_WORD *)(v69 + 5);
            *(_WORD *)(v6 + 7) = *(_WORD *)(v69 + 7);
            v25 = *(float *)(v69 + 0xD) + 1.0;
            *(_DWORD *)(v6 + 0x11) = 0;
            *(float *)(v6 + 0xD) = v25;
          }
        }
        sub_254BC((int)v64, v6);
      }
      else
      {
        Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0x588);
      }
    }
    else
    {
      v67 = *(_DWORD *)v6;
      sub_53384((float *)(v67 + 8), v68, (float *)v55);
      *(_DWORD *)(v6 + 0x11) = 0xFFFFFFFF;
      if ( v56 > (double)*(float *)(a1 + 0x106) && v56 < (double)*(float *)(a1 + 0x10A) )
      {
        sub_533D4(
          (float *)v55,
          *(float *)(a1 + 0x102),
          *(__int16 *)(a1 + 0x576),
          *(__int16 *)(a1 + 0x578),
          (int)v75,
          (int)&v74);
        *(_WORD *)(v6 + 5) = v75[0];
        *(_WORD *)(v6 + 7) = v74;
        *(float *)(v6 + 0xD) = v56;
        v8 = v66;
        *(_DWORD *)(v6 + 0x11) = 0;
        sub_254BC((int)v8, v6);
      }
    }
LABEL_29:
    v6 += 0x15;
    v7 = v70 + 0x15;
    ++v63;
  }
  sub_254DC(v66);
}
// 91060: using guessed type float flt_91060;
// D3660: using guessed type int dword_D3660;
// 2422C: using guessed type _WORD var_1C[14];

//----- (00024948) --------------------------------------------------------
int __fastcall sub_24948(int result, int a2, int a3)
{
  int v3; // ebp
  int v4; // ebx
  int v5; // edi
  int v6; // edx
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  __int16 v10; // si
  int i; // ebx
  int v12; // eax
  int v13; // edx
  int v14; // edi
  char v15; // dl
  int v16; // eax
  char *v17; // edi
  char *v18; // esi
  char v19; // al
  char v20; // al
  __int16 j; // si
  int v22; // ebx
  int v23; // edx
  int v24; // ebx
  int v25; // edx
  const char *v26; // ecx
  _DWORD v27[5]; // [esp+0h] [ebp-2Ch] BYREF
  int v28; // [esp+14h] [ebp-18h]
  int v29; // [esp+18h] [ebp-14h]

  v3 = result;
  v28 = a2;
  v29 = a3;
  if ( *(_DWORD *)(result + 0xD4) == 0xFFFFFFFF )
  {
    return result;
  }
  v4 = *(_DWORD *)(result + 0xBB);
  if ( v4 )
  {
    v5 = 0x28;
    v6 = *(__int16 *)(v4 + 5) - v28;
    v7 = *(__int16 *)(v4 + 7) - v29;
    if ( *(_BYTE *)(v4 + 4) == 2 )
    {
      v6 += unk_965F8;
      v5 = 0x14;
      v7 += SHIBYTE(dword_965FD);
    }
    result = v6 * v6 + v7 * v7;
    if ( result <= v5 )
    {
      return result;
    }
    v8 = *(_DWORD *)(v3 + 0x57E);
    *(_DWORD *)(v3 + 0xBB) = 0;
    sub_5A270(&V_Type3_stru_10AE70, v8, 0, 0);
    dword_D85E8 = *(_DWORD *)(v3 + 0x10) - 0x82;
    v9 = *(_DWORD *)(v3 + 0xA7);
    dword_D85EC = *(_DWORD *)(v3 + 0x14) - 0x1B;
    (*(void (__fastcall **)(int, int))(v9 + 0xC))(v3, 0xA);
  }
  v10 = *(_WORD *)(v3 + 0xB7) - 1;
  for ( i = 0x15 * (*(__int16 *)(v3 + 0xB7) - 1) + *(_DWORD *)(v3 + 0xB3); ; i -= 0x15 )
  {
    result = v10;
    if ( v10 < 0 )
    {
      break;
    }
    if ( *(_BYTE *)(i + 4) != 1 )
    {
      v12 = *(__int16 *)(i + 5) - v28;
      v13 = *(__int16 *)(i + 7) - v29;
      v14 = 0x28;
      if ( *(_BYTE *)(i + 4) == 2 )
      {
        v12 += unk_965F8;
        v13 += SHIBYTE(dword_965FD);
        v14 = 0x14;
      }
      result = v13 * v13 + v12 * v12;
      if ( result < v14 )
      {
        *(_DWORD *)(v3 + 0xBB) = i;
        break;
      }
    }
    --v10;
  }
  if ( *(_DWORD *)(v3 + 0xBB) )
  {
    sub_5A270(&V_Type3_stru_10AE70, *(_DWORD *)(v3 + 0x57E) + 1, 0, 0);
    result = *(_DWORD *)(v3 + 0xBB);
    if ( !*(_BYTE *)(result + 4) )
    {
      v27[0] = dword_96654[0];
      v27[1] = dword_96654[1];
      v27[2] = dword_96654[2];
      v27[3] = dword_96654[3];
      v27[4] = dword_96654[4];
      v15 = 1;
      v16 = **(_DWORD **)(v3 + 0xBB);
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(v16 + 0x17)) != 0 )
      {
        v17 = (char *)v27;
        v18 = (char *)(v16 + 0x1C);
        do
        {
          v19 = *v18;
          *v17 = *v18;
          if ( !v19 )
          {
            break;
          }
          v20 = v18[1];
          v18 += 2;
          v17[1] = v20;
          v17 += 2;
        }
        while ( v20 );
        for ( j = 0;
              j < 7
           && (*(_BYTE *)(**(_DWORD **)(v3 + 0xBB) + 0x14) & (unsigned __int8)(*(_BYTE *)(v3 + 0xD9) & v15)) == 0;
              ++j )
        {
          v15 *= 2;
        }
      }
      if ( LOBYTE(v27[0]) )
      {
        v22 = *(_DWORD *)(v3 + 0x14) - 0x1B;
        v23 = *(_DWORD *)(v3 + 0x10) - 0x82;
        *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v23, v22, (const char *)v27, 0, 0xFFFFFFFF, 0xFF, 0);
      }
      v24 = *(_DWORD *)(v3 + 0x14) - 0xC;
      v25 = *(_DWORD *)(v3 + 0x10) - 0x82;
      v26 = &byte_D84C4[0x14 * ***(_DWORD ***)(v3 + 0xBB)];
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], v25, v24, v26, 0, 0xFFFFFFFF, 0xFF, 0);
    }
  }
  return result;
}
// 965FD: using guessed type int dword_965FD;
// 96654: using guessed type _DWORD dword_96654[5];
// 968DC: using guessed type char byte_968DC;
// D85E8: using guessed type int dword_D85E8;
// D85EC: using guessed type int dword_D85EC;

//----- (00024BE0) --------------------------------------------------------
int __fastcall sub_24BE0(int a1)
{
  int result; // eax
  int v3; // eax
  int v4; // edx
  int i; // ecx
  _DWORD *v6; // ebx
  __int16 *v7; // ecx
  int v8; // edx

  result = *(_DWORD *)(a1 + 0xBB);
  if ( !*(_BYTE *)(result + 4) )
  {
    if ( *(_DWORD *)(a1 + 0x582) )
    {
      result = *(_DWORD *)result;
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(result + 0x16)) != 0 )
      {
        v4 = result;
        for ( i = 0; i < *(__int16 *)(result + 0x44); ++i )
        {
          v6 = *(_DWORD **)(v4 + 0x2C);
          if ( result == *v6 && v6[1] == **(_DWORD **)(a1 + 0x586)
            || *v6 == **(_DWORD **)(a1 + 0x586) && result == v6[1] )
          {
            v7 = **(__int16 ***)(a1 + 0x586);
            v8 = result;
            sub_1D654(v7, result, (int)v6);
            *(_DWORD *)(a1 + 0x582) = 0;
            sub_24D30(a1, v8, (int)v6, (int)v7);
            sub_2422C(a1, v8, (int)v6, (int)v7);
            return (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          }
          v4 += 4;
        }
      }
    }
    else if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 1 )
    {
      result = *(_DWORD *)result;
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(result + 0x17)) != 0 )
      {
        dword_D3660 = result;
        *(_DWORD *)(a1 + 0xBB) = 0;
        return sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 1);
      }
    }
    else if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 0xD )
    {
      dword_D3660 = *(_DWORD *)result;
      v3 = sub_56E18((int)&V_Type3_stru_10AE70, "NEGSCREEN", 0xD, 0);
      if ( !v3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x612);
      }
      sub_32A1C(v3);
      return (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
  }
  return result;
}
// 968DC: using guessed type char byte_968DC;
// D3660: using guessed type int dword_D3660;

//----- (00024D30) --------------------------------------------------------
int __fastcall sub_24D30(int a1, int a2, int a3, int a4)
{
  __int16 i; // di
  __int16 *v6; // esi
  __int16 v7; // bx
  int v8; // esi
  __int16 j; // si
  char *v10; // edi
  __int16 v11; // di
  __int16 k; // si
  int result; // eax
  char *v14; // eax
  int v15[107]; // [esp+0h] [ebp-1D4h] BYREF
  char s[32]; // [esp+1ACh] [ebp-28h] BYREF
  int v17; // [esp+1CCh] [ebp-8h]

  v17 = a4;
  *(_WORD *)(a1 + 0xB7) = 0;
  for ( i = 0; i < word_A62A1; ++i )
  {
    if ( *(_WORD *)(a1 + 0xB7) >= *(_WORD *)(a1 + 0xB9) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x659);
    }
    v6 = &word_A3D21[0x30 * i];
    *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * (*(int *)(a1 + 0xB5) >> 0x10)) = v6;
    *(_BYTE *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * *(__int16 *)(a1 + 0xB7) + 4) = 0;
    v7 = *(_WORD *)(a1 + 0xB7) + 1;
    *(_WORD *)(a1 + 0xB7) = v7;
    if ( *((_BYTE *)v6 + 0x15) )
    {
      if ( v7 >= *(__int16 *)(a1 + 0xB9) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x66B);
      }
      v8 = sub_1D794(&word_A3D21[0x30 * i], v15);
      if ( !v8 && dword_A0CFC == 0xFFFFFFFF )
      {
        sprintf(s, "cos%05d.bug", dword_A2F6C[0]);
        sub_54048(s, (int)"..\\coswnd.cpp", 0x676, a1);
        Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0x676);
      }
      if ( v8 > 0 )
      {
        *(_DWORD *)(0x15 * *(__int16 *)(a1 + 0xB7) + *(_DWORD *)(a1 + 0xB3)) = v15[0];
        *(_BYTE *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * (__int16)(*(_WORD *)(a1 + 0xB7))++ + 4) = 2;
      }
    }
  }
  for ( j = 0; j < word_A792F; ++j )
  {
    v10 = (char *)&unk_A62A3 + 0x27 * j;
    if ( ((unsigned __int8)byte_968DC & (unsigned __int8)v10[0x20]) != 0 )
    {
      if ( *(_WORD *)(a1 + 0xB7) >= *(_WORD *)(a1 + 0xB9) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x68B);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * *(__int16 *)(a1 + 0xB7)) = v10;
      *(_BYTE *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * (__int16)(*(_WORD *)(a1 + 0xB7))++ + 4) = 1;
    }
  }
  v11 = 0;
  for ( k = 0; ; ++k )
  {
    result = k;
    if ( k >= 0x6B || v11 >= SHIWORD(dword_D35E5) )
    {
      break;
    }
    if ( *(_WORD *)(a1 + 0xB7) >= *(_WORD *)(a1 + 0xB9) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x698);
    }
    v14 = (char *)&unk_CA1F1 + 0x162 * k;
    if ( *((__int16 *)v14 + 0x2B) != 0xFFFFFFFF )
    {
      ++v11;
      if ( v14[0x58] == 5 )
      {
        *(_DWORD *)(0x15 * *(__int16 *)(a1 + 0xB7) + *(_DWORD *)(a1 + 0xB3)) = v14;
        *(_BYTE *)(0x15 * (__int16)(*(_WORD *)(a1 + 0xB7))++ + *(_DWORD *)(a1 + 0xB3) + 4) = 2;
      }
    }
  }
  return result;
}
// 968DC: using guessed type char byte_968DC;
// A0CFC: using guessed type int dword_A0CFC;
// A2F6C: using guessed type int dword_A2F6C[];
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// A792F: using guessed type __int16 word_A792F;
// D35E5: using guessed type int dword_D35E5;
// 24D30: using guessed type int var_1D4[107];

//----- (00024FCC) --------------------------------------------------------
__int64 __fastcall sub_24FCC(int a1, T_Type1 *a2, int a3)
{
  _DWORD *v4; // ecx
  _DWORD *v5; // edi
  _DWORD *v6; // ebp
  _DWORD *v7; // edx
  _DWORD *v8; // edx
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  int v12; // [esp+0h] [ebp-1A4h] BYREF
  int v13; // [esp+4h] [ebp-1A0h]
  int v14; // [esp+8h] [ebp-19Ch]
  int v15; // [esp+Ch] [ebp-198h]
  int v16; // [esp+10h] [ebp-194h]
  int v17; // [esp+14h] [ebp-190h]
  int v18; // [esp+18h] [ebp-18Ch]
  _BYTE v19[158]; // [esp+1Ch] [ebp-188h] BYREF
  int v20[7]; // [esp+C0h] [ebp-E4h] BYREF
  char v21; // [esp+DCh] [ebp-C8h]
  char v22; // [esp+DDh] [ebp-C7h]
  int v23[40]; // [esp+DEh] [ebp-C6h] BYREF
  P_Type1 v24; // [esp+180h] [ebp-24h]
  _DWORD *v25; // [esp+184h] [ebp-20h]
  _DWORD *v26; // [esp+188h] [ebp-1Ch]
  _DWORD *v27; // [esp+18Ch] [ebp-18h]
  _DWORD *v28; // [esp+190h] [ebp-14h]

  v24 = a2;
  v4 = (_DWORD *)(a1 + 0xDA);
  v25 = (_DWORD *)(a1 + 0x14E);
  v5 = (_DWORD *)(a1 + 0xF2);
  v28 = (_DWORD *)(a1 + 0x10E);
  v6 = (_DWORD *)(a1 + 0x166);
  v27 = (_DWORD *)(a1 + 0xE6);
  v26 = (_DWORD *)(a1 + 0x15A);
  if ( a3 == 0xFFFFFFFF )
  {
    sub_1B4F0(v23);
    sub_1BF94(v24, v20, 0xBEu);
    *(_DWORD *)(a1 + 0xC0) = v20[0];
    *(_DWORD *)(a1 + 0xC4) = v20[1];
    *(_DWORD *)(a1 + 0x58A) = v20[2];
    *(_DWORD *)(a1 + 0xC8) = v20[3];
    *(_DWORD *)(a1 + 0xCC) = v20[4];
    *(_DWORD *)(a1 + 0xD0) = v20[5];
    *(_DWORD *)(a1 + 0xD4) = v20[6];
    *(_BYTE *)(a1 + 0xD8) = v21;
    *(_BYTE *)(a1 + 0xD9) = v22;
    *v4 = v23[0];
    v4[1] = v23[1];
    v4[2] = v23[2];
    v7 = v27;
    *v27 = v23[3];
    v7[1] = v23[4];
    v7[2] = v23[5];
    *v5 = v23[6];
    v5[1] = v23[7];
    v5[2] = v23[8];
    v4[9] = v23[9];
    v4[0xA] = v23[0xA];
    v4[0xB] = v23[0xB];
    v4[0xC] = v23[0xC];
    v8 = v28;
    *v28 = v23[0xD];
    v8[1] = v23[0xE];
    v8[2] = v23[0xF];
    v4[0x10] = v23[0x10];
    v4[0x11] = v23[0x11];
    v4[0x12] = v23[0x12];
    v4[0x13] = v23[0x13];
    v4[0x14] = v23[0x14];
    v4[0x15] = v23[0x15];
    v4[0x16] = v23[0x16];
    v4[0x17] = v23[0x17];
    v4[0x18] = v23[0x18];
    v4[0x19] = v23[0x19];
    v4[0x1A] = v23[0x1A];
    v4[0x1B] = v23[0x1B];
    v4[0x1C] = v23[0x1C];
    v9 = v25;
    *v25 = v23[0x1D];
    v9[1] = v23[0x1E];
    v9[2] = v23[0x1F];
    v10 = v26;
    *v26 = v23[0x20];
    v10[1] = v23[0x21];
    v10[2] = v23[0x22];
    *v6 = v23[0x23];
    v6[1] = v23[0x24];
    v6[2] = v23[0x25];
    *(float *)(a1 + 0x57A) = (float)v23[0x26];
    return (unsigned int)((int (*)(void))locret_1B66C)();
  }
  else
  {
    sub_1B4F0(&v19[2]);
    v12 = *(_DWORD *)(a1 + 0xC0);
    v13 = *(_DWORD *)(a1 + 0xC4);
    v14 = *(_DWORD *)(a1 + 0x58A);
    v15 = *(_DWORD *)(a1 + 0xC8);
    v16 = *(_DWORD *)(a1 + 0xCC);
    v17 = *(_DWORD *)(a1 + 0xD0);
    v18 = *(_DWORD *)(a1 + 0xD4);
    v19[0] = *(_BYTE *)(a1 + 0xD8);
    v19[1] = *(_BYTE *)(a1 + 0xD9);
    *(_DWORD *)&v19[2] = *v4;
    *(_DWORD *)&v19[6] = v4[1];
    *(_DWORD *)&v19[0xA] = v4[2];
    *(_DWORD *)&v19[0xE] = *v27;
    *(_DWORD *)&v19[0x12] = v27[1];
    *(_DWORD *)&v19[0x16] = v27[2];
    *(_DWORD *)&v19[0x1A] = *v5;
    *(_DWORD *)&v19[0x1E] = v5[1];
    *(_DWORD *)&v19[0x22] = v5[2];
    *(_DWORD *)&v19[0x26] = v4[9];
    *(_DWORD *)&v19[0x2A] = v4[0xA];
    *(_DWORD *)&v19[0x2E] = v4[0xB];
    *(_DWORD *)&v19[0x32] = v4[0xC];
    *(_DWORD *)&v19[0x36] = *v28;
    *(_DWORD *)&v19[0x3A] = v28[1];
    *(_DWORD *)&v19[0x3E] = v28[2];
    *(_DWORD *)&v19[0x42] = v4[0x10];
    *(_DWORD *)&v19[0x46] = v4[0x11];
    *(_DWORD *)&v19[0x4A] = v4[0x12];
    *(_DWORD *)&v19[0x4E] = v4[0x13];
    *(_DWORD *)&v19[0x52] = v4[0x14];
    *(_DWORD *)&v19[0x56] = v4[0x15];
    *(_DWORD *)&v19[0x5A] = v4[0x16];
    *(_DWORD *)&v19[0x5E] = v4[0x17];
    *(_DWORD *)&v19[0x62] = v4[0x18];
    *(_DWORD *)&v19[0x66] = v4[0x19];
    *(_DWORD *)&v19[0x6A] = v4[0x1A];
    *(_DWORD *)&v19[0x6E] = v4[0x1B];
    *(_DWORD *)&v19[0x72] = v4[0x1C];
    *(_DWORD *)&v19[0x76] = *v25;
    *(_DWORD *)&v19[0x7A] = v25[1];
    *(_DWORD *)&v19[0x7E] = v25[2];
    *(_DWORD *)&v19[0x82] = *v26;
    *(_DWORD *)&v19[0x86] = v26[1];
    *(_DWORD *)&v19[0x8A] = v26[2];
    *(_DWORD *)&v19[0x8E] = *v6;
    *(_DWORD *)&v19[0x92] = v6[1];
    *(_DWORD *)&v19[0x96] = v6[2];
    *(_DWORD *)&v19[0x9A] = (int)*(float *)(a1 + 0x57A);
    sub_1C098((unsigned int)v24, (int)&v12, 0xBEu);
    return (unsigned int)((int (__cdecl *)(int, int, int, int, int, int, int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))locret_1B66C)(
                           v12,
                           v13,
                           v14,
                           v15,
                           v16,
                           v17,
                           v18,
                           *(_DWORD *)v19,
                           *(_DWORD *)&v19[4],
                           *(_DWORD *)&v19[8],
                           *(_DWORD *)&v19[0xC],
                           *(_DWORD *)&v19[0x10],
                           *(_DWORD *)&v19[0x14],
                           *(_DWORD *)&v19[0x18],
                           *(_DWORD *)&v19[0x1C],
                           *(_DWORD *)&v19[0x20],
                           *(_DWORD *)&v19[0x24],
                           *(_DWORD *)&v19[0x28],
                           *(_DWORD *)&v19[0x2C],
                           *(_DWORD *)&v19[0x30],
                           *(_DWORD *)&v19[0x34],
                           *(_DWORD *)&v19[0x38],
                           *(_DWORD *)&v19[0x3C],
                           *(_DWORD *)&v19[0x40],
                           *(_DWORD *)&v19[0x44],
                           *(_DWORD *)&v19[0x48],
                           *(_DWORD *)&v19[0x4C],
                           *(_DWORD *)&v19[0x50],
                           *(_DWORD *)&v19[0x54],
                           *(_DWORD *)&v19[0x58],
                           *(_DWORD *)&v19[0x5C],
                           *(_DWORD *)&v19[0x60],
                           *(_DWORD *)&v19[0x64],
                           *(_DWORD *)&v19[0x68],
                           *(_DWORD *)&v19[0x6C],
                           *(_DWORD *)&v19[0x70],
                           *(_DWORD *)&v19[0x74],
                           *(_DWORD *)&v19[0x78],
                           *(_DWORD *)&v19[0x7C],
                           *(_DWORD *)&v19[0x80],
                           *(_DWORD *)&v19[0x84],
                           *(_DWORD *)&v19[0x88],
                           *(_DWORD *)&v19[0x8C],
                           *(_DWORD *)&v19[0x90],
                           *(_DWORD *)&v19[0x94],
                           *(_DWORD *)&v19[0x98]);
  }
}

//----- (000254A4) --------------------------------------------------------
int __fastcall sub_254A4(int a1)
{
  sub_254B0(a1);
  return a1;
}

//----- (000254B0) --------------------------------------------------------
int __fastcall sub_254B0(int result)
{
  *(_DWORD *)(result + 0x400) = 0;
  return result;
}

//----- (000254BC) --------------------------------------------------------
int __fastcall sub_254BC(int result, int a2)
{
  int v2; // ebx

  v2 = *(_DWORD *)(result + 0x400);
  if ( v2 < 0x100 )
  {
    if ( a2 )
    {
      *(_DWORD *)(result + 4 * v2) = a2;
      ++*(_DWORD *)(result + 0x400);
    }
  }
  return result;
}

//----- (000254DC) --------------------------------------------------------
void __fastcall sub_254DC(size_t *a1)
{
  qsort(a1, a1[0x100], 4u, sub_22430);
}

//----- (000254F8) --------------------------------------------------------
unsigned int __fastcall sub_254F8(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax
  int v3; // esi
  int v4; // edi
  int v5; // ebp
  int v6; // ecx
  unsigned int v7; // ebx
  void (__fastcall *v8)(_DWORD, _DWORD, _DWORD, _DWORD); // eax
  int v9; // ebp
  char v10; // dl
  int v11; // edi
  int v12; // ecx
  int v13; // [esp-Ch] [ebp-78h]
  int v14; // [esp-8h] [ebp-74h]
  int v15; // [esp-8h] [ebp-74h]
  T_Type5 *v16; // [esp+0h] [ebp-6Ch]
  unsigned int v18; // [esp+8h] [ebp-64h]
  int v19; // [esp+Ch] [ebp-60h]
  T_Type5 *v20; // [esp+10h] [ebp-5Ch]
  unsigned int v21; // [esp+14h] [ebp-58h]
  int **v22; // [esp+18h] [ebp-54h]
  T_Type5 *v23; // [esp+1Ch] [ebp-50h]
  int v24; // [esp+20h] [ebp-4Ch]
  T_Type5 *v25; // [esp+24h] [ebp-48h]
  int v26; // [esp+28h] [ebp-44h]
  int **v27; // [esp+2Ch] [ebp-40h]
  int v28; // [esp+30h] [ebp-3Ch]
  __int16 *v29; // [esp+34h] [ebp-38h]
  int v30; // [esp+38h] [ebp-34h]
  signed int i; // [esp+40h] [ebp-2Ch]
  __int16 v33; // [esp+44h] [ebp-28h]
  __int16 j; // [esp+48h] [ebp-24h]
  char v35; // [esp+4Ch] [ebp-20h]
  char v36; // [esp+50h] [ebp-1Ch]
  char v37; // [esp+54h] [ebp-18h]

  sub_5E9D0((P_Type5)(a2 + 4), *(_BYTE *)(a2 + 0xBF));
  v18 = a1;
  v35 = 4 * byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  result = a1;
  v26 = 0;
  if ( *(int *)(a1 + 0x400) > 0 )
  {
    v27 = (int **)(a2 + 4);
    v25 = (T_Type5 *)(a2 + 4);
    v24 = a2 + 4;
    v20 = (T_Type5 *)(a2 + 4);
    v28 = a2 + 4;
    v16 = (T_Type5 *)(a2 + 4);
    v22 = (int **)(a2 + 4);
    v23 = (T_Type5 *)(a2 + 4);
    do
    {
      v3 = *(_DWORD *)v18;
      LOBYTE(result) = *(_BYTE *)(*(_DWORD *)v18 + 4);
      v19 = (int)(*(float *)(*(_DWORD *)v18 + 0xD) + flt_910EA);
      if ( (_BYTE)result )
      {
        if ( (unsigned __int8)result <= 1u )
        {
          result = a2;
          if ( *(_DWORD *)(a2 + 0xC4) || *(_DWORD *)(a2 + 0x58A) )
          {
            v6 = 7;
            v7 = *(_DWORD *)v3;
            if ( v19 <= 0xDC )
            {
              if ( v19 <= 0x93 )
              {
                if ( v19 <= 0x49 )
                {
                  if ( v19 <= 0 )
                  {
                    if ( v19 <= (int)0xFFFFFFB7 )
                    {
                      if ( v19 <= (int)0xFFFFFF6D )
                      {
                        if ( v19 > (int)0xFFFFFF24 )
                        {
                          v6 = 6;
                        }
                      }
                      else
                      {
                        v6 = 5;
                      }
                    }
                    else
                    {
                      v6 = 4;
                    }
                  }
                  else
                  {
                    v6 = 3;
                  }
                }
                else
                {
                  v6 = 2;
                }
              }
              else
              {
                v6 = 1;
              }
            }
            else
            {
              v6 = 0;
            }
            if ( *(_DWORD *)(a2 + 0x58A) == 0xFFFFFFFF )
            {
              if ( *(_WORD *)(v7 + 0x21) )
              {
                v8 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(4
                                                                         * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA]
                                                                         + 0x10
                                                                         + v6 / 2);
              }
              else
              {
                v8 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(v6 + 0x30);
              }
            }
            else
            {
              v8 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(v6 + 0x68);
            }
            if ( !*(_DWORD *)(a2 + 0x58A) && (*(_BYTE *)(v7 + 0x23) & 1) != 0 )
            {
              v8 = (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(v6 / 2 + 0x70);
            }
            result = sub_5C001(
                       v22,
                       *(__int16 *)(v3 + 5),
                       *(__int16 *)(v3 + 7),
                       *(__int16 *)(v3 + 9),
                       *(__int16 *)(v3 + 0xB),
                       0,
                       v8);
          }
        }
        else if ( (_BYTE)result == 2 )
        {
          result = a2;
          if ( *(_DWORD *)(a2 + 0xC8) )
          {
            v9 = 3;
            result = *(_DWORD *)v3;
            if ( v19 <= 0xDC )
            {
              if ( v19 <= 0 )
              {
                if ( v19 > (int)0xFFFFFF24 )
                {
                  v9 = 2;
                }
              }
              else
              {
                v9 = 1;
              }
            }
            else
            {
              v9 = 0;
            }
            v10 = *(_BYTE *)(result + 0x58);
            if ( v10 == 5 )
            {
              if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*(_DWORD *)(result + 0x59) + 0x20)) != 0
                && ((1 << *(_WORD *)(result + 0x56)) & *(unsigned __int8 *)(a2 + 0xD8)) != 0 )
              {
                result = sub_53EB8(
                           v23,
                           *(_DWORD *)(a2 + 0xAF),
                           v9,
                           *(__int16 *)(v3 + 5),
                           *(__int16 *)(v3 + 7),
                           *(_WORD *)(result + 0x56));
              }
            }
            else
            {
              v36 = 1;
              if ( v10 == 4 )
              {
                v29 = *(__int16 **)(result + 0x59);
              }
              else
              {
                v29 = &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(result + 0x59) + 0xC)];
              }
              if ( !v29 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x822);
              }
              result = 1 << byte_104BEA;
              if ( ((1 << byte_104BEA) & *((unsigned __int8 *)v29 + 0x17)) != 0 )
              {
                v11 = 0;
                for ( i = 0; ; ++i )
                {
                  result = i;
                  if ( SHIWORD(dword_A3CF2) <= i )
                  {
                    break;
                  }
                  if ( (*(_BYTE *)(a2 + 0xD8) & (unsigned __int8)(v36 & *((_BYTE *)v29 + 0x15))) != 0 )
                  {
                    v15 = *(__int16 *)(v3 + 7) + (*(int *)((char *)&dword_965FD + v11) >> 0x18);
                    v12 = *(__int16 *)(v3 + 5) + (*(int *)&aCosdip[v11++ + 5] >> 0x18);
                    sub_53EB8(v20, *(_DWORD *)(a2 + 0xAF), v9, v12, v15, i);
                  }
                  v36 *= 2;
                }
              }
            }
          }
        }
      }
      else
      {
        v21 = *(_DWORD *)v3;
        v30 = 3;
        if ( v19 <= 0xDC )
        {
          if ( v19 <= 0 )
          {
            if ( v19 > (int)0xFFFFFF24 )
            {
              v30 = 2;
            }
          }
          else
          {
            v30 = 1;
          }
        }
        else
        {
          v30 = 0;
        }
        sub_5CB3C(v16, *(_DWORD *)(a2 + 0xAB), v30 + 4 * *(_DWORD *)v21, *(__int16 *)(v3 + 5), *(__int16 *)(v3 + 7));
        v33 = *(_WORD *)&V_Type3_stru_10AE70.z1[0x4228];
        v4 = 4;
        if ( (((1 << byte_104BEA) & *(unsigned __int8 *)(v21 + 0x17)) != 0
           || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 3)
          && *(_DWORD *)(a2 + 0xCC)
          && *(_BYTE *)(v21 + 0x14) )
        {
          v5 = 0;
          v37 = 1;
          do
          {
            if ( (*(_BYTE *)(a2 + 0xD8) & (unsigned __int8)(*(_BYTE *)(v21 + 0x14) & v37)) != 0 )
            {
              v14 = v4;
              v13 = v4;
              v4 += 2;
              sub_5F048(
                v28,
                *(__int16 *)(v3 + 5),
                *(__int16 *)(v3 + 7),
                v13,
                v14,
                (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(v30
                                                                    + (unsigned __int8)(4 * byte_A2F74[v5] + 0x13)
                                                                    - 3));
            }
            v5 += 0x1EE;
            v37 *= 2;
          }
          while ( v5 != 0xD82 );
        }
        if ( v21 == dword_D3660 && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 3 )
        {
          sub_5F048(
            v24,
            *(__int16 *)(v3 + 5),
            *(__int16 *)(v3 + 7),
            v4,
            v4,
            (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
        }
        if ( (((1 << byte_104BEA) & *(unsigned __int8 *)(v21 + 0x17)) != 0 || v33 == 3)
          && (*(_BYTE *)(v21 + 0x14) & 0x80) != 0
          && *(_DWORD *)(a2 + 0xD0) == 0xFFFFFFFF )
        {
          for ( j = 0; j < SHIWORD(dword_A3CF2); ++j )
          {
            if ( v21 == *(int *)((char *)&dword_A2F79 + 0x1EE * j) )
            {
              break;
            }
          }
          if ( j >= SHIWORD(dword_A3CF2) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x786);
          }
          if ( (*(_BYTE *)(a2 + 0xD8) & (unsigned __int8)(1 << j)) != 0
            || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 3 )
          {
            sub_53E38(v25, *(__int16 *)(v3 + 5) - 7, *(__int16 *)(v3 + 7) + 3, j);
          }
        }
        result = 1 << byte_104BEA;
        if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(v21 + 0x17)) != 0
          && *(_DWORD *)(a2 + 0xCC)
          && ((unsigned __int8)result & *(_BYTE *)(v21 + 0x14)) == 0 )
        {
          sub_5BE50(v27, *(__int16 *)(v3 + 5) - 4, *(__int16 *)(v3 + 7), v35);
          sub_5BE50(v27, *(__int16 *)(v3 + 5), *(__int16 *)(v3 + 7) - 4, v35);
          sub_5BE50(v27, *(__int16 *)(v3 + 5) + 4, *(__int16 *)(v3 + 7), v35);
          result = sub_5BE50(v27, *(__int16 *)(v3 + 5), *(__int16 *)(v3 + 7) + 4, v35);
        }
      }
      ++v26;
      v18 += 4;
    }
    while ( v26 < *(_DWORD *)(a1 + 0x400) );
  }
  return result;
}
// 910EA: using guessed type float flt_910EA;
// 965FD: using guessed type int dword_965FD;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// D3660: using guessed type int dword_D3660;

//----- (00025BF8) --------------------------------------------------------
P_TypeA2 __fastcall sub_25BF8(P_TypeA2 a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95B9C;
  return a1;
}
// 95B9C: using guessed type int (*off_95B9C[5])();

//----- (00025C08) --------------------------------------------------------
int __fastcall sub_25C08(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95B48);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95B9C;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95B9C: using guessed type int (*off_95B9C[5])();

//----- (00025C4C) --------------------------------------------------------
void __fastcall sub_25C4C(unsigned int a1, int a2)
{
  int v3; // edi
  __int16 v4; // si
  T_Type5 *v5; // ebp

  sub_2CD24(a1, a2);
  v3 = 0x2F;
  v4 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    v5 = (T_Type5 *)(a1 + 4);
    do
    {
      if ( v4 == (unsigned __int8)byte_104BEA || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v4] )
      {
        sub_53E38(v5, (__int16)v3, 3, v4);
        v3 += 0x10;
      }
      ++v4;
    }
    while ( v4 < SHIWORD(dword_A3CF2) );
  }
  JUMPOUT(0x25BF1);
}
// 25C69: control flows out of bounds to 25BF1
// A3CF2: using guessed type int dword_A3CF2;

//----- (00025CB8) --------------------------------------------------------
int __fastcall sub_25CB8(int result)
{
  sub_2C830((P_TypeA2)result);
  *(_DWORD *)(result + 0xA7) = off_95B84;
  *(_WORD *)(result + 0xAB) = 0;
  return result;
}
// 95B84: using guessed type int (*off_95B84[5])();

//----- (00025CD4) --------------------------------------------------------
int __fastcall sub_25CD4(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95B34);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95B84;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95B84: using guessed type int (*off_95B84[5])();

//----- (00025D18) --------------------------------------------------------
void __fastcall sub_25D18(int result, int a2)
{
  unsigned int v3; // esi
  int v4; // ecx
  unsigned __int8 v5; // al
  __int16 v6; // cx
  __int16 i; // ax
  char *sub_1CEA8; // eax
  char *v9; // eax
  __int16 v10; // eax^2
  _DWORD *v11; // esi
  const char *v12; // ecx
  _DWORD *v13; // esi
  int v14; // ecx
  int v15; // ebx
  int v16; // eax
  __int16 v17; // [esp-8h] [ebp-68h]
  int v18; // [esp-4h] [ebp-64h]
  int v19; // [esp-4h] [ebp-64h]
  char s[52]; // [esp+0h] [ebp-60h] BYREF
  int v21; // [esp+34h] [ebp-2Ch]
  int v22; // [esp+38h] [ebp-28h]
  char *v23; // [esp+3Ch] [ebp-24h]
  int v24; // [esp+40h] [ebp-20h]
  int v25; // [esp+44h] [ebp-1Ch]
  char v26; // [esp+48h] [ebp-18h]

  if ( *(_DWORD *)(result + 0x39) )
  {
    v3 = 0xFFFFFFFF;
    v25 = 0;
    v24 = 0xF2;
    if ( a2 )
    {
      v24 = a2;
    }
    v4 = *(__int16 *)(result + 0xAB);
    v21 = *(int *)((char *)&dword_A2F75 + 0x1EE * v4);
    v26 = byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v4];
    if ( !v26 || v21 )
    {
      v25 = 0xFFFFFFFF;
    }
    else
    {
      v5 = *((_BYTE *)&byte_A2F73 + 0x1EE * v4);
      v22 = 4 * (unsigned __int8)byte_A2F74[0x1EE * v4] + 0x13;
      v23 = &byte_1050A4[0x14 * v5];
    }
    if ( *(_WORD *)(result + 0xAB) == (unsigned __int8)byte_104BEA )
    {
      v6 = 0;
      for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
      {
        if ( i != (unsigned __int8)byte_104BEA && byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + i] )
        {
          ++v6;
        }
      }
      v18 = SHIWORD(dword_A3CF2) - 1;
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xB);// 11: "%d of %d Species Known"
      sprintf(s, sub_1CEA8, v6, v18);
      v23 = s;
      v25 = 0;
      v22 = 0xF3;
      v24 = 0xF2;
      v3 = 0;
    }
    if ( v21 == 0xFFFFFFFF )
    {
      v9 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xC);    // 12: "Extinct"
      sprintf(s, v9);
      v23 = s;
      v22 = 0xF3;
      v25 = 0;
    }
    if ( !v25 )
    {
      if ( v3 == 0xFFFFFFFF )
      {
        sub_5E9D0((P_Type5)(result + 4), v24);
        v19 = 0;
        v17 = v24;
        v10 = v22;
        v11 = (_DWORD *)(result + 4);
      }
      else
      {
        v10 = v22;
        v19 = v25;
        v11 = (_DWORD *)(result + 4);
        v17 = 0xFF;
      }
      v12 = v23;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *v11;
      v13 = v11 + 1;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *v13++;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *v13++;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *v13;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v13[1];
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, v12, 0x43, v10, v17, v19);
    }
    if ( v26 )
    {
      v14 = *(__int16 *)(result + 0xAB);
      if ( v14 != (unsigned __int8)byte_104BEA && v25 != 0xFFFFFFFF )
      {
        sub_53E38((P_Type5)(result + 4), 0xE, 3, v14);
        v15 = 0xFFFFFFFF;
        if ( !v21 )
        {
          if ( v26 == 3 )
          {
            v15 = 9;
          }
          else if ( v26 == 2 )
          {
            v15 = 8;
          }
        }
        if ( v15 != 0xFFFFFFFF )
        {
          v16 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEF2);
          sub_5CB3C((P_Type5)(result + 4), v16, v15, 0xE, 3);
        }
      }
    }
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(result + 4));
  }
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// FFEF2: using guessed type __int16 word_FFEF2;

//----- (00025FB4) --------------------------------------------------------
int __fastcall sub_25FB4(int result)
{
  if ( *(_DWORD *)(result + 0x39) )
  {
    return (*(int (**)(void))(*(_DWORD *)(result + 0xA7) + 0xC))();
  }
  return result;
}

//----- (00026000) --------------------------------------------------------
unsigned int __fastcall sub_26000(int a1, __int16 a2, __int16 a3, int a4)
{
  __int16 v5; // ax
  unsigned int result; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // [esp-4h] [ebp-14h]

  switch ( a2 )
  {
    case 1:
      v5 = *(char *)(a1 + 0x25) - 0x31;
      *(_WORD *)(a1 + 0xAB) = v5;
      if ( v5 < SHIWORD(dword_A3CF2) )
      {
        goto LABEL_10;
      }
      result = 0;
      break;
    case 2:
      *(_DWORD *)(a1 + 0x39) = 0;
      v7 = *(_DWORD *)(a1 + 0x10);
      v8 = *(_DWORD *)(a1 + 8);
      v11 = *(_DWORD *)(a1 + 0x14);
      v9 = *(_DWORD *)(a1 + 0xC);
      *(_DWORD *)(a1 + 0x35) = 0;
      sub_55214((int)&V_Type3_stru_10AE70, v8, v9, v7, v11);
      result = 0;
      break;
    case 4:
    case 5:
      v10 = *(__int16 *)(a1 + 0xAB);
      if ( byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v10]
        && v10 != (unsigned __int8)byte_104BEA
        && *(int *)((char *)&dword_A2F75 + 0x1EE * v10) != 0xFFFFFFFF )
      {
        byte_968DD = *(_BYTE *)(a1 + 0xAB);
        goto LABEL_10;
      }
      result = 0;
      break;
    case 6:
      goto LABEL_13;
    case 7:
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0x10))();
      result = 0xFFFFFFFF;
      break;
    case 0xB:
      *(_WORD *)(a1 + 0xAB) = a3;
LABEL_13:
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
      result = 0xFFFFFFFF;
      break;
    case 0xD:
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      result = sub_2F424(a1, a2, a3, a4);
      break;
    default:
LABEL_10:
      result = sub_2F424(a1, a2, a3, a4);
      break;
  }
  return result;
}
// 968DD: using guessed type char byte_968DD;
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00026140) --------------------------------------------------------
int __fastcall sub_26140(int a1)
{
  return ((int (__fastcall *)(int, _DWORD))locret_1B66C)(a1 + 0x1E, 0) - 0x1E;
}

//----- (00026150) --------------------------------------------------------
char *__fastcall sub_26150(int a1)
{
  return (char *)sub_1B4F0((_DWORD *)(a1 + 0x1E)) + 0xFFFFFFE2;
}

//----- (00026160) --------------------------------------------------------
int sub_26160()
{
  sub_2632C();
  sub_2C6CC(&V_Type6_stru_D8654);
  sub_4FE8C((int)&unk_10914C);
  return printf("\n%s\n\n", "Thank you for playing Ascendancy.");
}

//----- (00026194) --------------------------------------------------------
void Q_debugbreak_sub_26194()
{
  __debugbreak();
}

//----- (00026198) --------------------------------------------------------
void __fastcall __spoils<> Q_AssertLogBreakExit_sub_26198(int assert, const char *sourcefile, int line)
{
  if ( !assert )
  {
    sprintf("Thank you for playing Ascendancy.", "Assert Failed: <%s> Line %d\n\n", sourcefile, line);
    Q_debugbreak_exit_sub_2624C();
  }
  JUMPOUT(0x26195);
}
// 2619A: control flows out of bounds to 26195

//----- (000261A8) --------------------------------------------------------
void __fastcall __spoils<> Q_AssertLogBreakExit_sub_261A8(int assert, const char *sourcefile, int line)
{
  if ( !assert )
  {
    sprintf("Thank you for playing Ascendancy.", "Assert Failed: <%s> Line %d\n\n", sourcefile, line);
    Q_debugbreak_exit_sub_2624C();
  }
  JUMPOUT(0x26195);
}
// 261AA: control flows out of bounds to 26195

//----- (000261B8) --------------------------------------------------------
int __fastcall sub_261B8(int result, const char *a2, int a3)
{
  const char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char v7[264]; // [esp+0h] [ebp-108h] BYREF

  if ( !result )
  {
    v3 = "Thank you for playing Ascendancy.";
    v4 = v7;
    do
    {
      v5 = *v3;
      *v4 = *v3;
      if ( !v5 )
      {
        break;
      }
      v6 = v3[1];
      v3 += 2;
      v4[1] = v6;
      v4 += 2;
    }
    while ( v6 );
    sprintf("Thank you for playing Ascendancy.", "Assert Failed: <%s> Line %d\n\n%s\n", a2, a3, v7);
    Q_debugbreak_exit_sub_2624C();
  }
  return result;
}

//----- (0002620C) --------------------------------------------------------
int __cdecl sub_2620C(char *format, char a2)
{
  char *v3; // [esp+0h] [ebp-Ch] BYREF

  v3 = &a2;
  return vsprintf("Thank you for playing Ascendancy.", format, &v3);
}

//----- (0002624C) --------------------------------------------------------
void __noreturn Q_debugbreak_exit_sub_2624C()
{
  Q_debugbreak_sub_26194();
  exit(1);
}

//----- (0002625C) --------------------------------------------------------
void *__fastcall sub_2625C(void *aData, int a2, char *a3)
{
  void *v3; // esi

  v3 = aData;
  if ( aData )
  {
    Q_WINMGR_CPP_sub_5A094(&V_Type3_stru_10AE70, aData, a2, a3);
    return v3;
  }
  return aData;
}

//----- (0002627C) --------------------------------------------------------
void __fastcall sub_2627C(void *a1)
{
  Q_WINMGR_CPP_sub_5A144(&V_Type3_stru_10AE70, a1);
}

//----- (0002628C) --------------------------------------------------------
void *__fastcall sub_2628C(size_t a1, int a2, char *s2)
{
  void *result; // eax
  void *v4; // esi

  result = malloc(a1);
  v4 = result;
  if ( result )
  {
    Q_WINMGR_CPP_sub_5A094(&V_Type3_stru_10AE70, result, a2, s2);
    return v4;
  }
  return result;
}

//----- (000262B0) --------------------------------------------------------
void *__fastcall sub_262B0(size_t a1, size_t a2, int a3, char *a4)
{
  void *result; // eax
  void *v5; // esi

  result = calloc(a1, a2);
  v5 = result;
  if ( result )
  {
    Q_WINMGR_CPP_sub_5A094(&V_Type3_stru_10AE70, result, a3, a4);
    return v5;
  }
  return result;
}

//----- (000262CC) --------------------------------------------------------
void __fastcall sub_262CC(void *ptr)
{
  Q_WINMGR_CPP_sub_5A144(&V_Type3_stru_10AE70, ptr);
  free(ptr);
}

//----- (000262F0) --------------------------------------------------------
void sub_262F0()
{
  _wcpp_2_mod_register_(&unk_96768);
  sub_26314();
  dword_96770 = 1;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96770: using guessed type int dword_96770;

//----- (00026314) --------------------------------------------------------
void sub_26314()
{
  ;
}

//----- (0002631C) --------------------------------------------------------
void sub_2631C()
{
  sub_2632C();
  sub_26328();
}

//----- (0002632C) --------------------------------------------------------
void sub_2632C()
{
  if ( dword_D8628 )
  {
    sub_660FF();
  }
  else
  {
    sub_26328();
  }
}
// D8628: using guessed type int dword_D8628;

//----- (0002633C) --------------------------------------------------------
int sub_2633C()
{
  dword_D8628 = sub_65EA4(640, 480);
  return (dword_D8628 == 0) - 1;
}
// D8628: using guessed type int dword_D8628;

//----- (00026360) --------------------------------------------------------
__int16 __fastcall __spoils<> sub_26360(__int16 a1)
{
  bool v1; // zf
  int v2; // eax

  HIBYTE(a1) = 2;
  __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
  HIWORD(dword_D8622) = a1;
  if ( (a1 & 1) != 0 || (a1 & 2) != 0 )
  {
    a3 = 0xFFFFFFFF;
  }
  else
  {
    a3 = 0;
  }
  dword_D8604 = ((a1 & 4) == 0) - 1;
  dword_D8600 = ((a1 & 8) == 0) - 1;
  dword_D8614 = ((a1 & 0x10) == 0) - 1;
  dword_D8610 = ((a1 & 0x20) == 0) - 1;
  dword_D860C = ((a1 & 0x40) == 0) - 1;
  v2 = ((a1 & 0x80) == 0) - 1;
  v1 = v2 == 0;
  dword_D8618 = v2;
  BYTE1(v2) = 1;
  __asm { int     16h; KEYBOARD - CHECK BUFFER, DO NOT CLEAR }
  if ( v1 )
  {
    LOWORD(v2) = 0;
  }
  if ( (_WORD)v2 )
  {
    __asm { int     16h; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY }
    LOWORD(dword_D8622) = (unsigned __int8)v2;
    LOWORD(v2) = 0;
    dword_D85FC = 0xFFFFFFFF;
    word_D8620 = 0;
  }
  else
  {
    dword_D85FC = 0;
  }
  return v2;
}
// D85FC: using guessed type int dword_D85FC;
// D8600: using guessed type int dword_D8600;
// D8604: using guessed type int dword_D8604;
// D860C: using guessed type int dword_D860C;
// D8610: using guessed type int dword_D8610;
// D8614: using guessed type int dword_D8614;
// D8618: using guessed type int dword_D8618;
// D8620: using guessed type __int16 word_D8620;
// D8622: using guessed type int dword_D8622;

//----- (000264B4) --------------------------------------------------------
unsigned int sub_264B4()
{
  unsigned int result; // eax
  int v1; // [esp+0h] [ebp-2Ch] BYREF
  unsigned int v2; // [esp+4h] [ebp-28h] BYREF
  int v3; // [esp+8h] [ebp-24h] BYREF
  int v4; // [esp+Ch] [ebp-20h] BYREF
  int v5[7]; // [esp+10h] [ebp-1Ch] BYREF

  sub_64FFE(&v1, &v2, &v3, &v4, v5);
  if ( v1 == dword_D8648 && (result = v2, v2 == dword_D864C) )
  {
    dword_D8644 = 0;
  }
  else
  {
    dword_D8648 = v1;
    result = v2;
    dword_D8644 = 0xFFFFFFFF;
    dword_D864C = v2;
  }
  if ( v3 == dword_D862C )
  {
    dword_D8638 = 0;
  }
  else
  {
    result = 0xFFFFFFFF;
    dword_D862C = v3;
    dword_D8638 = 0xFFFFFFFF;
  }
  if ( v4 == dword_D8630 )
  {
    dword_D863C = 0;
  }
  else
  {
    dword_D8630 = v4;
    dword_D863C = 0xFFFFFFFF;
  }
  return result;
}
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;
// 264B4: using guessed type int var_1C[7];

//----- (0002656C) --------------------------------------------------------
int __fastcall sub_2656C(__int16 a1)
{
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D8644 = 0;
  dword_D85FC = 0;
  sub_26360(a1);
  if ( dword_D8628 )
  {
    sub_264B4();
  }
  return dword_96774;
}
// 96774: using guessed type int dword_96774;
// D85FC: using guessed type int dword_D85FC;
// D8628: using guessed type int dword_D8628;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;

//----- (000265A8) --------------------------------------------------------
void __fastcall sub_265A8(int a1)
{
  unsigned __int16 v1; // dx
  int v2; // edx
  int v3; // eax
  __int16 v4; // dx
  __int16 v5; // dx

  dword_D8644 = 0;
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D85FC = 0;
  v1 = *(_WORD *)(a1 + 8);
  if ( v1 < 2u )
  {
    if ( v1 == 1 )
    {
      v2 = *(_DWORD *)(a1 + 0xC);
      v3 = *(_DWORD *)(a1 + 0x10);
      dword_D8648 = v2;
      dword_D864C = v3;
      sub_6507C(v2, v3);
      dword_D8644 = 0xFFFFFFFF;
    }
  }
  else if ( v1 <= 2u )
  {
    if ( *(_DWORD *)(a1 + 0xC) )
    {
      dword_D8630 = *(_DWORD *)(a1 + 0x10);
      dword_D863C = 0xFFFFFFFF;
    }
    else
    {
      dword_D862C = *(_DWORD *)(a1 + 0x10);
      v4 = *(_WORD *)(a1 + 0xA);
      dword_D8638 = 0xFFFFFFFF;
      if ( v4 && dword_D862C )
      {
        a3 = 0xFFFFFFFF;
      }
      else
      {
        a3 = 0;
      }
    }
  }
  else if ( v1 == 3 )
  {
    HIWORD(dword_D8622) = *(_WORD *)(a1 + 0xA);
    v5 = *(_WORD *)(a1 + 0xC);
    LOWORD(dword_D8622) = *(_WORD *)(a1 + 0x10);
    word_D8620 = v5;
    dword_D85FC = 0xFFFFFFFF;
    if ( (dword_D8622 & 0x10000) != 0 || (dword_D8622 & 0x20000) != 0 )
    {
      a3 = 0xFFFFFFFF;
    }
    else
    {
      a3 = 0;
    }
    dword_D8604 = ((dword_D8622 & 0x40000) == 0) - 1;
    dword_D8600 = ((dword_D8622 & 0x80000) == 0) - 1;
    dword_D8614 = ((dword_D8622 & 0x100000) == 0) - 1;
    dword_D8610 = ((dword_D8622 & 0x200000) == 0) - 1;
    dword_D860C = ((dword_D8622 & 0x400000) == 0) - 1;
    if ( (dword_D8622 & 0x800000) != 0 )
    {
      dword_D8618 = 0xFFFFFFFF;
    }
    else
    {
      dword_D8618 = 0;
    }
  }
}
// D85FC: using guessed type int dword_D85FC;
// D8600: using guessed type int dword_D8600;
// D8604: using guessed type int dword_D8604;
// D860C: using guessed type int dword_D860C;
// D8610: using guessed type int dword_D8610;
// D8614: using guessed type int dword_D8614;
// D8618: using guessed type int dword_D8618;
// D8620: using guessed type __int16 word_D8620;
// D8622: using guessed type int dword_D8622;
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;

//----- (000267A0) --------------------------------------------------------
void __fastcall __spoils<> sub_267A0(P_TypeA5 a1)
{
  sub_2FC50(&a1->a);
  a1->a.b = (int)off_95C70;
  sub_26800(a1);
}
// 95C70: using guessed type int (*off_95C70[5])();

//----- (000267BC) --------------------------------------------------------
int __fastcall sub_267BC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95C2C);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95C70;
    v5 = (void *)sub_2FC68(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95C70: using guessed type int (*off_95C70[5])();

//----- (00026800) --------------------------------------------------------
void __fastcall __spoils<> sub_26800(P_TypeA5 result)
{
  result->b[0x341] = 0;
}

//----- (00026874) --------------------------------------------------------
char __fastcall sub_26874(int a1, __int16 *a2)
{
  char *v3; // edi
  char *v4; // esi
  char v5; // al
  char v6; // al
  __int16 *v7; // ebx
  int v8; // edx
  int v9; // esi
  __int16 v10; // kr00_2
  char *v11; // eax
  unsigned __int8 v12; // bl
  int v13; // ebx
  _WORD *v14; // edx
  int v15; // ebx
  int v16; // esi
  int v17; // ebx
  int v18; // eax
  int v19; // esi
  int v20; // edi
  int v21; // edx
  int v22; // eax
  int v23; // eax
  char *v24; // eax
  int v25; // edx
  int v26; // edi
  int v27; // esi
  int v28; // edi
  int v29; // esi
  _DWORD *v30; // edi
  int v31; // eax
  int v32; // edx
  __int16 v33; // bx
  int v34; // edx
  int v35; // eax
  int v36; // edx
  int v37; // eax
  int v38; // ebx
  __int16 v39; // ax
  int v40; // ecx
  __int16 v41; // ax
  int v42; // edx
  int v43; // edx
  int v44; // edx
  int v46; // [esp-8h] [ebp-298h]
  char *sub_1CEA8; // [esp-4h] [ebp-294h]
  char format[600]; // [esp+0h] [ebp-290h] BYREF
  char s[32]; // [esp+258h] [ebp-38h] BYREF
  int v50; // [esp+27Ch] [ebp-14h]
  int v51; // [esp+280h] [ebp-10h]
  int v52; // [esp+284h] [ebp-Ch]
  int v53; // [esp+288h] [ebp-8h]
  int v54; // [esp+28Ch] [ebp-4h]

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x48);
  }
  *(_DWORD *)(a1 + 0xDAF) = a2;
  sprintf(s, "event%02d", *a2);
  sub_2FCB0((_DWORD *)a1, "help.txt", s);
  v51 = a1 + 0xC95;
  v54 = a1 + 0xCB0;
  if ( *(_BYTE *)(a1 + 0xC95) != 1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x55);
  }
  if ( *(int *)(a1 + 0xDA3) > 1 && *(_BYTE *)v54 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x57);
  }
  v3 = format;
  v4 = *(char **)(v51 + 5);
  do
  {
    v5 = *v4;
    *v3 = *v4;
    if ( !v5 )
    {
      break;
    }
    v6 = v4[1];
    v4 += 2;
    v3[1] = v6;
    v3 += 2;
  }
  while ( v6 );
  v7 = *(__int16 **)(a1 + 0xDAF);
  v8 = *(_DWORD *)(v7 + 1);
  v9 = *(_DWORD *)(v7 + 3);
  v10 = *v7;
  v53 = v8 + 0x24;
  v52 = v9 + 0x24;
  v50 = 5 * v8;
  v11 = &byte_10525A[0x4B * v8];
  switch ( v10 )
  {
    case 0:
      sprintf(
        *(char **)(v51 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
        &byte_10525A[0x4B * v8]);
      v11 = (char *)v54;
      *(_WORD *)(v54 + 1) = 0x1F;
      *(_WORD *)(v11 + 3) = v8;
      break;
    case 1:
      v12 = *((_BYTE *)v7 + 6);
      sprintf(
        *(char **)(v51 + 5),
        format,
        &dword_103F9A[0xA * v12 + 3],
        v53,
        v53,
        *(unsigned __int16 *)(v8 + 0x42) - *(unsigned __int16 *)(v8 + 0x4C));
      *(_WORD *)(v54 + 1) = 0x1E;
      *(_WORD *)(v54 + 3) = v12;
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = *(_WORD *)(v8 + 0x14);
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * *(_WORD *)(v8 + 0x16);
      break;
    case 2:
      v33 = v7[1];
      sprintf(*(char **)(v51 + 5), format, &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v33)]);
      v11 = (char *)v54;
      *(_WORD *)(v54 + 3) = 0;
      *(_WORD *)(v11 + 1) = v33;
      break;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 0x14:
      v18 = *(_DWORD *)(a1 + 0xDAF);
      v19 = *(_DWORD *)(v18 + 2);
      v20 = *(_DWORD *)(v18 + 6);
      if ( *(_BYTE *)(v19 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xB3);
      }
      v21 = *(_DWORD *)(v19 + 0x59);
      if ( **(_WORD **)(a1 + 0xDAF) == 0x14 )
      {
        if ( *(_WORD *)(v21 + 0x44) == 1 )
        {
          v22 = 0xD;
        }
        else
        {
          v22 = 0xE;
        }
        sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v22);
        v46 = *(__int16 *)(v21 + 0x44);
        if ( *(_WORD *)(v21 + 0x5A) == 1 )
        {
          v23 = 0xD;
        }
        else
        {
          v23 = 0xE;
        }
        v24 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v23);
        sprintf(*(char **)(v51 + 5), format, v19 + 0x34, v21 + 0x1C, *(__int16 *)(v21 + 0x5A), v24, v46, sub_1CEA8);
      }
      else
      {
        sprintf(
          *(char **)(v51 + 5),
          format,
          v19 + 0x34,
          v21 + 0x1C,
          &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v20)]);
      }
      v25 = v54;
      *(_WORD *)(v54 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      LOWORD(v11) = *(char *)(v19 + 0xAA);
      *(_WORD *)(v25 + 3) = (_WORD)v11;
      break;
    case 8:
    case 9:
      v26 = *(_DWORD *)(a1 + 0xDAF);
      v27 = *(_DWORD *)(v26 + 2);
      v28 = *(_DWORD *)(v26 + 6);
      if ( *(_BYTE *)(v27 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xCD);
      }
      if ( **(_WORD **)(a1 + 0xDAF) == 9 )
      {
        sprintf(
          *(char **)(v51 + 5),
          format,
          &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v28)],
          *(_DWORD *)(v27 + 0x59) + 0x1C);
      }
      else
      {
        sprintf(*(char **)(v51 + 5), format, *(_DWORD *)(v27 + 0x59) + 0x1C);
      }
      *(_WORD *)(v54 + 1) = v28 + 0xE;
      LOWORD(v11) = *(char *)(v27 + 0xAA);
      *(_WORD *)(v54 + 3) = (_WORD)v11;
      break;
    case 0xA:
      sprintf(*(char **)(v51 + 5), format, &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v8)]);
      v34 = v54;
      LOWORD(v11) = *(_WORD *)(*(_DWORD *)(a1 + 0xDAF) + 2);
      *(_WORD *)(v54 + 3) = 0;
      *(_WORD *)(v34 + 1) = (_WORD)v11;
      break;
    case 0xB:
    case 0xC:
      v35 = *(_DWORD *)(a1 + 0xDAF);
      v36 = *(_DWORD *)(v35 + 2);
      v37 = *(_DWORD *)(v35 + 6);
      if ( v37 )
      {
        sprintf(*(char **)(v51 + 5), format, v37 + 0x1C);
      }
      v38 = v54;
      v39 = (unsigned __int8)byte_104BEA;
      *(_WORD *)(v54 + 3) = v36;
      LOWORD(v11) = v39 + 0xE;
      *(_WORD *)(v38 + 1) = (_WORD)v11;
      break;
    case 0xD:
      v40 = v8;
      if ( !v8 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x114);
      }
      sprintf(
        *(char **)(v51 + 5),
        format,
        v8 + 0x24,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(unsigned __int8 *)(v8 + 0x57))]);
      v41 = sub_1B270((int)&unk_12FC20, "data\\planets.shp", 0);
      v42 = v54;
      *(_WORD *)(v54 + 1) = v41;
      if ( *(unsigned __int16 *)(v42 + 1) == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x118);
      }
      LOWORD(v11) = 5 * *(_WORD *)(v40 + 0x16) + *(_WORD *)(v40 + 0x14);
      *(_WORD *)(v54 + 3) = (_WORD)v11;
      break;
    case 0xF:
      sprintf(*(char **)(v51 + 5), format, v53);
      *(_WORD *)(v54 + 1) = 0x1D;
      LOWORD(v11) = 5 * *(_WORD *)(v8 + 0x16) + *(_WORD *)(v8 + 0x14);
      *(_WORD *)(v54 + 3) = (_WORD)v11;
      *(_WORD *)(a1 + 0xCCC) = 0x2C;
      *(_WORD *)(a1 + 0xCCE) = 2;
      break;
    case 0x10:
      sprintf(*(char **)(v51 + 5), format, v8 + 0x34, v52);
      v17 = v54;
      *(_WORD *)(v54 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      *(_WORD *)(v17 + 3) = *(char *)(v8 + 0xAA);
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = *(_WORD *)(v9 + 0x14);
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * *(_WORD *)(v9 + 0x16);
      break;
    case 0x11:
    case 0x12:
      v13 = *(_DWORD *)(a1 + 0xDAF);
      v14 = *(_WORD **)(v13 + 6);
      v15 = *(_DWORD *)(v13 + 2);
      sprintf(
        *(char **)(v51 + 5),
        format,
        v15 + 0x34,
        v14 + 0x12,
        v14 + 0x12,
        (unsigned __int16)v14[0x21] - (unsigned __int16)v14[0x26]);
      v16 = v54;
      *(_WORD *)(v54 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      *(_WORD *)(v16 + 3) = *(char *)(v15 + 0xAA);
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = v14[0xA];
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * v14[0xB];
      break;
    case 0x13:
      LOBYTE(v11) = sprintf(*(char **)(v51 + 5), format, v8 + 0x1C);
      break;
    case 0x15:
      v43 = v54;
      sprintf(
        *(char **)(v51 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)]);
      *(_WORD *)(v43 + 3) = 0;
      LOBYTE(v11) = byte_104BEA;
      *(_WORD *)(v43 + 1) = (unsigned __int8)byte_104BEA;
      break;
    case 0x16:
      sprintf(
        *(char **)(v51 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
        v52,
        &byte_10525A[0x4B * v8]);
      v11 = (char *)v54;
      *(_WORD *)(v54 + 1) = 0x1F;
      *(_WORD *)(v11 + 3) = v8;
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = *(_WORD *)(v9 + 0x14);
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * *(_WORD *)(v9 + 0x16);
      break;
    case 0x17:
      v29 = v8;
      if ( *(_BYTE *)(v8 + 0x58) != 5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xE0);
      }
      v30 = *(_DWORD **)(v8 + 0x59);
      if ( !v30 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xE3);
      }
      v31 = *v30;
      if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*v30 + 0x17)) == 0 )
      {
        v31 = v30[1];
      }
      sprintf(*(char **)(v51 + 5), format, v8 + 0x34, v31 + 0x1C);
      v32 = v54;
      *(_WORD *)(v54 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      LOWORD(v11) = *(char *)(v29 + 0xAA);
      *(_WORD *)(v32 + 3) = (_WORD)v11;
      break;
    case 0x19:
      sprintf(
        *(char **)(v51 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)]);
      v44 = v54;
      LOBYTE(v11) = byte_104BEA;
      *(_WORD *)(v54 + 3) = 0;
      *(_WORD *)(v44 + 1) = (unsigned __int8)v11;
      break;
    default:
      return (char)v11;
  }
  return (char)v11;
}
// 26D02: conditional instruction was optimized away because bh.1!=4
// 103F9A: using guessed type int dword_103F9A[];

//----- (000270F4) --------------------------------------------------------
unsigned int __fastcall sub_270F4(int a1, __int16 a2, int a3, int a4)
{
  int v5; // ebx

  if ( !a2 || (unsigned __int16)a2 > 1u )
  {
    return sub_2FD68(a1, a2, a3, a4);
  }
  *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
  v5 = *(_DWORD *)(a1 + 0xA7);
  *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
  (*(void (**)(void))(v5 + 0xC))();
  return 0;
}

//----- (0002712C) --------------------------------------------------------
void __fastcall __spoils<> sub_2712C(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95C58;
}
// 95C58: using guessed type int (*off_95C58[5])();

//----- (0002713C) --------------------------------------------------------
int __fastcall sub_2713C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95C18);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95C58;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95C58: using guessed type int (*off_95C58[5])();

//----- (00027184) --------------------------------------------------------
unsigned int __fastcall sub_27184(int a1, __int16 a2, int a3, int a4)
{
  if ( !a2 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 1u )
  {
    sub_4F8CC((int)&unk_10914C, *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA) + 8, 0);
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( a2 != 2 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  sub_56B60((int)&V_Type3_stru_10AE70, 1, 1, 1);
  return 0xFFFFFFFF;
}

//----- (000271FC) --------------------------------------------------------
__int64 __fastcall sub_271FC(int a1)
{
  int v1; // ecx
  FILE *v2; // ebp
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char *v7; // esi
  char *v8; // edi
  char v9; // al
  char v10; // al
  char *v11; // esi
  char *v12; // edi
  char v13; // al
  char v14; // al
  char *v15; // esi
  char *v16; // edi
  char v17; // al
  char v18; // al
  char *v19; // esi
  char *v20; // edi
  char v21; // al
  char v22; // al
  char *v23; // esi
  char *v24; // edi
  char v25; // al
  char v26; // al
  char *v27; // ecx
  int v28; // esi
  char v29; // ah
  char v30; // bl
  char *v31; // ecx
  int v32; // esi
  char v33; // al
  char v34; // dh
  int v35; // eax
  unsigned __int8 v36; // al
  const char *v37; // ecx
  int v38; // esi
  unsigned __int8 v39; // al
  char v41[1004]; // [esp+0h] [ebp-624h] BYREF
  char s[204]; // [esp+3ECh] [ebp-238h] BYREF
  char v43[204]; // [esp+4B8h] [ebp-16Ch] BYREF
  char s1[60]; // [esp+584h] [ebp-A0h] BYREF
  T_Type5 v45; // [esp+5C0h] [ebp-64h] BYREF
  int v46; // [esp+5D4h] [ebp-50h]
  char *v47; // [esp+5D8h] [ebp-4Ch]
  int v48; // [esp+5DCh] [ebp-48h]
  int v49; // [esp+5E0h] [ebp-44h] BYREF
  int v50; // [esp+5E4h] [ebp-40h]
  int v51; // [esp+5E8h] [ebp-3Ch]
  int v52; // [esp+5ECh] [ebp-38h]
  int v53; // [esp+5F0h] [ebp-34h]
  int v54; // [esp+5F4h] [ebp-30h]
  int v55; // [esp+5F8h] [ebp-2Ch]
  int v56; // [esp+5FCh] [ebp-28h]
  int v57; // [esp+600h] [ebp-24h]
  char *v58; // [esp+604h] [ebp-20h]
  int v59; // [esp+608h] [ebp-1Ch]
  int v60; // [esp+60Ch] [ebp-18h]

  v46 = a1;
  v1 = *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA);
  v58 = byte_D8DA0;
  byte_D8DA0[0] = 0;
  v41[0] = 0;
  v2 = sub_1BB10("history.txt", 0);
  if ( !v2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x1C1);
  }
  v51 = 0;
  do
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
    sscanf(s, "%s", s1);
    if ( !stricmp(s1, "SPECNUM") )
    {
      sscanf(s, "%s %d", s1, &v49);
      if ( v1 == v49 )
      {
        v51 = 1;
      }
    }
    else if ( !stricmp(s1, "END") )
    {
      sub_2620C("Species %d not found in history file.\n", v1);
      sub_261B8(0, "..\\eventwnd.cpp", 0x1E8);
    }
  }
  while ( !v51 );
  v48 = 0;
  if ( v51 != 2 )
  {
    v47 = &byte_1050A4[0x14 * v1];
    do
    {
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
      sscanf(s, "%s", s1);
      if ( !stricmp(s1, "SPECNUM") || !stricmp(s1, "END") )
      {
        v51 = 2;
      }
      else if ( !stricmp(s1, "POWER") )
      {
        v53 = 0;
        v56 = 0;
        sprintf(v43, "%s: ", v47);
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDPOWER", 8u) )
          {
            v53 = 0xFFFFFFFF;
          }
          else
          {
            v56 += strlen(s);
            if ( v56 >= 0xC4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x238);
            }
            v3 = s;
            v4 = &v43[strlen(v43)];
            do
            {
              v5 = *v3;
              *v4 = *v3;
              if ( !v5 )
              {
                break;
              }
              v6 = v3[1];
              v3 += 2;
              v4[1] = v6;
              v4 += 2;
            }
            while ( v6 );
          }
        }
        while ( !v53 );
      }
      else if ( !stricmp(s1, "INTRO") )
      {
        v59 = 0;
        v55 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDINTRO", 8u) )
          {
            v59 = 0xFFFFFFFF;
            v48 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x24D);
            }
            v7 = s;
            v8 = &v41[strlen(v41)];
            do
            {
              v9 = *v7;
              *v8 = *v7;
              if ( !v9 )
              {
                break;
              }
              v10 = v7[1];
              v7 += 2;
              v8[1] = v10;
              v8 += 2;
            }
            while ( v10 );
          }
        }
        while ( !v59 );
      }
      else if ( !stricmp(s1, "PEACE") && v48 == 0xFFFFFFFF && !byte_A3D20 )
      {
        v50 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDPEACE", 8u) )
          {
            v50 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x25F);
            }
            v11 = s;
            v12 = &v41[strlen(v41)];
            do
            {
              v13 = *v11;
              *v12 = *v11;
              if ( !v13 )
              {
                break;
              }
              v14 = v11[1];
              v11 += 2;
              v12[1] = v14;
              v12 += 2;
            }
            while ( v14 );
          }
        }
        while ( !v50 );
      }
      else if ( !stricmp(s1, "NEUTRAL") && v48 == 0xFFFFFFFF && byte_A3D20 == 1 )
      {
        v57 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDNEUTRAL", 0xAu) )
          {
            v57 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x271);
            }
            v15 = s;
            v16 = &v41[strlen(v41)];
            do
            {
              v17 = *v15;
              *v16 = *v15;
              if ( !v17 )
              {
                break;
              }
              v18 = v15[1];
              v15 += 2;
              v16[1] = v18;
              v16 += 2;
            }
            while ( v18 );
          }
        }
        while ( !v57 );
      }
      else if ( !stricmp(s1, "HOSTILE") && v48 == 0xFFFFFFFF && byte_A3D20 == 2 )
      {
        v52 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDHOSTILE", 0xAu) )
          {
            v52 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x283);
            }
            v19 = s;
            v20 = &v41[strlen(v41)];
            do
            {
              v21 = *v19;
              *v20 = *v19;
              if ( !v21 )
              {
                break;
              }
              v22 = v19[1];
              v19 += 2;
              v20[1] = v22;
              v20 += 2;
            }
            while ( v22 );
          }
        }
        while ( !v52 );
      }
      else if ( !stricmp(s1, "TEXT") )
      {
        v60 = 0;
        v54 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDTEXT", 7u) )
          {
            v60 = 0xFFFFFFFF;
          }
          else
          {
            v54 += strlen(s);
            if ( v54 >= 0xBB4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x295);
            }
            v23 = s;
            v24 = &v58[strlen(v58)];
            do
            {
              v25 = *v23;
              *v24 = *v23;
              if ( !v25 )
              {
                break;
              }
              v26 = v23[1];
              v23 += 2;
              v24[1] = v26;
              v24 += 2;
            }
            while ( v26 );
          }
        }
        while ( !v60 );
      }
    }
    while ( v51 != 2 );
  }
  v27 = v41;
  fclose(v2);
  v28 = 0;
  if ( v41[0] )
  {
    while ( 1 )
    {
      if ( v28 >= 0x3E5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x2AB);
      }
      v29 = *v27;
      if ( *v27 == 0xA )
      {
        break;
      }
      if ( v29 == 0x40 )
      {
        *v27 = 0xA;
      }
      else if ( v29 == 0x5F )
      {
        break;
      }
LABEL_95:
      v30 = *++v27;
      ++v28;
      if ( !v30 )
      {
        goto LABEL_96;
      }
    }
    *v27 = 0x20;
    goto LABEL_95;
  }
LABEL_96:
  if ( !v58 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x2B7);
  }
  v31 = v58;
  v32 = 0;
  if ( *v58 )
  {
    while ( 1 )
    {
      if ( v32 >= 0xBB5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x2BD);
      }
      v33 = *v31;
      if ( *v31 == 0xA )
      {
        break;
      }
      if ( v33 == 0x40 )
      {
        *v31 = 0xA;
      }
      else if ( v33 == 0x5F )
      {
        break;
      }
LABEL_106:
      v34 = *++v31;
      ++v32;
      if ( !v34 )
      {
        goto LABEL_107;
      }
    }
    *v31 = 0x20;
    goto LABEL_106;
  }
LABEL_107:
  v35 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEAE[(unsigned __int8)byte_104BEA]);
  sub_5CB3C((P_Type5)&V_Type6_stru_D8654.pane, v35, 0, 7, 0x2E);
  v45.a = *(P_Type6 *)(v46 + 4);
  v45.rect.x2 = 0x278;
  v45.rect.x1 = 7;
  v45.rect.y1 = 0x105;
  v45.rect.y2 = 0x1D1;
  v36 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v37 = v58;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v45.a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = 7;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v45.rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v45.rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v45.rect.y2;
  v38 = v46;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0xA, v37, 0, 4 * v36 + 0x13, 0xFF, 0x257);
  v45.a = *(P_Type6 *)(v38 + 4);
  v45.rect.x2 = 0x278;
  v45.rect.y2 = 0xF5;
  v45.rect.x1 = 0x138;
  v45.rect.y1 = 0x2E;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v45.a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = 0x138;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v45.rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v45.rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v45.rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0xA, v41, 0, 0xF3, 0xFF, 0x126);
  v45.a = *(P_Type6 *)(v46 + 4);
  v45.rect.x1 = 7;
  v45.rect.y1 = 7;
  v45.rect.x2 = 0x278;
  v45.rect.y2 = 0x25;
  sub_53E38(&v45, 3, 3, (unsigned __int8)byte_104BEA);
  v39 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v45;
  return (unsigned int)sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xA, v43, 2, 4 * v39 + 0x13, 0xFF, 0x25A);
}
// A3D20: using guessed type char byte_A3D20;
// FFEAE: using guessed type __int16 word_FFEAE[7];
// 271FC: using guessed type char var_624[1004];
// 271FC: using guessed type char var_16C[204];

//----- (00027BF8) --------------------------------------------------------
void __fastcall __spoils<> sub_27BF8(P_TypeA2 a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95C40;
}
// 95C40: using guessed type int (*off_95C40[5])();

//----- (00027C08) --------------------------------------------------------
int __fastcall sub_27C08(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95C04);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95C40;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95C40: using guessed type int (*off_95C40[5])();

//----- (00027C50) --------------------------------------------------------
unsigned int __fastcall sub_27C50(int a1, __int16 a2, int a3, int a4)
{
  __int16 v5; // ax
  char v7[4]; // [esp+0h] [ebp-10h] BYREF
  __int16 v8; // [esp+4h] [ebp-Ch]

  v8 = a2;
  if ( a2 != 1 )
  {
    return sub_2F424(a1, v8, a3, a4);
  }
  v7[2] = 0;
  v7[1] = 0;
  v7[0] = 0;
  sub_2C2F8((int)&V_Type6_stru_D8654, v7);
  v5 = 5;
  dword_132B64 = 0;
  dword_132B60 = 0xFFFFFFFF;
  if ( byte_D366C == 1 )
  {
    v5 = *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA) + 8;
  }
  sub_4F8CC((int)&unk_10914C, v5, 0);
  return sub_2F424(a1, v8, a3, a4);
}
// D366C: using guessed type char byte_D366C;
// 132B60: using guessed type int dword_132B60;
// 132B64: using guessed type int dword_132B64;

//----- (00027D18) --------------------------------------------------------
void __fastcall sub_27D18(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  FILE *v5; // ebp
  char *v6; // esi
  char *v7; // edi
  char v8; // al
  char v9; // al
  char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  int v14; // ebx
  int v15; // ecx
  char *v16; // esi
  char *v17; // edi
  char v18; // al
  char v19; // al
  char *v20; // ecx
  char v21; // bh
  char v22; // dl
  char *v23; // ecx
  char v24; // bl
  char v25; // ah
  char *v26; // ecx
  char v27; // dh
  char v28; // al
  int v29; // eax
  unsigned __int8 v30; // al
  int v31; // ebp
  char *sub_1CEA8; // eax
  unsigned __int8 v33; // al
  unsigned __int8 v34; // al
  const char *v35; // ecx
  int v36; // eax
  int v37; // edi
  int v38; // esi
  int v39; // ebx
  int v40; // eax
  int v41; // eax
  int v42; // eax
  __int16 v43; // bp
  int v44; // eax
  char v45; // dl
  int v46; // esi
  signed int v47; // eax
  __int16 *v48; // edi
  unsigned int v49; // ebp
  int v50; // eax
  int v51; // eax
  char v52; // bl
  int v53; // ecx
  int v54; // ecx
  int v55; // eax
  int v56; // esi
  int v57; // eax
  char *v58; // edi
  unsigned int v59; // ebp
  char v60; // al
  char v61; // bl
  int v62; // ecx
  int v63; // eax
  int y1; // edx
  int v65; // ecx
  int v66; // eax
  int v67; // ebp
  int v68; // edi
  int v69; // esi
  int v70; // eax
  int v71; // [esp-20h] [ebp-378h]
  int v72; // [esp-20h] [ebp-378h]
  int v73; // [esp-20h] [ebp-378h]
  int v74; // [esp-1Ch] [ebp-374h]
  int v75; // [esp-18h] [ebp-370h]
  int v76; // [esp-18h] [ebp-370h]
  int v77; // [esp-Ch] [ebp-364h]
  __int16 v78; // [esp-4h] [ebp-35Ch]
  char v79[204]; // [esp+0h] [ebp-358h] BYREF
  char v80[204]; // [esp+CCh] [ebp-28Ch] BYREF
  char v81[204]; // [esp+198h] [ebp-1C0h] BYREF
  char s1[60]; // [esp+264h] [ebp-F4h] BYREF
  T_Type5 v83; // [esp+2A0h] [ebp-B8h] BYREF
  char s[16]; // [esp+2B4h] [ebp-A4h] BYREF
  __int16 *v85; // [esp+2C4h] [ebp-94h]
  int v86; // [esp+2C8h] [ebp-90h]
  int v87; // [esp+2CCh] [ebp-8Ch]
  int v88; // [esp+2D0h] [ebp-88h]
  int assert; // [esp+2D4h] [ebp-84h]
  int v90; // [esp+2D8h] [ebp-80h]
  int v91; // [esp+2DCh] [ebp-7Ch]
  int v92; // [esp+2E0h] [ebp-78h]
  int v93; // [esp+2E4h] [ebp-74h]
  int v94; // [esp+2E8h] [ebp-70h]
  int v95; // [esp+2ECh] [ebp-6Ch]
  int v96; // [esp+2F0h] [ebp-68h]
  int v97; // [esp+2F4h] [ebp-64h]
  int v98; // [esp+2F8h] [ebp-60h]
  int v99; // [esp+2FCh] [ebp-5Ch]
  int v100; // [esp+300h] [ebp-58h]
  int v101; // [esp+304h] [ebp-54h]
  int v102; // [esp+308h] [ebp-50h]
  int v103; // [esp+30Ch] [ebp-4Ch]
  int v104; // [esp+310h] [ebp-48h]
  char *v105; // [esp+314h] [ebp-44h]
  int v106; // [esp+318h] [ebp-40h]
  int v107; // [esp+31Ch] [ebp-3Ch]
  P_Type5 v108; // [esp+320h] [ebp-38h]
  unsigned int v109; // [esp+324h] [ebp-34h]
  int v110; // [esp+328h] [ebp-30h]
  int v111; // [esp+32Ch] [ebp-2Ch]
  int v112; // [esp+330h] [ebp-28h]
  int v113; // [esp+334h] [ebp-24h]
  int v114; // [esp+338h] [ebp-20h]
  int v115; // [esp+33Ch] [ebp-1Ch]
  int v116; // [esp+340h] [ebp-18h]

  v86 = a1;
  v87 = dword_D3668;
  v4 = dword_D3668 / 0xA - 1;
  v88 = v4;
  if ( v4 >= 0 )
  {
    if ( v4 > 9 )
    {
      v88 = 9;
    }
  }
  else
  {
    v88 = 0;
  }
  byte_D8DA0[0] = 0;
  assert = (int)byte_D8DA0;
  switch ( byte_D366C )
  {
    case 1:
      sprintf(s, "end-xtnc.txt");
      break;
    case 2:
      sprintf(s, "end-dest.txt");
      break;
    case 3:
      sprintf(s, "end-capt.txt");
      break;
    case 4:
      sprintf(s, "end-unit.txt");
      break;
    case 5:
      sprintf(s, "end-ctrl.txt");
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\eventwnd.cpp", 0x34E);
      break;
  }
  v5 = sub_1BB10(s, 0);
  if ( !v5 )
  {
    sub_2620C("Couldn't open %s", (char)s);
    sub_261B8(0, "..\\eventwnd.cpp", 0x370);
  }
  v79[0] = 0;
  v91 = 0;
  do
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
    sscanf(v81, "%s", s1);
    if ( !stricmp(s1, "END") )
    {
      v91 = 0xFFFFFFFF;
    }
    else if ( !stricmp(s1, "ENDDESC") )
    {
      v99 = 0;
      v100 = 0;
      do
      {
        Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
        if ( !strnicmp(v81, "ENDTEXT", 7u) )
        {
          v99 = 0xFFFFFFFF;
        }
        else
        {
          v100 += strlen(v81);
          if ( v100 >= 0xC4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3A1);
          }
          v6 = v81;
          v7 = &v79[strlen(v79)];
          do
          {
            v8 = *v6;
            *v7 = *v6;
            if ( !v8 )
            {
              break;
            }
            v9 = v6[1];
            v6 += 2;
            v7[1] = v9;
            v7 += 2;
          }
          while ( v9 );
        }
      }
      while ( !v99 );
    }
    else if ( !stricmp(s1, "CONGRAT") )
    {
      v101 = 0;
      v102 = 0;
      do
      {
        Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
        if ( !strnicmp(v81, "ENDTEXT", 7u) )
        {
          v101 = 0xFFFFFFFF;
        }
        else
        {
          v102 += strlen(v81);
          if ( v102 >= 0x3E4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3B3);
          }
          v10 = v81;
          v11 = (char *)(assert + strlen((const char *)assert));
          do
          {
            v12 = *v10;
            *v11 = *v10;
            if ( !v12 )
            {
              break;
            }
            v13 = v10[1];
            v10 += 2;
            v11[1] = v13;
            v11 += 2;
          }
          while ( v13 );
        }
      }
      while ( !v101 );
    }
    else if ( !stricmp(s1, "RANKS") )
    {
      v14 = 0;
      if ( v88 > 0 )
      {
        v15 = v88;
        do
        {
          ++v14;
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
        }
        while ( v14 < v15 );
      }
      v16 = v81;
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
      v80[0] = 0;
      v17 = &v80[strlen(v80)];
      do
      {
        v18 = *v16;
        *v17 = *v16;
        if ( !v18 )
        {
          break;
        }
        v19 = v16[1];
        v16 += 2;
        v17[1] = v19;
        v17 += 2;
      }
      while ( v19 );
    }
  }
  while ( v91 != 0xFFFFFFFF );
  v20 = v79;
  fclose(v5);
  v92 = 0;
  if ( v79[0] )
  {
    while ( 1 )
    {
      if ( v92 >= 0xC5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3D7);
      }
      v21 = *v20;
      if ( *v20 == 0xA )
      {
        break;
      }
      if ( v21 == 0x40 )
      {
        *v20 = 0xA;
      }
      else if ( v21 == 0x5F )
      {
        break;
      }
LABEL_55:
      v22 = *++v20;
      ++v92;
      if ( !v22 )
      {
        goto LABEL_56;
      }
    }
    *v20 = 0x20;
    goto LABEL_55;
  }
LABEL_56:
  v92 = 0;
  v23 = v80;
  if ( v80[0] )
  {
    while ( 1 )
    {
      if ( v92 >= 0xC5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3E9);
      }
      v24 = *v23;
      if ( *v23 == 0xA )
      {
        break;
      }
      if ( v24 == 0x40 )
      {
        *v23 = 0xA;
      }
      else if ( v24 == 0x5F )
      {
        break;
      }
LABEL_64:
      v25 = *++v23;
      ++v92;
      if ( !v25 )
      {
        goto LABEL_65;
      }
    }
    *v23 = 0x20;
    goto LABEL_64;
  }
LABEL_65:
  if ( !assert )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3F5);
  }
  v26 = (char *)assert;
  v92 = 0;
  if ( *(_BYTE *)assert )
  {
    while ( 1 )
    {
      if ( v92 >= 0x3E5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3FB);
      }
      v27 = *v26;
      if ( *v26 == 0xA )
      {
        break;
      }
      if ( v27 == 0x40 )
      {
        *v26 = 0xA;
      }
      else if ( v27 == 0x5F )
      {
        break;
      }
LABEL_75:
      v28 = *++v26;
      ++v92;
      if ( !v28 )
      {
        goto LABEL_76;
      }
    }
    *v26 = 0x20;
    goto LABEL_75;
  }
LABEL_76:
  v83.a = *(P_Type6 *)(v86 + 4);
  v83.rect.x1 = 7;
  v83.rect.y1 = 0xD7;
  v83.rect.x2 = 0x12F;
  v83.rect.y2 = 0x17D;
  if ( byte_D366C != 1 )
  {
    v77 = v88;
    v29 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEF6);
    sub_5CB3C(&v83, v29, v77, 0x94, 0x53);
  }
  v83.rect.x2 = 0x12F;
  v83.rect.x1 = 7;
  v83.rect.y1 = 0xD7;
  v83.rect.y2 = 0x107;
  sprintf(v81, "%s", v79);
  v30 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v31 = v87;
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v83;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xE, 0, v81, 1, 4 * v30 + 0x13, 0xFF, 0x118);
  v83.rect.x2 = 0x12F;
  v83.rect.y2 = 0x17D;
  v83.rect.x1 = 7;
  v83.rect.y1 = 0x14D;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xF); // 15: "Your score is %d%%.\nThis gives you the title of %s"
  sprintf(v81, sub_1CEA8, v31, v80);
  v33 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v83;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, v81, 3, 4 * v33 + 0x13, 0xFF, 0x118);
  v83.rect.x2 = 0x278;
  v83.rect.x1 = 7;
  v83.rect.y1 = 0x18D;
  v83.rect.y2 = 0x1D1;
  v34 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v35 = (const char *)assert;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v83.a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = 7;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v83.rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v83.rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v83.rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 7, 0, v35, 1, 4 * v34 + 0x13, 0xFF, 0x25A);
  v36 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEAE[(unsigned __int8)byte_104BEA]);
  v37 = 0x2A;
  sub_5CB3C((P_Type5)&V_Type6_stru_D8654.pane, v36, 0, 7, 7);
  v92 = 1;
  v109 = 2;
  v38 = 0x15B;
  sub_53E38((P_Type5)(v86 + 4), 0xA, 0xA, (unsigned __int8)byte_104BEA);
  while ( 1 )
  {
    v41 = SHIWORD(dword_A3CF2);
    if ( SHIWORD(dword_A3CF2) <= v92 )
    {
      break;
    }
    if ( v92 == 4 )
    {
      v38 = 0x15B;
      v37 = 0x85;
    }
    v42 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEA0[v109 / 2]);
    sub_5D631(
      (P_Type5)&V_Type6_stru_D8654.pane,
      v42,
      0,
      v38,
      v37,
      (int)byte_D8DA0,
      0,
      (void (__noreturn *)())0x8000,
      (void (__noreturn *)())0x8000,
      0);
    v43 = v92;
    v78 = v92;
    v44 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8((P_Type5)&V_Type6_stru_D8654.pane, v44, 3, v38, v37, v78);
    sub_53E38((P_Type5)&V_Type6_stru_D8654.pane, v38 - 7, v37 + 0x21, v43);
    v45 = byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA + 0x1C0 + v92];
    v39 = 0xFFFFFFFF;
    if ( v45 == 3 )
    {
      v39 = 9;
    }
    else if ( v45 == 2 )
    {
      v39 = 8;
    }
    if ( v39 != 0xFFFFFFFF )
    {
      v40 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEF2);
      sub_5CB3C((P_Type5)&V_Type6_stru_D8654.pane, v40, v39, v38 - 7, v37 + 0x21);
    }
    v38 += 0x3E;
    v109 += 2;
    ++v92;
  }
  v93 = 0x278;
  LOWORD(v41) = word_FFEBC[(unsigned __int8)byte_104BEA];
  v83.rect.x1 = 0x138;
  v115 = v41;
  v83.rect.y1 = 7;
  v83.rect.x2 = 0x278;
  v83.rect.y2 = 0x17D;
  v46 = 7;
  v47 = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], 0, 0);
  v94 = v47;
  if ( v47 < 0x14 )
  {
    v46 = 7 - 7 * (0x14 - v47) / 0x11;
  }
  if ( v46 >= 0 )
  {
    if ( v46 > 6 )
    {
      v46 = 6;
    }
  }
  else
  {
    v46 = 0;
  }
  v95 = v94 / (v46 + 1);
  v96 = 0;
  v98 = 0x9F;
  v97 = v93 - 0x212;
  if ( v93 - 0x212 < 2 )
  {
    v97 = 2;
  }
  v92 = 0;
  v90 = 0x208;
  v103 = 0x11;
  v48 = (__int16 *)&unk_CA1F1;
  v49 = 0xFFFFFF00 * v46 + 0x700;
  while ( 1 )
  {
    v50 = SHIWORD(dword_D35E5);
    if ( SHIWORD(dword_D35E5) <= v92 )
    {
      break;
    }
    v51 = v48[0x2B];
    v85 = v48;
    if ( v51 == (unsigned __int8)byte_104BEA )
    {
      v52 = 0;
      if ( v96 > v95 && v46 > 0 )
      {
        v49 += 0x100;
        --v46;
      }
      if ( v46 > 0 )
      {
        sub_5D007((const void *)(v49 + dword_D8D8F));
        v52 = 1;
      }
      v53 = v90 - v83.rect.x1;
      v54 = rand() % v97 + v53;
      v111 = v103 - v83.rect.y1;
      v75 = v111 + rand() % v98;
      v71 = *((char *)v85 + 0xAA);
      v55 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)v115);
      sub_5D631(
        &v83,
        v55,
        v71,
        v54,
        v75,
        (int)byte_D8DA0,
        0,
        (void (__noreturn *)())0x5555,
        (void (__noreturn *)())0x5555,
        v52);
    }
    v48 += 0xB1;
    ++v92;
    ++v96;
  }
  LOWORD(v50) = word_FFEDA;
  v116 = v50;
  v112 = 0x1FF;
  v56 = 7;
  v57 = sub_402E0(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
  if ( v57 < 0x14 )
  {
    v56 = 7 - 7 * (0x14 - v57) / 0x11;
  }
  if ( v56 >= 0 )
  {
    if ( v56 > 6 )
    {
      v56 = 6;
    }
  }
  else
  {
    v56 = 0;
  }
  v113 = v94 / (v56 + 1);
  v110 = v112 - 0x14C;
  v114 = 0;
  v104 = 0x97;
  if ( v112 - 0x14C < 2 )
  {
    v110 = 2;
  }
  v58 = (char *)&unk_BB1B3;
  v92 = 0;
  v106 = 0x142;
  v107 = 0xDC;
  v59 = 0xFFFFFF00 * v56 + 0x700;
  while ( SHIWORD(dword_CA1ED) > v92 )
  {
    v60 = v58[0x57];
    v105 = v58;
    if ( v60 == (_BYTE)byte_104BEA )
    {
      v61 = 0;
      if ( v114 > v113 && v56 > 0 )
      {
        v59 += 0x100;
        --v56;
      }
      if ( v56 > 0 )
      {
        sub_5D007((const void *)(v59 + dword_D8D8F));
        v61 = 1;
      }
      v62 = v106 - v83.rect.x1;
      v63 = rand();
      y1 = v83.rect.y1;
      v111 = v63 % v110 + v62;
      v65 = v107;
      v76 = v65 - y1 + rand() % v104;
      v74 = v111;
      v72 = 5 * *((unsigned __int16 *)v105 + 0xB) + *((unsigned __int16 *)v105 + 0xA);
      v66 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)v116);
      sub_5D631(
        &v83,
        v66,
        v72,
        v74,
        v76,
        (int)byte_D8DA0,
        0,
        (void (__noreturn *)())0x5555,
        (void (__noreturn *)())0x5555,
        v61);
    }
    v58 += 0x7B;
    ++v92;
    ++v114;
  }
  v67 = 0xCB;
  v68 = 0;
  v92 = 0;
  v69 = 0x213;
  v108 = (P_Type5)(v86 + 4);
  while ( (unsigned __int16)word_105258 > v92 )
  {
    if ( v92 && !(v92 % 6) )
    {
      v69 = 0x213;
      v67 += 0x11;
    }
    if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + v68) >> 0x18)) != 0 )
    {
      v73 = v92;
      v70 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEDE);
      sub_5D631(
        v108,
        v70,
        v73,
        v69,
        v67,
        (int)byte_D8DA0,
        0,
        (void (__noreturn *)())0x5555,
        (void (__noreturn *)())0x5555,
        0);
    }
    v69 += 0x11;
    v68 += 0x4B;
    ++v92;
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&V_Type6_stru_D8654.pane);
}
// 28784: conditional instruction was optimized away because %var_60.4==9F
// 289D7: conditional instruction was optimized away because %var_48.4==97
// A3CF2: using guessed type int dword_A3CF2;
// CA1ED: using guessed type int dword_CA1ED;
// D35E5: using guessed type int dword_D35E5;
// D3668: using guessed type int dword_D3668;
// D366C: using guessed type char byte_D366C;
// D8D8F: using guessed type int dword_D8D8F;
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEAE: using guessed type __int16 word_FFEAE[7];
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDA: using guessed type __int16 word_FFEDA;
// FFEDE: using guessed type __int16 word_FFEDE;
// FFEF2: using guessed type __int16 word_FFEF2;
// FFEF6: using guessed type __int16 word_FFEF6;
// 10529F: using guessed type int dword_10529F;
// 27D18: using guessed type char var_358[204];
// 27D18: using guessed type char var_28C[204];

//----- (00028C40) --------------------------------------------------------
void sub_28C40()
{
  dword_D8650 = 0xFFFFFFFF;
}
// D8650: using guessed type int dword_D8650;

//----- (00028C4C) --------------------------------------------------------
int __fastcall sub_28C4C(__int16 *a1, __int16 *a2)
{
  return *a1 - *a2;
}

//----- (00028C74) --------------------------------------------------------
void __fastcall __spoils<> sub_28C74(P_Type2 a1)
{
  int *__shifted(T_Type2,0x90A) v1; // eax
  P_Type2 v2; // ecx

  Q_InitFileInfo_sub_1BB78(&a1->a);
  v1 = (int *__shifted(T_Type2,0x90A))a1->gap90A;
  sub_2B2C0(v1);
  v2 = ADJ(v1);
  v2->dword198 = 0;
  v2->dword1A8 = 0;
  v2->dword1AC = 0;
  v2->dword1B0 = 0;
  v2->dword1B4 = 0;
  v2->dword19C = 0xFFFFFFFF;
  memset(ADJ(v1)->char118, 0, sizeof(ADJ(v1)->char118));
  v2->dword1E4 = 0;
  v2->dword1E8 = 0;
  v2->dword1EC = 0;
  v2->dword1F0 = 0;
  v2->dword946 = 0;
  memset(v2->char204, 0, sizeof(v2->char204));
  memset(v2->char808, 0, sizeof(v2->char808));
  v2->word804 = 0;
  v2->word806 = 0;
  v2->word908 = 0;
  v2->dword92E = 0;
  v2->word932 = 0;
  v2->word934 = 0;
  v2->dword936 = 0xFFFFFFFF;
  v2->dword1E0 = 0x12;
  v2->dword93A = 0;
  v2->dword93E = 0xFFFFFFFF;
  v2->dword942 = 0;
}

//----- (00028DA4) --------------------------------------------------------
__int64 __fastcall sub_28DA4(int a1)
{
  int v2; // edx
  int i; // ebx
  int v4; // ebx
  int v5; // edx
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 0x1B0) == 0xFFFFFFFF )
  {
    sub_2627C(*(void **)(a1 + 0x1AC));
  }
  operator delete(*(void **)(a1 + 0x1AC));
  if ( *(_DWORD *)(a1 + 0x1B4) == 0xFFFFFFFF )
  {
    sub_2627C(*(void **)(a1 + 0x198));
    operator delete(*(void **)(a1 + 0x198));
    sub_2627C(*(void **)(a1 + 0x1A8));
    operator delete(*(void **)(a1 + 0x1A8));
  }
  v2 = a1;
  for ( i = 0; i < *(__int16 *)(a1 + 0x908); ++i )
  {
    sub_2627C(*(void **)(v2 + 0x808));
    v2 += 8;
  }
  operator delete(*(void **)(v2 + 0x808));
  v4 = 0;
  v5 = a1;
  while ( v4 < *(__int16 *)(a1 + 0x806) )
  {
    if ( *(_WORD *)(v5 + 0x206) == 0xA )
    {
      sub_2627C(*(void **)(v5 + 0x20C));
      operator delete(*(void **)(v5 + 0x20C));
      *(_DWORD *)(v5 + 0x20C) = 0;
    }
    v5 += 0xC;
    ++v4;
  }
  if ( *(_DWORD *)(a1 + 0x92E) )
  {
    sub_2627C(*(void **)(a1 + 0x92E));
  }
  operator delete(*(void **)(a1 + 0x92E));
  sub_2AD08(a1);
  result = (unsigned int)sub_2B2E0((void **)(a1 + 0x90A)) + 0xFFFFF6F6;
  Q_CloseFileAndDelete_sub_1BBC8((P_Type1)result);
  return result;
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (00028EB4) --------------------------------------------------------
unsigned int __fastcall sub_28EB4(int a1, const char *a2, int a3, int a4, int a5)
{
  unsigned int result; // eax
  __int64 v7; // rax
  int v8; // eax
  __int64 v9; // rax
  int v10; // eax
  int v11; // eax

  if ( !a2 )
  {
    return 0;
  }
  sub_2A1DC(a1, "SUBTITLE.TXT");
  if ( Q_CfilePreload_sub_1BBFC((P_Type1)a1, a2, 0x200, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0xE9);
    return 0;
  }
  if ( sub_1BF94((P_Type1)a1, (void *)(a1 + 0x118), 0x80u) == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0xE3);
    return 0;
  }
  if ( *(unsigned __int16 *)(a1 + 0x11C) != 0xAF12 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0xEF);
    return 0;
  }
  if ( a4 == 0xFFFFFFFF )
  {
    v7 = 0x280 - *(unsigned __int16 *)(a1 + 0x120);
    v8 = ((int)v7 - HIDWORD(v7)) >> 1;
  }
  else
  {
    v8 = a4;
  }
  *(_DWORD *)(a1 + 0x1A0) = v8;
  if ( a5 == 0xFFFFFFFF )
  {
    v9 = 0x1E0 - *(unsigned __int16 *)(a1 + 0x122);
    v10 = ((int)v9 - HIDWORD(v9)) >> 1;
  }
  else
  {
    v10 = a5;
  }
  *(_DWORD *)(a1 + 0x1BC) = 0x27F;
  *(_DWORD *)(a1 + 0x1C0) = 0x1DF;
  *(_DWORD *)(a1 + 0x1A4) = v10;
  *(_DWORD *)(a1 + 0x1CC) = a1 + 0x1B8;
  if ( a3 )
  {
    *(_DWORD *)(a1 + 0x1B0) = 0;
    *(_DWORD *)(a1 + 0x1AC) = a3;
  }
  else
  {
    result = *(_DWORD *)V_Type6_stru_D8654.z1;
    *(_DWORD *)(a1 + 0x1AC) = *(_DWORD *)V_Type6_stru_D8654.z1;
    if ( !result )
    {
      return result;
    }
    *(_DWORD *)(a1 + 0x1B0) = 0;
  }
  *(_DWORD *)(a1 + 0x1C4) = 0;
  v11 = *(_DWORD *)(a1 + 0x1AC);
  *(_DWORD *)(a1 + 0x1C8) = 0;
  *(_DWORD *)(a1 + 0x1B8) = v11;
  return 0xFFFFFFFF;
}

//----- (00029038) --------------------------------------------------------
int __fastcall sub_29038(int a1, size_t a2, unsigned int a3, int a4, int a5, int a6)
{
  int v8; // edi
  int v9; // edx
  void *v10; // eax
  void *v11; // eax
  int v13; // eax
  size_t v14; // eax
  int v15; // edx
  int v16; // ebp
  int v17; // eax

  v8 = a3;
  *(_WORD *)(a1 + 0x804) = 0;
  *(_WORD *)(a1 + 0x92A) = 0;
  *(_DWORD *)(a1 + 0x942) = 0;
  *(_WORD *)(a1 + 0x92C) = 0;
  if ( a2 < a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x15E);
  }
  if ( a2 - a4 < a3 )
  {
    v8 = a2 - a4;
  }
  v9 = *(_DWORD *)(a1 + 0x1B4);
  *(_DWORD *)(a1 + 0x19C) = 0xFFFFFFFF;
  if ( v9 == 0xFFFFFFFF )
  {
    sub_2627C(*(void **)(a1 + 0x198));
    operator delete[](*(void **)(a1 + 0x198));
    sub_2627C(*(void **)(a1 + 0x1A8));
    operator delete[](*(void **)(a1 + 0x1A8));
    *(_DWORD *)(a1 + 0x198) = 0;
    *(_DWORD *)(a1 + 0x1A8) = 0;
    *(_DWORD *)(a1 + 0x1B4) = 0;
  }
  if ( a6 )
  {
    *(_DWORD *)(a1 + 0x1E8) = a6;
  }
  if ( *(_DWORD *)(a1 + 0x1E8)
    || (v10 = operator new[](a2), v11 = sub_2625C(v10, 1, "FLIC BUFFER"), (*(_DWORD *)(a1 + 0x1E8) = v11) != 0) )
  {
    v13 = *(_DWORD *)(a1 + 0x1E8);
    *(_DWORD *)(a1 + 0x1F4) = a2;
    v14 = a2 + v13;
    v15 = *(_DWORD *)(a1 + 0x168);
    *(_DWORD *)(a1 + 0x1EC) = v14;
    *(_DWORD *)(a1 + 0x1F0) = v14 - a4;
    v16 = *(_DWORD *)(a1 + 0x1F0) - v8;
    *(_DWORD *)(a1 + 0x1FC) = a5;
    *(_DWORD *)(a1 + 0x1E4) = v16;
    sub_1BECC((int *)a1, v15, 0);
    *(_DWORD *)(a1 + 0x200) = ((int)sub_1BFD4((int *)a1, *(void **)(a1 + 0x1E4), v8, 0x40u, (int)sub_2BCF4) >= v8) - 1;
    VFX_area_wipe(0, 0, 639, 479, 0);
    v17 = *(_DWORD *)(a1 + 0x1E4);
    *(_DWORD *)(a1 + 0x198) = v17;
    *(_DWORD *)(a1 + 0x1A8) = v17 + 0x10;
    *(_DWORD *)(a1 + 0x1E4) = *(_DWORD *)(a1 + 0x1E8);
    *(_DWORD *)(a1 + 0x1F8) = *(_DWORD *)(a1 + 0x198) - *(_DWORD *)(a1 + 0x1E4);
    return 0xFFFFFFFF;
  }
  else
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x183);
    return 0;
  }
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (000296B4) --------------------------------------------------------
unsigned int __fastcall sub_296B4(int a1, int a2, int a3, int a4)
{
  int v5; // edx
  int v7; // eax
  _DWORD *v8; // esi
  int i; // edi
  _DWORD *v10; // edx
  unsigned __int16 v11; // ax
  unsigned __int16 *v12; // edx
  unsigned __int16 v13; // ax
  _DWORD *v14; // esi
  unsigned int v15; // edx
  int v16; // edx
  void *v17; // edi
  const void *v18; // esi
  signed int v19; // ecx
  char *v20; // ecx
  int v21; // esi
  int v22; // edx
  int v23; // esi
  int v24; // edi
  unsigned int v25; // edx
  unsigned int v26; // eax
  int v27; // esi
  int v28; // edx
  int v29; // ecx
  int v30; // ecx
  unsigned int v31; // esi
  unsigned int v32; // eax

  if ( !dword_D8650 )
  {
    return 0xFFFFFFFF;
  }
  if ( *(_DWORD *)(a1 + 0x946) == 0xFFFFFFFF )
  {
    sub_29B24((_DWORD *)a1, a2, a3, a4);
  }
  if ( dword_D8650 != 0xFFFFFFFF && *(_DWORD *)(a1 + 0x93A) != 0xFFFFFFFF )
  {
    goto LABEL_54;
  }
  if ( !*(_DWORD *)(a1 + 0x93A) )
  {
    _disable();
    dword_D8650 = 0;
    _enable();
  }
  v5 = *(_DWORD *)(a1 + 0x19C) + 1;
  *(_DWORD *)(a1 + 0x19C) = v5;
  if ( !v5 )
  {
    VFX_area_wipe(0, 0, 639, 479, *(_DWORD *)(a1 + 0x926));
  }
  if ( *(unsigned __int16 *)(a1 + 0x11E) <= *(int *)(a1 + 0x19C) )
  {
    return 0;
  }
  v7 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 0x198) + 4);
  ++dword_A0CF8;
  if ( v7 != 0xF1FA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x32E);
  }
  v8 = *(_DWORD **)(a1 + 0x1A8);
  for ( i = 0; i < *(unsigned __int16 *)(*(_DWORD *)(a1 + 0x198) + 6); ++i )
  {
    v10 = v8;
    v8 = (_DWORD *)((char *)v8 + *v8);
    v11 = *((_WORD *)v10 + 2);
    v12 = (unsigned __int16 *)v10 + 3;
    if ( v11 < 0xFu )
    {
      if ( v11 >= 4u )
      {
        if ( v11 <= 4u )
        {
          *(_WORD *)(a1 + 0x92C) = 0;
          sub_29C6C(a1, v12);
          continue;
        }
        if ( v11 == 7 )
        {
          sub_2AD40(v12, *(_DWORD *)(a1 + 0x1A0), *(_DWORD *)(a1 + 0x1A4));
          continue;
        }
      }
LABEL_19:
      Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x355);
      continue;
    }
    if ( v11 <= 0xFu )
    {
      sub_29D54(a1, (unsigned __int8 *)v12);
      continue;
    }
    if ( v11 <= 0x10u )
    {
      sub_29F58(a1, v12);
      continue;
    }
    if ( v11 != 0x12 )
    {
      goto LABEL_19;
    }
  }
  v13 = *(_WORD *)(a1 + 0x92A);
  if ( v13 )
  {
    if ( v13 <= 1u )
    {
      sub_2C4C0((int)&V_Type6_stru_D8654, *(__int16 *)(a1 + 0x932), *(__int16 *)(a1 + 0x934));
    }
    else if ( v13 == 2 )
    {
      sub_2C418((int)&V_Type6_stru_D8654, *(__int16 *)(a1 + 0x932), *(_WORD *)(a1 + 0x934));
    }
  }
  if ( *(__int16 *)(a1 + 0xC * *(__int16 *)(a1 + 0x804) + 0x204) == *(_DWORD *)(a1 + 0x19C) )
  {
    sub_2AA88(a1);
  }
  if ( *(_WORD *)(a1 + 0x92C) )
  {
    sub_2C5E4((int)&V_Type6_stru_D8654, *(_BYTE *)(a1 + 0x92C) - 1);
    if ( (__int16)++*(_WORD *)(a1 + 0x92C) > 0x40 )
    {
      *(_WORD *)(a1 + 0x92C) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 0x93A) == 0xFFFFFFFF && *(_DWORD *)(a1 + 0x93E) == *(_DWORD *)(a1 + 0x19C) )
  {
    getch();
    *(_DWORD *)(a1 + 0x93A) = 0;
    *(_DWORD *)(a1 + 0x93E) = 0xFFFFFFFF;
  }
  *(_DWORD *)(a1 + 0x1F8) += **(_DWORD **)(a1 + 0x198);
  v14 = (_DWORD *)(**(_DWORD **)(a1 + 0x198) + *(_DWORD *)(a1 + 0x198));
  v15 = *(_DWORD *)(a1 + 0x1F0);
  *(_DWORD *)(a1 + 0x198) = v14;
  if ( (unsigned int)v14 >= v15 )
  {
    *(_DWORD *)(a1 + 0x198) = (char *)v14 + *(_DWORD *)(a1 + 0x1E8) - v15;
    goto LABEL_53;
  }
  v16 = (int)v14 - *(_DWORD *)(a1 + 0x1F0) + 0x10;
  if ( v16 > 0 )
  {
    qmemcpy(*(void **)(a1 + 0x1F0), *(const void **)(a1 + 0x1E8), (unsigned int)v14 - *(_DWORD *)(a1 + 0x1F0) + 0x10);
    v17 = v14 + 4;
    v18 = (const void *)(v16 + *(_DWORD *)(a1 + 0x1E8));
    v19 = **(_DWORD **)(a1 + 0x198) - 0x10;
    goto LABEL_52;
  }
  v20 = (char *)v14 + *v14;
  v21 = *(_DWORD *)(a1 + 0x1F0);
  v19 = (signed int)&v20[-v21];
  if ( v19 > 0 )
  {
    if ( v19 >= *(_DWORD *)(a1 + 0x1EC) - v21 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x3D0);
    }
    v18 = *(const void **)(a1 + 0x1E8);
    v17 = *(void **)(a1 + 0x1F0);
LABEL_52:
    qmemcpy(v17, v18, v19);
  }
LABEL_53:
  *(_DWORD *)(a1 + 0x1A8) = *(_DWORD *)(a1 + 0x198) + 0x10;
LABEL_54:
  if ( !*(_DWORD *)(a1 + 0x200) )
  {
    if ( *(_DWORD *)(a1 + 0x1F8) < *(_DWORD *)(a1 + 0x1FC) )
    {
      v22 = *(_DWORD *)(a1 + 0x1F8);
    }
    else
    {
      v22 = *(_DWORD *)(a1 + 0x1FC);
    }
    v23 = v22;
    if ( v22 + *(_DWORD *)(a1 + 0x1E4) - *(_DWORD *)(a1 + 0x1F0) > 0 )
    {
      v23 = *(_DWORD *)(a1 + 0x1F0) - *(_DWORD *)(a1 + 0x1E4);
    }
    if ( sub_1BF94((P_Type1)a1, *(void **)(a1 + 0x1E4), v23) < v23 )
    {
      *(_DWORD *)(a1 + 0x200) = 0xFFFFFFFF;
    }
    v24 = *(_DWORD *)(a1 + 0x1F8);
    v25 = *(_DWORD *)(a1 + 0x1F0);
    *(_DWORD *)(a1 + 0x1E4) += v23;
    v26 = *(_DWORD *)(a1 + 0x1E4);
    *(_DWORD *)(a1 + 0x1F8) = v24 - v23;
    if ( v26 >= v25 )
    {
      *(_DWORD *)(a1 + 0x1E4) = *(_DWORD *)(a1 + 0x1E8);
    }
  }
  if ( (unsigned int)(*(_DWORD *)(a1 + 0x1EC)
                    + **(_DWORD **)(a1 + 0x198)
                    + *(_DWORD *)(a1 + 0x1F8)
                    - *(_DWORD *)(a1 + 0x1F0)) >= *(_DWORD *)(a1 + 0x1F4) )
  {
    v27 = *(_DWORD *)(a1 + 0x1F8);
    v28 = *(_DWORD *)(a1 + 0x1F0);
    if ( v27 + *(_DWORD *)(a1 + 0x1E4) - v28 > 0 )
    {
      v27 = v28 - *(_DWORD *)(a1 + 0x1E4);
    }
    if ( sub_1BF94((P_Type1)a1, *(void **)(a1 + 0x1E4), v27) < v27 )
    {
      *(_DWORD *)(a1 + 0x200) = 0xFFFFFFFF;
    }
    v29 = *(_DWORD *)(a1 + 0x1F8);
    *(_DWORD *)(a1 + 0x1E4) += v27;
    v30 = v29 - v27;
    v31 = *(_DWORD *)(a1 + 0x1F0);
    v32 = *(_DWORD *)(a1 + 0x1E4);
    *(_DWORD *)(a1 + 0x1F8) = v30;
    if ( v32 >= v31 )
    {
      *(_DWORD *)(a1 + 0x1E4) = *(_DWORD *)(a1 + 0x1E8);
    }
  }
  return 0xFFFFFFFF;
}
// A0CF8: using guessed type int dword_A0CF8;
// D8650: using guessed type int dword_D8650;

//----- (00029B24) --------------------------------------------------------
void __fastcall sub_29B24(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ecx
  signed int v5; // ebx
  int v6; // edi
  int v7; // eax
  LONG v8; // esi
  RGB v9[5]; // [esp+0h] [ebp-18h] BYREF
  int v10; // [esp+10h] [ebp-8h]

  v10 = a4;
  v4 = a1[0x7A];
  v5 = a1[0x7D] / 0x27Fu;
  v6 = (a1[0x79] - v4) / v5;
  v7 = (a1[0x66] - v4) / v5;
  v9[0].g = 0;
  v9[0].b = 0;
  v8 = v7;
  v9[0].r = 0xFF;
  VFX_DAC_write(0xFE, v9);
  v9[0].r = 0;
  v9[0].g = 0xFF;
  VFX_DAC_write(0xFF, v9);
  if ( v8 < v6 )
  {
    VFX_area_wipe(0, 450, v8, 479, 254);
    VFX_area_wipe(v8, 450, v6, 479, 255);
    VFX_area_wipe(v6, 450, 639, 479, 254);
  }
  else
  {
    VFX_area_wipe(0, 450, v6, 479, 255);
    VFX_area_wipe(v6, 450, v8, 479, 254);
    VFX_area_wipe(v8, 450, 639, 479, 255);
  }
  VFX_area_wipe(v8, 450, v8, 479, 254);
}

//----- (00029C6C) --------------------------------------------------------
unsigned __int16 __fastcall sub_29C6C(int a1, _WORD *a2)
{
  RGB *v3; // esi
  unsigned __int16 result; // ax
  unsigned __int16 v5; // ax
  UBYTE *p_g; // esi
  unsigned __int8 v7; // dl
  unsigned __int16 j; // di
  int v9; // edx
  UBYTE r; // dh
  UBYTE b; // bh
  unsigned __int16 v12; // [esp+0h] [ebp-24h]
  unsigned __int16 v13; // [esp+4h] [ebp-20h]
  int v14; // [esp+8h] [ebp-1Ch]
  unsigned __int8 i; // [esp+Ch] [ebp-18h]

  v3 = (RGB *)(a2 + 1);
  result = *a2;
  v12 = *a2;
  v14 = 0;
  HIBYTE(result) = 0;
  for ( i = 0; (unsigned __int16)v14 < v12; ++v14 )
  {
    LOBYTE(v5) = v3->r;
    p_g = &v3->g;
    v7 = v5 + i;
    v5 = (unsigned __int8)v5;
    LOBYTE(v5) = *p_g;
    v3 = (RGB *)(p_g + 1);
    v13 = v5;
    result = v3[0xFFFFFFFF].b;
    i = v7;
    if ( !v3[0xFFFFFFFF].b )
    {
      v13 = 0x100;
    }
    for ( j = 0; j < v13; ++j )
    {
      v9 = *(__int16 *)(a1 + 0x932);
      if ( j < v9 || j >= *(__int16 *)(a1 + 0x934) + v9 )
      {
        r = v3->r;
        v3->g >>= 2;
        b = v3->b;
        v3->r = r >> 2;
        v3->b = b >> 2;
        VFX_DAC_write(i++, v3++);
      }
      result = v13;
    }
  }
  return result;
}

//----- (00029D54) --------------------------------------------------------
int __fastcall sub_29D54(int a1, unsigned __int8 *a2)
{
  int v3; // edx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebp
  int result; // eax
  int i; // [esp+0h] [ebp-2Ch]
  char *s; // [esp+8h] [ebp-24h]
  char v10[4]; // [esp+Ch] [ebp-20h] BYREF
  int v11; // [esp+10h] [ebp-1Ch]
  signed __int8 v12; // [esp+14h] [ebp-18h]

  s = *(char **)(a1 + 0x1AC);
  for ( i = 0; *(unsigned __int16 *)(a1 + 0x122) > i; ++i )
  {
    v11 = 0;
    ++a2;
    if ( *(_WORD *)(a1 + 0x120) )
    {
      do
      {
        v12 = *a2;
        v5 = a2 + 1;
        if ( v12 >= 0 )
        {
          v3 = *v5;
          a2 = v5 + 1;
          memset(s, v3, v12);
        }
        else
        {
          v12 = -v12;
          v3 = v12;
          qmemcpy(s, v5, v12);
          a2 = &v5[v12];
        }
        LOWORD(v3) = v12;
        s += v12;
        v4 = *(_WORD *)(a1 + 0x120);
        v11 += v3;
      }
      while ( (unsigned __int16)v11 < v4 );
    }
    s += 0x280 - *(unsigned __int16 *)(a1 + 0x120);
  }
  v10[0] = 0;
  v10[1] = 0;
  v10[2] = 0;
  sub_2C2B0((int)&V_Type6_stru_D8654, 0, 0x100, 0);
  sub_2C670((int)&V_Type6_stru_D8654, 0, 0x100, v10);
  *(_DWORD *)(a1 + 0x1D0) = 0;
  *(_DWORD *)(a1 + 0x1D4) = 0;
  *(_DWORD *)(a1 + 0x1D8) = *(unsigned __int16 *)(a1 + 0x120) - 1;
  *(_DWORD *)(a1 + 0x1DC) = *(unsigned __int16 *)(a1 + 0x122) - 1;
  VFX_pane_refresh(
    (PANE *)(a1 + 0x1CC),
    *(_DWORD *)(a1 + 0x1A0),
    *(_DWORD *)(a1 + 0x1A4),
    *(_DWORD *)(a1 + 0x1D8) + *(_DWORD *)(a1 + 0x1A0),
    *(_DWORD *)(a1 + 0x1DC) + *(_DWORD *)(a1 + 0x1A4));
  for ( *(_WORD *)(a1 + 0x92C) = 0; *(__int16 *)(a1 + 0x92C) < 0x20; ++*(_WORD *)(a1 + 0x92C) )
  {
    result = sub_2C5E4((int)&V_Type6_stru_D8654, *(_BYTE *)(a1 + 0x92C));
  }
  ++*(_WORD *)(a1 + 0x92C);
  return result;
}

//----- (00029F58) --------------------------------------------------------
void __fastcall sub_29F58(int a1, const void *a2)
{
  LONG v3; // edi
  LONG v4; // [esp-Ch] [ebp-1Ch]
  LONG v5; // [esp-8h] [ebp-18h]
  LONG v6; // [esp-4h] [ebp-14h]

  qmemcpy(*(void **)(a1 + 0x1AC), a2, *(unsigned __int16 *)(a1 + 0x122) * *(unsigned __int16 *)(a1 + 0x120));
  *(_DWORD *)(a1 + 0x1D8) = *(unsigned __int16 *)(a1 + 0x120) - 1;
  *(_DWORD *)(a1 + 0x1DC) = *(unsigned __int16 *)(a1 + 0x122) - 1;
  v6 = *(_DWORD *)(a1 + 0x1DC) + *(_DWORD *)(a1 + 0x1A4);
  v5 = *(_DWORD *)(a1 + 0x1D8) + *(_DWORD *)(a1 + 0x1A0);
  v4 = *(_DWORD *)(a1 + 0x1A4);
  v3 = *(_DWORD *)(a1 + 0x1A0);
  *(_DWORD *)(a1 + 0x1D0) = 0;
  *(_DWORD *)(a1 + 0x1D4) = 0;
  VFX_pane_refresh((PANE *)(a1 + 0x1CC), v3, v4, v5, v6);
}

//----- (0002A1DC) --------------------------------------------------------
FILE *__fastcall sub_2A1DC(int a1, const char *a2)
{
  FILE *result; // eax
  FILE *v4; // ebx
  int v5; // esi
  unsigned int v6; // kr04_4
  char *v7; // eax
  int v9; // esi
  int v10; // ecx
  void *v11; // eax
  void *v12; // eax
  char *v13; // esi
  char *v14; // edi
  char v15; // al
  char v16; // al
  int v17; // eax
  __int16 v18; // dx
  FILE *v19; // ecx
  __int16 v20; // si
  FILE *v21; // esi
  __int16 v22; // bx
  FILE *v23; // esi
  __int16 v24; // cx
  void *v25; // eax
  FILE *v26; // edi
  int v27; // ebx
  FILE *v28; // [esp-10h] [ebp-304h]
  T_Type1 v29; // [esp+0h] [ebp-2F4h] BYREF
  char v30[256]; // [esp+118h] [ebp-1DCh] BYREF
  char v31[128]; // [esp+218h] [ebp-DCh] BYREF
  char v32[52]; // [esp+298h] [ebp-5Ch] BYREF
  unsigned int v33; // [esp+2CCh] [ebp-28h] BYREF
  FILE *fp; // [esp+2D0h] [ebp-24h]
  int v35; // [esp+2D4h] [ebp-20h]
  int v36; // [esp+2D8h] [ebp-1Ch]
  __int16 v37; // [esp+2DCh] [ebp-18h]

  result = (FILE *)a2;
  if ( a2 )
  {
    v37 = 0;
    result = sub_1BB10(a2, 0);
    fp = result;
    if ( result )
    {
      v35 = 0;
      v36 = a1 + 0x90A;
      while ( 1 )
      {
        v4 = fp;
        fscanf(fp, "%s %d", v32, &v33);
        if ( v33 == 0xFFFFFFFF )
        {
          break;
        }
        v5 = ++v35;
        if ( v33 < 2 )
        {
          if ( v33 )
          {
            fscanf(v4, "%s %s", v32, v31);
            if ( !sub_2B360((void **)v36, v31) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x5E3);
            }
            fscanf(fp, "%s %s", v32, v31);
            Q_InitFileInfo_sub_1BB78(&v29);
            if ( Q_CfilePreload_sub_1BBFC(&v29, v31, 0x200, 0) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x5EB);
            }
            v25 = sub_1BF1C(&v29, 0);
            *(_DWORD *)(a1 + 0x92E) = v25;
            if ( !v25 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x5EE);
            }
            v26 = fp;
            fscanf(fp, "%s %d", v32, &v33);
            *(_WORD *)(a1 + 0x932) = v33;
            fscanf(v26, "%s %d", v32, &v33);
            *(_WORD *)(a1 + 0x934) = v33;
            fscanf(v26, "%s %d", v32, &v33);
            v27 = v35 + 6;
            *(_DWORD *)(a1 + 0x926) = v33;
            v35 = v27;
            Q_CloseFileAndDelete_sub_1BBC8(&v29);
          }
          else
          {
            fscanf(v4, "%s %d", v32, &v33);
            *(_DWORD *)(a1 + 0x916) = v33;
            fscanf(v4, "%s %d", v32, &v33);
            *(_DWORD *)(a1 + 0x91A) = v33;
            fscanf(v4, "%s %d", v32, &v33);
            *(_DWORD *)(a1 + 0x91E) = v33;
            fscanf(v4, "%s %d", v32, &v33);
            v35 = v5 + 5;
            *(_DWORD *)(a1 + 0x922) = v33;
          }
        }
        else if ( v33 <= 2 )
        {
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x5FF);
          }
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 1;
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v37;
          fscanf(fp, "%s %s", v32, v30);
          v6 = strlen(v30) + 1;
          v7 = v30;
          if ( v30[0] )
          {
            do
            {
              if ( *v7 == 0x5F )
              {
                *v7 = 0x20;
              }
            }
            while ( *++v7 );
          }
          v9 = sub_2B5BC((int *)v36, v30);
          if ( v9 == 0xFFFFFFFF )
          {
            Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x613);
          }
          v10 = v37;
          *(_DWORD *)(a1 + 8 * v37 + 0x80C) = v9;
          v11 = operator new[]((__int16)(v6 - 1) + 1);
          v12 = sub_2625C(v11, 1, "SUBTITLE");
          *(_DWORD *)(a1 + 8 * v10 + 0x808) = v12;
          if ( !v12 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x61B);
          }
          v13 = v30;
          v14 = *(char **)(a1 + 8 * v37 + 0x808);
          do
          {
            v15 = *v13;
            *v14 = *v13;
            if ( !v15 )
            {
              break;
            }
            v16 = v13[1];
            v13 += 2;
            v14[1] = v16;
            v14 += 2;
          }
          while ( v16 );
          fscanf(fp, "%s %d", v32, &v33);
          v33 -= 0x20;
          if ( (int)v33 <= 0 )
          {
            Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x622);
          }
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v33;
          v28 = fp;
          ++*(_WORD *)(a1 + 0x806);
          fscanf(v28, "%s %d", v32, &v33);
          v17 = 0xC * *(__int16 *)(a1 + 0x806);
          ++v37;
          *(_WORD *)(v17 + a1 + 0x204) = v33;
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 2;
          v18 = *(_WORD *)(a1 + 0x806);
          v35 += 4;
          *(_WORD *)(a1 + 0x806) = v18 + 1;
        }
        else if ( v33 < 0xB )
        {
          if ( v33 != 3 )
          {
LABEL_10:
            sprintf(
              "Thank you for playing Ascendancy.",
              "\n  ** Bad Subtitle Data: %s, %d (line %d)\n\n",
              v32,
              v33,
              v35);
            Q_debugbreak_exit_sub_2624C();
          }
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x635);
          }
          v19 = fp;
          fscanf(fp, "%s %d", v32, &v33);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v33;
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 3;
          fscanf(v19, "%s %d", v32, &v33);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v33;
          v20 = *(_WORD *)(a1 + 0x806);
          v35 += 3;
          *(_WORD *)(a1 + 0x806) = v20 + 1;
        }
        else if ( v33 <= 0xB )
        {
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x703);
          }
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 0xB;
          v23 = fp;
          fscanf(fp, "%s %d", v32, &v33);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v33;
          fscanf(v23, "%s %d", v32, &v33);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x20C) = v33;
          fscanf(v23, "%s %d", v32, &v33);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v33;
          v24 = *(_WORD *)(a1 + 0x806);
          v35 += 4;
          *(_WORD *)(a1 + 0x806) = v24 + 1;
        }
        else
        {
          if ( v33 != 0x10 )
          {
            goto LABEL_10;
          }
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x68A);
          }
          v21 = fp;
          fscanf(fp, "%s %d", v32, &v33);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v33;
          fscanf(v21, "%s %d", v32, &v33);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = (v33 != 1) + 0x1E;
          fscanf(v21, "%s %d", v32, &v33);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v33;
          v22 = *(_WORD *)(a1 + 0x806) + 1;
          v35 += 4;
          *(_WORD *)(a1 + 0x806) = v22;
        }
      }
      fclose(v4);
      qsort(
        (void *)(a1 + 0x204),
        *(__int16 *)(a1 + 0x806),
        0xCu,
        (int (__fastcall *)(const void *, const void *))sub_28C4C);
      return (FILE *)0xFFFFFFFF;
    }
  }
  return result;
}
// 2A1DC: using guessed type char var_5C[52];

//----- (0002AA88) --------------------------------------------------------
void __fastcall sub_2AA88(int a1)
{
  int v2; // edx
  int v3; // ebx
  int v4; // ecx
  int v5; // edi
  ULONG v6; // edx
  HTIMER v7; // eax
  unsigned __int16 v8; // ax
  int v9; // [esp+0h] [ebp-8h]
  int v10; // [esp+4h] [ebp-4h]

  v9 = a1 + 0x808;
  v10 = a1 + 0x90A;
  while ( 1 )
  {
    v2 = a1 + 0xC * *(__int16 *)(a1 + 0x804);
    v3 = *(__int16 *)(v2 + 0x204);
    v4 = *(_DWORD *)(a1 + 0x19C);
    if ( v3 != v4 )
    {
      break;
    }
    v8 = *(_WORD *)(v2 + 0x206);
    if ( v8 < 3u )
    {
      if ( !v8 )
      {
        goto LABEL_23;
      }
      if ( v8 <= 1u )
      {
        if ( !*(_DWORD *)(a1 + 0x942) )
        {
          v5 = 8 * *(_DWORD *)(v2 + 0x208) + v9;
          sub_2C1E0((int)&V_Type6_stru_D8654, *(_WORD *)(a1 + 0x932), *(_WORD *)(a1 + 0x934), *(_DWORD *)(a1 + 0x92E));
          sub_2C670((int)&V_Type6_stru_D8654, *(__int16 *)(a1 + 0x932), *(__int16 *)(a1 + 0x934), 0);
          sub_2B8A8(
            v10,
            *(__int16 *)(v5 + 4),
            *(__int16 *)(v5 + 6),
            *(const char **)v5,
            0x80,
            0xFFFFFFFF,
            0xFFFFFFFF,
            0);
          *(_WORD *)(a1 + 0x92A) = 1;
        }
        goto LABEL_6;
      }
      if ( *(_DWORD *)(a1 + 0x942) )
      {
        goto LABEL_6;
      }
      *(_WORD *)(a1 + 0x92A) = 2;
      ++*(_WORD *)(a1 + 0x804);
    }
    else if ( v8 <= 3u )
    {
      v6 = *(_DWORD *)(v2 + 0x208);
      v7 = *(_DWORD *)(a1 + 0x936);
      *(_DWORD *)(a1 + 0x1E0) = v6;
      if ( v7 == 0xFFFFFFFF )
      {
        goto LABEL_6;
      }
      if ( v6 )
      {
        AIL_set_timer_frequency(v7, v6);
      }
      else
      {
        AIL_stop_timer(v7);
      }
      ++*(_WORD *)(a1 + 0x804);
    }
    else if ( v8 < 0x1Eu )
    {
      if ( v8 != 0xB )
      {
        goto LABEL_23;
      }
      if ( dword_109357 == 0xFFFFFFFF )
      {
        sub_4FF4C((int)&unk_10914C, *(_DWORD *)(v2 + 0x20C));
        ++*(_WORD *)(a1 + 0x804);
      }
      else
      {
LABEL_6:
        ++*(_WORD *)(a1 + 0x804);
      }
    }
    else if ( v8 <= 0x1Eu )
    {
      sub_4F8CC((int)&unk_10914C, *(_DWORD *)(v2 + 0x208), v4 ^ v3);
      ++*(_WORD *)(a1 + 0x804);
    }
    else if ( v8 == 0x1F )
    {
      sub_4FA1C((int)&unk_10914C);
      ++*(_WORD *)(a1 + 0x804);
    }
    else
    {
LABEL_23:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x80F);
      ++*(_WORD *)(a1 + 0x804);
    }
  }
}
// 109357: using guessed type int dword_109357;

//----- (0002AC84) --------------------------------------------------------
int __fastcall sub_2AC84(int a1, ULONG hertz)
{
  HTIMER v4; // edx
  HTIMER v5; // eax

  *(_DWORD *)(a1 + 0x1E0) = hertz;
  v4 = *(_DWORD *)(a1 + 0x936);
  if ( v4 == 0xFFFFFFFF )
  {
    v5 = AIL_register_timer(sub_28C40);
    *(_DWORD *)(a1 + 0x936) = v5;
    if ( v5 == 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x823);
    }
    AIL_set_timer_frequency(*(_DWORD *)(a1 + 0x936), hertz);
    AIL_start_timer(*(_DWORD *)(a1 + 0x936));
  }
  else
  {
    AIL_set_timer_frequency(v4, hertz);
  }
  return (*(_DWORD *)(a1 + 0x936) == 0xFFFFFFFF) - 1;
}

//----- (0002AD08) --------------------------------------------------------
void __fastcall sub_2AD08(int a1)
{
  if ( *(_DWORD *)(a1 + 0x936) != 0xFFFFFFFF )
  {
    AIL_stop_timer(*(_DWORD *)(a1 + 0x936));
    AIL_release_timer_handle(*(_DWORD *)(a1 + 0x936));
    *(_DWORD *)(a1 + 0x936) = 0xFFFFFFFF;
  }
}

//----- (0002AD40) --------------------------------------------------------
__int16 __cdecl sub_2AD40(unsigned __int16 *a1, int a2, LONG y)
{
  int v4; // ecx
  __int16 *v5; // esi
  __int16 result; // ax
  int v7; // edx
  int v8; // eax
  _BYTE *v9; // esi
  LONG v10; // edx
  char v11; // al
  __int16 *v12; // esi
  int v13; // ecx
  __int16 v14; // ax
  int v15; // edx
  unsigned int v16; // ecx
  __int16 v17; // ax
  UBYTE *v18; // edi
  LONG v19; // edx
  ULONG i; // ecx
  unsigned int j; // ecx
  int v22; // edx
  unsigned int v23; // ecx
  UBYTE *v24; // edi
  ULONG v25; // ecx
  LONG v26; // edx
  int v27; // [esp-2Eh] [ebp-42h]
  int v28; // [esp-2Eh] [ebp-42h]
  LONG v29; // [esp-2Ah] [ebp-3Eh]
  int v30; // [esp-26h] [ebp-3Ah]
  int v31; // [esp-26h] [ebp-3Ah]
  LONG v32; // [esp-22h] [ebp-36h]
  LONG v33; // [esp-22h] [ebp-36h]
  int v34; // [esp-1Eh] [ebp-32h]
  __int16 v35; // [esp-1Eh] [ebp-32h]
  __int16 v36; // [esp-1Ah] [ebp-2Eh]
  ULONG v37; // [esp-1Ah] [ebp-2Eh]
  int v38; // [esp-16h] [ebp-2Ah]
  unsigned int v39; // [esp-16h] [ebp-2Ah]
  __int16 v40; // [esp-12h] [ebp-26h]
  int v41; // [esp-10h] [ebp-24h]
  ULONG v42; // [esp+4h] [ebp-10h] BYREF
  UBYTE *v43; // [esp+8h] [ebp-Ch] BYREF
  ULONG nbytes; // [esp+Ch] [ebp-8h] BYREF
  UBYTE *addr; // [esp+10h] [ebp-4h] BYREF

  v4 = *a1;
  v5 = (__int16 *)(a1 + 1);
  do
  {
    while ( 1 )
    {
      result = *v5++;
      if ( result > 0 )
      {
        break;
      }
      if ( (result & 0x4000) != 0 )
      {
        LOWORD(y) = y - result;
      }
    }
    v7 = a2;
    v41 = v4;
    do
    {
      v40 = result;
      v8 = *(unsigned __int8 *)v5;
      v9 = (char *)v5 + 1;
      v10 = v8 + v7;
      v11 = *v9;
      v12 = (__int16 *)(v9 + 1);
      if ( (v11 & 0x80) != 0 )
      {
        v13 = -v11;
        v14 = *v12;
        v5 = v12 + 1;
        v36 = v14;
        v34 = 2 * v13;
        VFX_line_address(v10, y, &addr, &nbytes);
        v15 = v27;
        v16 = v34;
        v17 = v36;
        v18 = addr;
        if ( v34 > (int)nbytes )
        {
          v37 = v34 - nbytes;
          v19 = nbytes + v27;
          for ( i = nbytes >> 1; i; --i )
          {
            *(_WORD *)v18 = v17;
            v18 += 2;
          }
          v35 = v17;
          VFX_line_address(v19, v29, &addr, &nbytes);
          v15 = v28;
          v17 = v35;
          v16 = v37;
          v18 = addr;
        }
        v7 = v16 + v15;
        for ( j = v16 >> 1; j; --j )
        {
          *(_WORD *)v18 = v17;
          v18 += 2;
        }
      }
      else
      {
        v38 = 2 * v11;
        VFX_line_address(v10, y, &v43, &v42);
        v22 = v30;
        y = v32;
        v23 = v38;
        v24 = v43;
        if ( v38 > (int)v42 )
        {
          v39 = v38 - v42;
          v25 = v42;
          v26 = v42 + v30;
          qmemcpy(v43, v12, v42);
          v12 = (__int16 *)((char *)v12 + v25);
          VFX_line_address(v26, v32, &v43, &v42);
          v22 = v31;
          y = v33;
          v23 = v39;
          v24 = v43;
        }
        v7 = v23 + v22;
        qmemcpy(v24, v12, v23);
        v5 = (__int16 *)((char *)v12 + v23);
      }
      result = v40 - 1;
    }
    while ( v40 != 1 );
    LOWORD(y) = y + 1;
    v4 = v41 - 1;
  }
  while ( v41 != 1 );
  return result;
}
// 2ADAB: variable 'v27' is possibly undefined
// 2ADD3: variable 'v29' is possibly undefined
// 2ADD9: variable 'v28' is possibly undefined
// 2AE00: variable 'v30' is possibly undefined
// 2AE01: variable 'v32' is possibly undefined
// 2AE29: variable 'v31' is possibly undefined
// 2AE2A: variable 'v33' is possibly undefined

//----- (0002AE80) --------------------------------------------------------
void __fastcall __spoils<> sub_2AE80(P_TypeA9 a1)
{
  T_Type2 *__shifted(T_TypeA9,0xAB) v1; // eax

  sub_2C830(&a1->a);
  v1 = &a1->b;
  sub_28C74(v1);
  ADJ(v1)->a.b = (int)off_95CB4;
  ADJ(v1)->c = 1;
  ADJ(v1)->d = 0;
}
// 95CB4: using guessed type int (*off_95CB4[3])();

//----- (0002AEB0) --------------------------------------------------------
void *__fastcall sub_2AEB0(int a1, char a2)
{
  void *v4; // eax
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  void *v9; // ebx

  if ( (a2 & 4) != 0 )
  {
    v4 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95CA0);
    operator delete[](v4);
    return (void *)a1;
  }
  else
  {
    v6 = a1 + 0xAB;
    *(_DWORD *)(v6 - 4) = off_95CB4;
    v7 = sub_28DA4(v6);
    v8 = (void *)sub_2C848(v7 - 0xAB, 1);
    v9 = v8;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v8);
    }
    return v9;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95CB4: using guessed type int (*off_95CB4[3])();

//----- (0002AF04) --------------------------------------------------------
unsigned int __fastcall sub_2AF04(int a1, const char *a2)
{
  unsigned int result; // eax

  result = sub_28EB4(a1 + 0xAB, a2, **(_DWORD **)&V_Type3_stru_10AE70.z1[0x300A], 0xFFFFFFFF, 0xFFFFFFFF);
  if ( !result )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flicwin.cpp", 0x4E);
  }
  return result;
}

//----- (0002AF3C) --------------------------------------------------------
int __fastcall sub_2AF3C(int a1)
{
  signed int v2; // esi
  int v4; // ebx
  unsigned int v5; // ebx

  v2 = *(__int16 *)(a1 + 0xA01) << 0x14;
  if ( v2 <= dword_132B08 )
  {
    v4 = *(__int16 *)(a1 + 0xA03);
    if ( v4 == 0xFFFFFFFF )
    {
      v2 = dword_132B08;
      v5 = dword_132B08;
    }
    else
    {
      v5 = v4 << 0x14;
    }
    sub_1B4D0(dword_12FC20);
    return sub_29038(a1 + 0xAB, v2, v5, *(__int16 *)(a1 + 0xA05) << 0xA, *(__int16 *)(a1 + 0xA07) << 0xA, dword_132B04);
  }
  else
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flicwin.cpp", 0x67);
    return 0;
  }
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002AFF0) --------------------------------------------------------
unsigned int __fastcall sub_2AFF0(int a1, __int16 a2, int a3, int a4)
{
  __int16 v6; // cx
  __int16 v7; // dx
  __int16 v8; // bx
  unsigned int result; // eax
  RGB v10[256]; // [esp+0h] [ebp-31Ch] BYREF
  int v11; // [esp+300h] [ebp-1Ch]
  unsigned int v12; // [esp+304h] [ebp-18h]
  int v13; // [esp+308h] [ebp-14h]
  char v14; // [esp+30Ch] [ebp-10h]

  LOWORD(v13) = a2;
  v12 = 0;
  v11 = a1 + 0xAB;
  switch ( a2 )
  {
    case 1:
      *(_DWORD *)(a1 + 0x247) = 0xFFFFFFFF;
      *(_WORD *)(a1 + 0x9F7) = 0;
      *(_DWORD *)(a1 + 0x9F9) = 0;
      *(_DWORD *)(a1 + 0x9FD) = 0;
      sub_64F06();
      dword_132B60 = 0;
      if ( sub_2AF3C(a1) )
      {
        sub_4FA1C((int)&unk_10914C);
        sub_2F424(a1, v13, a3, a4);
        sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xA, 0, 0, 0);
        sub_2AC84(v11, 0x12u);
      }
      else
      {
        sub_1ACE8((int)dword_12FC20);
        sub_64ECA();
        sub_56B60((int)&V_Type3_stru_10AE70, *(_WORD *)(a1 + 0x45), *(_DWORD *)(a1 + 0x47), *(_DWORD *)(a1 + 0x4B));
      }
      result = v12;
      break;
    case 2:
      v6 = 0;
      sub_2AD08(a1 + 0xAB);
      v14 = 0x81;
      while ( v6 < 0x40 )
      {
        sub_2BD04((int)&V_Type6_stru_D8654, v6, 0);
        sub_4FF4C((int)&unk_10914C, v14);
        ++v6;
        v14 -= 2;
      }
      sub_4FA1C((int)&unk_10914C);
      sub_1ACE8((int)dword_12FC20);
      memset(v10, 0, sizeof(v10));
      sub_2C224(&V_Type6_stru_D8654, 0, 0x100, v10);
      VFX_area_wipe(0, 0, 0x27F, 0x1DF, 0);
      sub_2C158(&V_Type6_stru_D8654, "DATA\\game.pal", 0, 0x100u);
      sub_2C224(&V_Type6_stru_D8654, 0, 0x100, v10);
      dword_132B60 = 0xFFFFFFFF;
      dword_132B64 = 0;
      sub_64ECA();
      sub_2F424(a1, v13, a3, a4);
      result = v12;
      break;
    case 3:
    case 4:
    case 5:
      goto LABEL_14;
    case 0xA:
      if ( !sub_296B4(a1 + 0xAB, a1 + 0xAB, a3, a4) )
      {
        v7 = *(_WORD *)(a1 + 0x9F7) + 1;
        v8 = *(_WORD *)(a1 + 0x9F5);
        *(_WORD *)(a1 + 0x9F7) = v7;
        if ( v7 < v8 )
        {
          sub_2AF3C(a1);
        }
      }
      if ( *(_WORD *)(a1 + 0x9F7) >= *(_WORD *)(a1 + 0x9F5) )
      {
LABEL_14:
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xA);
        sub_56B60((int)&V_Type3_stru_10AE70, *(_WORD *)(a1 + 0x45), *(_DWORD *)(a1 + 0x47), *(_DWORD *)(a1 + 0x4B));
      }
      v12 = 0xFFFFFFFF;
      result = 0xFFFFFFFF;
      break;
    default:
      result = sub_2F424(a1, v13, a3, a4);
      break;
  }
  return result;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 132B60: using guessed type int dword_132B60;
// 132B64: using guessed type int dword_132B64;

//----- (0002B2C0) --------------------------------------------------------
void __fastcall __spoils<> sub_2B2C0(_DWORD *a1)
{
  *a1 = 0;
  a1[2] = 0;
  sub_2B2FC((int)a1, 0);
}

//----- (0002B2E0) --------------------------------------------------------
void **__fastcall sub_2B2E0(void **a1)
{
  if ( *a1 )
  {
    sub_2627C(*a1);
  }
  operator delete(*a1);
  return a1;
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0002B2FC) --------------------------------------------------------
unsigned int __fastcall sub_2B2FC(int a1, const char *aFName)
{
  void *v4; // eax
  void *v5; // eax
  int i; // eax

  *(_DWORD *)(a1 + 8) = &V_Type6_stru_D8654;
  if ( aFName )
  {
    return sub_2B360((void **)a1, aFName);
  }
  v4 = operator new[](0x100u);
  v5 = sub_2625C(v4, 1, "FONT TRANSLATE");
  *(_DWORD *)(a1 + 4) = v5;
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x5D);
  }
  for ( i = 0; i < 0x100; ++i )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + i) = i;
  }
  return 0xFFFFFFFF;
}

//----- (0002B360) --------------------------------------------------------
unsigned int __fastcall sub_2B360(void **a1, const char *aFName)
{
  void *v4; // eax
  T_Type1 v6; // [esp+0h] [ebp-124h] BYREF

  if ( !aFName )
  {
    return 0xFFFFFFFF;
  }
  Q_InitFileInfo_sub_1BB78(&v6);
  if ( !Q_CfilePreload_sub_1BBFC(&v6, aFName, O_BINARY, 0) )
  {
    if ( *a1 )
    {
      sub_2627C(*a1);
    }
    operator delete(*a1);
    v4 = sub_1BF1C(&v6, 0);
    *a1 = v4;
    if ( v4 )
    {
      Q_CloseFileAndDelete_sub_1BBC8(&v6);
      return 0xFFFFFFFF;
    }
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v6);
  return 0;
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0002B3E0) --------------------------------------------------------
_DWORD *__fastcall sub_2B3E0(_DWORD *result, int a2, int a3, int a4, int a5)
{
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  result[6] = a5;
  return result;
}

//----- (0002B3F4) --------------------------------------------------------
int __fastcall sub_2B3F4(int a1, char *s2, char *s1, int a4)
{
  char *v6; // esi
  char v7; // al
  int v8; // ecx
  const char *v9; // ebp
  _BYTE *v10; // esi
  char v11; // al
  char v13; // bl
  char *v14; // esi
  char v15; // al
  char v16; // al
  char v17[4]; // [esp+0h] [ebp-14h] BYREF
  int v18; // [esp+4h] [ebp-10h]

  v18 = a1;
  v6 = s2;
  while ( *v6 != 0x7C )
  {
    if ( *v6 )
    {
      v7 = *++v6;
      if ( *v6 == 0x7C )
      {
        break;
      }
      ++v6;
      if ( v7 )
      {
        continue;
      }
    }
    v6 = 0;
    break;
  }
  v8 = 0;
  if ( v6 )
  {
    if ( v6 != s2 )
    {
      strncpy(s1, s2, v6 - s2);
      s1[v6 - s2] = 0;
      return v6 - s2;
    }
    v9 = v6 + 1;
    v10 = v6 + 1;
    *s1 = 0;
    while ( *v10 != 0x7C )
    {
      if ( *v10 )
      {
        v11 = *++v10;
        if ( *v10 == 0x7C )
        {
          break;
        }
        ++v10;
        if ( v11 )
        {
          continue;
        }
      }
      v10 = 0;
      break;
    }
    if ( v10 )
    {
      v8 = v10 - v9 + 2;
      if ( v10 == v9 )
      {
        s1[1] = 0;
        *s1 = 0x7C;
        return v10 - v9 + 2;
      }
      if ( a4 == 0xFFFFFFFF )
      {
        strncpy(v17, v9, 3u);
        v17[3] = 0;
        v13 = atoi(v17);
        *(_BYTE *)(*(_DWORD *)(v18 + 4) + 0xF3) = v13;
        return v10 - v9 + 2;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v14 = s2;
    do
    {
      v15 = *v14;
      *s1 = *v14;
      if ( !v15 )
      {
        break;
      }
      v16 = v14[1];
      v14 += 2;
      s1[1] = v16;
      s1 += 2;
    }
    while ( v16 );
  }
  return v8;
}

//----- (0002B4F4) --------------------------------------------------------
int __fastcall sub_2B4F4(_DWORD *a1, char *string)
{
  int v3; // edi
  char *v4; // esi
  int v6; // [esp-4h] [ebp-24h]
  int i; // [esp+0h] [ebp-20h]
  char *ptr; // [esp+4h] [ebp-1Ch]
  char *s2; // [esp+8h] [ebp-18h]

  if ( !string )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0xD7);
  }
  if ( !*a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0xD8);
  }
  s2 = string;
  v3 = 0;
  ptr = strdup(string);
  do
  {
    v4 = ptr;
    for ( i = sub_2B3F4((int)a1, s2, ptr, 0); *v4; v3 += sub_60653(*a1, v6) )
    {
      v6 = (unsigned __int8)*v4++;
    }
    s2 += i;
  }
  while ( i > 0 );
  free(ptr);
  return v3;
}

//----- (0002B594) --------------------------------------------------------
int __fastcall sub_2B594(int *a1)
{
  if ( !*a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x104);
  }
  return sub_60640(*a1);
}

//----- (0002B5BC) --------------------------------------------------------
int __fastcall sub_2B5BC(int *a1, char *a2)
{
  int v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // ebx

  v3 = sub_2B594(a1);
  v4 = sub_2B4F4(a1, a2);
  v5 = a1[6] - a1[4] - v3;
  v6 = a1[5] - a1[3] - v4;
  if ( v5 >= 0 && v6 >= 0 )
  {
    return (v6 >> 1) + (v5 >> 1 << 0x10);
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (0002B610) --------------------------------------------------------
void __fastcall sub_2B610(_DWORD *a1, int a2, int a3, char *a4, int a5, int a6, __int16 a7)
{
  __int16 v8; // cx
  int v9; // ebx
  int v10; // edx
  int v11; // edi
  int v12; // eax
  int v13; // edx
  char *v14; // esi
  char *v15; // edi
  int v16; // eax
  T_Type5 v17; // [esp+0h] [ebp-38h] BYREF
  int v18; // [esp+14h] [ebp-24h]
  int v19; // [esp+18h] [ebp-20h]
  char *string; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v21; // [esp+20h] [ebp-18h]
  int v22; // [esp+24h] [ebp-14h]
  int v23; // [esp+28h] [ebp-10h]

  v19 = a2;
  v22 = a3;
  string = a4;
  v8 = a6;
  if ( !string )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x13B);
  }
  if ( !*a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x13C);
  }
  if ( a7 == 0xFFFFFFFF )
  {
    a7 = *((_WORD *)a1 + 0xE);
  }
  if ( (__int16)a6 == 0xFFFFFFFF )
  {
    v8 = 0xF3;
  }
  if ( v8 != 0xFFFFFFFE )
  {
    *(_BYTE *)(a1[1] + 0xF3) = v8;
  }
  v9 = sub_2B594(a1);
  v17.a = (P_Type6)a1[2];
  v17.rect.x1 = a1[3];
  v17.rect.y1 = a1[4];
  v17.rect.x1 += v19;
  v17.rect.y1 += v22;
  v10 = sub_2B4F4(a1, string) + v17.rect.x1;
  v17.rect.x2 = v10;
  v17.rect.y2 = v9 + v17.rect.y1;
  v11 = a1[5];
  if ( v17.rect.x1 <= v11 )
  {
    v12 = v10;
    v13 = a1[3];
    if ( v12 >= v13 && v17.rect.y1 <= a1[6] && v17.rect.y2 >= a1[4] )
    {
      if ( v13 <= v17.rect.x1 )
      {
        if ( v11 < v17.rect.x2 )
        {
          v17.rect.x2 = a1[5];
        }
      }
      else
      {
        v17.rect.x1 = a1[3];
      }
      if ( v17.rect.y1 >= a1[4] )
      {
        if ( v17.rect.y2 > a1[6] )
        {
          v17.rect.y2 = a1[6];
        }
      }
      else
      {
        v17.rect.y1 = a1[4];
      }
      if ( a7 != 0xFF )
      {
        sub_5E9D0(&v17, a7);
      }
      v14 = strdup(string);
      v23 = v19;
      v15 = string;
      v21 = a1 + 2;
      do
      {
        v18 = sub_2B3F4((int)a1, v15, v14, 0xFFFFFFFF);
        if ( *v14 )
        {
          sub_60806(v21, v23, v22, *a1, v14, a1[1]);
        }
        v16 = sub_2B4F4(a1, v14);
        v15 += v18;
        v23 += v16;
      }
      while ( v18 > 0 );
      free(v14);
      if ( (a5 & 0xC0) == 0 )
      {
        sub_552CC(&V_Type3_stru_10AE70, &v17);
      }
    }
  }
}

//----- (0002B8A8) --------------------------------------------------------
int __fastcall sub_2B8A8(int a1, int a2, int a3, const char *a4, __int16 a5, __int16 a6, __int16 a7, int a8)
{
  __int16 v9; // ax
  char *v10; // ebp
  char *v11; // ebx
  char *v12; // ecx
  unsigned int v13; // edi
  int v14; // eax
  int v15; // eax
  int v16; // edx
  __int64 v17; // rax
  char *v18; // ebp
  int v19; // edx
  int v20; // edx
  int v22; // [esp+0h] [ebp-40h]
  int v23; // [esp+4h] [ebp-3Ch]
  char *ptr; // [esp+Ch] [ebp-34h]
  int i; // [esp+14h] [ebp-2Ch]
  int v27; // [esp+18h] [ebp-28h]
  int v29; // [esp+20h] [ebp-20h]
  char v30; // [esp+30h] [ebp-10h]

  if ( (a5 & 0x80) != 0 && a7 != 0xFF )
  {
    LOBYTE(v9) = a7;
    if ( a7 == 0xFFFFFFFF )
    {
      v9 = *(_WORD *)(a1 + 0x1C);
    }
    sub_5E9D0((P_Type5)(a1 + 8), v9);
  }
  if ( a6 == 0xFFFFFFFF )
  {
    LOBYTE(a6) = 0xF3;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 0xF3) = a6;
  if ( a8 < 1 )
  {
    a8 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  }
  ptr = strdup(a4);
  v10 = ptr;
  v11 = ptr;
  v12 = ptr;
  v29 = 1;
  v13 = 0;
  do
  {
    if ( !*v11 )
    {
      v13 = 0xFFFFFFFF;
    }
    v30 = *v11;
    *v11 = 0;
    v14 = sub_2B4F4((_DWORD *)a1, v10);
    *v11 = v30;
    if ( v30 == 0xA )
    {
      *v11++ = 0;
      v10 = v11;
      ++v29;
    }
    else if ( v14 <= a8 || v12 <= v10 )
    {
      if ( *v11 == 0x20 )
      {
        v12 = v11;
      }
      ++v11;
    }
    else
    {
      v10 = v12 + 1;
      *v12 = 0;
      v11 = v12 + 1;
      ++v29;
    }
  }
  while ( !v13 );
  v27 = sub_2B594((int *)a1) + 2;
  v22 = v29 * v27;
  if ( (a5 & 0x10) != 0 )
  {
    v15 = a3 - v22;
  }
  else
  {
    v16 = v22 + 1;
    if ( (a5 & 1) != 0 )
    {
      v17 = *(_DWORD *)(a1 + 0x18) - *(_DWORD *)(a1 + 0x10) - v16;
      v15 = ((int)v17 - HIDWORD(v17)) >> 1;
    }
    else
    {
      if ( (a5 & 4) != 0 )
      {
        v23 = a3 - v16 / 2;
        goto LABEL_30;
      }
      v15 = a3;
    }
  }
  v23 = v15;
LABEL_30:
  v18 = ptr;
  for ( i = 0; i < v29; ++i )
  {
    v19 = sub_2B4F4((_DWORD *)a1, v18);
    if ( (a5 & 0x20) != 0 )
    {
      v20 = a2 - v19;
    }
    else if ( (a5 & 2) != 0 )
    {
      v20 = (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) - v19) / 2;
    }
    else if ( (a5 & 8) != 0 )
    {
      v20 = a2 - v19 / 2;
    }
    else
    {
      v20 = a2;
    }
    sub_2B610((_DWORD *)a1, v20, v23, v18, a5, 0xFFFFFFFE, a7);
    v18 += strlen(v18) + 1;
    v23 += v27;
  }
  if ( (a5 & 0x80) != 0 )
  {
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 8));
  }
  free(ptr);
  return v29 * v27;
}
// 2B8A8: could not find valid save-restore pair for ebx

//----- (0002BB50) --------------------------------------------------------
int sub_2BB50()
{
  int result; // eax

  _wcpp_2_mod_register_(&unk_96780);
  result = sub_2BD4C((int)&V_Type6_stru_D8654);
  dword_96788 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96788: using guessed type int dword_96788;

//----- (0002BB74) --------------------------------------------------------
unsigned int __fastcall sub_2BB74(int **a1, int *a2, int *a3, int *a4, int *a5, unsigned __int8 a6, int a7)
{
  int *v9[5]; // [esp+0h] [ebp-2Ch] BYREF
  int *v10; // [esp+14h] [ebp-18h]
  int *v11; // [esp+18h] [ebp-14h]
  int *v12; // [esp+1Ch] [ebp-10h]

  v12 = a2;
  v11 = a3;
  v10 = a4;
  if ( a7 == 0xFFFFFFFF )
  {
    v9[0] = *a1;
    v9[1] = v12;
    v9[4] = a5;
    v9[3] = a4;
    v9[2] = a3;
    return sub_5EAAF(v9, 0, 0, a1, (int)v12, (int)a3, a6);
  }
  else
  {
    sub_5C001(a1, (int)v12, (int)a3, (int)a4, (int)a3, 0, (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a6);
    sub_5C001(a1, (int)v12, (int)a5, (int)v10, (int)a5, 0, (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a6);
    sub_5C001(a1, (int)v12, (int)v11, (int)v12, (int)a5, 0, (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a6);
    return sub_5C001(
             a1,
             (int)v10,
             (int)v11,
             (int)v10,
             (int)a5,
             0,
             (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a6);
  }
}
// 2BB74: could not find valid save-restore pair for ebx

//----- (0002BC40) --------------------------------------------------------
int __fastcall sub_2BC40(_DWORD *a1, int a2, int a3, int *a4, int *a5)
{
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-24h] BYREF
  int v11; // [esp+4h] [ebp-20h]
  int v12; // [esp+8h] [ebp-1Ch]
  int v13; // [esp+Ch] [ebp-18h]
  int v14; // [esp+10h] [ebp-14h]
  int v15; // [esp+14h] [ebp-10h]

  v15 = a2;
  v14 = a3;
  if ( !a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x40);
  }
  if ( !v15 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x41);
  }
  sub_5E1DD(v15, v14, 0, 0, 0, &v10);
  v6 = v13 - v11;
  v7 = a1[3] - a1[1] - (v12 - v10);
  *a4 = v7;
  if ( v7 )
  {
    *a4 = v7 / 2;
  }
  v8 = a1[4] - a1[2] - v6;
  *a5 = v8;
  if ( v8 )
  {
    *a5 = v8 / 2;
  }
  *a4 -= v10;
  result = v11;
  *a5 -= v11;
  return result;
}

//----- (0002BCF4) --------------------------------------------------------
int __fastcall sub_2BCF4(int a1, unsigned __int8 a2)
{
  return sub_2BD04(&V_Type6_stru_D8654, a2, 0);
}
// 2BD04: using guessed type int __fastcall sub_2BD04(_DWORD, _DWORD, _DWORD);

//----- (0002BD04) --------------------------------------------------------
__int64 __fastcall sub_2BD04(int a1, char a2, char *a3)
{
  char v4; // dh
  _BYTE *v5; // eax
  char v6; // dl
  char v7; // dl
  char v8; // dl
  char v10; // [esp+0h] [ebp-14h]
  char v11; // [esp+1h] [ebp-13h]
  char v12; // [esp+2h] [ebp-12h]

  if ( !a2 )
  {
    sub_2C2B0(a1, 0, 0x100, a1 + 0x133);
  }
  if ( a3 )
  {
    v10 = *a3;
    v11 = a3[1];
    v12 = a3[2];
  }
  else
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
  }
  v4 = 0x40 - a2;
  if ( (char)(0x40 - a2) < 0 )
  {
    v4 = 0;
  }
  v5 = (_BYTE *)a1;
  do
  {
    v8 = v5[0x133] - v10;
    if ( v8 >= 0 )
    {
      if ( (char)(v8 - v4) > 0 )
      {
        --v5[0x133];
      }
    }
    else if ( (char)(v4 + v8) < 0 )
    {
      ++v5[0x133];
    }
    v6 = v5[0x134] - v11;
    if ( v6 >= 0 )
    {
      if ( (char)(v6 - v4) > 0 )
      {
        --v5[0x134];
      }
    }
    else if ( (char)(v4 + v6) < 0 )
    {
      ++v5[0x134];
    }
    v7 = v5[0x135] - v12;
    if ( v7 >= 0 )
    {
      if ( (char)(v7 - v4) > 0 )
      {
        --v5[0x135];
      }
    }
    else if ( (char)(v4 + v7) < 0 )
    {
      ++v5[0x135];
    }
    v5 += 3;
  }
  while ( v5 != (_BYTE *)(a1 + 0x300) );
  return (unsigned int)sub_2C224((P_Type6)a1, 0, 0x100, (RGB *)(a1 + 0x133));
}

//----- (0002BD4C) --------------------------------------------------------
int __fastcall sub_2BD4C(int result)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 0x14) = 0;
  *(_DWORD *)(result + 0x12F) = 0;
  *(_BYTE *)(result + 0x30) = 0;
  *(_DWORD *)(result + 0x73B) = 0;
  *(_WORD *)(result + 0x73F) = 0;
  return result;
}

//----- (0002BD7C) --------------------------------------------------------
T_Type6 *__fastcall sub_2BD7C(T_Type6 *a1)
{
  sub_2C6CC(a1);
  return a1;
}

//----- (0002BD88) --------------------------------------------------------
unsigned int __fastcall sub_2BD88(P_Type6 a1, const char *a2, const char *a3)
{
  int (**fname)(void); // edx
  const char *v5; // esi
  char *v6; // edi
  char v7; // al
  char v8; // al
  const char *v9; // esi
  char *v10; // edi
  char v11; // al
  char v12; // al
  char *v13; // edi
  const char *v14; // esi
  char *v15; // edi
  char v16; // al
  char v17; // al
  const char *v18; // esi
  char *v19; // edi
  char v20; // al
  char v21; // al
  void *v22; // esi
  unsigned int result; // eax
  char *v24; // edi
  const char *v25; // esi
  int v26; // ecx
  bool v27; // zf
  char *v28; // edi
  char v29; // al
  char v30; // al
  const char *v31; // esi
  char *v32; // edi
  char v33; // al
  char v34; // al
  void *v35; // ecx
  void *v36; // eax
  int a; // eax
  int b; // eax
  int v39; // eax
  int v40; // eax
  int v41; // edi
  char *v42; // [esp-4h] [ebp-234h]
  T_Type1 v43; // [esp+0h] [ebp-230h] BYREF
  char v44[256]; // [esp+118h] [ebp-118h] BYREF
  const char *v45; // [esp+218h] [ebp-18h]
  void *drvr; // [esp+21Ch] [ebp-14h]

  v45 = a2;
  fname = (int (**)(void))a1->fname;
  v5 = v45;
  v6 = a1->fname;
  v42 = a1->fname;
  do
  {
    v7 = *v5;
    *v6 = *v5;
    if ( !v7 )
    {
      break;
    }
    v8 = v5[1];
    v5 += 2;
    v6[1] = v8;
    v6 += 2;
  }
  while ( v8 );
  v9 = "\\";
  v10 = &v42[strlen(v42)];
  do
  {
    v11 = *v9;
    *v10 = *v9;
    if ( !v11 )
    {
      break;
    }
    v12 = v9[1];
    v9 += 2;
    v10[1] = v12;
    v10 += 2;
  }
  while ( v12 );
  v13 = v42;
  if ( a3 )
  {
    v31 = a3;
    v26 = 0xFFFFFFFF;
    do
    {
      if ( !v26 )
      {
        break;
      }
      v27 = *v13++ == 0;
      --v26;
    }
    while ( !v27 );
    v32 = v13 + 0xFFFFFFFF;
    do
    {
      v33 = *v31;
      *v32 = *v31;
      if ( !v33 )
      {
        break;
      }
      v34 = v31[1];
      v31 += 2;
      v32[1] = v34;
      v32 += 2;
    }
    while ( v34 );
  }
  else
  {
    v14 = v45;
    v15 = v44;
    do
    {
      v16 = *v14;
      *v15 = *v14;
      if ( !v16 )
      {
        break;
      }
      v17 = v14[1];
      v14 += 2;
      v15[1] = v17;
      v15 += 2;
    }
    while ( v17 );
    v18 = "\\VFXSCAN.DLL";
    a3 = (const char *)0x200;
    v19 = &v44[strlen(v44)];
    do
    {
      v20 = *v18;
      *v19 = *v18;
      if ( !v20 )
      {
        break;
      }
      v21 = v18[1];
      v18 += 2;
      v19[1] = v21;
      v19 += 2;
    }
    while ( v21 );
    Q_InitFileInfo_sub_1BB78(&v43);
    Q_CfilePreload_sub_1BBFC(&v43, v44, 0x200, 0);
    v22 = sub_1BF1C(&v43, 0);
    if ( !v22 )
    {
      a3 = (const char *)0x9F;
      Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x9F);
    }
    Q_CloseFileAndDelete_sub_1BBC8(&v43);
    if ( !v22 )
    {
      return 0;
    }
    drvr = DLL_load(v22, 5u, 0);
    sub_2627C(v22);
    fname = (int (**)(void))drvr;
    operator delete(v22);
    if ( !fname )
    {
      return 0;
    }
    v24 = a1->fname;
    v25 = sub_5BE08(fname);
    v26 = 0xFFFFFFFF;
    do
    {
      if ( !v26 )
      {
        break;
      }
      v27 = *v24++ == 0;
      --v26;
    }
    while ( !v27 );
    v28 = v24 + 0xFFFFFFFF;
    do
    {
      v29 = *v25;
      *v28 = *v25;
      if ( !v29 )
      {
        break;
      }
      v30 = v25[1];
      v25 += 2;
      v28[1] = v30;
      v28 += 2;
    }
    while ( v30 );
    free(drvr);
  }
  result = sub_2BFDC(a1, (int)fname, (int)a3, v26);
  if ( result )
  {
    VFX_init_driver();
    v35 = *(void **)a1->z1;
    *(_DWORD *)&a1->fname[0xFF] = 0xFFFFFFFF;
    if ( v35 )
    {
      sub_262CC(v35);
    }
    v36 = sub_262B0(a1->b * a1->a, 1u, 1, "OFFSCREEN BUFFER");
    *(_DWORD *)&a1->z1[0xC] = 0;
    *(_DWORD *)a1->z1 = v36;
    a = a1->a;
    *(_DWORD *)&a1->z1[0x10] = 0;
    *(_DWORD *)&a1->z1[4] = a - 1;
    b = a1->b;
    a1->pane.x0 = 0;
    *(_DWORD *)&a1->z1[8] = b - 1;
    v39 = a1->a;
    a1->pane.y0 = 0;
    a1->pane.x1 = v39 - 1;
    v40 = a1->b;
    a1->pane.window = (WINDOW *)a1;
    v41 = *(_DWORD *)a1->z1;
    a1->pane.y1 = v40 - 1;
    if ( !v41 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0xD9);
    }
    return 0xFFFFFFFF;
  }
  return result;
}
// 76D64: using guessed type void __fastcall operator delete(void *);
// 2BD88: using guessed type char var_118[256];

//----- (0002BFDC) --------------------------------------------------------
unsigned int __fastcall sub_2BFDC(P_Type6 a1, int a2, int a3, int a4)
{
  void *v5; // esi
  void *v7; // edx
  VFX_DESC *VFX; // eax
  T_Type1 v9; // [esp-128h] [ebp-12Ch] BYREF
  int v10; // [esp-4h] [ebp-8h]

  v10 = a4;
  Q_InitFileInfo_sub_1BB78(&v9);
  Q_CfilePreload_sub_1BBFC(&v9, a1->fname, O_BINARY, 0);
  v5 = sub_1BF1C(&v9, 0);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0xEB);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v9);
  if ( !v5 )
  {
    return 0;
  }
  v7 = DLL_load(v5, DLLMEM_ALLOC|DLLSRC_MEM, 0);
  sub_2627C(v5);
  operator delete(v5);
  if ( !v7 )
  {
    return 0;
  }
  VFX_register_driver(v7);
  VFX = VFX_describe_driver();
  a1->a = VFX->scrn_width;
  a1->b = VFX->scrn_height;
  return 0xFFFFFFFF;
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0002C08C) --------------------------------------------------------
void *__fastcall sub_2C08C(int a1, unsigned __int16 a2)
{
  void *v3; // eax
  void *result; // eax

  v3 = operator new[](a2 << 8);
  result = sub_2625C(v3, 1, "GSYSTEM HAZE TABLES");
  *(_DWORD *)(a1 + 0x73B) = result;
  *(_WORD *)(a1 + 0x73F) = a2;
  return result;
}

//----- (0002C0C0) --------------------------------------------------------
int __fastcall sub_2C0C0(int a1, const char *a2, unsigned __int16 a3)
{
  void *v4; // eax
  T_Type1 v6; // [esp+0h] [ebp-128h] BYREF

  if ( a3 >= *(__int16 *)(a1 + 0x73F) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x11F);
  }
  Q_InitFileInfo_sub_1BB78(&v6);
  Q_CfilePreload_sub_1BBFC(&v6, a2, 0x200, 0);
  v4 = sub_1BF1C(&v6, (void *)((a3 << 8) + *(_DWORD *)(a1 + 0x73B)));
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\gsystem.cpp", 0x127);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v6);
  return (v4 == 0) - 1;
}

//----- (0002C158) --------------------------------------------------------
unsigned int __fastcall sub_2C158(P_Type6 a1, const char *aFName, int a3, unsigned __int16 a4)
{
  void *v6; // ecx
  T_Type1 v8; // [esp+0h] [ebp-124h] BYREF
  int v9; // [esp+118h] [ebp-Ch]

  v9 = a3;
  Q_InitFileInfo_sub_1BB78(&v8);
  Q_CfilePreload_sub_1BBFC(&v8, aFName, O_BINARY, 0);
  v6 = sub_1BF1C(&v8, &a1->z3[0x303]);
  if ( !v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x13C);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v8);
  if ( !v6 )
  {
    return 0;
  }
  sub_2C224(a1, v9, a4, (RGB *)&a1->z3[0x303]);
  return 0xFFFFFFFF;
}

//----- (0002C1E0) --------------------------------------------------------
int __fastcall sub_2C1E0(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned int a4)
{
  __int64 v5; // rax
  int v6; // ebx
  int v7; // esi

  v5 = a4;
  while ( SHIDWORD(v5) < a3 )
  {
    v6 = 3 * (HIDWORD(v5) + a2);
    v7 = v5;
    LODWORD(v5) = v5 + 3;
    ++HIDWORD(v5);
    *(_WORD *)(v6 + a1 + 0x433) = *(_WORD *)v7;
    *(_BYTE *)(v6 + a1 + 0x435) = *(_BYTE *)(v7 + 2);
  }
  return v5;
}

//----- (0002C224) --------------------------------------------------------
int __fastcall sub_2C224(P_Type6 a1, unsigned __int16 a2, __int16 a3, RGB *a4)
{
  LONG i; // esi
  int result; // eax
  RGB *v7; // [esp-2h] [ebp-10h]
  __int16 v8; // [esp+2h] [ebp-Ch]

  v8 = a2 + a3;
  VFX_wait_vblank_leading();
  for ( i = a2; ; ++i )
  {
    result = v8;
    if ( i >= v8 )
    {
      break;
    }
    v7 = a4++;
    VFX_DAC_write(i, v7);
  }
  return result;
}

//----- (0002C2B0) --------------------------------------------------------
int __fastcall sub_2C2B0(int a1, unsigned __int16 a2, __int16 a3, int a4)
{
  int v4; // edi
  LONG i; // esi
  int result; // eax
  RGB *v7; // [esp-2h] [ebp-10h]
  __int16 v8; // [esp+2h] [ebp-Ch]

  v4 = a4;
  if ( !a4 )
  {
    v4 = a1 + 0x433;
  }
  v8 = a2 + a3;
  VFX_wait_vblank_leading();
  for ( i = a2; ; ++i )
  {
    result = v8;
    if ( i >= v8 )
    {
      break;
    }
    v7 = (RGB *)v4;
    v4 += 3;
    VFX_DAC_read(i, v7);
  }
  return result;
}

//----- (0002C2F8) --------------------------------------------------------
void __fastcall sub_2C2F8(int a1, char *a2)
{
  int i; // ecx
  unsigned int v5; // eax

  for ( i = 0; i < 0x40; ++i )
  {
    sub_2BD04(a1, i, a2);
    v5 = i;
    delay(v5);
  }
}

//----- (0002C418) --------------------------------------------------------
void __fastcall sub_2C418(int a1, int a2, __int16 a3)
{
  __int16 v3; // si
  LONG v4; // [esp-8h] [ebp-1Ch]
  RGB v5; // [esp+0h] [ebp-14h] BYREF
  int v6; // [esp+4h] [ebp-10h]

  v6 = a2;
  v3 = a2;
  VFX_wait_vblank_leading();
  if ( (__int16)(a3 + a2) > (__int16)a2 )
  {
    do
    {
      VFX_DAC_read(v3, &v5);
      if ( v5.r )
      {
        --v5.r;
      }
      if ( v5.r )
      {
        --v5.r;
      }
      if ( v5.g )
      {
        --v5.g;
      }
      if ( v5.g )
      {
        --v5.g;
      }
      if ( v5.b )
      {
        --v5.b;
      }
      if ( v5.b )
      {
        --v5.b;
      }
      v4 = v3++;
      VFX_DAC_write(v4, &v5);
    }
    while ( v3 < (__int16)(a3 + a2) );
  }
  JUMPOUT(0x2C40E);
}
// 2C433: control flows out of bounds to 2C40E

//----- (0002C4C0) --------------------------------------------------------
void __fastcall sub_2C4C0(int a1, int a2, int a3)
{
  __int16 i; // si
  RGB v5; // [esp+0h] [ebp-1Ch] BYREF
  int v6; // [esp+4h] [ebp-18h]
  int v7; // [esp+8h] [ebp-14h]

  v6 = a2;
  VFX_wait_vblank_leading();
  v7 = a3 + a2;
  for ( i = a2; i < (__int16)v7; ++i )
  {
    VFX_DAC_read(i, &v5);
    if ( v5.r < *(_BYTE *)(a1 + 3 * i + 0x433) )
    {
      ++v5.r;
    }
    if ( v5.r < *(_BYTE *)(a1 + 3 * i + 0x433) )
    {
      ++v5.r;
    }
    if ( v5.g < *(_BYTE *)(a1 + 3 * i + 0x434) )
    {
      ++v5.g;
    }
    if ( v5.g < *(_BYTE *)(a1 + 3 * i + 0x434) )
    {
      ++v5.g;
    }
    if ( v5.b < *(_BYTE *)(a1 + 3 * i + 0x435) )
    {
      ++v5.b;
    }
    if ( v5.b < *(_BYTE *)(a1 + 3 * i + 0x435) )
    {
      ++v5.b;
    }
    VFX_DAC_write(i, &v5);
  }
}

//----- (0002C5E4) --------------------------------------------------------
__int64 __fastcall sub_2C5E4(int a1, char a2)
{
  _BYTE *v3; // ebx
  char v4; // dh
  _BYTE *v5; // eax
  char v6; // dl

  if ( !a2 )
  {
    sub_2C2B0(a1, 0, 0x100, a1 + 0x133);
  }
  v3 = (_BYTE *)(a1 + 0x433);
  v4 = 0x40 - a2;
  v5 = (_BYTE *)(a1 + 0x133);
  do
  {
    v6 = *v5 - *v3;
    if ( v6 >= 0 )
    {
      if ( (char)(v6 - v4) > 0 )
      {
        --*v5;
      }
    }
    else if ( (char)(v4 + v6) < 0 )
    {
      ++*v5;
    }
    ++v5;
    ++v3;
  }
  while ( v5 != (_BYTE *)(a1 + 0x433) );
  return (unsigned int)sub_2C224((P_Type6)a1, 0, 0x100, (RGB *)(a1 + 0x133));
}

//----- (0002C670) --------------------------------------------------------
void __fastcall sub_2C670(int a1, int a2, int a3, char *a4)
{
  RGB *v4; // edi
  __int16 v5; // si
  char v6[4]; // [esp+0h] [ebp-14h] BYREF
  int v7; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]

  v8 = a2;
  v4 = (RGB *)a4;
  if ( !a4 )
  {
    v4 = (RGB *)v6;
    v6[1] = 0;
    v6[2] = 0;
    v6[0] = 0;
  }
  v5 = v8;
  v7 = a3 + v8;
  VFX_wait_vblank_leading();
  for ( ; v5 < (__int16)v7; ++v5 )
  {
    VFX_DAC_write(v5, v4);
  }
}

//----- (0002C6CC) --------------------------------------------------------
void __fastcall sub_2C6CC(P_Type6 a1)
{
  void *v2; // ebx

  if ( *(_DWORD *)&a1->fname[0xFF] == 0xFFFFFFFF )
  {
    VFX_shutdown_driver();
  }
  v2 = *(void **)a1->z1;
  *(_DWORD *)&a1->fname[0xFF] = 0;
  if ( v2 )
  {
    sub_262CC(v2);
    *(_DWORD *)a1->z1 = 0;
  }
  if ( *(_DWORD *)&a1->z1[0x10] )
  {
    sub_262CC(*(void **)&a1->z1[0x10]);
    *(_DWORD *)&a1->z1[0x10] = 0;
  }
  sub_2627C(*(void **)&a1[1].z1[4]);
  operator delete[](*(void **)&a1[1].z1[4]);
  *(_DWORD *)&a1[1].z1[4] = 0;
  *(_WORD *)&a1[1].z1[8] = 0;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0002C744) --------------------------------------------------------
void __fastcall sub_2C744(P_Type6 a1, int a2, int a3, int a4)
{
  void *v5; // eax
  T_Type1 v6; // [esp-124h] [ebp-128h] BYREF
  int v7; // [esp-4h] [ebp-8h]

  v7 = a4;
  if ( dword_D8628 )
  {
    if ( !a1->c )
    {
      Q_InitFileInfo_sub_1BB78(&v6);
      Q_CfilePreload_sub_1BBFC(&v6, "DATA\\MOUSE.SHP", O_BINARY, 0);
      v5 = sub_1BF1C(&v6, 0);
      a1->c = (int)v5;
      if ( !v5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x2B3);
      }
      *(_DWORD *)a1[1].z1 = 0;
      Q_CloseFileAndDelete_sub_1BBC8(&v6);
    }
    sub_64F39(a1->c, *(_DWORD *)a1[1].z1);
  }
}
// D8628: using guessed type int dword_D8628;

//----- (0002C7D0) --------------------------------------------------------
void __fastcall Q_GSYSTEM_CPP_sub_2C7D0(T_Type6 *a1, int a2, int a3)
{
  int c; // ecx

  c = a3;
  if ( !a3 )
  {
    c = a1->c;
  }
  if ( !c )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x2C7);
  }
  if ( a2 < 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x2C8);
  }
  if ( c )
  {
    sub_64F39(c, a2);
  }
}

//----- (0002C830) --------------------------------------------------------
void __fastcall __spoils<> sub_2C830(P_TypeA2 a1)
{
  a1->b = (int)off_95E20;
  sub_2C8E4(&a1->a);
}
// 95E20: using guessed type int (*off_95E20[5])();

//----- (0002C848) --------------------------------------------------------
int __fastcall sub_2C848(int a1, char a2)
{
  void *v3; // eax
  int v4; // edx
  __int16 i; // ax
  int v6; // edx
  _DWORD *v7; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D7C);
    operator delete[](v3);
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 0x67);
    *(_DWORD *)(a1 + 0xA7) = off_95E20;
    if ( v4 )
    {
      for ( i = 0; i < 0x14; ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * i);
        if ( v6 )
        {
          *(_DWORD *)(v6 + 0x63) = 0;
        }
      }
      sub_262CC(*(void **)(a1 + 0x67));
    }
    v7 = *(_DWORD **)(a1 + 0x63);
    if ( v7 )
    {
      sub_2CA0C(*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * (_DWORD)v7), a1, v7);
    }
    if ( (a2 & 2) != 0 )
    {
      operator delete((void *)a1);
    }
  }
  return a1;
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E20: using guessed type int (*off_95E20[5])();

//----- (0002C8E4) --------------------------------------------------------
void __fastcall __spoils<> sub_2C8E4(P_TypeA1 result)
{
  result->l = 0;
  result->b = 0;
  result->d = 0xFFFF;
  result->e = 0;
  result->f = 0xFFFF;
  result->g = 0;
  result->i = 0;
  result->j = 0;
  result->k = 0;
  result->r = 0xFFFF;
  result->s = 0xFFFF;
  result->t = 0xFFFF;
  result->u = 0;
  result->m = 0;
  result->n = 0;
  result->o = 0;
  result->p = 0;
  result->v = 0;
  result->w = 0;
  result->x = 0;
  result->z = 0;
  result->zz = 0xFFFFFFFF;
}

//----- (0002C978) --------------------------------------------------------
int __fastcall sub_2C978(P_TypeA1 a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0002C990) --------------------------------------------------------
unsigned int __fastcall sub_2C990(int a1, int a2)
{
  void *v3; // eax
  __int16 v4; // ax

  if ( !*(_WORD *)(a1 + 0x6B) )
  {
    if ( *(_DWORD *)(a1 + 0x67) )
    {
      sub_262CC(*(void **)(a1 + 0x67));
    }
    v3 = sub_2628C(0x50u, 1, "CHILD WINDOWS");
    *(_DWORD *)(a1 + 0x67) = v3;
    memset(v3, 0, 0x50u);
  }
  if ( *(__int16 *)(a1 + 0x6B) >= 0x14 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x94);
  }
  v4 = *(_WORD *)(a1 + 0x6B);
  *(_WORD *)(a1 + 0x6B) = v4 + 1;
  *(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v4) = a2;
  return 0xFFFFFFFF;
}

//----- (0002CA0C) --------------------------------------------------------
unsigned int __fastcall sub_2CA0C(int a1, int a2, _DWORD *a3)
{
  unsigned int v3; // esi
  __int16 i; // kr00_2

  v3 = 0;
  if ( *(_DWORD *)(a1 + 0x67) )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      if ( a2 == *a3 )
      {
        *a3 = 0;
        v3 = 0xFFFFFFFF;
        --*(_WORD *)(a1 + 0x6B);
      }
    }
  }
  return v3;
}

//----- (0002CA78) --------------------------------------------------------
_DWORD *__fastcall sub_2CA78(_DWORD *result, __int16 a2, __int16 a3)
{
  int v3; // edi
  int v4; // ebp
  int v5; // esi

  v3 = result[3];
  v4 = result[5];
  v5 = a2 + result[4];
  result[2] += a2;
  result[4] = v5;
  result[3] = a3 + v3;
  result[5] = a3 + v4;
  return result;
}

//----- (0002CD24) --------------------------------------------------------
void __fastcall sub_2CD24(unsigned int a1, int a2)
{
  int v2; // eax
  __int16 v3; // ax
  int v4; // [esp-18h] [ebp-1Ch]
  int v5; // [esp-14h] [ebp-18h]
  int v6; // [esp-Ch] [ebp-10h]

  if ( *(_DWORD *)(a1 + 0x39) )
  {
    if ( (*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(a1 + 0x41) || a2 == 3)
      && *(_DWORD *)(a1 + 0x3D)
      && a2 != 2 )
    {
      (*(void (__fastcall **)(unsigned int, int))(*(_DWORD *)(a1 + 0xA7) + 0x10))(a1, a2);
    }
    else
    {
      if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
      {
        if ( *(_WORD *)(a1 + 0xA1) )
        {
          sub_2D0F4(a1, 0);
        }
        else
        {
          sub_5E9D0((P_Type5)(a1 + 4), 0xF2);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
          v3 = 0;
          if ( *(__int16 *)(a1 + 0x5B) == 0xFFFFFFFF )
          {
            v3 = 2;
          }
          if ( *(__int16 *)(a1 + 0x5D) == 0xFFFFFFFF )
          {
            LOBYTE(v3) = v3 | 1;
          }
          sub_2B8A8(
            (int)&V_Type3_stru_10AE70.z1[0x3046],
            *(__int16 *)(a1 + 0x5B),
            *(__int16 *)(a1 + 0x5D),
            (const char *)(a1 + 0x20),
            v3,
            0xFFFFFFFF,
            0xFF,
            0);
          if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
          {
            sub_5C001(
              (int **)(a1 + 4),
              0,
              0,
              *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
              0,
              0,
              (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
            sub_5C001(
              (int **)(a1 + 4),
              0,
              0,
              0,
              *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
              0,
              (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
            v5 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
            sub_5C001(
              (int **)(a1 + 4),
              *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
              v5,
              0,
              v5,
              0,
              (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
            v4 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
            sub_5C001(
              (int **)(a1 + 4),
              v4,
              *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
              v4,
              0,
              0,
              (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
          }
        }
      }
      else
      {
        v6 = *(__int16 *)(a1 + 0x1E);
        v2 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a1 + 0x18));
        sub_5CB3C((P_Type5)(a1 + 4), v2, v6, 0, 0);
      }
      sub_55274(
        &V_Type3_stru_10AE70,
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 0xC),
        *(_DWORD *)(a1 + 0x10),
        *(_DWORD *)(a1 + 0x14));
    }
    if ( *(_WORD *)(a1 + 0x6B) )
    {
      sub_2D218((_DWORD *)a1);
    }
  }
}

//----- (0002CF28) --------------------------------------------------------
void __fastcall sub_2CF28(unsigned int a1)
{
  T_Type5 *v1; // esi
  int v2; // eax
  __int16 v3; // ax
  int v4; // [esp-18h] [ebp-1Ch]
  int v5; // [esp-14h] [ebp-18h]
  int v6; // [esp-Ch] [ebp-10h]

  v1 = (T_Type5 *)(a1 + 4);
  if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
  {
    if ( *(_WORD *)(a1 + 0xA1) )
    {
      sub_2D0F4(a1, 1);
    }
    else
    {
      sub_5E9D0((P_Type5)(a1 + 4), 0x96);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
      v3 = 0;
      if ( *(__int16 *)(a1 + 0x5B) == 0xFFFFFFFF )
      {
        v3 = 2;
      }
      if ( *(__int16 *)(a1 + 0x5D) == 0xFFFFFFFF )
      {
        LOBYTE(v3) = v3 | 1;
      }
      sub_2B8A8(
        (int)&V_Type3_stru_10AE70.z1[0x3046],
        *(__int16 *)(a1 + 0x5B),
        *(__int16 *)(a1 + 0x5D),
        (const char *)(a1 + 0x20),
        v3,
        0xFFFFFFFF,
        0xFF,
        0);
      if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
      {
        sub_5C001(
          (int **)(a1 + 4),
          0,
          0,
          *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
          0,
          0,
          (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
        sub_5C001(
          (int **)(a1 + 4),
          0,
          0,
          0,
          *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
          0,
          (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
        v5 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
        sub_5C001(
          (int **)(a1 + 4),
          *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
          v5,
          0,
          v5,
          0,
          (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
        v4 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
        sub_5C001(
          (int **)(a1 + 4),
          v4,
          *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
          v4,
          0,
          0,
          (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
      }
    }
  }
  else
  {
    sub_5D007(*(const void **)&V_Type3_stru_10AE70.z1[0x3012]);
    v6 = *(__int16 *)(a1 + 0x1E);
    v2 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    sub_5D026(v1, v2, v6, 0, 0);
  }
  sub_55274(
    &V_Type3_stru_10AE70,
    *(_DWORD *)(a1 + 8),
    *(_DWORD *)(a1 + 0xC),
    *(_DWORD *)(a1 + 0x10),
    *(_DWORD *)(a1 + 0x14));
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002D0F4) --------------------------------------------------------
unsigned int __fastcall sub_2D0F4(unsigned int a1, int a2)
{
  char v2; // al
  T_Type5 *v3; // esi
  unsigned int result; // eax
  unsigned int i; // ebp
  char *v6; // eax
  int v7; // ebx
  int v8; // edx
  int v9; // eax
  __int16 v10; // [esp-10h] [ebp-30h]
  int v11; // [esp-Ch] [ebp-2Ch]
  int v12; // [esp-8h] [ebp-28h]
  int v13; // [esp-4h] [ebp-24h]
  int v15; // [esp+8h] [ebp-18h]

  v2 = 0xF2;
  if ( a2 )
  {
    v2 = 0x96;
  }
  v3 = (T_Type5 *)(a1 + 4);
  sub_5E9D0((P_Type5)(a1 + 4), v2);
  result = a1;
  v15 = 0;
  for ( i = a1 + 0x6D; (__int16)v15 < *(__int16 *)(a1 + 0xA1); ++v15 )
  {
    if ( !i )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x1CE);
    }
    if ( *(_BYTE *)i )
    {
      if ( *(_BYTE *)i == 1 )
      {
        v13 = *(__int16 *)(i + 0xB);
        v12 = *(__int16 *)(i + 9);
        v11 = *(_DWORD *)(i + 5);
        v9 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(i + 1));
        result = sub_5CB3C(v3, v9, v11, v12, v13);
      }
      else
      {
        result = 0;
        Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x1DF);
      }
    }
    else
    {
      v6 = sub_2D3D0(*(_DWORD *)(i + 1));
      v7 = *(__int16 *)(i + 0xB);
      v8 = *(int *)(i + 7) >> 0x10;
      v10 = *(_WORD *)(i + 5);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v3->a;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
      result = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v8, v7, v6, v10, 0xF3, 0xFF, 0);
    }
    i += 0xD;
  }
  return result;
}

//----- (0002D218) --------------------------------------------------------
void __fastcall sub_2D218(_DWORD *a1)
{
  __int16 i; // kr00_2
  _DWORD *v2; // ecx

  if ( *(_DWORD *)((char *)a1 + 0x67) )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      v2 = (_DWORD *)*a1;
      if ( *a1 )
      {
        a1 = (_DWORD *)*a1;
        if ( *(_DWORD *)((char *)v2 + 0x39) == 0xFFFFFFFF )
        {
          (*(void (__fastcall **)(_DWORD *, _DWORD))(*(_DWORD *)((char *)v2 + 0xA7) + 0xC))(a1, 0);
        }
      }
    }
  }
  JUMPOUT(0x2D210);
}
// 2D222: control flows out of bounds to 2D210

//----- (0002D258) --------------------------------------------------------
int __fastcall sub_2D258(int result, __int16 a2)
{
  int v2; // edi
  __int16 i; // si
  int v4; // ebx

  v2 = result;
  if ( *(_DWORD *)(result + 0x67) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= 0x14 )
      {
        break;
      }
      v4 = *(_DWORD *)(4 * i + *(_DWORD *)(v2 + 0x67));
      if ( v4 && (*(_DWORD *)(v4 + 0x35) || a2 == 1) )
      {
        (*(void (**)(void))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 0x67) + 4 * i) + 0xA7) + 8))();
      }
    }
  }
  return result;
}

//----- (0002D2CC) --------------------------------------------------------
int __fastcall sub_2D2CC(int a1, int a2, int a3, int a4)
{
  FILE *v4; // ecx
  int i; // ebx
  char v7[56]; // [esp+0h] [ebp-40h] BYREF
  int v8; // [esp+38h] [ebp-8h]

  v8 = a4;
  v4 = sub_1BB10("gwshare.txt", 0);
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x214);
  }
  for ( i = 0; i != 0x2D; word_FFE9E[i] = sub_1ADAC((int)&unk_12FC20, v7) )
  {
    fscanf(v4, "%s", v7);
    ++i;
  }
  return fclose(v4);
}
// FFE9E: using guessed type __int16 word_FFE9E[];
// 2D2CC: using guessed type char var_40[56];

//----- (0002D334) --------------------------------------------------------
int __fastcall sub_2D334(const char *a1)
{
  const char *v1; // esi
  unsigned int v2; // kr04_4
  char *v3; // edi
  char v4; // al
  char v5; // al
  int result; // eax

  v1 = a1;
  if ( !a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x226);
  }
  v2 = strlen(a1) + 1;
  if ( (int)(v2 - 1 + SHIWORD(dword_100302)) >= 0x400 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x229);
  }
  v3 = (char *)&unk_FFF04 + SHIWORD(dword_100302);
  do
  {
    v4 = *v1;
    *v3 = *v1;
    if ( !v4 )
    {
      break;
    }
    v5 = v1[1];
    v1 += 2;
    v3[1] = v5;
    v3 += 2;
  }
  while ( v5 );
  result = SHIWORD(dword_100302);
  HIWORD(dword_100302) += v2;
  return result;
}
// 100302: using guessed type int dword_100302;

//----- (0002D3D0) --------------------------------------------------------
char *__fastcall sub_2D3D0(int a1)
{
  if ( a1 >= SHIWORD(dword_100302) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x237);
  }
  return (char *)&unk_FFF04 + a1;
}
// 100302: using guessed type int dword_100302;

//----- (0002D400) --------------------------------------------------------
unsigned int __fastcall sub_2D400(int a1, int a2)
{
  unsigned int result; // eax
  __int16 v4; // cx

  if ( *(__int16 *)(a1 + 0xA1) < 4 )
  {
    v4 = *(_WORD *)(a1 + 0xA1);
    *(_WORD *)(a1 + 0xA1) = v4 + 1;
    result = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0xD * v4 + 0x6D) = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 0xD * v4 + 0x71) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 0xD * v4 + 0x75) = *(_DWORD *)(a2 + 8);
    *(_BYTE *)(a1 + 0xD * v4 + 0x79) = *(_BYTE *)(a2 + 0xC);
  }
  else
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x241);
    return 0;
  }
  return result;
}

//----- (0002D464) --------------------------------------------------------
void __fastcall __spoils<> sub_2D464(P_TypeA4 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95E08;
  sub_2D4C4(a1);
}
// 95E08: using guessed type int (*off_95E08[5])();

//----- (0002D480) --------------------------------------------------------
int __fastcall sub_2D480(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D68);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95E08;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E08: using guessed type int (*off_95E08[5])();

//----- (0002D4C4) --------------------------------------------------------
void __fastcall __spoils<> sub_2D4C4(P_TypeA4 result)
{
  result->b = 0;
}

//----- (0002D4D0) --------------------------------------------------------
unsigned int __fastcall sub_2D4D0(_DWORD *a1, __int16 a2, int a3, int a4)
{
  if ( (unsigned __int16)a2 < 4u || (unsigned __int16)a2 > 5u || a3 < a1[2] || a3 > a1[4] || a4 < a1[3] || a4 > a1[5] )
  {
    return sub_2F424((int)a1, a2, a3, a4);
  }
  *(_DWORD *)((char *)a1 + 0xAB) = ~*(_DWORD *)((char *)a1 + 0xAB);
  (*(void (__fastcall **)(_DWORD *, _DWORD))(*(_DWORD *)((char *)a1 + 0xA7) + 0x10))(a1, 0);
  return sub_2F424((int)a1, a2, a3, a4);
}

//----- (0002D528) --------------------------------------------------------
void __fastcall sub_2D528(int a1, int a2)
{
  T_Type5 *v2; // esi
  int v3; // eax
  int v4; // eax
  char v5; // al
  int v6; // [esp-18h] [ebp-1Ch]
  int v7; // [esp-14h] [ebp-18h]
  int v8; // [esp-Ch] [ebp-10h]
  int v9; // [esp-Ch] [ebp-10h]
  const void *v10; // [esp-4h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 0x39) )
  {
    if ( (*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(a1 + 0x41) || a2 == 3)
      && *(_DWORD *)(a1 + 0x3D)
      && a2 != 2 )
    {
      (*(void (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0x10))(a1, a2);
    }
    else
    {
      if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
      {
        v5 = 0xF2;
        if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
        {
          v5 = 0x50;
        }
        sub_5E9D0((P_Type5)(a1 + 4), v5);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
        if ( *(__int16 *)(a1 + 0x5B) == 0xFFFFFFFF && *(__int16 *)(a1 + 0x5D) == 0xFFFFFFFF )
        {
          sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, (const char *)(a1 + 0x20), 3, 0xFFFFFFFF, 0xFF, 0);
        }
        else
        {
          sub_2B8A8(
            (int)&V_Type3_stru_10AE70.z1[0x3046],
            *(__int16 *)(a1 + 0x5B),
            *(__int16 *)(a1 + 0x5D),
            (const char *)(a1 + 0x20),
            0,
            0xFFFFFFFF,
            0xFF,
            0);
        }
        if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
        {
          sub_5C001(
            (int **)(a1 + 4),
            0,
            0,
            *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
            0,
            0,
            (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
          sub_5C001(
            (int **)(a1 + 4),
            0,
            0,
            0,
            *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
            0,
            (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
          v7 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
          sub_5C001(
            (int **)(a1 + 4),
            *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
            v7,
            0,
            v7,
            0,
            (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
          v6 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
          sub_5C001(
            (int **)(a1 + 4),
            v6,
            *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
            v6,
            0,
            0,
            (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
        }
      }
      else
      {
        v2 = (T_Type5 *)(a1 + 4);
        if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
        {
          v10 = *(const void **)&V_Type3_stru_10AE70.z1[0x3012];
          *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0x50;
          sub_5D007(v10);
          v8 = *(__int16 *)(a1 + 0x1E);
          v3 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
          sub_5D026(v2, v3, v8, 0, 0);
          *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0x96;
        }
        else
        {
          v9 = *(__int16 *)(a1 + 0x1E);
          v4 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
          sub_5CB3C(v2, v4, v9, 0, 0);
        }
      }
      sub_55274(
        &V_Type3_stru_10AE70,
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 0xC),
        *(_DWORD *)(a1 + 0x10),
        *(_DWORD *)(a1 + 0x14));
    }
    if ( *(_WORD *)(a1 + 0x6B) )
    {
      sub_2D218((_DWORD *)a1);
    }
  }
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002D79C) --------------------------------------------------------
void __fastcall sub_2D79C(int a1)
{
  T_Type5 *v1; // esi
  int v2; // eax
  int v3; // eax
  char v4; // al
  int v5; // [esp-18h] [ebp-20h]
  int v6; // [esp-14h] [ebp-1Ch]
  int v7; // [esp-Ch] [ebp-14h]
  int v8; // [esp-Ch] [ebp-14h]
  const void *v9; // [esp-4h] [ebp-Ch]
  int **v10; // [esp+0h] [ebp-8h]

  if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
  {
    v4 = 0x96;
    if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
    {
      v4 = 0xCA;
    }
    v10 = (int **)(a1 + 4);
    sub_5E9D0((P_Type5)(a1 + 4), v4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, (const char *)(a1 + 0x20), 3, 0xFFFFFFFF, 0xFF, 0);
    if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
    {
      sub_5C001(
        v10,
        0,
        0,
        *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
        0,
        0,
        (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
      sub_5C001(
        v10,
        0,
        0,
        0,
        *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
        0,
        (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
      v6 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
      sub_5C001(
        v10,
        *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
        v6,
        0,
        v6,
        0,
        (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
      v5 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
      sub_5C001(
        v10,
        v5,
        *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
        v5,
        0,
        0,
        (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
    }
  }
  else
  {
    v1 = (T_Type5 *)(a1 + 4);
    if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
    {
      v9 = *(const void **)&V_Type3_stru_10AE70.z1[0x3012];
      *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0xCA;
      sub_5D007(v9);
      v7 = *(__int16 *)(a1 + 0x1E);
      v2 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
      sub_5D026(v1, v2, v7, 0, 0);
      *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0x96;
    }
    else
    {
      sub_5D007(*(const void **)&V_Type3_stru_10AE70.z1[0x3012]);
      v8 = *(__int16 *)(a1 + 0x1E);
      v3 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
      sub_5D026(v1, v3, v8, 0, 0);
    }
  }
  sub_55274(
    &V_Type3_stru_10AE70,
    *(_DWORD *)(a1 + 8),
    *(_DWORD *)(a1 + 0xC),
    *(_DWORD *)(a1 + 0x10),
    *(_DWORD *)(a1 + 0x14));
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002D99C) --------------------------------------------------------
int __fastcall sub_2D99C(int a1, unsigned int count, int a3)
{
  void *v5; // edx

  v5 = (void *)(a1 + 0xAB);
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, v5, 4u);
  }
  else
  {
    return sub_1C098(count, (int)v5, 4u);
  }
}

//----- (0002D9C4) --------------------------------------------------------
int __fastcall sub_2D9C4(int a1)
{
  sub_2C830((P_TypeA2)a1);
  *(_DWORD *)(a1 + 0xA7) = off_95DF0;
  *(_DWORD *)(a1 + 0xAB) = 0;
  *(_WORD *)(a1 + 0xAF) = 0;
  *(_WORD *)(a1 + 0xB1) = 0xFFFF;
  sub_2DA60(a1);
  return a1;
}
// 95DF0: using guessed type int (*off_95DF0[5])();

//----- (0002D9FC) --------------------------------------------------------
int __fastcall sub_2D9FC(int a1, char a2)
{
  void *v4; // eax
  void *v6; // edx
  void *v7; // eax
  void *v8; // ebx

  if ( (a2 & 4) != 0 )
  {
    v4 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D54);
    operator delete[](v4);
    return a1;
  }
  else
  {
    v6 = *(void **)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xA7) = off_95DF0;
    if ( v6 )
    {
      sub_262CC(v6);
      *(_DWORD *)(a1 + 0xAB) = 0;
    }
    v7 = (void *)sub_2C848(a1, 1);
    v8 = v7;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v7);
    }
    return (int)v8;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DF0: using guessed type int (*off_95DF0[5])();

//----- (0002DA60) --------------------------------------------------------
int __fastcall sub_2DA60(int result)
{
  *(_WORD *)(result + 0x59) = 7;
  return result;
}

//----- (0002DA68) --------------------------------------------------------
int __fastcall sub_2DA68(T_TypeA1 *a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0002DA80) --------------------------------------------------------
void *__fastcall sub_2DA80(int a1, __int16 a2)
{
  void *result; // eax

  if ( a2 <= 0 )
  {
    return 0;
  }
  result = sub_262B0(a2, 0xEu, 1, "CONTROLS");
  *(_DWORD *)(a1 + 0xAB) = result;
  if ( result )
  {
    result = (void *)0xFFFFFFFF;
    *(_WORD *)(a1 + 0xAF) = a2;
  }
  return result;
}

//----- (0002DAC8) --------------------------------------------------------
unsigned int __fastcall sub_2DAC8(int a1, __int16 a2, __int16 a3, int a4)
{
  int v6; // eax
  int i; // edx
  int v8; // eax
  int v9; // edi

  v6 = 0;
  for ( i = 0; v6 < *(__int16 *)(a1 + 0xAF) && a2 != *(_WORD *)(i + *(_DWORD *)(a1 + 0xAB)); i += 0xE )
  {
    ++v6;
  }
  if ( v6 >= *(__int16 *)(a1 + 0xAF) )
  {
    return 0;
  }
  v8 = 0xE * v6;
  if ( a4 )
  {
    v9 = v8 + *(_DWORD *)(a1 + 0xAB);
    qmemcpy((void *)v9, (const void *)a4, 0xCu);
    qmemcpy((void *)(v9 + 0xC), (const void *)(a4 + 0xC), 2u);
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + v8 + 0xA) = a3;
  }
  return 0xFFFFFFFF;
}

//----- (0002DB54) --------------------------------------------------------
int __fastcall sub_2DB54(int result, __int16 a2, __int16 a3)
{
  int v4; // edi
  int v5; // ebp
  int v6; // ecx
  int v7; // ebx
  __int16 v8; // dx
  int v9; // edx

  v4 = *(_DWORD *)(result + 0xC);
  v5 = *(_DWORD *)(result + 0x14);
  v6 = a2 + *(_DWORD *)(result + 0x10);
  *(_DWORD *)(result + 8) += a2;
  *(_DWORD *)(result + 0x10) = v6;
  v7 = 0;
  *(_DWORD *)(result + 0xC) = a3 + v4;
  v8 = *(_WORD *)(result + 0xAF);
  *(_DWORD *)(result + 0x14) = a3 + v5;
  if ( v8 > 0 )
  {
    do
    {
      v9 = 0xE * (__int16)v7;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 2) += a2;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 4) += a2;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 6) += a3;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 8) += a3;
      ++v7;
    }
    while ( (__int16)v7 < *(__int16 *)(result + 0xAF) );
  }
  return result;
}

//----- (0002DBE4) --------------------------------------------------------
unsigned int __fastcall sub_2DBE4(int a1, int a2, int a3)
{
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // eax

  v4 = a2;
  v5 = *(__int16 *)(a1 + 0xB1);
  if ( v5 != 0xFFFFFFFF )
  {
    v6 = 0xE * v5 + *(_DWORD *)(a1 + 0xAB);
    if ( a2 <= *(__int16 *)(v6 + 4)
      && a2 >= *(int *)v6 >> 0x10
      && a3 <= *(__int16 *)(v6 + 8)
      && a3 >= *(__int16 *)(v6 + 6) )
    {
      LOWORD(a2) = *(_WORD *)(a1 + 0xB1);
      return a2;
    }
  }
  v7 = 0;
  if ( *(__int16 *)(a1 + 0xAF) <= 0 )
  {
    return 0xFFFFFFFF;
  }
  while ( 1 )
  {
    v8 = *(_DWORD *)(a1 + 0xAB) + 0xE * (__int16)v7;
    if ( v4 <= *(__int16 *)(v8 + 4)
      && v4 >= *(int *)v8 >> 0x10
      && a3 <= *(__int16 *)(v8 + 8)
      && a3 >= *(__int16 *)(v8 + 6) )
    {
      break;
    }
    if ( (__int16)++v7 >= *(__int16 *)(a1 + 0xAF) )
    {
      return 0xFFFFFFFF;
    }
  }
  return v7;
}

//----- (0002DCA0) --------------------------------------------------------
int __fastcall sub_2DCA0(int result, __int16 a2)
{
  int v2; // ecx
  int v4; // edx

  v2 = result;
  if ( a2 != *(_WORD *)(result + 0xB1) )
  {
    if ( a2 >= *(__int16 *)(result + 0xAF) )
    {
      result = 0;
      Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x396);
    }
    v4 = *(__int16 *)(v2 + 0xB1);
    if ( v4 != 0xFFFFFFFF )
    {
      result = 7 * v4;
      *(_BYTE *)(*(_DWORD *)(v2 + 0xAB) + 0xE * v4 + 0xA) &= ~2u;
    }
    if ( a2 != 0xFFFFFFFF )
    {
      result = *(_DWORD *)(v2 + 0xAB) + 0xE * a2;
      if ( (*(_WORD *)(result + 0xA) & 1) != 0 )
      {
        *(_BYTE *)(result + 0xA) |= 2u;
      }
    }
    *(_WORD *)(v2 + 0xB1) = a2;
  }
  return result;
}

//----- (0002DD70) --------------------------------------------------------
int __fastcall sub_2DD70(int a1)
{
  int result; // eax

  for ( result = 0; (__int16)result < SHIWORD(dword_A3CF2); ++result )
  {
    *(_WORD *)(0xE * (__int16)result + *(_DWORD *)(a1 + 0xAB) + 0xC) = 5
                                                                     * (unsigned __int8)byte_A2F74[0x1EE
                                                                                                 * (__int16)result]
                                                                     + 0x14;
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;

//----- (0002DDB8) --------------------------------------------------------
unsigned int __fastcall sub_2DDB8(int a1, __int16 a2)
{
  int v2; // eax

  if ( a2 >= *(__int16 *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x3CD);
  }
  if ( a2 == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x3CE);
  }
  v2 = 0xE * a2 + *(_DWORD *)(a1 + 0xAB);
  if ( (*(_WORD *)(v2 + 0xA) & 1) == 0 )
  {
    return 0;
  }
  if ( (*(_WORD *)(v2 + 0xA) & 4) != 0 )
  {
    *(_BYTE *)(v2 + 0xA) &= ~4u;
  }
  else
  {
    *(_BYTE *)(v2 + 0xA) |= 4u;
  }
  return 0xFFFFFFFF;
}

//----- (0002DE68) --------------------------------------------------------
unsigned int __fastcall sub_2DE68(int a1, __int16 a2, int a3, int a4)
{
  unsigned int result; // eax
  __int16 v6; // ax
  __int16 v7; // bx
  int v8; // edx
  int v9; // edi
  unsigned int v10; // ebx
  __int16 i; // [esp+6h] [ebp-Ch]

  switch ( a2 )
  {
    case 1:
      sub_2DD70(a1);
      sub_2F424(a1, a2, a3, a4);
      goto LABEL_3;
    case 4:
    case 5:
      if ( a3 < *(_DWORD *)(a1 + 8)
        || a3 > *(_DWORD *)(a1 + 0x10)
        || a4 < *(_DWORD *)(a1 + 0xC)
        || a4 > *(_DWORD *)(a1 + 0x14) )
      {
LABEL_3:
        result = 0;
      }
      else
      {
        v7 = sub_2DBE4(a1, a3, a4);
        if ( v7 != 0xFFFFFFFF )
        {
          v8 = *(__int16 *)(a1 + 0x59);
          if ( v8 != 0xFFFFFFFF )
          {
            sub_4FB90((int)&unk_10914C, v8);
          }
          v9 = v7;
          sub_2DCA0(a1, v7);
          v10 = sub_2DDB8(a1, v7);
          (*(void (__fastcall **)(int, _DWORD, unsigned int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0, v10);
          if ( v10 == 0xFFFFFFFF )
          {
            if ( *(_DWORD *)(a1 + 0x63) )
            {
              sub_56D30(
                (int)&V_Type3_stru_10AE70,
                *(_DWORD *)(a1 + 0x63),
                *(__int16 *)(a1 + 0x45),
                *(__int16 *)(*(_DWORD *)(a1 + 0xAB) + 0xE * v9),
                0);
            }
          }
        }
        result = 0xFFFFFFFF;
      }
      break;
    case 6:
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      result = 0xFFFFFFFF;
      break;
    case 7:
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
      result = 0xFFFFFFFF;
      break;
    case 8:
      v6 = sub_2DBE4(a1, a3, a4);
      if ( v6 != *(_WORD *)(a1 + 0xB1) )
      {
        sub_2DCA0(a1, v6);
        (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
      }
      result = 0xFFFFFFFF;
      break;
    case 9:
      if ( a3 == 0xFFFFFFFF )
      {
        for ( i = 0; i < *(__int16 *)(a1 + 0xAF); ++i )
        {
          sub_2DAC8(a1, 1 << i, a4, 0);
        }
      }
      else
      {
        sub_2DAC8(a1, a3, a4, 0);
      }
      result = 0xFFFFFFFF;
      break;
    default:
      result = sub_2F424(a1, a2, a3, a4);
      break;
  }
  return result;
}

//----- (0002E084) --------------------------------------------------------
void __usercall sub_2E084(int a1@<eax>, __int16 a2@<si>)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // [esp-Ch] [ebp-18h]
  int v7; // [esp-Ch] [ebp-18h]
  int v8; // [esp-8h] [ebp-14h]
  int v9; // [esp-4h] [ebp-10h]
  __int16 i; // [esp+8h] [ebp-4h]
  __int16 savedregs_4; // [esp+10h] [ebp+4h]

  v6 = *(__int16 *)(a1 + 0x1E);
  v3 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  sub_5CB3C((P_Type5)(a1 + 4), v3, v6, 0, 0);
  for ( i = 0; i < *(__int16 *)(a1 + 0xAF); ++i )
  {
    v4 = 0xE * savedregs_4 + *(_DWORD *)(a1 + 0xAB);
    switch ( *(_WORD *)(v4 + 0xA) )
    {
      case 0:
        a2 = 4;
        break;
      case 1:
        a2 = 0;
        break;
      case 3:
        a2 = 1;
        break;
      case 5:
        a2 = 2;
        break;
      case 7:
        a2 = 3;
        break;
      default:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x48A);
        break;
    }
    v9 = *(__int16 *)(v4 + 6) - *(_DWORD *)(a1 + 0xC);
    v8 = (*(int *)v4 >> 0x10) - *(_DWORD *)(a1 + 8);
    v7 = *(__int16 *)(v4 + 0xC) + a2;
    v5 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    sub_5CB3C((P_Type5)(a1 + 4), v5, v7, v8, v9);
  }
  sub_55274(
    &V_Type3_stru_10AE70,
    *(_DWORD *)(a1 + 8),
    *(_DWORD *)(a1 + 0xC),
    *(_DWORD *)(a1 + 0x10),
    *(_DWORD *)(a1 + 0x14));
}
// 2E0DC: variable 'savedregs_4' is possibly undefined
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002E1B4) --------------------------------------------------------
int __fastcall sub_2E1B4(int a1, unsigned int count, int a3)
{
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, *(void **)(a1 + 0xAB), 0xE * *(__int16 *)(a1 + 0xAF));
  }
  else
  {
    return sub_1C098(count, *(_DWORD *)(a1 + 0xAB), 0xE * *(__int16 *)(a1 + 0xAF));
  }
}

//----- (0002E248) --------------------------------------------------------
T_TypeA2 *__fastcall sub_2E248(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95DD8;
  sub_2E2B8((int)a1);
  return a1;
}
// 95DD8: using guessed type int (*off_95DD8[5])();

//----- (0002E264) --------------------------------------------------------
int __fastcall sub_2E264(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D40);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95DD8;
    sub_2ED4C(a1);
    sub_2F2B4(a1);
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DD8: using guessed type int (*off_95DD8[5])();

//----- (0002E2B8) --------------------------------------------------------
int __fastcall sub_2E2B8(int a1)
{
  __int16 v2; // ax

  sub_2C8E4((P_TypeA1)a1);
  *(_DWORD *)(a1 + 0xAB) = 0;
  *(_DWORD *)(a1 + 0xAF) = 0;
  *(_DWORD *)(a1 + 0xB3) = 0;
  *(_DWORD *)(a1 + 0xB7) = 0;
  *(_DWORD *)(a1 + 0xBB) = 0;
  *(_BYTE *)(a1 + 0xC4) = 0x31;
  *(_BYTE *)(a1 + 0xC5) = 0xF2;
  *(_BYTE *)(a1 + 0xC6) = 0;
  memset((void *)(a1 + 0xC7), 0, 0x800u);
  *(_WORD *)(a1 + 0x8C7) = 0;
  v2 = sub_2B594((int *)&V_Type3_stru_10AE70.z1[0x3046]);
  *(_WORD *)(a1 + 0x8CB) = 0;
  *(_WORD *)(a1 + 0x8CD) = 0;
  *(_WORD *)(a1 + 0x8CF) = 0xFFFF;
  *(_BYTE *)(a1 + 0x8E5) = 0;
  *(_DWORD *)(a1 + 0x8E6) = 0;
  *(_DWORD *)(a1 + 0x8EA) = 0;
  *(_DWORD *)(a1 + 0x8EE) = 0;
  *(_DWORD *)(a1 + 0x8F2) = 0;
  *(_WORD *)(a1 + 0x8C9) = v2 + 3;
  *(_DWORD *)(a1 + 0x8F6) = 0;
  sub_2F1C8(a1, (int)sub_2E208);
  *(_WORD *)(a1 + 0x18) = word_FFEE8;
  return sub_2E9CC(a1, 1);
}
// 2E208: using guessed type int sub_2E208();
// FFEE8: using guessed type __int16 word_FFEE8;

//----- (0002E3BC) --------------------------------------------------------
int __fastcall sub_2E3BC(T_TypeA1 *a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0002E3D4) --------------------------------------------------------
unsigned int __fastcall sub_2E3D4(int a1, __int16 a2, signed int a3, signed int a4)
{
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  __int16 v10; // ax
  int v11; // eax
  int v12; // edx
  unsigned __int16 v13; // dx
  int v14; // ebx

  if ( (unsigned __int16)a2 < 8u )
  {
    if ( (unsigned __int16)a2 < 4u )
    {
      if ( a2 == 1 )
      {
        sub_2E9CC(a1, *(_BYTE *)(a1 + 0xC3));
        return sub_2F424(a1, 1, a3, a4);
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 > 5u )
    {
      if ( (unsigned __int16)a2 <= 6u )
      {
        sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        *(_WORD *)(a1 + 0x8CF) = 0xFFFF;
        v7 = *(_DWORD *)(a1 + 0xA7);
        *(_BYTE *)(a1 + 0x8E5) = 0;
        (*(void (__fastcall **)(int, _DWORD))(v7 + 0xC))(a1, 0);
      }
      else
      {
        sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
        sub_2EDC8(a1, dword_D8648, dword_D864C);
      }
      return 0xFFFFFFFF;
    }
LABEL_11:
    if ( a3 < *(_DWORD *)(a1 + 8)
      || a3 > *(_DWORD *)(a1 + 0x10)
      || a4 < *(_DWORD *)(a1 + 0xC)
      || a4 > *(_DWORD *)(a1 + 0x14) )
    {
      return 0;
    }
    if ( a2 == 0xC && *(_BYTE *)(a1 + 0x4F) != 0x30 )
    {
      return sub_2F424(a1, 0xC, a3, a4);
    }
    sub_2F090(a1, a3, a4, a2);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)a2 <= 8u )
  {
    sub_2EDC8(a1, a3, a4);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)a2 < 0x191u )
  {
    if ( a2 != 0xC )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    goto LABEL_11;
  }
  if ( (unsigned __int16)a2 <= 0x191u )
  {
    v8 = sub_56528((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2);
    if ( v8 != 0xFFFF )
    {
      v9 = 2 * v8 / 3 - 1;
      if ( v9 < 0 )
      {
        v9 = 0;
      }
      sub_56564((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2, v9);
    }
    v10 = *(_WORD *)(a1 + 0x8CD);
    if ( v10 )
    {
      *(_WORD *)(a1 + 0x8CD) = v10 - 1;
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  else
  {
    if ( (unsigned __int16)a2 > 0x192u )
    {
      if ( a2 == 0x193 )
      {
        sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x193);
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        return 0xFFFFFFFF;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    v11 = sub_56528((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2);
    if ( v11 != 0xFFFF )
    {
      v12 = 2 * v11 / 3 - 1;
      if ( v12 < 0 )
      {
        v12 = 0;
      }
      sub_56564((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2, v12);
    }
    v13 = *(_WORD *)(a1 + 0x8CD);
    if ( v13 < *(unsigned __int16 *)(a1 + 0x8C7)
             - (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / *(unsigned __int16 *)(a1 + 0x8C9) )
    {
      v14 = *(_DWORD *)(a1 + 0xA7);
      *(_WORD *)(a1 + 0x8CD) = v13 + 1;
      (*(void (__fastcall **)(int, _DWORD))(v14 + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
}
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;

//----- (0002E6C0) --------------------------------------------------------
void __fastcall sub_2E6C0(int a1)
{
  int v2; // edi
  __int16 v3; // di
  unsigned int v4; // ebp
  unsigned __int16 v5; // ax
  int v6; // ecx
  _DWORD *v7; // ebx
  int v8[2]; // [esp+0h] [ebp-30h] BYREF
  int v9; // [esp+8h] [ebp-28h]
  int v10; // [esp+Ch] [ebp-24h]
  int v11; // [esp+10h] [ebp-20h]
  int v12; // [esp+14h] [ebp-1Ch]
  int v13; // [esp+18h] [ebp-18h]

  sub_5E9D0((P_Type5)(a1 + 4), *(_BYTE *)(a1 + 0xC5));
  v12 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
  v2 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  sub_5C001(
    (int **)(a1 + 4),
    0,
    0,
    v12,
    0,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*(unsigned __int8 *)(a1 + 0xC4));
  sub_5C001(
    (int **)(a1 + 4),
    0,
    0,
    0,
    v2,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*(unsigned __int8 *)(a1 + 0xC4));
  sub_5C001(
    (int **)(a1 + 4),
    v12,
    v2,
    v12,
    0,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*(unsigned __int8 *)(a1 + 0xC4));
  sub_5C001(
    (int **)(a1 + 4),
    v12,
    v2,
    0,
    v2,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*(unsigned __int8 *)(a1 + 0xC4));
  if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
  {
    sub_2E868(a1, 0);
  }
  v8[1] = *(_DWORD *)(a1 + 8) + 1;
  v9 = *(_DWORD *)(a1 + 0xC) + 1;
  v8[0] = *(_DWORD *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 0x10) - 1;
  if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
  {
    v10 -= *(_DWORD *)(a1 + 0xBF);
  }
  v3 = *(_WORD *)(a1 + 0x8CD);
  v4 = 0;
  v13 = a1 + 0xC7;
  while ( v3 < (int)*(unsigned __int16 *)(a1 + 0x8C7) && !v4 )
  {
    v7 = (_DWORD *)(8 * v3 + v13);
    if ( *(_DWORD *)(a1 + 0x8F6) )
    {
      v5 = (*(int (__fastcall **)(_DWORD, _DWORD))(a1 + 0x8F6))(*v7, v7[1]);
    }
    else
    {
      v5 = *(_WORD *)(a1 + 0x8C9);
    }
    v11 = v9 + v5 - 1;
    v6 = *(_DWORD *)(a1 + 0x14);
    if ( v11 >= v6 )
    {
      v4 = 0xFFFFFFFF;
      v11 = v6 - 1;
    }
    (*(void (__fastcall **)(int *, _DWORD, _DWORD, int))(a1 + 0x8FA))(
      v8,
      *v7,
      v7[1],
      (v3++ != *(_WORD *)(a1 + 0x8CF)) - 1);
    v9 = v11 + 1;
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
}

//----- (0002E868) --------------------------------------------------------
void __fastcall sub_2E868(int a1, int a2)
{
  int v3; // edi
  int v4; // edx
  int v5; // ebx
  int v6; // edi
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // [esp-Ch] [ebp-34h]
  int v11; // [esp-Ch] [ebp-34h]
  int v12; // [esp-8h] [ebp-30h]
  char v13; // [esp-4h] [ebp-2Ch]
  int v14; // [esp-4h] [ebp-2Ch]
  T_Type5 v15; // [esp+0h] [ebp-28h] BYREF
  int v16; // [esp+14h] [ebp-14h]
  P_Type5 v17; // [esp+18h] [ebp-10h]
  int v18; // [esp+1Ch] [ebp-Ch]
  int v19; // [esp+20h] [ebp-8h]
  int v20; // [esp+24h] [ebp-4h]

  v18 = a2;
  v3 = *(_DWORD *)(a1 + 0x10);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 0xBF);
  v20 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  v6 = v3 - v4 - v5;
  sub_5C001(
    (int **)(a1 + 4),
    v6,
    0,
    v6,
    v20,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*(unsigned __int8 *)(a1 + 0xC4));
  v7 = *(_DWORD *)(a1 + 0xC) + (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / 2;
  v15.a = *(P_Type6 *)(a1 + 4);
  v15.rect.x1 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 0xBF) + 1;
  v15.rect.x2 = *(_DWORD *)(a1 + 0x10) - 1;
  v15.rect.y1 = *(_DWORD *)(a1 + 0xC) + 1;
  v15.rect.y2 = *(_DWORD *)(a1 + 0x14) - 1;
  v13 = *(_BYTE *)(a1 + 0xC6);
  v19 = v7;
  sub_5E9D0(&v15, v13);
  if ( *(unsigned __int8 *)(a1 + 0x8E5) > 1u )
  {
    if ( *(_BYTE *)(a1 + 0x8E5) == 2 )
    {
      v15.rect.y2 = v19;
    }
    else
    {
      v15.rect.y1 = v19;
    }
    sub_5E9D0(&v15, 0x96);
  }
  v16 = v6 + 2;
  v10 = *(__int16 *)(a1 + 0x1E);
  v8 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  v17 = (P_Type5)(a1 + 4);
  sub_5CB3C((P_Type5)(a1 + 4), v8, v10, v6 + 2, 2);
  v14 = v20 - *(_DWORD *)(a1 + 0xBF) + 2;
  v12 = v16;
  v11 = *(__int16 *)(a1 + 0x1E) + 1;
  v9 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  sub_5CB3C(v17, v9, v11, v12, v14);
  if ( v18 == 0xFFFFFFFF )
  {
    sub_55274(
      &V_Type3_stru_10AE70,
      v6 + *(_DWORD *)(a1 + 8),
      *(_DWORD *)(a1 + 0xC),
      *(_DWORD *)(a1 + 0x10),
      *(_DWORD *)(a1 + 0x14));
  }
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002E9CC) --------------------------------------------------------
int __fastcall sub_2E9CC(int a1, char a2)
{
  int v3; // eax
  int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // ecx
  int v11; // [esp-4h] [ebp-10h]

  if ( a2 == 1 )
  {
    *(_WORD *)(a1 + 0x1E) = 0;
  }
  else
  {
    *(_WORD *)(a1 + 0x1E) = 2;
  }
  v3 = *(__int16 *)(a1 + 0x1E);
  *(_BYTE *)(a1 + 0xC3) = a2;
  v11 = v3;
  v4 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  LOWORD(v5) = sub_610E8(v4, v11);
  *(_DWORD *)(a1 + 0xBF) = v5;
  *(_DWORD *)(a1 + 0x8D1) = *(_DWORD *)(a1 + 4);
  v6 = HIWORD(v5);
  v7 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 0xBF) = v6;
  *(_DWORD *)(a1 + 0x8D5) = v7 + 1;
  v8 = *(_DWORD *)(a1 + 0x10);
  *(_DWORD *)(a1 + 0xBF) = v6 + 3;
  result = v8 - 1;
  v10 = *(_DWORD *)(a1 + 0xB3);
  *(_DWORD *)(a1 + 0x8DD) = result;
  if ( v10 == 0xFFFFFFFF )
  {
    result = *(_DWORD *)(a1 + 0xBF);
    *(_DWORD *)(a1 + 0x8DD) -= result;
  }
  return result;
}
// 2EA0A: variable 'v5' is possibly undefined

//----- (0002EA8C) --------------------------------------------------------
int __fastcall sub_2EA8C(int a1, const char *a2, __int16 a3, int a4)
{
  __int16 v6; // di
  int v7; // edx
  int v8; // eax
  int v9; // edi
  size_t v10; // kr04_4
  void *v11; // eax
  int v12; // ecx
  char *v14; // edi
  char v15; // al
  char v16; // al
  int v17; // eax
  const char *v19; // [esp+4h] [ebp-10h]

  v6 = a3;
  if ( *(unsigned __int16 *)(a1 + 0x8C7) >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x62A);
  }
  if ( a3 == 0xFFFFFFFF )
  {
    v6 = *(_WORD *)(a1 + 0x8C9);
  }
  *(_WORD *)(a1 + 0x8CB) += v6;
  v7 = *(unsigned __int16 *)(a1 + 0x8CB);
  if ( (unsigned __int16)v7 > *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) - 1 )
  {
    if ( *(_DWORD *)(a1 + 0xB7) == 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0x14) = *(_DWORD *)(a1 + 0xC) + v7 + 2;
    }
    else if ( !*(_DWORD *)(a1 + 0xB3) )
    {
      v8 = *(_DWORD *)(a1 + 0xBF);
      v9 = *(_DWORD *)(a1 + 0x8DD);
      *(_DWORD *)(a1 + 0xB3) = 0xFFFFFFFF;
      *(_DWORD *)(a1 + 0x8DD) = v9 - v8;
    }
  }
  if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
  {
    v10 = strlen(a2) + 1;
    if ( *(_DWORD *)(a1 + 0x8E6) )
    {
      v12 = *(_DWORD *)(a1 + 0x8EE);
      if ( *(_DWORD *)(a1 + 0x8F2) - v12 < v10 )
      {
        Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x653);
        return 0xFFFFFFFF;
      }
      v19 = (const char *)(*(_DWORD *)(a1 + 0x8EA) + v12);
      *(_DWORD *)(a1 + 0x8EE) += v10;
    }
    else
    {
      v11 = operator new[](v10);
      v19 = (const char *)sub_2625C(v11, 1, "LISTBOX STRING");
      if ( !v19 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x648);
      }
    }
    v14 = (char *)v19;
    do
    {
      v15 = *a2;
      *v14 = *a2;
      if ( !v15 )
      {
        break;
      }
      v16 = a2[1];
      a2 += 2;
      v14[1] = v16;
      v14 += 2;
    }
    while ( v16 );
    a2 = v19;
  }
  *(_DWORD *)(a1 + 8 * *(unsigned __int16 *)(a1 + 0x8C7) + 0xC7) = a2;
  *(_DWORD *)(a1 + 8 * *(unsigned __int16 *)(a1 + 0x8C7) + 0xCB) = 0;
  HIWORD(v17) = HIWORD(a4);
  ++*(_WORD *)(a1 + 0x8C7);
  if ( a4 == 0xFFFFFFFF )
  {
    v17 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
  }
  LOWORD(v17) = *(_WORD *)(a1 + 0x8C7);
  return v17 - 1;
}

//----- (0002EC50) --------------------------------------------------------
unsigned int __fastcall sub_2EC50(int a1, unsigned __int16 a2, int a3)
{
  int v3; // esi
  unsigned int result; // eax

  if ( a2 >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x66B);
  }
  v3 = 8 * a2 + a1;
  if ( !*(_DWORD *)(v3 + 0xC7) )
  {
    return 0;
  }
  result = 0xFFFFFFFF;
  *(_DWORD *)(v3 + 0xCB) = a3;
  return result;
}

//----- (0002ECA4) --------------------------------------------------------
int __fastcall sub_2ECA4(int a1, unsigned __int16 a2)
{
  if ( a2 >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x679);
  }
  return *(_DWORD *)(a1 + 8 * a2 + 0xCB);
}

//----- (0002ECDC) --------------------------------------------------------
int __fastcall sub_2ECDC(int result, unsigned __int16 a2)
{
  if ( *(unsigned __int16 *)(result + 0x8CB) > *(_DWORD *)(result + 0x14) - *(_DWORD *)(result + 0xC) - 1
    && a2 < *(_WORD *)(result + 0x8C7) )
  {
    *(_WORD *)(result + 0x8CF) = 0xFFFF;
    *(_WORD *)(result + 0x8CD) = a2;
  }
  return result;
}

//----- (0002ED14) --------------------------------------------------------
int __fastcall sub_2ED14(int a1, unsigned __int16 a2)
{
  if ( a2 >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x68D);
  }
  return *(_DWORD *)(a1 + 8 * a2 + 0xC7);
}

//----- (0002ED4C) --------------------------------------------------------
int __fastcall sub_2ED4C(int a1)
{
  int v1; // ecx
  int i; // edx
  int v3; // eax
  int result; // eax
  int v5; // edx

  v1 = a1;
  *(_DWORD *)(a1 + 0x8EE) = 0;
  for ( i = 0; i < *(unsigned __int16 *)(v1 + 0x8C7); ++i )
  {
    if ( *(_DWORD *)(a1 + 0xC7) )
    {
      *(_DWORD *)(a1 + 0xC7) = 0;
    }
    a1 += 8;
  }
  *(_WORD *)(v1 + 0x8C7) = 0;
  *(_WORD *)(v1 + 0x8CB) = 0;
  *(_WORD *)(v1 + 0x8CF) = 0xFFFF;
  v3 = *(_DWORD *)(v1 + 0x10);
  *(_WORD *)(v1 + 0x8CD) = 0;
  result = v3 - 1;
  v5 = *(_DWORD *)(v1 + 0xAF);
  *(_DWORD *)(v1 + 0x8DD) = result;
  if ( !v5 )
  {
    *(_DWORD *)(v1 + 0xB3) = 0;
  }
  return result;
}

//----- (0002EDC8) --------------------------------------------------------
void __fastcall sub_2EDC8(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5; // eax
  unsigned __int16 v6; // di
  unsigned __int16 v7; // dx
  unsigned int v8; // ebx
  unsigned __int16 v9; // cx
  int v10; // eax
  int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // eax
  char v14; // al
  int v15; // edx
  int v16; // eax
  char v17; // [esp-4h] [ebp-18h]

  if ( *(__int16 *)(a1 + 0x8CF) != 0xFFFFFFFF )
  {
    if ( a3 >= *(_DWORD *)(a1 + 0x8D9) && a3 <= *(_DWORD *)(a1 + 0x8E1) && a2 <= *(_DWORD *)(a1 + 0x8DD) )
    {
      if ( *(_DWORD *)(a1 + 0xBB) == 0xFFFFFFFF )
      {
        sub_5E9D0((P_Type5)(a1 + 0x8D1), *(_BYTE *)(a1 + 0xC5));
        (*(void (__fastcall **)(int, _DWORD, _DWORD, unsigned int))(a1 + 0x8FA))(
          a1 + 0x8D1,
          *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xC7),
          *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xCB),
          0xFFFFFFFF);
        sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 0x8D1));
      }
      return;
    }
    sub_5E9D0((P_Type5)(a1 + 0x8D1), *(_BYTE *)(a1 + 0xC5));
    (*(void (__fastcall **)(int, _DWORD, _DWORD, _DWORD))(a1 + 0x8FA))(
      a1 + 0x8D1,
      *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xC7),
      *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xCB),
      0);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 0x8D1));
    *(_WORD *)(a1 + 0x8CF) = 0xFFFF;
  }
  v5 = *(_DWORD *)(a1 + 0x10);
  if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
  {
    v5 -= *(_DWORD *)(a1 + 0xBF);
  }
  if ( v5 <= a2 )
  {
    if ( *(_DWORD *)(a1 + 0xB3) != 0xFFFFFFFF )
    {
      return;
    }
    v12 = *(_DWORD *)(a1 + 0xC) + (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / 2;
    v13 = *(unsigned __int8 *)(a1 + 0x8E5);
    if ( v13 > 1 )
    {
      if ( a3 <= v12 )
      {
        if ( v13 == 2 )
        {
          return;
        }
        v15 = *(_DWORD *)(a1 + 0xB3);
        v16 = a1;
        *(_BYTE *)(a1 + 0x8E5) = 2;
      }
      else
      {
        if ( v13 == 3 )
        {
          return;
        }
        v15 = *(_DWORD *)(a1 + 0xB3);
        v16 = a1;
        *(_BYTE *)(a1 + 0x8E5) = 3;
      }
    }
    else
    {
      v14 = (a3 > v12) + 2;
      v15 = *(_DWORD *)(a1 + 0xB3);
      *(_BYTE *)(a1 + 0x8E5) = v14;
      v16 = a1;
    }
    sub_2E868(v16, v15);
  }
  else
  {
    if ( *(unsigned __int8 *)(a1 + 0x8E5) > 1u )
    {
      *(_BYTE *)(a1 + 0x8E5) = 1;
      sub_2E868(a1, 0xFFFFFFFF);
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x193);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
    }
    v6 = *(_WORD *)(a1 + 0x8CD);
    v7 = *(_WORD *)(a1 + 0x8C7);
    v8 = 0;
    *(_DWORD *)(a1 + 0x8D9) = *(_DWORD *)(a1 + 0xC) + 1;
    if ( v6 < v7 )
    {
      while ( !v8 )
      {
        v10 = *(_DWORD *)(a1 + 0x8F6);
        if ( v10 )
        {
          v10 = (*(unsigned __int16 (__fastcall **)(_DWORD, _DWORD))(a1 + 0x8F6))(
                  *(_DWORD *)(a1 + 8 * v6 + 0xC7),
                  *(_DWORD *)(a1 + 8 * v6 + 0xCB));
        }
        else
        {
          LOWORD(v10) = *(_WORD *)(a1 + 0x8C9);
        }
        *(_DWORD *)(a1 + 0x8E1) = *(_DWORD *)(a1 + 0x8D9) + v10 - 1;
        v11 = *(_DWORD *)(a1 + 0x14);
        if ( *(_DWORD *)(a1 + 0x8E1) >= v11 )
        {
          v8 = 0xFFFFFFFF;
          *(_DWORD *)(a1 + 0x8E1) = v11 - 1;
        }
        if ( a3 >= *(_DWORD *)(a1 + 0x8D9) && a3 <= *(_DWORD *)(a1 + 0x8E1) )
        {
          v17 = *(_BYTE *)(a1 + 0xC5);
          *(_WORD *)(a1 + 0x8CF) = v6;
          sub_5E9D0((P_Type5)(a1 + 0x8D1), v17);
          (*(void (__fastcall **)(int, _DWORD, _DWORD, unsigned int))(a1 + 0x8FA))(
            a1 + 0x8D1,
            *(_DWORD *)(a1 + 8 * v6 + 0xC7),
            *(_DWORD *)(a1 + 8 * v6 + 0xCB),
            0xFFFFFFFF);
          sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 0x8D1));
          return;
        }
        ++v6;
        v9 = *(_WORD *)(a1 + 0x8C7);
        *(_DWORD *)(a1 + 0x8D9) = *(_DWORD *)(a1 + 0x8E1) + 1;
        if ( v6 >= v9 )
        {
          return;
        }
      }
    }
  }
}

//----- (0002F090) --------------------------------------------------------
void __fastcall sub_2F090(int a1, unsigned int a2, unsigned int a3, __int16 a4)
{
  int v6; // ecx
  int v7; // edx
  int v8; // ebx

  if ( *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 0xBF) <= a2 )
  {
    if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
    {
      if ( *(_DWORD *)(a1 + 0xC) + (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / 2 <= a3 )
      {
        (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 8))(a1, 0x192, 0, 0);
        sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x192, 0, 0, 0x1E);
      }
      else
      {
        (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 8))(a1, 0x191, 0, 0);
        sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x191, 0, 0, 0x1E);
      }
      v8 = 1;
      if ( a4 == 5 )
      {
        v8 = 2;
      }
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), v8, 0x193, 0, 0);
    }
  }
  else
  {
    v6 = *(__int16 *)(a1 + 0x8CF);
    if ( v6 != 0xFFFFFFFF )
    {
      if ( dword_12FC14 )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x63), 0x1C02, v6, a4);
      }
      else
      {
        v7 = *(__int16 *)(a1 + 0x59);
        if ( v7 != 0xFFFFFFFF )
        {
          sub_4FB90((int)&unk_10914C, v7);
        }
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x63), 0x1C01, *(__int16 *)(a1 + 0x8CF), a4);
      }
      sub_2EDC8(a1, a2, a3);
    }
  }
}
// 12FC14: using guessed type int dword_12FC14;

//----- (0002F1C8) --------------------------------------------------------
int __fastcall sub_2F1C8(int result, int a2)
{
  *(_DWORD *)(result + 0x8FA) = a2;
  return result;
}

//----- (0002F1D8) --------------------------------------------------------
int __fastcall sub_2F1D8(int result, int a2)
{
  *(_DWORD *)(result + 0x8FE) = a2;
  return result;
}

//----- (0002F1E0) --------------------------------------------------------
void __fastcall sub_2F1E0(int a1)
{
  if ( !*(_DWORD *)(a1 + 0x8FE) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x7AB);
  }
  qsort(
    (void *)(a1 + 0xC7),
    *(unsigned __int16 *)(a1 + 0x8C7),
    8u,
    *(int (__fastcall **)(const void *, const void *))(a1 + 0x8FE));
}

//----- (0002F228) --------------------------------------------------------
int __fastcall sub_2F228(int a1, size_t a2, int a3)
{
  int result; // eax

  sub_2ED4C(a1);
  if ( *(_DWORD *)(a1 + 0x8EA) )
  {
    sub_262CC(*(void **)(a1 + 0x8EA));
    *(_DWORD *)(a1 + 0x8EA) = 0;
  }
  if ( a3 )
  {
    *(_DWORD *)(a1 + 0x8EA) = a3;
  }
  else
  {
    *(_DWORD *)(a1 + 0x8EA) = sub_2628C(a2, 1, "LISTBOX MEMPOOL");
  }
  if ( *(_DWORD *)(a1 + 0x8EA) )
  {
    *(_DWORD *)(a1 + 0x8E6) = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x8EE) = 0;
    result = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x8F2) = a2;
  }
  else
  {
    *(_DWORD *)(a1 + 0x8E6) = 0;
    *(_DWORD *)(a1 + 0x8F2) = 0;
    result = 0;
    *(_DWORD *)(a1 + 0x8EE) = 0;
  }
  return result;
}

//----- (0002F2B4) --------------------------------------------------------
void __fastcall sub_2F2B4(int a1)
{
  if ( *(_DWORD *)(a1 + 0x8EA) )
  {
    sub_262CC(*(void **)(a1 + 0x8EA));
    *(_DWORD *)(a1 + 0x8EA) = 0;
  }
  *(_DWORD *)(a1 + 0x8F2) = 0;
  *(_DWORD *)(a1 + 0x8EE) = 0;
  *(_DWORD *)(a1 + 0x8E6) = 0;
}

//----- (0002F2F4) --------------------------------------------------------
T_TypeA2 *__fastcall sub_2F2F4(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_95DC0;
  return result;
}
// 95DC0: using guessed type int (*off_95DC0[5])();

//----- (0002F30C) --------------------------------------------------------
int __fastcall sub_2F30C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D2C);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95DC0;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DC0: using guessed type int (*off_95DC0[5])();

//----- (0002F354) --------------------------------------------------------
void __fastcall sub_2F354(int a1)
{
  int v2; // eax
  __int16 v3; // si
  int v4; // ecx
  int v5; // ebx
  int v6; // eax
  int v7; // [esp-Ch] [ebp-20h]
  __int16 v8; // [esp-4h] [ebp-18h]
  char s[12]; // [esp+0h] [ebp-14h] BYREF
  int v10; // [esp+Ch] [ebp-8h]
  int a2; // [esp+10h] [ebp-4h]
  void *retaddr; // [esp+28h] [ebp+14h]

  v7 = *(_DWORD *)(a1 + 0xAB) + 0xC;
  v2 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  v10 = a1 + 4;
  sub_5CB3C((P_Type5)(a1 + 4), v2, v7, 0, 0);
  v3 = 0;
  sprintf(s, "%05d", dword_A2F6C[0]);
  a2 = v10;
  while ( v3 < 5 )
  {
    v4 = 0x1F * v3 + 2;
    v8 = (unsigned __int8)byte_104BEA;
    v5 = *(_DWORD *)(a1 + 0xAB) + *((char *)&retaddr + v3) - 0x30;
    v6 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    ++v3;
    sub_53EB8((P_Type5)a2, v6, v5, v4, 0, v8);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)a2);
}
// A2F6C: using guessed type int dword_A2F6C[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 2F354: using guessed type char s[12];

//----- (0002F414) --------------------------------------------------------
int __fastcall sub_2F414(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
}

//----- (0002F420) --------------------------------------------------------
int __fastcall sub_2F420(int a1, __int16 a2, int a3, int a4)
{
  return sub_2F424(a1, a2, a3, a4);
}
// 2F424: using guessed type int __fastcall sub_2F424(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002F424) --------------------------------------------------------
unsigned int __fastcall sub_2F424(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ebp
  __int16 v5; // cx
  int v6; // ebx
  int v7; // edx
  int v10; // [esp+2h] [ebp-10h]

  if ( (unsigned __int16)a2 < 7u )
  {
    if ( (unsigned __int16)a2 < 2u )
    {
      if ( a2 == 1 )
      {
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        v4 = *(_DWORD *)(a1 + 0xA7);
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        (*(void (**)(void))(v4 + 0xC))();
        sub_2D258(a1, 1);
        return 0;
      }
      return 0;
    }
    if ( (unsigned __int16)a2 <= 2u )
    {
      sub_2D258(a1, a2);
      *(_DWORD *)(a1 + 0x39) = 0;
      *(_DWORD *)(a1 + 0x35) = 0;
      if ( *(_DWORD *)(a1 + 0x41) == *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] )
      {
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] = 0xFFFFFFFF;
      }
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      return 0;
    }
    else
    {
      if ( (unsigned __int16)a2 < 4u )
      {
        return 0;
      }
      if ( (unsigned __int16)a2 <= 5u )
      {
        if ( a3 < *(_DWORD *)(a1 + 8)
          || a3 > *(_DWORD *)(a1 + 0x10)
          || a4 < *(_DWORD *)(a1 + 0xC)
          || a4 > *(_DWORD *)(a1 + 0x14) )
        {
          return 0;
        }
        v5 = *(_WORD *)(a1 + 0x45);
        v10 = *(_DWORD *)(a1 + 0x47);
        v6 = *(_DWORD *)(a1 + 0x4B);
        if ( v5 == 0x3E7 )
        {
          v5 = a2;
        }
        if ( v10 == 0x3E7 )
        {
          v10 = a2;
        }
        if ( v6 == 0x3E7 )
        {
          v6 = a2;
        }
        v7 = *(__int16 *)(a1 + 0x59);
        if ( v7 != 0xFFFFFFFF )
        {
          sub_4FB90((int)&unk_10914C, v7);
        }
        if ( *(_DWORD *)(a1 + 0x63) )
        {
          if ( v5 == 0x3E6 )
          {
            sub_56B60((int)&V_Type3_stru_10AE70, v10, v6, 0);
            return 0xFFFFFFFF;
          }
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x63), v5, v10, v6);
        }
        else
        {
          sub_56B60((int)&V_Type3_stru_10AE70, v5, v10, v6);
        }
        return 0xFFFFFFFF;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 0x39) && *(_DWORD *)(a1 + 0x35) && *(_DWORD *)(a1 + 0x3D) )
        {
          (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
        }
        return 0xFFFFFFFF;
      }
    }
  }
  else if ( (unsigned __int16)a2 <= 7u )
  {
    if ( *(_DWORD *)(a1 + 0x39) && *(_DWORD *)(a1 + 0x35) && *(_DWORD *)(a1 + 0x3D) )
    {
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
    }
    return 0xFFFFFFFF;
  }
  else
  {
    if ( (unsigned __int16)a2 >= 0xEu )
    {
      if ( (unsigned __int16)a2 <= 0xEu )
      {
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        return 0;
      }
      if ( (unsigned __int16)a2 <= 0xFu )
      {
        *(_DWORD *)(a1 + 0x35) = 0;
        return 0;
      }
      if ( (unsigned __int16)a2 >= 0xC9u )
      {
        if ( (unsigned __int16)a2 > 0xCAu )
        {
          return 0;
        }
        sub_56B60((int)&V_Type3_stru_10AE70, 6, a2, 0);
        return 0xFFFFFFFF;
      }
      return 0;
    }
    if ( a2 != 0xC )
    {
      return 0;
    }
    if ( a3 < *(_DWORD *)(a1 + 8)
      || a3 > *(_DWORD *)(a1 + 0x10)
      || a4 < *(_DWORD *)(a1 + 0xC)
      || a4 > *(_DWORD *)(a1 + 0x14) )
    {
      return 0;
    }
    if ( *(_BYTE *)(a1 + 0x4F) != 0x30 )
    {
      sub_56B60((int)&V_Type3_stru_10AE70, 5, a1 + 0x4F, 0);
    }
    return 0xFFFFFFFF;
  }
}

//----- (0002F478) --------------------------------------------------------
int __fastcall sub_2F478(int a1, __int16 a2, int a3, int a4)
{
  if ( a2 != 0xD )
  {
    return sub_2F420(a1, a2, a3, a4);
  }
  (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
  return 0;
}

//----- (0002F48C) --------------------------------------------------------
T_TypeA2 *__fastcall sub_2F48C(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95DA8;
  sub_2F4EC((int)a1);
  return a1;
}
// 95DA8: using guessed type int (*off_95DA8[4])();

//----- (0002F4A8) --------------------------------------------------------
int __fastcall sub_2F4A8(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D18);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95DA8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DA8: using guessed type int (*off_95DA8[4])();

//----- (0002F4EC) --------------------------------------------------------
int __fastcall sub_2F4EC(int result)
{
  *(_DWORD *)(result + 0xAB) = 0;
  *(_WORD *)(result + 0xB1) = 0;
  *(_WORD *)(result + 0xAF) = 0;
  *(_WORD *)(result + 0xB3) = 0;
  *(_WORD *)(result + 0xB7) = 0xF2;
  *(_DWORD *)(result + 0xB9) = &V_Type3_stru_10AE70.z1[0x3046];
  *(_DWORD *)(result + 0xBD) = 0xFFFFFFFF;
  *(_WORD *)(result + 0xB5) = (unsigned __int8)byte_96778;
  return result;
}
// 96778: using guessed type char byte_96778;

//----- (0002F540) --------------------------------------------------------
void __fastcall sub_2F540(int a1)
{
  _DWORD *v2; // eax
  const char *v3; // ecx
  int v4; // edx
  int v5; // eax
  int v6; // eax
  int v7; // [esp-18h] [ebp-30h]
  int v8; // [esp-14h] [ebp-2Ch]
  __int16 v9; // [esp-Ch] [ebp-24h]
  int a2; // [esp+0h] [ebp-18h]

  a2 = a1 + 4;
  sub_5E9D0((P_Type5)(a1 + 4), *(_WORD *)(a1 + 0xB7));
  sub_5C001(
    (int **)a2,
    0,
    0,
    *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
    0,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
  sub_5C001(
    (int **)a2,
    0,
    0,
    0,
    *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
  v8 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  sub_5C001(
    (int **)a2,
    *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
    v8,
    0,
    v8,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
  v7 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
  sub_5C001(
    (int **)a2,
    v7,
    *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
    v7,
    0,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
  v2 = *(_DWORD **)(a1 + 0xB9);
  v9 = *(_WORD *)(a1 + 0xB5);
  v3 = *(const char **)(a1 + 0xAB);
  v2[2] = *(_DWORD *)a2;
  v2[3] = *(_DWORD *)(a2 + 4);
  v2[4] = *(_DWORD *)(a2 + 8);
  v2[5] = *(_DWORD *)(a2 + 0xC);
  v2[6] = *(_DWORD *)(a2 + 0x10);
  sub_2B8A8((int)v2, 2, 4, v3, 0, v9, 0xFF, 0);
  v4 = *(__int16 *)(a1 + 0xB3);
  v5 = *(_DWORD *)(a1 + 0xAB);
  LOBYTE(v3) = *(_BYTE *)(v4 + v5);
  *(_BYTE *)(v4 + v5) = 0;
  v6 = sub_2B4F4(*(_DWORD **)(a1 + 0xB9), *(char **)(a1 + 0xAB));
  *(_BYTE *)(*(__int16 *)(a1 + 0xB3) + *(_DWORD *)(a1 + 0xAB)) = (_BYTE)v3;
  sub_5C001(
    (int **)a2,
    v6 + 2,
    3,
    v6 + 2,
    *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) - 3,
    0,
    (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x98);
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)a2);
}

//----- (0002F6B0) --------------------------------------------------------
unsigned int __fastcall sub_2F6B0(int a1, __int16 a2, char a3, unsigned int a4)
{
  int v6; // ecx
  int v8; // ebx
  __int16 v9; // ax
  int v10; // ebx

  if ( a2 != 3 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  v6 = *(_DWORD *)(a1 + 0xBD);
  *(_DWORD *)(a1 + 0xBD) = 0;
  if ( a3 >= 0x30 && a3 <= 0x39 || a3 >= 0x41 && a3 <= 0x5A || a3 >= 0x61 && a3 <= 0x7A || a3 == 0x20 || a3 == 0x2D )
  {
    if ( v6 )
    {
      *(_WORD *)(a1 + 0xB3) = 0;
      *(_WORD *)(a1 + 0xB1) = *(_WORD *)(a1 + 0xB3);
      **(_BYTE **)(a1 + 0xAB) = 0;
    }
    if ( *(_WORD *)(a1 + 0xB1) < *(_WORD *)(a1 + 0xAF)
      && sub_2B4F4(&V_Type3_stru_10AE70.z1[0x3046], *(char **)(a1 + 0xAB)) < 0x5F )
    {
      sub_2F8F8(a1, *(_WORD *)(a1 + 0xB3), a3, a2);
      ++*(_WORD *)(a1 + 0xB3);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  if ( a4 < 0x4B )
  {
    if ( a4 >= 0xE )
    {
      if ( a4 > 0xE )
      {
        if ( a4 == 0x1C )
        {
          sub_56B60((int)&V_Type3_stru_10AE70, 6, 3, 0);
          return 0xFFFFFFFF;
        }
        return sub_2F424(a1, a2, a3, a4);
      }
      if ( *(__int16 *)(a1 + 0xB3) > 0 )
      {
        sub_2F8A4(a1, (__int16)--*(_WORD *)(a1 + 0xB3));
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( a4 <= 0x4B )
  {
    if ( *(__int16 *)(a1 + 0xB3) > 0 )
    {
      v8 = *(_DWORD *)(a1 + 0xA7);
      --*(_WORD *)(a1 + 0xB3);
      (*(void (__fastcall **)(int, _DWORD))(v8 + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  if ( a4 < 0x4D )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( a4 <= 0x4D )
  {
    v9 = *(_WORD *)(a1 + 0xB3);
    if ( v9 < *(__int16 *)(a1 + 0xB1) )
    {
      v10 = *(_DWORD *)(a1 + 0xA7);
      *(_WORD *)(a1 + 0xB3) = v9 + 1;
      (*(void (__fastcall **)(int, _DWORD))(v10 + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  else
  {
    if ( a4 != 0x53 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( *(_WORD *)(a1 + 0xB3) < *(_WORD *)(a1 + 0xB1) )
    {
      sub_2F8A4(a1, *(__int16 *)(a1 + 0xB3));
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
}

//----- (0002F8A4) --------------------------------------------------------
int __fastcall sub_2F8A4(int a1, int a2)
{
  int result; // eax

  if ( (__int16)a2 >= *(__int16 *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x8F2);
  }
  for ( result = a2; (__int16)result < *(__int16 *)(a1 + 0xB1); ++result )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + (__int16)result) = *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + (__int16)result + 1);
  }
  --*(_WORD *)(a1 + 0xB1);
  return result;
}

//----- (0002F8F8) --------------------------------------------------------
char __usercall sub_2F8F8@<al>(int a1@<eax>, __int16 a2@<dx>, char a3@<bl>, int a4@<edi>)
{
  int i; // eax
  _BYTE *v7; // edx
  char result; // al

  if ( a2 > *(__int16 *)(a1 + 0xB1) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x903);
  }
  if ( *(_WORD *)(a1 + 0xB1) >= *(_WORD *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x904);
  }
  LOWORD(a4) = *(_WORD *)(a1 + 0xB1);
  if ( a2 == (_WORD)a4 )
  {
    *(_BYTE *)((__int16)a4 + *(_DWORD *)(a1 + 0xAB)) = a3;
    *(_BYTE *)((__int16)a4 + *(_DWORD *)(a1 + 0xAB) + 1) = 0;
  }
  else
  {
    for ( i = a4; (__int16)i >= a2; v7[1] = *v7 )
    {
      v7 = (_BYTE *)((__int16)i-- + *(_DWORD *)(a1 + 0xAB));
    }
  }
  result = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + a2) = a3;
  ++*(_WORD *)(a1 + 0xB1);
  return result;
}

//----- (0002F9A4) --------------------------------------------------------
int __fastcall sub_2F9A4(int a1, const char *a2, __int16 a3)
{
  int result; // eax
  unsigned int v5; // kr04_4

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x91B);
  }
  *(_DWORD *)(a1 + 0xAB) = a2;
  *(_WORD *)(a1 + 0xAF) = a3;
  result = 0;
  v5 = strlen(a2) + 1;
  *(_WORD *)(a1 + 0xB1) = v5 - 1;
  if ( (__int16)(v5 - 1) > a3 )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x921);
  }
  *(_WORD *)(a1 + 0xB3) = *(_WORD *)(a1 + 0xB1);
  return result;
}

//----- (0002FA18) --------------------------------------------------------
void __fastcall __spoils<> sub_2FA18(P_TypeA3 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95D90;
  sub_2FA78(a1);
}
// 95D90: using guessed type int (*off_95D90[5])();

//----- (0002FA34) --------------------------------------------------------
int __fastcall sub_2FA34(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D04);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95D90;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95D90: using guessed type int (*off_95D90[5])();

//----- (0002FA78) --------------------------------------------------------
void __fastcall __spoils<> sub_2FA78(P_TypeA3 result)
{
  result->c = 0;
  result->d = 3;
  result->e = 0xF3;
}

//----- (0002FA98) --------------------------------------------------------
void __fastcall sub_2FA98(int a1)
{
  int **v2; // esi
  const char *v3; // ecx
  int v4; // [esp-18h] [ebp-2Ch]
  int v5; // [esp-14h] [ebp-28h]
  __int16 v6; // [esp-10h] [ebp-24h]
  __int16 v7; // [esp-Ch] [ebp-20h]
  int v8; // [esp-4h] [ebp-18h]

  v2 = (int **)(a1 + 4);
  sub_5E9D0((P_Type5)(a1 + 4), 0xF2);
  if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
  {
    sub_5C001(
      v2,
      0,
      0,
      *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
      0,
      0,
      (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
    sub_5C001(
      v2,
      0,
      0,
      0,
      *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
      0,
      (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
    v5 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
    sub_5C001(
      v2,
      *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8),
      v5,
      0,
      v5,
      0,
      (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
    v4 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
    sub_5C001(
      v2,
      v4,
      *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC),
      v4,
      0,
      0,
      (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xF3);
  }
  if ( *(_DWORD *)(a1 + 0xAB) )
  {
    v3 = *(const char **)(a1 + 0xAB);
    v8 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8) - 5;
    v7 = *(_WORD *)(a1 + 0xB1);
    v6 = *(_WORD *)(a1 + 0xAF);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, v3, v6, v7, 0xFF, v8);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
}

//----- (0002FBA4) --------------------------------------------------------
void __fastcall sub_2FBA4(int a1, int a2)
{
  int v3; // ecx
  char v4; // al
  int v5; // ebx
  int v6; // eax
  __int16 v7; // [esp-4h] [ebp-14h]

  v3 = *(_DWORD *)(a1 + 0x41);
  v4 = 0xF2;
  if ( *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == v3 && a2 != 2 || a2 == 3 )
  {
    v4 = 0x96;
  }
  sub_5E9D0((P_Type5)(a1 + 4), v4);
  if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x9A0);
  }
  v5 = *(__int16 *)(a1 + 0x1E);
  if ( v5 != 0xFFFFFFFF )
  {
    v7 = (unsigned __int8)byte_104BEA;
    v6 = sub_1B084((unsigned int)&unk_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    sub_53EB8((P_Type5)(a1 + 4), v6, v5, 0, 0, v7);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
}

//----- (0002FC3C) --------------------------------------------------------
int __fastcall sub_2FC3C(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
}

//----- (0002FC50) --------------------------------------------------------
void __fastcall __spoils<> sub_2FC50(P_TypeA2 a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95E54;
}
// 95E54: using guessed type int (*off_95E54[5])();

//----- (0002FC68) --------------------------------------------------------
int __fastcall sub_2FC68(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95E40);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95E54;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E54: using guessed type int (*off_95E54[5])();

//----- (0002FCB0) --------------------------------------------------------
int __fastcall sub_2FCB0(_DWORD *a1, char *a2, char *a3)
{
  char *v4; // edi
  char v6; // al
  char v7; // al
  char *v8; // edi
  char v10; // al
  char v11; // al
  int result; // eax
  int v13; // ebx

  *(_DWORD *)((char *)a1 + 0xDAB) = 0;
  v4 = (char *)a1 + 0xAB;
  *(_DWORD *)((char *)a1 + 0xDA7) = *(_DWORD *)((char *)a1 + 0xDAB);
  do
  {
    v6 = *a2;
    *v4 = *a2;
    if ( !v6 )
    {
      break;
    }
    v7 = a2[1];
    a2 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  v8 = (char *)a1 + 0xC9;
  do
  {
    v10 = *a3;
    *v8 = *a3;
    if ( !v10 )
    {
      break;
    }
    v11 = a3[1];
    a3 += 2;
    v8[1] = v11;
    v8 += 2;
  }
  while ( v11 );
  ((void (__fastcall *)(_DWORD *))loc_2FEB8)(a1);
  result = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
  v13 = 0x98;
  if ( !*(_WORD *)&V_Type3_stru_10AE70.z1[0x4228]
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 1
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 7
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 8
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 0x10
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 0x14 )
  {
    v13 = 0x50;
  }
  a1[2] = v13;
  a1[3] = 0x78;
  a1[4] = v13 + 0x14F;
  a1[5] = 0x177;
  return result;
}

//----- (0002FD68) --------------------------------------------------------
unsigned int __fastcall sub_2FD68(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ebx
  int v6; // edx
  int v7; // ebx

  if ( (unsigned __int16)a2 < 6u )
  {
    if ( (unsigned __int16)a2 < 2u )
    {
      if ( a2 == 1 )
      {
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        v4 = *(_DWORD *)(a1 + 0xA7);
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        (*(void (**)(void))(v4 + 0xC))();
        return 0;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 > 2u && a2 == 5 )
    {
      goto LABEL_9;
    }
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 7u )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 < 0xDu )
  {
    if ( a2 != 0xC )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
LABEL_9:
    sub_56B60((int)&V_Type3_stru_10AE70, 6, 0xCA, 0);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)a2 <= 0xDu || (unsigned __int16)a2 < 0x32u || (unsigned __int16)a2 > 0x32u )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  v6 = *(_DWORD *)(a1 + 0xDA7);
  if ( v6 >= *(_DWORD *)(a1 + 0xDAB) )
  {
    sub_56B60((int)&V_Type3_stru_10AE70, 6, a3, a4);
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 0xA7);
    *(_DWORD *)(a1 + 0xDA7) = v6 + 1;
    (*(void (**)(void))(v7 + 0xC))();
  }
  return 0;
}

//----- (0002FE58) --------------------------------------------------------
void __fastcall Q_HELPWIN_CPP_FgetsLine_sub_2FE58(FILE *fp, char *line)
{
  unsigned int found; // edi
  char first; // ah

  found = 0;
  do
  {
    if ( !fgets(line, 200, fp) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\helpwin.cpp", 0x9E);
    }
    first = *line;
    if ( *line != ' ' && first != '\t' && first != '\n' && first != '\r' && first != '/' && first != '#' )
    {
      found = 0xFFFFFFFF;
    }
  }
  while ( !found );
}

//----- (00030774) --------------------------------------------------------
void __fastcall sub_30774(int a1)
{
  T_Type5 *v1; // esi
  int v2; // eax
  int v3; // eax
  int v4; // edi
  int v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // esi
  int v9; // ebx
  int v10; // ecx
  int v11; // ebp
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  int v14; // esi
  _DWORD *v15; // edi
  _DWORD *v16; // eax
  int v17; // edx
  int v18; // ebx
  int v19; // esi
  char *v20; // ebp
  char v21; // ah
  int v22; // eax
  int v23; // edx
  int v24; // ebx
  int v25; // eax
  const char *v26; // ecx
  int v27; // eax
  int v28; // edx
  int v29; // edi
  __int16 v30; // [esp-Ch] [ebp-A4h]
  int v31; // [esp-8h] [ebp-A0h]
  int v32; // [esp-8h] [ebp-A0h]
  __int16 v33; // [esp-8h] [ebp-A0h]
  int v34; // [esp-4h] [ebp-9Ch]
  int v35[21]; // [esp+0h] [ebp-98h]
  T_Type5 v36; // [esp+54h] [ebp-44h] BYREF
  int v37; // [esp+68h] [ebp-30h]
  int v38; // [esp+6Ch] [ebp-2Ch]
  int v39; // [esp+70h] [ebp-28h]
  int v40; // [esp+74h] [ebp-24h]
  _DWORD *v41; // [esp+78h] [ebp-20h]
  __int16 v42; // [esp+7Ch] [ebp-1Ch]
  __int16 v43; // [esp+80h] [ebp-18h]

  v41 = (_DWORD *)a1;
  v1 = (T_Type5 *)(a1 + 4);
  sub_5E9D0((P_Type5)(a1 + 4), 0xF2);
  v2 = *((unsigned __int16 *)v41 + 0xC);
  if ( (unsigned __int16)v2 != 0xFFFF )
  {
    v35[0] = 0;
    v31 = *((__int16 *)v41 + 0xF);
    v3 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[v2]);
    sub_5CB3C(v1, v3, v31, 0, 0);
  }
  v4 = 0;
  v5 = 0;
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(v41 + 1));
  v6 = 0;
  v7 = 0;
  while ( v6 < *(__int16 *)((char *)v41 + 0x6B) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(v7 + *(_DWORD *)((char *)v41 + 0x67)) + 0x35) == 0xFFFFFFFF )
    {
      ++v5;
      ++v4;
      v35[v5] = v6;
    }
    v7 += 4;
    ++v6;
  }
  v8 = v41[2] + 8;
  v9 = v41[2] + 0x147;
  if ( v4 > 0 )
  {
    v10 = v4;
    v11 = 0;
    v38 = 4 * v4;
    do
    {
      v12 = *(_DWORD **)(*(_DWORD *)((char *)v41 + 0x67) + 4 * v35[v11 / 4u + 1]);
      v13 = v41;
      v12[2] = v8;
      v12[3] = v13[3] + 0xD9;
      v12[5] = v41[3] + 0xF7;
      v14 = (v9 - v8) / v10 + v8;
      v15 = v12 + 1;
      if ( v14 > v9 )
      {
        v14 = v9;
      }
      --v10;
      v11 += 4;
      v15[3] = v14;
      v8 = v14 + 1;
    }
    while ( v11 < v38 );
  }
  v36 = *(T_Type5 *)(v41 + 1);
  v36.rect.x1 = v41[2] + 0xA;
  v36.rect.y1 = v41[3] + 0xA;
  v36.rect.x2 = v41[2] + 0x145;
  v36.rect.y2 = v41[3] + 0xCF;
  v16 = v41;
  v17 = 0;
  v18 = *(_DWORD *)((char *)v41 + 0xDA7);
  v40 = 0;
  if ( v18 > 0 )
  {
    do
    {
      if ( v40 >= *(_DWORD *)((char *)v41 + 0xDA3) )
      {
        break;
      }
      if ( v16[0x32B] == 0xFFFFFFFF )
      {
        ++v17;
      }
      v16 = (_DWORD *)((char *)v16 + 0x1B);
      v19 = *(_DWORD *)((char *)v41 + 0xDA7);
      ++v40;
    }
    while ( v17 < v19 );
  }
  v39 = 0;
  v20 = (char *)v41 + 0x1B * v40 + 0xC95;
  if ( v40 < *(_DWORD *)((char *)v41 + 0xDA3) )
  {
    do
    {
      if ( v39 == 0xFFFFFFFF )
      {
        break;
      }
      v39 = *(_DWORD *)(v20 + 0x17);
      v21 = *v20;
      if ( *v20 )
      {
        if ( v21 == 1 )
        {
          v23 = 0;
          if ( (v20[0xF] & 2) == 0 )
          {
            v23 = v36.rect.x2 - v36.rect.x1 - *(__int16 *)(v20 + 0x13);
          }
          v35[0] = v23;
          v24 = *(_DWORD *)(v20 + 0x13);
          v25 = *(_DWORD *)(v20 + 0x11);
          v26 = *(const char **)(v20 + 5);
          v42 = *(_WORD *)(v20 + 0xF);
          v43 = *(_WORD *)(v20 + 9);
          v37 = v25 >> 0x10;
          v27 = *(_DWORD *)(v20 + 0xB);
          v33 = v43;
          v30 = v42;
          v28 = v37;
          *(T_Type5 *)(v27 + 8) = v36;
          sub_2B8A8(v27, v28, v24 >> 0x10, v26, v30, v33, 0xFF, v35[0]);
        }
        else if ( v21 != 2 )
        {
          Q_AssertLogBreakExit_sub_261A8(0, "..\\helpwin.cpp", 0x245);
        }
      }
      else
      {
        v35[0] = *(__int16 *)(v20 + 0x15);
        v34 = *(__int16 *)(v20 + 0x13);
        v32 = *(unsigned __int16 *)(v20 + 3);
        v22 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[*(unsigned __int16 *)(v20 + 1)]);
        sub_5CB3C(&v36, v22, v32, v34, v35[0]);
      }
      v20 += 0x1B;
      v29 = *(_DWORD *)((char *)v41 + 0xDA3);
      ++v40;
    }
    while ( v40 < v29 );
  }
  sub_2D218(v41);
}
// FFEA0: using guessed type __int16 word_FFEA0[7];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00030A90) --------------------------------------------------------
int __fastcall sub_30A90(T_Type5 *a1, int edx0, int a3, int a4)
{
  int v5; // edx
  int v6; // eax
  char *sub_1CEA8; // eax
  int result; // eax
  int *v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  char *v13; // eax
  int v14; // edx
  int v15; // ebx
  int v16; // ecx
  int v17; // esi
  char *v18; // eax
  int v19; // eax
  int v20; // eax
  unsigned int v21; // eax
  char *v22; // eax
  __int16 v23; // di
  int v24; // ecx
  int v25; // eax
  __int16 v26; // edx^2
  char *v27; // eax
  __int16 v28; // di
  int v29; // ecx
  int v30; // eax
  __int16 v31; // edx^2
  int v32; // eax
  char *v33; // eax
  __int16 v34; // di
  int v35; // ecx
  int v36; // eax
  int v37; // esi
  int v38; // ebx
  int v39; // eax
  int *v40; // edi
  int v41; // ebx
  int v42; // eax
  int v43; // ecx
  int v44; // [esp-20h] [ebp-B0h]
  __int16 v45; // [esp-Ch] [ebp-9Ch]
  __int16 v46; // [esp-Ch] [ebp-9Ch]
  __int16 v47; // [esp-Ch] [ebp-9Ch]
  __int16 v48; // [esp-Ch] [ebp-9Ch]
  __int16 v49; // [esp-Ch] [ebp-9Ch]
  int v50; // [esp-8h] [ebp-98h]
  int v51; // [esp-8h] [ebp-98h]
  int v52; // [esp-8h] [ebp-98h]
  int v53; // [esp-8h] [ebp-98h]
  char v54; // [esp-4h] [ebp-94h]
  int v55; // [esp-4h] [ebp-94h]
  char v56; // [esp-4h] [ebp-94h]
  char v57; // [esp-4h] [ebp-94h]
  char v58; // [esp-4h] [ebp-94h]
  char v59; // [esp-4h] [ebp-94h]
  __int16 v60; // [esp-4h] [ebp-94h]
  char s[52]; // [esp+0h] [ebp-90h] BYREF
  int v62; // [esp+34h] [ebp-5Ch]
  int v63; // [esp+38h] [ebp-58h]
  int v64; // [esp+3Ch] [ebp-54h]
  char *v65; // [esp+40h] [ebp-50h]
  int a2; // [esp+44h] [ebp-4Ch]
  int v67; // [esp+48h] [ebp-48h]
  int v68; // [esp+4Ch] [ebp-44h]
  int v69; // [esp+50h] [ebp-40h]
  int v70; // [esp+54h] [ebp-3Ch]
  int v71; // [esp+58h] [ebp-38h]
  int v72; // [esp+5Ch] [ebp-34h]
  int v73; // [esp+60h] [ebp-30h]
  int v74; // [esp+64h] [ebp-2Ch]
  int v75; // [esp+68h] [ebp-28h]
  int v76; // [esp+6Ch] [ebp-24h]
  int *v77; // [esp+70h] [ebp-20h]
  int v78; // [esp+74h] [ebp-1Ch]
  unsigned int v79; // [esp+78h] [ebp-18h]
  __int16 i; // [esp+7Ch] [ebp-14h]
  int v81; // [esp+80h] [ebp-10h]

  v77 = (int *)edx0;
  v67 = 9;
  if ( a4 && (a3 == 1 || *(_DWORD *)(edx0 + 8) != 0xFFFFFFFF) )
  {
    v67 = 0xF3;
  }
  else
  {
    v5 = v77[2];
    if ( v5 != 0xFFFFFFFF )
    {
      v67 = 4 * v77[v5 + 0xA] + 0x13;
    }
  }
  sprintf(s, "%d.", v77[0x1B]);
  v45 = v67;
  a2 = (__int16)v67;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 5, 5, s, 0, v45, 0xFF, 0);
  HIWORD(v6) = HIWORD(v77);
  if ( v77[2] == 0xFFFFFFFF )
  {
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x10);
    v46 = a2;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
    return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x1E, 5, sub_1CEA8, 0, v46, 0xFF, 0);
  }
  LOWORD(v6) = word_FFEE0;
  v81 = v6;
  v9 = &v77[v77[2]];
  v10 = v9[3];
  v78 = v9[0xA];
  v64 = v10;
  v54 = v78;
  v11 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v81);
  sub_53F40(a1, v11, v10, 0x19, 5, v54);
  v12 = v64;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 5, &byte_1050A4[0x14 * v12], 0, a2, 0xFF, 0);
  v55 = *v77;
  v13 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x11);
  sprintf(s, v13, v55);
  v47 = a2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 0x14, s, 0, v47, 0xFF, 0);
  v14 = ((v77[0x1C] & 0xFE00) >> 9) + 0x50;
  v15 = v77[0x1C] & 0x1F;
  v16 = (v77[0x1C] & 0x1E0) >> 5;
  v69 = (*((_WORD *)v77 + 0x39) & 0xF800) >> 0xB;
  v17 = v69;
  v65 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x12);
  if ( v17 )
  {
    if ( v17 == 0xC )
    {
      v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x13);
    }
    else
    {
      if ( v17 <= 0xC )
      {
        goto LABEL_16;
      }
      v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x13);
      v69 = v17 - 0xC;
    }
    v65 = v18;
    goto LABEL_16;
  }
  v69 = 0xC;
LABEL_16:
  v62 = (*((_WORD *)v77 + 0x39) & 0x7E0) >> 5;
  sprintf(s, "%d/%d/%d", v16, v15, v14);
  v48 = v67;
  v63 = (__int16)v67;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 0x32, s, 0, v48, 0xFF, 0);
  sprintf(s, "%d : %.2d %s", v69, v62, v65);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 0x41, s, 0, v63, 0xFF, 0);
  v44 = v64;
  v19 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
  sub_5D631(
    a1,
    v19,
    v44,
    0x96,
    0x1E,
    (int)byte_D8DA0,
    0,
    (void (__noreturn *)())0x8000,
    (void (__noreturn *)())0x8000,
    0);
  v56 = v78;
  v20 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
  v21 = sub_53F40(a1, v20, 3, 0x96, 0x1E, v56);
  LOWORD(v21) = word_FFEF2;
  v79 = v21;
  v68 = 0xC8;
  v22 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x14);
  v73 = 0x14;
  v49 = v63;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v23 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xC8, 5, v22, 0, v49, 0xFF, 0);
  while ( v23 < v77[0x18] )
  {
    v24 = v68;
    v57 = v78;
    v50 = v73;
    v25 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v79);
    sub_53F40(a1, v25, 5, v24, v50, v57);
    v68 += 8;
    if ( v23 % 9 == 8 )
    {
      v68 = 0xC8;
      v73 += 8;
    }
    ++v23;
  }
  v26 = v67;
  v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x15);
  v74 = 0x118;
  v72 = 0x14;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v28 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x118, 5, v27, 0, v26, 0xFF, 0);
  while ( v28 < v77[0x19] )
  {
    v29 = v74;
    v58 = v78;
    v51 = v72;
    v30 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v79);
    sub_53F40(a1, v30, 6, v29, v51, v58);
    v74 += 8;
    if ( v28 % 9 == 8 )
    {
      v74 = 0x118;
      v72 += 8;
    }
    ++v28;
  }
  v31 = v67;
  v32 = v77[0x1A] >> 2;
  v75 = 0x168;
  v70 = v32;
  v71 = 0x14;
  v33 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x16);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v34 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x168, 5, v33, 0, v31, 0xFF, 0);
  while ( v34 < v70 )
  {
    v59 = v78;
    v52 = v71;
    v35 = v75;
    v36 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v79);
    sub_53F40(a1, v36, 7, v35, v52, v59);
    v75 += 8;
    if ( v34 % 9 == 8 )
    {
      v75 = 0x168;
      v71 += 8;
    }
    ++v34;
  }
  v76 = 5;
  v37 = 0x1CC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v77[1] )
    {
      break;
    }
    if ( i != v77[2] )
    {
      v40 = &v77[i];
      if ( v40[0x11] )
      {
        v60 = *((_WORD *)v40 + 0x14);
        v53 = v76;
        v41 = v40[3];
        v42 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v81);
        sub_53F40(a1, v42, v41, v37, v53, v60);
        v43 = v40[0x11];
        v38 = 0xFFFFFFFF;
        if ( v43 == 3 )
        {
          v38 = 9;
        }
        else if ( v43 == 2 )
        {
          v38 = 8;
        }
        if ( v38 != 0xFFFFFFFF )
        {
          v39 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
          sub_5CB3C(a1, v39, v38, v37, v76);
        }
        v37 += 0x39;
        if ( v37 > 0x258 )
        {
          v37 = 0x1CC;
          v76 += 0x1B;
        }
      }
    }
  }
  return result;
}
// FFEE0: using guessed type __int16 word_FFEE0;
// FFEF2: using guessed type __int16 word_FFEF2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00031158) --------------------------------------------------------
int __fastcall sub_31158(_DWORD *a1, int a2, int a3, int a4)
{
  __int16 v5; // dx
  char s[12]; // [esp+0h] [ebp-20h] BYREF
  int v8; // [esp+Ch] [ebp-14h]
  int v9; // [esp+10h] [ebp-10h]

  v9 = a2;
  v5 = 9;
  if ( a4 )
  {
    v5 = 0xF3;
  }
  sprintf(s, "%d.", *(_DWORD *)(v9 + 0xDC));
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  v8 = v5;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 5, 5, s, 0, v5, 0xFF, 0);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x1E, 5, (const char *)(v9 + 0x14), 0, v8, 0xFF, 0x226);
}

//----- (00031200) --------------------------------------------------------
T_TypeA2 *__fastcall sub_31200(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_95E88;
  sub_2C8E4(&result->a);
  return result;
}
// 95E88: using guessed type int (*off_95E88[5])();

//----- (0003121C) --------------------------------------------------------
int __fastcall sub_3121C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95E74);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95E88;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E88: using guessed type int (*off_95E88[5])();

//----- (00031268) --------------------------------------------------------
unsigned int __fastcall sub_31268(int a1, unsigned __int16 a2, int a3, int a4)
{
  const char *v6; // ecx
  int v7; // eax
  char v8; // bl
  int v9; // edx
  char *v10; // edi
  const char *v11; // esi
  int v12; // ebx
  char v13; // al
  char v14; // al
  const char *v15; // esi
  int v16; // edx
  char *v17; // edi
  int v18; // ecx
  char v19; // al
  char v20; // al
  int v21; // eax
  int v22; // ebx
  int v23; // eax
  int v24; // edx
  int v25; // esi
  char v26; // ah
  int v27; // ebp
  char *v28; // edi
  char *v29; // esi
  char v30; // al
  char v31; // al
  const char *v32; // esi
  unsigned int v33; // kr04_4
  char *v34; // edi
  char v35; // al
  char v36; // al
  char *v37; // edi
  char *v38; // esi
  char v39; // al
  char v40; // al
  const char *v41; // esi
  char *v42; // edi
  char v43; // al
  char v44; // al
  T_Type1 v45; // [esp+0h] [ebp-150h] BYREF
  char s[32]; // [esp+118h] [ebp-38h] BYREF
  int v47; // [esp+138h] [ebp-18h]
  _BYTE v48[6]; // [esp+13Ch] [ebp-14h]

  *(_WORD *)&v48[4] = a2;
  *(_DWORD *)v48 = a3;
  v47 = a4;
  if ( a2 < 3u )
  {
    if ( a2 != 1 )
    {
      return sub_2F424(a1, *(__int16 *)&v48[4], *(int *)v48, v47);
    }
    v6 = "savescr";
    if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 2 )
    {
      *(_BYTE *)(a1 + 0xAF) = 1;
    }
    else if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 4 )
    {
      v6 = "loadscr";
      *(_BYTE *)(a1 + 0xAF) = 0;
    }
    else
    {
      v6 = "tutscr";
      *(_BYTE *)(a1 + 0xAF) = 2;
    }
    v7 = sub_56DA8((int)&V_Type3_stru_10AE70, "LOADLIST", 0);
    v8 = *(_BYTE *)(a1 + 0xAF);
    *(_DWORD *)(a1 + 0xAB) = v7;
    if ( v8 == 2 )
    {
      *(_WORD *)(v7 + 0x8C9) = 0x3C;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_31158);
      sub_317D0(a1);
    }
    else
    {
      *(_WORD *)(v7 + 0x8C9) = 0x55;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_30A90);
      sub_316A8(a1, (int)sub_30A90);
    }
    v9 = *(_DWORD *)&v48[2];
    v10 = (char *)(a1 + 0x4F);
    v11 = v6;
    v12 = *(_DWORD *)v48;
    do
    {
      v13 = *v11;
      *v10 = *v11;
      if ( !v13 )
      {
        break;
      }
      v14 = v11[1];
      v11 += 2;
      v10[1] = v14;
      v10 += 2;
    }
    while ( v14 );
    v15 = v6;
    v16 = v9 >> 0x10;
    v17 = (char *)(*(_DWORD *)(a1 + 0xAB) + 0x4F);
    v18 = v47;
    do
    {
      v19 = *v15;
      *v17 = *v15;
      if ( !v19 )
      {
        break;
      }
      v20 = v15[1];
      v15 += 2;
      v17[1] = v20;
      v17 += 2;
    }
    while ( v20 );
    sub_2F424(a1, v16, v12, v18);
    return 0;
  }
  if ( a2 <= 3u )
  {
    if ( a3 >= 0x31 && a3 <= 0x39 )
    {
      v21 = 9;
      v22 = a3 - 0x30;
      if ( *(_BYTE *)(a1 + 0xAF) == 1 )
      {
        v21 = 0xA;
      }
      if ( v22 < v21 )
      {
        (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 8))();
        return 0xFFFFFFFF;
      }
    }
    return 0;
  }
  if ( a2 != 0x1C01 )
  {
    return sub_2F424(a1, *(__int16 *)&v48[4], *(int *)v48, v47);
  }
  v23 = sub_2ED14(*(_DWORD *)(a1 + 0xAB), *(unsigned __int16 *)v48);
  v24 = *(_DWORD *)(v23 + 0x6C);
  v25 = v23;
  sprintf(s, "%02d.sav", v24);
  Q_InitFileInfo_sub_1BB78(&v45);
  v26 = *(_BYTE *)(a1 + 0xAF);
  if ( v26 == 1 )
  {
    sub_54048(s, 3, a3, a4);
    sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
  }
  else if ( v26 )
  {
    v27 = 0xE0 * a3 + a1 + 0x9C0;
    v28 = s;
    v29 = (char *)v27;
    do
    {
      v30 = *v29;
      *v28 = *v29;
      if ( !v30 )
      {
        break;
      }
      v31 = v29[1];
      v29 += 2;
      v28[1] = v31;
      v28 += 2;
    }
    while ( v31 );
    v32 = ".tsv";
    v33 = strlen(s) + 1;
    v34 = &s[v33 - 1];
    do
    {
      v35 = *v32;
      *v34 = *v32;
      if ( !v35 )
      {
        break;
      }
      v36 = v32[1];
      v32 += 2;
      v34[1] = v36;
      v34 += 2;
    }
    while ( v36 );
    v37 = s;
    sub_53FB0(s, 3, 0, ~v33);
    v38 = (char *)v27;
    sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
    srand(0);
    dword_96BBC = LODWORD(flt_12FC1C);
    flt_12FC1C = 1.0;
    do
    {
      v39 = *v38;
      *v37 = *v38;
      if ( !v39 )
      {
        break;
      }
      v40 = v38[1];
      v38 += 2;
      v37[1] = v40;
      v37 += 2;
    }
    while ( v40 );
    v41 = ".bin";
    v42 = &s[strlen(s)];
    do
    {
      v43 = *v41;
      *v42 = *v41;
      if ( !v43 )
      {
        break;
      }
      v44 = v41[1];
      v41 += 2;
      v42[1] = v44;
      v42 += 2;
    }
    while ( v44 );
    sub_59988(&V_Type3_stru_10AE70, s, 0);
  }
  else if ( *(_DWORD *)(v25 + 8) != 0xFFFFFFFF )
  {
    sub_53FB0(s, v24, 1, a4);
    *(_WORD *)&V_Type3_stru_10AE70.z2[0x148] = 1;
    *(_WORD *)&V_Type3_stru_10AE70.z2[0x126] = 0;
    *(_WORD *)&V_Type3_stru_10AE70.z2[0x146] = 1;
    sub_56B60((int)&V_Type3_stru_10AE70, 1, 1, 0);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v45);
  return 0xFFFFFFFF;
}
// 96BBC: using guessed type int dword_96BBC;
// 12FC1C: using guessed type float flt_12FC1C;
// 31268: using guessed type char s[32];

//----- (0003160C) --------------------------------------------------------
void __fastcall sub_3160C(int a1)
{
  char v2; // ah
  int v3; // edx
  char *v4; // eax
  char *sub_1CEA8; // [esp+0h] [ebp-18h]

  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x17);
  v2 = *(_BYTE *)(a1 + 0xAF);
  v3 = 0x10;
  if ( v2 == 1 )
  {
    v3 = 0x73;
    v4 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x18);
  }
  else
  {
    if ( v2 != 2 )
    {
      goto LABEL_6;
    }
    v4 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x19);
    v3 = 0;
  }
  sub_1CEA8 = v4;
LABEL_6:
  if ( v3 )
  {
    sub_5E9D0((P_Type5)(a1 + 4), v3);
  }
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 4, sub_1CEA8, 3, 0xFFFFFFFF, 0xFF, 0);
  sub_2D218((_DWORD *)a1);
}

//----- (000316A8) --------------------------------------------------------
T_Type1 *__fastcall sub_316A8(int a1, int a2)
{
  int v3; // edi
  int v4; // esi
  unsigned __int16 v5; // dx
  T_Type1 *result; // eax
  T_Type1 handle; // [esp+0h] [ebp-158h] BYREF
  char s[32]; // [esp+118h] [ebp-40h] BYREF
  int v9; // [esp+138h] [ebp-20h]
  int v10; // [esp+13Ch] [ebp-1Ch]

  v10 = a1;
  sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
  v3 = 0;
  Q_InitFileInfo_sub_1BB78(&handle);
  v4 = a1 + 0xB0;
  do
  {
    v9 = v3 + 1;
    sprintf(s, "%02d.sav", v3 + 1);
    if ( access(s, 0) )
    {
      *(_DWORD *)(v4 + 8) = 0xFFFFFFFF;
    }
    else
    {
      Q_CfilePreload_sub_1BBFC(&handle, s, 0x200, 0);
      sub_1BF94(&handle, (void *)v4, 0x74u);
      dos_getftime(handle.fh, (unsigned __int16 *)(v4 + 0x70), (unsigned __int16 *)(v4 + 0x72));
    }
    *(_DWORD *)(v4 + 0x6C) = v9;
    sub_2EA8C(*(_DWORD *)(v10 + 0xAB), (const char *)v4, 0xFFFFFFFF, 0);
    v4 += 0x74;
    v5 = v3++;
    sub_2EC50(*(_DWORD *)(v10 + 0xAB), v5, *(_BYTE *)(v10 + 0xAF) == 1);
  }
  while ( v3 < 0x14 );
  result = &handle;
  Q_CloseFileAndDelete_sub_1BBC8(&handle);
  return result;
}
// 317B7: returning address of temporary local variable '%handle'
// 316A8: using guessed type T_Type1 handle;

//----- (000317D0) --------------------------------------------------------
int __fastcall sub_317D0(int a1)
{
  FILE *v1; // ebp
  int v2; // esi
  char *v3; // edi
  int v4; // eax
  int v6; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+4h] [ebp-20h]
  int v8; // [esp+8h] [ebp-1Ch]

  v7 = a1;
  sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
  v1 = sub_1BB10("tutindex.txt", 0);
  fscanf(v1, "%d", &v6);
  if ( v6 > 7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\loadwin.cpp", 0x1EA);
  }
  v2 = v7 + 0x9C0;
  v8 = 0;
  if ( v6 > 0 )
  {
    v3 = (char *)(v7 + 0x9D4);
    do
    {
      fscanf(v1, "%s", v2);
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v1, v3);
      sub_2EA8C(*(_DWORD *)(v7 + 0xAB), (const char *)v2, 0xFFFFFFFF, 0);
      v4 = v8 + 1;
      v3 += 0xE0;
      *(_DWORD *)(v2 + 0xDC) = v8 + 1;
      v2 += 0xE0;
      v8 = v4;
    }
    while ( v4 < v6 );
  }
  return fclose(v1);
}

//----- (000318A0) --------------------------------------------------------
int __fastcall sub_318A0(unsigned __int16 a1, unsigned __int8 a2)
{
  int v3; // esi
  unsigned int v4; // edx
  int v5; // edi
  _DWORD *v7; // eax
  int v8; // ebx

  v3 = *((unsigned __int16 *)dword_10032C + a1);
  if ( (unsigned __int16)v3 == 0xFFFF )
  {
    return 0;
  }
  v4 = dword_100328 + 4 * (unsigned __int16)word_100330;
  v5 = a2;
  v7 = (_DWORD *)(dword_100328 + 4 * v3);
  v8 = (v5 << 0x10) + a1;
  if ( (unsigned int)v7 >= v4 )
  {
    return 0;
  }
  while ( v8 != *v7 )
  {
    if ( (unsigned int)++v7 >= v4 )
    {
      return 0;
    }
  }
  return (unsigned __int16)((int)((int)v7
                                + -dword_100328
                                - __CFSHL__(((int)v7 - dword_100328) >> 0x1F, 2)
                                + 0xFFFFFFFC * (((int)v7 - dword_100328) >> 0x1F)) >> 2)
       + 0x102;
}
// 100328: using guessed type int dword_100328;
// 100330: using guessed type __int16 word_100330;

//----- (00031934) --------------------------------------------------------
unsigned __int8 __fastcall sub_31934(int a1)
{
  char v1; // ch
  unsigned __int16 v2; // si
  char v3; // dh
  char v4; // al
  int v5; // edx
  unsigned __int8 result; // al
  char v7; // ch
  int v8; // ebx

  v1 = byte_100335;
  v2 = a1;
  v3 = (a1 << byte_100335) | *(_BYTE *)dword_100324++;
  *(_BYTE *)(dword_100324 - 1) = v3;
  v4 = byte_100334;
  if ( (unsigned __int16)(dword_100324 - dword_100338) == 0x100 )
  {
    *(_BYTE *)dword_100338 = 0xFF;
    dword_100338 = dword_100324++;
  }
  v5 = (int)v2 >> (8 - v1);
  result = v4 - (8 - v1);
  v7 = 0;
  v8 = dword_100324;
  *(_BYTE *)dword_100324 = v5;
  if ( result >= 8u )
  {
    dword_100324 = v8 + 1;
    if ( (unsigned __int16)(v8 + 1 - dword_100338) == 0x100 )
    {
      *(_BYTE *)dword_100338 = 0xFF;
      dword_100338 = dword_100324++;
    }
    if ( result > 8u )
    {
      v7 = result - 8;
      *(_BYTE *)dword_100324 = BYTE1(v5);
    }
  }
  else
  {
    v7 = result;
  }
  byte_100335 = v7;
  return result;
}
// 100324: using guessed type int dword_100324;
// 100334: using guessed type char byte_100334;
// 100335: using guessed type char byte_100335;
// 100338: using guessed type int dword_100338;

//----- (00031A34) --------------------------------------------------------
int __fastcall sub_31A34(unsigned __int16 a1, char a2)
{
  int v2; // ecx
  unsigned __int16 v3; // bx
  _WORD *v4; // edx
  int result; // eax

  v2 = dword_100328;
  v3 = word_100330;
  *(_BYTE *)(dword_100328 + 4 * (unsigned __int16)word_100330 + 2) = a2;
  *(_WORD *)(v2 + 4 * v3) = a1;
  v4 = (char *)dword_10032C + 2 * a1;
  if ( (unsigned __int16)*v4 == 0xFFFF )
  {
    *v4 = word_100330;
  }
  sub_31934(a1);
  result = (unsigned __int16)++word_100330 + 0x102;
  if ( result > (unsigned __int16)word_100332 )
  {
    if ( result <= 0x1000 )
    {
      BYTE1(result) = byte_100334 + 1;
      word_100332 *= 2;
      ++byte_100334;
    }
    else
    {
      sub_31934(0x100);
      byte_100334 = 9;
      word_100332 = 0x200;
      word_100330 = 0;
      return (int)memset(dword_10032C, 0xFF, 0x2008u);
    }
  }
  return result;
}
// 100328: using guessed type int dword_100328;
// 100330: using guessed type __int16 word_100330;
// 100332: using guessed type __int16 word_100332;
// 100334: using guessed type char byte_100334;

//----- (00031B08) --------------------------------------------------------
int __spoils<> sub_31B08()
{
  int v0; // ebx
  int v1; // esi
  unsigned __int16 v2; // ax
  UBYTE v3; // cl
  int v4; // ebx
  int v5; // eax
  char v6; // dh
  int result; // eax
  _BYTE *v8; // ebx
  int v9; // ebx
  char v10; // bl

  v0 = dword_100324;
  byte_100334 = 9;
  word_100332 = 0x200;
  *(_BYTE *)dword_100324 = 8;
  byte_100335 = 0;
  dword_100338 = v0 + 1;
  dword_100324 = v0 + 2;
  sub_31934(0x100);
  v1 = 1;
  v2 = *V_Window1.buffer;
  do
  {
    v3 = V_Window1.buffer[v1];
    v4 = v2;
    v2 = sub_318A0(v2, v3);
    if ( !v2 )
    {
      sub_31A34(v4, v3);
      v2 = v3;
    }
    ++v1;
  }
  while ( v1 < 0x4B000 );
  sub_31934(v2);
  sub_31934(0x101);
  LOWORD(v5) = dword_100324;
  LOWORD(v4) = dword_100338;
  v6 = byte_100335;
  result = v5 - v4;
  if ( byte_100335 )
  {
    *(_BYTE *)dword_100338 = result;
    v8 = (_BYTE *)(dword_100324 + 1);
    dword_100324 = (int)v8;
    *v8 = 0;
    v9 = (int)(v8 + 1);
  }
  else
  {
    v10 = result;
    if ( (unsigned __int16)result == 1 )
    {
      result = dword_100338;
      *(_BYTE *)dword_100338 = byte_100335;
      return result;
    }
    result = dword_100338;
    *(_BYTE *)dword_100338 = v10 - 1;
    v9 = dword_100324 + 1;
    *(_BYTE *)dword_100324 = v6;
  }
  dword_100324 = v9;
  return result;
}
// 31BC0: variable 'v5' is possibly undefined
// 100324: using guessed type int dword_100324;
// 100332: using guessed type __int16 word_100332;
// 100334: using guessed type char byte_100334;
// 100335: using guessed type char byte_100335;
// 100338: using guessed type int dword_100338;

//----- (00031C18) --------------------------------------------------------
int __fastcall sub_31C18(int result, int a2)
{
  RGB *v2; // edi
  LONG v3; // esi
  int v4; // edi
  _BYTE *v5; // ebp
  int v6; // esi
  _BYTE *v7; // ebp
  int v8; // ebx
  _WORD *v9; // ebp
  int v10; // ebp
  void *v11; // ecx
  int v12; // esi
  RGB *v13; // [esp-4h] [ebp-30h]
  int v14; // [esp-4h] [ebp-30h]
  char s[20]; // [esp+0h] [ebp-2Ch] BYREF
  RGB *triplet; // [esp+14h] [ebp-18h]

  if ( a2 >= (int)&V_CobFilesIndex_stru_9A254.fnames[0x17][0x16] )
  {
    V_Window1.buffer = (UBYTE *)result;
    V_Window1.x_max = 0x27F;
    V_Window1.y_max = 0x1DF;
    V_Window1.shadow = 0;
    V_Window1.stencil = 0;
    triplet = (RGB *)(result + 0x4B000);
    VFX_window_read(&V_Window1, 0, 0, 0x27F, 0x1DF);
    dword_100308 = (int)triplet;
    v2 = triplet;
    v3 = 0;
    triplet += 0x100;
    do
    {
      v13 = v2++;
      VFX_DAC_read(v3++, v13);
    }
    while ( v3 < 0x100 );
    buf = triplet;
    memset(triplet, 0, (size_t)&loc_493DC + 4);
    dword_100328 = (int)triplet + (_DWORD)&loc_493DC + 4;
    word_100330 = 0;
    triplet = (RGB *)((char *)triplet + (_DWORD)&loc_493DC + 4 + 0x4000);
    dword_10032C = triplet;
    dword_100324 = (int)buf;
    memset(triplet, 0xFF, 0x2008u);
    v4 = dword_100324;
    qmemcpy((void *)dword_100324, "GIF87a", 4u);
    qmemcpy((void *)(v4 + 4), "7a", 2u);
    v5 = (_BYTE *)(dword_100324 + 6);
    *(_WORD *)(dword_100324 + 6) = 0x280;
    v5 += 2;
    *(_WORD *)v5 = 0x1E0;
    v5 += 2;
    *v5++ = 0x87;
    *v5++ = 0xFF;
    v6 = 0;
    *v5 = 0;
    v7 = v5 + 1;
    do
    {
      ++v7;
      v8 = 0xFF * *(unsigned __int8 *)(v6 + dword_100308) / 0x3F;
      ++v6;
      v7[0xFFFFFFFF] = v8;
    }
    while ( v6 < 0x300 );
    *v7 = 0x2C;
    v9 = v7 + 1;
    *v9++ = 0;
    *v9++ = 0;
    *v9++ = 0x280;
    *v9++ = 0x1E0;
    *(_BYTE *)v9 = 7;
    dword_100324 = (int)v9 + 1;
    sub_31B08();
    v14 = dword_10033C;
    v10 = dword_100324;
    *(_BYTE *)dword_100324 = 0x3B;
    ++v10;
    v11 = buf;
    dword_100324 = v10;
    sprintf(s, "scr%03d.gif", v14);
    v12 = open(s, 0x262, 0x1C0);
    write(v12, buf, v10 - (_DWORD)v11);
    result = close(v12);
    dword_100324 = 0;
    dword_10032C = 0;
    dword_100328 = 0;
    buf = 0;
    V_Window1.buffer = 0;
    dword_100308 = 0;
    ++dword_10033C;
  }
  return result;
}
// 100308: using guessed type int dword_100308;
// 100324: using guessed type int dword_100324;
// 100328: using guessed type int dword_100328;
// 100330: using guessed type __int16 word_100330;
// 10033C: using guessed type int dword_10033C;

//----- (00031E60) --------------------------------------------------------
char __fastcall sub_31E60(const char *a1, int a2)
{
  int v3; // edx
  const char *v4; // esi
  char *v5; // edi
  char v6; // al
  char v7; // al
  const char *v8; // edi
  char *v9; // esi
  char *v10; // edi
  char v11; // al
  char v12; // al
  char *v13; // esi
  char *v14; // edi
  char v15; // al
  char v16; // al
  char *v17; // esi
  char *v18; // edi
  char result; // al
  const char *v20; // [esp-4h] [ebp-1Ch]

  if ( a2 < 0 || !a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\name.cpp", 0x29);
  }
  v3 = 0x3E8;
  if ( a2 > 0x3E8 )
  {
    v8 = a1;
    do
    {
      if ( v3 >= 0xFA0 )
      {
        break;
      }
      v4 = "M";
      v20 = v8;
      v5 = (char *)&v8[strlen(v8)];
      do
      {
        v6 = *v4;
        *v5 = *v4;
        if ( !v6 )
        {
          break;
        }
        v7 = v4[1];
        v4 += 2;
        v5[1] = v7;
        v5 += 2;
      }
      while ( v7 );
      v8 = v20;
      v3 += 0x3E8;
    }
    while ( v3 < a2 );
  }
  v9 = (char *)&unk_9678C + 5 * (a2 / 0x64 % 0xA);
  v10 = (char *)&a1[strlen(a1)];
  do
  {
    v11 = *v9;
    *v10 = *v9;
    if ( !v11 )
    {
      break;
    }
    v12 = v9[1];
    v9 += 2;
    v10[1] = v12;
    v10 += 2;
  }
  while ( v12 );
  v13 = (char *)&unk_967BE + 5 * (a2 / 0xA % 0xA);
  v14 = (char *)&a1[strlen(a1)];
  do
  {
    v15 = *v13;
    *v14 = *v13;
    if ( !v15 )
    {
      break;
    }
    v16 = v13[1];
    v13 += 2;
    v14[1] = v16;
    v14 += 2;
  }
  while ( v16 );
  v17 = (char *)&unk_967F0 + 5 * (a2 % 0xA);
  v18 = (char *)&a1[strlen(a1)];
  do
  {
    result = *v17;
    *v18 = *v17;
    if ( !result )
    {
      break;
    }
    result = v17[1];
    v17 += 2;
    v18[1] = result;
    v18 += 2;
  }
  while ( result );
  return result;
}

//----- (00031FB0) --------------------------------------------------------
int __fastcall sub_31FB0(_DWORD *a1, const char *a2, int a3, int a4)
{
  unsigned __int8 v5; // dl
  int v7; // [esp-4h] [ebp-10h]

  v5 = 4 * byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  if ( a4 == 0xFFFFFFFF )
  {
    v5 = 0xF3;
  }
  v7 = a1[3] - a1[1] - 0x10;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 8, 3, a2, 0, v5, 0xFF, v7);
}

//----- (0003201C) --------------------------------------------------------
void __fastcall __spoils<> sub_3201C(P_TypeA7 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95F1C;
  sub_3207C(a1);
}
// 95F1C: using guessed type int (*off_95F1C[5])();

//----- (00032038) --------------------------------------------------------
int __fastcall sub_32038(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95ED8);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F1C;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F1C: using guessed type int (*off_95F1C[5])();

//----- (0003207C) --------------------------------------------------------
void __fastcall __spoils<> sub_3207C(P_TypeA7 result)
{
  result->b = 0;
  result->c = 0;
  result->d = 0;
  result->f = 0xFFFF;
  result->g = 0xFFFF;
  result->h = 0xFFFF;
}

//----- (000320B8) --------------------------------------------------------
unsigned int __fastcall sub_320B8(int a1, __int16 a2, int a3, int a4)
{
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char v9; // bl
  int v10; // eax
  char *v11; // eax
  __int16 v12; // ax
  __int16 v13; // ax
  int v15; // edx
  char v16[32]; // [esp+0h] [ebp-44h] BYREF
  char v17[16]; // [esp+20h] [ebp-24h] BYREF
  int v18; // [esp+30h] [ebp-14h]
  int v19; // [esp+34h] [ebp-10h]
  int v20; // [esp+38h] [ebp-Ch]
  int v21; // [esp+3Ch] [ebp-8h]
  __int16 v22; // [esp+40h] [ebp-4h]
  _BYTE savedregs[12]; // [esp+44h] [ebp+0h]
  void *retaddr; // [esp+50h] [ebp+Ch]

  v22 = a2;
  v5 = a3;
  v21 = a4;
  v18 = (unsigned __int8)byte_104BEA;
  v20 = (unsigned __int8)byte_968DD;
  if ( (unsigned __int16)a2 < 4u )
  {
    if ( !a2 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    if ( (unsigned __int16)a2 <= 1u )
    {
      if ( !*(_DWORD *)(a1 + 0xAB) )
      {
        a3 = 0xD;
        a4 = 0;
        v6 = sub_56E18((int)&V_Type3_stru_10AE70, "PLAYERDIP", 0xD, 0);
        *(_DWORD *)(a1 + 0xAB) = v6;
        if ( !v6 )
        {
          a3 = 0x7B;
          Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x7B);
        }
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x1D;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_31FB0);
      sub_2E9CC(*(_DWORD *)(a1 + 0xAB), 0);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC6) = 0xF2;
      if ( !*(_DWORD *)(a1 + 0xAF) )
      {
        a3 = 0xD;
        a4 = 0;
        v7 = sub_56E18((int)&V_Type3_stru_10AE70, "ALIENDIP", 0xD, 0);
        *(_DWORD *)(a1 + 0xAF) = v7;
        if ( !v7 )
        {
          a3 = 0x88;
          Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x88);
        }
      }
      if ( !*(_DWORD *)(a1 + 0xB3) )
      {
        a3 = 0xD;
        a4 = 0;
        v8 = sub_56E18((int)&V_Type3_stru_10AE70, "COSMOSWnd", 0xD, 0);
        *(_DWORD *)(a1 + 0xB3) = v8;
        if ( !v8 )
        {
          a3 = 0x8F;
          Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x8F);
        }
      }
      sub_32658(a1);
      sub_32E84(a1, 0, a3, a4);
      *(_WORD *)(*(_DWORD *)(a1 + 0xAF) + 0xB1) = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_968DD]
                                                + 0x13;
      memset(byte_101DC4, 0, 0xFu);
      v9 = byte_A315B[0x1EE * v20];
      v10 = 0x1EE * v18;
      *(_DWORD *)(a1 + 0xB7) = 0;
      v11 = &byte_A2F72[v10];
      if ( v9 == 0xE )
      {
        v13 = sub_44238(
                (int)v11,
                (unsigned __int8)byte_968DD,
                v17,
                HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF))));
        sub_32A48(a1, (int)v17, v13, 0xFFFFFFFF, 0xFFFFFFFF);
        sub_32C14(a1, 0x1D);
      }
      else
      {
        v19 = v9;
        *(_DWORD *)(a1 + 0xB7) = 0xFFFFFFFF;
        v12 = sub_44A2C(v11, (__int16)retaddr, v9, v16);
        sub_32B44(a1, (int)v16, v12);
        sub_32BDC(a1, v19);
      }
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    if ( a2 != 2 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    sub_2D258(a1, *(__int16 *)&savedregs[4]);
    return 0;
  }
  if ( (unsigned __int16)a2 <= 5u )
  {
    if ( a3 >= 0xAE && a3 <= 0x147 && a4 >= 0x145 && a4 <= 0x1D8 )
    {
      sub_4FB90((int)&unk_10914C, 0);
      sub_32714(a1, a3, a4);
      return 0xFFFFFFFF;
    }
    return 0;
  }
  if ( (unsigned __int16)a2 < 0xCu )
  {
    return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
  }
  if ( (unsigned __int16)a2 <= 0xCu )
  {
    if ( a3 < 0xAE || a3 > 0x147 || a4 < 0x145 || a4 > 0x1D8 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    sub_56B60((int)&V_Type3_stru_10AE70, 5, (int)"tinyrace", 0);
    return 0xFFFFFFFF;
  }
  else
  {
    if ( a2 != 0x1C01 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    v15 = sub_2ECA4(*(_DWORD *)(a1 + 0xAB), a3);
    sub_32800(a1, v15);
    if ( *(_DWORD *)(a1 + 0xB7) == 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0xB7) = 0;
    }
    return 0xFFFFFFFF;
  }
}
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;

//----- (00032414) --------------------------------------------------------
void __fastcall sub_32414(int a1)
{
  int v1; // eax
  __int16 i; // di
  int v3; // eax
  __int16 v4; // bx
  __int16 v5; // ax
  __int16 v6; // dx
  int v7; // esi
  int v8; // eax
  int v9; // eax
  char *sub_1CEA8; // eax
  int v11; // [esp-1Ch] [ebp-50h]
  int v12; // [esp-8h] [ebp-3Ch]
  T_Type5 pane; // [esp+0h] [ebp-34h] BYREF
  _DWORD *v14; // [esp+14h] [ebp-20h]
  int v15; // [esp+18h] [ebp-1Ch]
  int v16; // [esp+1Ch] [ebp-18h]

  v14 = (_DWORD *)a1;
  pane = (T_Type5)V_Type6_stru_D8654.pane;
  if ( *(_WORD *)(a1 + 0xC1) )
  {
    pane.rect.x1 = 0xAE;
    pane.rect.y1 = 0x145;
    pane.rect.x2 = 0x147;
    pane.rect.y2 = 0x1D8;
    sub_5E9D0(&pane, 0xF2);
    sub_552CC(&V_Type3_stru_10AE70, &pane);
    v1 = sub_56DA8((int)&V_Type3_stru_10AE70, "INTELSCREEN", 0);
    LOWORD(v1) = word_FFEF2;
    v16 = v1;
    for ( i = 0; i < *(__int16 *)((char *)v14 + 0xC1); ++i )
    {
      v4 = *((_WORD *)&dword_96840 + i + 1);
      v5 = word_9682E[i];
      v6 = word_96838[i];
      v7 = v5;
      v11 = v5;
      v15 = v6;
      v8 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[v4]);
      sub_5D631(
        (P_Type5)&V_Type6_stru_D8654.pane,
        v8,
        0,
        v11,
        v6,
        (int)byte_D8DA0,
        0,
        (void (__noreturn *)())0x8000,
        (void (__noreturn *)())0x8000,
        0);
      v12 = v15;
      if ( i == *(_WORD *)((char *)v14 + 0xBF) )
      {
        v9 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v16);
        sub_53EB8((P_Type5)&V_Type6_stru_D8654.pane, v9, 4, v7, v12, v4);
      }
      else
      {
        v3 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v16);
        sub_53EB8((P_Type5)&V_Type6_stru_D8654.pane, v3, 3, v7, v12, v4);
      }
    }
  }
  pane.rect.x1 = 7;
  pane.rect.y1 = 0x145;
  pane.rect.x2 = 0xA5;
  pane.rect.y2 = 0x163;
  sub_5E9D0(&pane, 0xF2);
  sub_552CC(&V_Type3_stru_10AE70, &pane);
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1A);// 26: "Selected System"
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x302E] = pane;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 2, 2, sub_1CEA8, 0, 0xFFFFFFFF, 0xFF, 0);
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = pane;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0xD, (const char *)(dword_D3660 + 0x1C), 0, 0xFFFFFFFF, 0xFF, 0);
  if ( *(_WORD *)((char *)v14 + 0x6B) )
  {
    sub_2D218(v14);
  }
}
// 9682E: using guessed type __int16 word_9682E[5];
// 96838: using guessed type __int16 word_96838[4];
// 96840: using guessed type int dword_96840;
// D3660: using guessed type int dword_D3660;
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEF2: using guessed type __int16 word_FFEF2;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00032658) --------------------------------------------------------
void *__fastcall sub_32658(int a1)
{
  void *result; // eax
  __int16 i; // dx
  int v4; // ebx

  *(_WORD *)(a1 + 0xC1) = 0;
  *(_WORD *)(a1 + 0xBF) = 0;
  result = memset((char *)&dword_96840 + 2, 0xFFFFFFFF, 0xAu);
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    result = (void *)i;
    if ( i != (unsigned __int8)byte_104BEA
      && i != (unsigned __int8)byte_968DD
      && *(int *)((char *)&dword_A2F75 + 0x1EE * i) != 0xFFFFFFFF
      && byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + i] )
    {
      if ( byte_A3132[0x1EE * (unsigned __int8)byte_968DD + i] )
      {
        LOWORD(result) = *(_WORD *)(a1 + 0xC1);
        v4 = (__int16)result;
        result = (char *)result + 1;
        *(_WORD *)(a1 + 0xC1) = (_WORD)result;
        *((_WORD *)&dword_96840 + v4 + 1) = i;
      }
    }
  }
  return result;
}
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00032714) --------------------------------------------------------
int __fastcall sub_32714(int a1, int a2, __int16 a3)
{
  __int16 v5; // dx
  int result; // eax
  __int16 v7; // cx
  __int16 v8; // bx
  int v9; // edx
  __int16 v10; // ax
  char v11[16]; // [esp+0h] [ebp-20h] BYREF
  int v12; // [esp+10h] [ebp-10h]

  v12 = a2;
  v5 = *(_WORD *)(a1 + 0xC1);
  result = 0;
  if ( v5 > 0 )
  {
    do
    {
      v7 = v12 - word_9682E[(__int16)result];
      v8 = a3 - word_96838[(__int16)result];
      if ( v7 < 0x16 && v7 > (int)0xFFFFFFEA && v8 < 0x16 && v8 > (int)0xFFFFFFEA )
      {
        break;
      }
      ++result;
    }
    while ( (__int16)result < *(__int16 *)(a1 + 0xC1) );
  }
  if ( (__int16)result < *(__int16 *)(a1 + 0xC1) && (_WORD)result != *(_WORD *)(a1 + 0xBF) )
  {
    v9 = *(_DWORD *)(a1 + 0xB7);
    *(_WORD *)(a1 + 0xBF) = result;
    if ( !v9 )
    {
      v10 = sub_44238(
              (int)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA],
              (unsigned __int8)byte_968DD,
              v11,
              HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * (*(int *)(a1 + 0xBD) >> 0x10))));
      sub_32A48(a1, (int)v11, v10, 0, 0xFFFFFFFF);
    }
    return (*(int (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
  }
  return result;
}
// 9682E: using guessed type __int16 word_9682E[5];
// 96838: using guessed type __int16 word_96838[4];
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;

//----- (00032800) --------------------------------------------------------
int __fastcall sub_32800(int a1, int a2)
{
  int v3; // ebx
  char *v4; // edi
  __int16 v6; // ax
  char v7; // bl
  char v8; // cl
  __int16 v9; // ax
  char v10[16]; // [esp+0h] [ebp-30h] BYREF
  char v11[16]; // [esp+10h] [ebp-20h] BYREF
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  unsigned __int8 *v15; // [esp+2Ch] [ebp-4h]

  v14 = (unsigned __int8)byte_104BEA;
  v3 = 0x1EE * (unsigned __int8)byte_968DD;
  v15 = (unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA];
  v4 = &byte_A2F72[v3];
  if ( *(_DWORD *)(a1 + 0xB7) != 0xFFFFFFFF )
  {
    v7 = a2;
    v12 = 0;
    if ( (_BYTE)a2 == 0xE )
    {
      return sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
    }
    byte_101DC4[a2] = 1;
    if ( (unsigned __int8)a2 < 9u )
    {
      if ( (_BYTE)a2 != 7 )
      {
        goto LABEL_14;
      }
    }
    else if ( (unsigned __int8)a2 > 0xBu )
    {
      if ( (_BYTE)a2 == 0xC )
      {
        v12 = dword_D3660;
      }
      goto LABEL_14;
    }
    v12 = *(int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF)) >> 0x10;
LABEL_14:
    v13 = (char)a2;
    v8 = sub_44BCC((int)v4, (__int16 *)(unsigned __int8)byte_104BEA, a2, v12, 0);
    sub_32C14(a1, v8);
    sub_450B0(v15, (unsigned __int8)byte_968DD, v7, v8, v12, 0);
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x41), 0xD, 0, 0);
    v9 = sub_44238(
           (int)v15,
           (unsigned __int8)byte_968DD,
           v11,
           HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF))));
    return sub_32A48(a1, (int)v11, v9, 0xFFFFFFFF, 0xFFFFFFFF);
  }
  if ( (_BYTE)a2 == 1 )
  {
    dword_D3660 = *(int *)((char *)&dword_A315C + 0x1EE * (unsigned __int8)byte_968DD);
    return sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 0);
  }
  else
  {
    sub_450B0((unsigned __int8 *)&byte_A2F72[v3], v14, v4[0x1E9], a2, *(_DWORD *)(v4 + 0x1EA), 0);
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x41), 0xD, 0, 0);
    v4[0x1E9] = 0xE;
    v6 = sub_44238(
           (int)v15,
           (unsigned __int8)byte_968DD,
           v10,
           HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF))));
    sub_32A48(a1, (int)v10, v6, 0xFFFFFFFF, 0xFFFFFFFF);
    return sub_32BDC(a1, 0xE);
  }
}
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;
// A315C: using guessed type int dword_A315C;
// D3660: using guessed type int dword_D3660;

//----- (00032A1C) --------------------------------------------------------
int __fastcall sub_32A1C(int a1)
{
  if ( !*(_DWORD *)(a1 + 0xB7) )
  {
    sub_32A48(a1, 0, 0, 0, 0);
  }
  return (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
}

//----- (00032A48) --------------------------------------------------------
__int64 __fastcall sub_32A48(int a1, int a2, __int16 a3, int a4, int a5)
{
  int v6; // eax
  __int16 v7; // si
  unsigned __int16 v8; // dx
  const char *v9; // eax
  unsigned __int16 v10; // ax
  int v12; // [esp+0h] [ebp-18h]

  word_103F94 = 0;
  if ( a5 )
  {
    qmemcpy(&unk_100340, (const void *)a2, 0xCu);
    qmemcpy((char *)&unk_100340 + 0xC, (const void *)(a2 + 0xC), 3u);
    word_100350 = a3;
  }
  v6 = *(_DWORD *)(a1 + 0xAB);
  v7 = 0;
  v8 = *(_WORD *)(v6 + 0x8CD);
  sub_2ED4C(v6);
  if ( word_100350 > 0 )
  {
    do
    {
      if ( !byte_101DC4[*(int *)((char *)&dword_10033C + v7 + 1) >> 0x18] )
      {
        v9 = (const char *)((int (__fastcall *)(int))loc_32C48)(a1);
        v12 = *(_DWORD *)(a1 + 0xAB);
        v10 = sub_2EA8C(v12, v9, 0xFFFFFFFF, 0);
        sub_2EC50(*(_DWORD *)(a1 + 0xAB), v10, *(int *)((char *)&dword_10033C + v7 + 1) >> 0x18);
      }
      ++v7;
    }
    while ( v7 < word_100350 );
  }
  if ( !a4 )
  {
    sub_2ECDC(*(_DWORD *)(a1 + 0xAB), v8);
  }
  return (unsigned int)(*(int (__cdecl **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xA7) + 0xC))(v12);
}
// 32B38: variable 'v12' is possibly undefined
// 10033C: using guessed type int dword_10033C;
// 100350: using guessed type __int16 word_100350;
// 103F94: using guessed type __int16 word_103F94;

//----- (00032B44) --------------------------------------------------------
__int64 __fastcall sub_32B44(int a1, int a2, __int16 a3)
{
  int v4; // eax
  int v5; // edi
  const char *v6; // eax
  unsigned __int16 v7; // ax
  char *v9; // [esp+0h] [ebp-1Ch]

  v4 = *(_DWORD *)(a1 + 0xAB);
  v5 = 0;
  word_103F94 = 0;
  sub_2ED4C(v4);
  if ( a3 > 0 )
  {
    do
    {
      v9 = (char *)((__int16)v5 + a2);
      v6 = (const char *)((int (__fastcall *)(int, _DWORD, unsigned int, _DWORD))loc_32C48)(a1, *v9, 0xFFFFFFFF, 0);
      v7 = sub_2EA8C(*(_DWORD *)(a1 + 0xAB), v6, 0xFFFFFFFF, 0);
      ++v5;
      sub_2EC50(*(_DWORD *)(a1 + 0xAB), v7, *v9);
    }
    while ( (__int16)v5 < a3 );
  }
  return (unsigned int)(*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xA7) + 0xC))();
}
// 103F94: using guessed type __int16 word_103F94;

//----- (00032BDC) --------------------------------------------------------
__int64 __fastcall sub_32BDC(int a1, char a2)
{
  *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xAB) = ((int (__fastcall *)(int, _DWORD, _DWORD, unsigned int))loc_32C48)(
                                                 a1,
                                                 a2,
                                                 0,
                                                 0xFFFFFFFF);
  return (unsigned int)(*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xA7) + 0xC))();
}

//----- (00032C14) --------------------------------------------------------
__int64 __fastcall sub_32C14(int a1, char a2)
{
  *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xAB) = ((int (__fastcall *)(int, _DWORD, _DWORD, _DWORD))loc_32C48)(
                                                 a1,
                                                 a2,
                                                 0,
                                                 0);
  return (unsigned int)(*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xA7) + 0xC))();
}

//----- (00032E84) --------------------------------------------------------
int __fastcall sub_32E84(int a1, int a2, int a3, int a4)
{
  const char *v5; // esi
  int *v6; // edi
  char v7; // al
  char v8; // al
  FILE *v9; // eax
  FILE *v10; // esi
  int result; // eax
  FILE *v12; // eax
  FILE *v13; // esi
  char s[16]; // [esp+0h] [ebp-34h] BYREF
  int v15[9]; // [esp+10h] [ebp-24h] BYREF

  v15[7] = a4;
  if ( (unsigned __int8)byte_968DD >= 0x15u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2D6);
  }
  if ( (unsigned __int8)byte_104BEA >= 0x15u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2D7);
  }
  sprintf(s, "RACE%02d.DIP", *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_968DD));
  v5 = "PLAYER.DIP";
  v6 = v15;
  do
  {
    v7 = *v5;
    *(_BYTE *)v6 = *v5;
    if ( !v7 )
    {
      break;
    }
    v8 = v5[1];
    v5 += 2;
    *((_BYTE *)v6 + 1) = v8;
    v6 = (int *)((char *)v6 + 2);
  }
  while ( v8 );
  if ( *(_WORD *)(a1 + 0xBB) != (unsigned __int8)byte_968DD )
  {
    v9 = sub_1BB10(s, 0);
    v10 = v9;
    if ( !v9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2E4);
    }
    sub_32FD8(a1, v9, 0);
    fclose(v10);
    *(_WORD *)(a1 + 0xBB) = (unsigned __int8)byte_968DD;
  }
  result = *(__int16 *)(a1 + 0xBD);
  if ( result != (unsigned __int8)byte_104BEA )
  {
    v12 = sub_1BB10((const char *)v15, 0);
    v13 = v12;
    if ( !v12 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2EF);
    }
    sub_32FD8(a1, v12, 0xFFFFFFFF);
    fclose(v13);
    result = (unsigned __int8)byte_104BEA;
    *(_WORD *)(a1 + 0xBD) = (unsigned __int8)byte_104BEA;
  }
  return result;
}
// 968DD: using guessed type char byte_968DD;

//----- (00032FD8) --------------------------------------------------------
int __fastcall sub_32FD8(int a1, FILE *a2, int a3)
{
  __int16 v3; // si
  char *v4; // eax
  __int16 i; // si
  int result; // eax
  char *v7; // eax
  char v8[220]; // [esp+0h] [ebp-DCh] BYREF

  while ( strncmp(v8, "ACTIONS", 7u) )
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  }
  Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  v3 = 0;
  while ( strncmp(v8, "RESPONSES", 9u) )
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
    if ( a3 )
    {
      v4 = (char *)&unk_100744 + 0x80 * v3;
    }
    else
    {
      v4 = (char *)&unk_101DD4 + 0x80 * v3;
    }
    ++v3;
    strncpy(v4, v8, 0x7Fu);
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  }
  Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  for ( i = 0; ; ++i )
  {
    result = strncmp(v8, "END DIPLO", 9u);
    if ( !result )
    {
      break;
    }
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
    if ( a3 )
    {
      v7 = (char *)&unk_100EC4 + 0x80 * i;
    }
    else
    {
      v7 = (char *)&unk_102554 + 0x80 * i;
    }
    strncpy(v7, v8, 0x7Fu);
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  }
  return result;
}

//----- (000330DC) --------------------------------------------------------
unsigned int __fastcall sub_330DC(T_Type5 *a1, unsigned __int8 *a2)
{
  int v3; // eax
  int v4; // esi
  const char *v5; // ecx
  int v6; // eax
  int v7; // eax
  char *sub_1CEA8; // eax
  __int16 v9; // di
  int v10; // ecx
  int v11; // eax
  __int16 v12; // edx^2
  char *v13; // eax
  __int16 v14; // di
  int v15; // eax
  int v16; // eax
  char *v17; // eax
  __int16 v18; // di
  int v19; // ecx
  int v20; // eax
  int v21; // esi
  unsigned int result; // eax
  __int16 v23; // di
  int v24; // ebx
  int v25; // eax
  unsigned __int8 v26; // cl
  __int16 v27; // [esp-Ch] [ebp-64h]
  __int16 v28; // [esp-Ch] [ebp-64h]
  __int16 v29; // [esp-Ch] [ebp-64h]
  int v30; // [esp-8h] [ebp-60h]
  int v31; // [esp-8h] [ebp-60h]
  int v32; // [esp-8h] [ebp-60h]
  __int16 v33; // [esp-4h] [ebp-5Ch]
  __int16 v34; // [esp-4h] [ebp-5Ch]
  __int16 v35; // [esp-4h] [ebp-5Ch]
  int v36; // [esp+0h] [ebp-58h] BYREF
  int v37; // [esp+4h] [ebp-54h]
  int v38; // [esp+8h] [ebp-50h]
  int v39; // [esp+Ch] [ebp-4Ch]
  int v40; // [esp+10h] [ebp-48h]
  unsigned __int8 *v41; // [esp+14h] [ebp-44h]
  int v42; // [esp+18h] [ebp-40h]
  char *v43; // [esp+1Ch] [ebp-3Ch]
  int v44; // [esp+20h] [ebp-38h]
  unsigned __int8 *v45; // [esp+24h] [ebp-34h]
  int v46; // [esp+28h] [ebp-30h]
  int v47; // [esp+2Ch] [ebp-2Ch]
  int v48; // [esp+30h] [ebp-28h]
  int v49; // [esp+34h] [ebp-24h]
  int v50; // [esp+38h] [ebp-20h]
  int i; // [esp+3Ch] [ebp-1Ch]
  int v52; // [esp+40h] [ebp-18h]
  int v53; // [esp+44h] [ebp-14h]
  int v54; // [esp+48h] [ebp-10h]

  v41 = a2;
  v3 = sub_56DA8((int)&V_Type3_stru_10AE70, "INTELSCREEN", 0);
  LOWORD(v3) = word_FFEF2;
  v54 = v3;
  v45 = a2;
  v4 = 0x1EE * *a2;
  v47 = *a2;
  v40 = 4 * (unsigned __int8)byte_A2F74[v4] + 0x13;
  v37 = (__int16)v47;
  sub_53E38(a1, 3, 3, v47);
  v5 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + v4)];
  v27 = v40;
  v39 = (__int16)v40;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x14, 5, v5, 0, v27, 0xFF, 0);
  v6 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[v47]);
  sub_5D631(a1, v6, 0, 0x96, 0x1E, (int)byte_D8DA0, 0, (void (__noreturn *)())0x8000, (void (__noreturn *)())0x8000, 0);
  v7 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v54);
  v50 = 0xC8;
  sub_53EB8(a1, v7, 3, 0x96, 0x1E, v37);
  v36 = 0;
  sub_40224(v41, 0, &v36);
  v48 = 0x14;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x14);
  v28 = v39;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v9 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xC8, 5, sub_1CEA8, 0, v28, 0xFF, 0);
  while ( v9 < v36 )
  {
    v10 = v50;
    v33 = v47;
    v30 = v48;
    v11 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8(a1, v11, 5, v10, v30, v33);
    v50 += 8;
    if ( v9 % 9 == 8 )
    {
      v50 = 0xC8;
      v48 += 8;
    }
    ++v9;
  }
  v12 = v40;
  v42 = sub_402E0(v45);
  v53 = 0x118;
  v46 = 0x14;
  v13 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x15);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v14 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x118, 5, v13, 0, v12, 0xFF, 0);
  while ( v14 < v42 )
  {
    v34 = v47;
    v31 = v46;
    v15 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8(a1, v15, 6, v53, v31, v34);
    v53 += 8;
    if ( v14 % 9 == 8 )
    {
      v53 = 0x118;
      v46 += 8;
    }
    ++v14;
  }
  v16 = sub_40664(v45);
  v52 = 0x168;
  v44 = v16 >> 2;
  v49 = 0x14;
  v17 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x16);
  v29 = v40;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v18 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x168, 5, v17, 0, v29, 0xFF, 0);
  while ( v18 < v44 )
  {
    v19 = v52;
    v35 = v47;
    v32 = v49;
    v20 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8(a1, v20, 7, v19, v32, v35);
    v52 += 8;
    if ( v18 % 9 == 8 )
    {
      v52 = 0x168;
      v49 += 8;
    }
    ++v18;
  }
  v21 = 0x1CC;
  result = 0x1EE * (unsigned __int8)byte_104BEA;
  v23 = 0;
  v43 = &byte_A2F72[result];
  for ( i = 5; v23 < SHIWORD(dword_A3CF2); ++v23 )
  {
    result = v23;
    if ( v23 != v47
      && v45[v23 + 0x1C0]
      && !*(int *)((char *)&dword_A2F75 + 0x1EE * v23)
      && (v43[v23 + 0x1C0] || v23 == (unsigned __int8)byte_104BEA) )
    {
      v38 = v23;
      sub_53E38(a1, v21, i, v23);
      result = (unsigned int)&v45[v38];
      v26 = v45[v38 + 0x1C0];
      v24 = 0xFFFFFFFF;
      if ( v26 == 3 )
      {
        v24 = 9;
      }
      else if ( v26 == 2 )
      {
        v24 = 8;
      }
      if ( v24 != 0xFFFFFFFF )
      {
        v25 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
        result = sub_5CB3C(a1, v25, v24, v21, i);
      }
      v21 += 0x39;
      if ( v21 > 0x258 )
      {
        v21 = 0x1CC;
        i += 0x1B;
      }
    }
  }
  return result;
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEF2: using guessed type __int16 word_FFEF2;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00033598) --------------------------------------------------------
void __fastcall __spoils<> sub_33598(P_TypeA4 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95F04;
  sub_335F8(a1);
}
// 95F04: using guessed type int (*off_95F04[5])();

//----- (000335B4) --------------------------------------------------------
int __fastcall sub_335B4(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95EC4);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F04;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F04: using guessed type int (*off_95F04[5])();

//----- (000335F8) --------------------------------------------------------
void __fastcall __spoils<> sub_335F8(P_TypeA4 result)
{
  result->b = 0;
}

//----- (00033604) --------------------------------------------------------
unsigned int __fastcall sub_33604(int a1, __int16 a2, int a3, int a4)
{
  int v5; // eax

  if ( a2 != 1 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( !*(_DWORD *)(a1 + 0xAB) )
  {
    v5 = sub_56DA8((int)&V_Type3_stru_10AE70, "INTELLIST", 0);
    *(_DWORD *)(a1 + 0xAB) = v5;
    *(_WORD *)(v5 + 0x8C9) = 0x3C;
    sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_330DC);
  }
  return sub_2F424(a1, 1, a3, a4);
}

//----- (00033674) --------------------------------------------------------
void __fastcall sub_33674(int a1)
{
  T_Type5 *v1; // esi
  char *sub_1CEA8; // eax
  const char *v3; // ebp
  unsigned __int8 *v4; // edi
  int v5; // esi
  unsigned __int16 v6; // ax
  __int16 v7; // [esp-Ch] [ebp-60h]
  char *v8; // [esp-4h] [ebp-58h]
  char s[52]; // [esp+0h] [ebp-54h] BYREF
  _DWORD *v10; // [esp+34h] [ebp-20h]
  int v11; // [esp+38h] [ebp-1Ch] BYREF
  int v12; // [esp+3Ch] [ebp-18h]

  v10 = (_DWORD *)a1;
  v1 = (T_Type5 *)(a1 + 4);
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
  sub_53E38(v1, 3, 3, (unsigned __int8)byte_104BEA);
  v8 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1B);// 27: "%s Intelligence"
  sprintf(s, sub_1CEA8, v8);
  v3 = byte_A2F72;
  v7 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v1->a;
  v1 = (T_Type5 *)((char *)v1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v1->a;
  v1 = (T_Type5 *)((char *)v1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v1->a;
  v1 = (T_Type5 *)((char *)v1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v1->rect.x1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 9, s, 2, v7, 0xFF, 0);
  v4 = (unsigned __int8 *)byte_A2F72;
  v5 = 0;
  sub_2ED4C(*(_DWORD *)((char *)v10 + 0xAB));
  while ( v5 < SHIWORD(dword_A3CF2) )
  {
    if ( v5 == (unsigned __int8)byte_104BEA
      || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v5] && !*(int *)((char *)&dword_A2F75 + 0x1EE * v5) )
    {
      v11 = 0;
      sub_40224(v4, 0, &v11);
      v12 = sub_402E0(v4);
      v6 = sub_2EA8C(*(_DWORD *)((char *)v10 + 0xAB), v3, 0xFFFFFFFF, 0);
      sub_2EC50(*(_DWORD *)((char *)v10 + 0xAB), v6, -(v12 + v11));
    }
    v4 += 0x1EE;
    ++v5;
    v3 += 0x1EE;
  }
  sub_2F1D8(*(_DWORD *)((char *)v10 + 0xAB), (int)sub_10A14);
  sub_2F1E0(*(_DWORD *)((char *)v10 + 0xAB));
  sub_2D218(v10);
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00033830) --------------------------------------------------------
void __fastcall __spoils<> sub_33830(P_TypeA6 a1)
{
  sub_2FC50(&a1->a);
  a1->a.b = (int)off_95EEC;
}
// 95EEC: using guessed type int (*off_95EEC[5])();

//----- (00033840) --------------------------------------------------------
int __fastcall sub_33840(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95EB0);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95EEC;
    v5 = (void *)sub_2FC68(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95EEC: using guessed type int (*off_95EEC[5])();

//----- (00033884) --------------------------------------------------------
int __fastcall sub_33884(_DWORD *a1, int a2, int a3, int a4)
{
  char s[24]; // [esp+0h] [ebp-20h] BYREF
  int v7; // [esp+18h] [ebp-8h]

  v7 = a4;
  sprintf(s, "abil%02d", byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA + 0x19D]);
  return sub_2FCB0(a1, "help.txt", s);
}

//----- (000338DC) --------------------------------------------------------
unsigned int __fastcall sub_338DC(int a1, __int16 a2, int a3, int a4)
{
  int v5; // eax
  char *v6; // esi
  int v7; // edx
  int v8; // eax
  char *sub_1CEA8; // eax
  char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  char *v14; // esi
  char *v15; // edi
  char v16; // al
  char v17; // al
  int v18; // ebx
  char s[100]; // [esp+0h] [ebp-84h] BYREF
  char v21[32]; // [esp+64h] [ebp-20h] BYREF

  v5 = 0x1EE * (unsigned __int8)byte_104BEA;
  v6 = &byte_A2F72[v5];
  if ( !a2 )
  {
    return sub_2FD68(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 1u )
  {
    if ( sub_434E4(&byte_A2F72[v5], 0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(a1 + 0xCCB) = 2;
    }
    else
    {
      sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(**(_DWORD **)(a1 + 0x67) + 0x41), 2, 0, 0);
      v7 = (unsigned __int16)word_968E8[v6[0x19D]] - *(_DWORD *)(v6 + 0x19E);
      if ( v7 == 1 )
      {
        v8 = 0x1C;
      }
      else
      {
        v8 = 0x1D;
      }
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v8);
      sprintf(s, *(const char **)(a1 + 0xCD0), v7, sub_1CEA8);
      v10 = s;
      v11 = *(char **)(a1 + 0xCD0);
      do
      {
        v12 = *v10;
        *v11 = *v10;
        if ( !v12 )
        {
          break;
        }
        v13 = v10[1];
        v10 += 2;
        v11[1] = v13;
        v11 += 2;
      }
      while ( v13 );
      v14 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
      v15 = (char *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4) + 0x20);
      do
      {
        v16 = *v14;
        *v15 = *v14;
        if ( !v16 )
        {
          break;
        }
        v17 = v14[1];
        v14 += 2;
        v15[1] = v17;
        v15 += 2;
      }
      while ( v17 );
    }
    *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
    v18 = *(_DWORD *)(a1 + 0xA7);
    *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
    (*(void (__fastcall **)(int, _DWORD))(v18 + 0xC))(a1, 0);
    return 0;
  }
  else
  {
    if ( a2 != 0x32 || a3 != 1 )
    {
      return sub_2FD68(a1, a2, a3, a4);
    }
    sub_434E4(&byte_A2F72[v5], 1);
    sprintf(v21, "abres%02d", v6[0x19D]);
    sub_2FCB0((_DWORD *)a1, "help.txt", v21);
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    return 0;
  }
}
// 968E8: using guessed type __int16 word_968E8[21];

//----- (00033A68) --------------------------------------------------------
unsigned int __fastcall sub_33A68(int a1)
{
  int v2; // eax
  int v3; // eax
  int v5; // [esp-Ch] [ebp-18h]

  sub_30774(a1);
  v2 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int8)byte_104BEA);
  sub_5CB3C((P_Type5)(a1 + 4), v2, 0, 0xFA, 0x41);
  v5 = (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v3 = sub_1B084((unsigned int)dword_12FC20, 0x21);
  return sub_5CB3C((P_Type5)(a1 + 4), v3, v5, 0xFA, 0x41);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00033AF0) --------------------------------------------------------
__int16 __fastcall sub_33AF0(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4)
{
  int v5; // ebx
  int i; // eax
  unsigned __int16 v7; // bx
  unsigned __int8 *v8; // ebx
  signed int v9; // ebp
  unsigned int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int v13; // edx
  char v14; // al
  int v15; // eax
  unsigned __int8 v16; // al
  unsigned __int16 v17; // bx
  int v18; // eax
  __int16 v19; // ax
  int v21; // [esp+0h] [ebp-1Ch]
  int v22; // [esp+4h] [ebp-18h]
  int v23; // [esp+8h] [ebp-14h]

  if ( *(_DWORD *)(a1 + 0x10) && a2 != *(_WORD *)(a1 + 0x14) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x41);
  }
  v5 = dword_1045B4;
  *(_DWORD *)(a1 + 0x10) = a4;
  if ( !v5 )
  {
    sub_33D30();
  }
  if ( a2 >= 5u )
  {
    *(_WORD *)(a1 + 0x14) = 4;
  }
  else
  {
    *(_WORD *)(a1 + 0x14) = a2;
  }
  *(_WORD *)(a1 + 0x18) = 0;
  for ( i = 0; i < 0xF; ++i )
  {
    v7 = (unsigned __int8)byte_104604[0xF * *(unsigned __int16 *)(a1 + 0x14) + i] + *(_WORD *)(a1 + 0x18);
    *(_WORD *)(a1 + 0x18) = v7;
  }
  if ( v7 > 0x64u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x52);
  }
  *(_WORD *)(a1 + 0x1A) = *(_WORD *)(a1 + 0x18) + 0xA;
  if ( a3 >= 0xBu )
  {
    *(_WORD *)(a1 + 0x16) = 2;
  }
  else
  {
    *(_WORD *)(a1 + 0x16) = a3;
  }
  v8 = (unsigned __int8 *)&unk_104650 + 4 * *(unsigned __int16 *)(a1 + 0x16);
  v9 = 0x7FFF * (unsigned int)*v8 / 0x64;
  v23 = 0x7FFF * (unsigned int)v8[1] / 0x64 + v9;
  v21 = 0x7FFF * (unsigned int)v8[2] / 0x64 + v23;
  v10 = 0x7FFF * (unsigned int)v8[3] / 0x64;
  v11 = 0;
  v12 = 0;
  v22 = v10 + v21;
  v13 = 0;
  while ( v11 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    *(_BYTE *)(v13 + *(_DWORD *)(a1 + 0x10) + 1) = 0xFF;
    *(_WORD *)(v13 + *(_DWORD *)(a1 + 0x10) + 2) = 0;
    v14 = 1;
    if ( v11 < *(unsigned __int16 *)(a1 + 0x18) )
    {
      v15 = rand();
      if ( v15 >= v9 )
      {
        ++v12;
        if ( v15 >= v23 )
        {
          if ( v15 >= v21 )
          {
            if ( v15 >= v22 )
            {
              v14 = 1;
            }
            else
            {
              v14 = 4;
            }
          }
          else
          {
            v14 = 3;
          }
        }
        else
        {
          v14 = 2;
        }
      }
      else
      {
        v14 = 0;
      }
    }
    v13 += 4;
    ++v11;
    *(_BYTE *)(v13 + *(_DWORD *)(a1 + 0x10) - 4) = v14;
  }
  *(_BYTE *)(a1 + 0x66) = 0;
  v16 = *(_BYTE *)(a1 + 0x66);
  *(_WORD *)(a1 + 0x50) = v16;
  *(_WORD *)(a1 + 0x4E) = v16;
  *(_WORD *)(a1 + 0x4C) = v16;
  *(_WORD *)(a1 + 0x48) = v16;
  *(_WORD *)(a1 + 0x46) = v16;
  *(_WORD *)(a1 + 0x44) = v16;
  *(_WORD *)(a1 + 0x42) = v16;
  if ( !(rand() % 7) )
  {
    v17 = *(_WORD *)(a1 + 0x18);
    v18 = rand();
    *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * (v18 % v17)) |= 8u;
    *(_BYTE *)(a1 + 0x66) |= 2u;
  }
  *(_WORD *)(a1 + 0x52) = 0xFFFF;
  *(_BYTE *)(a1 + 0x54) = 0xFF;
  v19 = v12 / 3 + 5;
  *(_WORD *)(a1 + 0x55) = v19;
  *(_WORD *)(a1 + 0x4A) = v19;
  *(_BYTE *)(a1 + 0x57) = 0xFF;
  sub_34E70(a1);
  *(_DWORD *)(a1 + 0x5E) = 0;
  return *(_WORD *)(a1 + 0x1A);
}
// 1045B4: using guessed type int dword_1045B4;

//----- (00033D30) --------------------------------------------------------
FILE *sub_33D30()
{
  FILE *result; // eax
  FILE *v1; // esi
  unsigned int v2; // edi
  int v3; // ebp
  int v4; // edi
  int v5; // edx
  int v6; // ebp
  int i; // edi
  int v8; // edx
  int v9; // ebp
  int j; // edi
  int v11; // edx
  unsigned int v12; // ebp
  signed int v13; // edx
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // edx
  const char *v17; // ebx
  unsigned int v18; // kr04_4
  char v19[200]; // [esp+0h] [ebp-104h] BYREF
  int v20; // [esp+C8h] [ebp-3Ch] BYREF
  int v21; // [esp+CCh] [ebp-38h] BYREF
  int v22; // [esp+D0h] [ebp-34h] BYREF
  char v23; // [esp+D4h] [ebp-30h] BYREF
  char v24; // [esp+D8h] [ebp-2Ch] BYREF
  int v25; // [esp+DCh] [ebp-28h] BYREF
  char v26; // [esp+E0h] [ebp-24h] BYREF
  int *v27; // [esp+E8h] [ebp-1Ch]

  result = sub_1BB10("planitem.txt", 0);
  v1 = result;
  if ( result )
  {
    v2 = 0;
    do
    {
      fgets(v19, 0xC3, v1);
      if ( v19[0] == 0x23 )
      {
        v2 = 0xFFFFFFFF;
      }
    }
    while ( !v2 );
    v3 = 4;
    fscanf(v1, "%d", &v20);
    v4 = 0;
    dword_9684C = v20;
    do
    {
      v5 = 4 * v4;
      do
      {
        fscanf(v1, "%d", &v20);
        byte_10464F[++v5] = v20;
      }
      while ( v5 != v3 );
      ++v4;
      v3 += 4;
    }
    while ( v4 < 0xB );
    v6 = 0xF;
    for ( i = 0; i < 5; ++i )
    {
      v8 = 0xF * i;
      do
      {
        fscanf(v1, "%d", &v20);
        *((_BYTE *)&dword_1045B4 + ++v8 + 3) = v20;
      }
      while ( v8 != v6 );
      v6 += 0xF;
    }
    v9 = 0xF;
    for ( j = 0; j < 5; ++j )
    {
      v11 = 0xF * j;
      do
      {
        fscanf(v1, "%d", &v20);
        byte_104603[++v11] = v20;
      }
      while ( v11 != v9 );
      v9 += 0xF;
    }
    fscanf(v1, "%d %d %d", &v20, &v21, &v22);
    if ( v20 != 0x27 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0xE1);
    }
    word_103F98[0] = v21;
    LOWORD(dword_103F9A[0]) = v22;
    if ( (unsigned __int16)v21 + (unsigned __int16)v22 > 0x27 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0xE6);
    }
    v12 = 0;
    v27 = &dword_103F9A[3];
    do
    {
      v17 = (const char *)v27;
      fscanf(v1, "%s %d %d %d %d %d %d %d", v27, &v20, &v21, &v22, &v23, &v24, &v25, &v26);
      v13 = 0;
      v18 = strlen(v17) + 1;
      v15 = v18 - 1;
      v14 = v12;
      if ( (int)(v18 - 1) > 0 )
      {
        do
        {
          if ( byte_103FA6[v14] == 0x5E )
          {
            byte_103FA6[v14] = 0x20;
          }
          ++v13;
          ++v14;
        }
        while ( v13 < (int)(v18 - 1) );
      }
      BYTE2(dword_103F9A[v12 / 4]) = v20;
      word_103FA2[v12 / 2] = 0;
      HIBYTE(dword_103F9A[v12 / 4]) = v21;
      byte_103F9E[v12] = v22;
      byte_103F9F[v12] = v23;
      byte_103FA0[v12] = v24;
      word_103FA4[v12 / 2] = v25;
      v16 = 0;
      byte_103FA1[v12] = v26;
      do
      {
        fscanf(v1, "%d", &v20);
        if ( v20 == 0xFF )
        {
          break;
        }
        LOWORD(v15) = word_103FA2[v12 / 2];
        v15 |= 1 << v20;
        ++v16;
        word_103FA2[v12 / 2] = v15;
      }
      while ( v16 < 8 );
      v12 += 0x28;
      v27 += 0xA;
    }
    while ( v12 != 0x618 );
    result = (FILE *)fclose(v1);
  }
  dword_1045B4 = 0xFFFFFFFF;
  return result;
}
// 9684C: using guessed type int dword_9684C;
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 103FA4: using guessed type __int16 word_103FA4[];
// 1045B4: using guessed type int dword_1045B4;
// 33D30: using guessed type char var_104[200];

//----- (0003407C) --------------------------------------------------------
int __fastcall sub_3407C(int a1)
{
  int v2; // ebp
  _BYTE *v3; // eax
  unsigned int v4; // kr00_4
  unsigned __int16 v5; // bx
  int v7; // [esp+0h] [ebp-2Ch]
  int v8; // [esp+4h] [ebp-28h]
  unsigned __int16 v9; // [esp+8h] [ebp-24h]
  unsigned __int16 v10; // [esp+Ch] [ebp-20h]
  unsigned __int16 v11; // [esp+10h] [ebp-1Ch]

  v2 = 0;
  v8 = 0;
  v7 = 0;
  while ( *(unsigned __int16 *)(a1 + 0x1A) > v8 && v2 < 0x64 )
  {
    v3 = (_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10));
    if ( (*v3 & 8) == 0
      && (*v3 || byte_A310F[0x1EE * *(unsigned __int8 *)(a1 + 0x57)] == 2)
      && *(_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10) + 1) == 0xFF )
    {
      v4 = sub_35A00(a1, v8);
      v11 = sub_35968(a1, HIWORD(v4) - 1, (unsigned __int16)v4);
      v9 = sub_35968(a1, HIWORD(v4) + 1, (unsigned __int16)v4);
      v10 = sub_35968(a1, HIWORD(v4), (unsigned __int16)v4 - 1);
      v5 = sub_35968(a1, HIWORD(v4), (unsigned __int16)v4 + 1);
      ++v2;
      if ( (v11 == 0xFFFF || (*(_WORD *)(4 * v11 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
        && (v9 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v9 + 2) & 1) == 0)
        && (v10 == 0xFFFF || (*(_WORD *)(4 * v10 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
        && (v5 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v5 + 2) & 1) == 0) )
      {
        --v2;
      }
    }
    v7 += 4;
    ++v8;
  }
  return v2;
}

//----- (0003420C) --------------------------------------------------------
void __fastcall sub_3420C(int a1)
{
  int v2; // ebp
  _BYTE *v3; // esi
  int v4; // eax
  unsigned int v5; // kr00_4
  unsigned __int16 v6; // bx
  int v7; // [esp+0h] [ebp-2Ch]
  int v8; // [esp+4h] [ebp-28h]
  unsigned __int16 v9; // [esp+8h] [ebp-24h]
  unsigned __int16 v10; // [esp+Ch] [ebp-20h]
  unsigned __int16 v11; // [esp+10h] [ebp-1Ch]

  v2 = 0;
  v7 = 0;
  v8 = 0;
  while ( *(unsigned __int16 *)(a1 + 0x1A) > v7 && v2 < 0x64 )
  {
    v3 = (_BYTE *)(v8 + *(_DWORD *)(a1 + 0x10));
    v4 = *v3 & 8;
    if ( (*v3 & 8) == 0 )
    {
      LOBYTE(v4) = *v3;
      if ( !v4 && v3[1] == 0xFF )
      {
        v5 = sub_35A00(a1, v7);
        v10 = sub_35968(a1, HIWORD(v5) - 1, (unsigned __int16)v5);
        v11 = sub_35968(a1, HIWORD(v5) + 1, (unsigned __int16)v5);
        v9 = sub_35968(a1, HIWORD(v5), (unsigned __int16)v5 - 1);
        v6 = sub_35968(a1, HIWORD(v5), (unsigned __int16)v5 + 1);
        ++v2;
        if ( (v10 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v10 + 2) & 1) == 0)
          && (v11 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v11 + 2) & 1) == 0)
          && (v9 == 0xFFFF || (*(_WORD *)(4 * v9 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
          && (v6 == 0xFFFF || (*(_WORD *)(4 * v6 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0) )
        {
          --v2;
        }
      }
    }
    v8 += 4;
    ++v7;
  }
  JUMPOUT(0x341FF);
}
// 3423F: control flows out of bounds to 341FF

//----- (00034368) --------------------------------------------------------
unsigned int __fastcall sub_34368(int a1, unsigned __int8 a2, unsigned __int16 a3)
{
  unsigned int v4; // ebp
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  _BYTE *v8; // eax
  int v9; // eax
  unsigned int v10; // eax
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // bx
  int v14; // [esp+0h] [ebp-30h]
  int v15; // [esp+8h] [ebp-28h]
  unsigned __int16 v16; // [esp+Ch] [ebp-24h]
  unsigned __int16 v17; // [esp+14h] [ebp-1Ch]
  unsigned __int16 v18; // [esp+18h] [ebp-18h]
  unsigned __int16 v19; // [esp+1Ch] [ebp-14h]

  v4 = 0xFFFFFFFF;
  v5 = 0xFFFFFFFF;
  if ( *(unsigned __int8 *)(a1 + 0x57) == 0xFF && a2 != 5 )
  {
    return 0;
  }
  if ( a2 < 0x27u )
  {
    v4 = 0;
    v6 = (unsigned __int8)byte_103FA1[0x28 * a2];
    if ( v6 == 0xFF
      || (unsigned __int16)word_105258 > v6
      && ((1 << *(_BYTE *)(a1 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * v6) >> 0x18)) != 0 )
    {
      v19 = *(_WORD *)(a1 + 0x42) - *(_WORD *)(a1 + 0x4C);
      if ( *(_BYTE *)(a1 + 0x54) != 0xFF )
      {
        v19 += byte_103FA0[0x28 * *(unsigned __int8 *)(a1 + 0x54)];
      }
      if ( v19 >= *(int *)((char *)&dword_103F9A[0xA * a2] + 3) >> 0x18 )
      {
        v4 = 0xFFFFFFFF;
      }
      if ( v4 == 0xFFFFFFFF && a2 == 0x17 )
      {
        v4 = sub_362E0(a1);
      }
    }
    if ( a2 == 5 )
    {
      v4 = 0xFFFFFFFF;
    }
  }
  if ( a3 < *(_WORD *)(a1 + 0x1A) )
  {
    v5 = 0;
    if ( a2 < 0x27u && ((word_103FA2[0x14 * a2] & 1) != 0 || byte_A310F[0x1EE * *(unsigned __int8 *)(a1 + 0x57)] == 2) )
    {
      v5 = 0xFFFFFFFF;
    }
    v14 = 4 * a3;
    v7 = *(unsigned __int8 *)(v14 + *(_DWORD *)(a1 + 0x10));
    if ( *(_BYTE *)(v14 + *(_DWORD *)(a1 + 0x10)) || a2 == 0xFF || (LOBYTE(v7) = a2, (word_103FA2[0x14 * v7] & 2) != 0) )
    {
      v5 = 0xFFFFFFFF;
    }
    if ( a2 != 0xFF && a2 <= 0x1Eu && a3 < *(_WORD *)(a1 + 0x18) != a2 < (int)(unsigned __int16)word_103F98 )
    {
      v5 = 0;
    }
    if ( a2 != 0xFF && ((*(_BYTE *)(4 * a3 + *(_DWORD *)(a1 + 0x10)) & 8) != 0) != (a2 == 0x26) )
    {
      v5 = 0;
    }
    if ( a2 == 0x24 )
    {
      v8 = (_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * a3);
      if ( *v8 || v8[1] != 0xFF )
      {
        v5 = 0;
      }
    }
    if ( a2 == 0x23 )
    {
      v9 = *(_DWORD *)(a1 + 0x10) + 4 * a3;
      if ( (*(_WORD *)(v9 + 2) & 1) == 0 || *(_BYTE *)(v9 + 1) == 0x17 || (*(_WORD *)(v9 + 2) & 2) != 0 )
      {
        v5 = 0;
      }
    }
    if ( a3 < *(_WORD *)(a1 + 0x18)
      && (*(_WORD *)(4 * a3 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0
      && a2 != 5
      && a2 != 0x23 )
    {
      v10 = sub_35A00(a1, a3);
      v11 = v10;
      v15 = HIWORD(v10);
      v16 = sub_35968(a1, HIWORD(v10) - 1, (unsigned __int16)v10);
      v18 = sub_35968(a1, v15 + 1, v11);
      v17 = sub_35968(a1, v15, v11 - 1);
      v12 = sub_35968(a1, v15, v11 + 1);
      if ( (v16 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v16 + 2) & 1) == 0)
        && (v18 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v18 + 2) & 1) == 0)
        && (v17 == 0xFFFF || (*(_WORD *)(4 * v17 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
        && (v12 == 0xFFFF || (*(_WORD *)(4 * v12 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0) )
      {
        v5 = 0;
      }
    }
  }
  if ( v4 && v5 )
  {
    return 0xFFFFFFFF;
  }
  else
  {
    return 0;
  }
}
// 103F98: using guessed type __int16 word_103F98;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 10529F: using guessed type int dword_10529F;

//----- (00034774) --------------------------------------------------------
int __fastcall sub_34774(int result, unsigned __int8 a2, int a3, int a4)
{
  unsigned __int8 v5; // cl
  int v6; // edx
  unsigned __int8 v7; // bl
  unsigned __int16 v8; // si

  if ( a3 != 0xFFFF && *(_BYTE *)(*(_DWORD *)(result + 0x10) + 4 * a3 + 1) == 0xFF )
  {
    if ( a4 == 0xFFFFFFFF )
    {
      v5 = 0;
      v6 = (unsigned __int16)a3;
      v7 = a2;
    }
    else
    {
      v5 = 2;
      v8 = a3;
      v7 = a2;
      v6 = v8;
    }
    return sub_34B0C(result, v6, v7, v5);
  }
  return result;
}

//----- (000347CC) --------------------------------------------------------
int __fastcall sub_347CC(int a1, unsigned __int8 a2)
{
  unsigned __int8 v3; // cl
  int v4; // ebp
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  signed int v8; // edi
  int v9; // ecx
  int v10; // esi
  int v11; // eax
  char v12; // bl
  char v13; // bl
  char v14; // bl
  __int16 v16[101]; // [esp+0h] [ebp-F6h]
  int v17; // [esp+CAh] [ebp-2Ch]
  int v18; // [esp+CEh] [ebp-28h]
  int v19; // [esp+D2h] [ebp-24h]
  int v20; // [esp+D6h] [ebp-20h]
  int v21; // [esp+DAh] [ebp-1Ch]
  unsigned __int8 v22; // [esp+DEh] [ebp-18h]

  v22 = a2;
  v19 = 0xFFFF;
  v3 = *(_BYTE *)(a1 + 0x57);
  v4 = 0;
  v5 = *(int *)((char *)&dword_10529F + 0x4B * (unsigned __int16)word_105258 - 0x4B) >> 0x18;
  v18 = 0;
  if ( ((1 << v3) & v5) != 0 && sub_40664(&byte_A2F72[0x1EE * v3]) == (unsigned __int16)word_105258 )
  {
    v18 = 0xFFFFFFFF;
  }
  v6 = 0;
  v7 = 0;
  v21 = 0;
  while ( v6 < *(unsigned __int16 *)(a1 + 0x1A) && v7 < 0x64 )
  {
    if ( *(_BYTE *)(v21 + *(_DWORD *)(a1 + 0x10) + 1) == 0xFF )
    {
      if ( sub_34368(a1, v22, v6) )
      {
        ++v7;
        ++v4;
        v16[v7] = v6;
      }
    }
    ++v6;
    v21 += 4;
  }
  if ( v4 )
  {
    v8 = 0xFFFFFFFF;
    v9 = 0;
    v20 = 0xFFFFFFFF;
    if ( v4 > 0 )
    {
      v17 = *(_DWORD *)(a1 + 0x10);
      v10 = 0;
      do
      {
        switch ( *(_BYTE *)(v17 + 4 * (unsigned __int16)v16[v10 + 1]) )
        {
          case 2:
            v11 = 0;
            if ( *(int *)((char *)&word_103F98[0x14 * v22] + 1) >> 0x18 > 0 )
            {
              v12 = BYTE2(dword_103F9A[0xA * v22]);
              v11 = 3;
              if ( v12 < SHIBYTE(dword_103F9A[0xA * v22]) || v12 < byte_103F9E[0x28 * v22] )
              {
                v11 = 2;
              }
            }
            break;
          case 3:
            v11 = 0;
            if ( *(int *)((char *)&dword_103F9A[0xA * v22] + 1) >> 0x18 > 0 )
            {
              v13 = byte_103F9E[0x28 * v22];
              v11 = 3;
              if ( v13 < SBYTE2(dword_103F9A[0xA * v22]) || v13 < SHIBYTE(dword_103F9A[0xA * v22]) )
              {
                v11 = 2;
              }
            }
            break;
          case 4:
            if ( v18 )
            {
              goto LABEL_24;
            }
            v11 = 0;
            if ( dword_103F9A[0xA * v22] >> 0x18 > 0 )
            {
              v14 = HIBYTE(dword_103F9A[0xA * v22]);
              v11 = 3;
              if ( v14 < SBYTE2(dword_103F9A[0xA * v22]) || v14 < byte_103F9E[0x28 * v22] )
              {
                v11 = 2;
              }
            }
            break;
          default:
LABEL_24:
            v11 = 1;
            break;
        }
        if ( v11 > v8 )
        {
          v20 = v9;
          v8 = v11;
        }
        ++v9;
        ++v10;
      }
      while ( v9 < v4 );
    }
    if ( v20 >= 0 )
    {
      return (unsigned __int16)v16[v20 + 1];
    }
  }
  return v19;
}
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 10529F: using guessed type int dword_10529F;

//----- (00034A44) --------------------------------------------------------
unsigned __int16 __fastcall sub_34A44(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  unsigned __int16 result; // ax
  int v6; // [esp+0h] [ebp-14h]
  int v7; // [esp+4h] [ebp-10h]

  *a2 = 0;
  *a3 = 0;
  v6 = 0;
  v7 = 0;
  *a4 = 0;
  while ( 1 )
  {
    result = *(_WORD *)(a1 + 0x1A);
    if ( result <= v6 )
    {
      return result;
    }
    if ( *(_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10) + 1) == 0xFF && sub_34368(a1, 0, v6) )
    {
      switch ( *(_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10)) )
      {
        case 2:
          ++*a3;
          break;
        case 3:
          goto LABEL_3;
        case 4:
          ++*a2;
          break;
        default:
          ++*a2;
          ++*a3;
LABEL_3:
          ++*a4;
          break;
      }
    }
    v7 += 4;
    ++v6;
  }
}

//----- (00034AE4) --------------------------------------------------------
int __fastcall sub_34AE4(int a1, unsigned __int8 a2, int a3)
{
  int v5; // ebx

  v5 = sub_347CC(a1, a2);
  sub_34774(a1, a2, v5, a3);
  return v5;
}

//----- (00034B0C) --------------------------------------------------------
unsigned int __fastcall sub_34B0C(int a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  unsigned int v5; // ebp
  int v6; // edi
  unsigned __int8 v8; // dl
  unsigned __int8 v9; // al
  int v10; // edx
  char *v11; // eax
  int v12; // eax
  unsigned __int8 v13; // dl
  int v14; // eax
  int v15; // edx
  int v16; // [esp+0h] [ebp-30h] BYREF
  int v17; // [esp+4h] [ebp-2Ch] BYREF
  int v18; // [esp+8h] [ebp-28h] BYREF
  int v19; // [esp+Ch] [ebp-24h] BYREF
  int v20; // [esp+10h] [ebp-20h] BYREF
  int v21; // [esp+14h] [ebp-1Ch] BYREF
  int v22; // [esp+18h] [ebp-18h]
  int v23; // [esp+1Ch] [ebp-14h]
  unsigned __int8 v24; // [esp+20h] [ebp-10h]

  v23 = a2;
  v24 = a3;
  v5 = 0;
  if ( (unsigned __int16)a2 == 0xFFFF && ((word_103FA2[0x14 * a3] & 2) == 0 || a4 != 2) )
  {
    goto LABEL_42;
  }
  v22 = ((unsigned __int16)v23 < *(_WORD *)(a1 + 0x18)) - 1;
  v6 = *(_DWORD *)(a1 + 0x10);
  if ( (unsigned __int16)v23 != 0xFFFF )
  {
    v6 += 4 * (unsigned __int16)v23;
  }
  if ( !a4 )
  {
    if ( *(_BYTE *)(v6 + 1) == 0xFF && v24 < 0x27u )
    {
      v8 = v24;
      if ( *(unsigned __int16 *)(a1 + 0x42) - *(unsigned __int16 *)(a1 + 0x4C) >= *(int *)((char *)&dword_103F9A[0xA * v24]
                                                                                         + 3) >> 0x18
        && v24 >= (int)(unsigned __int16)word_103F98 == v22 )
      {
        *(_BYTE *)(v6 + 1) = v24;
        *(_WORD *)(v6 + 2) = 1;
        v5 = 0xFFFFFFFF;
        if ( (word_103FA2[0x14 * v8] & 4) != 0 )
        {
          sub_366C8(a1, v8, &v16, &v17, &v18);
          if ( v18 )
          {
            *(_BYTE *)(v6 + 3) = 0;
            *(_WORD *)(v6 + 2) |= (_WORD)v18 << 8;
            sub_34E70(a1);
            return 0xFFFFFFFF;
          }
        }
      }
    }
    goto LABEL_42;
  }
  if ( a4 > 1u )
  {
    if ( a4 > 3u )
    {
      sub_34E70(a1);
      return 0;
    }
    if ( a4 == 3
      || (word_103FA2[0x14 * v24] & 2) != 0
      || sub_34368(a1, v24, v23) && ((*(_WORD *)(v6 + 2) & 1) == 0 || v24 == 0x23 && (*(_WORD *)(v6 + 2) & 2) == 0) )
    {
      v10 = *(unsigned __int16 *)(a1 + 0x52);
      if ( (unsigned __int16)v10 != 0xFFFF )
      {
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * v10 + 1) == 0x17 )
        {
          v11 = sub_35A70(a1, v10);
          sub_49940((int)v11);
        }
        v12 = *(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52);
        if ( (*(_WORD *)(v12 + 2) & 1) == 0 )
        {
          *(_BYTE *)(v12 + 1) = 0xFF;
        }
      }
      v13 = v24;
      v14 = 5 * v24;
      *(_WORD *)(a1 + 0x52) = 0xFFFF;
      if ( (word_103FA2[4 * v14] & 2) == 0 )
      {
        *(_WORD *)(a1 + 0x52) = v23;
        if ( v13 != 0x23 )
        {
          *(_BYTE *)(v6 + 1) = v13;
        }
      }
      v15 = v24;
      *(_BYTE *)(a1 + 0x54) = v24;
      if ( (word_103FA2[0x14 * v15] & 4) != 0 )
      {
        sub_366C8(a1, v15, &v19, &v20, &v21);
        if ( v21 )
        {
          *(_BYTE *)(v6 + 3) = 0;
          *(_WORD *)(v6 + 2) |= (_WORD)v21 << 8;
        }
      }
      sub_34E70(a1);
      return 0xFFFFFFFF;
    }
LABEL_42:
    sub_34E70(a1);
    return v5;
  }
  v9 = *(_BYTE *)(v6 + 1);
  if ( v9 == 0xFF
    || *(int *)((char *)&dword_103F9A[0xA * v9] + 2) >> 0x18 > *(unsigned __int16 *)(a1 + 0x4A)
                                                             - *(unsigned __int16 *)(a1 + 0x42)
    && (*(_WORD *)(v6 + 2) & 1) != 0 )
  {
    goto LABEL_42;
  }
  *(_BYTE *)(v6 + 1) = 0xFF;
  *(_WORD *)(v6 + 2) = 0;
  if ( (_WORD)v23 == *(_WORD *)(a1 + 0x52) )
  {
    *(_WORD *)(a1 + 0x52) = 0xFFFF;
    *(_BYTE *)(a1 + 0x54) = 0xFF;
  }
  sub_34E70(a1);
  return 0xFFFFFFFF;
}
// 103F98: using guessed type __int16 word_103F98;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];

//----- (00034E70) --------------------------------------------------------
unsigned __int16 __fastcall sub_34E70(int a1)
{
  int v2; // ecx
  int v3; // ebp
  int v4; // esi
  unsigned __int8 v5; // dl
  char *v6; // eax
  char v7; // dh
  int v8; // edi
  char v9; // dh
  int v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // eax
  char v14; // dl
  int v15; // eax
  double v16; // st7
  unsigned __int16 v17; // dx
  unsigned __int16 result; // ax
  unsigned __int16 v19; // cx
  char v20; // [esp+10h] [ebp-48h]
  __int16 v21; // [esp+14h] [ebp-44h]
  char v22; // [esp+18h] [ebp-40h]
  __int16 v23; // [esp+1Ch] [ebp-3Ch]
  __int16 v24; // [esp+20h] [ebp-38h]
  __int16 v25; // [esp+24h] [ebp-34h]
  int v26; // [esp+28h] [ebp-30h]
  int v27; // [esp+2Ch] [ebp-2Ch]
  int v28; // [esp+30h] [ebp-28h]
  int v29; // [esp+30h] [ebp-28h]
  int v30; // [esp+34h] [ebp-24h]

  v2 = 0;
  v3 = 0;
  v27 = 0;
  v26 = 0;
  v28 = 0;
  v21 = 0;
  v25 = 0;
  v23 = 0;
  v24 = 0;
  v20 = 0;
  v22 = 0;
  v30 = *(unsigned __int16 *)(a1 + 0x55);
  while ( v3 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v4 = v2 + *(_DWORD *)(a1 + 0x10);
    v5 = *(_BYTE *)(v4 + 1);
    v6 = (char *)&dword_103F9A[0xA * v5] + 2;
    if ( v5 == 0xFF )
    {
      if ( v3 < *(unsigned __int16 *)(a1 + 0x18) )
      {
        if ( (*(_BYTE *)v4 & 8) == 0 )
        {
          ++v25;
          if ( !*(_BYTE *)v4 )
          {
            ++v23;
          }
        }
      }
      else
      {
        ++v24;
      }
    }
    else
    {
      if ( (*(_WORD *)(v4 + 2) & 1) != 0 )
      {
        if ( *v6 )
        {
          v27 += *v6;
          if ( *(_BYTE *)v4 == 2 )
          {
            ++v27;
          }
        }
        v7 = v6[2];
        if ( v7 )
        {
          v8 = v7 + v28;
          v28 = v8;
          if ( *(_BYTE *)(v2 + *(_DWORD *)(a1 + 0x10)) == 3 )
          {
            v28 = v8 + 1;
          }
        }
        v9 = v6[1];
        if ( v9 )
        {
          v10 = v9 + v26;
          v26 = v10;
          if ( *(_BYTE *)(v2 + *(_DWORD *)(a1 + 0x10)) == 4 )
          {
            v26 = v10 + 1;
          }
        }
        if ( (*((_WORD *)v6 + 3) & 4) == 0 || v5 == 0x11 )
        {
          if ( (*((_WORD *)v6 + 3) & 8) != 0 || v5 == 0x11 )
          {
            ++v22;
          }
        }
        else
        {
          ++v20;
        }
        v30 += *(int *)v6 >> 0x18;
      }
      if ( v5 != 0x17 && (*(_WORD *)(v2 + *(_DWORD *)(a1 + 0x10) + 2) & 2) == 0 && (word_103FA2[0x14 * v5] & 0x40) == 0 )
      {
        v21 += v6[4];
      }
    }
    v2 += 4;
    ++v3;
  }
  v11 = (unsigned __int16)sub_35930(a1, 0xC);
  if ( v11 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v11 + 2) & 1) != 0 )
  {
    v27 += v27 >> 1;
  }
  v12 = (unsigned __int16)sub_35930(a1, 0xD);
  if ( v12 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v12 + 2) & 1) != 0 )
  {
    v28 += v28 >> 1;
  }
  v13 = (unsigned __int16)sub_35930(a1, 0xE);
  if ( v13 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v13 + 2) & 1) != 0 )
  {
    v26 += v26 >> 1;
  }
  if ( *(_BYTE *)(a1 + 0x54) != 0xFF )
  {
    v14 = *(_BYTE *)(a1 + 0x54);
    v15 = v27 >> 2;
    switch ( v14 )
    {
      case '!':
        v28 += v15;
        break;
      case '"':
        LOWORD(v26) = v15 + v26;
        break;
      case '#':
        v21 += SHIBYTE(dword_104515);
        break;
    }
  }
  if ( v27 )
  {
    v27 = (int)pow((double)(v27 + 1), 0.85);
  }
  if ( v28 )
  {
    v28 = (int)pow((double)(v28 + 1), 0.85);
  }
  v29 = v28 - ((int)*(unsigned __int16 *)(a1 + 0x42) >> 2);
  if ( v29 < 0 )
  {
    LOWORD(v29) = 0;
  }
  *(_WORD *)(a1 + 0x1C) = v25;
  *(_WORD *)(a1 + 0x20) = v23;
  *(_WORD *)(a1 + 0x1E) = v24;
  *(_WORD *)(a1 + 0x44) = v27;
  *(_WORD *)(a1 + 0x46) = v26;
  if ( (_BYTE)byte_104BEA != *(_BYTE *)(a1 + 0x57) && !dword_A0D00 && byte_A3D20 )
  {
    if ( (unsigned __int8)byte_A3D20 <= 1u )
    {
      *(_WORD *)(a1 + 0x44) = (int)((double)*(unsigned __int16 *)(a1 + 0x44) * dbl_91DB5);
    }
    else if ( byte_A3D20 == 2 )
    {
      v16 = dbl_91DB5;
      *(_WORD *)(a1 + 0x44) = (int)((double)*(unsigned __int16 *)(a1 + 0x44) * dbl_91DB5);
      *(_WORD *)(a1 + 0x46) = (int)(v16 * (double)*(unsigned __int16 *)(a1 + 0x46));
    }
  }
  *(_WORD *)(a1 + 0x48) = v29;
  *(_WORD *)(a1 + 0x4A) = v30;
  *(_WORD *)(a1 + 0x4C) = v21;
  *(_BYTE *)(a1 + 0x58) = v20;
  *(_BYTE *)(a1 + 0x59) = v22;
  if ( *(unsigned __int16 *)(a1 + 0x4A) > 0x64u )
  {
    *(_WORD *)(a1 + 0x4A) = 0x64;
  }
  v17 = *(_WORD *)(a1 + 0x4A);
  if ( *(_WORD *)(a1 + 0x42) > v17 )
  {
    *(_WORD *)(a1 + 0x42) = v17;
  }
  result = *(_WORD *)(a1 + 0x4C);
  v19 = *(_WORD *)(a1 + 0x42);
  if ( result > v19 )
  {
    *(_WORD *)(a1 + 0x4C) = v19;
  }
  return result;
}
// 91DB5: using guessed type double dbl_91DB5;
// A0D00: using guessed type int dword_A0D00;
// A3D20: using guessed type char byte_A3D20;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 104515: using guessed type int dword_104515;

//----- (000352E0) --------------------------------------------------------
int __fastcall sub_352E0(int a1)
{
  int v2; // edi
  int v3; // edx
  unsigned __int8 v4; // ah
  unsigned int v5; // ebp
  int v6; // eax
  unsigned __int16 v7; // dx
  unsigned __int8 v8; // al
  _BYTE *v9; // eax
  char *v10; // eax
  __int16 v11; // ax
  int v12; // edi
  int v13; // ecx
  int v14; // edx
  int i; // eax
  __int16 v16; // bx
  char v17; // bl
  __int16 v18; // di
  char v19; // al
  int v20; // eax
  unsigned __int16 v21; // di
  int result; // eax
  float x_4; // [esp+4h] [ebp-58h]
  float v24; // [esp+8h] [ebp-54h] BYREF
  float v25; // [esp+Ch] [ebp-50h]
  float v26; // [esp+10h] [ebp-4Ch]
  float v27; // [esp+14h] [ebp-48h]
  float v28; // [esp+18h] [ebp-44h]
  float v29; // [esp+1Ch] [ebp-40h]
  int v30; // [esp+2Ch] [ebp-30h] BYREF
  int v31; // [esp+30h] [ebp-2Ch] BYREF
  int v32; // [esp+38h] [ebp-24h] BYREF
  float v33; // [esp+3Ch] [ebp-20h]
  int v34; // [esp+40h] [ebp-1Ch]

  *(_DWORD *)(a1 + 0x62) = 0;
  if ( *(unsigned __int8 *)(a1 + 0x57) != 0xFF )
  {
    v2 = *(_DWORD *)(a1 + 0x10);
    LOWORD(v34) = 0;
    while ( (__int16)v34 < (int)*(unsigned __int16 *)(a1 + 0x1A) )
    {
      if ( *(_BYTE *)(v2 + 1) != 0xFF )
      {
        v3 = *(unsigned __int8 *)(v2 + 1);
        if ( (word_103FA2[0x14 * v3] & 4) != 0 )
        {
          sub_366C8(a1, v3, &v30, &v31, &v32);
          if ( v32 )
          {
            *(_BYTE *)(v2 + 3) = 0;
            *(_WORD *)(v2 + 2) |= (_WORD)v32 << 8;
          }
        }
      }
      v2 += 4;
      LOWORD(v34) = v34 + 1;
    }
    v4 = *(_BYTE *)(a1 + 0x54);
    v5 = 0;
    if ( v4 != 0xFF )
    {
      v6 = 0x14 * v4;
      if ( (word_103FA2[v6] & 0x20) == 0 )
      {
        if ( *(unsigned __int16 *)(a1 + 0x52) == 0xFFFF && (word_103FA2[v6] & 2) == 0 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x3E9);
        }
        v7 = *(_WORD *)(a1 + 0x52);
        *(_WORD *)(a1 + 0x50) += *(_WORD *)(a1 + 0x44);
        if ( (unsigned __int16)sub_3583C(a1, v7, *(_BYTE *)(a1 + 0x54)) > *(_WORD *)(a1 + 0x50) )
        {
          if ( *(_BYTE *)(a1 + 0x54) == 0x1F && !(dword_A2F6C[0] % 0xA) )
          {
            v12 = (unsigned __int8)byte_104BEA;
            v13 = *(unsigned __int16 *)(a1 + 0x44) / 0xA + 1;
            v14 = 0;
            for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
            {
              v16 = word_A3124[v12 + v14];
              v14 += 0xF7;
              *(_WORD *)&V_StaticStrings_dword_A0D04.buffer[2 * v12 + 0x1F12 + v14 * 2] = v13 + v16;
            }
          }
        }
        else
        {
          v8 = *(_BYTE *)(a1 + 0x57);
          if ( v8 == (_BYTE)byte_104BEA
            && *(_BYTE *)(a1 + 0x54) == 2
            && (unsigned __int16)word_106FA6[v8] == 0xFFFF
            && !sub_469F0((int)&word_105258, v8) )
          {
            sub_55AEC((int)&V_Type3_stru_10AE70, 0x19, 0, 0);
          }
          if ( (_BYTE)byte_104BEA == *(_BYTE *)(a1 + 0x57)
            && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11
            && *(_BYTE *)(a1 + 0x54) != 0x17
            && !*(_DWORD *)(a1 + 0x5A) )
          {
            v5 = 0xFFFFFFFF;
            sub_55AEC((int)&V_Type3_stru_10AE70, 1, a1, *(unsigned __int8 *)(a1 + 0x54));
          }
          v9 = (_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52));
          if ( (*v9 & 8) != 0 )
          {
            *v9 &= ~8u;
            *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 1) = 0xFF;
            sub_46A94((unsigned __int16 *)&word_105258, *(unsigned __int8 *)(a1 + 0x57), a1);
          }
          else
          {
            v9[2] |= 1u;
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x17 )
          {
            v10 = sub_35A70(a1, *(_WORD *)(a1 + 0x52));
            if ( !v10 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x415);
            }
            if ( v10[0x58] == 1 )
            {
              *(_WORD *)(a1 + 0x42) -= byte_104338;
            }
            sub_49828((int)v10);
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x24 )
          {
            *(_WORD *)(4 * *(unsigned __int16 *)(a1 + 0x52) + *(_DWORD *)(a1 + 0x10) + 2) = 0;
            *(_BYTE *)(4 * *(unsigned __int16 *)(a1 + 0x52) + *(_DWORD *)(a1 + 0x10) + 1) = 0xFF;
            *(_BYTE *)(4 * *(unsigned __int16 *)(a1 + 0x52) + *(_DWORD *)(a1 + 0x10)) = 1;
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x23 )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 2) |= 2u;
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x25 && (*(_BYTE *)(a1 + 0x66) & 1) == 0 )
          {
            *(_WORD *)(a1 + 0x55) += 0xA;
            *(_BYTE *)(a1 + 0x66) |= 1u;
          }
          if ( (word_103FA2[0x14 * *(unsigned __int8 *)(a1 + 0x54)] & 8) != 0
            && *(_WORD *)(a1 + 0x52) >= *(_WORD *)(a1 + 0x18) )
          {
            v11 = 0xF;
            if ( *(_BYTE *)(a1 + 0x54) == 0x1B )
            {
              v11 = 0x23;
            }
            *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 3) = 0;
            *(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 2) |= v11 << 8;
          }
          *(_WORD *)(a1 + 0x52) = 0xFFFF;
          *(_BYTE *)(a1 + 0x54) = 0xFF;
          *(_WORD *)(a1 + 0x50) = 0;
        }
      }
    }
    if ( *(_WORD *)(a1 + 0x42) < *(_WORD *)(a1 + 0x4A) )
    {
      v17 = byte_104BEA;
      v18 = *(_WORD *)(a1 + 0x48) + *(_WORD *)(a1 + 0x4E);
      v19 = *(_BYTE *)(a1 + 0x57);
      *(_WORD *)(a1 + 0x4E) = v18;
      if ( v19 != v17 && *(unsigned __int16 *)(a1 + 0x48) < 4u )
      {
        *(_WORD *)(a1 + 0x4E) = v18 + 1;
      }
      if ( *(unsigned __int16 *)(a1 + 0x4E) < dword_9684C )
      {
        goto LABEL_71;
      }
      if ( (_BYTE)byte_104BEA == *(_BYTE *)(a1 + 0x57)
        && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11
        && *(_WORD *)(a1 + 0x42) == *(_WORD *)(a1 + 0x4C)
        && !v5
        && !*(_DWORD *)(a1 + 0x5A)
        && (*(_BYTE *)(a1 + 0x54) == 0xFF || (word_103FA2[0x14 * *(unsigned __int8 *)(a1 + 0x54)] & 0x20) != 0) )
      {
        sub_55AEC((int)&V_Type3_stru_10AE70, 0xF, a1, 0);
      }
      ++*(_WORD *)(a1 + 0x42);
      v20 = (unsigned __int16)sub_35930(a1, 0xF);
      if ( v20 != 0xFFFF && (*(_WORD *)(4 * v20 + *(_DWORD *)(a1 + 0x10) + 2) & 1) != 0 )
      {
        ++*(_WORD *)(a1 + 0x42);
      }
      v21 = *(_WORD *)(a1 + 0x4A);
      if ( *(_WORD *)(a1 + 0x42) > v21 )
      {
        *(_WORD *)(a1 + 0x42) = v21;
      }
    }
    *(_WORD *)(a1 + 0x4E) = 0;
LABEL_71:
    sub_34E70(a1);
  }
  v24 = *(float *)a1;
  v25 = *(float *)(a1 + 4);
  v26 = *(float *)(a1 + 8);
  v33 = sqrt(v25 * v25 + v24 * v24 + v26 * v26);
  sub_53000(&v24);
  x_4 = dbl_91DD9 / (v33 * v33);
  sub_532AC(&v24, x_4);
  v27 = v24 * v33;
  v28 = v25 * v33;
  v29 = v26 * v33;
  v25 = v28;
  v26 = v29;
  *(float *)a1 = v27;
  *(float *)(a1 + 4) = v25;
  result = LODWORD(v26);
  *(float *)(a1 + 8) = v26;
  return result;
}
// 91DD9: using guessed type double dbl_91DD9;
// 9684C: using guessed type int dword_9684C;
// A2F6C: using guessed type int dword_A2F6C[];
// A3124: using guessed type __int16 word_A3124[5];
// A3CF2: using guessed type int dword_A3CF2;
// 103FA2: using guessed type __int16 word_103FA2[];
// 104338: using guessed type char byte_104338;
// 106FA6: using guessed type __int16 word_106FA6[7];

//----- (0003583C) --------------------------------------------------------
__int16 __fastcall sub_3583C(int a1, unsigned __int16 a2, unsigned __int8 a3)
{
  __int16 result; // ax
  char *v5; // eax

  result = 0xFFFF;
  if ( a2 != 0xFFFF )
  {
    a3 = *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 1);
  }
  if ( a3 != 0xFF )
  {
    if ( a3 == 0x17 )
    {
      if ( sub_35A70(a1, a2)[0x58] == 2 )
      {
        result = *(_WORD *)(a1 + 0x77);
      }
      else
      {
        v5 = sub_35A70(a1, a2);
        result = sub_4A18C((int)v5);
      }
    }
    else
    {
      result = word_103FA4[0x14 * a3];
    }
    if ( a3 == 0x23 && a2 == *(_WORD *)(a1 + 0x52) )
    {
      result *= 3;
    }
  }
  return result;
}
// 35893: conditional instruction was optimized away because bl.1 is in (<17u|18..FE)
// 103FA4: using guessed type __int16 word_103FA4[];

//----- (000358BC) --------------------------------------------------------
int __fastcall sub_358BC(int a1)
{
  unsigned __int16 v1; // si
  unsigned __int16 v2; // cx
  unsigned __int16 v3; // ax

  v1 = *(_WORD *)(a1 + 0x44);
  v2 = *(_WORD *)(a1 + 0x50);
  v3 = sub_3583C(a1, *(_WORD *)(a1 + 0x52), *(_BYTE *)(a1 + 0x54));
  return sub_46C20(v3, v2, v1);
}

//----- (000358F0) --------------------------------------------------------
int __fastcall sub_358F0(int a1)
{
  __int16 v2; // dx
  int v3; // ebx
  unsigned __int16 v4; // ax
  char v5; // cl

  v2 = *(_WORD *)(a1 + 0x18);
  v3 = 0;
  v4 = 0;
  if ( v2 )
  {
    do
    {
      v5 = *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * v4 + 1);
      if ( v5 != (char)0xFF && v5 != 5 )
      {
        ++v3;
      }
      ++v4;
    }
    while ( v4 < *(_WORD *)(a1 + 0x18) );
  }
  return v3;
}

//----- (00035930) --------------------------------------------------------
int __fastcall sub_35930(int a1, char a2)
{
  __int16 v4; // dx
  int result; // eax

  v4 = *(_WORD *)(a1 + 0x1A);
  result = 0;
  if ( !v4 )
  {
    return 0xFFFF;
  }
  while ( a2 != *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * (unsigned __int16)result + 1) )
  {
    if ( (unsigned __int16)++result >= *(_WORD *)(a1 + 0x1A) )
    {
      return 0xFFFF;
    }
  }
  return result;
}

//----- (00035968) --------------------------------------------------------
int __fastcall sub_35968(int a1, int a2, int a3)
{
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // esi
  int v11; // eax
  int v12; // eax
  int v14; // [esp+4h] [ebp-14h]

  v6 = 0;
  v14 = 0xFFFF;
  if ( a2 >= 0 && a2 < 0xF && a3 >= 0 )
  {
    v7 = 0;
    if ( a2 > 0 )
    {
      v8 = *(unsigned __int16 *)(a1 + 0x14);
      v9 = 0xF * v8;
      do
      {
        LOWORD(v8) = (unsigned __int8)byte_104603[++v9];
        ++v7;
        v6 += v8;
      }
      while ( v7 < a2 );
    }
    v10 = 0xF * *(unsigned __int16 *)(a1 + 0x14) + a2;
    v11 = (unsigned __int8)byte_1045B8[v10];
    if ( a3 >= v11 )
    {
      v12 = (unsigned __int8)byte_104604[v10] + v11;
      if ( a3 < v12 )
      {
        LOWORD(v12) = (unsigned __int8)byte_1045B8[v10];
        return a3 + v6 - v12;
      }
    }
  }
  return v14;
}

//----- (00035A00) --------------------------------------------------------
unsigned int __fastcall sub_35A00(int a1, unsigned __int16 a2)
{
  unsigned int v4; // edi
  int v5; // edi
  int v6; // ecx
  __int16 v7; // si
  unsigned __int16 v8; // ax
  int v9; // edx

  v4 = 0xFFFFFFFF;
  if ( a2 < *(_WORD *)(a1 + 0x18) )
  {
    v5 = 0;
    v6 = 0;
    v7 = *(_WORD *)(a1 + 0x18);
    v8 = 0;
    if ( v7 )
    {
      v9 = 0xF * *(unsigned __int16 *)(a1 + 0x14);
      do
      {
        v5 = (unsigned __int8)byte_1045B8[v9] + a2 - v8;
        v8 += (unsigned __int8)byte_104604[v9];
        if ( v8 > a2 )
        {
          break;
        }
        ++v9;
        ++v6;
      }
      while ( v8 < *(_WORD *)(a1 + 0x18) );
    }
    return (v6 << 0x10) + v5;
  }
  return v4;
}

//----- (00035A70) --------------------------------------------------------
char *__fastcall sub_35A70(int a1, unsigned __int16 a2)
{
  unsigned int v2; // ecx

  if ( a2 >= *(_WORD *)(a1 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x50B);
  }
  v2 = ((int)*(unsigned __int16 *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 2) >> 8) & 0x7F;
  if ( v2 >= 0x6B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x50F);
  }
  if ( *(int *)((char *)&dword_CA245 + 0x162 * (unsigned __int16)v2) >> 0x10 == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x510);
  }
  return (char *)&unk_CA1F1 + 0x162 * (unsigned __int16)v2;
}
// CA245: using guessed type int dword_CA245;

//----- (00035B04) --------------------------------------------------------
unsigned __int16 __fastcall sub_35B04(int a1, unsigned __int16 a2, int a3)
{
  int v4; // edi
  unsigned __int16 result; // ax

  if ( a2 >= *(_WORD *)(a1 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x519);
  }
  if ( a2 < *(_WORD *)(a1 + 0x18) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x51A);
  }
  v4 = (a3 - (int)&unk_CA1F1) / 0x162;
  if ( (unsigned __int16)v4 >= 0x6Bu )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x51E);
  }
  if ( *(int *)((char *)&dword_CA245 + 0x162 * (unsigned __int16)v4) >> 0x10 == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x51F);
  }
  result = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 2) = ((_WORD)v4 << 8) | (unsigned __int8)*(_WORD *)(*(_DWORD *)(a1 + 0x10)
                                                                                                 + 4 * a2
                                                                                                 + 2);
  return result;
}
// CA245: using guessed type int dword_CA245;

//----- (00035BB4) --------------------------------------------------------
unsigned int __fastcall sub_35BB4(int a1, int a2)
{
  int v4; // edx
  int v5; // eax

  if ( *(unsigned __int8 *)(a1 + 0x57) == *(__int16 *)(a2 + 0x56) || !sub_361B8(a1) )
  {
    v4 = *(unsigned __int16 *)(a1 + 0x18);
    v5 = 4 * (unsigned __int16)v4;
    while ( v4 < *(unsigned __int16 *)(a1 + 0x1A) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + v5 + 1) == 0xFF )
      {
        *(_BYTE *)(a2 + 0x58) = 3;
        *(_DWORD *)(a2 + 0x59) = a1;
        *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + v5 + 1) = 0x17;
        *(_WORD *)(*(_DWORD *)(a1 + 0x10) + v5 + 2) = 1;
        sub_35B04(a1, v4, a2);
        return 0xFFFFFFFF;
      }
      v5 += 4;
      ++v4;
    }
  }
  return 0;
}

//----- (00035C38) --------------------------------------------------------
unsigned int __fastcall sub_35C38(int a1, int a2)
{
  int v3; // ecx
  int v4; // esi
  int v5; // eax
  double v6; // st7
  float v8; // [esp+0h] [ebp-40h] BYREF
  float v9; // [esp+4h] [ebp-3Ch]
  float v10; // [esp+8h] [ebp-38h]
  int v11[3]; // [esp+Ch] [ebp-34h] BYREF
  float v12; // [esp+18h] [ebp-28h]
  float v13; // [esp+1Ch] [ebp-24h]
  float v14; // [esp+20h] [ebp-20h]
  int v15; // [esp+24h] [ebp-1Ch]
  int *v16; // [esp+28h] [ebp-18h]

  v3 = *(unsigned __int16 *)(a1 + 0x18);
  v4 = 4 * v3;
  while ( v3 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v5 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_WORD *)(v5 + 2) && *(_BYTE *)(v5 + 1) == 0x17 && sub_35A70(a1, v3) == (char *)a2 )
    {
      *(_BYTE *)(v4 + *(_DWORD *)(a1 + 0x10) + 1) = 0xFF;
      *(_WORD *)(v4 + *(_DWORD *)(a1 + 0x10) + 2) = 0;
      *(_BYTE *)(a2 + 0x58) = 4;
      *(_DWORD *)(a2 + 0x59) = &word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)];
      v8 = (float)(rand() % 0x3E8 - 0x1F4);
      v9 = (float)(rand() % 0x3E8 - 0x1F4);
      v15 = rand() % 0x3E8 - 0x1F4;
      v10 = (float)v15;
      sub_53054(&v8, 250.0);
      v12 = 0.0;
      v13 = 0.0;
      v14 = 0.0;
      v16 = v11;
      v12 = *(float *)a1 + v8;
      v13 = *(float *)(a1 + 4) + v9;
      v6 = *(float *)(a1 + 8);
      *(float *)v11 = v12;
      v14 = v6 + v10;
      *(float *)&v11[1] = v13;
      *(float *)&v11[2] = v14;
      sub_496BC(a2, v11);
      return 0xFFFFFFFF;
    }
    v4 += 4;
    ++v3;
  }
  return 0;
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00035DA4) --------------------------------------------------------
char __fastcall sub_35DA4(int a1)
{
  char v1; // bl
  int v2; // ecx

  v1 = 0xFF;
  if ( (unsigned __int8)byte_1043D9 == 0xFF )
  {
    return 0x1B;
  }
  v2 = 1 << *(_BYTE *)(a1 + 0x57);
  if ( (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_1043D9) >> 0x18)) != 0 )
  {
    return 0x1B;
  }
  if ( (unsigned __int8)byte_1043B1 == 0xFF
    || (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_1043B1) >> 0x18)) != 0 )
  {
    return 0x1A;
  }
  return v1;
}
// 1043B1: using guessed type char byte_1043B1;
// 1043D9: using guessed type char byte_1043D9;
// 10529F: using guessed type int dword_10529F;

//----- (00035E24) --------------------------------------------------------
char __fastcall __spoils<ah> sub_35E24(int a1)
{
  char v1; // dl
  int v2; // ecx

  v1 = 0xFF;
  if ( (unsigned __int8)byte_104451 == 0xFF )
  {
    return 0x1E;
  }
  v2 = 1 << *(_BYTE *)(a1 + 0x57);
  if ( (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104451) >> 0x18)) != 0 )
  {
    return 0x1E;
  }
  if ( (unsigned __int8)byte_104429 == 0xFF
    || (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104429) >> 0x18)) != 0 )
  {
    return 0x1D;
  }
  if ( (unsigned __int8)byte_104401 == 0xFF
    || (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104401) >> 0x18)) != 0 )
  {
    return 0x1C;
  }
  return v1;
}
// 104401: using guessed type char byte_104401;
// 104429: using guessed type char byte_104429;
// 104451: using guessed type char byte_104451;
// 10529F: using guessed type int dword_10529F;

//----- (00035ED8) --------------------------------------------------------
int __fastcall sub_35ED8(int a1)
{
  int v2; // ebp
  int v3; // edi
  unsigned __int8 v4; // al
  int v5; // eax
  char v6; // dl
  int v8; // [esp+Ch] [ebp-34h] BYREF
  int v9; // [esp+10h] [ebp-30h] BYREF
  int v10; // [esp+14h] [ebp-2Ch] BYREF
  float v11; // [esp+18h] [ebp-28h]
  int v12; // [esp+1Ch] [ebp-24h]
  int v13; // [esp+20h] [ebp-20h]
  float v14; // [esp+24h] [ebp-1Ch]

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v14 = -1.0;
  v3 = 4 * v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v5 = v3 + *(_DWORD *)(a1 + 0x10);
    v6 = *(_BYTE *)(v5 + 1);
    v11 = -1.0;
    if ( v6 != (char)0xFF && (*(_WORD *)(v5 + 2) & 1) != 0 )
    {
      v4 = *(_BYTE *)(v5 + 1);
      if ( v4 >= 0x1Cu && v4 <= 0x1Eu )
      {
        v8 = 0;
        v9 = 0;
        v10 = 1;
        sub_366C8(a1, *(_BYTE *)(v3 + *(_DWORD *)(a1 + 0x10) + 1), &v8, &v9, &v10);
        if ( v10 )
        {
          v13 = (int)*(unsigned __int16 *)(v3 + *(_DWORD *)(a1 + 0x10) + 2) >> 8;
        }
        if ( v13 > 0 )
        {
          v12 = 0x20 * v8;
          v11 = (double)(0x20 * v8) * dbl_91E43;
        }
      }
    }
    if ( v11 > (double)v14 )
    {
      v14 = v11;
    }
    v3 += 4;
    ++v2;
  }
  return (int)v14;
}
// 91E43: using guessed type double dbl_91E43;

//----- (00035FE0) --------------------------------------------------------
int __fastcall sub_35FE0(int a1)
{
  int v2; // ebx
  int result; // eax
  int v4; // esi
  unsigned __int8 v5; // dl
  int v6; // edx

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  result = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v6 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v6 + 1) != 0xFF && (*(_WORD *)(v6 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v6 + 1);
      if ( v5 >= 0x1Au )
      {
        if ( v5 <= 0x1Au )
        {
          result += 3;
        }
        else if ( v5 == 0x1B )
        {
          result += 6;
        }
      }
    }
    v4 += 4;
    ++v2;
  }
  return result;
}

//----- (00036050) --------------------------------------------------------
void __fastcall sub_36050(int a1)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  unsigned __int8 v5; // dl
  int v6; // edx

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v3 = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v6 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v6 + 1) != 0xFF && (*(_WORD *)(v6 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v6 + 1);
      if ( v5 < 0x1Du )
      {
        if ( v5 == 0x1C )
        {
          v3 += 2;
        }
      }
      else if ( v5 <= 0x1Du )
      {
        v3 += 4;
      }
      else if ( v5 == 0x1E )
      {
        v3 += 6;
      }
    }
    v4 += 4;
    ++v2;
  }
  JUMPOUT(0x36045);
}
// 3609C: control flows out of bounds to 36045

//----- (000360D8) --------------------------------------------------------
void __fastcall sub_360D8(int a1)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  int v5; // edx

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v3 = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v5 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v5 + 1) != 0xFF && (*(_WORD *)(v5 + 2) & 1) != 0 )
    {
      switch ( *(_BYTE *)(v5 + 1) )
      {
        case 0x1A:
          ++v3;
          break;
        case 0x1B:
        case 0x1C:
          v3 += 2;
          break;
        case 0x1D:
          v3 += 4;
          break;
        case 0x1E:
          v3 += 6;
          break;
        default:
          break;
      }
    }
    v4 += 4;
    ++v2;
  }
  JUMPOUT(0x36045);
}
// 3610E: control flows out of bounds to 36045

//----- (00036158) --------------------------------------------------------
void __fastcall sub_36158(int a1)
{
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  unsigned __int8 v5; // dl
  int v6; // edx

  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( v3 < *(unsigned __int16 *)(a1 + 0x18) )
  {
    v6 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v6 + 1) != 0xFF && (*(_WORD *)(v6 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v6 + 1);
      if ( v5 >= 0x12u )
      {
        if ( v5 <= 0x12u )
        {
          v2 += 2;
        }
        else if ( v5 == 0x13 )
        {
          v2 += 4;
        }
      }
    }
    v4 += 4;
    ++v3;
  }
  JUMPOUT(0x36045);
}
// 3618F: control flows out of bounds to 36045

//----- (000361B8) --------------------------------------------------------
unsigned int __fastcall sub_361B8(int a1)
{
  int v2; // ecx
  int v3; // edi
  int v4; // esi
  int v5; // eax
  char v6; // dl

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v3 = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v5 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v5 + 1) != 0xFF && (*(_WORD *)(v5 + 2) & 1) != 0 )
    {
      if ( *(_BYTE *)(v5 + 1) == 0x17 && *((_WORD *)sub_35A70(a1, v2) + 0x2B) == *(unsigned __int8 *)(a1 + 0x57) )
      {
        return 0xFFFFFFFF;
      }
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 0x10) + 1);
      if ( v6 == 0x1A || v6 == 0x1B )
      {
        return 0xFFFFFFFF;
      }
    }
    v4 += 4;
    ++v2;
  }
  return v3;
}

//----- (0003623C) --------------------------------------------------------
unsigned int __fastcall sub_3623C(int a1)
{
  unsigned int v2; // ebp
  int v3; // edi
  int v4; // eax
  char v5; // dh
  int i; // [esp+0h] [ebp-1Ch]

  v2 = 0;
  v3 = 0;
  for ( i = 0; *(unsigned __int16 *)(a1 + 0x18) > i; ++i )
  {
    v4 = v3 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v4 + 1) != 0xFF && (*(_WORD *)(v4 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v4 + 1);
      if ( v5 == 2 || v5 == 8 )
      {
        if ( sub_34B0C(a1, (unsigned __int16)i, *(_BYTE *)(v3 + *(_DWORD *)(a1 + 0x10) + 1), 1u) )
        {
          v2 = 0xFFFFFFFF;
        }
      }
    }
    v3 += 4;
  }
  return v2;
}

//----- (000362C8) --------------------------------------------------------
int __fastcall sub_362C8(int a1, _DWORD *a2)
{
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = a2[1];
  *(_DWORD *)(a1 + 8) = a2[2];
  return sub_53440((float *)a1);
}

//----- (000362E0) --------------------------------------------------------
unsigned int __fastcall sub_362E0(int a1)
{
  int v2; // ebx
  int v3; // eax

  if ( *(unsigned __int8 *)(a1 + 0x57) >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x688);
  }
  v2 = 0;
  v3 = (unsigned __int16)sub_35930(a1, 0x16);
  if ( v3 != 0xFFFF
    && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v3 + 2) & 1) != 0
    && (int)sub_3EFE0((int)&byte_A2F72[0x1EE * *(unsigned __int8 *)(a1 + 0x57)]) > 0 )
  {
    return 0xFFFFFFFF;
  }
  return v2;
}
// A3CF2: using guessed type int dword_A3CF2;

//----- (0003636C) --------------------------------------------------------
void __fastcall sub_3636C(int a1, int a2)
{
  _BYTE *v4; // edx
  __int16 v5; // bx
  int v6; // eax

  v4 = *(_BYTE **)(a1 + 0x10);
  v5 = 0;
  v6 = 0;
  while ( v5 < (int)*(unsigned __int16 *)(a1 + 0x18) )
  {
    if ( (unsigned __int8)*v4 < 2u )
    {
      if ( *v4 )
      {
        ++v6;
      }
      else if ( a2 )
      {
        ++v6;
      }
    }
    else
    {
      v6 += 2;
    }
    ++v5;
    v4 += 4;
  }
  JUMPOUT(0x35D9B);
}
// 36399: control flows out of bounds to 35D9B

//----- (000363B0) --------------------------------------------------------
int __fastcall sub_363B0(int a1)
{
  unsigned __int16 v2; // ax
  int v3; // edi
  int v4; // edx
  int v5; // ebx
  int i; // eax
  int v7; // ecx
  int v8; // edi

  if ( *(unsigned __int8 *)(a1 + 0x57) > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x6CD);
  }
  sub_3636C(a1, (byte_A310F[0x1EE * *(unsigned __int8 *)(a1 + 0x57)] != 2) - 1);
  v3 = (*(unsigned __int16 *)(a1 + 0x4A) - *(unsigned __int16 *)(a1 + 0x42)) / 2
     + *(unsigned __int16 *)(a1 + 0x42)
     + *(unsigned __int16 *)(a1 + 0x46)
     + *(unsigned __int16 *)(a1 + 0x48)
     + *(unsigned __int16 *)(a1 + 0x44)
     + v2;
  if ( (*(_BYTE *)(a1 + 0x66) & 2) != 0 )
  {
    v3 += 0x64;
  }
  v4 = *(_DWORD *)(a1 + 0x10);
  v5 = 0;
  for ( i = 0; i < *(unsigned __int16 *)(a1 + 0x1A); ++i )
  {
    v7 = (unsigned __int16)word_103FA4[0x14 * *(unsigned __int8 *)(v4 + 1)];
    v4 += 4;
    v5 += v7;
  }
  v8 = v5 + v3;
  if ( (unsigned __int16)sub_35930(a1, 0x16) )
  {
    v8 += 0x32;
  }
  if ( (unsigned __int16)sub_35930(a1, 0x18) )
  {
    v8 += 0x32;
  }
  if ( v8 < 0 )
  {
    return 0;
  }
  return v8;
}
// 36405: variable 'v2' is possibly undefined
// A3CF2: using guessed type int dword_A3CF2;
// 103FA4: using guessed type __int16 word_103FA4[];

//----- (000364B4) --------------------------------------------------------
int __fastcall sub_364B4(int a1, __int16 a2)
{
  char *v3; // ebx
  int v4; // eax
  unsigned __int16 v5; // ax
  unsigned int v6; // esi
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  int i; // edx
  int v11; // esi
  int v12; // ebx
  int j; // edx
  int v14; // esi
  int v15; // edi
  int v16; // eax
  int v18; // [esp+0h] [ebp-1Ch]
  unsigned int v19; // [esp+4h] [ebp-18h]

  if ( a2 > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x71A);
  }
  v3 = &byte_A2F72[0x1EE * a2];
  v4 = *(unsigned __int8 *)(a1 + 0x57);
  v18 = 0;
  if ( v4 == 0xFF || a2 != v4 && v3[v4 + 0x1C0] == 2 )
  {
    sub_3636C(a1, (byte_A310F[0x1EE * a2] != 2) - 1);
    v18 = v5;
    if ( (*(_BYTE *)(a1 + 0x66) & 2) != 0 )
    {
      v18 = v5 + 0x28;
    }
    if ( v18 > 0x46 || v3[*(unsigned __int8 *)(a1 + 0x57) + 0x1C0] == 2 )
    {
      if ( v3[*(unsigned __int8 *)(a1 + 0x57) + 0x1C0] != 2 )
      {
        goto LABEL_30;
      }
      v6 = 0;
      v7 = (*(unsigned __int16 *)(a1 + 0x4A) - *(unsigned __int16 *)(a1 + 0x42)) / 2
         + *(unsigned __int16 *)(a1 + 0x42)
         + *(unsigned __int16 *)(a1 + 0x46)
         + *(unsigned __int16 *)(a1 + 0x48)
         + *(unsigned __int16 *)(a1 + 0x44);
      v19 = 0;
      if ( (unsigned __int16)sub_35930(a1, 0xB) != 0xFFFF )
      {
        v6 = 0xFFFFFFFF;
      }
      if ( (unsigned __int16)sub_35930(a1, 0x19) != 0xFFFF )
      {
        v19 = 0xFFFFFFFF;
      }
      v8 = *(_DWORD *)(a1 + 0x10);
      v9 = 0;
      if ( !v6 )
      {
        for ( i = 0; i < *(unsigned __int16 *)(a1 + 0x18); ++i )
        {
          v11 = (unsigned __int16)word_103FA4[0x14 * *(unsigned __int8 *)(v8 + 1)];
          v8 += 4;
          v9 += v11;
        }
      }
      if ( !v19 )
      {
        v12 = *(_DWORD *)(a1 + 0x10);
        for ( j = *(unsigned __int16 *)(a1 + 0x18); j < *(unsigned __int16 *)(a1 + 0x1A); ++j )
        {
          v14 = (unsigned __int16)word_103FA4[0x14 * *(unsigned __int8 *)(v12 + 1)];
          v12 += 4;
          v9 += v14;
        }
      }
      v15 = v9 + v7;
      if ( (unsigned __int16)sub_35930(a1, 0x16) )
      {
        v15 += 0x32;
      }
      if ( (unsigned __int16)sub_35930(a1, 0x18) )
      {
        v15 += 0x32;
      }
      v16 = 2 * (v15 / 0xA + v18);
    }
    else
    {
      v16 = 0;
    }
    v18 = v16;
  }
LABEL_30:
  if ( v18 < 0 )
  {
    return 0;
  }
  return v18;
}
// 3654C: variable 'v5' is possibly undefined
// A3CF2: using guessed type int dword_A3CF2;
// 103FA4: using guessed type __int16 word_103FA4[];

//----- (000366C8) --------------------------------------------------------
int __fastcall sub_366C8(int a1, char a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int result; // eax

  if ( !a3 || !a4 || !a5 )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x785);
  }
  BYTE1(result) = a2;
  switch ( a2 )
  {
    case 0x1C:
      *a3 = 0x2D;
      *a4 = 7;
      *a5 = 1;
      break;
    case 0x1D:
      *a3 = 0x2D;
      *a4 = 7;
      *a5 = 3;
      break;
    case 0x1E:
      *a3 = 0x5A;
      *a4 = 8;
      *a5 = 3;
      break;
    case 0x11:
      *a3 = 0xC8;
      *a4 = 0;
      *a5 = 2;
      break;
  }
  return result;
}

//----- (0003676C) --------------------------------------------------------
int __fastcall sub_3676C(int a1, int a2)
{
  int v3; // eax
  int v4; // edi
  double v5; // st7
  BOOL v6; // eax
  int v7; // eax
  double v8; // st7
  double v9; // st7
  int v10; // eax
  int result; // eax
  float v12; // [esp+8h] [ebp-8Ch]
  float v13; // [esp+Ch] [ebp-88h]
  float v14; // [esp+10h] [ebp-84h]
  float v15; // [esp+14h] [ebp-80h] BYREF
  float v16; // [esp+18h] [ebp-7Ch]
  float v17; // [esp+1Ch] [ebp-78h]
  float v18; // [esp+20h] [ebp-74h] BYREF
  float v19; // [esp+24h] [ebp-70h]
  float v20; // [esp+28h] [ebp-6Ch]
  int v21[3]; // [esp+2Ch] [ebp-68h] BYREF
  float v22; // [esp+38h] [ebp-5Ch]
  float v23; // [esp+3Ch] [ebp-58h]
  float v24; // [esp+40h] [ebp-54h]
  float v25; // [esp+44h] [ebp-50h]
  float v26; // [esp+48h] [ebp-4Ch]
  float v27; // [esp+4Ch] [ebp-48h]
  int *v28; // [esp+50h] [ebp-44h]
  int v29; // [esp+54h] [ebp-40h]
  int v30[3]; // [esp+58h] [ebp-3Ch] BYREF
  int v31; // [esp+64h] [ebp-30h] BYREF
  int v32[2]; // [esp+68h] [ebp-2Ch] BYREF
  int v33; // [esp+70h] [ebp-24h]
  float v34; // [esp+74h] [ebp-20h]
  int v35; // [esp+78h] [ebp-1Ch]
  int v36; // [esp+7Ch] [ebp-18h]

  v3 = *(_DWORD *)(a1 + 0x6B);
  v36 = 0;
  LOBYTE(v3) = *(_BYTE *)(v3 + 1);
  v33 = 0xFFFFFFFF;
  if ( (_BYTE)v3 == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x7AB);
  }
  v4 = *(_DWORD *)(a1 + 0x6F);
  v31 = 0;
  v32[0] = 0;
  v30[0] = 1;
  sub_366C8(a1, *(_BYTE *)(*(_DWORD *)(a1 + 0x6B) + 1), &v31, v32, v30);
  if ( v4 )
  {
    if ( *(_BYTE *)(v4 + 0x58) != 4 || &word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)] != *(__int16 **)(v4 + 0x59) )
    {
      v33 = 0;
    }
    if ( v31 > 0 )
    {
      v28 = v21;
      v25 = 0.0;
      v26 = 0.0;
      v27 = 0.0;
      v25 = *(float *)(v4 + 0x9E) - *(float *)a1;
      v26 = *(float *)(v4 + 0xA2) - *(float *)(a1 + 4);
      v27 = *(float *)(v4 + 0xA6) - *(float *)(a1 + 8);
      *(float *)v21 = v25;
      *(float *)&v21[1] = v26;
      *(float *)&v21[2] = v27;
      v5 = sqrt(v26 * v26 + v25 * v25 + v27 * v27);
      v29 = 0x20 * v31;
      if ( (double)(0x20 * v31) < v5 )
      {
        v33 = 0;
      }
    }
  }
  v35 = 1;
  if ( v30[0] )
  {
    v35 = (int)*(unsigned __int16 *)(*(_DWORD *)(a1 + 0x6B) + 2) >> 8;
  }
  v6 = v33 && v35;
  v36 |= v6;
  if ( (v36 & 1) != 0 )
  {
    if ( v32[0] )
    {
      v7 = sub_4B7A0(v4, a2, v32[0], *(unsigned __int8 *)(a1 + 0x57));
      v36 |= v7;
    }
    if ( a2 == 1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0x6B) + 1) == 0x11 )
      {
        v30[2] = (int)&v18;
        v12 = *(float *)(v4 + 0x9E) - *(float *)a1;
        v13 = *(float *)(v4 + 0xA2) - *(float *)(a1 + 4);
        v14 = *(float *)(v4 + 0xA6) - *(float *)(a1 + 8);
        v18 = v12;
        v19 = v13;
        v20 = v14;
        v8 = sqrt(v13 * v13 + v12 * v12 + v14 * v14) + flt_91E91;
        v34 = v8;
        if ( v8 < flt_91E95 )
        {
          v34 = 1280.0;
        }
        sub_53054(&v18, v34);
        v22 = 0.0;
        v23 = 0.0;
        v24 = 0.0;
        v32[1] = (int)&v15;
        v22 = *(float *)a1 + v18;
        v23 = *(float *)(a1 + 4) + v19;
        v9 = *(float *)(a1 + 8);
        v15 = v22;
        v24 = v9 + v20;
        v16 = v23;
        v17 = v24;
        *(float *)(v4 + 0x9E) = v22;
        *(float *)(v4 + 0xA2) = v16;
        *(float *)(v4 + 0xA6) = v17;
      }
      if ( v30[0] && v35 > 0 )
      {
        v10 = *(_DWORD *)(a1 + 0x6B);
        --v35;
        *(_BYTE *)(v10 + 3) = 0;
        *(_WORD *)(*(_DWORD *)(a1 + 0x6B) + 2) |= (_WORD)v35 << 8;
      }
    }
  }
  result = v36;
  *(_DWORD *)(a1 + 0x73) = v36;
  return result;
}
// 91E91: using guessed type float flt_91E91;
// 91E95: using guessed type float flt_91E95;
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00036A5C) --------------------------------------------------------
__int16 __fastcall sub_36A5C(int a1, int a2, __int16 a3)
{
  int v3; // esi
  int v4; // edx
  int v5; // eax
  unsigned __int16 v6; // cx
  int v7; // edi
  int v8; // ebx
  int v9; // ecx
  unsigned __int16 v10; // di
  int v11; // ebp
  int v12; // edx
  int v13; // eax
  __int16 v14; // ecx^2
  int v15; // ebx
  char *v16; // eax
  __int16 v18[10]; // [esp+0h] [ebp-30h]
  int v19; // [esp+14h] [ebp-1Ch]
  int v20; // [esp+18h] [ebp-18h]
  int v21; // [esp+1Ch] [ebp-14h]

  v3 = a1;
  v19 = a2;
  LOWORD(v21) = a3;
  if ( *(_DWORD *)(a1 + 0x62) != 0xFFFFFFFF )
  {
    if ( *(unsigned __int8 *)(a1 + 0x57) >= SHIWORD(dword_A3CF2) && *(unsigned __int8 *)(a1 + 0x57) != 0xFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x7FE);
    }
    if ( (v21 & 0x8000u) != 0 || (LOWORD(a1) = v21, (__int16)v21 >= SHIWORD(dword_A3CF2)) )
    {
      LOWORD(a1) = 0;
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x7FF);
    }
    v4 = *(unsigned __int8 *)(v3 + 0x57);
    if ( v4 != 0xFF )
    {
      v5 = 0x1EE * v4;
      v4 = (__int16)v21;
      LOWORD(a1) = sub_433E0((int)&byte_A2F72[v5], v21, (int)&word_A3D21[0x30 * *(__int16 *)(v3 + 0xC)]);
    }
    LOWORD(v4) = *(_WORD *)(v3 + 0x18);
    v6 = *(_WORD *)(v3 + 0x1A);
    v7 = 0;
    v20 = 0xFFFF;
    if ( (unsigned __int16)v4 < v6 )
    {
      a1 = 0;
      do
      {
        v8 = 4 * (unsigned __int16)v4;
        if ( *(_BYTE *)(v8 + *(_DWORD *)(v3 + 0x10) + 1) != 0xFF )
        {
          *(__int16 *)((char *)v18 + a1) = v4;
          if ( (word_103FA2[0x14 * *(unsigned __int8 *)(*(_DWORD *)(v3 + 0x10) + v8 + 1)] & 8) != 0
            && (_WORD)v4 != *(_WORD *)(v3 + 0x52) )
          {
            v20 = v4;
          }
          a1 += 2;
          ++v7;
        }
        ++v4;
      }
      while ( (unsigned __int16)v4 < *(_WORD *)(v3 + 0x1A) );
    }
    if ( v7 )
    {
      v9 = 0xFFFFFFFF;
      if ( (unsigned __int16)v20 == 0xFFFF )
      {
        v10 = v18[rand() % v7];
      }
      else
      {
        v10 = v20;
        v11 = 4 * (unsigned __int16)v20;
        v12 = v11 + *(_DWORD *)(v3 + 0x10);
        v13 = ((int)*(unsigned __int16 *)(v12 + 2) >> 8) - v19;
        if ( v13 > 0 && (_WORD)v20 != *(_WORD *)(v3 + 0x52) )
        {
          *(_BYTE *)(v12 + 3) = 0;
          *(_WORD *)(*(_DWORD *)(v3 + 0x10) + v11 + 2) |= (_WORD)v13 << 8;
          v9 = 0;
        }
      }
      if ( *(_BYTE *)(*(_DWORD *)(v3 + 0x10) + 4 * v10 + 1) == 0x17 )
      {
        v14 = v21;
        v15 = v19;
        v16 = sub_35A70(v3, v10);
        v9 = ((sub_4B7A0((int)v16, 1, 2 * v15, v14) & 4) == 0) - 1;
      }
      if ( *(_WORD *)(v3 + 0x4A) < *(_WORD *)(v3 + 0x42) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x837);
      }
      if ( *(int *)((char *)&dword_103F9A[0xA * *(unsigned __int8 *)(*(_DWORD *)(v3 + 0x10) + 4 * v10 + 1)] + 2) >> 0x18 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x838);
      }
      if ( v9 == 0xFFFFFFFF )
      {
        sub_34B0C(v3, v10, 0xFFu, 1u);
        if ( *(_BYTE *)(*(_DWORD *)(v3 + 0x10) + 4 * v10 + 1) != 0xFF )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x83D);
        }
        if ( v10 == *(_WORD *)(v3 + 0x52) )
        {
          *(_WORD *)(v3 + 0x52) = 0xFFFF;
          *(_BYTE *)(v3 + 0x54) = 0xFF;
          *(_WORD *)(v3 + 0x50) = 0;
        }
      }
      LOWORD(a1) = sub_34E70(v3);
    }
  }
  return a1;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 36A5C: using guessed type __int16 var_30[10];

//----- (00036CD4) --------------------------------------------------------
unsigned int __fastcall sub_36CD4(int a1, unsigned __int16 a2, int *a3)
{
  char *v5; // eax
  int v6; // edx
  char *v7; // ebp
  int v8; // eax
  int v9; // edx
  __int16 v10; // di
  __int16 i; // ax
  __int16 j; // ax
  int v13; // edx
  int v14; // edx
  int v15; // edi
  __int16 v16; // bx
  int v17; // edi
  int v18; // eax
  int v19; // eax
  unsigned int v21; // [esp+0h] [ebp-30h]
  int v22; // [esp+4h] [ebp-2Ch]
  int v23; // [esp+8h] [ebp-28h]
  unsigned int v24; // [esp+Ch] [ebp-24h]
  int v25; // [esp+10h] [ebp-20h]
  int v26; // [esp+14h] [ebp-1Ch]
  unsigned __int16 m; // [esp+18h] [ebp-18h]
  unsigned __int16 k; // [esp+1Ch] [ebp-14h]

  v24 = 0;
  if ( a2 >= *(_WORD *)(a1 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x851);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 1) != 0x17 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x852);
  }
  v5 = sub_35A70(a1, a2);
  v6 = *(unsigned __int8 *)(a1 + 0x57);
  v7 = v5;
  if ( v6 == 0xFF || v6 == *((__int16 *)v5 + 0x2B) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x856);
  }
  v21 = 0;
  if ( !byte_A310F[0x1EE * *((__int16 *)v5 + 0x2B)] )
  {
    v21 = 0xFFFFFFFF;
  }
  if ( sub_433E0(
         (int)&byte_A2F72[0x1EE * *(unsigned __int8 *)(a1 + 0x57)],
         *((_WORD *)v5 + 0x2B),
         (int)&word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)]) == 0xFFFFFFFF )
  {
    v8 = 0x1EE * *(unsigned __int8 *)(a1 + 0x57);
    v9 = v8 + 2 * *((__int16 *)v7 + 0x2B);
    v10 = *(_WORD *)((char *)&dword_A313B + v8);
    if ( v10 < *(__int16 *)((char *)word_A3124 + v9) )
    {
      *(__int16 *)((char *)word_A3124 + v9) = v10 - 0xA;
    }
  }
  v25 = 0;
  v22 = 0;
  for ( i = 0; i < *(_DWORD *)(v7 + 0x15A); ++i )
  {
    if ( v7[7 * i + 0xAB] == 0x49 )
    {
      ++v25;
    }
  }
  for ( j = 0; j < (int)*(unsigned __int16 *)(a1 + 0x18); ++j )
  {
    v14 = *(_DWORD *)(a1 + 0x10) + 4 * j;
    if ( *(_BYTE *)(v14 + 1) == 0x12 && (*(_WORD *)(v14 + 2) & 1) != 0 )
    {
      ++v22;
    }
    else
    {
      v13 = *(_DWORD *)(a1 + 0x10) + 4 * j;
      if ( *(_BYTE *)(v13 + 1) == 0x13 && (*(_WORD *)(v13 + 2) & 1) != 0 )
      {
        v22 += 2;
      }
    }
  }
  v26 = v25;
  if ( v25 > v22 )
  {
    v26 = v22 + 1;
  }
  v23 = v26;
  if ( v21 == 0xFFFFFFFF )
  {
    v23 = 1;
  }
  v15 = 0;
  v16 = 0;
  *a3 = v23;
  while ( v16 < *(_DWORD *)(v7 + 0x15A) && v15 < v23 )
  {
    if ( v7[7 * v16 + 0xAB] == 0x49 )
    {
      ++v15;
      sub_492F8(v7, v16);
    }
    ++v16;
  }
  sub_496E0(v7);
  v17 = 0;
  for ( k = 0; (__int16)k < (int)*(unsigned __int16 *)(a1 + 0x18) && v17 < v26; ++k )
  {
    v18 = 4 * (__int16)k + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v18 + 1) == 0x12 && (*(_WORD *)(v18 + 2) & 1) != 0 )
    {
      ++v17;
      sub_34B0C(a1, k, 0xFFu, 1u);
    }
  }
  for ( m = 0; (__int16)m < (int)*(unsigned __int16 *)(a1 + 0x18) && v17 < v26; ++m )
  {
    v19 = *(_DWORD *)(a1 + 0x10) + 4 * (__int16)m;
    if ( *(_BYTE *)(v19 + 1) == 0x13 && (*(_WORD *)(v19 + 2) & 1) != 0 )
    {
      v17 += 2;
      if ( v17 <= v26 )
      {
        sub_34B0C(a1, m, 0xFFu, 1u);
      }
    }
  }
  if ( v25 > v22 || v21 == 0xFFFFFFFF )
  {
    if ( *(_BYTE *)(a1 + 0x57) == (_BYTE)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10 )
    {
      sub_55AEC((int)&V_Type3_stru_10AE70, 0xD, a1, 0);
    }
    sub_1D234((int)&word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)], a1, *((_WORD *)v7 + 0x2B));
    v24 = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x67) = dword_A2F6C;
  }
  sub_34E70(a1);
  return v24;
}
// A2F6C: using guessed type int dword_A2F6C;
// A3124: using guessed type __int16 word_A3124[5];
// A313B: using guessed type int dword_A313B;
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00037040) --------------------------------------------------------
unsigned __int16 __fastcall sub_37040(int a1)
{
  int v2; // edx
  int v3; // eax
  int v4; // esi

  sub_1D234((int)&word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)], a1, 0xFFFFFFFF);
  v2 = 0;
  v3 = 0;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v4 = v3 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v4 + 1) != 0x17 )
    {
      *(_BYTE *)(v4 + 1) = 0xFF;
      *(_WORD *)(*(_DWORD *)(a1 + 0x10) + v3 + 2) = 0;
    }
    v3 += 4;
    ++v2;
  }
  *(_WORD *)(a1 + 0x4C) = 0;
  *(_WORD *)(a1 + 0x42) = *(_WORD *)(a1 + 0x4C);
  *(_BYTE *)(a1 + 0x57) = 0xFF;
  return sub_34E70(a1);
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (000370B8) --------------------------------------------------------
unsigned int __fastcall sub_370B8(int a1, unsigned int count, int a3)
{
  unsigned int result; // eax
  int v5; // [esp+0h] [ebp-8Ch] BYREF
  int v6; // [esp+4h] [ebp-88h]
  int v7; // [esp+8h] [ebp-84h]
  int v8; // [esp+Ch] [ebp-80h]
  int v9; // [esp+10h] [ebp-7Ch]
  int v10; // [esp+14h] [ebp-78h]
  __int16 v11; // [esp+18h] [ebp-74h]
  int v12; // [esp+1Ah] [ebp-72h]
  int v13; // [esp+1Eh] [ebp-6Eh]
  __int16 v14; // [esp+22h] [ebp-6Ah]
  char v15[28]; // [esp+24h] [ebp-68h] BYREF
  __int16 v16; // [esp+40h] [ebp-4Ch]
  int v17; // [esp+42h] [ebp-4Ah]
  int v18; // [esp+46h] [ebp-46h]
  int v19; // [esp+4Ah] [ebp-42h]
  int v20; // [esp+4Eh] [ebp-3Eh]
  char v21[5]; // [esp+52h] [ebp-3Ah]
  char v22; // [esp+57h] [ebp-35h]
  char v23; // [esp+58h] [ebp-34h]
  char v24; // [esp+59h] [ebp-33h]
  int v25; // [esp+5Ah] [ebp-32h]
  int v26; // [esp+5Eh] [ebp-2Eh]
  int v27; // [esp+62h] [ebp-2Ah]
  char v28; // [esp+66h] [ebp-26h]
  int v29; // [esp+67h] [ebp-25h]
  int v30; // [esp+6Bh] [ebp-21h]
  int v31; // [esp+6Fh] [ebp-1Dh]
  int v32; // [esp+73h] [ebp-19h]
  int v33; // [esp+77h] [ebp-15h]

  if ( a3 != 0xFFFFFFFF )
  {
    return sub_1C098(count, a1, 0x7Bu);
  }
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v9 = 0;
  v25 = 0;
  LOWORD(v12) = 0;
  sub_1BF94((P_Type1)count, &v5, 0x7Bu);
  *(_DWORD *)a1 = v5;
  *(_DWORD *)(a1 + 4) = v6;
  *(_DWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 0xC) = v8;
  *(_DWORD *)(a1 + 0x10) = v9;
  *(_DWORD *)(a1 + 0x14) = v10;
  *(_WORD *)(a1 + 0x18) = v11;
  *(_DWORD *)(a1 + 0x1A) = v12;
  *(_DWORD *)(a1 + 0x1E) = v13;
  *(_WORD *)(a1 + 0x22) = v14;
  qmemcpy((void *)(a1 + 0x24), v15, 0x1Cu);
  *(_WORD *)(a1 + 0x40) = v16;
  *(_DWORD *)(a1 + 0x42) = v17;
  *(_DWORD *)(a1 + 0x46) = v18;
  *(_DWORD *)(a1 + 0x4A) = v19;
  *(_DWORD *)(a1 + 0x4E) = v20;
  *(_WORD *)(a1 + 0x52) = *(_WORD *)v21;
  *(_BYTE *)(a1 + 0x54) = v21[2];
  *(_WORD *)(a1 + 0x55) = *(_WORD *)&v21[3];
  *(_BYTE *)(a1 + 0x57) = v22;
  *(_BYTE *)(a1 + 0x58) = v23;
  *(_BYTE *)(a1 + 0x59) = v24;
  *(_DWORD *)(a1 + 0x5A) = v25;
  *(_DWORD *)(a1 + 0x5E) = v26;
  *(_DWORD *)(a1 + 0x62) = v27;
  *(_BYTE *)(a1 + 0x66) = v28;
  *(_DWORD *)(a1 + 0x67) = v29;
  *(_DWORD *)(a1 + 0x6B) = v30;
  *(_DWORD *)(a1 + 0x6F) = v31;
  *(_DWORD *)(a1 + 0x73) = v32;
  *(_DWORD *)(a1 + 0x77) = v33;
  if ( word_A62A1 <= *(__int16 *)(a1 + 0xC) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x8E4);
  }
  if ( *(__int16 *)(a1 + 0xE) >= 5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x8E5);
  }
  dword_A3D67[0x18 * *(__int16 *)(a1 + 0xC) + *(__int16 *)(a1 + 0xE)] = a1;
  result = 0x30 * *(__int16 *)(a1 + 0xC);
  ++word_A3D7B[result];
  return result * 2;
}
// A3D67: using guessed type int dword_A3D67[];
// A3D7B: using guessed type __int16 word_A3D7B[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (000372B0) --------------------------------------------------------
T_TypeA2 *__fastcall sub_372B0(T_TypeA2 *a1, int a2, int a3, int a4)
{
  sub_2C830(a1);
  a1->b = (int)off_95F84;
  sub_37310((int)a1, (int)a1, a3, a4);
  return a1;
}
// 95F84: using guessed type int (*off_95F84[5])();

//----- (000372CC) --------------------------------------------------------
int __fastcall sub_372CC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95F58);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F84;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F84: using guessed type int (*off_95F84[5])();

//----- (00037310) --------------------------------------------------------
int __fastcall sub_37310(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  __int16 v5; // ax
  int v6; // ebx
  int result; // eax
  char s[56]; // [esp+0h] [ebp-40h] BYREF
  int v9; // [esp+38h] [ebp-8h]

  v9 = a4;
  v4 = a1;
  *(_BYTE *)(a1 + 0xAB) = 0xFF;
  *(_WORD *)(a1 + 0xAE) = 0xFFFF;
  v5 = *(_WORD *)(a1 + 0xAE);
  *(_BYTE *)(v4 + 0x18B) = 5;
  *(_WORD *)(v4 + 0xB0) = v5;
  v6 = 0;
  *(_WORD *)(v4 + 0xAC) = v5;
  do
  {
    v4 += 2;
    sprintf(s, "data\\planal%02d.shp", v6++);
    result = sub_1ADAC((int)&unk_12FC20, s);
    *(_WORD *)(v4 + 0x173) = result;
  }
  while ( v6 < 0xB );
  return result;
}

//----- (00037380) --------------------------------------------------------
int __fastcall sub_37380(int a1, int a2)
{
  return (__int16)((0x11 * a1 + 0x22 * a2 - 0x29D6) / 0x484) | (((0x11 * a1 - 0x22 * a2 - 0xC9E) / (int)0xFFFFFB7C) << 0x10);
}

//----- (000373E0) --------------------------------------------------------
int __fastcall sub_373E0(int a1, int a2)
{
  int v3; // eax

  if ( a1 > 0xD && a1 < 0x99 && a2 > 0x77 && a2 < 0x1D5 )
  {
    return (a2 - 0x77) / 0x46 + *(unsigned __int16 *)(dword_D3664 + 0x18) + 5 * ((a1 - 0xD) / 0x46);
  }
  v3 = sub_37380(a1, a2);
  return (unsigned __int16)sub_35968(dword_D3664, v3 >> 0x10, (__int16)v3);
}

//----- (0003745C) --------------------------------------------------------
int __fastcall sub_3745C(T_Type5 *a1, unsigned __int8 *a2, int a3, int a4)
{
  char v5; // al
  int v6; // eax
  int v7; // ebp
  unsigned __int16 v8; // bx
  int v9; // eax
  int v10; // eax
  const char *v11; // ecx
  T_Rect *p_rect; // esi
  int v14; // [esp-20h] [ebp-40h]
  int v15; // [esp-18h] [ebp-38h]
  int v16; // [esp+0h] [ebp-20h] BYREF
  int v17; // [esp+4h] [ebp-1Ch] BYREF
  unsigned __int16 v18; // [esp+8h] [ebp-18h] BYREF
  unsigned __int16 v19; // [esp+Ch] [ebp-14h] BYREF
  unsigned __int8 v20; // [esp+10h] [ebp-10h]

  v5 = 0xF2;
  if ( a4 )
  {
    v5 = 0x96;
  }
  sub_5E9D0(a1, v5);
  v20 = *a2;
  if ( v20 != 0xFF )
  {
    v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANETALLOC", 0);
    sub_39390(v6, v20, (__int16 *)&v19, &v18);
    v7 = (int)sub_10000;
    if ( v20 == 0x17 )
    {
      v7 = 0x8000;
    }
    v8 = v18;
    v9 = sub_1B084((unsigned int)dword_12FC20, v19);
    sub_2BC40(a1, v9, v8, &v16, &v17);
    v15 = v17;
    v14 = v18;
    v10 = sub_1B084((unsigned int)dword_12FC20, v19);
    sub_5D631(a1, v10, v14, 0x28, v15, (int)byte_D8DA0, 0, (void (__noreturn *)())v7, (void (__noreturn *)())v7, 0);
  }
  v11 = (const char *)&dword_103F9A[0xA * *a2 + 3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  p_rect = &a1->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = p_rect->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = p_rect->y1;
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x50, 0, v11, 1, 0xFFFFFFFF, 0xFF, 0);
}
// 10000: using guessed type void __noreturn sub_10000();
// 103F9A: using guessed type int dword_103F9A[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00037568) --------------------------------------------------------
unsigned int __fastcall sub_37568(int a1, unsigned __int16 a2, int a3, unsigned int a4)
{
  int v4; // ecx
  int v5; // eax
  int v6; // edi
  int v7; // ebx
  int v9; // eax
  int v10; // ebx
  int i; // esi
  char *v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // edx
  unsigned __int8 v22; // ch
  unsigned __int8 v23; // dh
  char *v24; // esi
  int v25; // eax
  __int16 *v26; // edi
  int v27; // ebx
  char *sub_1CEA8; // eax
  int v29; // edx
  char v30; // cl
  int v31; // edi
  int v32; // ecx
  __int16 j; // dx
  int v34; // esi
  int v35; // eax
  char *v36; // ebx
  int v37; // eax
  char *v38; // eax
  _DWORD *v39; // edi
  char *v40; // esi
  char *v41; // edi
  char v42; // al
  char v43; // al
  char *v44; // esi
  _DWORD *v45; // edi
  char *v46; // edi
  char v47; // al
  char v48; // al
  unsigned int v49; // eax
  unsigned __int8 v50; // al
  unsigned __int16 v51; // bx
  int v52; // eax
  int v53; // eax
  int v54; // ebx
  int v55; // esi
  int v56; // eax
  int v57; // edi
  int v58; // esi
  const char *v59; // edi
  int v60; // eax
  int v61; // esi
  char *v62; // ecx
  int v63; // edi
  char *v64; // eax
  char *v65; // [esp-8h] [ebp-120h]
  int v66; // [esp-4h] [ebp-11Ch]
  char v67[200]; // [esp+0h] [ebp-118h] BYREF
  int s[7]; // [esp+C8h] [ebp-50h] BYREF
  _DWORD v69[5]; // [esp+E4h] [ebp-34h]
  int v70; // [esp+F8h] [ebp-20h]
  _DWORD *v71; // [esp+FCh] [ebp-1Ch]
  unsigned int v72; // [esp+100h] [ebp-18h]
  int v73; // [esp+104h] [ebp-14h]
  int v74; // [esp+108h] [ebp-10h]
  int v75; // [esp+10Ch] [ebp-Ch]
  int v76; // [esp+110h] [ebp-8h]
  int v77; // [esp+114h] [ebp-4h]
  _BYTE savedregs[12]; // [esp+118h] [ebp+0h]

  v76 = a1;
  LOWORD(v77) = a2;
  v74 = a3;
  v72 = a4;
  v4 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0);
  v73 = v4;
  v5 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLSQUARE", 0);
  v6 = v5;
  if ( a2 >= 7u )
  {
    if ( (unsigned __int16)v77 <= 7u )
    {
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(v76 + 0x41), 4, 8, 0, 0);
      if ( (*(_DWORD *)(v76 + 0x3D) & *(_DWORD *)(v76 + 0x35) & *(_DWORD *)(v76 + 0x39)) == 0xFFFFFFFF )
      {
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v76 + 0xA7) + 0x10))(v76, 0);
      }
      return 0xFFFFFFFF;
    }
    if ( (unsigned __int16)v77 >= 0x33u )
    {
      if ( a2 > 0x33u )
      {
        if ( (unsigned __int16)v77 < 0x1C01u )
        {
          if ( (_WORD)v77 != 0x34 )
          {
            return sub_2F424(v76, *(__int16 *)&savedregs[4], v74, v72);
          }
          v61 = 0xFFFFFFFF;
          if ( v72 )
          {
            *(_WORD *)(v76 + 0xB0) = *(_WORD *)(v5 + 0xAB);
          }
          else
          {
            v62 = sub_40144(
                    (unsigned __int8 *)&byte_A2F72[0x1EE * *(unsigned __int8 *)(dword_D3664 + 0x57)],
                    dword_D3664);
            if ( !v62 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x2AD);
            }
            v61 = 0;
            sub_35B04(dword_D3664, v74, (int)v62);
          }
          v63 = sub_56DA8((int)&V_Type3_stru_10AE70, "SHIPDESSCREEN", 0);
          v64 = sub_35A70(dword_D3664, v74);
          sub_4DA7C(v63, (int)v64, v61, 0);
          sub_56B60((int)&V_Type3_stru_10AE70, 1, 8, 1);
          return 0;
        }
        else
        {
          v7 = 5 * v74 + v76;
          if ( (unsigned __int16)v77 <= 0x1C01u )
          {
            v50 = *(_BYTE *)(v7 + 0xB2);
            v51 = *(_WORD *)(v76 + 0xAE);
            *(_BYTE *)(v76 + 0xAB) = v50;
            if ( v51 == 0xFFFF )
            {
              if ( v50 != 0xFF && (word_103FA2[0x14 * v50] & 2) != 0 )
              {
                sub_34B0C(dword_D3664, 0xFFFF, v50, 2u);
                *(_BYTE *)(v76 + 0xAB) = 0xFF;
              }
            }
            else if ( v50 != 0xFF )
            {
              if ( sub_34368(dword_D3664, *(_BYTE *)(v76 + 0xAB), v51) == 0xFFFFFFFF )
              {
                if ( *(_BYTE *)(v76 + 0xAB) == 0x17 )
                {
                  *(_WORD *)(v76 + 0xB0) = *(_WORD *)(v76 + 0xAE);
                }
                sub_34B0C(dword_D3664, *(unsigned __int16 *)(v76 + 0xAE), *(_BYTE *)(v76 + 0xAB), 2u);
              }
              v52 = v76;
              *(_BYTE *)(v76 + 0xAB) = 0xFF;
              *(_WORD *)(v52 + 0xAC) = 0xFFFF;
              *(_WORD *)(v76 + 0xAE) = *(_WORD *)(v52 + 0xAC);
            }
            sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v73 + 0x41), 2, 0, 0);
            v53 = *(unsigned __int16 *)(v76 + 0xB0);
            if ( (unsigned __int16)v53 == 0xFFFF )
            {
              (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v76 + 0xA7) + 0xC))(v76, 0);
            }
            else
            {
              (*(void (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)(v76 + 0xA7) + 8))(v76, 0x34, v53, 0);
            }
            return 0;
          }
          else
          {
            if ( (_WORD)v77 != 0x1C02 )
            {
              return sub_2F424(v76, *(__int16 *)&savedregs[4], v74, v72);
            }
            v54 = *(unsigned __int8 *)(v7 + 0xB2);
            if ( v54 != 0xFF )
            {
              sub_56B60((int)&V_Type3_stru_10AE70, 5, v54, 5);
            }
            return 0xFFFFFFFF;
          }
        }
      }
      if ( (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
      {
        if ( v74 == 1 )
        {
          *(_WORD *)(v76 + 0xAE) = 0xFFFF;
        }
        v56 = v73;
        v57 = v76;
        *(_DWORD *)(v73 + 0xAB) = 0;
        v58 = v76;
        *(_WORD *)(v56 + 0x8C9) = 0x4B;
        *(_BYTE *)(v56 + 0xC6) = 0xF2;
        sub_2F1C8(v56, (int)sub_3745C);
        v70 = 0;
        v75 = 0;
        v59 = (const char *)(v57 + 0xB2);
        sub_2ED4C(v73);
        do
        {
          if ( (_BYTE)v75 != 5 && sub_34368(dword_D3664, v75, *(_WORD *)(v76 + 0xAE)) )
          {
            v60 = v73;
            *(_BYTE *)(v58 + 0xB2) = v75;
            *(_DWORD *)(v58 + 0xB3) = 0;
            sub_2EA8C(v60, v59, 0xFFFFFFFF, 0);
            v58 += 5;
            v59 += 5;
            ++v70;
          }
          ++v75;
        }
        while ( v75 < 0x27 );
        if ( v70 )
        {
          sub_2D258(v76, 6);
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v73 + 0x41), 1, 0, 0);
        }
      }
LABEL_153:
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v76 + 0xA7) + 0xC))(v76, 0);
      return 0;
    }
    if ( (unsigned __int16)v77 <= 8u )
    {
      if ( !*(_DWORD *)(v4 + 0x35) && !*(_DWORD *)(v5 + 0x35) )
      {
        v16 = v76;
        *(_WORD *)(v76 + 0xAC) = sub_373E0(v74, v72);
        if ( *(_BYTE *)(dword_D3664 + 0x57) != (_BYTE)byte_104BEA
          && *(_BYTE *)(v16 + 0xAB) != 5
          && *(unsigned __int16 *)(v76 + 0xAC) != 0xFFFF
          && (*(_BYTE *)(4 * *(unsigned __int16 *)(v76 + 0xAC) + *(_DWORD *)(dword_D3664 + 0x10) + 1) != 0x17
           || *((_WORD *)sub_35A70(dword_D3664, *(_WORD *)(v76 + 0xAC)) + 0x2B) != (unsigned __int8)byte_104BEA) )
        {
          *(_WORD *)(v76 + 0xAC) = 0xFFFF;
        }
        v17 = *(unsigned __int16 *)(v76 + 0xAC);
        if ( (unsigned __int16)v17 != 0xFFFF
          && *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v17 + 1) == 0x17
          && *((_WORD *)sub_35A70(dword_D3664, v17) + 0x2B) != (unsigned __int8)byte_104BEA )
        {
          *(_WORD *)(v76 + 0xAC) = 0xFFFF;
        }
        goto LABEL_153;
      }
    }
    else
    {
      if ( (_WORD)v77 != 0x32 )
      {
        return sub_2F424(v76, *(__int16 *)&savedregs[4], v74, v72);
      }
      *(_WORD *)(v76 + 0xAC) = 0xFFFF;
      if ( v74 == 0xA || v74 == 0xB )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, 0);
        (*(void (**)(void))(*(_DWORD *)(v76 + 0xA7) + 8))();
        return 0;
      }
      if ( v74 == 0xC )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, 0);
        v55 = *(_DWORD *)(v76 + 0xA7);
        *(_BYTE *)(v76 + 0xAB) = 5;
        (*(void (**)(void))(v55 + 8))();
        return 0;
      }
      if ( v74 == 4
        || (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57)
        || *(unsigned __int16 *)(v76 + 0xAE) != 0xFFFF
        && *(_BYTE *)(4 * *(unsigned __int16 *)(v76 + 0xAE) + *(_DWORD *)(dword_D3664 + 0x10) + 1) == 0x17
        && *((_WORD *)sub_35A70(dword_D3664, *(_WORD *)(v76 + 0xAE)) + 0x2B) == (unsigned __int8)byte_104BEA )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v6 + 0x41), 0x32, v74, *(unsigned __int16 *)(v76 + 0xAE));
        sub_2D258(v76, 6);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v6 + 0x41), 1, 0, 0);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v76 + 0xA7) + 0xC))(v76, 0);
        return 0;
      }
    }
    return 0;
  }
  if ( (unsigned __int16)v77 < 4u )
  {
    if ( !(_WORD)v77 )
    {
      return sub_2F424(v76, *(__int16 *)&savedregs[4], v74, v72);
    }
    if ( a2 > 1u )
    {
      if ( (_WORD)v77 != 3 )
      {
        return sub_2F424(v76, *(__int16 *)&savedregs[4], v74, v72);
      }
      if ( v72 < 0x17 )
      {
        if ( v72 < 0x13 )
        {
          if ( v72 == 1 )
          {
            if ( *(_DWORD *)(v4 + 0x35) )
            {
              sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v4 + 0x41), 2, 0, 0);
            }
            else if ( *(_DWORD *)(v5 + 0x35) )
            {
              sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, *(_DWORD *)(v4 + 0x35));
            }
            else
            {
              sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
            }
          }
        }
        else if ( v72 <= 0x13 )
        {
          if ( dword_A0CFC )
          {
            if ( *(unsigned __int8 *)(dword_D3664 + 0x57) == 0xFF )
            {
              *(_BYTE *)(dword_D3664 + 0x57) = byte_104BEA;
            }
            else
            {
              sub_1D234(
                (int)&word_A3D21[0x30 * *(__int16 *)(dword_D3664 + 0xC)],
                dword_D3664,
                (unsigned __int8)byte_104BEA);
            }
          }
        }
        else if ( v72 == 0x14 && dword_A0CFC )
        {
          v20 = dword_D3664;
          *(_WORD *)(dword_D3664 + 0x42) += 2;
          sub_34AE4(v20, 5u, 0xFFFFFFFF);
        }
      }
      else if ( v72 <= 0x17 )
      {
        if ( dword_A0CFC )
        {
          v18 = dword_D3664;
          *(_WORD *)(dword_D3664 + 0x50) += 0xC8;
          sub_352E0(v18);
        }
      }
      else if ( v72 < 0x1F )
      {
        if ( v72 == 0x18 && dword_A0CFC )
        {
          *(_WORD *)(dword_D3664 + 0x42) = *(_WORD *)(dword_D3664 + 0x4A);
        }
      }
      else if ( v72 <= 0x1F )
      {
        *(_BYTE *)(v76 + 0x18B) ^= 1u;
      }
      else if ( v72 >= 0x31 )
      {
        if ( v72 <= 0x31 )
        {
          if ( dword_A0CFC )
          {
            sub_352E0(dword_D3664);
          }
        }
        else if ( v72 == 0x32 )
        {
          if ( ::a3 )
          {
            if ( dword_A0CFC )
            {
              v19 = dword_D3664;
              ++*(_WORD *)(dword_D3664 + 0x55);
              sub_34E70(v19);
            }
          }
          else
          {
            *(_DWORD *)(dword_D3664 + 0x5A) = ~*(_DWORD *)(dword_D3664 + 0x5A);
          }
        }
      }
      goto LABEL_153;
    }
    v69[0] = off_96850[0];
    v69[1] = off_96850[1];
    v69[2] = off_96850[2];
    v69[3] = off_96850[3];
    v69[4] = off_96850[4];
    for ( i = 0; i != 5; ++i )
    {
      v12 = (char *)v69[i];
      sub_56D70((int)&V_Type3_stru_10AE70, v12, *(__int16 *)&savedregs[4], v74, v72);
    }
    v13 = v76;
    *(_DWORD *)(v76 + 0x35) = 0xFFFFFFFF;
    *(_DWORD *)(v13 + 0x39) = 0xFFFFFFFF;
    *(_BYTE *)(v13 + 0xAB) = 0xFF;
    *(_WORD *)(v13 + 0xAC) = 0xFFFF;
    v14 = v76;
    *(_WORD *)(v76 + 0xAE) = *(_WORD *)(v13 + 0xAC);
    if ( *(unsigned __int16 *)(v14 + 0xB0) != 0xFFFF )
    {
      sub_394BC(v14);
    }
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v76 + 0xA7) + 0xC))(v76, 0);
    if ( dword_10467C )
    {
      sub_557D4(&V_Type3_stru_10AE70, dword_104680, (const char *)dword_10467C, 0x14);
      dword_10467C = 0;
    }
    return 0;
  }
  if ( a2 > 4u )
  {
    if ( (unsigned __int16)v77 <= 5u )
    {
      v9 = v76;
      *(_BYTE *)(v76 + 0xAB) = 0xFF;
      v10 = *(_DWORD *)(v9 + 0xA7);
      *(_WORD *)(v9 + 0xAE) = 0xFFFF;
      (*(void (**)(void))(v10 + 0xC))();
      return 0xFFFFFFFF;
    }
    else
    {
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(v76 + 0x41), 8);
      if ( (*(_DWORD *)(v76 + 0x3D) & *(_DWORD *)(v76 + 0x35) & *(_DWORD *)(v76 + 0x39)) == 0xFFFFFFFF )
      {
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v76 + 0xA7) + 0xC))(v76, 0);
      }
      return 0xFFFFFFFF;
    }
  }
  v15 = *(_DWORD *)(v76 + 0x35);
  if ( !v15 )
  {
    return v15;
  }
  if ( *(_DWORD *)(v4 + 0x35) )
  {
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v4 + 0x41), 2, 0, 0);
  }
  else if ( *(_DWORD *)(v5 + 0x35) )
  {
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, *(_DWORD *)(v4 + 0x35));
  }
  else
  {
    v21 = v76;
    *(_WORD *)(v76 + 0xAE) = *(_WORD *)(v76 + 0xAC);
    if ( *(unsigned __int16 *)(v21 + 0xAE) == 0xFFFF )
    {
      if ( *(_BYTE *)(v21 + 0xAB) != 0xFF )
      {
        *(_BYTE *)(v21 + 0xAB) = 0xFF;
      }
    }
    else
    {
      if ( *(__int16 *)(v21 + 0x59) != 0xFFFFFFFF )
      {
        sub_4FB90((int)&unk_10914C, *(_WORD *)(v21 + 0x59));
      }
      v22 = *(_BYTE *)(v76 + 0xAB);
      if ( v22 == 0xFF )
      {
        (*(void (**)(void))(*(_DWORD *)(v76 + 0xA7) + 8))();
        return 0;
      }
      if ( sub_34368(dword_D3664, v22, *(_WORD *)(v76 + 0xAE)) )
      {
        v23 = *(_BYTE *)(v76 + 0xAB);
        if ( v23 == 5 )
        {
          v24 = sub_35A70(dword_D3664, *(_WORD *)(v6 + 0xAB));
          v25 = sub_4937C((int)v24, 0x47);
          sub_492F8(v24, v25);
          v26 = &word_A3D21[0x30 * *(__int16 *)(dword_D3664 + 0xC)];
          if ( *(unsigned __int8 *)(dword_D3664 + 0x57) != 0xFF )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x1C6);
          }
          v27 = dword_D3664;
          sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1F);
          sub_557D4(&V_Type3_stru_10AE70, sub_1CEA8, (const char *)(v27 + 0x24), 0x14);
          v29 = dword_D3664;
          v30 = v24[0x56];
          *(_BYTE *)(dword_D3664 + 0x57) = v30;
          *((_BYTE *)v26 + 0x14) |= 1 << v30;
          *(_WORD *)(v29 + 0x42) = 2;
          *(_DWORD *)(v29 + 0x67) = dword_A2F6C[0];
          v31 = 0;
          sub_34B0C(dword_D3664, *(unsigned __int16 *)(v76 + 0xAE), *(_BYTE *)(v76 + 0xAB), 0);
          v32 = 0xFFFFFFFF;
          memset(s, 0, sizeof(s));
          for ( j = 0; j < SHIWORD(dword_A3CF2); ++j )
          {
            v34 = 0x1EE * j;
            if ( !*(int *)((char *)&dword_A2F75 + v34) )
            {
              v35 = sub_402E0(&byte_A2F72[v34]);
              s[j] = v35;
              if ( v31 < v35
                && (j == (unsigned __int8)byte_104BEA || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + j]) )
              {
                v32 = j;
                v31 = s[j];
              }
            }
          }
          if ( v32 < 0 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x1E9);
          }
          v71 = (_DWORD *)sub_56DA8((int)&V_Type3_stru_10AE70, "HELPWINDOW", 0);
          v36 = "colonize";
          if ( v32 == (unsigned __int8)byte_104BEA )
          {
            v36 = "maxcolonize";
          }
          sub_2FCB0(v71, "help.txt", v36);
          v66 = s[v32];
          v65 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v32)];
          if ( s[(unsigned __int8)byte_104BEA] == 1 )
          {
            v37 = 0x20;
          }
          else
          {
            v37 = 0x21;
          }
          v38 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v37);
          v39 = v71;
          sprintf(
            v67,
            *(const char **)((char *)v71 + 0xC9A),
            &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
            s[(unsigned __int8)byte_104BEA],
            v38,
            v65,
            v66);
          v40 = v67;
          v41 = *(char **)((char *)v39 + 0xC9A);
          do
          {
            v42 = *v40;
            *v41 = *v40;
            if ( !v42 )
            {
              break;
            }
            v43 = v40[1];
            v40 += 2;
            v41[1] = v43;
            v41 += 2;
          }
          while ( v43 );
          *(_WORD *)((char *)v71 + 0xCB1) = 0x1D;
          *(_WORD *)((char *)v71 + 0xCB3) = *(_WORD *)(dword_D3664 + 0x14) + 5 * *(_WORD *)(dword_D3664 + 0x16);
          v44 = v67;
          v45 = v71;
          sprintf(v67, (const char *)v71[0x334], dword_D3664 + 0x24);
          v46 = (char *)v45[0x334];
          do
          {
            v47 = *v44;
            *v46 = *v44;
            if ( !v47 )
            {
              break;
            }
            v48 = v44[1];
            v44 += 2;
            v46[1] = v48;
            v46 += 2;
          }
          while ( v48 );
          sub_56B60((int)&V_Type3_stru_10AE70, 5, 0, 0);
          *(_BYTE *)(v76 + 0xAB) = 0xFF;
        }
        else
        {
          v49 = sub_34B0C(dword_D3664, *(unsigned __int16 *)(v76 + 0xAE), v23, 2u);
          if ( *(_BYTE *)(v76 + 0xAB) == 0x17 && v49 == 0xFFFFFFFF )
          {
            *(_WORD *)(v76 + 0xB0) = *(_WORD *)(v76 + 0xAE);
          }
          *(_BYTE *)(v76 + 0xAB) = 0xFF;
        }
      }
    }
  }
  (*(void (**)(void))(*(_DWORD *)(v76 + 0xA7) + 8))();
  return 0;
}
// 37B38: conditional instruction was optimized away because ch.1!=FF
// 96850: using guessed type char *off_96850[5];
// A0CFC: using guessed type int dword_A0CFC;
// A2F6C: using guessed type int dword_A2F6C[];
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;
// 103FA2: using guessed type __int16 word_103FA2[];
// 10467C: using guessed type int dword_10467C;
// 37568: using guessed type int s[7];

//----- (000384B0) --------------------------------------------------------
void __fastcall sub_384B0(int a1)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  char v6; // ah
  int v7; // ebx
  unsigned int v8; // eax
  unsigned __int8 *v9; // edx
  unsigned __int16 v10; // di
  int v11; // esi
  int v12; // eax
  int v13; // ebx
  int v14; // ecx
  int v15; // eax
  int v16; // edx
  int v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // edx
  int v21; // ebx
  int v22; // eax
  int i; // esi
  int v24; // eax
  int v25; // edi
  int v26; // edx
  int v27; // eax
  unsigned __int16 v28; // di
  int v29; // esi
  int v30; // esi
  unsigned __int8 v31; // al
  int v32; // eax
  int v33; // eax
  unsigned int v34; // eax
  char v35; // dl
  int v36; // esi
  int v37; // edx
  int v38; // edx
  unsigned __int16 v39; // si
  int v40; // eax
  int v41; // esi
  int v42; // ecx
  int v43; // edi
  unsigned __int8 v44; // al
  int v45; // eax
  bool v46; // di
  int v47; // eax
  int v48; // [esp-24h] [ebp-3B8h]
  int v49; // [esp-24h] [ebp-3B8h]
  int v50; // [esp-20h] [ebp-3B4h]
  int v51; // [esp-20h] [ebp-3B4h]
  int v52; // [esp-20h] [ebp-3B4h]
  int v53; // [esp-1Ch] [ebp-3B0h]
  int v54; // [esp-1Ch] [ebp-3B0h]
  int v55; // [esp-1Ch] [ebp-3B0h]
  int v56; // [esp-18h] [ebp-3ACh]
  int v57; // [esp-18h] [ebp-3ACh]
  int v58; // [esp-18h] [ebp-3ACh]
  int v59; // [esp-Ch] [ebp-3A0h]
  int v60; // [esp-Ch] [ebp-3A0h]
  int v61; // [esp-8h] [ebp-39Ch]
  int v62; // [esp-4h] [ebp-398h]
  _BYTE v63[256]; // [esp+0h] [ebp-394h] BYREF
  char s[256]; // [esp+100h] [ebp-294h] BYREF
  int v65; // [esp+200h] [ebp-194h] BYREF
  int v66[5]; // [esp+204h] [ebp-190h]
  int v67; // [esp+218h] [ebp-17Ch]
  int v68; // [esp+21Ch] [ebp-178h]
  int v69; // [esp+230h] [ebp-164h]
  int v70; // [esp+234h] [ebp-160h]
  int v71; // [esp+248h] [ebp-14Ch]
  int v72; // [esp+24Ch] [ebp-148h]
  int v73; // [esp+260h] [ebp-134h] BYREF
  int v74[5]; // [esp+264h] [ebp-130h]
  int v75; // [esp+278h] [ebp-11Ch]
  int v76; // [esp+27Ch] [ebp-118h]
  int v77; // [esp+280h] [ebp-114h]
  int v78; // [esp+290h] [ebp-104h]
  int v79; // [esp+294h] [ebp-100h]
  int v80; // [esp+298h] [ebp-FCh]
  int v81; // [esp+2A8h] [ebp-ECh]
  int v82; // [esp+2ACh] [ebp-E8h]
  int v83; // [esp+2B0h] [ebp-E4h]
  T_Type5 v84; // [esp+2C0h] [ebp-D4h] BYREF
  T_Type5 pane; // [esp+2D4h] [ebp-C0h] BYREF
  T_Type5 v86; // [esp+2E8h] [ebp-ACh] BYREF
  int *v87; // [esp+2FCh] [ebp-98h] BYREF
  int v88; // [esp+300h] [ebp-94h]
  int v89; // [esp+304h] [ebp-90h]
  int v90; // [esp+308h] [ebp-8Ch]
  int v91; // [esp+30Ch] [ebp-88h]
  int v92; // [esp+310h] [ebp-84h]
  int v93; // [esp+314h] [ebp-80h]
  int v94; // [esp+318h] [ebp-7Ch]
  int v95; // [esp+31Ch] [ebp-78h]
  int v96; // [esp+320h] [ebp-74h]
  int v97; // [esp+324h] [ebp-70h]
  int v98; // [esp+328h] [ebp-6Ch]
  int v99; // [esp+32Ch] [ebp-68h]
  int v100; // [esp+330h] [ebp-64h]
  int v101; // [esp+334h] [ebp-60h]
  int v102; // [esp+338h] [ebp-5Ch]
  int v103; // [esp+33Ch] [ebp-58h]
  int v104; // [esp+340h] [ebp-54h]
  int v105; // [esp+344h] [ebp-50h]
  int v106; // [esp+348h] [ebp-4Ch]
  unsigned __int8 *v107; // [esp+34Ch] [ebp-48h]
  int v108; // [esp+350h] [ebp-44h]
  int v109; // [esp+354h] [ebp-40h]
  int v110; // [esp+358h] [ebp-3Ch]
  int v111; // [esp+35Ch] [ebp-38h]
  int v112; // [esp+360h] [ebp-34h]
  int v113; // [esp+364h] [ebp-30h]
  int v114; // [esp+368h] [ebp-2Ch] BYREF
  unsigned int v115; // [esp+36Ch] [ebp-28h]
  int v116; // [esp+370h] [ebp-24h]
  int v117; // [esp+374h] [ebp-20h]
  int v118; // [esp+378h] [ebp-1Ch] BYREF
  unsigned __int8 v119; // [esp+37Ch] [ebp-18h]

  v104 = *(unsigned __int16 *)(dword_D3664 + 0x14);
  LOWORD(v2) = *(_WORD *)(dword_D3664 + 0x16);
  v116 = (unsigned __int16)word_FFEF8;
  v2 = (unsigned __int16)v2;
  LOWORD(v2) = *(_WORD *)(a1 + 2 * (unsigned __int16)v2 + 0x175);
  v114 = v2;
  if ( *(__int16 *)(a1 + 0x1E) != 0xFFFFFFFF )
  {
    v3 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v116);
    sub_5CB3C((P_Type5)(a1 + 4), v3, 4, 7, 0x73);
    if ( (*(_BYTE *)(a1 + 0x18B) & 4) != 0 )
    {
      v4 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
      sub_5CB3C((P_Type5)(a1 + 4), v4, v104, 0x198, 0x128);
    }
    v59 = *(__int16 *)(a1 + 0x1E);
    v5 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v116);
    sub_5CB3C((P_Type5)(a1 + 4), v5, v59, 0, 0);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
  }
  v87 = *(int **)(a1 + 4);
  v88 = *(_DWORD *)(a1 + 8);
  v89 = *(_DWORD *)(a1 + 0xC);
  v90 = *(_DWORD *)(a1 + 0x10);
  v91 = *(_DWORD *)(a1 + 0x14);
  v6 = *(_BYTE *)(a1 + 0xAB);
  v115 = 0xFFFF;
  if ( v6 != (char)0xFF )
  {
    v115 = 0xFFFE;
    v7 = *(unsigned __int16 *)(a1 + 0xAC);
    if ( (unsigned __int16)v7 != 0xFFFF && *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v7 + 1) == 0xFF )
    {
      v8 = sub_34368(dword_D3664, *(_BYTE *)(a1 + 0xAB), v7);
      if ( v8 )
      {
        LOWORD(v8) = *(_WORD *)(a1 + 0xAC);
        v115 = v8;
      }
    }
  }
  v9 = *(unsigned __int8 **)(dword_D3664 + 0x10);
  v118 = 0xFFFF;
  v107 = v9;
  LOBYTE(v9) = *(_BYTE *)(dword_D3664 + 0x57);
  v100 = 0;
  if ( (_BYTE)v9 == (_BYTE)byte_104BEA || (unsigned __int16)sub_35930(dword_D3664, 0xB) == 0xFFFF )
  {
    v109 = 0x6E;
    v96 = 0x19A;
    v110 = 0xF * v104;
    do
    {
      v94 = (unsigned __int8)byte_1045B8[v110];
      v103 = v96;
      v98 = v110;
      v108 = v109;
      while ( (unsigned __int8)byte_1045B8[v98] + (unsigned __int8)byte_104604[v98] > v94 )
      {
        v73 = 0x22 * v94 + v103;
        v75 = v73 + 0x22;
        v78 = v73;
        v81 = v73 - 0x22;
        v74[0] = 0x11 * v94 + v108;
        v76 = v74[0] + 0x11;
        v79 = v74[0] + 0x22;
        v82 = v74[0] + 0x11;
        v83 = 0x960000;
        v80 = 0x960000;
        v77 = 0x960000;
        v74[1] = 0x960000;
        HIWORD(v33) = HIWORD(v107);
        v119 = v107[1];
        LOWORD(v33) = *v107;
        v117 = v33;
        v92 = dword_96864[0];
        v93 = dword_96864[1];
        v34 = sub_34368(dword_D3664, 0xFFu, v100);
        if ( *(unsigned __int16 *)(a1 + 0xAC) == v100
          && *(_BYTE *)(a1 + 0xAB) == 0xFF
          && v119 == 0xFF
          && v34 == 0xFFFFFFFF )
        {
          sub_61800(&V_Type6_stru_D8654.pane.window, 4, (int)&v73);
          goto LABEL_34;
        }
        if ( (*(_BYTE *)(a1 + 0x18B) & 1) != 0 )
        {
          v10 = 0xC;
          v113 = 0xD;
          if ( !(_WORD)v117 )
          {
            v113 = 7;
            v10 = 0;
          }
          switch ( (unsigned __int16)v117 )
          {
            case 2u:
              v10 = 0x75;
              v113 = 8;
              break;
            case 3u:
              v10 = 0x92;
              v113 = 9;
              break;
            case 4u:
              v10 = 0xFF;
              v113 = 0xA;
              break;
          }
          if ( v34 == 0xFFFFFFFF )
          {
            v65 = v73;
            v66[0] = v74[0] + 1;
            v67 = v75 - 2;
            v68 = v76;
            v69 = v78;
            v70 = v79 - 1;
            v71 = v81 + 2;
            v11 = 0;
            v72 = v82;
            do
            {
              v12 = 6 * *((char *)&v93 + v11);
              v13 = v66[v12];
              v14 = v66[v12 - 1];
              v15 = 6 * *((char *)&v92 + v11++);
              sub_5C001(
                (int **)&V_Type6_stru_D8654.pane,
                v66[v15 - 1],
                v66[v15],
                v14,
                v13,
                0,
                (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v10);
            }
            while ( v11 < 4 );
            if ( (_WORD)v113 )
            {
              v16 = dword_D8D8F;
              v17 = (unsigned __int16)v113 << 8;
LABEL_33:
              sub_62DA5(&V_Type6_stru_D8654.pane.window, 4, (int)&v65, v16 + v17);
            }
          }
          else
          {
            v65 = v73;
            v66[0] = v74[0] + 0xE;
            v67 = v75 - 0x1C;
            v68 = v76;
            v69 = v78;
            v70 = v79 - 0xE;
            v71 = v81 + 0x1C;
            v18 = 0;
            v72 = v82;
            do
            {
              v19 = 6 * *((char *)&v93 + v18);
              v20 = v66[v19];
              v21 = v66[v19 - 1];
              v22 = 6 * *((char *)&v92 + v18++);
              sub_5C001(
                (int **)&V_Type6_stru_D8654.pane,
                v66[v22 - 1],
                v66[v22],
                v21,
                v20,
                0,
                (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v10);
            }
            while ( v18 < 4 );
            if ( (_WORD)v113 )
            {
              v17 = dword_D8D8F;
              v16 = (unsigned __int16)v113 << 8;
              goto LABEL_33;
            }
          }
        }
LABEL_34:
        if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 && *(_BYTE *)(a1 + 0xAB) == 0xFF && v119 == 0xFF )
        {
          for ( i = 0; i < 4; ++i )
          {
            v24 = 6 * *((char *)&v93 + i);
            v25 = v74[v24];
            v26 = v74[v24 - 1];
            v27 = 6 * *((char *)&v92 + i);
            sub_5C001(
              (int **)&V_Type6_stru_D8654.pane,
              v74[v27 - 1],
              v74[v27],
              v26,
              v25,
              0,
              (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0x96);
          }
        }
        if ( v119 == 0xFF && (v117 & 8) == 0 )
        {
          if ( (unsigned __int16)v115 == v100 )
          {
            sub_39390(a1, *(_BYTE *)(a1 + 0xAB), (__int16 *)&v114, &v118);
            v62 = v74[0];
            v61 = v73;
            v60 = (unsigned __int16)v118;
            v32 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
            sub_5CB3C((P_Type5)&V_Type6_stru_D8654.pane, v32, v60, v61, v62);
          }
        }
        else
        {
          v28 = v100;
          sub_393F4(a1, v100, &v114, &v118);
          v29 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
          v99 = v29;
          if ( *(unsigned __int16 *)(dword_D3664 + 0x52) == v100 )
          {
            sub_61800(&V_Type6_stru_D8654.pane.window, 4, (int)&v73);
            v30 = 0x22 * *(unsigned __int16 *)(dword_D3664 + 0x50);
            v112 = v30 / (unsigned __int16)sub_3583C(dword_D3664, v28, 0xFFu);
            v31 = 0xF2;
            if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
            {
              v31 = 0x96;
            }
            memset(s, v31, sizeof(s));
            sub_5D007(s);
            sub_5D026((P_Type5)&V_Type6_stru_D8654.pane, v99, (unsigned __int16)v118, v73, v74[0]);
            pane = (T_Type5)V_Type6_stru_D8654.pane;
            pane.rect.y1 = v74[0] + 0x22 - v112;
            if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
            {
              sub_5D007((const void *)(dword_D8D8F + 0x1500));
              sub_5D026(&pane, v99, (unsigned __int16)v118, v73, v74[0] - pane.rect.y1);
            }
            else
            {
              sub_5CB3C(&pane, v99, (unsigned __int16)v118, v73, v74[0] - pane.rect.y1);
            }
          }
          else if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
          {
            sub_5D007((const void *)(dword_D8D8F + 0x1500));
            sub_5D026((P_Type5)&V_Type6_stru_D8654.pane, v29, (unsigned __int16)v118, v73, v74[0]);
          }
          else
          {
            sub_5CB3C((P_Type5)&V_Type6_stru_D8654.pane, v29, (unsigned __int16)v118, v73, v74[0]);
          }
        }
        ++v94;
        ++v100;
        v107 += 4;
      }
      v109 += 0x11;
      v96 -= 0x22;
      ++v110;
    }
    while ( v109 != 0x16D );
  }
  v97 = 0xD;
  v35 = *(_BYTE *)(dword_D3664 + 0x57);
  v106 = 0x77;
  v101 = 0;
  if ( v35 != (_BYTE)byte_104BEA && (unsigned __int16)sub_35930(dword_D3664, 0x19) != 0xFFFF )
  {
    v101 = 0xFFFFFFFF;
  }
  v100 = *(unsigned __int16 *)(dword_D3664 + 0x18);
  v95 = 4 * v100;
  v111 = v97 + 0x23;
  while ( *(unsigned __int16 *)(dword_D3664 + 0x1A) > v100 )
  {
    v38 = v95 + *(_DWORD *)(dword_D3664 + 0x10);
    v102 = 0;
    v39 = *(unsigned __int8 *)(v38 + 1);
    if ( *(_BYTE *)(v38 + 1) == 0x17 && *((_WORD *)sub_35A70(dword_D3664, v100) + 0x2B) == (unsigned __int8)byte_104BEA )
    {
      v102 = 0xFFFFFFFF;
    }
    if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
    {
      HIWORD(v40) = HIWORD(v100);
      LOWORD(v40) = v39;
      if ( v40 == 0xFF && !v101 && *(_BYTE *)(a1 + 0xAB) == 0xFF )
      {
        v88 = v97;
        v89 = v106;
        v90 = v97 + 0x46;
        v91 = v106 + 0x46;
        sub_2BB74(&v87, (int *)1, (int *)1, (int *)0x45, (int *)0x45, 0x96u, 0);
      }
    }
    v105 = v39;
    if ( v39 == 0xFF )
    {
      if ( (unsigned __int16)v115 == v100 )
      {
        v36 = (int)sub_10000;
        if ( *(_BYTE *)(a1 + 0xAB) == 0x17 )
        {
          v36 = 0x8000;
        }
        sub_39390(a1, *(_BYTE *)(a1 + 0xAB), (__int16 *)&v114, &v118);
        v56 = v106 + 0x23;
        v53 = v111;
        v50 = (unsigned __int16)v118;
        v48 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
        sub_5D631(
          (P_Type5)&V_Type6_stru_D8654.pane,
          v48,
          v50,
          v53,
          v56,
          (int)byte_D8DA0,
          0,
          (void (__noreturn *)())v36,
          (void (__noreturn *)())v36,
          0);
      }
    }
    else
    {
      sub_393F4(a1, v100, &v114, &v118);
      v84 = *(T_Type5 *)(a1 + 4);
      v41 = (int)sub_10000;
      if ( v105 == 0x17 )
      {
        v41 = 0x8000;
      }
      if ( *(unsigned __int16 *)(dword_D3664 + 0x52) == v100 )
      {
        v42 = 0x46 * *(unsigned __int16 *)(dword_D3664 + 0x50);
        v43 = v42 / (unsigned __int16)sub_3583C(dword_D3664, v100, 0xFFu);
        v44 = 0xF2;
        if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
        {
          v44 = 0x96;
        }
        memset(v63, v44, sizeof(v63));
        if ( !v101 || v102 == 0xFFFFFFFF )
        {
          sub_5D007(v63);
          v57 = v106 + 0x23;
          v54 = v111;
          v51 = (unsigned __int16)v118;
          v45 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
          sub_5D631(
            (P_Type5)&V_Type6_stru_D8654.pane,
            v45,
            v51,
            v54,
            v57,
            (int)byte_D8DA0,
            0,
            (void (__noreturn *)())v41,
            (void (__noreturn *)())v41,
            1);
        }
        v84.rect.y1 = v106 + 0x46 - v43;
      }
      if ( !v101 || v102 == 0xFFFFFFFF )
      {
        v46 = *(unsigned __int16 *)(a1 + 0xAC) == v100;
        sub_5D007((const void *)(dword_D8D8F + 0x1500));
        v58 = v106 + 0x23 - v84.rect.y1;
        v55 = v111;
        v52 = (unsigned __int16)v118;
        v49 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
        sub_5D631(
          &v84,
          v49,
          v52,
          v55,
          v58,
          (int)byte_D8DA0,
          0,
          (void (__noreturn *)())v41,
          (void (__noreturn *)())v41,
          v46);
      }
    }
    v37 = (v100 - *(unsigned __int16 *)(dword_D3664 + 0x18)) % 5;
    v106 += 0x46;
    if ( v37 == 4 )
    {
      v106 = 0x77;
      v111 += 0x46;
      v97 += 0x46;
    }
    v95 += 4;
    ++v100;
  }
  if ( *(_DWORD *)(sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0) + 0x35) == 0xFFFFFFFF )
  {
    v86.a = &V_Type6_stru_D8654;
    v86.rect.x1 = 0x70;
    v86.rect.y1 = 0x70;
    v86.rect.y2 = 0x1AC;
    v86.rect.x2 = 0x210;
    v47 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v116);
    sub_5CB3C(&v86, v47, 5, 0, 0);
  }
  sub_2D218((_DWORD *)a1);
}
// 10000: using guessed type void __noreturn sub_10000();
// 96864: using guessed type _DWORD dword_96864[2];
// D8D8F: using guessed type int dword_D8D8F;
// FFEF8: using guessed type __int16 word_FFEF8;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 384B0: using guessed type _DWORD var_C0[2];
// 384B0: using guessed type _DWORD var_D4[2];

//----- (00039390) --------------------------------------------------------
char __fastcall sub_39390(int a1, unsigned __int8 a2, __int16 *a3, _WORD *a4)
{
  __int16 v4; // ax

  if ( a2 >= 0x27u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x461);
  }
  LOBYTE(v4) = word_FFEDC;
  *a3 = word_FFEDC;
  *a4 = 0;
  if ( a2 != 0xFF )
  {
    LOBYTE(v4) = a2;
    *a4 = a2;
  }
  if ( a2 == 0x17 )
  {
    v4 = word_FFEBC[*(unsigned __int8 *)(dword_D3664 + 0x57)];
    *a3 = v4;
    *a4 = 0;
  }
  return v4;
}
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDC: using guessed type __int16 word_FFEDC;

//----- (000393F4) --------------------------------------------------------
__int16 __fastcall sub_393F4(int a1, unsigned __int16 a2, _WORD *a3, _WORD *a4)
{
  int v5; // eax
  _BYTE *v6; // eax
  __int16 v7; // dx
  __int16 result; // ax
  char *v9; // esi

  if ( a2 >= *(_WORD *)(dword_D3664 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x476);
  }
  *a3 = word_FFEDC;
  v5 = dword_D3664;
  *a4 = 0;
  v6 = (_BYTE *)(4 * a2 + *(_DWORD *)(v5 + 0x10));
  v7 = (unsigned __int8)v6[1];
  if ( (unsigned __int8)v7 == 0xFF )
  {
    if ( (*v6 & 8) != 0 )
    {
      *a4 = 0x27;
    }
  }
  else
  {
    *a4 = v7;
  }
  result = v7;
  if ( v7 == 0x17 )
  {
    v9 = sub_35A70(dword_D3664, a2);
    *a3 = word_FFEBC[*((__int16 *)v9 + 0x2B)];
    if ( v9[0xAA] < 0 || v9[0xAA] >= 4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x48A);
    }
    result = v9[0xAA];
    *a4 = result;
  }
  return result;
}
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDC: using guessed type __int16 word_FFEDC;

//----- (000394BC) --------------------------------------------------------
char *__fastcall sub_394BC(int a1)
{
  int v2; // esi
  char *result; // eax
  int v4; // edx
  int v5; // ebp
  char *v6; // eax
  int v7; // eax
  int v8; // edx

  v2 = sub_56DA8((int)&V_Type3_stru_10AE70, "SHIPDESSCREEN", 0);
  dword_10467C = *(_DWORD *)(v2 + 0xAB) + 0x34;
  result = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x22);
  v4 = *(_DWORD *)(v2 + 0xAB);
  dword_104680 = result;
  if ( v4 )
  {
    if ( *(_DWORD *)(v2 + 0xC9) == 0xFFFFFFFF )
    {
      dword_104680 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x23);
      v7 = dword_D3664;
      *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0xB0) + 2) &= ~1u;
      sub_34B0C(v7, *(unsigned __int16 *)(a1 + 0xB0), 0x17u, 3u);
      v8 = sub_4EE00(v2);
      result = (char *)dword_D3664;
      *(_DWORD *)(dword_D3664 + 0x77) = v8;
      *(_BYTE *)(*(_DWORD *)(v2 + 0xAB) + 0x58) = 2;
      *(_DWORD *)(*(_DWORD *)(v2 + 0xAB) + 0x59) = result;
    }
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 0xC9);
    dword_10467C = 0;
    if ( !v5 )
    {
      v6 = sub_35A70(dword_D3664, *(_WORD *)(a1 + 0xB0));
      sub_49940((int)v6);
      result = (char *)sub_34B0C(dword_D3664, *(unsigned __int16 *)(a1 + 0xB0), 0xFFu, 1u);
    }
  }
  *(_WORD *)(a1 + 0xB0) = 0xFFFF;
  return result;
}
// 10467C: using guessed type int dword_10467C;

//----- (000395C4) --------------------------------------------------------
int __fastcall sub_395C4(int a1, unsigned int count, int a3)
{
  void *v5; // edx

  v5 = (void *)(a1 + 0x18B);
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, v5, 1u);
  }
  else
  {
    return sub_1C098(count, (int)v5, 1u);
  }
}

//----- (000395EC) --------------------------------------------------------
void __fastcall __spoils<> sub_395EC(P_TypeA2 result)
{
  sub_2C830(result);
  result->b = (int)off_95F6C;
}
// 95F6C: using guessed type int (*off_95F6C[5])();

//----- (000395FC) --------------------------------------------------------
int __fastcall sub_395FC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95F44);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F6C;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F6C: using guessed type int (*off_95F6C[5])();

//----- (00039644) --------------------------------------------------------
unsigned int __fastcall sub_39644(int a1, __int16 a2, int a3, int a4)
{
  int v5; // eax
  int v7; // [esp+0h] [ebp-10h]

  v7 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0);
  v5 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLSQUARE", 0);
  if ( (*(_DWORD *)(v7 + 0x35) || *(_DWORD *)(v5 + 0x35)) && a2 != 0xF && a2 != 0xE )
  {
    return 0;
  }
  if ( (unsigned __int16)a2 < 6u )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 6u )
  {
    (*(void (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 2);
  }
  else
  {
    if ( a2 != 7 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    (*(void (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 1);
  }
  return 0;
}

//----- (000396F0) --------------------------------------------------------
void __fastcall sub_396F0(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // eax
  char v8; // al
  int v9; // ebp
  int v10; // edi
  int i; // esi
  int v12; // eax
  char v13; // al
  char *sub_1CEA8; // eax
  unsigned __int16 v15; // bx
  unsigned __int8 v16; // cl
  char *v17; // edi
  char *v18; // esi
  char v19; // al
  char v20; // al
  unsigned __int8 v21; // ch
  int v22; // esi
  __int16 v23; // ax
  int v24; // eax
  char *v25; // eax
  char *v26; // edi
  char *v27; // esi
  char v28; // al
  char v29; // al
  int v30; // edi
  unsigned __int16 v31; // bx
  T_Type5 *v32; // esi
  int v33; // eax
  int v34; // eax
  char *v35; // ecx
  int v36; // ebx
  T_Rect *p_rect; // esi
  const char *v38; // ecx
  _DWORD *v39; // esi
  int v40; // edi
  int v41; // ecx
  int v42; // ebp
  int v43; // esi
  int *v44; // edi
  int *v45; // ebp
  int j; // esi
  int *v47; // ecx
  int *v48; // ebx
  int *v49; // edx
  int v50; // [esp-10h] [ebp-A0h]
  int v51; // [esp-Ch] [ebp-9Ch]
  int v52; // [esp-8h] [ebp-98h]
  char *v53; // [esp+Ch] [ebp-84h]
  char s[60]; // [esp+10h] [ebp-80h] BYREF
  int v55; // [esp+4Ch] [ebp-44h] BYREF
  int v56; // [esp+50h] [ebp-40h] BYREF
  int *v57; // [esp+54h] [ebp-3Ch]
  int v58; // [esp+58h] [ebp-38h]
  int v59; // [esp+5Ch] [ebp-34h]
  int v60; // [esp+60h] [ebp-30h]
  P_Type5 v61; // [esp+64h] [ebp-2Ch]
  int **v62; // [esp+68h] [ebp-28h]
  int v63; // [esp+6Ch] [ebp-24h]
  int v64; // [esp+70h] [ebp-20h] BYREF
  int v65; // [esp+74h] [ebp-1Ch] BYREF
  unsigned __int8 v66; // [esp+78h] [ebp-18h]

  v60 = a1;
  v58 = 0;
  if ( a2 != 2 && (*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(a1 + 0x41) || a2 == 1) )
  {
    v58 = 0xFFFFFFFF;
  }
  v2 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0);
  v3 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLSQUARE", 0);
  if ( *(_DWORD *)(v2 + 0x35) || *(_DWORD *)(v3 + 0x35) )
  {
    v58 = 0;
  }
  v59 = *(_DWORD *)(v60 + 0x47);
  if ( v59 == 4 )
  {
    v59 = 3;
  }
  if ( *(_WORD *)(v60 + 0x45) == 0x33 )
  {
    v59 = 4;
  }
  v4 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANETALLOC", 0);
  v64 = 0xFFFF;
  v65 = 0xFFFF;
  sub_5D007((const void *)(dword_D8D8F + 0x1500));
  if ( v59 <= 2 )
  {
    sub_5E9D0((P_Type5)(v60 + 4), 0);
  }
  HIWORD(v5) = HIWORD(v59);
  switch ( v59 )
  {
    case 0:
      LOWORD(v5) = word_FFEEC;
      v64 = v5;
      v63 = (int)pow((double)*(unsigned __int16 *)(dword_D3664 + 0x46), 0.75);
      v65 = v63;
      if ( (unsigned __int16)v63 > 0x14u )
      {
        v65 = 0x14;
      }
      goto LABEL_23;
    case 1:
      LOWORD(v5) = word_FFEEE;
      v64 = v5;
      v63 = (int)pow((double)*(unsigned __int16 *)(dword_D3664 + 0x44), 0.75);
      v65 = v63;
      if ( (unsigned __int16)v63 > 0x14u )
      {
        v65 = 0x14;
      }
      goto LABEL_23;
    case 2:
      LOWORD(v5) = word_FFEF0;
      v64 = v5;
      HIWORD(v6) = HIWORD(dword_D3664);
      LOWORD(v6) = *(_WORD *)(dword_D3664 + 0x48);
      v65 = v6;
      if ( (unsigned __int16)v6 > 0x14u )
      {
        v65 = 0x14;
      }
LABEL_23:
      v7 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v64);
      sub_5CB3C((P_Type5)(v60 + 4), v7, (unsigned __int16)v65, 0, 0);
      goto LABEL_66;
    case 3:
      v8 = 0xF2;
      if ( v58 )
      {
        v8 = 0x96;
      }
      v9 = 0;
      v63 = v60 + 4;
      sub_5E9D0((P_Type5)(v60 + 4), v8);
      v10 = 0;
      v65 = 1;
      v61 = (P_Type5)(v60 + 4);
      for ( i = 0; i < *(unsigned __int16 *)(dword_D3664 + 0x4A); ++i )
      {
        if ( i == *(unsigned __int16 *)(dword_D3664 + 0x4C) )
        {
          ++v65;
        }
        if ( i == *(unsigned __int16 *)(dword_D3664 + 0x42) )
        {
          ++v65;
        }
        v12 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF8);
        sub_5CB3C(v61, v12, (unsigned __int16)v65, v10, v9);
        v10 += 0xA;
        if ( i % 0xA == 9 )
        {
          v10 = 0;
          v9 += 0xA;
        }
      }
      goto LABEL_66;
    case 4:
      v13 = 0xF2;
      if ( v58 && *(_BYTE *)(dword_D3664 + 0x57) == (_BYTE)byte_104BEA )
      {
        v13 = 0x96;
      }
      sub_5E9D0((P_Type5)(v60 + 4), v13);
      v66 = 0xFF;
      qmemcpy(s, &unk_9686C, sizeof(s));
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x24);// 36: "No Project"
      v15 = 0xFFFF;
      v16 = *(_BYTE *)(v4 + 0xAB);
      v57 = (int *)sub_1CEA8;
      if ( v16 == 0xFF )
      {
        v21 = *(_BYTE *)(dword_D3664 + 0x54);
        if ( v21 != 0xFF )
        {
          v22 = (unsigned __int16)sub_358BC(dword_D3664);
          v23 = word_103FA2[0x14 * v21];
          v66 = v21;
          if ( (v23 & 0x20) == 0 )
          {
            if ( v22 == 0xFFFF )
            {
              v26 = s;
              v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x27);// 39: "No Progress"
              do
              {
                v28 = *v27;
                *v26 = *v27;
                if ( !v28 )
                {
                  break;
                }
                v29 = v27[1];
                v27 += 2;
                v26[1] = v29;
                v26 += 2;
              }
              while ( v29 );
            }
            else
            {
              if ( v22 == 1 )
              {
                v24 = 0x1C;                            // 28: ""
              }
              else
              {
                v24 = 0x1D;                            // 29: "s"
              }
              v53 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v24);
              v25 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x26);// 38: "%d day%s until completion"
              sprintf(s, v25, v22, v53);
            }
          }
          if ( *(_BYTE *)(dword_D3664 + 0x54) != 0x23 )
          {
            v15 = *(_WORD *)(dword_D3664 + 0x52);
          }
        }
      }
      else
      {
        v17 = s;
        v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x25);// 37: "Pick a Location"
        v66 = v16;
        do
        {
          v19 = *v18;
          *v17 = *v18;
          if ( !v19 )
          {
            break;
          }
          v20 = v18[1];
          v18 += 2;
          v17[1] = v20;
          v17 += 2;
        }
        while ( v20 );
      }
      if ( v66 == 0xFF )
      {
        if ( *(_WORD *)(dword_D3664 + 0x42) != *(_WORD *)(dword_D3664 + 0x4C) )
        {
          goto LABEL_65;
        }
        v36 = 0x19;
        v32 = (T_Type5 *)(v60 + 4);
        v35 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x28);// 40: "(No Free Population)"
      }
      else
      {
        if ( v15 == 0xFFFF )
        {
          sub_39390(v4, v66, (__int16 *)&v64, &v65);
        }
        else
        {
          sub_393F4(v4, v15, &v64, &v65);
        }
        v30 = (int)sub_10000;
        if ( v66 == 0x17 )
        {
          v30 = 0x8000;
        }
        v31 = v65;
        v57 = &dword_103F9A[0xA * v66 + 3];
        v32 = (T_Type5 *)(v60 + 4);
        v33 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v64);
        sub_2BC40(v32, v33, v31, &v55, &v56);
        v52 = v56;
        v51 = v55;
        v50 = (unsigned __int16)v65;
        v34 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v64);
        sub_5D631(
          v32,
          v34,
          v50,
          v51,
          v52,
          (int)byte_D8DA0,
          0,
          (void (__noreturn *)())v30,
          (void (__noreturn *)())v30,
          0);
        v35 = s;
        v36 = 0x50;
      }
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v32->a;
      p_rect = &v32->rect;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = p_rect->x1;
      p_rect = (T_Rect *)((char *)p_rect + 4);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = p_rect->x1;
      p_rect = (T_Rect *)((char *)p_rect + 4);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = p_rect->x1;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = p_rect->y1;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v36, v35, 2, 0xFFFFFFFF, 0xFF, 0);
LABEL_65:
      v38 = (const char *)v57;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(v60 + 4);
      v39 = (_DWORD *)(v60 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(v60 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *++v39;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *++v39;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v39[1];
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xA, v38, 2, 0xFFFFFFFF, 0xFF, 0);
LABEL_66:
      if ( v59 <= 2 && v58 && (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
      {
        v40 = *(_DWORD *)(v60 + 0x10);
        v41 = *(_DWORD *)(v60 + 8);
        v42 = *(_DWORD *)(v60 + 0x14);
        v43 = *(_DWORD *)(v60 + 0xC);
        v62 = (int **)(v60 + 4);
        v44 = (int *)(v40 - v41);
        v45 = (int *)(v42 - v43);
        for ( j = 0; j < 3; ++j )
        {
          v47 = v44;
          v48 = (int *)j;
          v49 = (int *)j;
          v44 = (int *)((char *)v44 + 0xFFFFFFFF);
          sub_2BB74(v62, v49, v48, v47, v45, 0x96u, 0);
          v45 = (int *)((char *)v45 + 0xFFFFFFFF);
        }
      }
      sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(v60 + 4));
      return;
    default:
      goto LABEL_66;
  }
}
// 10000: using guessed type void __noreturn sub_10000();
// D8D8F: using guessed type int dword_D8D8F;
// FFEEC: using guessed type __int16 word_FFEEC;
// FFEEE: using guessed type __int16 word_FFEEE;
// FFEF0: using guessed type __int16 word_FFEF0;
// FFEF8: using guessed type __int16 word_FFEF8;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00039D80) --------------------------------------------------------
T_TypeA2 *__fastcall sub_39D80(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95FB8;
  sub_39DE0();
  return a1;
}
// 95FB8: using guessed type int (*off_95FB8[5])();

//----- (00039D9C) --------------------------------------------------------
int __fastcall sub_39D9C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95FA4);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95FB8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95FB8: using guessed type int (*off_95FB8[5])();

//----- (00039DE0) --------------------------------------------------------
char *sub_39DE0()
{
  int v0; // ebx
  int i; // edx
  char *sub_1CEA8; // eax
  int v3; // edx
  int j; // ebx
  char *v5; // eax
  int v6; // ebx
  int k; // edx
  char *result; // eax

  v0 = 0x29;
  for ( i = 0; i != 5; dword_104684[i] = (int)sub_1CEA8 )
  {
    ++i;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v0++);
  }
  v3 = 0x2E;
  for ( j = 0; j != 0xB; dword_104698[j] = (int)v5 )
  {
    ++j;
    v5 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3++);
  }
  v6 = 0x39;
  for ( k = 0; k != 8; dword_1046C4[k] = (int)result )
  {
    ++k;
    result = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v6++);
  }
  return result;
}
// 104684: using guessed type int dword_104684[];
// 104698: using guessed type int dword_104698[];
// 1046C4: using guessed type int dword_1046C4[];

//----- (00039E3C) --------------------------------------------------------
unsigned int __fastcall sub_39E3C(int a1, __int16 dx0, int a3, int a4)
{
  int v4; // eax
  char v5; // cl
  int v7; // eax
  int v8; // esi
  int v9; // eax
  char *v10; // eax
  int v11; // esi
  int v12; // ebx
  int v13; // edx
  int v14; // edi
  int v15; // ebx
  int v16; // edx
  int v17; // edi
  int v18; // ebx
  int v19; // esi
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  char *v25; // esi
  char *v26; // edi
  char v27; // al
  char v28; // al
  int v29; // edi
  int v30; // ebx
  int v31; // edx
  int v32; // eax
  int v33; // ebx
  int v34; // edx
  int v35; // edi
  char *sub_1CEA8; // esi
  char *v37; // edi
  char v38; // al
  char v39; // al
  int v40; // edx
  int v41; // ecx
  int v42; // ebx
  char *v43; // edi
  char *v44; // esi
  int v45; // ebx
  char v46; // al
  char v47; // al
  int v48; // edi
  int v49; // eax
  char *v50; // eax
  char *v51; // eax
  unsigned int v52; // esi
  char *v53; // ebx
  int v54; // ecx
  int v55; // edi
  int v56; // eax
  int v57; // eax
  char *v58; // eax
  char *v59; // esi
  char *v60; // edi
  char v61; // al
  char v62; // al
  int v63; // [esp-4h] [ebp-144h]
  char *v64; // [esp-4h] [ebp-144h]
  char s[280]; // [esp+0h] [ebp-140h] BYREF
  int v66; // [esp+118h] [ebp-28h]
  int a2; // [esp+11Ch] [ebp-24h] BYREF
  int v68; // [esp+120h] [ebp-20h]
  int v69; // [esp+124h] [ebp-1Ch]
  int v70; // [esp+128h] [ebp-18h]
  int v71; // [esp+12Ch] [ebp-14h]
  int v72; // [esp+130h] [ebp-10h]
  int v73; // [esp+134h] [ebp-Ch]
  _BYTE v74[6]; // [esp+138h] [ebp-8h]
  _BYTE savedregs[12]; // [esp+140h] [ebp+0h]

  v72 = a1;
  *(_WORD *)&v74[4] = dx0;
  v66 = a3;
  v69 = a4;
  v4 = *(unsigned __int16 *)(a1 + 0xAB);
  v5 = 0xFF;
  if ( (unsigned __int16)v4 != 0xFFFF )
  {
    v5 = *(_BYTE *)(4 * v4 + *(_DWORD *)(dword_D3664 + 0x10) + 1);
  }
  if ( *(_WORD *)&v74[4] < 0x33u )
  {
    if ( *(_WORD *)&v74[4] >= 4u )
    {
      if ( *(_WORD *)&v74[4] > 5u )
      {
        if ( *(_WORD *)&v74[4] >= 7u )
        {
          if ( *(_WORD *)&v74[4] <= 7u )
          {
            if ( *(_DWORD *)(v72 + 0x39) && *(_DWORD *)(v72 + 0x35) && *(_DWORD *)(v72 + 0x3D) )
            {
              (*(void (**)(void))(*(_DWORD *)(v72 + 0xA7) + 0x10))();
            }
            return 0xFFFFFFFF;
          }
          else
          {
            if ( *(_WORD *)&v74[4] != 0x32 )
            {
              return sub_2F424(v72, *(__int16 *)&savedregs[4], v66, v69);
            }
            dword_104684[0] = v66;
            *(_WORD *)(v72 + 0xAB) = v69;
            return 0;
          }
        }
        if ( *(_DWORD *)(v72 + 0x39) && *(_DWORD *)(v72 + 0x35) && *(_DWORD *)(v72 + 0x3D) )
        {
          (*(void (**)(void))(*(_DWORD *)(v72 + 0xA7) + 0xC))();
        }
      }
      return 0xFFFFFFFF;
    }
    if ( !*(_WORD *)&v74[4] )
    {
      return sub_2F424(v72, *(__int16 *)&savedregs[4], v66, v69);
    }
    if ( *(_WORD *)&v74[4] <= 1u )
    {
      v7 = v72;
      *(_DWORD *)(v72 + 0x39) = 0xFFFFFFFF;
      v8 = dword_104684[0];
      *(_DWORD *)(v7 + 0x35) = 0xFFFFFFFF;
      if ( v8 == 3 )
      {
        HIWORD(v9) = 0;
        v70 = 0;
        if ( v5 == (char)0xFF )
        {
          v20 = 0;
          while ( (_BYTE)v20 == 5 || !sub_34368(dword_D3664, v20, *(_WORD *)(v72 + 0xAB)) )
          {
            if ( ++v20 >= 0x27 )
            {
              goto LABEL_37;
            }
          }
          v21 = v70 + 1;
          *(_DWORD *)&s[4 * v21 + 0xC4] = 0x36;
          v70 = v21;
        }
        else
        {
          if ( v5 == 0x17 )
          {
            LOWORD(v9) = *(_WORD *)(v72 + 0xAB);
            if ( (*(_WORD *)(4 * v9 + *(_DWORD *)(dword_D3664 + 0x10) + 2) & 1) != 0 )
            {
              v10 = sub_35A70(dword_D3664, *(_WORD *)(v72 + 0xAB));
              v11 = (int)v10;
              if ( !v10 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\psqwin.cpp", 0x79);
              }
              if ( sub_4937C((int)v10, 0x47) != 0xFFFFFFFF && *(unsigned __int8 *)(dword_D3664 + 0x57) == 0xFF )
              {
                v12 = v70 + 1;
                *(_DWORD *)&s[4 * v70 + 0xC8] = 0x34;
                v70 = v12;
              }
              if ( sub_4937C(v11, 0x49) != 0xFFFFFFFF )
              {
                v13 = *(unsigned __int8 *)(dword_D3664 + 0x57);
                if ( v13 != 0xFF && (_BYTE)v13 != (_BYTE)byte_104BEA )
                {
                  v14 = v70 + 1;
                  *(_DWORD *)&s[4 * v70 + 0xC8] = 0x39;
                  v70 = v14;
                }
              }
              *(_DWORD *)&s[4 * v70 + 0xC8] = 0x37;
              v15 = v70;
              v16 = (unsigned __int16)sub_35930(dword_D3664, 0x18);
              v70 = v15 + 1;
              if ( (unsigned __int16)v16 != 0xFFFF
                && (*(_WORD *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v16 + 2) & 1) != 0
                && (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
              {
                v17 = v70 + 1;
                *(_DWORD *)&s[4 * v70 + 0xC8] = 0x38;
                v70 = v17;
              }
            }
          }
          if ( v5 != 5 )
          {
            v18 = v70 + 1;
            *(_DWORD *)&s[4 * v70 + 0xC8] = 0x35;
            v70 = v18;
          }
          if ( sub_34368(dword_D3664, 0x23u, *(_WORD *)(v72 + 0xAB)) )
          {
            v19 = v70 + 1;
            *(_DWORD *)&s[4 * v70 + 0xC8] = 0x3A;
            v70 = v19;
          }
        }
LABEL_37:
        *(_DWORD *)v74 = 0xA0;
        v22 = v70 + 1;
        *(_DWORD *)&s[4 * v70 + 0xC8] = 0x33;
        v70 = v22;
        if ( v22 > 0 )
        {
          v71 = v22;
          v73 = 0;
          v68 = 4 * v22;
          do
          {
            v23 = v73;
            v24 = *(_DWORD *)(v73 + *(_DWORD *)(v72 + 0x67));
            v25 = (char *)dword_1045FC[*(_DWORD *)&s[v73 + 0xC8]];
            v26 = (char *)(v24 + 0x20);
            do
            {
              v27 = *v25;
              *v26 = *v25;
              if ( !v27 )
              {
                break;
              }
              v28 = v25[1];
              v25 += 2;
              v26[1] = v28;
              v26 += 2;
            }
            while ( v28 );
            v29 = v71;
            *(_WORD *)(v24 + 0x45) = *(_WORD *)&s[v23 + 0xC8];
            v30 = *(_DWORD *)v74;
            v31 = 0x1DF - *(_DWORD *)v74;
            *(_DWORD *)(v24 + 8) = *(_DWORD *)v74;
            *(_DWORD *)(v24 + 0xC) = 0x151;
            *(_DWORD *)(v24 + 0x14) = 0x16F;
            *(_DWORD *)v74 = v31 / v29 + v30;
            if ( *(int *)v74 > 0x1DF )
            {
              *(_DWORD *)v74 = 0x1DF;
            }
            v32 = *(_DWORD *)v74;
            v33 = *(__int16 *)&savedregs[4];
            v63 = v69;
            *(_DWORD *)(v24 + 0x10) = *(_DWORD *)v74;
            v34 = *(_DWORD *)(v24 + 0x41);
            *(_DWORD *)v74 = v32 + 1;
            sub_56D30((int)&V_Type3_stru_10AE70, v34, v33, v66, v63);
            --v71;
            v73 += 4;
          }
          while ( v73 < v68 );
        }
        if ( v70 == 1 )
        {
          v35 = v72;
          sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
          v37 = (char *)(**(_DWORD **)(v35 + 0x67) + 0x20);
          do
          {
            v38 = *sub_1CEA8;
            *v37 = *sub_1CEA8;
            if ( !v38 )
            {
              break;
            }
            v39 = sub_1CEA8[1];
            sub_1CEA8 += 2;
            v37[1] = v39;
            v37 += 2;
          }
          while ( v39 );
        }
      }
      else
      {
        v40 = **(_DWORD **)(v7 + 0x67);
        *(_DWORD *)(v40 + 8) = 0xA0;
        *(_DWORD *)(v40 + 0xC) = 0x151;
        v41 = v66;
        *(_DWORD *)(v40 + 0x10) = 0x1DF;
        v42 = *(_DWORD *)&v74[2];
        *(_DWORD *)(v40 + 0x14) = 0x16F;
        v43 = (char *)(v40 + 0x20);
        v44 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
        v45 = v42 >> 0x10;
        do
        {
          v46 = *v44;
          *v43 = *v44;
          if ( !v46 )
          {
            break;
          }
          v47 = v44[1];
          v44 += 2;
          v43[1] = v47;
          v43 += 2;
        }
        while ( v47 );
        v48 = v69;
        *(_WORD *)(v40 + 0x45) = 0x33;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v40 + 0x41), v45, v41, v48);
      }
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v72 + 0xA7) + 0xC))(v72, 0);
      return 0;
    }
    else
    {
      if ( *(_WORD *)&v74[4] != 2 )
      {
        return sub_2F424(v72, *(__int16 *)&savedregs[4], v66, v69);
      }
      sub_2D258(v72, *(__int16 *)&savedregs[4]);
      v49 = v72;
      *(_DWORD *)(v72 + 0x39) = 0;
      *(_DWORD *)(v49 + 0x35) = 0;
      if ( *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(v72 + 0x41) )
      {
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] = 0xFFFFFFFF;
      }
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x41), 0xFFFFFFFF);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x41), 0xFFFFFFFF);
      return 0;
    }
  }
  else
  {
    if ( *(_WORD *)&v74[4] <= 0x33u )
    {
LABEL_88:
      sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x32, 0xA, 0);
      return 0;
    }
    if ( *(_WORD *)&v74[4] < 0x37u )
    {
      if ( *(_WORD *)&v74[4] < 0x35u )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x32, 0xC, 0);
        return 0;
      }
      else if ( *(_WORD *)&v74[4] <= 0x35u )
      {
        if ( v5 == 0x17 )
        {
          v50 = sub_35A70(dword_D3664, *(_WORD *)(v72 + 0xAB));
          sub_49940((int)v50);
        }
        sub_34B0C(dword_D3664, *(unsigned __int16 *)(v72 + 0xAB), 0xFFu, 1u);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x32, 0xA, 0);
        return 0;
      }
      else
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x32, 0xB, 0);
        return 0;
      }
    }
    else
    {
      if ( *(_WORD *)&v74[4] <= 0x37u )
      {
        v51 = sub_35A70(dword_D3664, *(_WORD *)(v72 + 0xAB));
        sub_35C38(dword_D3664, (int)v51);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x32, 0xA, 0);
        return 0;
      }
      if ( *(_WORD *)&v74[4] < 0x39u )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x32, 0xA, 0);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x34, *(unsigned __int16 *)(v72 + 0xAB), 1);
        return 0;
      }
      if ( *(_WORD *)&v74[4] > 0x39u )
      {
        if ( *(_WORD *)&v74[4] != 0x3A )
        {
          return sub_2F424(v72, *(__int16 *)&savedregs[4], v66, v69);
        }
        sub_34B0C(dword_D3664, *(unsigned __int16 *)(v72 + 0xAB), 0x23u, 2u);
        goto LABEL_88;
      }
      v52 = sub_36CD4(dword_D3664, *(_WORD *)(v72 + 0xAB), &a2);
      v53 = "invadefailure";
      v54 = sub_56DA8((int)&V_Type3_stru_10AE70, "HELPWINDOW", 0);
      if ( v52 == 0xFFFFFFFF )
      {
        v53 = "invadesuccess";
      }
      v55 = sub_402E0(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
      sub_2FCB0((_DWORD *)v54, "help.txt", v53);
      if ( v55 == 1 )
      {
        v56 = 0x20;
      }
      else
      {
        v56 = 0x21;
      }
      v64 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v56);
      if ( a2 == 1 )
      {
        v57 = 0x1C;
      }
      else
      {
        v57 = 0x1D;
      }
      v58 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v57);
      sprintf(s, *(const char **)(v54 + 0xC9A), dword_D3664 + 0x24, a2, v58, v55, v64);
      v59 = s;
      v60 = *(char **)(v54 + 0xC9A);
      do
      {
        v61 = *v59;
        *v60 = *v59;
        if ( !v61 )
        {
          break;
        }
        v62 = v59[1];
        v59 += 2;
        v60[1] = v62;
        v60 += 2;
      }
      while ( v62 );
      *(_WORD *)(v54 + 0xCB1) = 0x1C;
      *(_WORD *)(v54 + 0xCB3) = 0x49;
      *(_WORD *)(v54 + 0xCCC) = 0x1D;
      *(_WORD *)(v54 + 0xCCE) = *(_WORD *)(dword_D3664 + 0x14) + 5 * *(_WORD *)(dword_D3664 + 0x16);
      sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v72 + 0x63), 0x32, 0xA, 0);
      sub_56B60((int)&V_Type3_stru_10AE70, 5, 0, 0);
      return 0;
    }
  }
}
// 1045FC: using guessed type int dword_1045FC[];
// 104684: using guessed type int dword_104684[];

//----- (0003A6BC) --------------------------------------------------------
void __fastcall sub_3A6BC(int a1)
{
  T_Type5 *v1; // esi
  int v2; // eax
  int v3; // eax
  char *sub_1CEA8; // eax
  int v5; // esi
  int v6; // edx
  int v7; // ebx
  char *v8; // eax
  int v9; // edx
  unsigned __int8 v10; // al
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // si
  unsigned __int16 v13; // ax
  int v14; // eax
  unsigned __int16 v15; // dx
  unsigned __int16 v16; // bx
  int v17; // eax
  unsigned __int16 v18; // bx
  char v19; // al
  char *v20; // edi
  int *v21; // esi
  char v22; // al
  char v23; // al
  char *v24; // eax
  char *v25; // eax
  const char *v26; // ebx
  char *v27; // eax
  unsigned __int16 v28; // dx
  unsigned __int16 v29; // cx
  unsigned __int16 v30; // si
  unsigned __int16 v31; // ax
  int v32; // eax
  int v33; // edx
  char *v34; // edi
  char *v35; // esi
  char v36; // al
  char v37; // al
  int v38; // eax
  char *v39; // eax
  char *v40; // edi
  char *v41; // esi
  char v42; // al
  char v43; // al
  char *v44; // eax
  char *v45; // edi
  char *v46; // esi
  char v47; // al
  char v48; // al
  char *v49; // edi
  char *v50; // esi
  char v51; // al
  char v52; // al
  char *v53; // edi
  char *v54; // esi
  char v55; // al
  char v56; // al
  char *v57; // eax
  char *v58; // eax
  char *v59; // edi
  char *v60; // esi
  char v61; // al
  char v62; // al
  char *v63; // edi
  char *v64; // esi
  char v65; // al
  char v66; // al
  char *v67; // eax
  char *v68; // eax
  char *v69; // ecx
  char *v70; // eax
  int v71; // eax
  char *v72; // eax
  char *v73; // [esp-10h] [ebp-1AAh]
  __int16 v74; // [esp-Ch] [ebp-1A6h]
  int v75; // [esp-Ch] [ebp-1A6h]
  char *v76; // [esp-Ch] [ebp-1A6h]
  char *v77; // [esp-8h] [ebp-1A2h]
  int v78; // [esp-8h] [ebp-1A2h]
  int v79; // [esp-8h] [ebp-1A2h]
  int v80; // [esp-8h] [ebp-1A2h]
  int v81; // [esp-8h] [ebp-1A2h]
  char *v82; // [esp-4h] [ebp-19Eh]
  char *v83; // [esp-4h] [ebp-19Eh]
  char *v84; // [esp-4h] [ebp-19Eh]
  int v85; // [esp-4h] [ebp-19Eh]
  int v86; // [esp-4h] [ebp-19Eh]
  int v87; // [esp-4h] [ebp-19Eh]
  int v88; // [esp-4h] [ebp-19Eh]
  char *v89; // [esp-4h] [ebp-19Eh]
  char v90[152]; // [esp+0h] [ebp-19Ah] BYREF
  char v91[100]; // [esp+98h] [ebp-102h] BYREF
  char v92[100]; // [esp+FCh] [ebp-9Eh] BYREF
  char s[52]; // [esp+160h] [ebp-3Ah] BYREF
  char v94[52]; // [esp+194h] [ebp-6h] BYREF
  int v95; // [esp+1C8h] [ebp+2Eh]
  int v96; // [esp+1CCh] [ebp+32h]
  int v97; // [esp+1D0h] [ebp+36h]
  int v98; // [esp+1D4h] [ebp+3Ah]
  int v99; // [esp+1D8h] [ebp+3Eh]
  char v100[20]; // [esp+1DCh] [ebp+42h] BYREF
  int a2; // [esp+1F0h] [ebp+56h]
  char *v102; // [esp+1F4h] [ebp+5Ah]
  char *v103; // [esp+1F8h] [ebp+5Eh]
  char *format; // [esp+1FCh] [ebp+62h]
  char *v105; // [esp+200h] [ebp+66h]
  char *v106; // [esp+204h] [ebp+6Ah]
  int v107; // [esp+208h] [ebp+6Eh]
  int v108; // [esp+20Ch] [ebp+72h]
  _DWORD *v109; // [esp+210h] [ebp+76h]
  int v110; // [esp+214h] [ebp+7Ah]
  char *v111; // [esp+218h] [ebp+7Eh]

  v109 = (_DWORD *)a1;
  v1 = (T_Type5 *)(a1 + 4);
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
  sub_5E9D0(v1, 0xF2);
  v2 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEEA);
  v107 = 0;
  sub_5CB3C(v1, v2, 0, 0, 0);
  v95 = v109[1];
  v96 = v109[2];
  v97 = v109[3];
  v98 = v109[4];
  v99 = v109[5];
  v96 = v109[2] + 0xA;
  v97 = v109[3] + 0xA;
  v108 = 0;
  v3 = v109[2];
  v102 = 0;
  v106 = 0;
  v98 = v3 + 0x145;
  format = 0;
  v110 = 0xFFFF;
  v99 = v109[3] + 0xCF;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v95;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v96;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v97;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v98;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v99;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3062] = 0xFF;
  v111 = 0;
  switch ( dword_104684[0] )
  {
    case 0:
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x41);// 65: "Research"
      v108 = (int)sub_1CEA8;
      LOWORD(sub_1CEA8) = *(_WORD *)(dword_D3664 + 0x46);
      v5 = *(unsigned __int8 *)(dword_D3664 + 0x57);
      v111 = sub_1CEA8;
      v6 = (unsigned __int16)word_106FA6[v5];
      if ( v6 != 0xFFFF )
      {
        v107 = 0xFFFFFFFF;
        v102 = &byte_10525A[0x4B * v6];
        v7 = sub_469F0((int)&word_105258, v5);
        v110 = sub_46C20(
                 *(unsigned __int16 *)((char *)&word_105296 + 0x4B * v6),
                 (unsigned __int16)word_106FB4[*(unsigned __int8 *)(dword_D3664 + 0x57)],
                 v7);
      }
      v106 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x42); // 66: "be discovered"
      format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x43);// 67: "No progress is being made on %s."
      break;
    case 1:
      v8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x44);   // 68: "Industry"
      HIWORD(v9) = 0;
      v108 = (int)v8;
      LOWORD(v8) = *(_WORD *)(dword_D3664 + 0x44);
      LOWORD(v9) = *(_WORD *)(dword_D3664 + 0x52);
      v111 = v8;
      v10 = 0xFF;
      if ( (unsigned __int16)v9 != 0xFFFF )
      {
        v10 = *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v9 + 1);
      }
      if ( v10 != 0xFF )
      {
        v102 = (char *)&dword_103F9A[0xA * v10 + 3];
        v107 = 0xFFFFFFFF;
        v11 = *(_WORD *)(dword_D3664 + 0x44);
        v12 = *(_WORD *)(dword_D3664 + 0x50);
        v13 = sub_3583C(dword_D3664, v9, 0xFFu);
        v110 = sub_46C20(v13, v12, v11);
      }
      v106 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x45); // 69: "be completed"
      format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x43);// 67: "No progress is being made on %s."
      break;
    case 2:
      v108 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x46);// 70: "Prosperity"
      HIWORD(v14) = HIWORD(dword_D3664);
      LOWORD(v14) = *(_WORD *)(dword_D3664 + 0x48);
      v111 = (char *)v14;
      v102 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x47); // 71: "Population"
      v106 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x48); // 72: "grow"
      v15 = *(_WORD *)(dword_D3664 + 0x42);
      v16 = *(_WORD *)(dword_D3664 + 0x4A);
      v107 = 0xFFFFFFFF;
      if ( v15 >= v16 )
      {
        format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4A);// 74: "%s has no more room to grow."
      }
      else
      {
        v110 = sub_46C20(
                 dword_9684C,
                 *(unsigned __int16 *)(dword_D3664 + 0x4E),
                 *(unsigned __int16 *)(dword_D3664 + 0x48));
        if ( (unsigned __int16)v110 == 0xFFFF )
        {
          format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x49);// 73: "%s is not growing."
        }
      }
      break;
    case 3:
      v17 = *(unsigned __int16 *)((char *)v109 + 0xAB);
      if ( (unsigned __int16)v17 != 0xFFFF )
      {
        HIBYTE(v18) = 0;
        v103 = (char *)(4 * v17 + *(_DWORD *)(dword_D3664 + 0x10));
        LOBYTE(v18) = v103[1];
        v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4B);// 75: "White"
        v19 = *v103;
        a2 = 0;
        switch ( v19 & 7 )
        {
          case 0:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4C);// 76: "Black"
            break;
          case 2:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4D);// 77: "Red"
            a2 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4E);// 78: "industry"
            break;
          case 3:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4F);// 79: "Green"
            a2 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x50);// 80: "prosperity"
            break;
          case 4:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x51);// 81: "Blue"
            a2 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x52);// 82: "research"
            break;
          default:
            break;
        }
        if ( *(_WORD *)((char *)v109 + 0xAB) >= *(_WORD *)(dword_D3664 + 0x18) )
        {
          v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x53);// 83: "Orbital"
        }
        if ( v18 == 0xFF )
        {
          if ( (*v103 & 8) != 0 && (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
          {
            v40 = v92;
            v41 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x58);// 88: "Xenoarcheological Ruins"
            do
            {
              v42 = *v41;
              *v40 = *v41;
              if ( !v42 )
              {
                break;
              }
              v43 = v41[1];
              v41 += 2;
              v40[1] = v43;
              v40 += 2;
            }
            while ( v43 );
          }
          else
          {
            v84 = v105;
            v44 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x59);// 89: "%s Square"
            sprintf(v92, v44, v84);
          }
          sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x14, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          if ( (*v103 & 8) == 0 )
          {
            if ( *(_WORD *)((char *)v109 + 0xAB) < *(_WORD *)(dword_D3664 + 0x18) )
            {
              if ( (*v103 & 7) == 1 )
              {
                v49 = v90;
                v50 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5B);// 91: "White squares are ordinary habitable surface squares."
                do
                {
                  v51 = *v50;
                  *v49 = *v50;
                  if ( !v51 )
                  {
                    break;
                  }
                  v52 = v50[1];
                  v50 += 2;
                  v49[1] = v52;
                  v49 += 2;
                }
                while ( v52 );
              }
              else if ( (*v103 & 7) != 0 )
              {
                v85 = a2;
                v77 = v105;
                v57 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5D);// 93: "%s squares increase the effectiveness of %s-producing structures."
                sprintf(v90, v57, v77, v85);
              }
              else
              {
                v53 = v90;
                v54 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5C);// 92: "Black squares are uninhabitable.  Most structures cannot be built on them."
                do
                {
                  v55 = *v54;
                  *v53 = *v54;
                  if ( !v55 )
                  {
                    break;
                  }
                  v56 = v54[1];
                  v54 += 2;
                  v53[1] = v56;
                  v53 += 2;
                }
                while ( v56 );
              }
            }
            else
            {
              v45 = v90;
              v46 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5A);// 90: "Orbital squares are used for building orbital structures such as 
                                                       // Shipyards and Ships."
              do
              {
                v47 = *v46;
                *v45 = *v46;
                if ( !v47 )
                {
                  break;
                }
                v48 = v46[1];
                v46 += 2;
                v45[1] = v48;
                v45 += 2;
              }
              while ( v48 );
            }
            sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0x50, v90, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          }
        }
        else
        {
          v20 = s;
          v21 = &dword_103F9A[0xA * v18 + 3];
          do
          {
            v22 = *(_BYTE *)v21;
            *v20 = *(_BYTE *)v21;
            if ( !v22 )
            {
              break;
            }
            v23 = *((_BYTE *)v21 + 1);
            v21 = (int *)((char *)v21 + 2);
            v20[1] = v23;
            v20 += 2;
          }
          while ( v23 );
          if ( v18 == 0x17 )
          {
            v24 = sub_35A70(dword_D3664, *(_WORD *)((char *)v109 + 0xAB));
            sprintf(s, "%s \"%s\"", (const char *)&dword_103F9A[0xE9], v24 + 0x34);
          }
          if ( (*((_WORD *)v103 + 1) & 2) != 0 )
          {
            v25 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x54);// 84: "Automated "
          }
          else
          {
            v25 = (char *)&unk_920AA;
          }
          v26 = v25;
          qmemcpy(v94, &unk_968A8, 0x32u);
          if ( *(_WORD *)((char *)v109 + 0xAB) < *(_WORD *)(dword_D3664 + 0x18) )
          {
            v82 = v105;
            v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x55);// 85: " on %s Square"
            sprintf(v94, v27, v82);
          }
          sprintf(v91, "%s%s%s", v26, s, v94);
          sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xF, v91, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          v28 = *(_WORD *)((char *)v109 + 0xAB);
          if ( !*(_WORD *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v28 + 2) )
          {
            v29 = *(_WORD *)(dword_D3664 + 0x44);
            v30 = *(_WORD *)(dword_D3664 + 0x50);
            v31 = sub_3583C(dword_D3664, v28, 0xFFu);
            v32 = sub_46C20(v31, v30, v29);
            v33 = v32;
            if ( v32 == 0xFFFF )
            {
              v34 = v91;
              v35 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x56);// 86: "No progress"
              do
              {
                v36 = *v35;
                *v34 = *v35;
                if ( !v36 )
                {
                  break;
                }
                v37 = v35[1];
                v35 += 2;
                v34[1] = v37;
                v34 += 2;
              }
              while ( v37 );
            }
            else
            {
              if ( v32 == 1 )
              {
                v38 = 0x1C;                            // 28: ""
              }
              else
              {
                v38 = 0x1D;                            // 29: "s"
              }
              v83 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v38);
              v39 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x57);// 87: "%d day%s until completion"
              sprintf(v91, v39, v33, v83);
            }
            sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x32, v91, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          }
        }
      }
      break;
    case 4:
      sub_2B8A8(
        (int)&V_Type3_stru_10AE70.z1[0x3046],
        0,
        0xF,
        (const char *)(dword_D3664 + 0x24),
        2,
        0xFFFFFFFF,
        0xFFFFFFFF,
        0);
      v86 = dword_10469C[*(unsigned __int16 *)(dword_D3664 + 0x16)];
      v78 = dword_104688[*(unsigned __int16 *)(dword_D3664 + 0x14)];
      v58 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5E);  // 94: "%s %s Planet"
      sprintf(v92, v58, v78, v86);
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x3C, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v59 = v100;
      v60 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5F);  // 95: "No One"
      do
      {
        v61 = *v60;
        *v59 = *v60;
        if ( !v61 )
        {
          break;
        }
        v62 = v60[1];
        v60 += 2;
        v59[1] = v62;
        v59 += 2;
      }
      while ( v62 );
      if ( *(unsigned __int8 *)(dword_D3664 + 0x57) != 0xFF )
      {
        v63 = v100;
        v64 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(unsigned __int8 *)(dword_D3664 + 0x57))];
        do
        {
          v65 = *v64;
          *v63 = *v64;
          if ( !v65 )
          {
            break;
          }
          v66 = v64[1];
          v64 += 2;
          v63[1] = v66;
          v63 += 2;
        }
        while ( v66 );
      }
      v79 = 4 * (unsigned __int8)byte_A2F74[0x1EE * *(unsigned __int8 *)(dword_D3664 + 0x57)] + 0x13;
      v67 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x60);  // 96: "Owned by |%d|%s"
      sprintf(v92, v67, v79, v100);
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x5A, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v87 = *(unsigned __int16 *)(dword_D3664 + 0x4A);
      v68 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x61);  // 97: "Maximum Population  %d"
      sprintf(v92, v68, v87);
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x78, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      if ( *(_BYTE *)(dword_D3664 + 0x57) == (_BYTE)byte_104BEA && *(_DWORD *)(dword_D3664 + 0x5A) == 0xFFFFFFFF )
      {
        v74 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
        v69 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x62);// 98: "Self Managed"
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x96, v69, 2, v74, 0xFFFFFFFF, 0);
      }
      break;
    default:
      break;
  }
  if ( v108 )
  {
    v88 = (unsigned __int16)v111;
    v80 = v108;
    v75 = dword_D3664 + 0x24;
    v70 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x63);    // 99: "%s %s: %d per day"
    sprintf(v92, v70, v75, v80, v88);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xF, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
    if ( v107 )
    {
      if ( (unsigned __int16)v110 == 0xFFFF )
      {
        sprintf(v92, format, v102);
      }
      else
      {
        if ( (unsigned __int16)v110 == 1 )
        {
          v71 = 0x1C;                                  // 28: ""
        }
        else
        {
          v71 = 0x1D;                                  // 29: "s"
        }
        v89 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v71);
        v81 = (unsigned __int16)v110;
        v76 = v106;
        v73 = v102;
        v72 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x64);// 100: "%s will %s in %d day%s."
        sprintf(v92, v72, v73, v76, v81, v89);
      }
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x50, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
    }
  }
  if ( *(_WORD *)((char *)v109 + 0x6B) )
  {
    sub_2D218(v109);
  }
}
// 9684C: using guessed type int dword_9684C;
// FFEEA: using guessed type __int16 word_FFEEA;
// 103F9A: using guessed type int dword_103F9A[];
// 104684: using guessed type int dword_104684[];
// 104688: using guessed type int dword_104688[4];
// 10469C: using guessed type int dword_10469C[10];
// 105296: using guessed type __int16 word_105296;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0003B120) --------------------------------------------------------
int __fastcall sub_3B120(int a1)
{
  char *v2; // edx
  int v3; // ebx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char v6; // al
  char v7; // al

  v2 = byte_1050A4;
  v3 = 0x65;
  do
  {
    v4 = v2;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3);
    do
    {
      v6 = *sub_1CEA8;
      *v4 = *sub_1CEA8;
      if ( !v6 )
      {
        break;
      }
      v7 = sub_1CEA8[1];
      sub_1CEA8 += 2;
      v4[1] = v7;
      v4 += 2;
    }
    while ( v7 );
    v2 += 0x14;
    ++v3;
  }
  while ( v2 != &byte_1050A4[0x1A4] );
  *(_BYTE *)(a1 + 1) = 0xFF;
  *(_BYTE *)a1 = 0xFF;
  *(_DWORD *)(a1 + 7) = 0;
  sub_3B188(a1);
  return a1;
}

//----- (0003B188) --------------------------------------------------------
int __fastcall sub_3B188(int result)
{
  int v1; // esi
  int v2; // edx
  int v3; // ebx

  v1 = result;
  *(_WORD *)(result + 0x1AA) = 0x12;
  *(_WORD *)(result + 0x1AC) = 0x16;
  *(_WORD *)(result + 0x1AE) = 0;
  *(_WORD *)(result + 0x19B) = 0;
  *(_WORD *)(result + 0x1D9) = 0;
  *(_WORD *)(result + 0x1DB) = 0;
  *(_BYTE *)(result + 0x1E9) = 0xE;
  v2 = result;
  *(_DWORD *)(result + 0x1EA) = 0;
  v3 = result + 0xE;
  do
  {
    result += 2;
    *(_BYTE *)(v2 + 0x1C0) = 0;
    ++v2;
    *(_WORD *)(result + 0x1B0) = 0;
  }
  while ( result != v3 );
  *(_DWORD *)(v1 + 3) = 0;
  return result;
}

//----- (0003B1FC) --------------------------------------------------------
int __fastcall sub_3B1FC(_BYTE *a1, char a2, __int16 a3)
{
  int result; // eax

  sub_3B188((int)a1);
  *a1 = a2;
  result = (unsigned __int8)a1[1];
  if ( result != a3 )
  {
    a1[1] = a3;
    return sub_43C80((int)a1, a3, a3, (int)a1);
  }
  return result;
}

//----- (0003B220) --------------------------------------------------------
char __fastcall sub_3B220(int a1, int a2, int a3, int a4)
{
  int v4; // ebp
  __int16 v5; // di
  int v6; // esi
  int v7; // eax
  int v8; // ebx
  __int16 v9; // dx
  int v10; // ebx
  int v11; // edx
  int v12; // eax
  char v13; // dl
  int v14; // ecx
  int v16[107]; // [esp+0h] [ebp-1CCh] BYREF
  size_t v17; // [esp+1ACh] [ebp-20h]
  int v18; // [esp+1B0h] [ebp-1Ch]

  v4 = a1;
  if ( *(_DWORD *)(a1 + 3) != 0xFFFFFFFF )
  {
    v18 = sub_3EFE0(a1);
    if ( v18 < 0 )
    {
      v5 = 0;
      v17 = sub_40224((unsigned __int8 *)v4, v16, 0) - 1;
      while ( v5 < -v18 )
      {
        v6 = v16[v17 - v5];
        if ( *(_BYTE *)v4 == (_BYTE)byte_104BEA )
        {
          a4 = 0;
          sub_55AEC((int)&V_Type3_stru_10AE70, 0xB, *(char *)(v6 + 0xAA), 0);
        }
        sub_49940(v6);
        ++v5;
      }
    }
    v7 = sub_40224((unsigned __int8 *)v4, v16, 0);
    sub_3C1C0((unsigned __int8 *)v4, v16, v7);
    v8 = sub_40224((unsigned __int8 *)v4, v16, 0);
    if ( !v8 && !sub_402E0((_BYTE *)v4) )
    {
      v9 = 0xA;
      LOBYTE(v8) = *(_BYTE *)v4;
      *(_DWORD *)(v4 + 3) = 0xFFFFFFFF;
LABEL_19:
      LOBYTE(a1) = sub_55AEC((int)&V_Type3_stru_10AE70, v9, v8, 0);
      return a1;
    }
    if ( v8 > 0 )
    {
      v10 = 4 * v8;
      v11 = 0;
      do
      {
        v12 = v16[v11 / 4u];
        v11 += 4;
        sub_4A6AC(v12, v11, v10, a4);
      }
      while ( v11 < v10 );
    }
    v8 = 0;
    dword_10509C = 0;
    sub_3B5B8((unsigned __int8 *)v4);
    sub_405F4((_BYTE *)v4);
    LOBYTE(a1) = *(_BYTE *)(*(_DWORD *)(v4 + 7) + 0x14) & 0x80;
    if ( (_BYTE)a1 )
    {
      v13 = byte_104BEA;
      v14 = *(_DWORD *)(v4 + 0x19E) + 1;
      LOBYTE(a1) = *(_BYTE *)v4;
      *(_DWORD *)(v4 + 0x19E) = v14;
      if ( (_BYTE)a1 == v13 )
      {
        if ( v14 )
        {
          a1 = (unsigned __int16)word_968E8[*(char *)(v4 + 0x19D)];
          if ( a1 == v14 )
          {
            v9 = 0x18;
            goto LABEL_19;
          }
        }
      }
    }
  }
  return a1;
}
// 968E8: using guessed type __int16 word_968E8[21];
// 10509C: using guessed type int dword_10509C;
// 3B220: using guessed type int var_1CC[107];

//----- (0003B56C) --------------------------------------------------------
int __fastcall sub_3B56C(unsigned __int8 *a1, __int16 *a2)
{
  int v3; // edi
  __int16 i; // dx
  int result; // eax
  int v6; // eax
  int v7[111]; // [esp+0h] [ebp-1BCh] BYREF

  v3 = sub_1D794(a2, v7);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
    {
      break;
    }
    v6 = v7[i];
    if ( v6 )
    {
      if ( *(_WORD *)(v6 + 0x56) == *a1 )
      {
        sub_4A5B8(v6);
      }
    }
  }
  return result;
}
// 3B56C: using guessed type int var_1BC[111];

//----- (0003B5B8) --------------------------------------------------------
void __fastcall sub_3B5B8(unsigned __int8 *a1)
{
  int v1; // ebx
  int v2; // edi
  __int16 i; // bx
  __int16 *v4; // edi
  __int16 j; // dx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // ebp
  int v13; // ecx
  int v14; // eax
  int v15; // ebx
  int v16; // eax
  int v17; // ecx
  double v18; // st7
  double v19; // st7
  double v20; // st7
  __int16 k; // si
  int v22; // ecx
  __int16 v23; // dx
  int v24; // eax
  int v25; // eax
  __int16 v26; // di
  int v27; // edx
  __int16 *v28; // ebp
  __int16 m; // si
  __int16 *v30; // edi
  __int16 n; // bx
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // ebp
  int v36; // ecx
  __int16 v37; // si
  int v38; // ecx
  __int16 v39; // si
  signed int v40; // ebp
  char *v41; // ecx
  int v42; // edx
  __int16 ii; // bx
  char *v44; // edx
  int v45[107]; // [esp+0h] [ebp-214h] BYREF
  int v46; // [esp+1ACh] [ebp-68h]
  int v47; // [esp+1B0h] [ebp-64h]
  float v48; // [esp+1B4h] [ebp-60h]
  int v49; // [esp+1B8h] [ebp-5Ch]
  int v50; // [esp+1BCh] [ebp-58h]
  int v51; // [esp+1C0h] [ebp-54h]
  int v52; // [esp+1C4h] [ebp-50h]
  unsigned __int8 *v53; // [esp+1C8h] [ebp-4Ch]
  float v54; // [esp+1CCh] [ebp-48h]
  int v55; // [esp+1D0h] [ebp-44h]
  int v56; // [esp+1D4h] [ebp-40h]
  _BYTE *v57; // [esp+1D8h] [ebp-3Ch]
  int v58; // [esp+1DCh] [ebp-38h]
  float v59; // [esp+1E0h] [ebp-34h]
  float v60; // [esp+1E4h] [ebp-30h]
  float v61; // [esp+1E8h] [ebp-2Ch]
  float v62; // [esp+1ECh] [ebp-28h]
  int v63; // [esp+1F0h] [ebp-24h]
  int v64; // [esp+1F4h] [ebp-20h]
  unsigned __int8 v65; // [esp+1F8h] [ebp-1Ch]

  v53 = a1;
  v49 = sub_40224(a1, v45, 0);
  if ( *v53 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF )
  {
    sub_3C670(v53);
    v1 = v49;
    sub_3C968((int)v53);
    sub_44080(v53);
    sub_3C2E8(v53, (int)v45, v1);
  }
  if ( sub_40590(v53) != 0xFFFFFFFF
    && ((_BYTE)byte_104BEA != *v53 || dword_A0D00 || dword_106FC2 == 0xFFFFFFFF)
    && (unsigned __int16)word_106FA6[*v53] == 0xFFFF )
  {
    sub_3EA7C(v53);
  }
  if ( (_BYTE)byte_104BEA != *v53 || dword_A0D00 == 0xFFFFFFFF )
  {
    sub_434E4((char *)v53, 1);
  }
  v2 = v49;
  for ( i = 0; i < v2; ++i )
  {
    if ( (_BYTE)byte_104BEA != *v53 || dword_A0D00 == 0xFFFFFFFF )
    {
      sub_3EBDC((int)v53, v45[i]);
    }
  }
  if ( (_BYTE)byte_104BEA != *v53 || dword_A0D00 == 0xFFFFFFFF )
  {
    LOWORD(v64) = sub_3EFE0((int)v53);
    if ( (__int16)v64 > 0xA )
    {
      LOWORD(v64) = 0xA;
    }
    if ( (__int16)v64 > 0 )
    {
      v61 = 0.0;
      v59 = 0.0;
      v60 = 0.0;
      v4 = word_A3D21;
      v65 = sub_43374(v53, 0xFFFFFFFF);
      for ( j = 0; j < word_A62A1; v4 += 0x30 )
      {
        if ( ((_BYTE)v4[0xA] & v65) != 0 )
        {
          v10 = dword_104BEC[j];
          v11 = *(int *)((char *)&dword_104F6D + j) >> 0x18;
          v58 = v10;
          if ( v11 > 1 )
          {
            v58 = v10 >> (v11 - 1);
          }
          v12 = j;
          v13 = *(int *)((char *)&dword_104F09 + j);
          v14 = dword_104D7C[v12];
          v15 = dword_104BEC[v12];
          v59 = (double)v58 + v59;
          v16 = v15 + v14;
          v17 = v13 >> 0x18;
          v58 = v16;
          if ( v17 > 0 )
          {
            v58 = v16 >> v17;
          }
          v61 = (double)v58 + v61;
        }
        else if ( (*((_BYTE *)v4 + 0x15) & v65) != 0 )
        {
          v6 = dword_104D7C[j];
          v7 = *(int *)((char *)&dword_104F09 + j) >> 0x18;
          v52 = v6;
          if ( v7 > 0 )
          {
            v52 = v6 >> v7;
          }
          v61 = (double)v52 + v61;
        }
        else
        {
          if ( *(int *)((char *)&dword_104FD1 + j) >> 0x18 <= 0 )
          {
            v60 = (double)dword_104BEC[j] + v60;
          }
          v8 = dword_104D7C[j];
          v9 = *(int *)((char *)&dword_104F09 + j) >> 0x18;
          v51 = v8;
          if ( v9 > 0 )
          {
            v51 = v8 >> v9;
          }
          v61 = (double)v51 + v61;
        }
        ++j;
      }
      v60 = v60 * flt_920F0;
      v18 = v59 * dbl_920F4;
      v59 = v18;
      v48 = v18 + v61 + v60;
      if ( v48 <= 0.0 )
      {
        v47 = (__int16)v64 / 3;
        v60 = (float)v47;
        v61 = v60;
        v59 = (double)(__int16)v64 - v60 - v60;
      }
      else
      {
        v19 = (double)(__int16)v64;
        v59 = v59 * v19;
        v61 = v61 * v19;
        v60 = v19 * v60;
        v20 = 1.0 / v48;
        v59 = v59 * v20;
        v61 = v61 * v20;
        v60 = v20 * v60;
      }
      for ( k = 0; k < v49; ++k )
      {
        v22 = v45[k];
        if ( !v22 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x22A);
        }
        if ( *(_BYTE *)(v22 + 0x58) == 1 )
        {
          if ( *(_DWORD *)(v22 + 0x28) && v60 > 0.0 )
          {
            v60 = v60 - 1.0;
          }
          else if ( sub_4A534(v22, 0x49) && v59 > 0.0 )
          {
            v59 = v59 - 1.0;
          }
          else if ( v61 > 0.0 )
          {
            v61 = v61 - 1.0;
          }
        }
      }
      v23 = 0;
      while ( 1 )
      {
        v24 = v23;
        if ( v23 >= 0x64 )
        {
          break;
        }
        ++v23;
        dword_1046E8[v24] = 0;
        dword_104878[v24] = 0;
        dword_104A08[v24] = 0;
      }
      v25 = 0;
      if ( (__int16)v64 > 0 )
      {
        v26 = v64;
        do
        {
          v27 = (__int16)v25++;
          dword_104B98[v27] = 0xFFFFFFFF;
        }
        while ( (__int16)v25 < v26 );
      }
      v28 = word_A3D21;
      for ( m = 0; m < word_A62A1; v28 += 0x30 )
      {
        if ( ((1 << *v53) & (unsigned __int8)v28[0xA]) != 0 )
        {
          v30 = word_A3D21;
          for ( n = 0; n < word_A62A1; v30 += 0x30 )
          {
            if ( ((1 << *v53) & (unsigned __int8)v30[0xB]) != 0 )
            {
              v47 = 1 / ((__int16)sub_1DA04((int)v30, (int)v28) / 0x19 + 1);
              v62 = (float)v47;
              v54 = v62;
              if ( ((_BYTE)v28[0xA] & v65) != 0 )
              {
                v34 = *(int *)((char *)&dword_104F6D + n) >> 0x18;
                v50 = (int)((double)dword_104BEC[n] * v62);
                if ( v34 >= 1 )
                {
                  if ( v34 < 2 )
                  {
                    dword_104A08[m] += v50 / 2;
                  }
                }
                else
                {
                  dword_104A08[m] += v50;
                }
                if ( *(int *)((char *)&dword_104F09 + n) >> 0x18 < 1 )
                {
                  dword_104878[m] += v50;
                }
              }
              else if ( (*((_BYTE *)v28 + 0x15) & v65) != 0 )
              {
                v47 = dword_104BEC[n] + dword_104D7C[n];
                v32 = *(int *)((char *)&dword_104F09 + n) >> 0x18;
                v55 = (int)((double)v47 * v62);
                if ( v32 < 1 )
                {
                  dword_104878[m] += v55;
                }
              }
              else
              {
                if ( *(int *)((char *)&dword_104FD1 + n) >> 0x18 < 1 )
                {
                  dword_1046E8[m] = (int)((double)dword_104BEC[n] * v62 * flt_920F0 + (double)dword_1046E8[m]);
                }
                v33 = *(int *)((char *)&dword_104F09 + n) >> 0x18;
                v46 = (int)((double)dword_104D7C[n] * v54);
                if ( v33 < 1 )
                {
                  dword_104878[m] += v46;
                }
              }
            }
            ++n;
          }
        }
        ++m;
      }
      v57 = &unk_BB1B3;
      LOWORD(v63) = 0;
      if ( SHIWORD(dword_CA1ED) > 0 )
      {
        do
        {
          if ( v57[0x54] == 0xFF && (unsigned __int16)sub_35930((int)v57, 0x16) != 0xFFFF && v57[0x57] == *v53 )
          {
            v38 = *((__int16 *)v57 + 6);
            if ( v38 >= 0x64 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2A1);
            }
            v56 = (dword_104878[v38] + dword_1046E8[v38] + dword_104A08[v38]) / 0xA;
            v35 = 0;
            v37 = 0;
            v36 = dword_104BC0[0];
            v56 *= *((unsigned __int16 *)v57 + 0x22);
            if ( (__int16)v64 > 0 )
            {
              while ( 1 )
              {
                if ( v37 >= 0xA )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2B1);
                }
                if ( dword_104B98[v37] == 0xFFFFFFFF )
                {
                  break;
                }
                if ( v36 > dword_104BC0[v37] )
                {
                  v35 = v37;
                  v36 = dword_104BC0[v37];
                }
                if ( ++v37 >= (__int16)v64 )
                {
                  goto LABEL_96;
                }
              }
              v35 = v37;
            }
LABEL_96:
            if ( v56 > dword_104BC0[v35] || dword_104B98[v35] == 0xFFFFFFFF )
            {
              dword_104B98[v35] = (__int16)v63;
              dword_104BC0[v35] = v56;
            }
          }
          LOWORD(v63) = v63 + 1;
          v57 += 0x7B;
        }
        while ( (__int16)v63 < SHIWORD(dword_CA1ED) );
      }
      v2 = v64;
      v39 = 0;
      if ( (__int16)v64 > 0 )
      {
        while ( 1 )
        {
          v40 = dword_104B98[v39];
          if ( v40 <= (int)0xFFFFFFFF || SHIWORD(dword_CA1ED) <= v40 )
          {
            goto LABEL_117;
          }
          v41 = (char *)&unk_BB1B3 + 0x7B * v40;
          if ( !v41 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2D9);
          }
          v2 = *((__int16 *)v41 + 6);
          if ( v2 >= 0x64 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2DD);
          }
          if ( v60 > 0.0 )
          {
            v42 = dword_1046E8[v2];
            if ( v42 > dword_104878[v2] && v42 > dword_104A08[v2] )
            {
              break;
            }
          }
          if ( v61 > 0.0 && dword_104878[v2] > dword_104A08[v2] )
          {
LABEL_116:
            sub_3CB60(v53, (int)&unk_BB1B3 + 0x7B * v40, 1u);
            v61 = v61 - 1.0;
            goto LABEL_117;
          }
          if ( v59 <= 0.0 )
          {
            if ( v60 > 0.0 )
            {
              break;
            }
            if ( v61 > 0.0 )
            {
              goto LABEL_116;
            }
          }
          else
          {
            sub_3CB60(v53, (int)&unk_BB1B3 + 0x7B * v40, 2u);
            v59 = v59 - 1.0;
          }
LABEL_117:
          if ( ++v39 >= (__int16)v64 )
          {
            goto LABEL_128;
          }
        }
        sub_3CB60(v53, (int)&unk_BB1B3 + 0x7B * v40, 0);
        v60 = v60 - 1.0;
        goto LABEL_117;
      }
    }
  }
LABEL_128:
  for ( ii = 0; ii < SHIWORD(dword_CA1ED); ++ii )
  {
    v44 = (char *)&unk_BB1B3 + 0x7B * ii;
    if ( v44[0x57] == *v53
      && (*v53 != (_BYTE)byte_104BEA || *(_DWORD *)(v44 + 0x5A) || dword_A0D00)
      && v44[0x54] == (char)0xFF )
    {
      sub_3D8F0(v53, (int)v44, v2);
    }
  }
}
// 920F0: using guessed type float flt_920F0;
// 920F4: using guessed type double dbl_920F4;
// A0D00: using guessed type int dword_A0D00;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// CA1ED: using guessed type int dword_CA1ED;
// 1046E8: using guessed type int dword_1046E8[100];
// 104878: using guessed type int dword_104878[100];
// 104A08: using guessed type int dword_104A08[100];
// 104B98: using guessed type int dword_104B98[];
// 104BC0: using guessed type int dword_104BC0[9];
// 104BEC: using guessed type int dword_104BEC[100];
// 104D7C: using guessed type int dword_104D7C[99];
// 104F09: using guessed type int dword_104F09;
// 104F6D: using guessed type int dword_104F6D;
// 104FD1: using guessed type int dword_104FD1;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FC2: using guessed type int dword_106FC2;
// 3B5B8: using guessed type int var_214[107];

//----- (0003C12C) --------------------------------------------------------
unsigned int __fastcall sub_3C12C(unsigned __int8 *a1, _DWORD *a2)
{
  int v3; // ebp
  int v4; // esi
  char v5; // al
  int v6; // ebx

  v3 = *(_DWORD *)((char *)a2 + 0x15A) - *(_DWORD *)((char *)a2 + 0x15E);
  v4 = 0;
  v5 = sub_4A36C((int)a2, 0, *a1);
  if ( v5 <= (char)0xFFFFFFFF || v5 >= 0x4C )
  {
    v6 = 0;
  }
  else
  {
    v6 = *(int *)((char *)&dword_107072 + 0x6A * v5);
  }
  if ( 3 * v3 > *(_DWORD *)((char *)a2 + 0x15A)
    || !a2[0xA] && !sub_4A534((int)a2, 0x49) && v6 > *a2
    || sub_4A8CC((int)a2) >= 1 && sub_4A1CC((int)a2, *a1) >= 0xF )
  {
    return 0xFFFFFFFF;
  }
  return v4;
}
// 107072: using guessed type int dword_107072;

//----- (0003C1C0) --------------------------------------------------------
char __fastcall sub_3C1C0(unsigned __int8 *a1, int *a2, int a3)
{
  int *v4; // esi
  signed int v5; // eax
  int v6; // ecx
  __int16 v7; // ax
  int i; // edi
  int v9; // ecx
  char v10; // dl
  char v11; // bl

  v4 = a2;
  v5 = sub_3EFE0((int)a1);
  if ( v5 < 2 )
  {
    if ( a2 )
    {
      if ( a3 > 0 )
      {
        LOBYTE(v5) = *a1;
        if ( *a1 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF )
        {
          v6 = 1 << *a1;
          v7 = 0;
          if ( (v6 & SHIBYTE(dword_1052EA)) != 0 )
          {
            v7 = 1;
            if ( (v6 & SHIBYTE(dword_105830)) != 0 )
            {
              v7 = 2;
              if ( (v6 & SHIBYTE(dword_105BB4)) != 0 )
              {
                v7 = 3;
              }
            }
          }
          if ( !v7 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x365);
          }
          for ( i = 0; i < a3; ++i )
          {
            if ( !v4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x36B);
            }
            v9 = *v4;
            if ( !*v4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x36F);
            }
            v10 = *(_BYTE *)(v9 + 0x58);
            if ( v10 != 1 && v10 != 2 )
            {
              v11 = *(_BYTE *)(v9 + 0x5D);
              if ( v11 != 2 && v11 != 5 && v11 != 6 && sub_3C12C(a1, (_DWORD *)v9) )
              {
                sub_49940(v9);
              }
            }
            LOBYTE(v5) = a3;
            ++v4;
          }
        }
      }
    }
  }
  return v5;
}
// 3C265: conditional instruction was optimized away because ebx.4>=1
// A0D00: using guessed type int dword_A0D00;
// 1052EA: using guessed type int dword_1052EA;
// 105830: using guessed type int dword_105830;
// 105BB4: using guessed type int dword_105BB4;

//----- (0003C2E8) --------------------------------------------------------
int __fastcall sub_3C2E8(unsigned __int8 *a1, int a2, int a3)
{
  __int16 *v3; // edi
  __int16 v4; // si
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  __int16 i; // si
  int v9; // edi
  int v10; // ebx
  int v11; // edi
  int v12; // ebx
  int result; // eax
  int v14; // ecx
  char v15; // al
  _BYTE v17[6]; // [esp+8h] [ebp-1Ch]
  char v18; // [esp+10h] [ebp-14h]

  *(_DWORD *)v17 = a3;
  v18 = sub_43374(a1, 0xFFFFFFFF);
  v3 = word_A3D21;
  sub_1FD90((int)dword_A2F6C, (int)&dword_105035 + 3, *a1);
  *(_WORD *)&v17[4] = 0;
  if ( word_A62A1 > 0 )
  {
    do
    {
      v6 = *(__int16 *)&v17[4];
      dword_104BEC[v6] = sub_1DA4C((int)v3, *a1, a2, *(int *)v17);
      dword_104D7C[v6] = sub_1DB70((int)v3, *a1, a2, *(int *)v17);
      v7 = *(int *)((char *)&dword_105035 + (char)((unsigned int)*(__int16 *)&v17[4] >> 0x18));
      if ( v7 > 0 && (*((_BYTE *)v3 + 0x15) & (unsigned __int8)v18) != 0 )
      {
        dword_104D7C[*(__int16 *)&v17[4]] = 2 * dword_104D7C[*(__int16 *)&v17[4]] + 0x12C + 0x96 * v7;
      }
      v4 = word_A62A1;
      v3 += 0x30;
      v5 = *(int *)&v17[2] >> 0x10;
      ++*(_WORD *)&v17[4];
      *((_BYTE *)&dword_104F09 + v5 + 3) = 0;
      *((_BYTE *)&dword_104F6D + v5 + 3) = 0;
      *((_BYTE *)&dword_104FD1 + v5 + 3) = 0;
    }
    while ( *(__int16 *)&v17[4] < v4 );
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(int *)v17 )
    {
      break;
    }
    v14 = *(_DWORD *)(a2 + 4 * i);
    if ( !v14 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3B3);
    }
    v15 = *(_BYTE *)(v14 + 0x58);
    v12 = 0xFFFFFFFF;
    if ( v15 == 4 )
    {
      v11 = *(_DWORD *)(v14 + 0x59);
      if ( !v11 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3BB);
      }
      goto LABEL_16;
    }
    if ( v15 == 3 )
    {
      v9 = *(_DWORD *)(v14 + 0x59);
      if ( !v9 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3C3);
      }
      v10 = *(_DWORD *)(v9 + 0xA);
      goto LABEL_17;
    }
    if ( v15 == 5 && *(_BYTE *)(v14 + 0x5D) == 1 )
    {
      v11 = *(_DWORD *)(v14 + 0x5E);
      if ( !v11 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3CC);
      }
LABEL_16:
      v10 = *(_DWORD *)(v11 + 2);
LABEL_17:
      v12 = v10 >> 0x10;
    }
    if ( v12 > (int)0xFFFFFFFF && v12 < word_A62A1 )
    {
      if ( *(_DWORD *)(v14 + 0x28) )
      {
        ++*((_BYTE *)&dword_104FD1 + v12 + 3);
      }
      else if ( sub_4A534(v14, 0x49) )
      {
        ++*((_BYTE *)&dword_104F6D + v12 + 3);
      }
      else
      {
        ++*((_BYTE *)&dword_104F09 + v12 + 3);
      }
    }
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// 104BEC: using guessed type int dword_104BEC[];
// 104D7C: using guessed type int dword_104D7C[99];
// 104F09: using guessed type int dword_104F09;
// 104F6D: using guessed type int dword_104F6D;
// 104FD1: using guessed type int dword_104FD1;
// 105035: using guessed type int dword_105035;

//----- (0003C670) --------------------------------------------------------
char __fastcall sub_3C670(_BYTE *a1)
{
  _BYTE *v1; // ebp
  __int16 *v2; // eax
  int i; // edx
  __int16 v4; // bx
  unsigned __int8 *v5; // ecx
  __int16 v6; // si
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  bool v12; // zf
  int v13; // edx
  int v14; // ecx
  unsigned __int8 v15; // dl
  int v17; // [esp+0h] [ebp-34h]
  __int16 v18; // [esp+4h] [ebp-30h]
  int v19; // [esp+8h] [ebp-2Ch]
  int v20; // [esp+Ch] [ebp-28h]
  unsigned __int8 v21; // [esp+10h] [ebp-24h]
  unsigned __int8 v22; // [esp+14h] [ebp-20h]
  unsigned __int8 v23; // [esp+18h] [ebp-1Ch]

  v1 = a1;
  LOWORD(v20) = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( 1 )
    {
      LOBYTE(a1) = v20;
      v14 = (unsigned __int8)*v1;
      if ( (__int16)v20 != v14
        && v1[(__int16)v20 + 0x1C0]
        && *(int *)((char *)&dword_A2F75 + 0x1EE * (__int16)v20) != 0xFFFFFFFF )
      {
        break;
      }
LABEL_54:
      LOWORD(v20) = v20 + 1;
      if ( (__int16)v20 >= SHIWORD(dword_A3CF2) )
      {
        return (char)a1;
      }
    }
    v15 = v1[(__int16)v20 + 0x1C0];
    v4 = 0;
    if ( v15 < 2u )
    {
      v12 = v15 == 1;
    }
    else
    {
      if ( v15 <= 2u )
      {
        v4 = word_A3CF6[3 * (__int16)v20] - word_A3CF6[3 * v14];
        if ( v4 >= 0 )
        {
          if ( v4 > 3 )
          {
            v4 = 3;
          }
        }
        else
        {
          v4 = 0;
        }
        goto LABEL_34;
      }
      v12 = v15 == 3;
    }
    if ( v12 )
    {
      if ( v1[(__int16)v20 + 0x1C0] == 1 )
      {
        v2 = word_A3D21;
        for ( i = 0; i < word_A62A1; ++i )
        {
          if ( ((1 << *v1) & (unsigned __int8)v2[0xA]) != 0 && ((1 << v20) & *((unsigned __int8 *)v2 + 0x15)) != 0 )
          {
            v17 = unk_96912;
            v18 = *((_WORD *)&unk_96912 + 2);
            v4 += *((_WORD *)&v17 + byte_A3D20);
          }
          v2 += 0x30;
        }
      }
      v5 = (unsigned __int8 *)&byte_A2F72[0x1EE * (__int16)v20];
      v21 = sub_43374(v5, 0xFFFFFFFF);
      v22 = v21;
      v23 = sub_43374(v5, 0xFFFFFFFF);
      if ( v23 != v21 )
      {
        v6 = 0;
        v7 = 0;
        v8 = 0;
        v19 = 0;
        while ( v7 < SHIWORD(dword_A3CF2) )
        {
          if ( v7 != (__int16)v20 && v7 != (unsigned __int8)*v1 )
          {
            if ( ((1 << v7) & v22) != 0 )
            {
              v6 += *(_WORD *)((char *)&dword_A3CF8 + v8);
            }
            v9 = 1 << v7;
            if ( (v23 & (1 << v7)) != 0 )
            {
              LOWORD(v9) = *(_WORD *)((char *)&dword_A3CF8 + v8);
              v19 += v9;
            }
          }
          v8 += 6;
          ++v7;
        }
        if ( v6 <= (__int16)v19 )
        {
          v4 += 3;
        }
        else
        {
          --v4;
        }
        if ( v1[(__int16)v20 + 0x1C0] == 1 )
        {
          v10 = *(int *)((char *)&dword_A3CF2 + 6 * (__int16)v20 + 2) >> 0x10;
          v11 = *(int *)((char *)&dword_A3CF2 + 6 * (unsigned __int8)*v1 + 2) >> 0x10;
          if ( v10 - v11 <= 1 )
          {
            if ( v11 - v10 > 1 )
            {
              v4 += 4;
            }
          }
          else
          {
            v4 -= 2;
          }
        }
      }
    }
LABEL_34:
    LOBYTE(a1) = byte_104BEA;
    if ( (__int16)v20 == (unsigned __int8)byte_104BEA && !dword_A0D00 )
    {
      if ( v4 < 0 )
      {
        LOBYTE(a1) = byte_A3D20;
        if ( byte_A3D20 )
        {
          if ( (unsigned __int8)byte_A3D20 <= 1u )
          {
            v4 *= 2;
          }
          else if ( byte_A3D20 == 2 )
          {
            v4 *= 3;
          }
        }
      }
      else
      {
        LOBYTE(a1) = byte_A3D20;
        if ( byte_A3D20 )
        {
          if ( (unsigned __int8)byte_A3D20 <= 1u )
          {
            LOWORD(a1) = v4 / 2;
            v4 /= 2;
          }
          else if ( byte_A3D20 == 2 )
          {
            LOWORD(a1) = v4 / 3;
            v4 /= 3;
          }
        }
      }
    }
    if ( v4 )
    {
      a1 = &v1[2 * (__int16)v20];
      *((_WORD *)a1 + 0xD9) += v4;
      v13 = *((__int16 *)a1 + 0xD9);
      if ( v13 >= 0x32 )
      {
        if ( v13 > 0x3B6 )
        {
          *((_WORD *)a1 + 0xD9) = 0x3B6;
        }
      }
      else
      {
        *((_WORD *)a1 + 0xD9) = 0x32;
      }
    }
    goto LABEL_54;
  }
  return (char)a1;
}
// A0D00: using guessed type int dword_A0D00;
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3CF6: using guessed type __int16 word_A3CF6[];
// A3CF8: using guessed type int dword_A3CF8;
// A3D20: using guessed type char byte_A3D20;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (0003C968) --------------------------------------------------------
int __fastcall sub_3C968(int a1)
{
  int result; // eax
  double v3; // st7
  float v4; // edx
  double v5; // st7
  double v6; // [esp+8h] [ebp-34h]
  double v7; // [esp+8h] [ebp-34h]
  double v8; // [esp+8h] [ebp-34h]
  double v9; // [esp+10h] [ebp-2Ch]
  double v10; // [esp+10h] [ebp-2Ch]
  float v11; // [esp+18h] [ebp-24h]
  float v12; // [esp+1Ch] [ebp-20h]
  float v13; // [esp+20h] [ebp-1Ch]
  float v14; // [esp+24h] [ebp-18h]
  float v15; // [esp+24h] [ebp-18h]
  float v16; // [esp+24h] [ebp-18h]

  result = dword_A2F6C / 0xA;
  if ( dword_A2F6C % 0xA )
  {
    return result;
  }
  v13 = (double)(dword_A2F6C % *(__int16 *)(a1 + 0x1D7)) / (double)*(__int16 *)(a1 + 0x1D7) * dbl_92150;
  if ( (LODWORD(v13) & 0x7FFFFFFF) == 0 )
  {
    v13 = 0.0099999998;
  }
  v6 = *(float *)(a1 + 0x1DD);
  v7 = sin(v13) * v6;
  v9 = *(float *)(a1 + 0x1E1);
  v10 = sin(v13 * flt_92158) * v9 + v7;
  v8 = *(float *)(a1 + 0x1E5);
  v14 = sin(v13 * flt_9215C) * v8 + v10;
  if ( v14 >= 0.0 )
  {
    v3 = v14 + flt_92158;
  }
  else
  {
    v3 = v14 + flt_92160;
  }
  v15 = v3;
  v11 = (float)*(__int16 *)(a1 + 0x1D9);
  if ( v15 > (double)v11 )
  {
    v4 = (float)*(__int16 *)(a1 + 0x1D9);
LABEL_11:
    v15 = v4;
    goto LABEL_12;
  }
  v12 = (float)*(__int16 *)(a1 + 0x1DB);
  if ( v15 < (double)v12 )
  {
    v4 = (float)*(__int16 *)(a1 + 0x1DB);
    goto LABEL_11;
  }
LABEL_12:
  if ( *(_BYTE *)a1 == (_BYTE)byte_104BEA )
  {
    word_104BE8 = (int)v15;
  }
  if ( byte_A3D20 == 2 )
  {
    v5 = v15 + flt_9216C;
  }
  else if ( byte_A3D20 )
  {
    v5 = v15 + flt_92164;
  }
  else
  {
    v5 = v15 + flt_92168;
  }
  for ( result = 0; (__int16)result < SHIWORD(dword_A3CF2); ++result )
  {
    if ( *(_BYTE *)((__int16)result + a1 + 0x1C0) )
    {
      if ( !*(int *)((char *)&dword_A2F75 + 0x1EE * (__int16)result) )
      {
        v16 = v5;
        *(_WORD *)(a1 + 2 * (__int16)result + 0x1B2) = (int)((double)*(__int16 *)(a1 + 2 * (__int16)result + 0x1B2) + v16);
      }
    }
  }
  return result;
}
// 92150: using guessed type double dbl_92150;
// 92158: using guessed type float flt_92158;
// 9215C: using guessed type float flt_9215C;
// 92160: using guessed type float flt_92160;
// 92164: using guessed type float flt_92164;
// 92168: using guessed type float flt_92168;
// 9216C: using guessed type float flt_9216C;
// A2F6C: using guessed type int dword_A2F6C;
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;
// 104BE8: using guessed type __int16 word_104BE8;

//----- (0003CB60) --------------------------------------------------------
int __fastcall sub_3CB60(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  char *v5; // eax
  int v6; // ebp
  int v7; // [esp+0h] [ebp-14h]

  if ( *(_WORD *)(a2 + 0x44) )
  {
    if ( (unsigned __int16)sub_35930(a2, 0x16) == 0xFFFF )
    {
      if ( (dword_A2F6C[0] > 0xAA || byte_A3D20 == 2)
        && ((1 << *a1) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104311) >> 0x18)) != 0 )
      {
        if ( !sub_34AE4(a2, 0x16u, 0) )
        {
          return 2;
        }
        return 1;
      }
    }
    else if ( sub_362E0(a2) && (*(_BYTE *)(a2 + 0x57) != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF) )
    {
      v7 = sub_34AE4(a2, 0x17u, 0);
      if ( v7 != 0xFFFF )
      {
        v5 = sub_40144(a1, a2);
        v6 = (int)v5;
        if ( !v5 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x537);
        }
        sub_3F060(a1, v5, a2, a3);
        sub_35B04(a2, v7, v6);
        return 1;
      }
    }
  }
  return 0;
}
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// A3D20: using guessed type char byte_A3D20;
// 104311: using guessed type char byte_104311;
// 10529F: using guessed type int dword_10529F;

//----- (0003CCE4) --------------------------------------------------------
unsigned int __fastcall sub_3CCE4(_BYTE *a1, int a2)
{
  unsigned int v4; // ebp
  int v5; // eax
  int v6; // edi
  int v7; // ebx
  int v8; // ebx
  int v9; // ecx
  int v10; // edx
  unsigned __int8 v11; // al
  __int16 v12; // ax
  int v13; // eax
  int *v14; // ebx
  unsigned __int8 *v15; // edi
  int v16; // eax
  int v17; // edi
  char v18; // al
  int v19; // edi
  int v20; // eax
  char v21; // ah
  int v22; // edi
  int v23; // eax
  int v24; // edi
  int v25; // eax
  int v26; // edx
  int v27; // ebx
  char v28; // bl
  unsigned __int8 v29; // bh
  int v31[3]; // [esp+0h] [ebp-10Ch]
  int v32; // [esp+Ch] [ebp-100h]
  int v33; // [esp+10h] [ebp-FCh]
  int v34; // [esp+18h] [ebp-F4h]
  int v35; // [esp+1Ch] [ebp-F0h]
  int v36; // [esp+20h] [ebp-ECh]
  int v37; // [esp+24h] [ebp-E8h]
  int v38; // [esp+28h] [ebp-E4h]
  int v39; // [esp+2Ch] [ebp-E0h]
  int v40; // [esp+30h] [ebp-DCh]
  int v41; // [esp+34h] [ebp-D8h]
  int v42; // [esp+38h] [ebp-D4h]
  int v43; // [esp+3Ch] [ebp-D0h]
  int v44; // [esp+44h] [ebp-C8h]
  int v45; // [esp+48h] [ebp-C4h]
  int v46; // [esp+4Ch] [ebp-C0h]
  int v47; // [esp+50h] [ebp-BCh]
  int v48; // [esp+9Ch] [ebp-70h]
  int v49; // [esp+A0h] [ebp-6Ch]
  int v50; // [esp+A4h] [ebp-68h]
  int v51; // [esp+A8h] [ebp-64h]
  float v52; // [esp+ACh] [ebp-60h]
  float v53; // [esp+B0h] [ebp-5Ch]
  float v54; // [esp+B4h] [ebp-58h]
  float v55; // [esp+B8h] [ebp-54h]
  int v56; // [esp+BCh] [ebp-50h]
  float v57; // [esp+C0h] [ebp-4Ch]
  float v58; // [esp+C4h] [ebp-48h]
  int v59; // [esp+C8h] [ebp-44h]
  int v60; // [esp+CCh] [ebp-40h]
  int v61; // [esp+D0h] [ebp-3Ch]
  int v62; // [esp+D4h] [ebp-38h]
  int v63; // [esp+D8h] [ebp-34h]
  float v64; // [esp+DCh] [ebp-30h]
  int v65; // [esp+E0h] [ebp-2Ch]
  int v66; // [esp+E4h] [ebp-28h]
  int v67; // [esp+E8h] [ebp-24h]
  int v68; // [esp+ECh] [ebp-20h]
  int v69; // [esp+F0h] [ebp-1Ch]
  unsigned __int8 v70; // [esp+F4h] [ebp-18h]

  v4 = 0;
  v56 = 0;
  v59 = 0xFFFFFFFF;
  v57 = 0.0;
  v55 = 1.0;
  v52 = 1.0;
  v58 = 1.0;
  v54 = 1.0;
  v53 = 1.0;
  v48 = 0;
  v68 = 0;
  v51 = 0;
  v66 = 0;
  v65 = 0;
  sub_36158(a2);
  v6 = v5;
  if ( (unsigned __int8)byte_104299 == 0xFF
    || ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104299) >> 0x18)) != 0 )
  {
    v65 = 0xFFFFFFFF;
  }
  if ( (unsigned __int8)byte_104299 == 0xFF
    || ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104299) >> 0x18)) != 0 )
  {
    v66 = 0xFFFFFFFF;
  }
  if ( *(unsigned __int16 *)(a2 + 0x4A) - *(unsigned __int16 *)(a2 + 0x42) > 0 )
  {
    v48 = 0xFFFFFFFF;
  }
  if ( sub_40590(a1) )
  {
    v56 = 0xFFFFFFFF;
  }
  if ( *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    v68 = 0xFFFFFFFF;
    v58 = 2.0;
    v4 = 4;
  }
  if ( *(_WORD *)(a2 + 0x1C) || *(unsigned __int16 *)(a2 + 0x4A) - *(unsigned __int16 *)(a2 + 0x42) <= 3 || !v66 )
  {
    if ( *(unsigned __int16 *)(a2 + 0x1C) > 1u
      && *(unsigned __int16 *)(a2 + 0x4A) - *(unsigned __int16 *)(a2 + 0x42) < 2 )
    {
      v4 = 8;
      if ( v48 == 0xFFFFFFFF )
      {
        v54 = 0.0;
      }
    }
  }
  else
  {
    v54 = 0.5;
    v51 = 0xFFFFFFFF;
  }
  if ( v6 < 4 )
  {
    v53 = 2.0;
    if ( !v4 )
    {
      v4 = 0x10;
    }
  }
  if ( v56 )
  {
    v52 = 0.0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x42) - *(unsigned __int16 *)(a2 + 0x4C) <= *(unsigned __int16 *)(a2 + 0x48)
    || *(unsigned __int16 *)(a2 + 0x48) >= 3u )
  {
    if ( *(unsigned __int16 *)(a2 + 0x42) - *(unsigned __int16 *)(a2 + 0x4C) < *(unsigned __int16 *)(a2 + 0x48)
      || *(unsigned __int16 *)(a2 + 0x48) > 5u )
    {
      v58 = 0.5;
    }
  }
  else
  {
    v58 = 2.0;
    if ( !v4 )
    {
      v4 = 4;
    }
  }
  v7 = *(unsigned __int16 *)(a2 + 0x44);
  if ( (unsigned __int16)v7 < 0x19u )
  {
    if ( *(_WORD *)(a2 + 0x44) )
    {
      v49 = 0x19 / v7;
      v55 = (float)(0x19 / v7);
    }
    else
    {
      v55 = 25.0;
    }
    if ( !v4 )
    {
      v4 = 2;
    }
  }
  if ( !v56 )
  {
    v8 = *(unsigned __int16 *)(a2 + 0x46);
    if ( (unsigned __int16)v8 < 0x19u )
    {
      if ( *(_WORD *)(a2 + 0x46) )
      {
        v49 = 0x19 / v8;
        v55 = (float)(0x19 / v8);
      }
      else
      {
        v55 = 25.0;
      }
      if ( !v4 )
      {
        v4 = 1;
      }
    }
  }
  if ( 5 * v6 < 2 * *(unsigned __int16 *)(a2 + 0x18) )
  {
    v53 = 1.5;
    if ( !v4 )
    {
      v4 = 0x10;
    }
  }
  v9 = 0;
  v10 = 0;
  while ( v9 < *(unsigned __int16 *)(a2 + 0x18) )
  {
    v13 = *(_DWORD *)(a2 + 0x10);
    LOBYTE(v13) = *(_BYTE *)(v10 + v13 + 1);
    v62 = 0;
    v61 = 0;
    v63 = 0;
    v60 = 0;
    v50 = 0;
    v14 = (int *)((char *)&dword_103F9A[0xA * (unsigned __int8)v13] + 2);
    if ( (_BYTE)v13 != 0xFF
      && (_BYTE)v13 != 4
      && (_BYTE)v13 != 6
      && (_BYTE)v13 != 7
      && (_BYTE)v13 != 8
      && (_BYTE)v13 != 0x13
      && (_BYTE)v13 != 5
      && (_BYTE)v13 != 0xB
      && (_BYTE)v13 != 0xC
      && (_BYTE)v13 != 0xD
      && (_BYTE)v13 != 0xE
      && (_BYTE)v13 != 0xF
      && (_BYTE)v13 != 0x11
      && (_BYTE)v13 != 0x10
      && ((_BYTE)v13 != 0x12 || v65 && (v4 == 0x10 || !v4))
      && ((_BYTE)v13 != 3 || v51)
      && ((_BYTE)v13 != 0x14 || v48)
      && ((_BYTE)v13 != 9 && (_BYTE)v13 != 0xA || v56) )
    {
      v15 = (unsigned __int8 *)(v10 + *(_DWORD *)(a2 + 0x10));
      LOWORD(v13) = *((_WORD *)v15 + 1) & 1;
      v69 = v13;
      HIWORD(v16) = 0;
      if ( (_WORD)v69 )
      {
        if ( *(_BYTE *)v14 )
        {
          v16 = *(char *)v14;
          v17 = *v15;
          v62 += v16;
          if ( v17 == 2 )
          {
            ++v62;
          }
        }
        v18 = *((_BYTE *)v14 + 2);
        if ( v18 )
        {
          v19 = v18 + v63;
          v20 = *(_DWORD *)(a2 + 0x10);
          v63 = v19;
          v16 = *(unsigned __int8 *)(v10 + v20);
          if ( v16 == 3 )
          {
            v16 = v19 + 1;
            v63 = v19 + 1;
          }
        }
        v21 = *((_BYTE *)v14 + 1);
        if ( v21 )
        {
          v22 = v21 + v61;
          v23 = *(_DWORD *)(a2 + 0x10);
          v61 = v22;
          v16 = *(unsigned __int8 *)(v10 + v23);
          if ( v16 == 4 )
          {
            v61 = v22 + 1;
          }
        }
        v24 = v10 + *(_DWORD *)(a2 + 0x10);
        if ( *(_BYTE *)(v24 + 1) != 0xFF )
        {
          LOWORD(v16) = *(_WORD *)(v24 + 2) & 1;
          v69 = v16;
          if ( (_BYTE)v16 )
          {
            v11 = *(_BYTE *)(v24 + 1);
            if ( v11 >= 0x12u )
            {
              if ( v11 <= 0x12u )
              {
                v50 += 2;
              }
              else if ( v11 == 0x13 )
              {
                v50 += 4;
              }
            }
          }
        }
        v60 += *v14 >> 0x18;
      }
      v64 = (double)v62 * v55;
      v64 = (double)v61 * v52 + v64;
      v64 = (double)v63 * v58 + v64;
      v12 = *(_WORD *)(v10 + *(_DWORD *)(a2 + 0x10) + 2);
      v64 = (double)v60 * v54 + v64;
      v64 = (double)v50 * v53 + v64;
      if ( (v12 & 2) != 0 )
      {
        v64 = v64 + v58;
      }
      if ( v59 == 0xFFFFFFFF || v64 < (double)v57 )
      {
        v59 = v9;
        v57 = v64;
      }
    }
    v10 += 4;
    ++v9;
  }
  if ( v59 == 0xFFFFFFFF )
  {
    return 0;
  }
  v67 = rand() % 0x64;
  v25 = 0;
  v26 = 0;
  do
  {
    v27 = (unsigned __int8)byte_103FA1[v26];
    if ( v27 == 0xFF || ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * v27) >> 0x18)) != 0 )
    {
      v31[v25] = 0xFFFFFFFF;
    }
    else
    {
      v31[v25] = 0;
    }
    ++v25;
    v26 += 0x28;
  }
  while ( v25 != 0x27 );
  v70 = 0xFF;
  v28 = *(_BYTE *)(*(_DWORD *)(a2 + 0x10) + 4 * v59 + 1);
  v29 = v28;
  if ( (v28 == 2 || v28 == 9 || v28 == 0xA) && v56 == 0xFFFFFFFF )
  {
    if ( v68 == 0xFFFFFFFF )
    {
      v28 = 1;
    }
    else if ( v67 >= 0x19 )
    {
      v28 = 0;
    }
    else
    {
      v28 = 0x12;
    }
  }
  if ( v4 < 2 )
  {
    if ( !v4 )
    {
      goto LABEL_222;
    }
    if ( !v56 )
    {
      v28 = 2;
      goto LABEL_222;
    }
LABEL_123:
    v28 = 0;
    goto LABEL_222;
  }
  if ( v4 <= 2 )
  {
    goto LABEL_123;
  }
  if ( v4 < 8 )
  {
    v28 = 1;
  }
  else if ( v4 <= 8 )
  {
    v28 = 0x14;
  }
  else
  {
    v28 = 0x12;
  }
LABEL_222:
  if ( (unsigned __int8)v28 < 2u )
  {
    if ( v28 )
    {
      if ( (unsigned __int16)sub_35930(a2, 0xD) == 0xFFFF && v41 )
      {
        v70 = 0xD;
        goto LABEL_136;
      }
      if ( !v68 && (unsigned __int16)sub_35930(a2, 0xF) == 0xFFFF && v43 )
      {
        v70 = 0xF;
        goto LABEL_136;
      }
      if ( !v68 && (unsigned __int16)sub_35930(a2, 0x11) == 0xFFFF && v44 )
      {
        v70 = 0x11;
        goto LABEL_136;
      }
      if ( !v68 && (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF && v39 )
      {
        v70 = 0xB;
        goto LABEL_136;
      }
      if ( v33 && v35 )
      {
        if ( v67 < 0x32 && !v56 )
        {
          v70 = 4;
          goto LABEL_136;
        }
      }
      else
      {
        if ( v33 && !v56 )
        {
          v70 = 4;
          goto LABEL_136;
        }
        if ( !v35 )
        {
          if ( !v37 || v56 )
          {
            if ( v29 != v28 && v31[1] )
            {
              v70 = 1;
            }
          }
          else
          {
            v70 = 9;
          }
          goto LABEL_136;
        }
      }
      v70 = 7;
      goto LABEL_136;
    }
    if ( (unsigned __int16)sub_35930(a2, 0xC) == 0xFFFF && v40 )
    {
      v70 = 0xC;
      goto LABEL_136;
    }
    if ( (unsigned __int16)sub_35930(a2, 0x11) == 0xFFFF && v44 )
    {
      v70 = 0x11;
      goto LABEL_136;
    }
    if ( (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF && v39 )
    {
      v70 = 0xB;
      goto LABEL_136;
    }
    if ( v33 && v34 )
    {
      if ( v67 < 0x32 && !v56 )
      {
        v70 = 4;
        goto LABEL_136;
      }
    }
    else
    {
      if ( v33 && !v56 )
      {
        v70 = 4;
        goto LABEL_136;
      }
      if ( !v34 )
      {
        if ( !v38 || v56 )
        {
          if ( v29 && v31[0] )
          {
            v70 = 0;
          }
        }
        else
        {
          v70 = 0xA;
        }
        goto LABEL_136;
      }
    }
    v70 = 6;
    goto LABEL_136;
  }
  if ( (unsigned __int8)v28 <= 2u )
  {
    if ( (unsigned __int16)sub_35930(a2, 0xE) == 0xFFFF && v42 )
    {
      v70 = 0xE;
    }
    else if ( (unsigned __int16)sub_35930(a2, 0x11) == 0xFFFF && v44 )
    {
      v70 = 0x11;
    }
    else if ( (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF && v39 )
    {
      v70 = 0xB;
    }
    else if ( v36 )
    {
      v70 = 8;
    }
    else if ( v33 )
    {
      v70 = 4;
    }
    else if ( v38 )
    {
      v70 = 0xA;
    }
    else if ( v37 )
    {
      v70 = 9;
    }
    else if ( v29 != v28 && v31[2] )
    {
      v70 = 2;
    }
  }
  else if ( (unsigned __int8)v28 < 0x12u )
  {
    if ( v28 != 3 )
    {
      return 0;
    }
    if ( v33 )
    {
      v70 = 4;
    }
    else if ( v29 != 3 && v32 )
    {
      v70 = 3;
    }
  }
  else if ( (unsigned __int8)v28 <= 0x12u )
  {
    if ( v46 )
    {
      v70 = 0x13;
    }
    else if ( v29 != v28 && v45 )
    {
      v70 = 0x12;
    }
  }
  else
  {
    if ( v28 != 0x14 )
    {
      return 0;
    }
    if ( v33 )
    {
      v70 = 4;
    }
    else if ( v32 )
    {
      v70 = 3;
    }
    else if ( v29 != 0x14 && v47 )
    {
      v70 = 0x14;
    }
  }
LABEL_136:
  if ( v70 < 0x27u && sub_34B0C(a2, (unsigned __int16)v59, v29, 1u) )
  {
    sub_34774(a2, v70, v59, 0);
    return 0xFFFFFFFF;
  }
  return 0;
}
// 3D3C4: conditional instruction was optimized away because ebp.4==10
// 3D3FB: conditional instruction was optimized away because ebp.4==4
// 3CD75: variable 'v5' is possibly undefined
// 103F9A: using guessed type int dword_103F9A[];
// 104299: using guessed type char byte_104299;
// 10529F: using guessed type int dword_10529F;

//----- (0003D8F0) --------------------------------------------------------
char __usercall sub_3D8F0@<al>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  int v4; // eax
  int v5; // eax
  unsigned __int8 v6; // dl
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // ebp
  int v13; // ebp
  int v14; // eax
  int v15; // edx
  char v16; // bl
  char *v17; // ebx
  int v18; // ebx
  int v19; // ebx
  int v20; // ebp
  int v21; // edi
  int v22; // edx
  int v23; // eax
  char v24; // cl
  int v25; // ecx
  int *v26; // eax
  int v27; // ecx
  __int16 v28; // ax
  int v29; // et2
  int v30; // edi
  int v31; // ebx
  unsigned __int8 *v32; // ecx
  char v33; // dl
  int v34; // eax
  unsigned __int16 v35; // di
  char v37[5]; // [esp+1h] [ebp-125h]
  _BYTE v38[196]; // [esp+6h] [ebp-120h] BYREF
  int v39; // [esp+CAh] [ebp-5Ch] BYREF
  int v40; // [esp+CEh] [ebp-58h] BYREF
  int v41; // [esp+D2h] [ebp-54h] BYREF
  int v42; // [esp+D6h] [ebp-50h]
  int v43; // [esp+DAh] [ebp-4Ch]
  _BYTE *v44; // [esp+DEh] [ebp-48h]
  int v45; // [esp+E6h] [ebp-40h]
  int v46; // [esp+EAh] [ebp-3Ch]
  unsigned int v47; // [esp+EEh] [ebp-38h]
  int v48; // [esp+F2h] [ebp-34h]
  int v49; // [esp+F6h] [ebp-30h]
  int v50; // [esp+FAh] [ebp-2Ch]
  int v51; // [esp+FEh] [ebp-28h]
  unsigned __int8 *v52; // [esp+102h] [ebp-24h]
  int v53; // [esp+106h] [ebp-20h]
  int v54; // [esp+10Ah] [ebp-1Ch]
  unsigned __int8 v55; // [esp+10Eh] [ebp-18h]

  v44 = a1;
  v43 = 0;
  v51 = 0;
  sub_34A44(a2, &v40, &v39, &v41);
  if ( sub_40590(v44) == 0xFFFFFFFF )
  {
    v39 += v40;
    v41 += v40;
    v40 = 0;
  }
  v4 = sub_358F0(a2);
  if ( v4 < 1 )
  {
    if ( v39 > 0 )
    {
LABEL_5:
      v5 = a2;
      v6 = 0;
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  if ( v4 < 2 )
  {
    if ( v41 <= 0 || *(unsigned __int16 *)(a2 + 0x44) <= 1u )
    {
      goto LABEL_5;
    }
LABEL_18:
    v6 = 1;
    goto LABEL_19;
  }
  if ( v4 >= 3 )
  {
    goto LABEL_21;
  }
  if ( v40 <= 0 || *(unsigned __int16 *)(a2 + 0x48) <= 1u || *(unsigned __int16 *)(a2 + 0x44) <= 1u )
  {
    if ( v39 > 0 && *(unsigned __int16 *)(a2 + 0x48) > 1u )
    {
      v5 = a2;
      v6 = 0;
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  v6 = 2;
LABEL_19:
  v5 = a2;
LABEL_20:
  v7 = sub_34AE4(v5, v6, 0xFFFFFFFF);
  if ( v7 != 0xFFFF )
  {
    return v7;
  }
LABEL_21:
  LOWORD(v7) = *(_WORD *)(a2 + 0x44);
  if ( !(_WORD)v7 )
  {
    return v7;
  }
  if ( *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    v8 = *(unsigned __int16 *)(a2 + 0x42);
    if ( *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v8 < 1 && v8 - *(unsigned __int16 *)(a2 + 0x4C) < 1 )
    {
      v51 = 0xFFFFFFFF;
    }
  }
  v9 = *(unsigned __int16 *)(a2 + 0x42);
  if ( *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v9 < 1 && v9 - *(unsigned __int16 *)(a2 + 0x4C) < 2 )
  {
    v43 = 0xFFFFFFFF;
  }
  v7 = (__int16)sub_3E1CC((int)v44, a2);
  v46 = v7;
  if ( (__int16)v7 == 1 )
  {
    return v7;
  }
  v50 = (sub_3407C(a2) <= 0) - 1;
  sub_3420C(a2);
  v49 = (v10 <= 0) - 1;
  v11 = sub_34AE4(a2, 0x26u, 0xFFFFFFFF);
  v12 = (v11 == 0xFFFF) - 1;
  sub_34B0C(a2, (unsigned __int16)v11, 0x26u, 1u);
  if ( !*(_WORD *)(a2 + 0x1C) || !v50 && !v49 && !v12 )
  {
LABEL_102:
    LOBYTE(v7) = sub_3CCE4(v44, a2);
    return v7;
  }
  if ( v12 == 0xFFFFFFFF )
  {
    LOBYTE(v7) = sub_3E520((int)v44, a2);
    return v7;
  }
  if ( v50 != 0xFFFFFFFF )
  {
    if ( ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104541) >> 0x18)) != 0 )
    {
      LOWORD(v45) = sub_35930(a2, 0x15);
      v45 = (unsigned __int16)v45;
      if ( (unsigned __int16)v45 == 0xFFFF )
      {
        v7 = sub_34AE4(a2, 0x24u, 0);
        if ( v7 != 0xFFFF )
        {
          return v7;
        }
      }
      else
      {
        v35 = v45;
        sub_34B0C(a2, (unsigned __int16)v45, 0x15u, 1u);
        if ( sub_34368(a2, 0x24u, v35) )
        {
          LOBYTE(v7) = sub_34774(a2, 0x24u, v45, 0);
          return v7;
        }
      }
    }
    else if ( *(_WORD *)(a2 + 0x1C) > *(_WORD *)(a2 + 0x20) && v43 != 0xFFFFFFFF )
    {
      v7 = sub_34AE4(a2, 0x15u, 0xFFFFFFFF);
      if ( v7 != 0xFFFF )
      {
        return v7;
      }
    }
    goto LABEL_102;
  }
  v45 = 0xFFFFFFFF;
  LOWORD(v7) = *(_WORD *)(a2 + 0x4C);
  v13 = 0;
  if ( (unsigned __int16)v7 < *(_WORD *)(a2 + 0x4A) )
  {
    if ( (unsigned __int16)v7 >= *(_WORD *)(a2 + 0x42) || v46 == 2 )
    {
      return v7;
    }
  }
  else
  {
    v14 = 0;
    v15 = 0;
    while ( v14 < *(unsigned __int16 *)(a2 + 0x18) )
    {
      a3 = v15 + *(_DWORD *)(a2 + 0x10);
      v16 = *(_BYTE *)(a3 + 1);
      if ( v16 != (char)0xFF && v16 != 5 )
      {
        v17 = (char *)&dword_103F9A[0xA * *(unsigned __int8 *)(a3 + 1)] + 2;
        if ( !v17[3] )
        {
          v18 = v17[4];
          if ( v18 > v13 )
          {
            v13 = v18;
            v45 = v14;
          }
        }
      }
      v15 += 4;
      ++v14;
    }
    if ( v45 == 0xFFFFFFFF )
    {
      Q_debugbreak_sub_26194();
      LOBYTE(v7) = sub_37040(a2);
      return v7;
    }
    sub_34B0C(a2, (unsigned __int16)v45, *(_BYTE *)(a3 + 1), 1u);
    LOWORD(v7) = *(_WORD *)(a2 + 0x4C);
    if ( (unsigned __int16)v7 >= *(_WORD *)(a2 + 0x42) )
    {
      return v7;
    }
  }
  if ( *(unsigned __int16 *)(a2 + 0x42) - *(unsigned __int16 *)(a2 + 0x4C) <= 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x85A);
  }
  if ( v51 || (v7 = sub_3E520((int)v44, a2), v7 != 0xFFFFFFFF) )
  {
    v47 = (__int16)sub_3E800(v44, (unsigned __int16 *)a2);
    if ( v47 == 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x870);
    }
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    do
    {
      while ( 1 )
      {
        if ( (_BYTE)v19 != 5 && v19 < (unsigned __int16)word_103F98[0] )
        {
          v23 = (unsigned __int8)byte_103FA1[v21 * 4];
          if ( v23 == 0xFF
            || (v24 = *(_BYTE *)(a2 + 0x57),
                v42 = *(int *)((char *)&dword_10529F + 0x4B * v23) >> 0x18,
                ((1 << v24) & v42) != 0) )
          {
            v42 = *(unsigned __int16 *)(a2 + 0x4A);
            if ( *(int *)((char *)&dword_103F9A[v21] + 3) >> 0x18 <= v42 - *(unsigned __int16 *)(a2 + 0x4C) )
            {
              break;
            }
          }
        }
LABEL_64:
        ++v19;
        v21 += 0xA;
        if ( v19 >= 0x27 )
        {
          goto LABEL_77;
        }
      }
      HIWORD(v25) = HIWORD(v47);
      v26 = (int *)((char *)&dword_103F9A[v21] + 2);
      if ( v47 <= 3 )
      {
        switch ( (unsigned int)v26 )
        {
          case 0u:
            v25 = *(char *)v26;
            if ( !*(_BYTE *)v26 )
            {
              goto LABEL_64;
            }
            *(_WORD *)&v38[v22 + 1] = *(char *)v26;
            break;
          case 1u:
            v25 = *((char *)v26 + 1);
            if ( !*((_BYTE *)v26 + 1) )
            {
              goto LABEL_64;
            }
            *(_WORD *)&v38[v22 + 1] = *((char *)v26 + 1);
            break;
          case 2u:
            v25 = *((char *)v26 + 2);
            if ( !*((_BYTE *)v26 + 2) )
            {
              goto LABEL_64;
            }
            *(_WORD *)&v38[v22 + 1] = *((char *)v26 + 2);
            break;
          case 3u:
            v25 = *v26 >> 0x18;
            if ( !v25 )
            {
              goto LABEL_64;
            }
            *(_WORD *)&v38[v22 + 1] = *((char *)v26 + 3);
            break;
        }
      }
      LOWORD(v25) = *((char *)v26 + 3);
      v53 = v25;
      LOWORD(v25) = *((char *)v26 + 2);
      v27 = v25 + v53;
      v22 += 5;
      v54 = v27;
      LOWORD(v27) = *((char *)v26 + 1);
      ++v20;
      v53 = v27;
      v28 = *(char *)v26;
      LOWORD(v27) = v27 + v54;
      v37[v22] = v19;
      *(_WORD *)&v37[v22 + 3] = v27 + v28;
      ++v19;
      v21 += 0xA;
    }
    while ( v19 < 0x27 );
LABEL_77:
    if ( v20 || (v7 = sub_3CCE4(v44, a2), v7 != 0xFFFFFFFF) )
    {
      v29 = rand() % 0x64;
      v30 = 0;
      v55 = 0xFF;
      v48 = v29;
      v31 = 0;
      if ( v20 > 0 )
      {
        v32 = v38;
        while ( 1 )
        {
          v33 = *v32;
          v52 = v32;
          if ( (unsigned __int16)sub_35930(a2, v33) == 0xFFFF )
          {
            break;
          }
          if ( v48 <= 0x41 )
          {
            v34 = *(__int16 *)(v32 + 1);
          }
          else
          {
            v34 = *(__int16 *)(v32 + 3);
          }
          if ( v34 > v30 )
          {
            v30 = v34;
            v55 = *v52;
          }
          ++v31;
          v32 += 5;
          if ( v31 >= v20 )
          {
            goto LABEL_90;
          }
        }
        if ( (unsigned __int16)word_103FA4[0x14 * *v32] / (int)*(unsigned __int16 *)(a2 + 0x44) < 0x46 )
        {
          v55 = *v32;
        }
      }
LABEL_90:
      LOBYTE(v7) = v55;
      if ( v55 != 0xFF )
      {
        v7 = sub_34AE4(a2, v55, 0);
        if ( v7 == 0xFFFF )
        {
          goto LABEL_102;
        }
      }
    }
  }
  return v7;
}
// 3DAD9: variable 'v10' is possibly undefined
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA4: using guessed type __int16 word_103FA4[];
// 104541: using guessed type char byte_104541;
// 10529F: using guessed type int dword_10529F;

//----- (0003E020) --------------------------------------------------------
unsigned int __fastcall sub_3E020(int a1, int a2, unsigned __int8 a3)
{
  unsigned int result; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // esi
  int v10; // edi
  signed int v11; // eax
  char v12; // cl
  unsigned int v13; // [esp+8h] [ebp-28h]
  int v14; // [esp+Ch] [ebp-24h]
  signed int v15; // [esp+10h] [ebp-20h]
  unsigned int v16; // [esp+14h] [ebp-1Ch]
  int v17; // [esp+18h] [ebp-18h]

  if ( a3 > 0x1Eu || a3 < 0x16u || a3 == 0x17 )
  {
    return 0;
  }
  sub_36050(a2);
  v15 = 0;
  v17 = 0xFFFFFFFF;
  v13 = 0;
  v6 = v5;
  v16 = 0;
  v7 = sub_35FE0(a2);
  v8 = v7;
  if ( a3 == 0x1A || a3 == 0x1B )
  {
    v16 = 0xFFFFFFFF;
  }
  else if ( a3 == 0x1C || a3 == 0x1D || a3 == 0x1E )
  {
    v13 = 0xFFFFFFFF;
  }
  v14 = v7 - 3;
  v9 = *(unsigned __int16 *)(a2 + 0x18);
  v10 = 4 * (unsigned __int16)v9;
  while ( v9 < *(unsigned __int16 *)(a2 + 0x1A) )
  {
    v12 = *(_BYTE *)(v10 + *(_DWORD *)(a2 + 0x10) + 1);
    v11 = 0xFFFFFFFF;
    if ( v12 != 0x1A || a3 == 0x1A )
    {
      if ( v12 != 0x1C || a3 == 0x1C )
      {
        if ( v12 == 0x1D && a3 != 0x1D && (!v16 || v8 < v6 - 4) )
        {
          v11 = 4;
          if ( v8 > v6 )
          {
            v11 = 8;
          }
        }
      }
      else if ( !v16 || v8 < v6 - 2 )
      {
        v11 = 2;
        if ( v8 > v6 )
        {
          v11 = 4;
        }
      }
    }
    else if ( !v13 || v6 < v14 )
    {
      v11 = 3;
      if ( v6 > v8 )
      {
        v11 = 6;
      }
    }
    if ( v11 != 0xFFFFFFFF && (v17 == 0xFFFFFFFF || v11 < v15) )
    {
      v17 = v9;
      v15 = v11;
    }
    v10 += 4;
    ++v9;
  }
  if ( v17 == 0xFFFFFFFF )
  {
    return 0;
  }
  result = sub_34B0C(a2, (unsigned __int16)v17, *(_BYTE *)(*(_DWORD *)(a2 + 0x10) + 4 * v17 + 1), 1u);
  if ( result )
  {
    sub_34774(a2, a3, v17, 0);
    return 0xFFFFFFFF;
  }
  return result;
}
// 3E061: variable 'v5' is possibly undefined

//----- (0003E1CC) --------------------------------------------------------
int __fastcall sub_3E1CC(int a1, int a2)
{
  unsigned __int8 v4; // ch
  int v5; // ebx
  int v6; // eax
  int v7; // ebp
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // edx
  unsigned int v14; // [esp+0h] [ebp-28h]
  int v15; // [esp+8h] [ebp-20h]
  unsigned __int8 v16; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 v17; // [esp+10h] [ebp-18h]

  v4 = 0xFF;
  v14 = 0;
  v5 = *(unsigned __int16 *)(a2 + 0x46);
  if ( sub_40590((_BYTE *)a1) )
  {
    v5 = 0x3E8;
  }
  if ( sub_358F0(a2) < 5 )
  {
    return 0;
  }
  v15 = sub_35FE0(a2);
  sub_36050(a2);
  v7 = v6;
  v17 = sub_35DA4(a2);
  v16 = sub_35E24(a2);
  if ( *(unsigned __int16 *)(a2 + 0x1E) < 2u
    || (v8 = *(unsigned __int16 *)(a2 + 0x42), *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v8 < 1)
    && v8 - *(unsigned __int16 *)(a2 + 0x4C) < 2
    || *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    v14 = 0xFFFFFFFF;
  }
  if ( v15 < 1 && v17 != 0xFF )
  {
    v4 = v17;
  }
  if ( v4 == 0xFF && v7 < 1 && v16 != 0xFF )
  {
    v4 = v16;
  }
  if ( v4 == 0xFF
    && (unsigned __int16)sub_35930(a2, 0x16) == 0xFFFF
    && *(unsigned __int16 *)(a2 + 0x14) > 1u
    && (*(unsigned __int16 *)(a2 + 0x44) >= 4u || *(unsigned __int16 *)(a2 + 0x1C) - *(unsigned __int16 *)(a2 + 0x20) < 5) )
  {
    if ( ((*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104311) >> 0x18) & (1 << *(_BYTE *)a1)) != 0 )
    {
      v4 = 0x16;
    }
  }
  else if ( *(unsigned __int16 *)(a2 + 0x44) < 4u && sub_3407C(a2) > 0 )
  {
    return 0;
  }
  if ( (*(unsigned __int16 *)(a2 + 0x44) < 0x14u || v5 < 0x14)
    && sub_3407C(a2) > 0
    && (v15 > 0 || v17 == 0xFF)
    && (v7 > 0 || v16 == 0xFF) )
  {
    v9 = *(unsigned __int16 *)(a2 + 0x44);
    v10 = v7 + v15;
    if ( (unsigned __int16)v9 <= v5 )
    {
      if ( v10 > v9 )
      {
        return 0;
      }
    }
    else if ( v10 > v5 )
    {
      return 0;
    }
  }
  v11 = 0;
  if ( &word_A3D21[0x30 * *(__int16 *)(a2 + 0xC)] == *(__int16 **)(a1 + 7) )
  {
    v11 = 6;
  }
  if ( v4 != 0xFF || v7 >= v15 || v16 == 0xFF || v7 >= v11 + 6 )
  {
    if ( v4 == 0xFF && v17 != 0xFF && v11 + 6 > v15 )
    {
      v4 = v17;
    }
  }
  else
  {
    v4 = v16;
  }
  v12 = rand() % 0x64;
  if ( v4 == 0xFF && v12 < 0x14 && sub_34368(a2, 0x19u, 0xFFFFu) && (unsigned __int16)sub_35930(a2, 0x19) == 0xFFFF )
  {
    v4 = 0x19;
  }
  if ( v4 != 0xFF || v7 >= v15 || v16 == 0xFF )
  {
    if ( v4 == 0xFF && v17 != 0xFF )
    {
      v4 = v17;
    }
  }
  else
  {
    v4 = v16;
  }
  if ( v4 != 0xFF )
  {
    if ( !v14 && sub_34AE4(a2, v4, 0) != 0xFFFF )
    {
      return 1;
    }
    if ( sub_3E020(a1, a2, v4) )
    {
      return 1;
    }
    if ( v4 != v17 || v16 == 0xFF )
    {
      if ( v4 == v16 && v17 != 0xFF && sub_3E020(a1, a2, v17) )
      {
        return 1;
      }
    }
    else if ( sub_3E020(a1, a2, v16) )
    {
      return 1;
    }
  }
  return 0;
}
// 3E215: variable 'v6' is possibly undefined
// A3D21: using guessed type __int16 word_A3D21[];
// 104311: using guessed type char byte_104311;
// 10529F: using guessed type int dword_10529F;

//----- (0003E520) --------------------------------------------------------
unsigned int __fastcall sub_3E520(int a1, int a2)
{
  unsigned int result; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // esi
  int v9; // edx
  int v10; // eax
  unsigned __int16 v11; // di
  int v12; // edx
  __int16 i; // di
  unsigned __int8 v14; // si
  int v15; // [esp+0h] [ebp-24h]
  char v16; // [esp+4h] [ebp-20h]
  unsigned __int8 v17; // [esp+8h] [ebp-1Ch]
  unsigned __int8 v18; // [esp+Ch] [ebp-18h]

  if ( (*(_BYTE *)(a2 + 0x66) & 2) != 0 && sub_34AE4(a2, 0x26u, 0) != 0xFFFF )
  {
    result = 0xFFFFFFFF;
    *(_BYTE *)(a2 + 0x66) &= ~2u;
    return result;
  }
  v5 = 3;
  if ( sub_40590((_BYTE *)a1) == 0xFFFFFFFF )
  {
    v5 = 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x44) < 3u )
  {
    return 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x46) < v5 )
  {
    return 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    return 0;
  }
  v6 = *(unsigned __int16 *)(a2 + 0x42);
  if ( *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v6 < 1 && v6 - *(unsigned __int16 *)(a2 + 0x4C) < 2 )
  {
    return 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x1C) - *(unsigned __int16 *)(a2 + 0x20) < 3 )
  {
    return 0;
  }
  sub_36158(a2);
  v8 = v7;
  if ( &word_A3D21[0x30 * *(__int16 *)(a2 + 0xC)] == *(__int16 **)(a1 + 7) )
  {
    v9 = *(unsigned __int16 *)(a2 + 0x18);
  }
  else
  {
    v9 = 2 * *(unsigned __int16 *)(a2 + 0x18);
  }
  v10 = v9 / 5;
  if ( v9 / 5 < 4 )
  {
    v10 = 4;
  }
  if ( (*(unsigned __int16 *)(a2 + 0x44) < 0x14u || *(unsigned __int16 *)(a2 + 0x46) < 0x14u) && v8 > 0 )
  {
    v11 = *(_WORD *)(a2 + 0x46);
    v12 = 3 * v8;
    if ( *(_WORD *)(a2 + 0x44) <= v11 )
    {
      if ( v12 <= 2 * *(unsigned __int16 *)(a2 + 0x44) )
      {
        goto LABEL_25;
      }
    }
    else if ( v12 <= 2 * v11 )
    {
      goto LABEL_25;
    }
    v10 = v8;
  }
LABEL_25:
  if ( v8 < v10 )
  {
    v17 = 0xFF;
    if ( sub_34368(a2, 0x13u, 0xFFFFu) )
    {
      v17 = 0x13;
    }
    else if ( sub_34368(a2, 0x12u, 0xFFFFu) )
    {
      v17 = 0x12;
    }
    if ( v17 != 0xFF && sub_34AE4(a2, v17, 0) )
    {
      return 0xFFFFFFFF;
    }
  }
  if ( *(unsigned __int8 *)(a2 + 0x57) % 2
    && *(unsigned __int16 *)(a2 + 0x44) > 0x14u
    && rand() % 0x64 < 4
    && sub_34368(a2, 0xBu, 0xFFFFu)
    && (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF
    && sub_34AE4(a2, 0xBu, 0) )
  {
    return 0xFFFFFFFF;
  }
  v15 = unk_96918;
  v16 = *((_BYTE *)&unk_96918 + 4);
  for ( i = 0; i < 5; ++i )
  {
    v18 = *((_BYTE *)&v15 + i);
    if ( (v18 != 0x25 || (*(_BYTE *)(a2 + 0x66) & 1) == 0)
      && sub_34368(a2, v18, 0xFFFFu)
      && (sub_40590((_BYTE *)a1) == 0xFFFFFFFF || v18 != 0xE) )
    {
      v14 = v18;
      if ( (unsigned __int16)sub_35930(a2, v18) == 0xFFFF )
      {
        if ( sub_34AE4(a2, v14, 0) )
        {
          return 0xFFFFFFFF;
        }
      }
    }
  }
  return 0;
}
// 3E5E7: variable 'v7' is possibly undefined
// A3D21: using guessed type __int16 word_A3D21[];

//----- (0003E800) --------------------------------------------------------
int __fastcall sub_3E800(_BYTE *a1, unsigned __int16 *a2)
{
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // ecx
  int v11; // [esp+0h] [ebp-1Ch] BYREF
  int v12; // [esp+4h] [ebp-18h] BYREF
  int v13[5]; // [esp+8h] [ebp-14h] BYREF

  sub_34A44((int)a2, &v12, &v11, v13);
  v3 = sub_40590(a1);
  if ( v3 == 0xFFFFFFFF )
  {
    v4 = v12;
    v12 = 0;
    v11 += v4;
    v13[0] += v4;
  }
  v5 = a2[0x21];
  if ( a2[0x25] - (unsigned __int16)v5 >= 2 || v5 - a2[0x26] >= 2 )
  {
    if ( a2[0x22] < 3u && v11 > 0 )
    {
      return 0;
    }
    if ( a2[0x23] < 3u && v12 > 0 && !v3 )
    {
      return 1;
    }
    if ( a2[0x24] < 2u && v13[0] > 0 )
    {
      return 2;
    }
    if ( a2[0x22] < 4u && v11 > 0 )
    {
      return 0;
    }
    if ( a2[0x24] < 3u && v13[0] > 0 )
    {
      return 2;
    }
    if ( a2[0x23] < 5u && v12 > 0 && !v3 )
    {
      return 1;
    }
    if ( !a2[0x24] )
    {
      return 2;
    }
    if ( a2[0x24] < 2u )
    {
      v7 = a2[0x21];
      if ( a2[0x25] - (unsigned __int16)v7 < 1 && v7 - a2[0x26] < 1 )
      {
        return 2;
      }
    }
    if ( v13[0] > 0 && dword_9684C / a2[0x24] > 0xF )
    {
      v8 = a2[0x21];
      if ( a2[0x25] - (unsigned __int16)v8 > 3 && v8 - a2[0x26] != 1 )
      {
        return 2;
      }
    }
    if ( v3 == 0xFFFFFFFF )
    {
      if ( v11 > 0 )
      {
        return 0;
      }
      if ( v13[0] > 0 && a2[0x24] < 5u )
      {
        return 2;
      }
    }
    else
    {
      v9 = a2[0x22];
      v10 = a2[0x23];
      if ( (unsigned __int16)sub_35930((int)a2, 0xC) != 0xFFFF )
      {
        v10 += v9 >> 1;
      }
      if ( (unsigned __int16)sub_35930((int)a2, 0xE) != 0xFFF )
      {
        v9 += v10 >> 1;
      }
      if ( (v9 > v10 || v11 <= 0) && v12 > 0 )
      {
        return 1;
      }
      if ( v11 > 0 )
      {
        return 0;
      }
      if ( v13[0] > 0 )
      {
        return 2;
      }
    }
  }
  return 3;
}
// 9684C: using guessed type int dword_9684C;
// 3E800: using guessed type int var_14[5];

//----- (0003EA7C) --------------------------------------------------------
__int16 __fastcall sub_3EA7C(_BYTE *a1)
{
  signed __int16 v2; // si
  int v3; // eax
  int v4; // edi
  __int16 i; // si
  __int16 j; // ax
  __int16 v8[32]; // [esp+0h] [ebp-90h]
  __int16 v9[24]; // [esp+40h] [ebp-50h] BYREF
  int v10; // [esp+70h] [ebp-20h]
  int v11; // [esp+74h] [ebp-1Ch]

  v2 = 0;
  v10 = 0;
  while ( 1 )
  {
    LOWORD(v3) = word_105258;
    if ( v2 >= (int)(unsigned __int16)word_105258 )
    {
      break;
    }
    v4 = (unsigned __int16)v10;
    if ( (unsigned __int16)v10 >= 0x20u )
    {
      break;
    }
    if ( ((1 << *a1) & (*(int *)((char *)&dword_10529F + 0x4B * v2) >> 0x18)) == 0 )
    {
      if ( sub_4694C((int)&word_105258, v2, (unsigned __int8)*a1) )
      {
        v8[v4] = v2;
        v10 = v4 + 1;
      }
    }
    ++v2;
  }
  LOWORD(v11) = 0xFFFF;
  if ( (_WORD)v10 )
  {
    qmemcpy(v9, &unk_9691E, 0x2Eu);
    if ( ((1 << *a1) & SHIBYTE(dword_105416)) != 0 && rand() % 0x64 < 0x2D )
    {
      LOWORD(v11) = 0xFFFE;
    }
    for ( i = 0; i < (int)(unsigned __int16)v10 && (__int16)v11 == 0xFFFFFFFF; ++i )
    {
      for ( j = 0; j < 0x17 && (__int16)v11 == 0xFFFFFFFF; ++j )
      {
        if ( v9[j] == v8[i] )
        {
          LOWORD(v11) = v8[i];
        }
      }
    }
    if ( (v11 & 0x8000u) != 0 )
    {
      LOWORD(v11) = v8[rand() % (unsigned __int16)v10];
    }
    v3 = (unsigned __int8)*a1;
    word_106FA6[v3] = v11;
  }
  return v3;
}
// 10529F: using guessed type int dword_10529F;
// 105416: using guessed type int dword_105416;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 3EA7C: using guessed type __int16 var_90[32];
// 3EA7C: using guessed type __int16 var_50[24];

//----- (0003EBDC) --------------------------------------------------------
char __fastcall sub_3EBDC(int a1, int a2)
{
  unsigned __int8 *v2; // ecx
  char v4; // ah
  int v5; // edx
  int v6; // esi
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v11; // esi
  int v12; // eax
  int v13; // ecx
  double v14; // st7
  double v15; // st7
  double v16; // st7
  int v17; // eax
  int v19; // [esp+4h] [ebp-40h]
  int v20; // [esp+8h] [ebp-3Ch]
  float v21; // [esp+Ch] [ebp-38h]
  unsigned int v22; // [esp+10h] [ebp-34h]
  int v23; // [esp+14h] [ebp-30h]
  __int16 *v24; // [esp+1Ch] [ebp-28h]
  float v25; // [esp+20h] [ebp-24h]
  float v26; // [esp+20h] [ebp-24h]
  __int16 v27; // [esp+24h] [ebp-20h]
  __int16 v28; // [esp+28h] [ebp-1Ch]
  unsigned __int8 v29; // [esp+2Ch] [ebp-18h]

  v2 = (unsigned __int8 *)a1;
  v4 = *(_BYTE *)(a2 + 0x58);
  if ( v4 != 1 && v4 != 2 && v4 != 5 )
  {
    LOBYTE(a1) = byte_104BEA;
    if ( *(_WORD *)(a2 + 0x56) == (unsigned __int8)byte_104BEA )
    {
      v5 = dword_A0D00;
      if ( !dword_A0D00 )
      {
        *(_BYTE *)(a2 + 0x5D) = 0;
        *(_DWORD *)(a2 + 0x5E) = v5;
        return a1;
      }
    }
    if ( *(_BYTE *)(a2 + 0x58) == 4 && *(_BYTE *)(a2 + 0x5D) == 1 )
    {
      v6 = *(_DWORD *)(a2 + 0x59);
      if ( !v6 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBBC);
      }
      if ( *(_DWORD *)(a2 + 0x28) )
      {
        v7 = *(__int16 *)(v6 + 4);
        if ( *(int *)((char *)&dword_104FD1 + v7) >> 0x18 > 0 )
        {
          --*((_BYTE *)&dword_104FD1 + v7 + 3);
        }
      }
      else if ( sub_4A534(a2, 0x49) )
      {
        v8 = *(__int16 *)(v6 + 4);
        if ( *(int *)((char *)&dword_104F6D + v8) >> 0x18 > 0 )
        {
          --*((_BYTE *)&dword_104F6D + v8 + 3);
        }
      }
      else
      {
        v9 = *(__int16 *)(v6 + 4);
        if ( *(int *)((char *)&dword_104F09 + v9) >> 0x18 > 0 )
        {
          --*((_BYTE *)&dword_104F09 + v9 + 3);
        }
      }
      *(_BYTE *)(a2 + 0x5D) = 0;
      *(_DWORD *)(a2 + 0x5E) = 0;
    }
    LOBYTE(a1) = *(_BYTE *)(a2 + 0x5D);
    if ( !(_BYTE)a1 )
    {
      if ( *(_BYTE *)(a2 + 0x58) == 3 && sub_35C38(*(_DWORD *)(a2 + 0x59), a2) != 0xFFFFFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBE7);
      }
      if ( *(_BYTE *)(a2 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBEB);
      }
      a1 = *(_DWORD *)(a2 + 0x59);
      v19 = a1;
      if ( !a1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBEF);
      }
      if ( *(_DWORD *)(a2 + 0x28) == 0xFFFFFFFF )
      {
        a1 = sub_403C0(v2, *(_DWORD *)(a2 + 0x59));
        if ( a1 )
        {
          *(_BYTE *)(a2 + 0x5D) = 2;
          *(_DWORD *)(a2 + 0x5E) = a1;
          return a1;
        }
      }
      if ( *(int *)(a2 + 8) > 0 || *(int *)(a2 + 0xC) > 0 )
      {
        v10 = 0;
        v11 = 0;
        v21 = 0.0;
        v27 = 0;
        v20 = 0;
        v22 = sub_4A534(a2, 0x49);
        v24 = word_A3D21;
        v29 = sub_43374(v2, 0xFFFFFFFF);
        while ( 1 )
        {
          if ( v11 >= word_A62A1 )
          {
            LOBYTE(a1) = v20;
            if ( v20 )
            {
              if ( v20 != v19 )
              {
                a1 = sub_4AA78(a2, v20);
                if ( a1 > 0 )
                {
                  LOBYTE(a1) = v27;
                  if ( v27 != *(_WORD *)(v19 + 4) )
                  {
                    if ( *(_DWORD *)(a2 + 0x28) )
                    {
                      LOBYTE(a1) = v27;
                      ++*((_BYTE *)&dword_104FD1 + v27 + 3);
                    }
                    else
                    {
                      LOBYTE(a1) = v27;
                      if ( v22 )
                      {
                        ++*((_BYTE *)&dword_104F6D + v27 + 3);
                      }
                      else
                      {
                        ++*((_BYTE *)&dword_104F09 + v27 + 3);
                      }
                    }
                  }
                }
              }
            }
            return a1;
          }
          if ( dword_104BEC[v10] > 0 || dword_104D7C[v10] > 0 )
          {
            break;
          }
LABEL_56:
          ++v10;
          ++v11;
          v24 += 0x30;
        }
        v28 = sub_4AA78(a2, (int)v24);
        v17 = *((unsigned __int8 *)v24 + 0x14);
        v23 = *((unsigned __int8 *)v24 + 0x15);
        if ( ((v17 | v23) & v29) != 0 )
        {
          if ( *(_DWORD *)(a2 + 0x28) )
          {
            if ( ((unsigned __int8)v17 & v29) != 0 && (v29 & (unsigned __int8)v23) == 0 )
            {
              if ( *(int *)((char *)&dword_104FD1 + v11) >> 0x18 <= 0 )
              {
                v15 = (double)dword_104BEC[v10];
                goto LABEL_53;
              }
LABEL_35:
              v25 = 0.0;
              goto LABEL_54;
            }
LABEL_36:
            v25 = 0.0;
            goto LABEL_54;
          }
          if ( v22 )
          {
            if ( ((unsigned __int8)v17 & v29) == 0 )
            {
              goto LABEL_35;
            }
            v12 = *(int *)((char *)&dword_104F6D + v11) >> 0x18;
            v25 = (float)dword_104BEC[v10];
            if ( v12 <= 1 )
            {
              goto LABEL_54;
            }
            LOBYTE(v13) = v12 - 1;
          }
          else
          {
            if ( ((unsigned __int8)v17 & v29) != 0 )
            {
              v14 = (double)(dword_104D7C[v10] + dword_104BEC[v10]);
            }
            else
            {
              v14 = (double)dword_104D7C[v10];
            }
            v25 = v14;
            if ( *(int *)((char *)&dword_104F09 + v11) >> 0x18 <= 0 )
            {
              goto LABEL_54;
            }
            LOBYTE(v13) = HIBYTE(*(unsigned int *)((char *)&dword_104F09 + v11));
          }
        }
        else
        {
          if ( *(_DWORD *)(a2 + 0x28) )
          {
            if ( *(int *)((char *)&dword_104FD1 + v11) >> 0x18 > 0 )
            {
              goto LABEL_36;
            }
            v15 = (double)dword_104BEC[v10];
LABEL_53:
            v25 = v15;
            goto LABEL_54;
          }
          if ( v22 )
          {
            v25 = *(float *)(a2 + 0x28);
            goto LABEL_54;
          }
          v13 = *(int *)((char *)&dword_104F09 + v11) >> 0x18;
          v25 = (float)dword_104D7C[v10];
          if ( v13 <= 0 )
          {
LABEL_54:
            v16 = v25 / (double)(v28 / 0x19 + 1);
            if ( v16 > v21 )
            {
              v20 = (int)v24;
              v27 = v11;
              v26 = v16;
              v21 = v26;
            }
            goto LABEL_56;
          }
        }
        v15 = v25 / (double)(1 << v13);
        goto LABEL_53;
      }
    }
  }
  return a1;
}
// A0D00: using guessed type int dword_A0D00;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// 104BEC: using guessed type int dword_104BEC[];
// 104D7C: using guessed type int dword_104D7C[];
// 104F09: using guessed type int dword_104F09;
// 104F6D: using guessed type int dword_104F6D;
// 104FD1: using guessed type int dword_104FD1;

//----- (0003EFE0) --------------------------------------------------------
size_t __fastcall sub_3EFE0(int a1)
{
  int v2; // ebx
  __int16 *v3; // edx
  size_t v4; // ebp
  int i; // eax
  size_t result; // eax

  v2 = 1;
  v3 = word_A3D21;
  v4 = sub_40224((unsigned __int8 *)a1, 0, 0);
  for ( i = 0; (__int16)i < word_A62A1; v3 += 0x30 )
  {
    if ( *((unsigned __int8 *)v3 + 0x14) == 1 << *(_BYTE *)a1 )
    {
      ++v2;
    }
    ++i;
  }
  result = v2 - v4;
  if ( ((1 << *(_BYTE *)a1) & *(unsigned __int8 *)(*(_DWORD *)(a1 + 7) + 0x14)) != 0 )
  {
    ++result;
  }
  return result;
}
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (0003F060) --------------------------------------------------------
__int16 __fastcall sub_3F060(unsigned __int8 *a1, _DWORD *a2, int a3, unsigned __int8 a4)
{
  int v6; // eax
  __int16 v7; // cx
  int v8; // edx
  char v9; // bl
  char v10; // bh
  __int16 result; // ax
  int v12; // [esp+0h] [ebp-26h]
  __int16 v13; // [esp+6h] [ebp-20h]
  char v14; // [esp+Ah] [ebp-1Ch]
  char v15; // [esp+Eh] [ebp-18h]
  char v16; // [esp+12h] [ebp-14h]

  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xCD0);
  }
  v13 = 0;
  v6 = 1 << *a1;
  if ( (v6 & SHIBYTE(dword_1052EA)) != 0 )
  {
    v13 = 1;
    if ( (v6 & SHIBYTE(dword_105830)) != 0 )
    {
      v13 = 2;
      if ( (v6 & SHIBYTE(dword_105BB4)) != 0 )
      {
        v13 = 3;
      }
    }
  }
  if ( !v13 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xCE2);
  }
  HIWORD(v12) = dword_A2F6C[0] / 0xFA;
  v7 = v13;
  if ( SHIWORD(v12) >= 1 )
  {
    if ( SHIWORD(v12) > 8 )
    {
      HIWORD(v12) = 8;
    }
  }
  else
  {
    HIWORD(v12) = 1;
  }
  while ( v7 >= 0 )
  {
    sub_49148((int)a2, v7);
    v8 = sub_4A18C((int)a2) + *(_DWORD *)((char *)a2 + 0x15A) * (v12 >> 0x10);
    if ( !*(_WORD *)(a3 + 0x44) )
    {
      *(_WORD *)(a3 + 0x44) = 1;
    }
    if ( v8 / *(unsigned __int16 *)(a3 + 0x44) + 1 < *((__int16 *)a1 + 0xD8) )
    {
      break;
    }
    --v7;
  }
  if ( v7 < 0 )
  {
    v7 = 0;
  }
  sub_49148((int)a2, v7);
  v15 = sub_4A36C((int)a2, 0, *a1);
  v14 = sub_4A36C((int)a2, 4, *a1);
  v16 = sub_4A36C((int)a2, 2, *a1);
  v9 = sub_4A36C((int)a2, 1, *a1);
  v10 = 0x2B;
  if ( sub_4A404((int)a2, 0x2C) )
  {
    v10 = 0x2C;
  }
  if ( v14 == (char)0xFF )
  {
    v14 = 0x1B;
  }
  if ( v16 == (char)0xFF )
  {
    v16 = 0x10;
  }
  if ( v15 == (char)0xFF )
  {
    v15 = 0;
  }
  if ( v9 == (char)0xFF )
  {
    v9 = 0xA;
  }
  result = v7;
  switch ( v7 )
  {
    case 0:
      result = sub_3F324((int)a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    case 1:
      result = sub_3F3F8(a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    case 2:
      result = sub_3F784((int)a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    case 3:
      result = sub_3FBAC((int)a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    default:
      return result;
  }
  return result;
}
// 3F0F5: conditional instruction was optimized away because %var_20.2<4u
// 3F15C: variable 'v12' is possibly undefined
// A2F6C: using guessed type int dword_A2F6C[];
// 1052EA: using guessed type int dword_1052EA;
// 105830: using guessed type int dword_105830;
// 105BB4: using guessed type int dword_105BB4;

//----- (0003F324) --------------------------------------------------------
unsigned int __fastcall sub_3F324(int a1, char a2, char a3, char a4, int a5, char a6, _DWORD *a7, unsigned __int8 a8)
{
  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a3, 1);
  sub_492AC(a7, a6, 2);
  if ( a8 )
  {
    if ( a8 > 1u && a8 == 2 )
    {
      sub_492AC(a7, 0x49, 3);
      return sub_492AC(a7, 0x49, 4);
    }
    else
    {
      sub_492AC(a7, a4, 3);
      return sub_492AC(a7, a4, 4);
    }
  }
  else
  {
    sub_492AC(a7, 0x47, 3);
    return sub_492AC(a7, 0x47, 4);
  }
}

//----- (0003F3F8) --------------------------------------------------------
unsigned int __fastcall sub_3F3F8(
        unsigned __int8 *a1,
        char a2,
        char a3,
        char a4,
        char a5,
        char a6,
        _DWORD *a7,
        unsigned __int8 a8)
{
  int v9; // ecx
  int v10; // edi
  int v11; // ecx
  int v12; // ecx
  unsigned int result; // eax
  int v14; // edx
  char v15; // edx^3
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx
  int v19; // ecx
  int v20; // ecx
  int v21; // ebx
  int v22; // ebx
  int v23; // ecx
  int v24; // edx
  char v25; // edx^3
  int v26; // ebx
  int v27; // ecx
  int v28; // ebx
  int v29; // ecx
  int v30; // ebx
  int v31; // ecx
  int v32; // edx
  char v33; // edx^3
  int v34; // ebx

  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a2, 1);
  sub_492AC(a7, a3, 2);
  sub_492AC(a7, a6, 3);
  v9 = 4;
  if ( (int)a7[6] < 8 )
  {
    v9 = 5;
    sub_492AC(a7, a2, 4);
  }
  v10 = v9 + 1;
  if ( !a8 )
  {
    sub_492AC(a7, 0x47, v9);
    sub_492AC(a7, 0x47, v10);
    sub_492AC(a7, 0x47, v9 + 2);
    sub_492AC(a7, 0x49, v9 + 3);
    v12 = v9 + 5;
    result = sub_492AC(a7, a6, v10 + 3);
    if ( v10 + 4 >= 0xA )
    {
      return result;
    }
    while ( 1 )
    {
      v14 = rand() % 0x64;
      if ( v14 > 0x4B )
      {
        break;
      }
      if ( v14 > 0x32 )
      {
        v15 = a5;
        goto LABEL_17;
      }
      if ( v14 <= 0x19 )
      {
        v15 = a6;
        goto LABEL_17;
      }
      result = sub_492AC(a7, 0x47, v12++);
LABEL_18:
      if ( v12 >= 0xA )
      {
        return result;
      }
    }
    v15 = a2;
LABEL_17:
    v16 = v12++;
    result = sub_492AC(a7, v15, v16);
    goto LABEL_18;
  }
  if ( a8 > 1u && a8 == 2 )
  {
    if ( a4 == 5 || !sub_4A404((int)a7, 5) )
    {
      v28 = v9;
      v27 = v9 + 1;
      sub_492AC(a7, a4, v28);
    }
    else
    {
      sub_492AC(a7, 5, v9);
      v27 = v9 + 1;
    }
    sub_492AC(a7, 0x49, v27);
    v29 = v27 + 1;
    sub_492AC(a7, 0x49, v29++);
    sub_492AC(a7, 0x49, v29);
    v30 = v29 + 1;
    v31 = v29 + 2;
    result = sub_492AC(a7, a5, v30);
    if ( v31 >= 0xA )
    {
      return result;
    }
    while ( 1 )
    {
      v32 = rand() % 0x64;
      if ( v32 > 0x4B )
      {
        break;
      }
      if ( v32 > 0x32 )
      {
        v33 = a5;
        goto LABEL_48;
      }
      if ( v32 <= 0x19 )
      {
        v33 = a6;
        goto LABEL_48;
      }
      result = sub_492AC(a7, 0x49, v31++);
LABEL_49:
      if ( v31 >= 0xA )
      {
        return result;
      }
    }
    v33 = a2;
LABEL_48:
    v34 = v31++;
    result = sub_492AC(a7, v33, v34);
    goto LABEL_49;
  }
  if ( a4 == 5 || !sub_4A404((int)a7, 5) )
  {
    v17 = v9;
    v11 = v9 + 1;
    sub_492AC(a7, a4, v17);
  }
  else
  {
    sub_492AC(a7, 5, v9);
    v11 = v9 + 1;
  }
  v18 = v11;
  v19 = v11 + 1;
  sub_492AC(a7, a4, v18);
  sub_492AC(a7, a4, v19++);
  sub_492AC(a7, a5, v19);
  v20 = v19 + 1;
  if ( sub_4A404((int)a7, 0x24) )
  {
    sub_492AC(a7, 0x24, v20++);
  }
  if ( a6 == 0x2B || dword_A2F6C[0] > 0x320 || *(int *)((char *)&dword_A3CF2 + 6 * *a1 + 2) >> 0x10 >= 3 )
  {
    v21 = v20++;
    sub_492AC(a7, a6, v21);
  }
  sub_492AC(a7, a5, v20);
  v22 = v20 + 1;
  v23 = v20 + 2;
  result = sub_492AC(a7, 0x49, v22);
  if ( v23 < 0xA )
  {
    while ( 1 )
    {
      v24 = rand() % 0x64;
      if ( v24 > 0x42 )
      {
        break;
      }
      if ( v24 <= 0x21 )
      {
        v25 = a5;
        goto LABEL_33;
      }
      result = sub_492AC(a7, 0x49, v23++);
LABEL_34:
      if ( v23 >= 0xA )
      {
        return result;
      }
    }
    v25 = a2;
LABEL_33:
    v26 = v23++;
    result = sub_492AC(a7, v25, v26);
    goto LABEL_34;
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3CF2: using guessed type int dword_A3CF2;

//----- (0003F784) --------------------------------------------------------
unsigned int __fastcall sub_3F784(int a1, char a2, char a3, char a4, char a5, char a6, _DWORD *a7, unsigned __int8 a8)
{
  int v8; // esi
  int v9; // ebp
  int v10; // esi
  int v11; // esi
  int v12; // esi
  unsigned int result; // eax
  int v14; // edx
  int v15; // ebx
  int v16; // ebx
  char v17; // dl
  int v18; // ebx
  int v19; // esi
  int v20; // ebx
  int v21; // esi
  int v22; // esi
  int v23; // ecx
  int v24; // esi
  char v25; // dl
  int v26; // esi
  int v27; // ebx
  int v28; // esi
  int v29; // ebx
  int v30; // esi
  int v31; // edx
  int v32; // ebx
  int v33; // ebx
  char v34; // dl

  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a2, 1);
  sub_492AC(a7, a2, 2);
  sub_492AC(a7, a3, 3);
  sub_492AC(a7, a6, 4);
  sub_492AC(a7, a6, 5);
  v8 = 6;
  if ( (int)a7[6] < 0x10 )
  {
    v8 = 7;
    sub_492AC(a7, a2, 6);
  }
  v9 = v8 + 1;
  if ( a8 )
  {
    if ( a8 <= 1u || a8 != 2 )
    {
      sub_492AC(a7, a4, v8);
      v10 = v8 + 1;
      if ( a4 == 7 || !sub_4A404((int)a7, 7) )
      {
        v18 = v10;
        v11 = v10 + 1;
        sub_492AC(a7, a4, v18);
      }
      else
      {
        sub_492AC(a7, 7, v10);
        v11 = v10 + 1;
      }
      if ( a4 == 5 || !sub_4A404((int)a7, 5) )
      {
        v20 = v11;
        v19 = v11 + 1;
        sub_492AC(a7, a4, v20);
      }
      else
      {
        sub_492AC(a7, 5, v11);
        v19 = v11 + 1;
      }
      sub_492AC(a7, a5, v19);
      v21 = v19 + 1;
      if ( a6 == 0x2B )
      {
        sub_492AC(a7, 0x2B, v21++);
      }
      sub_492AC(a7, 0x49, v21);
      v22 = v21 + 1;
      if ( sub_4A404((int)a7, 0x39) )
      {
        sub_492AC(a7, 0x39, v22++);
      }
      if ( sub_4A404((int)a7, 0x24) )
      {
        sub_492AC(a7, 0x24, v22++);
      }
      if ( sub_4A404((int)a7, 0x41) )
      {
        sub_492AC(a7, 0x41, v22++);
      }
      v23 = v22 + 2;
      sub_492AC(a7, 0x46, v22);
      v24 = v22 + 1;
      if ( sub_4A404((int)a7, 0x23) )
      {
        v25 = 0x23;
      }
      else
      {
        if ( !sub_4A404((int)a7, 0x21) )
        {
          return sub_40084(a1, a7, v24, a2);
        }
        v25 = 0x21;
      }
      sub_492AC(a7, v25, v24);
      v24 = v23;
      return sub_40084(a1, a7, v24, a2);
    }
    if ( a4 == 5 || !sub_4A404((int)a7, 5) )
    {
      v27 = v8;
      v26 = v8 + 1;
      sub_492AC(a7, a4, v27);
    }
    else
    {
      sub_492AC(a7, 5, v8);
      v26 = v8 + 1;
    }
    sub_492AC(a7, 0x49, v26);
    v28 = v26 + 1;
    sub_492AC(a7, 0x49, v28++);
    sub_492AC(a7, 0x49, v28++);
    sub_492AC(a7, 0x49, v28++);
    sub_492AC(a7, a5, v28);
    v29 = v28 + 1;
    v30 = v28 + 2;
    result = sub_492AC(a7, a6, v29);
    while ( v30 < 0xF )
    {
      v31 = rand() % 0x64;
      if ( v31 <= 0x4B )
      {
        if ( v31 <= 0x32 )
        {
          if ( v31 <= 0x19 )
          {
            v33 = v30;
            v34 = a6;
          }
          else
          {
            v34 = 0x49;
            v33 = v30;
          }
        }
        else
        {
          v33 = v30;
          v34 = a5;
        }
        result = sub_492AC(a7, v34, v33);
        ++v30;
      }
      else
      {
        v32 = v30++;
        result = sub_492AC(a7, a2, v32);
      }
    }
  }
  else
  {
    sub_492AC(a7, 0x47, v8);
    sub_492AC(a7, 0x47, v9);
    sub_492AC(a7, 0x47, v8 + 2);
    sub_492AC(a7, 0x47, v8 + 3);
    sub_492AC(a7, 0x49, v8 + 4);
    sub_492AC(a7, a5, v8 + 5);
    v12 = v8 + 7;
    result = sub_492AC(a7, a6, v9 + 5);
    if ( v9 + 6 < 0xF )
    {
      do
      {
        v14 = rand() % 0x64;
        if ( v14 <= 0x50 )
        {
          if ( v14 <= 0x3C )
          {
            if ( v14 <= 0x28 )
            {
              if ( v14 <= 0x14 )
              {
                v16 = v12;
                v17 = a6;
              }
              else
              {
                v17 = 0x47;
                v16 = v12;
              }
            }
            else
            {
              v17 = 0x49;
              v16 = v12;
            }
          }
          else
          {
            v16 = v12;
            v17 = a5;
          }
          result = sub_492AC(a7, v17, v16);
          ++v12;
        }
        else
        {
          v15 = v12++;
          result = sub_492AC(a7, a2, v15);
        }
      }
      while ( v12 < 0xF );
    }
  }
  return result;
}

//----- (0003FBAC) --------------------------------------------------------
unsigned int __fastcall sub_3FBAC(int a1, char a2, char a3, char a4, char a5, char a6, _DWORD *a7, unsigned __int8 a8)
{
  int v8; // esi
  int v9; // ebp
  int v10; // ebx
  int v11; // esi
  int v12; // esi
  int v13; // esi
  unsigned int result; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // ebx
  char v18; // dl
  int v19; // ebx
  int v20; // esi
  int v21; // ebx
  int v22; // esi
  int v23; // ebx
  int v24; // esi
  int v25; // esi
  int v26; // ebp
  int v27; // esi
  int v28; // esi
  char v29; // dl
  int v30; // esi
  int v31; // ebx
  int v32; // esi
  int v33; // ebx
  int v34; // esi
  int v35; // edx
  int v36; // ebx
  int v37; // ebx
  char v38; // dl

  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a2, 1);
  sub_492AC(a7, a2, 2);
  sub_492AC(a7, a2, 3);
  sub_492AC(a7, a3, 4);
  sub_492AC(a7, a3, 5);
  sub_492AC(a7, a6, 6);
  sub_492AC(a7, a6, 7);
  sub_492AC(a7, a5, 8);
  v8 = 9;
  if ( (int)a7[6] < 0x18 )
  {
    v8 = 0xA;
    sub_492AC(a7, a2, 9);
  }
  if ( a6 == 0x2B )
  {
    sub_492AC(a7, 0x2B, v8++);
  }
  v9 = v8 + 1;
  if ( a8 )
  {
    if ( a8 <= 1u || a8 != 2 )
    {
      v10 = v8;
      v11 = v8 + 1;
      sub_492AC(a7, a4, v10);
      if ( a4 == 7 || !sub_4A404((int)a7, 7) )
      {
        v19 = v11;
        v12 = v11 + 1;
        sub_492AC(a7, a4, v19);
      }
      else
      {
        sub_492AC(a7, 7, v11);
        v12 = v11 + 1;
      }
      if ( a4 == 5 || !sub_4A404((int)a7, 5) )
      {
        v21 = v12;
        v20 = v12 + 1;
        sub_492AC(a7, a4, v21);
      }
      else
      {
        sub_492AC(a7, 5, v12);
        v20 = v12 + 1;
      }
      if ( a4 == 8 || !sub_4A404((int)a7, 8) )
      {
        v23 = v20;
        v22 = v20 + 1;
        sub_492AC(a7, a4, v23);
      }
      else
      {
        sub_492AC(a7, 8, v20);
        v22 = v20 + 1;
      }
      sub_492AC(a7, 0x49, v22);
      v24 = v22 + 1;
      sub_492AC(a7, 0x49, v24);
      v25 = v24 + 1;
      if ( sub_4A404((int)a7, 0x39) )
      {
        sub_492AC(a7, 0x39, v25++);
      }
      if ( sub_4A404((int)a7, 0x24) )
      {
        sub_492AC(a7, 0x24, v25++);
      }
      if ( sub_4A404((int)a7, 0x41) )
      {
        sub_492AC(a7, 0x41, v25++);
      }
      v26 = v25 + 4;
      sub_492AC(a7, 0x46, v25);
      v27 = v25 + 1;
      sub_492AC(a7, 0x46, v27++);
      sub_492AC(a7, a6, v27);
      v28 = v27 + 1;
      if ( sub_4A404((int)a7, 0x23) )
      {
        v29 = 0x23;
      }
      else
      {
        if ( !sub_4A404((int)a7, 0x21) )
        {
          return sub_40084(a1, a7, v28, a2);
        }
        v29 = 0x21;
      }
      sub_492AC(a7, v29, v28);
      v28 = v26;
      return sub_40084(a1, a7, v28, a2);
    }
    if ( a4 == 5 || !sub_4A404((int)a7, 5) )
    {
      v31 = v8;
      v30 = v8 + 1;
      sub_492AC(a7, a4, v31);
    }
    else
    {
      sub_492AC(a7, 5, v8);
      v30 = v8 + 1;
    }
    sub_492AC(a7, 0x49, v30);
    v32 = v30 + 1;
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, a5, v32);
    v33 = v32 + 1;
    v34 = v32 + 2;
    result = sub_492AC(a7, a6, v33);
    while ( v34 < 0x19 )
    {
      v35 = rand() % 0x64;
      if ( v35 <= 0x4B )
      {
        if ( v35 <= 0x32 )
        {
          if ( v35 <= 0x19 )
          {
            v37 = v34;
            v38 = a6;
          }
          else
          {
            v38 = 0x49;
            v37 = v34;
          }
        }
        else
        {
          v37 = v34;
          v38 = a5;
        }
        result = sub_492AC(a7, v38, v37);
        ++v34;
      }
      else
      {
        v36 = v34++;
        result = sub_492AC(a7, a2, v36);
      }
    }
  }
  else
  {
    sub_492AC(a7, 0x47, v8);
    sub_492AC(a7, 0x47, v9);
    sub_492AC(a7, 0x47, v8 + 2);
    sub_492AC(a7, 0x47, v8 + 3);
    sub_492AC(a7, 0x47, v8 + 4);
    sub_492AC(a7, 0x49, v8 + 5);
    v13 = v8 + 7;
    result = sub_492AC(a7, a5, v9 + 5);
    if ( v9 + 6 < 0x19 )
    {
      do
      {
        v15 = rand() % 0x64;
        if ( v15 <= 0x50 )
        {
          if ( v15 <= 0x3C )
          {
            if ( v15 <= 0x28 )
            {
              if ( v15 <= 0x14 )
              {
                v17 = v13;
                v18 = a6;
              }
              else
              {
                v18 = 0x47;
                v17 = v13;
              }
            }
            else
            {
              v18 = 0x49;
              v17 = v13;
            }
          }
          else
          {
            v17 = v13;
            v18 = a5;
          }
          result = sub_492AC(a7, v18, v17);
          ++v13;
        }
        else
        {
          v16 = v13++;
          result = sub_492AC(a7, a2, v16);
        }
      }
      while ( v13 < 0x19 );
    }
  }
  return result;
}

//----- (00040084) --------------------------------------------------------
int __fastcall sub_40084(int a1, _DWORD *a2, int a3, char a4)
{
  __int16 v4; // cx
  __int16 v5; // bx
  int v6; // eax
  int v7; // esi
  int v8; // edi
  char v9; // al
  int result; // eax
  int v11; // ebx
  char v12[28]; // [esp+4h] [ebp-44h]
  char v13[20]; // [esp+20h] [ebp-28h] BYREF
  int v14; // [esp+34h] [ebp-14h]
  char v15; // [esp+38h] [ebp-10h]

  v14 = a3;
  v15 = a4;
  v4 = 0;
  v5 = 0;
  qmemcpy(v13, "E?2.-&%\"/74@62&%B=01", sizeof(v13));
  while ( v5 < 0x14 )
  {
    if ( sub_4A404((int)a2, v13[v5]) )
    {
      v6 = v4++;
      v12[v6] = v13[v5];
    }
    ++v5;
  }
  while ( v14 < *(_DWORD *)((char *)a2 + 0x15A) && v4 )
  {
    v7 = rand() % v4;
    v8 = v14 + 1;
    --v4;
    sub_492AC(a2, v12[v7], v14);
    v9 = v12[v4];
    v14 = v8;
    v12[v7] = v9;
  }
  while ( 1 )
  {
    result = v14;
    if ( v14 >= *(_DWORD *)((char *)a2 + 0x15A) )
    {
      break;
    }
    v11 = v14++;
    sub_492AC(a2, v15, v11);
  }
  return result;
}
// 40084: using guessed type char var_28[20];
// 40084: using guessed type char var_44[28];

//----- (00040144) --------------------------------------------------------
char *__fastcall sub_40144(unsigned __int8 *a1, int a2)
{
  char *v5; // eax
  char *v6; // ecx
  unsigned __int16 v7; // di
  int v8; // edx
  unsigned __int16 v9; // [esp+0h] [ebp-14h]

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF3C);
  }
  if ( (int)sub_3EFE0((int)a1) > 0 )
  {
    v5 = sub_20684((int)dword_A2F6C, *a1);
    v6 = v5;
    if ( !v5 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF45);
    }
    if ( v5 )
    {
      v9 = sub_4A18C((int)v5);
      if ( !v9 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF51);
      }
      v7 = *(_WORD *)(a2 + 0x44);
      if ( !v7 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF54);
      }
      v8 = dword_A2F6C[0];
      v6[0x58] = 1;
      *(_DWORD *)(v6 + 0x59) = a2;
      *(_DWORD *)(v6 + 0x52) = v8 + v9 / (int)v7 + 1;
    }
    return v6;
  }
  else
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\race.cpp", 0xF40);
    return 0;
  }
}
// A2F6C: using guessed type int dword_A2F6C[];

//----- (00040218) --------------------------------------------------------
int __fastcall compar(const void *a1, const void *a2)
{
  return *(_DWORD *)(*(_DWORD *)a1 + 0x52) - *(_DWORD *)(*(_DWORD *)a2 + 0x52);
}

//----- (00040224) --------------------------------------------------------
size_t __fastcall sub_40224(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3)
{
  __int16 *v4; // eax
  int v5; // esi
  __int16 i; // cx
  void *base; // [esp+4h] [ebp-1Ch]
  size_t nmemb; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]

  base = a2;
  v4 = (__int16 *)&unk_CA1F1;
  v5 = 0;
  nmemb = 0;
  if ( a3 )
  {
    *a3 = 0;
  }
  for ( i = 0; i < 0x6B && v5 < SHIWORD(dword_D35E5); ++i )
  {
    v10 = v4[0x2B];
    if ( v10 != 0xFFFFFFFF )
    {
      ++v5;
      if ( v10 == *a1 )
      {
        if ( base )
        {
          *a2 = v4;
        }
        ++a2;
        ++nmemb;
        if ( a3 )
        {
          *a3 += *((char *)v4 + 0xAA) + 1;
        }
      }
    }
    v4 += 0xB1;
  }
  if ( base )
  {
    qsort(base, nmemb, 4u, compar);
  }
  return nmemb;
}
// D35E5: using guessed type int dword_D35E5;

//----- (000402E0) --------------------------------------------------------
int __fastcall sub_402E0(_BYTE *a1)
{
  int v2; // ebx
  int v3; // eax
  int v4; // edx

  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( v3 < SHIWORD(dword_CA1ED) )
  {
    if ( byte_BB20A[v4] == *a1 )
    {
      ++v2;
    }
    v4 += 0x7B;
    ++v3;
  }
  return v2;
}
// CA1ED: using guessed type int dword_CA1ED;

//----- (000403C0) --------------------------------------------------------
int __fastcall sub_403C0(unsigned __int8 *a1, int a2)
{
  __int16 v3; // bx
  __int16 v4; // cx
  int i; // ebp
  int v6; // ebx
  unsigned __int16 v7; // ax
  int *v8; // ecx
  int v9; // ebx
  __int16 v10; // ax
  int v11; // ebx
  int v14; // [esp+0h] [ebp-28h]
  unsigned __int16 v15; // [esp+4h] [ebp-24h]
  unsigned __int16 v16; // [esp+8h] [ebp-20h]
  __int16 v17; // [esp+Ch] [ebp-1Ch]

  v16 = 0;
  v3 = 0;
  v14 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( *(int *)((char *)&dword_A2F75 + 0x1EE * v3) == 0xFFFFFFFF
         || v3 == *a1
         || a1[v3 + 0x1C0] != 3
         || ((1 << v3) & *(unsigned __int8 *)(a2 + 0x14)) == 0 )
    {
      if ( ++v3 >= SHIWORD(dword_A3CF2) )
      {
        goto LABEL_9;
      }
    }
    return 0;
  }
LABEL_9:
  v4 = 0;
  for ( i = (a1[0x19D] != 2) - 1; v4 < *(__int16 *)(a2 + 0x5A); ++v4 )
  {
    v6 = *(_DWORD *)(a2 + 4 * v4 + 0x46);
    if ( *(unsigned __int8 *)(v6 + 0x57) == 0xFF )
    {
      sub_3636C(*(_DWORD *)(a2 + 4 * v4 + 0x46), i);
      if ( (*(_BYTE *)(v6 + 0x66) & 2) != 0 )
      {
        v7 += 0x28;
      }
      if ( v7 > v16 )
      {
        v16 = v7;
        v14 = v6;
      }
    }
  }
  v15 = 0x46;
  if ( *(_BYTE *)(a2 + 0x14) )
  {
    v10 = 0;
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      while ( 1 )
      {
        if ( a1[v10 + 0x1C0] == 2 )
        {
          v11 = *(unsigned __int8 *)(a2 + 0x14);
          if ( ((1 << v10) & v11) != 0 && ((1 << *a1) & v11) == 0 )
          {
            break;
          }
        }
        if ( ++v10 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_34;
        }
      }
      v15 = 0;
    }
  }
  else
  {
    v15 = 0x23;
    v17 = 0;
    if ( *(__int16 *)(a2 + 0x44) > 0 )
    {
      while ( 1 )
      {
        v8 = *(int **)(a2 + 4 * v17 + 0x2C);
        if ( !v8 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x100E);
        }
        v9 = *v8;
        if ( a2 == *v8 )
        {
          v9 = v8[1];
        }
        if ( ((1 << *a1) & *(unsigned __int8 *)(v9 + 0x14)) != 0 )
        {
          break;
        }
        if ( ++v17 >= *(__int16 *)(a2 + 0x44) )
        {
          goto LABEL_34;
        }
      }
      v15 = 0x11;
    }
  }
LABEL_34:
  if ( v16 <= v15 )
  {
    return 0;
  }
  return v14;
}
// 40480: variable 'v7' is possibly undefined
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00040590) --------------------------------------------------------
int __fastcall sub_40590(_BYTE *a1)
{
  int v2; // edx
  int v3; // eax

  v2 = dword_10509C;
  if ( !dword_10509C )
  {
    v3 = 0;
    dword_1050A0 = 0xFFFFFFFF;
    while ( v2 < (unsigned __int16)word_105258 )
    {
      if ( ((1 << *a1) & (*(int *)((char *)&dword_10529F + v3) >> 0x18)) == 0 )
      {
        dword_1050A0 = 0;
        break;
      }
      v3 += 0x4B;
      ++v2;
    }
    dword_10509C = 0xFFFFFFFF;
  }
  return dword_1050A0;
}
// 10509C: using guessed type int dword_10509C;
// 1050A0: using guessed type int dword_1050A0;
// 10529F: using guessed type int dword_10529F;

//----- (000405F4) --------------------------------------------------------
unsigned int __fastcall sub_405F4(_BYTE *a1)
{
  unsigned int v2; // esi
  __int16 i; // dx
  char *v4; // eax
  char v5; // cl

  v2 = 0;
  if ( sub_40590(a1) )
  {
    for ( i = 0; i < SHIWORD(dword_CA1ED); ++i )
    {
      v4 = (char *)&unk_BB1B3 + 0x7B * i;
      v5 = v4[0x57];
      if ( v5 == *a1 && (v5 != (_BYTE)byte_104BEA || *(_DWORD *)(v4 + 0x5A) || dword_A0D00) )
      {
        if ( sub_3623C((int)v4) )
        {
          v2 = 0xFFFFFFFF;
        }
      }
    }
  }
  return v2;
}
// A0D00: using guessed type int dword_A0D00;
// CA1ED: using guessed type int dword_CA1ED;

//----- (00040664) --------------------------------------------------------
int __fastcall sub_40664(_BYTE *a1)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( v3 < (unsigned __int16)word_105258 )
  {
    if ( ((1 << *a1) & (*(int *)((char *)&dword_10529F + v4) >> 0x18)) != 0 )
    {
      ++v2;
    }
    v4 += 0x4B;
    ++v3;
  }
  return v2;
}
// 10529F: using guessed type int dword_10529F;

//----- (000406C4) --------------------------------------------------------
int __fastcall sub_406C4(unsigned __int8 *a1, __int16 *a2, int a3)
{
  unsigned __int8 v4; // cl
  __int16 v5; // cx
  int v6; // ebp
  int v7; // esi
  __int16 v8; // bx
  char v9; // dh
  __int16 v10; // ax
  __int16 *v11; // ecx
  int v12; // edx
  int v13; // ebx
  char v14; // cl
  int v15; // eax
  unsigned int v16; // ebx
  char v17; // ch
  __int16 v18; // si
  int v19; // ebx
  unsigned int v20; // eax
  int result; // eax
  __int16 v22; // dx
  unsigned __int8 v23; // al
  unsigned int v24; // ebp
  int v25; // ebx
  __int16 *v26; // esi
  __int16 i; // ax
  int v28; // ebx
  int v29; // esi
  __int16 v30; // cx
  __int16 j; // bx
  int v32; // edx
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ebx
  unsigned __int8 v37; // al
  __int16 v38; // dx
  __int16 v39; // di
  int v40; // ecx
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  char v45; // dl
  int v46; // eax
  int v47; // eax
  int v48; // eax
  int v49; // ecx
  char v50; // bl
  int v51; // eax
  int v52; // ebp
  unsigned __int8 v53; // al
  __int16 v54; // cx
  int v55; // eax
  __int16 v56; // bx
  __int16 v57; // ax
  int v58[107]; // [esp+0h] [ebp-3CCh] BYREF
  int v59[107]; // [esp+1ACh] [ebp-220h] BYREF
  int v60[5]; // [esp+358h] [ebp-74h] BYREF
  __int16 v61[8]; // [esp+36Ch] [ebp-60h] BYREF
  int v62; // [esp+37Ch] [ebp-50h]
  int v63; // [esp+380h] [ebp-4Ch]
  int v64; // [esp+384h] [ebp-48h]
  int v65; // [esp+388h] [ebp-44h]
  int v66; // [esp+38Ch] [ebp-40h]
  int v67; // [esp+390h] [ebp-3Ch]
  __int16 *v68; // [esp+394h] [ebp-38h]
  int v69; // [esp+398h] [ebp-34h]
  int v70; // [esp+39Ch] [ebp-30h]
  __int16 v71; // [esp+3A0h] [ebp-2Ch]
  __int16 v72; // [esp+3A4h] [ebp-28h]
  int v73; // [esp+3A8h] [ebp-24h]
  int v74; // [esp+3ACh] [ebp-20h]
  __int16 v75; // [esp+3B0h] [ebp-1Ch]
  int v76; // [esp+3B2h] [ebp-1Ah]
  unsigned __int8 v77; // [esp+3B8h] [ebp-14h]

  v68 = a2;
  v64 = a3;
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1081);
  }
  v4 = *a1;
  v77 = *((_BYTE *)v68 + 0x14) | *((_BYTE *)v68 + 0x15);
  if ( ((1 << v4) & v77) == 0 )
  {
    return 0;
  }
  sub_3B56C(a1, v68);
  v5 = 0;
  HIWORD(v76) = 0;
  LOWORD(v73) = 0;
  LOWORD(v74) = 0;
  LOWORD(v70) = 0;
  v65 = 0;
  v6 = sub_1D794(v68, v58);
  while ( v5 < v6 )
  {
    v7 = v58[v5];
    if ( !v7 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x10AC);
    }
    if ( *(_WORD *)(v7 + 0x56) == *a1 && *(int *)(v7 + 0x88) > 0 && *(_BYTE *)(v7 + 0x58) != 1 )
    {
      v8 = *(_WORD *)(v7 + 0x94) + v70;
      LOWORD(v74) = *(_WORD *)(v7 + 0x88) + v74;
      v59[SHIWORD(v76)] = v7;
      LOWORD(v70) = v8;
      v9 = *(_BYTE *)(v7 + 0x5D);
      ++HIWORD(v76);
      if ( v9 )
      {
        v65 = 0xFFFFFFFF;
      }
    }
    ++v5;
  }
  v10 = 0;
  if ( v68[0x2D] > 0 )
  {
    v11 = v68;
    do
    {
      v12 = *(_DWORD *)&v11[2 * v10 + 0x23];
      if ( *(_BYTE *)(v12 + 0x57) == *a1 )
      {
        v13 = (__int16)v73;
        LOWORD(v73) = v73 + 1;
        v60[v13] = v12;
      }
      ++v10;
    }
    while ( v10 < v68[0x2D] );
  }
  if ( !HIWORD(v76) && !(_WORD)v73 )
  {
    return 0;
  }
  if ( v68 == *(__int16 **)(a1 + 7)
    || !HIWORD(v76)
    || (_BYTE)byte_104BEA == *a1
    || ((1 << *a1) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_107F3D) >> 0x18)) == 0 )
  {
    goto LABEL_39;
  }
  v14 = sub_43374(a1, 0xFFFFFFFF);
  v15 = *(_DWORD *)(a1 + 7);
  v16 = 0;
  v17 = *(_BYTE *)(v15 + 0x14);
  if ( (v17 & 0x7F) == 0 )
  {
    v16 = 0xFFFFFFFF;
  }
  if ( !v16 && ((unsigned __int8)v14 & (unsigned __int8)(v17 | *(_BYTE *)(v15 + 0x15))) != 0 )
  {
    v16 = 0xFFFFFFFF;
  }
  if ( v16 && (v18 = 0, SHIWORD(v76) > 0) )
  {
    while ( 1 )
    {
      v19 = v59[v18];
      if ( *(_BYTE *)(v19 + 0x58) == 4 )
      {
        if ( *(_DWORD *)(v19 + 0x88) )
        {
          v20 = sub_4937C(v59[v18], 0x24);
          if ( v20 != 0xFFFFFFFF )
          {
            *(_BYTE *)(v19 + 0x62) = 1;
            *(_DWORD *)(v19 + 0x63) = 7 * v20 + v19 + 0xAB;
            *(_BYTE *)(v19 + 0x67) = 5;
            if ( (sub_49B3C(v19, 0) & 1) != 0 )
            {
              break;
            }
          }
        }
      }
      if ( ++v18 >= SHIWORD(v76) )
      {
        goto LABEL_39;
      }
    }
    *(_BYTE *)v64 = 3;
    *(_DWORD *)(v64 + 1) = v59[v18];
    return 0xFFFFFFFF;
  }
  else
  {
LABEL_39:
    v22 = 0;
    v23 = 1;
    v24 = 0;
    v75 = 0;
    v62 = 0;
    while ( v22 < 7 )
    {
      v66 = v23;
      if ( (v23 & v77) != 0 )
      {
        v25 = v75;
        v26 = v68;
        v61[v25] = v22;
        if ( ((unsigned __int8)v66 & *((_BYTE *)v26 + 0x15)) != 0 )
        {
          LOBYTE(v61[v25]) |= 8u;
        }
        if ( (v23 & (_BYTE)v68[0xA]) != 0 )
        {
          LOBYTE(v61[v75]) |= 0x10u;
        }
        if ( a1[v22 + 0x1C0] == 2 )
        {
          if ( (_BYTE)byte_104BEA != *a1 || dword_A0D00 == 0xFFFFFFFF || (*((_BYTE *)v68 + 0x15) & v23) != 0 )
          {
            v24 = 0xFFFFFFFF;
            LOBYTE(v61[v75]) |= 0x20u;
          }
        }
        else if ( *a1 != (_BYTE)byte_104BEA
               && v22 == (unsigned __int8)byte_104BEA
               && ((1 << *a1) & (unsigned __int8)byte_D8460[v68[2]]) != 0 )
        {
          v24 = 0xFFFFFFFF;
          LOBYTE(v61[v75]) |= 0x20u;
        }
        ++v75;
      }
      ++v22;
      v23 *= 2;
    }
    if ( v75 <= 0 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1133);
    }
    if ( v75 == 1 )
    {
      v62 = 0xFFFFFFFF;
    }
    if ( !v62 && !v24 && (*a1 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF) )
    {
      LOWORD(v69) = 0;
      if ( v75 > 0 )
      {
        do
        {
          v71 = v61[(__int16)v69] & 7;
          if ( a1[(unsigned __int8)v71 + 0x1C0] == 3 )
          {
            for ( i = 0; i < v75; ++i )
            {
              v28 = v61[i] & 7;
              if ( byte_A3132[0x1EE * v71 + (unsigned __int8)v28] == 2 && a1[v28 + 0x1C0] != 3 )
              {
                v24 = 0xFFFFFFFF;
                LOBYTE(v61[i]) |= 0x20u;
              }
            }
          }
          LOWORD(v69) = v69 + 1;
        }
        while ( (__int16)v69 < v75 );
      }
    }
    if ( v24 != 0xFFFFFFFF
      || (_BYTE)byte_104BEA == *a1 && dword_A0D00 != 0xFFFFFFFF && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10
      || (result = sub_41268(
                     a1,
                     v75,
                     v76 >> 0x10,
                     (int)v61,
                     (int)v68,
                     (int)v59,
                     v73,
                     (int)v60,
                     (__int16)v74,
                     (__int16)v70,
                     (int)v68,
                     v64),
          result != 0xFFFFFFFF) )
    {
      if ( (_BYTE)byte_104BEA == *a1 && !v65 && !dword_A0D00 )
      {
        return 0;
      }
      v29 = 0;
      v30 = 0;
      for ( j = 0; j < SHIWORD(v76); ++j )
      {
        if ( !*(_BYTE *)(v59[j] + 0x5D) && (*a1 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF) )
        {
          sub_3EBDC((int)a1, v59[j]);
        }
        v32 = v59[j];
        if ( v30 < *(_DWORD *)(v32 + 0x88) && *(_BYTE *)(v32 + 0x5D) )
        {
          v29 = v59[j];
          v30 = *(_WORD *)(v32 + 0x88);
        }
      }
      if ( !v29 )
      {
        return 0;
      }
      switch ( *(_BYTE *)(v29 + 0x5D) )
      {
        case 1:
          if ( *(_BYTE *)(v29 + 0x58) == 3 )
          {
            sub_35C38(*(_DWORD *)(v29 + 0x59), v29);
          }
          if ( *(_BYTE *)(v29 + 0x58) != 4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1188);
          }
          if ( *a1 != (_BYTE)byte_104BEA
            && sub_1D834((int)v68, *a1) == 0xFFFFFFFF
            && *(_DWORD *)(v29 + 0x28) != 0xFFFFFFFF
            && sub_4A534(v29, 0x49) == 0xFFFFFFFF )
          {
            return 0;
          }
          v33 = *(_DWORD *)(v29 + 0x5E);
          if ( (__int16 *)v33 != v68 )
          {
            v36 = *(_DWORD *)(v29 + 0x5E);
            v37 = byte_D5D47[0x64 * v68[2] + *(__int16 *)(v33 + 4)];
            v38 = 0;
            v63 = 0;
            v39 = v68[0x22];
            v72 = v37;
            if ( v39 > 0 )
            {
              while ( 1 )
              {
                v67 = *(_DWORD *)&v68[2 * v38 + 0x16];
                if ( v68 == *(__int16 **)v67 )
                {
                  v41 = 0x64 * *(__int16 *)(*(_DWORD *)(v67 + 4) + 4);
                  v40 = *(__int16 *)(v36 + 4);
                }
                else
                {
                  v40 = 0x64 * *(__int16 *)(*(_DWORD *)v67 + 4);
                  v41 = *(__int16 *)(v36 + 4);
                }
                if ( (unsigned __int8)byte_D5D47[v40 + v41] == v72 - 1 )
                {
                  break;
                }
                if ( ++v38 >= v68[0x22] )
                {
                  goto LABEL_116;
                }
              }
              v63 = 0xFFFFFFFF;
            }
LABEL_116:
            if ( v63 != 0xFFFFFFFF )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x11CC);
            }
            if ( (*(_BYTE *)(v67 + 0x23) & 2) != 0 && sub_4A480(v29, 0, v67) )
            {
              v42 = v64;
              *(_BYTE *)v64 = 3;
              *(_DWORD *)(v42 + 1) = v29;
            }
            else
            {
              *(_BYTE *)(v29 + 0x62) = 0;
              v43 = v67;
              *(_DWORD *)(v29 + 0x63) = 0;
              *(_DWORD *)(v29 + 0x68) = v43;
              v44 = v64;
              *(_BYTE *)(v29 + 0x67) = 2;
              *(_BYTE *)v44 = 3;
              *(_DWORD *)(v44 + 1) = v29;
            }
            goto LABEL_122;
          }
          v34 = (unsigned int)v68 ^ v33;
          v35 = *(__int16 *)(v29 + 0x56);
          LOBYTE(v34) = byte_104BEA;
          *(_BYTE *)(v29 + 0x5D) = 0;
          if ( v35 != v34 || dword_A0D00 == 0xFFFFFFFF )
          {
            sub_3EBDC((int)a1, v29);
          }
          result = 0xFFFFFFFF;
          break;
        case 2:
          v49 = *(_DWORD *)(v29 + 0x5E);
          if ( !*(_DWORD *)(v29 + 0x28) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x123F);
          }
          if ( *(unsigned __int8 *)(v49 + 0x57) == 0xFF )
          {
            v50 = *(_BYTE *)(v29 + 0x58);
            if ( v50 == 3 )
            {
              v51 = *(_DWORD *)(v29 + 0x59);
              if ( v49 == v51 )
              {
                v52 = sub_4937C(v29, 0x47);
                if ( v52 == 0xFFFFFFFF )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x125A);
                }
                sub_492F8((_DWORD *)v29, v52);
                v53 = *a1;
                *(_WORD *)(v49 + 0x42) = 2;
                *(_BYTE *)(v49 + 0x57) = v53;
                *(_DWORD *)(v49 + 0x67) = dword_A2F6C;
                sub_34AE4(v49, 5u, 0xFFFFFFFF);
                --*(_DWORD *)(v29 + 0x88);
                *((_BYTE *)v68 + 0x14) |= 1 << *a1;
                v54 = v74 - 1;
                *(_BYTE *)(v29 + 0x5D) = 0;
                LOWORD(v74) = v54;
              }
              else
              {
                sub_35C38(v51, v29);
                if ( *(_BYTE *)(v29 + 0x58) != 4 )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1252);
                }
              }
            }
            else
            {
              if ( v50 != 4 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x126C);
              }
              *(_BYTE *)(v29 + 0x62) = 0;
              *(_DWORD *)(v29 + 0x63) = 0;
              *(_BYTE *)(v29 + 0x67) = 1;
              v55 = v64;
              *(_DWORD *)(v29 + 0x68) = v49;
              *(_BYTE *)v55 = 3;
              *(_DWORD *)(v55 + 1) = v29;
            }
          }
          else
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          goto LABEL_122;
        case 3:
          if ( *(_WORD *)(v29 + 0x56) != (unsigned __int8)byte_104BEA )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x11F3);
          }
          v45 = *(_BYTE *)(v29 + 0x58);
          if ( v45 == 3 )
          {
            if ( *(_DWORD *)(v29 + 0x59) != *(_DWORD *)(v29 + 0x5E) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x11F7);
            }
            v46 = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
            *(_BYTE *)(v29 + 0x5D) = 0;
            if ( v46 != 0x10 )
            {
              sub_55AEC((int)&V_Type3_stru_10AE70, 0x10, v29, *(_DWORD *)(v29 + 0x5E));
            }
          }
          else if ( v45 == 4 )
          {
            *(_BYTE *)(v29 + 0x62) = 0;
            *(_DWORD *)(v29 + 0x63) = 0;
            *(_DWORD *)(v29 + 0x68) = *(_DWORD *)(v29 + 0x5E);
            v47 = v64;
            *(_BYTE *)(v29 + 0x67) = 1;
            *(_BYTE *)v47 = 3;
            *(_DWORD *)(v47 + 1) = v29;
          }
          else
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          goto LABEL_122;
        case 7:
          if ( *(_WORD *)(v29 + 0x56) != (unsigned __int8)byte_104BEA )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x121D);
          }
          if ( *(_BYTE *)(v29 + 0x58) != 4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x121E);
          }
          if ( (*(_BYTE *)(v29 + 0x84) & 8) != 0 )
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          else if ( *(_BYTE *)(v29 + 0x62) )
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          else
          {
            v48 = v64;
            *(_BYTE *)(v29 + 0x67) = 3;
            *(_BYTE *)v48 = 3;
            *(_DWORD *)(v48 + 1) = v29;
          }
          goto LABEL_122;
        default:
          v56 = v74;
          v57 = *(_WORD *)(v29 + 0x88);
          *(_DWORD *)(v29 + 0x94) = 0;
          *(_DWORD *)(v29 + 0x88) = 0;
          LOWORD(v74) = v56 - v57;
LABEL_122:
          if ( (__int16)v74 <= 0 )
          {
            return 0;
          }
          return 0xFFFFFFFF;
      }
    }
  }
  return result;
}
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C;
// 10529F: using guessed type int dword_10529F;
// 107F3D: using guessed type char byte_107F3D;
// 406C4: using guessed type int var_3CC[107];
// 406C4: using guessed type int var_220[107];
// 406C4: using guessed type int var_74[5];

//----- (00041268) --------------------------------------------------------
int __userpurge sub_41268@<eax>(
        unsigned __int8 *a1@<eax>,
        __int16 a2@<dx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6,
        __int16 a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  __int16 v13; // ax
  _BYTE *v14; // edx
  int v15; // edi
  __int16 j; // ax
  int v17; // edx
  int v18; // esi
  char v19; // cl
  int v20; // edx
  int v21; // eax
  int v22; // edx
  int v23; // ebx
  int v24; // edx
  int v26; // ecx
  unsigned int v27; // eax
  unsigned int v28; // eax
  int v29; // edx
  int v30; // edx
  int v31; // esi
  __int16 n; // cx
  int v33; // ebx
  int v34; // esi
  int v35; // eax
  char v36; // bh
  __int16 v37; // bx
  int v38; // edx
  int v39; // ebp
  float *v40; // ebx
  __int16 ii; // si
  int v42; // edx
  char v43; // cl
  int v44; // ecx
  double v45; // st7
  double v46; // st7
  int v47; // edx
  __int16 v48; // bx
  __int16 v49; // cx
  int v50; // eax
  int v51; // edx
  int v52; // edi
  unsigned __int8 *v53; // ebp
  signed __int16 kk; // cx
  char *v55; // esi
  int *v56; // eax
  int v57; // ecx
  __int16 mm; // ax
  __int16 v59; // bx
  int *v60; // eax
  int v61; // ecx
  unsigned int v62; // eax
  unsigned int v63; // eax
  int v64; // ebp
  int v65; // ecx
  double v66; // st7
  char v67; // cl
  int v68; // ebp
  int v69; // edx
  int v70; // ebx
  int v71; // ebp
  int v72; // ebx
  int v73; // edi
  unsigned int v74; // eax
  unsigned int v75; // eax
  int v76; // edx
  int v77; // edx
  int *v78; // eax
  int v79; // eax
  int v80; // ecx
  __int16 v81; // ax
  char v82; // dl
  int v83; // esi
  int v84; // eax
  __int16 i2; // bx
  int v86; // edx
  char v87; // cl
  int v88; // eax
  int v89[107]; // [esp+8h] [ebp-40Ch] BYREF
  char v90; // [esp+1B4h] [ebp-260h]
  int v91; // [esp+1B5h] [ebp-25Fh]
  char v92; // [esp+1B9h] [ebp-25Bh]
  int v93; // [esp+1BAh] [ebp-25Ah]
  int v94; // [esp+1BEh] [ebp-256h]
  int v95; // [esp+1C2h] [ebp-252h]
  int v96; // [esp+1C6h] [ebp-24Eh]
  int v97; // [esp+1CAh] [ebp-24Ah]
  int v98; // [esp+1CEh] [ebp-246h]
  int v99; // [esp+1D2h] [ebp-242h]
  int v100; // [esp+1D6h] [ebp-23Eh]
  char v101; // [esp+1DCh] [ebp-238h]
  int v102; // [esp+1DDh] [ebp-237h]
  char v103; // [esp+1E1h] [ebp-233h]
  int v104; // [esp+1E2h] [ebp-232h]
  int v105; // [esp+1E6h] [ebp-22Eh]
  int v106; // [esp+1EAh] [ebp-22Ah]
  int v107; // [esp+1EEh] [ebp-226h]
  int v108; // [esp+1F2h] [ebp-222h]
  int v109; // [esp+1F6h] [ebp-21Eh]
  int v110; // [esp+1FAh] [ebp-21Ah]
  int v111; // [esp+1FEh] [ebp-216h]
  int v112[3]; // [esp+204h] [ebp-210h] BYREF
  float v113; // [esp+210h] [ebp-204h] BYREF
  float v114; // [esp+214h] [ebp-200h]
  float v115; // [esp+218h] [ebp-1FCh]
  float v116; // [esp+21Ch] [ebp-1F8h]
  int v117; // [esp+220h] [ebp-1F4h]
  int v118; // [esp+224h] [ebp-1F0h]
  float v119; // [esp+228h] [ebp-1ECh]
  int v120; // [esp+22Ch] [ebp-1E8h]
  int v121; // [esp+230h] [ebp-1E4h]
  int v122[3]; // [esp+234h] [ebp-1E0h] BYREF
  float v123; // [esp+240h] [ebp-1D4h]
  float v124; // [esp+244h] [ebp-1D0h]
  float v125; // [esp+248h] [ebp-1CCh]
  int v126[3]; // [esp+24Ch] [ebp-1C8h] BYREF
  int v127[3]; // [esp+258h] [ebp-1BCh] BYREF
  float v128; // [esp+264h] [ebp-1B0h]
  float v129; // [esp+268h] [ebp-1ACh]
  float v130; // [esp+26Ch] [ebp-1A8h]
  float v131; // [esp+270h] [ebp-1A4h]
  float v132; // [esp+274h] [ebp-1A0h]
  float v133; // [esp+278h] [ebp-19Ch]
  int v134[3]; // [esp+27Ch] [ebp-198h] BYREF
  int v135[3]; // [esp+288h] [ebp-18Ch] BYREF
  float v136; // [esp+294h] [ebp-180h]
  float v137; // [esp+298h] [ebp-17Ch]
  float v138; // [esp+29Ch] [ebp-178h]
  float v139; // [esp+2A0h] [ebp-174h]
  float v140; // [esp+2A4h] [ebp-170h]
  float v141; // [esp+2A8h] [ebp-16Ch]
  float v142; // [esp+2ACh] [ebp-168h]
  float v143; // [esp+2B0h] [ebp-164h]
  float v144; // [esp+2B4h] [ebp-160h]
  float v145; // [esp+2B8h] [ebp-15Ch] BYREF
  float v146; // [esp+2BCh] [ebp-158h]
  float v147; // [esp+2C0h] [ebp-154h]
  float v148; // [esp+2C4h] [ebp-150h]
  float v149; // [esp+2C8h] [ebp-14Ch]
  float v150; // [esp+2CCh] [ebp-148h]
  float v151; // [esp+2D0h] [ebp-144h]
  float v152; // [esp+2D4h] [ebp-140h]
  float v153; // [esp+2D8h] [ebp-13Ch]
  int v154[3]; // [esp+2DCh] [ebp-138h] BYREF
  float v155; // [esp+2E8h] [ebp-12Ch]
  float v156; // [esp+2ECh] [ebp-128h]
  float v157; // [esp+2F0h] [ebp-124h]
  float v158; // [esp+2F4h] [ebp-120h]
  float v159; // [esp+2F8h] [ebp-11Ch]
  float v160; // [esp+2FCh] [ebp-118h]
  float v161; // [esp+300h] [ebp-114h]
  float v162; // [esp+304h] [ebp-110h]
  float v163; // [esp+308h] [ebp-10Ch]
  int v164[5]; // [esp+30Ch] [ebp-108h] BYREF
  int v165; // [esp+320h] [ebp-F4h]
  int v166; // [esp+324h] [ebp-F0h]
  unsigned __int8 *v167; // [esp+328h] [ebp-ECh]
  float v168; // [esp+32Ch] [ebp-E8h]
  int v169; // [esp+330h] [ebp-E4h] BYREF
  int v170; // [esp+334h] [ebp-E0h]
  int v171; // [esp+338h] [ebp-DCh]
  int v172; // [esp+33Ch] [ebp-D8h]
  int v173; // [esp+340h] [ebp-D4h]
  int *v174; // [esp+344h] [ebp-D0h]
  float v175; // [esp+348h] [ebp-CCh]
  unsigned int v176; // [esp+34Ch] [ebp-C8h]
  int v177; // [esp+350h] [ebp-C4h]
  float v178; // [esp+354h] [ebp-C0h]
  float v179; // [esp+358h] [ebp-BCh]
  int *v180; // [esp+35Ch] [ebp-B8h]
  int v181; // [esp+360h] [ebp-B4h]
  float v182; // [esp+364h] [ebp-B0h]
  int *v183; // [esp+368h] [ebp-ACh]
  float v184; // [esp+36Ch] [ebp-A8h]
  int *v185; // [esp+370h] [ebp-A4h]
  int *v186; // [esp+374h] [ebp-A0h]
  int *v187; // [esp+378h] [ebp-9Ch]
  unsigned int v188; // [esp+37Ch] [ebp-98h] BYREF
  unsigned int v189; // [esp+380h] [ebp-94h]
  float v190; // [esp+384h] [ebp-90h]
  int v191; // [esp+388h] [ebp-8Ch]
  float v192; // [esp+38Ch] [ebp-88h]
  float *v193; // [esp+390h] [ebp-84h]
  int *v194; // [esp+394h] [ebp-80h]
  float v195; // [esp+398h] [ebp-7Ch]
  int v196; // [esp+39Ch] [ebp-78h]
  int *v197; // [esp+3A0h] [ebp-74h]
  int v198; // [esp+3A4h] [ebp-70h]
  unsigned int v199; // [esp+3A8h] [ebp-6Ch]
  float v200; // [esp+3ACh] [ebp-68h]
  float v201; // [esp+3B0h] [ebp-64h]
  int v202; // [esp+3B4h] [ebp-60h]
  int v203; // [esp+3B8h] [ebp-5Ch]
  int v204; // [esp+3BCh] [ebp-58h] BYREF
  int v205; // [esp+3C0h] [ebp-54h]
  __int16 i1; // [esp+3C4h] [ebp-50h]
  int v207; // [esp+3C8h] [ebp-4Ch]
  __int16 nn; // [esp+3CCh] [ebp-48h]
  int v209; // [esp+3D0h] [ebp-44h]
  int v210; // [esp+3D4h] [ebp-40h]
  int v211; // [esp+3D8h] [ebp-3Ch]
  int v212; // [esp+3DCh] [ebp-38h]
  __int16 m; // [esp+3E0h] [ebp-34h]
  int v214; // [esp+3E4h] [ebp-30h]
  int v215; // [esp+3E8h] [ebp-2Ch]
  __int16 v216; // [esp+3ECh] [ebp-28h]
  __int16 v217; // [esp+3F0h] [ebp-24h]
  __int16 jj; // [esp+3F4h] [ebp-20h]
  __int16 v219; // [esp+3F8h] [ebp-1Ch]
  __int16 k; // [esp+3FCh] [ebp-18h]
  int v221; // [esp+400h] [ebp-14h]
  unsigned __int8 i; // [esp+404h] [ebp-10h]

  v167 = a1;
  v207 = a3;
  sub_45958(a1, 2, (__int16 *)a11, &v169);
  sub_45958(v167, 3, (__int16 *)a11, &v204);
  sub_1DA4C(a11, *v167, 0, 0xFFFFFFFF);
  sub_1DB70(a11, *v167, 0, 0xFFFFFFFF);
  v219 = 1;
  if ( ((1 << byte_104BEA) & (*(unsigned __int8 *)(a11 + 0x14) | *(unsigned __int8 *)(a11 + 0x15))) == 0 )
  {
    v219 = 1;
  }
  if ( *v167 == (_BYTE)byte_104BEA && !dword_A0D00 )
  {
    v219 = 1;
  }
  v13 = 0;
  for ( i = 0; v13 < a2; ++v13 )
  {
    v14 = (_BYTE *)(a4 + 2 * v13);
    if ( (*(_WORD *)v14 & 0x20) != 0 )
    {
      i |= 1 << (*v14 & 7);
    }
  }
  v15 = sub_1D794((__int16 *)a11, v89);
  v170 = 0;
  for ( j = 0; j < v15; ++j )
  {
    v17 = v89[j];
    if ( *(_BYTE *)(v17 + 0x58) == 4 && ((1 << *(_WORD *)(v17 + 0x56)) & i) != 0 )
    {
      v170 = 0xFFFFFFFF;
      break;
    }
  }
  if ( !v170 && (_BYTE)byte_104BEA == *v167 && !dword_A0D00 )
  {
    return 2;
  }
  if ( (_WORD)v207 )
  {
    v18 = 0;
    v171 = 0;
    v181 = 0;
    if ( v219 == 1 )
    {
      if ( v170 )
      {
        v105 = 0;
        v106 = 0;
        v172 = 0;
        v107 = 0;
        v173 = 0;
        v108 = 0;
        v109 = 0;
        v110 = 0;
        LOWORD(v210) = 0;
        if ( (__int16)v207 > 0 )
        {
          do
          {
            v19 = *(_BYTE *)(*(_DWORD *)(a6 + 4 * (__int16)v210) + 0x58);
            v191 = *(_DWORD *)(a6 + 4 * (__int16)v210);
            if ( v19 == 4 )
            {
              for ( k = 0; k < v15; ++k )
              {
                v176 = 4 * k;
                v177 = v89[v176 / 4];
                if ( (i & (1 << *(_WORD *)(v177 + 0x56))) != 0 )
                {
                  v101 = *(_BYTE *)(v177 + 0x62);
                  v102 = *(_DWORD *)(v177 + 0x63);
                  v103 = *(_BYTE *)(v177 + 0x67);
                  v104 = *(_DWORD *)(v177 + 0x68);
                  v105 = *(_DWORD *)(v177 + 0x6C);
                  v106 = *(_DWORD *)(v177 + 0x70);
                  v107 = *(_DWORD *)(v177 + 0x74);
                  v108 = *(_DWORD *)(v177 + 0x78);
                  v109 = *(_DWORD *)(v177 + 0x7C);
                  v110 = *(_DWORD *)(v177 + 0x80);
                  v111 = *(_DWORD *)(v177 + 0x84);
                  if ( sub_4A480(v177, 3u, v191) )
                  {
                    sub_49A40(v191, 0xFFFFFFFF);
                    v173 = v191;
                    v172 = v89[v176 / 4];
                  }
                  v20 = v89[k];
                  *(_BYTE *)(v20 + 0x62) = v101;
                  *(_DWORD *)(v20 + 0x63) = v102;
                  *(_BYTE *)(v20 + 0x67) = v103;
                  v20 += 0x62;
                  *(_DWORD *)(v20 + 6) = v104;
                  *(_DWORD *)(v20 + 0xA) = v105;
                  *(_DWORD *)(v20 + 0xE) = v106;
                  *(_DWORD *)(v20 + 0x12) = v107;
                  *(_DWORD *)(v20 + 0x16) = v108;
                  *(_DWORD *)(v20 + 0x1A) = v109;
                  *(_DWORD *)(v20 + 0x1E) = v110;
                  *(_DWORD *)(v20 + 0x22) = v111;
                }
              }
              if ( v173 != v191 )
              {
                sub_49A40(v191, 0);
              }
            }
            LOWORD(v210) = v210 + 1;
          }
          while ( (__int16)v210 < (__int16)v207 );
        }
        LOWORD(v205) = 0;
        if ( (__int16)v207 > 0 )
        {
          do
          {
            v21 = *(_DWORD *)(a6 + 4 * (__int16)v205);
            v22 = *(_DWORD *)(v21 + 0x28);
            v203 = v21;
            if ( (!v22 || sub_4A534(v21, 0x49)) && *(_BYTE *)(v203 + 0x58) == 4 && *(_DWORD *)(v203 + 0x88) )
            {
              if ( sub_4A564(v203) )
              {
                for ( m = 0; m < v15; ++m )
                {
                  v23 = v89[m];
                  if ( (i & (1 << *(_WORD *)(v23 + 0x56))) != 0 )
                  {
                    if ( sub_4A480(v203, 3u, v23) )
                    {
                      v24 = v203;
                      *(_BYTE *)a12 = 3;
                      *(_DWORD *)(a12 + 1) = v24;
                      return 0xFFFFFFFF;
                    }
                    v181 = v203;
                  }
                }
              }
              else
              {
                v171 = v203;
              }
            }
            LOWORD(v205) = v205 + 1;
          }
          while ( (__int16)v205 < (__int16)v207 );
        }
        v26 = v181;
        if ( v181 )
        {
          v27 = sub_4937C(v181, 0x39);
          if ( v27 != 0xFFFFFFFF && (*(_WORD *)(v26 + 0x9C) & 4) == 0 && *(int *)(v26 + 0x88) > 0xC )
          {
            *(_BYTE *)(v26 + 0x62) = 1;
            *(_BYTE *)(v26 + 0x67) = 5;
            *(_DWORD *)(v26 + 0x63) = 7 * v27 + v26 + 0xAB;
            *(_BYTE *)a12 = 3;
            *(_DWORD *)(a12 + 1) = v26;
            sub_49B3C(v26, 0);
            if ( (*(_BYTE *)(v26 + 0x84) & 1) != 0 )
            {
              return 0xFFFFFFFF;
            }
          }
        }
        if ( v171 )
        {
          v28 = sub_4937C(v171, 0x41);
          if ( v28 != 0xFFFFFFFF )
          {
            v29 = v171;
            if ( *(int *)(v171 + 0x88) > 0xD )
            {
              *(_BYTE *)(v171 + 0x62) = 1;
              *(_BYTE *)(v29 + 0x67) = 5;
              v30 = v171;
              *(_DWORD *)(v171 + 0x63) = 7 * v28 + v171 + 0xAB;
              *(_BYTE *)a12 = 3;
              *(_DWORD *)(a12 + 1) = v30;
              sub_49B3C(v171, 0);
              if ( (*(_BYTE *)(v171 + 0x84) & 1) != 0 )
              {
                return 0xFFFFFFFF;
              }
            }
          }
        }
        v202 = v173;
        if ( v173 && sub_43184((int)v167, v173, v172) )
        {
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v173;
          return 0xFFFFFFFF;
        }
        v31 = 0;
        for ( n = 0; n < (__int16)v207; ++n )
        {
          v33 = *(_DWORD *)(a6 + 4 * n);
          if ( (!*(_DWORD *)(v33 + 0x28) || sub_4A534(*(_DWORD *)(a6 + 4 * n), 0x49))
            && *(_BYTE *)(v33 + 0x58) == 4
            && *(_DWORD *)(v33 + 0x88) * *(_DWORD *)v33 * *(_DWORD *)(v33 + 0x8C) > v31 )
          {
            v31 = *(_DWORD *)(v33 + 0x88) * *(_DWORD *)v33 * *(_DWORD *)(v33 + 0x8C);
            v202 = v33;
          }
        }
        if ( !v202 )
        {
          return 0;
        }
        if ( !a7 || (v148 = 0.0, v149 = 0.0, v150 = 0.0, LOWORD(v215) = 0, a7 <= 0) )
        {
LABEL_101:
          v39 = 0;
          v145 = 0.0;
          v146 = 0.0;
          v147 = 0.0;
          v175 = 99999.0;
          v40 = (float *)(v202 + 0x9E);
          for ( ii = 0; ii < v15; ++ii )
          {
            v42 = v89[ii];
            if ( (i & (1 << *(_WORD *)(v42 + 0x56))) != 0 )
            {
              v183 = v135;
              v151 = 0.0;
              v152 = 0.0;
              v153 = 0.0;
              v151 = *(float *)(v42 + 0x9E) - *v40;
              v152 = *(float *)(v42 + 0xA2) - v40[1];
              v153 = *(float *)(v42 + 0xA6) - v40[2];
              *(float *)v135 = v151;
              *(float *)&v135[1] = v152;
              *(float *)&v135[2] = v153;
              v145 = v151;
              v146 = v152;
              v147 = v153;
              v184 = sqrt(v152 * v152 + v151 * v151 + v153 * v153);
              v43 = *(_BYTE *)(v42 + 0x58);
              v192 = v184;
              if ( v43 != 4 )
              {
                v192 = v184 + flt_92338;
              }
              if ( v192 < (double)v175 && v192 > (double)flt_9233C )
              {
                v39 = v42;
                v175 = v192;
              }
            }
          }
          v44 = v202;
          if ( v202 && v39 )
          {
            v185 = v122;
            v155 = 0.0;
            v156 = 0.0;
            v157 = 0.0;
            v155 = *v40 - *(float *)(v39 + 0x9E);
            v156 = v40[1] - *(float *)(v39 + 0xA2);
            v45 = v40[2] - *(float *)(v39 + 0xA6);
            *(float *)v122 = v155;
            v157 = v45;
            *(float *)&v122[1] = v156;
            *(float *)&v122[2] = v157;
            v158 = 0.0;
            v145 = v155;
            v159 = 0.0;
            v146 = v156;
            v160 = 0.0;
            v147 = v157;
            v196 = rand() % 0xC8 + 0x64;
            v158 = (float)v196;
            v196 = rand() % 0xC8 + 0x64;
            v159 = (float)v196;
            v196 = rand() % 0xC8 + 0x64;
            v160 = (float)v196;
            v186 = v164;
            v116 = v145 + v158;
            *(float *)v164 = v116;
            *(float *)&v117 = v146 + v159;
            v164[1] = v117;
            *(float *)&v118 = v147 + v160;
            v164[2] = v118;
            v145 = v116;
            v146 = *(float *)&v117;
            v147 = *(float *)&v118;
            v196 = sub_49B68(v44, 1);
            v195 = (float)v196;
            if ( v195 < 0.0 )
            {
              v196 = sub_49B68(v39, 1);
              v195 = (double)v196 * dbl_9232C;
            }
            if ( v195 >= 0.0 )
            {
              sub_53054(&v145, v195);
            }
            v187 = v154;
            v128 = 0.0;
            v129 = 0.0;
            v130 = 0.0;
            v128 = v145 + *(float *)(v39 + 0x9E);
            v129 = v146 + *(float *)(v39 + 0xA2);
            v46 = v147 + *(float *)(v39 + 0xA6);
            *(float *)v154 = v128;
            v130 = v46;
            *(float *)&v154[1] = v129;
            *(float *)&v154[2] = v130;
            v145 = v128;
            v146 = v129;
            v147 = v130;
            v47 = v202;
            *(_BYTE *)a12 = 3;
            *(_DWORD *)(a12 + 1) = v47;
            *(_BYTE *)(v47 + 0x62) = 0;
            *(_BYTE *)(v47 + 0x67) = 3;
            *(_DWORD *)(v47 + 0x63) = 0;
            *(_DWORD *)(v47 + 0x68) = 0;
            *(float *)(v47 + 0x6C) = v145;
            *(float *)(v47 + 0x70) = v146;
            *(float *)(v47 + 0x74) = v147;
            return 0xFFFFFFFF;
          }
          return 0;
        }
LABEL_79:
        v34 = *(_DWORD *)(a8 + 4 * (__int16)v215);
        for ( jj = 0; ; ++jj )
        {
          if ( jj >= (int)*(unsigned __int16 *)(v34 + 0x1A) )
          {
            LOWORD(v215) = v215 + 1;
            if ( (__int16)v215 >= a7 )
            {
              goto LABEL_101;
            }
            goto LABEL_79;
          }
          v35 = 4 * jj + *(_DWORD *)(v34 + 0x10);
          v36 = *(_BYTE *)(v35 + 1);
          if ( v36 != (char)0xFF
            && (*(_WORD *)(v35 + 2) & 1) != 0
            && (word_103FA2[0x14 * *(unsigned __int8 *)(v35 + 1)] & 4) != 0
            && (v36 != 0x11 || *(_BYTE *)(v34 + 0x58)) )
          {
            v37 = 0;
            v178 = 99999.0;
            while ( v37 < v15 )
            {
              v38 = v89[v37];
              if ( (i & (1 << *(_WORD *)(v38 + 0x56))) != 0 )
              {
                v180 = v112;
                v131 = 0.0;
                v132 = 0.0;
                v133 = 0.0;
                v131 = *(float *)v34 - *(float *)(v38 + 0x9E);
                v132 = *(float *)(v34 + 4) - *(float *)(v38 + 0xA2);
                v133 = *(float *)(v34 + 8) - *(float *)(v38 + 0xA6);
                *(float *)v112 = v131;
                *(float *)&v112[1] = v132;
                *(float *)&v112[2] = v133;
                v148 = v131;
                v149 = v132;
                v150 = v133;
                v182 = sqrt(v132 * v132 + v131 * v131 + v133 * v133);
                v179 = v182;
                if ( *(_BYTE *)(v38 + 0x58) != 4 )
                {
                  v179 = v182 + flt_92338;
                }
                if ( v179 < (double)v178 )
                {
                  a5 = v38;
                  v178 = v179;
                }
              }
              ++v37;
            }
            if ( *(_BYTE *)(*(_DWORD *)(v34 + 0x10) + 4 * jj + 1) != 0x11 || v178 >= (double)flt_92334 )
            {
              if ( !a5 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x13E7);
              }
              *(_DWORD *)(v34 + 0x6B) = 4 * jj + *(_DWORD *)(v34 + 0x10);
              *(_DWORD *)(v34 + 0x6F) = a5;
              sub_3676C(v34, 0);
              if ( (*(_BYTE *)(v34 + 0x73) & 1) != 0 )
              {
                break;
              }
            }
          }
        }
        *(_BYTE *)a12 = 2;
        *(_DWORD *)(a12 + 1) = v34;
        return 0xFFFFFFFF;
      }
      else
      {
        v48 = *(_WORD *)(a11 + 0x5A);
        LOWORD(v212) = 0;
        if ( v48 <= 0 )
        {
          return 0;
        }
        while ( 1 )
        {
          v50 = *(_DWORD *)(a11 + 4 * (__int16)v212 + 0x46);
          v51 = *(unsigned __int8 *)(v50 + 0x57);
          if ( v51 != 0xFF
            && (_BYTE)v51 != *v167
            && (v167[v51 + 0x1C0] == 2
             || (_BYTE)byte_104BEA == *(_BYTE *)(v50 + 0x57)
             && ((1 << *v167) & (unsigned __int8)byte_D8460[*(__int16 *)(a11 + 4)]) != 0) )
          {
            v52 = *(_DWORD *)(a11 + 4 * (__int16)v212 + 0x46);
            if ( !v50 )
            {
              return 0;
            }
            v53 = v167;
            for ( kk = *(_WORD *)(v50 + 0x18); kk < (int)*(unsigned __int16 *)(v52 + 0x1A); ++kk )
            {
              if ( *(_BYTE *)(4 * kk + *(_DWORD *)(v52 + 0x10) + 1) == 0x17
                && *((_WORD *)sub_35A70(v52, kk) + 0x2B) == *v53 )
              {
                v55 = sub_35A70(v52, kk);
                if ( *((_WORD *)v55 + 0x2B) != *v53 )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1468);
                }
                sub_36CD4(v52, kk, (int *)&v188);
                if ( v55 != sub_35A70(v52, kk) )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x146C);
                }
                v188 = sub_35C38(v52, (int)v55);
                if ( v188 != 0xFFFFFFFF )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x146E);
                }
                return 0xFFFFFFFF;
              }
            }
            v189 = sub_361B8(v52);
            if ( !v189 )
            {
              LOWORD(v211) = 0;
              if ( (__int16)v207 > 0 )
              {
                do
                {
                  if ( v18 )
                  {
                    break;
                  }
                  v56 = (int *)(a6 + 4 * (__int16)v211);
                  v57 = *v56;
                  if ( *(_BYTE *)(*v56 + 0x58) == 4 )
                  {
                    for ( mm = 0; mm < *(_DWORD *)(v57 + 0x15A); ++mm )
                    {
                      if ( *(_BYTE *)(v57 + 7 * mm + 0xAB) == 0x49 )
                      {
                        v18 = v57;
                        break;
                      }
                    }
                  }
                  LOWORD(v211) = v211 + 1;
                }
                while ( (__int16)v211 < (__int16)v207 );
              }
              if ( v18 )
              {
                *(_BYTE *)a12 = 3;
                *(_DWORD *)(a12 + 1) = v18;
                *(_BYTE *)(v18 + 0x62) = 0;
                *(_DWORD *)(v18 + 0x63) = 0;
                *(_BYTE *)(v18 + 0x67) = 1;
                *(_DWORD *)(v18 + 0x68) = v52;
                return 0xFFFFFFFF;
              }
              v59 = 0;
              if ( (__int16)v207 > 0 )
              {
                while ( 1 )
                {
                  v60 = (int *)(a6 + 4 * v59);
                  v61 = *v60;
                  if ( !*(_DWORD *)(*v60 + 0x28) || sub_4A534(*v60, 0x49) )
                  {
                    v62 = 0;
                    if ( *(_BYTE *)(v61 + 0x5D) == 1 && *(_DWORD *)(v61 + 0x5E) == a11 )
                    {
                      v62 = 0xFFFFFFFF;
                    }
                    if ( *(_BYTE *)(v61 + 0x58) == 4 && !v62 && sub_4A534(v61, 0x46) )
                    {
                      break;
                    }
                  }
                  if ( ++v59 >= (__int16)v207 )
                  {
                    goto LABEL_162;
                  }
                }
                if ( sub_4A480(v61, 1u, v52) )
                {
                  v18 = v61;
                }
              }
LABEL_162:
              if ( v18 )
              {
                *(_BYTE *)a12 = 3;
                *(_DWORD *)(a12 + 1) = v18;
                return 0xFFFFFFFF;
              }
            }
            v63 = 0;
            if ( *(unsigned __int16 *)(v52 + 0x1A) - *(unsigned __int16 *)(v52 + 0x18) > *(unsigned __int16 *)(v52 + 0x1E) )
            {
              v63 = 0xFFFFFFFF;
            }
            if ( v189 == 0xFFFFFFFF || v63 == 0xFFFFFFFF )
            {
              break;
            }
          }
          v49 = *(_WORD *)(a11 + 0x5A);
          LOWORD(v212) = v212 + 1;
          if ( (__int16)v212 >= v49 )
          {
            return 0;
          }
        }
        v64 = 0;
        LOWORD(v214) = 0;
        if ( (__int16)v207 > 0 )
        {
          do
          {
            if ( v18 )
            {
              break;
            }
            v65 = *(_DWORD *)(a6 + 4 * (__int16)v214);
            if ( (!*(_DWORD *)(v65 + 0x28) || sub_4A534(*(_DWORD *)(a6 + 4 * (__int16)v214), 0x49))
              && *(_BYTE *)(v65 + 0x58) == 4
              && (sub_4A564(v65) || sub_4A534(v65, 0x46)) )
            {
              v64 = v65;
              if ( sub_4A480(v65, 1u, v52) )
              {
                v18 = v65;
              }
            }
            LOWORD(v214) = v214 + 1;
          }
          while ( (__int16)v214 < (__int16)v207 );
        }
        if ( v18 )
        {
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v18;
          return 0xFFFFFFFF;
        }
        if ( !v64 )
        {
          return v18;
        }
        v136 = 0.0;
        v137 = 0.0;
        v138 = 0.0;
        v193 = &v113;
        v136 = *(float *)(v64 + 0x9E) - *(float *)v52;
        v137 = *(float *)(v64 + 0xA2) - *(float *)(v52 + 4);
        v138 = *(float *)(v64 + 0xA6) - *(float *)(v52 + 8);
        v113 = v136;
        v123 = 0.0;
        v124 = 0.0;
        v114 = v137;
        v125 = 0.0;
        v115 = v138;
        v196 = rand() % 0x64 + 0x14;
        v123 = (float)v196;
        v196 = rand() % 0x64 + 0x14;
        v124 = (float)v196;
        v196 = rand() % 0x64 + 0x14;
        v125 = (float)v196;
        v194 = v126;
        v119 = v113 + v123;
        *(float *)v126 = v119;
        *(float *)&v120 = v114 + v124;
        v126[1] = v120;
        *(float *)&v121 = v115 + v125;
        v126[2] = v121;
        v113 = v119;
        v114 = *(float *)&v120;
        v115 = *(float *)&v121;
        v196 = sub_49B68(v64, 2);
        v190 = (float)v196;
        if ( v190 < 0.0 )
        {
          v196 = sub_35ED8(v52);
          v190 = (double)v196 * dbl_9232C;
        }
        if ( v190 >= 0.0 )
        {
          sub_53054(&v113, v190);
        }
        v197 = v134;
        v142 = 0.0;
        v143 = 0.0;
        v144 = 0.0;
        v142 = v113 + *(float *)v52;
        v143 = v114 + *(float *)(v52 + 4);
        v66 = v115 + *(float *)(v52 + 8);
        *(float *)v134 = v142;
        v144 = v66;
        *(float *)&v134[1] = v143;
        *(float *)&v134[2] = v144;
        v113 = v142;
        v114 = v143;
        v115 = v144;
        *(_BYTE *)a12 = 3;
        *(_DWORD *)(a12 + 1) = v64;
        *(_BYTE *)(v64 + 0x62) = 0;
        *(_BYTE *)(v64 + 0x67) = 3;
        *(_DWORD *)(v64 + 0x63) = 0;
        *(_DWORD *)(v64 + 0x68) = 0;
        *(float *)(v64 + 0x6C) = v113;
        *(float *)(v64 + 0x70) = v114;
        *(float *)(v64 + 0x74) = v115;
        return 0xFFFFFFFF;
      }
    }
    else
    {
      v94 = 0;
      v95 = 0;
      v96 = 0;
      v97 = 0;
      v98 = 0;
      v99 = 0;
      LOWORD(v221) = 0;
      if ( (__int16)v207 > 0 )
      {
        do
        {
          if ( v18 )
          {
            break;
          }
          v67 = *(_BYTE *)(*(_DWORD *)(a6 + 4 * (__int16)v221) + 0x58);
          v166 = *(_DWORD *)(a6 + 4 * (__int16)v221);
          if ( v67 == 4 )
          {
            for ( nn = 0; nn < v15 && !v18; ++nn )
            {
              v68 = v89[nn];
              v199 = 4 * nn;
              if ( (i & (1 << *(_WORD *)(v68 + 0x56))) != 0 )
              {
                v90 = *(_BYTE *)(v68 + 0x62);
                v91 = *(_DWORD *)(v68 + 0x63);
                v92 = *(_BYTE *)(v68 + 0x67);
                v93 = *(_DWORD *)(v68 + 0x68);
                v94 = *(_DWORD *)(v68 + 0x6C);
                v95 = *(_DWORD *)(v68 + 0x70);
                v96 = *(_DWORD *)(v68 + 0x74);
                v97 = *(_DWORD *)(v68 + 0x78);
                v98 = *(_DWORD *)(v68 + 0x7C);
                v99 = *(_DWORD *)(v68 + 0x80);
                v100 = *(_DWORD *)(v68 + 0x84);
                if ( sub_4A480(v68, 3u, v166) )
                {
                  v18 = v166;
                  v198 = v89[v199 / 4];
                }
                v69 = v89[nn];
                *(_BYTE *)(v69 + 0x62) = v90;
                *(_DWORD *)(v69 + 0x63) = v91;
                *(_BYTE *)(v69 + 0x67) = v92;
                v69 += 0x62;
                *(_DWORD *)(v69 + 6) = v93;
                *(_DWORD *)(v69 + 0xA) = v94;
                *(_DWORD *)(v69 + 0xE) = v95;
                *(_DWORD *)(v69 + 0x12) = v96;
                *(_DWORD *)(v69 + 0x16) = v97;
                *(_DWORD *)(v69 + 0x1A) = v98;
                *(_DWORD *)(v69 + 0x1E) = v99;
                *(_DWORD *)(v69 + 0x22) = v100;
              }
            }
          }
          LOWORD(v221) = v221 + 1;
        }
        while ( (__int16)v221 < (__int16)v207 );
      }
      if ( v18 )
      {
        v70 = v198;
        sub_49A40(v18, 0xFFFFFFFF);
        if ( sub_43184((int)v167, v18, v70) )
        {
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v18;
          return 0xFFFFFFFF;
        }
      }
      LOWORD(v209) = 0;
      if ( (__int16)v207 > 0 )
      {
        do
        {
          if ( v18 )
          {
            break;
          }
          v71 = *(_DWORD *)(a6 + 4 * (__int16)v209);
          if ( *(_BYTE *)(v71 + 0x58) == 4 && *(_DWORD *)(v71 + 0x88) )
          {
            if ( sub_4A564(*(_DWORD *)(a6 + 4 * (__int16)v209)) )
            {
              for ( i1 = 0; i1 < v15; ++i1 )
              {
                v72 = v89[i1];
                if ( (i & (1 << *(_WORD *)(v72 + 0x56))) != 0 )
                {
                  if ( sub_4A480(v71, 3u, v72) )
                  {
                    *(_BYTE *)a12 = 3;
                    *(_DWORD *)(a12 + 1) = v71;
                    return 0xFFFFFFFF;
                  }
                  v181 = v71;
                }
              }
            }
            else
            {
              v171 = v71;
            }
          }
          LOWORD(v209) = v209 + 1;
        }
        while ( (__int16)v209 < (__int16)v207 );
      }
      v73 = v181;
      if ( v181 )
      {
        v74 = sub_4937C(v181, 0x39);
        if ( v74 != 0xFFFFFFFF && (*(_WORD *)(v73 + 0x9C) & 4) == 0 && *(int *)(v73 + 0x88) > 0xC )
        {
          *(_BYTE *)(v73 + 0x62) = 1;
          *(_BYTE *)(v73 + 0x67) = 5;
          *(_DWORD *)(v73 + 0x63) = 7 * v74 + v73 + 0xAB;
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v73;
          sub_49B3C(v73, 0);
          if ( (*(_BYTE *)(v73 + 0x84) & 1) != 0 )
          {
            return 0xFFFFFFFF;
          }
        }
      }
      if ( v171 )
      {
        v75 = sub_4937C(v171, 0x41);
        if ( v75 != 0xFFFFFFFF )
        {
          v76 = v171;
          if ( *(int *)(v171 + 0x88) > 0xD )
          {
            *(_BYTE *)(v171 + 0x62) = 1;
            *(_BYTE *)(v76 + 0x67) = 5;
            *(_DWORD *)(v171 + 0x63) = 7 * v75 + v171 + 0xAB;
            v77 = v171;
            *(_BYTE *)a12 = 3;
            *(_DWORD *)(a12 + 1) = v77;
            sub_49B3C(v171, 0);
            if ( (*(_BYTE *)(v171 + 0x84) & 1) != 0 )
            {
              return 0xFFFFFFFF;
            }
          }
        }
      }
      v78 = *(int **)(a11 + 0x2C);
      if ( *v78 == a11 )
      {
        v79 = v78[1];
      }
      else
      {
        v79 = *v78;
      }
      v80 = v79;
      v81 = 0;
      if ( (__int16)v207 > 0 )
      {
        while ( 1 )
        {
          v18 = *(_DWORD *)(a6 + 4 * v81);
          v82 = *(_BYTE *)(v18 + 0x58);
          if ( v82 == 3 )
          {
            break;
          }
          if ( v82 != 4 )
          {
            ++v81;
            v18 = 0;
            if ( v81 < (__int16)v207 )
            {
              continue;
            }
          }
          goto LABEL_240;
        }
        sub_35C38(*(_DWORD *)(v18 + 0x59), *(_DWORD *)(a6 + 4 * v81));
        if ( *(_BYTE *)(v18 + 0x58) != 4 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x15E4);
        }
      }
LABEL_240:
      if ( !v18 )
      {
        return v18;
      }
      if ( *(_BYTE *)(v18 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x15EF);
      }
      *(_BYTE *)(v18 + 0x5D) = 1;
      *(_DWORD *)(v18 + 0x5E) = v80;
      return 2;
    }
  }
  else
  {
    if ( !a7 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x15FD);
    }
    if ( !v170 )
    {
      return 0;
    }
    v161 = 0.0;
    v162 = 0.0;
    v163 = 0.0;
    v217 = 0;
    if ( a7 > 0 )
    {
      while ( 2 )
      {
        v216 = 0;
        v83 = *(_DWORD *)(a8 + 4 * v217);
        while ( v216 < (int)*(unsigned __int16 *)(v83 + 0x1A) )
        {
          v84 = 4 * v216 + *(_DWORD *)(v83 + 0x10);
          if ( *(_BYTE *)(v84 + 1) != 0xFF
            && (*(_WORD *)(v84 + 2) & 1) != 0
            && (word_103FA2[0x14 * *(unsigned __int8 *)(v84 + 1)] & 4) != 0
            && (*(_BYTE *)(v84 + 1) != 0x11 || *(_BYTE *)(v83 + 0x58)) )
          {
            v200 = 99999.0;
            for ( i2 = 0; i2 < v15; ++i2 )
            {
              v86 = v89[i2];
              if ( (i & (1 << *(_WORD *)(v86 + 0x56))) != 0 )
              {
                v174 = v127;
                v139 = 0.0;
                v140 = 0.0;
                v141 = 0.0;
                v139 = *(float *)v83 - *(float *)(v86 + 0x9E);
                v140 = *(float *)(v83 + 4) - *(float *)(v86 + 0xA2);
                v141 = *(float *)(v83 + 8) - *(float *)(v86 + 0xA6);
                *(float *)v127 = v139;
                *(float *)&v127[1] = v140;
                *(float *)&v127[2] = v141;
                v161 = v139;
                v162 = v140;
                v163 = v141;
                v168 = sqrt(v140 * v140 + v139 * v139 + v141 * v141);
                v87 = *(_BYTE *)(v86 + 0x58);
                v201 = v168;
                if ( v87 != 4 )
                {
                  v201 = v168 + flt_92338;
                }
                if ( v201 < (double)v200 )
                {
                  v165 = v86;
                  v200 = v201;
                }
              }
            }
            if ( *(_BYTE *)(*(_DWORD *)(v83 + 0x10) + 4 * v216 + 1) != 0x11 || v200 >= (double)flt_92334 )
            {
              if ( !v165 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1633);
              }
              v88 = v165;
              *(_DWORD *)(v83 + 0x6B) = 4 * v216 + *(_DWORD *)(v83 + 0x10);
              *(_DWORD *)(v83 + 0x6F) = v88;
              sub_3676C(v83, 0);
              if ( (*(_BYTE *)(v83 + 0x73) & 1) != 0 )
              {
                *(_BYTE *)a12 = 2;
                *(_DWORD *)(a12 + 1) = v83;
                return 0xFFFFFFFF;
              }
            }
          }
          ++v216;
        }
        if ( ++v217 < a7 )
        {
          continue;
        }
        break;
      }
      return 0;
    }
    else
    {
      return 0;
    }
  }
}
// 42437: conditional instruction was optimized away because esi.4==0
// 9232C: using guessed type double dbl_9232C;
// 92334: using guessed type float flt_92334;
// 92338: using guessed type float flt_92338;
// 9233C: using guessed type float flt_9233C;
// A0D00: using guessed type int dword_A0D00;
// 103FA2: using guessed type __int16 word_103FA2[];
// 41268: using guessed type int var_40C[107];

//----- (00043184) --------------------------------------------------------
unsigned int __fastcall sub_43184(int a1, int a2, int a3)
{
  __int16 v4; // di
  __int16 i; // bx
  int v6; // esi
  char v8[12]; // [esp+0h] [ebp-2Ch] BYREF
  _DWORD v9[2]; // [esp+Ch] [ebp-20h]
  __int16 v10; // [esp+14h] [ebp-18h]
  int v11; // [esp+18h] [ebp-14h]

  strcpy(v8, "E?2.-&%#!");
  v9[0] = unk_9696C;
  v9[1] = *((_DWORD *)&unk_9696C + 1);
  v10 = *((_WORD *)&unk_9696C + 4);
  if ( sub_4A8FC(a2) / 2 < *(_DWORD *)(a2 + 0x88) )
  {
    *(_BYTE *)(a2 + 0x62) = 1;
    v4 = 0;
    v11 = a2 + 0xAB;
    while ( v4 < *(_DWORD *)(a2 + 0x15A) )
    {
      if ( byte_107052[0x6A * *(char *)(a2 + 7 * v4 + 0xAB)] == 5 )
      {
        for ( i = 0; i < 0xA; ++i )
        {
          v6 = 7 * v4;
          if ( *(_BYTE *)(a2 + v6 + 0xAB) == v8[i] )
          {
            *(_DWORD *)(a2 + 0x63) = v6 + v11;
            *(_BYTE *)(a2 + 0x67) = *((_BYTE *)v9 + i);
            *(_DWORD *)(a2 + 0x68) = a3;
            sub_49B3C(a2, 0);
            if ( (*(_BYTE *)(a2 + 0x84) & 1) != 0 )
            {
              return 0xFFFFFFFF;
            }
          }
        }
      }
      ++v4;
    }
  }
  return 0;
}

//----- (00043374) --------------------------------------------------------
char __fastcall sub_43374(unsigned __int8 *a1, int a2)
{
  char v3; // ch
  __int16 i; // bx

  v3 = 0;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    if ( i != *a1
      && *(int *)((char *)&dword_A2F75 + 0x1EE * i) != 0xFFFFFFFF
      && a1[i + 0x1C0] == 2
      && (a2 == 0xFFFFFFFF || sub_43B7C((int)a1, i) > a2) )
    {
      v3 |= 1 << i;
    }
  }
  return v3;
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (000433E0) --------------------------------------------------------
unsigned int __fastcall sub_433E0(int a1, __int16 a2, int a3)
{
  int v6; // eax
  __int16 v7; // dx
  int v8; // ebx
  int v9; // eax
  __int16 v10; // si
  __int16 v11; // bx

  if ( a2 < 0 || a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1705);
  }
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1706);
  }
  v6 = a1 + a2;
  if ( *(_BYTE *)(v6 + 0x1C0) == 2 )
  {
    return 0;
  }
  v7 = 0xA * (byte_A3D20 + 1);
  if ( *(_BYTE *)(v6 + 0x1C0) == 3 )
  {
    v7 = 0x14 * (byte_A3D20 + 1);
  }
  v8 = a2;
  v9 = a1 + 2 * a2;
  v10 = *(_WORD *)(v9 + 0x1B2) - v7;
  *(_WORD *)(v9 + 0x1B2) = v10;
  if ( *(_BYTE *)(a1 + v8 + 0x1C0) == 3 )
  {
    v11 = *(_WORD *)(a1 + 0x1CF);
    if ( v10 > v11 )
    {
      *(_WORD *)(v9 + 0x1B2) = v11 - 0xA;
    }
  }
  byte_D8460[*(__int16 *)(a3 + 4)] |= 1 << *(_BYTE *)a1;
  return 0xFFFFFFFF;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;

//----- (000434E4) --------------------------------------------------------
int __fastcall sub_434E4(char *a1, int a2)
{
  int v3; // eax
  int v4; // ebx
  signed int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  char *v10; // eax
  int i; // edx
  char *v12; // ecx
  int v13; // ebx
  signed int v14; // eax
  int v15; // ebx
  int v16; // eax
  int v17; // edx
  __int16 *v18; // edi
  int v19; // eax
  unsigned int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // esi
  int v24; // eax
  int v25; // edi
  int v26; // eax
  int v27; // edx
  _WORD *v28; // eax
  unsigned __int16 v29; // cx
  int k; // edx
  unsigned __int16 v31; // si
  _BYTE *v32; // ecx
  int m; // ebx
  char *v34; // edi
  int n; // esi
  int *v36; // edx
  int v37; // ecx
  int ii; // eax
  int v39; // edx
  __int16 v40; // bx
  unsigned __int16 v41; // dx
  char *v42; // eax
  int jj; // edx
  char *v44; // edx
  int kk; // edi
  __int16 *v46; // esi
  int mm; // edi
  __int16 *v48; // edx
  int nn; // eax
  int v50; // ecx
  int i1; // edi
  char *v52; // edx
  int v53; // eax
  char *v54; // ecx
  int v55; // ebx
  int v56; // edx
  _WORD *v57; // eax
  int i2; // edx
  char v59; // al
  int v60[107]; // [esp+0h] [ebp-6F8h] BYREF
  int v61[107]; // [esp+1ACh] [ebp-54Ch] BYREF
  int v62[107]; // [esp+358h] [ebp-3A0h] BYREF
  int v63[107]; // [esp+504h] [ebp-1F4h] BYREF
  _DWORD v64[3]; // [esp+6B0h] [ebp-48h]
  int j; // [esp+6BCh] [ebp-3Ch]
  char *v66; // [esp+6C0h] [ebp-38h]
  int v67; // [esp+6C4h] [ebp-34h]
  int v68; // [esp+6C8h] [ebp-30h]
  int v69; // [esp+6CCh] [ebp-2Ch]
  _WORD *v70; // [esp+6D0h] [ebp-28h]
  int v71; // [esp+6D4h] [ebp-24h]
  int v72; // [esp+6D8h] [ebp-20h]
  __int16 *v73; // [esp+6DCh] [ebp-1Ch]
  int v74; // [esp+6E0h] [ebp-18h]

  v3 = a1[0x19D];
  v4 = 0;
  v67 = 0;
  if ( (unsigned __int16)word_968E8[v3] <= *(int *)(a1 + 0x19E) )
  {
    v67 = 0xFFFFFFFF;
    if ( a2 != 1 )
    {
      return v67;
    }
    v59 = a1[0x19D] - 5;
    v68 = 0;
    switch ( v59 )
    {
      case 0:
        v6 = sub_40224((unsigned __int8 *)a1, v62, 0);
        if ( v6 > 0 )
        {
          v7 = 4 * v6;
          v8 = 0;
          do
          {
            v9 = v62[v8 / 4u];
            v8 += 4;
            *(_DWORD *)(v9 + 0x8C) = *(_DWORD *)(v9 + 0x98);
          }
          while ( v8 < v7 );
        }
        break;
      case 1:
        v10 = byte_A2F72;
        for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
        {
          if ( v10 != a1 )
          {
            v12 = &v10[2 * (unsigned __int8)*a1];
            v13 = *(__int16 *)(v10 + 0x1CD) + 0x14;
            if ( *((__int16 *)v12 + 0xD9) < v13 )
            {
              *((_WORD *)v12 + 0xD9) = v13;
            }
          }
          v10 += 0x1EE;
        }
        break;
      case 2:
        v14 = sub_40224((unsigned __int8 *)a1, v60, 0);
        if ( v14 > 0 )
        {
          v15 = 4 * v14;
          v16 = 0;
          do
          {
            v17 = v60[v16 / 4u];
            v16 += 4;
            *(_DWORD *)(v17 + 0x88) *= 2;
          }
          while ( v16 < v15 );
        }
        break;
      case 3:
        v18 = word_A3D21;
        for ( j = 0; word_A62A1 > j; ++j )
        {
          if ( ((1 << *a1) & (unsigned __int8)v18[0xA]) != 0 )
          {
            v19 = sub_1D794(v18, v61);
            if ( v19 > 0 )
            {
              v20 = 0;
              v74 = 4 * v19;
              do
              {
                v21 = v61[v20 / 4];
                v22 = *(__int16 *)(v21 + 0x56);
                if ( v22 != (unsigned __int8)*a1 && *(_BYTE *)(v21 + 0x58) == 4 )
                {
                  v23 = *(int *)((char *)&dword_A2F79 + 0x1EE * v22);
                  sub_1D538((int)v18, v21);
                  sub_1D3E8(v23, v61[v20 / 4], 0);
                }
                v20 += 4;
              }
              while ( (int)v20 < v74 );
            }
          }
          v18 += 0x30;
        }
        break;
      case 4:
        v72 = 0;
        v73 = word_A3D21;
        while ( word_A62A1 > v72 )
        {
          if ( ((1 << *a1) & *((unsigned __int8 *)v73 + 0x15)) != 0 )
          {
            v24 = sub_1D794(v73, v63);
            if ( v24 > 0 )
            {
              v25 = 4 * v24;
              v26 = 0;
              do
              {
                v27 = v63[v26 / 4u];
                if ( *(_WORD *)(v27 + 0x56) != (unsigned __int8)*a1 )
                {
                  *(_DWORD *)(v27 + 0x88) = 0;
                }
                v26 += 4;
              }
              while ( v26 < v25 );
            }
          }
          ++v72;
          v73 += 0x30;
        }
        break;
      case 5:
        v28 = &unk_BB1B3;
        v29 = 0xFFFF;
        v70 = 0;
        for ( k = 0; k < SHIWORD(dword_CA1ED); ++k )
        {
          if ( *((_BYTE *)v28 + 0x57) == *a1 && v28[0xB] != 0xA )
          {
            v31 = v28[0x21];
            if ( v29 > v31 )
            {
              v70 = v28;
              v29 = v31;
            }
          }
          v28 = (_WORD *)((char *)v28 + 0x7B);
        }
        if ( v70 )
        {
          v32 = (_BYTE *)*((_DWORD *)v70 + 4);
          for ( m = 0; m < (unsigned __int16)v70[0xC]; ++m )
          {
            if ( !*v32 || *v32 == 1 )
            {
              v64[0] = unk_96994;
              v64[1] = *((_DWORD *)&unk_96994 + 1);
              v64[2] = *((_DWORD *)&unk_96994 + 2);
              *v32 = v64[rand() % 3];
            }
            v32 += 4;
          }
        }
        break;
      case 6:
        v34 = (char *)&unk_CA1F1;
        for ( n = 0; n < SHIWORD(dword_D35E5); ++n )
        {
          if ( *((__int16 *)v34 + 0x2B) != 0xFFFFFFFF && v34[0x58] == 5 )
          {
            v36 = *(int **)(v34 + 0x59);
            v37 = *v36;
            if ( (*(_DWORD *)(v34 + 0xA2) & 0x7FFFFFFF) == 0 )
            {
              v37 = v36[1];
            }
            sub_1D3E8(v37, (int)v34, 0);
          }
          v34 += 0x162;
        }
        break;
      case 7:
        v69 = 0;
        v71 = 0;
        while ( (unsigned __int16)word_105258 > v69 )
        {
          v39 = 0;
          for ( ii = 0; ii < SHIWORD(dword_A3CF2); ++ii )
          {
            if ( ((1 << ii) & (*(int *)((char *)&dword_10529F + v71) >> 0x18)) != 0 )
            {
              ++v39;
            }
          }
          if ( v39 >= 2 )
          {
            *((_BYTE *)&dword_10529F + v71 + 3) |= 1 << *a1;
            v40 = v69;
            v41 = word_106FA6[(unsigned __int8)*a1];
            if ( v41 == v69 )
            {
              word_106FA6[(unsigned __int8)*a1] = 0xFFFF;
              word_106FB4[(unsigned __int8)*a1] = v40 ^ v41;
            }
          }
          v71 += 0x4B;
          ++v69;
        }
        break;
      case 8:
        v42 = (char *)&unk_BB1B3;
        for ( jj = 0; jj < SHIWORD(dword_CA1ED); ++jj )
        {
          if ( v42[0x57] == *a1 )
          {
            *(_DWORD *)(v42 + 0x62) = 0xFFFFFFFF;
          }
          v42 += 0x7B;
        }
        v68 = *(_DWORD *)(a1 + 0x19E) - (unsigned __int16)word_968E8[a1[0x19D]];
        break;
      case 9:
        v44 = (char *)&unk_BB1B3;
        for ( kk = 0; kk < SHIWORD(dword_CA1ED); ++kk )
        {
          if ( v44[0x57] == *a1 )
          {
            *(_WORD *)(v44 + 0x55) += 2;
            sub_34E70((int)v44);
          }
          v44 += 0x7B;
        }
        break;
      case 0xB:
        v46 = word_A3D21;
        for ( mm = 0; mm < word_A62A1; ++mm )
        {
          if ( ((1 << *a1) & (unsigned __int8)v46[0xA]) != 0 )
          {
            v48 = v46;
            for ( nn = 0; nn < v46[0x22]; *(_BYTE *)(v50 + 0x23) |= 2u )
            {
              v50 = *((_DWORD *)v48 + 0xB);
              v48 += 2;
              ++nn;
            }
          }
          v46 += 0x30;
        }
        break;
      case 0xC:
        v66 = a1;
        for ( i1 = 0; i1 < SHIWORD(dword_A3CF2); ++i1 )
        {
          if ( i1 != (unsigned __int8)*a1 && v66[0x1C0] == 2 )
          {
            v52 = byte_A2F72;
            v53 = 0;
            v54 = &byte_A2F72[v4];
            while ( v53 < SHIWORD(dword_A3CF2) )
            {
              if ( v53 != i1 && v53 != (unsigned __int8)*a1 && *((_WORD *)v54 + 0xD9) > *(_WORD *)(v52 + 0x1C9) )
              {
                *((_WORD *)v54 + 0xD9) = *(_WORD *)(v52 + 0x1C9);
              }
              ++v53;
              v54 += 0x1EE;
              v52 += 0x1EE;
            }
          }
          v4 += 2;
          ++v66;
        }
        break;
      case 0xE:
        LOBYTE(v4) = *a1;
        v55 = v4;
        v56 = (unsigned __int16)word_106FA6[v55];
        if ( (unsigned __int16)v56 != 0xFFFF )
        {
          word_106FB4[v55] = *(__int16 *)((char *)&word_105296 + 0x4B * v56);
        }
        break;
      case 0xF:
        v57 = &unk_BB1B3;
        for ( i2 = 0; i2 < SHIWORD(dword_CA1ED); ++i2 )
        {
          if ( *((_BYTE *)v57 + 0x57) == *a1 && *((_BYTE *)v57 + 0x54) != 0xFF )
          {
            v57[0x28] += 0x64;
          }
          v57 = (_WORD *)((char *)v57 + 0x7B);
        }
        break;
      default:
        break;
    }
    *(_DWORD *)(a1 + 0x19E) = v68;
  }
  return v67;
}
// 968E8: using guessed type __int16 word_968E8[21];
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// CA1ED: using guessed type int dword_CA1ED;
// D35E5: using guessed type int dword_D35E5;
// 105296: using guessed type __int16 word_105296;
// 10529F: using guessed type int dword_10529F;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];

//----- (00043B7C) --------------------------------------------------------
int __fastcall sub_43B7C(int a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edx

  v2 = *(__int16 *)(a1 + 0x1D1) - *(__int16 *)(a1 + 2 * a2 + 0x1B2);
  if ( v2 <= 0 )
  {
    v3 = 0x64;
  }
  else
  {
    v3 = 0x64 * v2 / (*(__int16 *)(a1 + 0x1D1) - *(__int16 *)(a1 + 0x1C9));
  }
  if ( v3 > 0x64 )
  {
    return 0x64;
  }
  return v3;
}

//----- (00043BDC) --------------------------------------------------------
__int64 __fastcall sub_43BDC(int a1, unsigned int a2, int a3)
{
  int v4; // eax
  __int64 result; // rax
  _WORD v6[248]; // [esp+0h] [ebp-204h] BYREF
  unsigned int count; // [esp+1F0h] [ebp-14h]

  count = a2;
  sub_3B120((int)v6);
  if ( a3 == 0xFFFFFFFF )
  {
    sub_1BF94((P_Type1)count, v6, 0x1EEu);
    qmemcpy((void *)a1, v6, 0x1ECu);
    *(_WORD *)(a1 + 0x1EC) = v6[0xF6];
    v4 = 0x30 * *(_DWORD *)(a1 + 7);
    *(_WORD *)(a1 + 0x19B) = 0;
    *(_DWORD *)(a1 + 7) = &word_A3D21[v4];
  }
  else
  {
    qmemcpy(v6, (const void *)a1, 0x1EEu);
    *(_DWORD *)((char *)&v6[3] + 1) = *(__int16 *)(*(_DWORD *)((char *)&v6[3] + 1) + 4);
    sub_1C098(count, (int)v6, 0x1EEu);
  }
  LODWORD(result) = v6;
  HIDWORD(result) = 0;
  return result;
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00043C80) --------------------------------------------------------
int __fastcall sub_43C80(int a1, int a2, int a3, int a4)
{
  FILE *v5; // ecx
  __int16 v6; // ax
  __int16 v7; // dx
  __int16 v8; // ax
  __int16 v9; // bx
  __int16 v10; // ax
  __int16 v11; // di
  __int16 v12; // ax
  __int16 v13; // dx
  __int16 v14; // ax
  __int16 v15; // bx
  int v17; // [esp-4h] [ebp-11Ch]
  char v18[204]; // [esp+0h] [ebp-118h] BYREF
  char s[52]; // [esp+CCh] [ebp-4Ch] BYREF
  int v20; // [esp+100h] [ebp-18h] BYREF
  int v21; // [esp+110h] [ebp-8h]

  v21 = a4;
  v17 = *(unsigned __int8 *)(a1 + 1);
  dword_105248 = 0xFFFFFFF6;
  dword_10524C = 0xFFFFFFF6;
  dword_105250 = 0xFFFFFFF6;
  sprintf(s, "RACE%02d.DIP", v17);
  v5 = sub_1BB10(s, 0);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x55);
  }
  v18[0] = 0;
  while ( strncmp(v18, "DIPVALUES", 9u) )
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v18);
  }
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1C9) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  v6 = v20;
  v7 = *(_WORD *)(a1 + 0x1C9);
  *(_WORD *)(a1 + 0x1CB) = v20;
  if ( v6 <= v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x64);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v8 = v20;
  v9 = *(_WORD *)(a1 + 0x1CB);
  *(_WORD *)(a1 + 0x1CD) = v20;
  if ( v8 <= v9 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x68);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v10 = v20;
  v11 = *(_WORD *)(a1 + 0x1CD);
  *(_WORD *)(a1 + 0x1CF) = v20;
  if ( v10 <= v11 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x6C);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v12 = v20;
  v13 = *(_WORD *)(a1 + 0x1CF);
  *(_WORD *)(a1 + 0x1D1) = v20;
  if ( v12 <= v13 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x70);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v14 = v20;
  v15 = *(_WORD *)(a1 + 0x1D1);
  *(_WORD *)(a1 + 0x1D3) = v20;
  if ( v14 <= v15 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x74);
  }
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1D5) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1B0) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1D7) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1D9) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1DB) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(float *)(a1 + 0x1DD) = (float)(__int16)v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(float *)(a1 + 0x1E1) = (float)(__int16)v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(float *)(a1 + 0x1E5) = (float)(__int16)v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1C7) = v20;
  *(_BYTE *)(a1 + 0x19D) = *(_BYTE *)(a1 + 1);
  *(_DWORD *)(a1 + 0x19E) = 0;
  return fclose(v5);
}
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00044024) --------------------------------------------------------
unsigned int __fastcall sub_44024(_BYTE *a1, char a2)
{
  int v3; // eax
  int v4; // edi
  __int16 *v5; // edx
  int v6; // ebx
  int v8; // [esp+0h] [ebp-18h]

  v3 = 0;
  v8 = 0;
  v4 = 1 << a2;
  v5 = word_A3D21;
  while ( v3 < word_A62A1 )
  {
    v6 = *((unsigned __int8 *)v5 + 0x17);
    if ( ((1 << *a1) & v6) != 0 && (v4 & v6) != 0 )
    {
      return 0xFFFFFFFF;
    }
    ++v3;
    v5 += 0x30;
  }
  return v8;
}
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00044080) --------------------------------------------------------
char *__fastcall sub_44080(unsigned __int8 *a1)
{
  unsigned __int8 *v2; // ebp
  int v3; // edi
  char v4; // al
  char *result; // eax
  char v6; // al
  int v7; // ecx
  int v8; // ebx
  char v9; // [esp+0h] [ebp-2Ch]
  int v10; // [esp+4h] [ebp-28h] BYREF
  int v11; // [esp+8h] [ebp-24h] BYREF
  char *v12; // [esp+Ch] [ebp-20h]
  unsigned __int8 *v13; // [esp+10h] [ebp-1Ch]

  if ( *a1 == (_BYTE)byte_104BEA && dword_A0D00 != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0xCD);
  }
  v13 = a1;
  v2 = a1;
  a1[0x1E9] = 0xE;
  v3 = 0;
  v12 = byte_A2F72;
  do
  {
    if ( v3 != *a1 && *(int *)((char *)&dword_A2F75 + 0x1EE * v3) != 0xFFFFFFFF )
    {
      if ( (v3 != (unsigned __int8)byte_104BEA || dword_A0D00 == 0xFFFFFFFF)
        && !v2[0x1C0]
        && sub_44024(a1, v3) == 0xFFFFFFFF )
      {
        *((_WORD *)v13 + 0xD9) = *(_WORD *)(a1 + 0x1D5);
        word_A3124[0xF7 * v3 + *a1] = word_A3147[0xF7 * v3];
        byte_A3132[0x1EE * v3 + *a1] = 1;
        v2[0x1C0] = 1;
      }
      if ( v2[0x1C0] )
      {
        v6 = sub_44434(a1, v3, &v10);
        if ( v6 != 0xE )
        {
          if ( v3 != (unsigned __int8)byte_104BEA || dword_A0D00 )
          {
            v9 = v6;
            v4 = sub_44BCC((int)v12, (__int16 *)*a1, v6, v10, &v11);
            sub_450B0(a1, v3, v9, v4, v10, v11);
          }
          else
          {
            a1[0x1E9] = v6;
            v7 = (char)a1[0x1E9];
            v8 = *a1;
            *(_DWORD *)(a1 + 0x1EA) = v10;
            sub_55AEC((int)&V_Type3_stru_10AE70, 2, v8, v7);
          }
        }
      }
    }
    ++v2;
    ++v3;
    result = v12 + 0x1EE;
    v13 += 2;
    v12 += 0x1EE;
  }
  while ( v3 < 7 );
  return result;
}
// A0D00: using guessed type int dword_A0D00;
// A2F75: using guessed type int dword_A2F75;
// A3124: using guessed type __int16 word_A3124[5];
// A3147: using guessed type __int16 word_A3147[];

//----- (00044238) --------------------------------------------------------
int __fastcall sub_44238(int a1, __int16 a2, _BYTE *a3, __int16 a4)
{
  char *v7; // edi
  int v8; // ecx
  char v9; // kr00_1
  _BYTE *v10; // eax
  int result; // eax
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  _BYTE *v21; // [esp+4h] [ebp-10h]

  *a3 = 0xE;
  v7 = &byte_A2F72[0x1EE * a2];
  v8 = 1;
  v9 = *(_BYTE *)(a1 + a2 + 0x1C0);
  v21 = a3 + 2;
  v10 = a3 + 1;
  switch ( v9 )
  {
    case 0:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x126);
      result = 1;
      break;
    case 1:
      *v10 = 2;
      *v21 = 3;
      v8 = 3;
      if ( dword_A2F6C[0] - dword_105248 >= 5 )
      {
        v8 = 4;
        a3[3] = 4;
      }
      if ( dword_A2F6C[0] - dword_10524C >= 5 )
      {
        v12 = (__int16)v8++;
        a3[v12] = 5;
      }
      if ( dword_A2F6C[0] - dword_105250 >= 5 )
      {
        v13 = (__int16)v8++;
        a3[v13] = 6;
      }
      if ( !*(_BYTE *)(a1 + a4 + 0x1C0) || v7[a4 + 0x1C0] != 2 )
      {
        goto LABEL_29;
      }
      a3[(__int16)v8] = 7;
      result = v8 + 1;
      break;
    case 2:
      *v10 = 0xD;
      result = 2;
      break;
    case 3:
      *v10 = 8;
      v14 = 2;
      if ( dword_A2F6C[0] - dword_105248 >= 5 )
      {
        v14 = 3;
        *v21 = 4;
      }
      if ( dword_A2F6C[0] - dword_10524C >= 5 )
      {
        v15 = (__int16)v14++;
        a3[v15] = 5;
      }
      if ( dword_A2F6C[0] - dword_105250 >= 5 )
      {
        v16 = (__int16)v14++;
        a3[v16] = 6;
      }
      a3[(__int16)v14] = 0xC;
      v8 = v14 + 1;
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) && v7[a4 + 0x1C0] == 2 )
      {
        v17 = (__int16)v8++;
        a3[v17] = 7;
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) && v7[a4 + 0x1C0] == 1 )
      {
        v18 = (__int16)v8;
        v19 = v8 + 1;
        a3[v18] = 9;
        v20 = (__int16)v19;
        v8 = v19 + 1;
        a3[v20] = 0xB;
      }
      if ( !*(_BYTE *)(a1 + a4 + 0x1C0) || v7[a4 + 0x1C0] != 3 )
      {
        goto LABEL_29;
      }
      a3[(__int16)v8] = 0xA;
      result = v8 + 1;
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x17E);
LABEL_29:
      result = v8;
      break;
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C[];
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00044434) --------------------------------------------------------
char __fastcall sub_44434(unsigned __int8 *a1, __int16 a2, _DWORD *a3)
{
  char v5; // bh
  unsigned __int8 v6; // bl
  unsigned __int8 *v7; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // edx
  unsigned __int8 *v12; // eax
  __int16 v13; // dx
  __int16 v14; // ax
  __int16 v15; // dx
  int v16; // [esp+0h] [ebp-18h]

  if ( *a1 == (_BYTE)byte_104BEA && dword_A0D00 != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x18D);
  }
  v5 = sub_43374(a1, 0xFFFFFFFF);
  v6 = a1[a2 + 0x1C0];
  v7 = &a1[2 * a2];
  if ( v6 < 2u )
  {
    if ( v6 == 1 )
    {
      if ( byte_A3D20 )
      {
        if ( (unsigned __int8)byte_A3D20 <= 1u )
        {
          if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1C9) && a2 == (unsigned __int8)byte_104BEA )
          {
            return 2;
          }
        }
        else if ( byte_A3D20 == 2 )
        {
          if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1CB) && a2 == (unsigned __int8)byte_104BEA )
          {
            *((_WORD *)v7 + 0xD9) = *(_WORD *)(a1 + 0x1C9) - 1;
            return 2;
          }
          v9 = &a1[2 * a2];
          if ( *(_WORD *)(a1 + 0x1CD) > *((_WORD *)v9 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
          {
            *((_WORD *)v9 + 0xD9) = *(_WORD *)(a1 + 0x1CB) - 1;
          }
          else
          {
            v10 = &a1[2 * a2];
            if ( *(_WORD *)(a1 + 0x1CF) > *((_WORD *)v10 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
            {
              *((_WORD *)v10 + 0xD9) = *(_WORD *)(a1 + 0x1CD) - 1;
            }
            else
            {
              v11 = &a1[2 * a2];
              if ( *(_WORD *)(a1 + 0x1D1) > *((_WORD *)v11 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
              {
                *((_WORD *)v11 + 0xD9) = *(_WORD *)(a1 + 0x1CF) - 1;
              }
              else
              {
                v12 = &a1[2 * a2];
                if ( *(_WORD *)(a1 + 0x1D3) > *((_WORD *)v12 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
                {
                  *((_WORD *)v12 + 0xD9) = *(_WORD *)(a1 + 0x1D1) - 1;
                }
                else if ( a2 == (unsigned __int8)byte_104BEA )
                {
                  *(_WORD *)&a1[2 * a2 + 0x1B2] = *(_WORD *)(a1 + 0x1D3) - 1;
                }
              }
            }
          }
        }
      }
      else if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1C9)
             && (!v5 || a2 == (unsigned __int8)byte_104BEA)
             && (a2 == (unsigned __int8)byte_104BEA || *(int *)((char *)&dword_A3CF8 + 6 * *a1) >> 0x10 > 2) )
      {
        return 2;
      }
      if ( *(_WORD *)(a1 + 0x1D3) < *(_WORD *)&a1[2 * a2 + 0x1B2] )
      {
        return 3;
      }
    }
  }
  else if ( v6 <= 2u )
  {
    if ( *((_WORD *)v7 + 0xD9) > *(_WORD *)(a1 + 0x1CD) )
    {
      return 0xD;
    }
  }
  else
  {
    if ( v6 != 3 )
    {
      goto LABEL_51;
    }
    if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1C9) && !v5 )
    {
      if ( a2 == (unsigned __int8)byte_104BEA || *(int *)((char *)&dword_A3CF8 + 6 * *a1) >> 0x10 > 2 )
      {
        return 2;
      }
      return 8;
    }
    if ( *(_WORD *)(a1 + 0x1CF) > *(_WORD *)&a1[2 * a2 + 0x1B2] )
    {
      return 8;
    }
  }
LABEL_51:
  if ( dword_A2F6C[0] % *(__int16 *)(a1 + 0x1C7) || a2 != (unsigned __int8)byte_104BEA || a1[a2 + 0x1C0] == 2 )
  {
    return 0xE;
  }
  v16 = rand() % 0x64;
  if ( a2 != (unsigned __int8)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x212);
  }
  if ( a1[a2 + 0x1C0] != 3 || v16 >= 0x50 )
  {
LABEL_85:
    if ( *(_WORD *)(a1 + 0x1C9) <= *(_WORD *)&a1[2 * a2 + 0x1B2] )
    {
      if ( a1[a2 + 0x1C0] == 3 )
      {
        v16 += 0xF;
      }
      if ( *(__int16 *)&a1[2 * a2 + 0x1B2] > *(__int16 *)(a1 + 0x1CF) + 0xA && v16 >= 0x5D && sub_46208(a1, a2) )
      {
        return 6;
      }
      if ( *(_WORD *)(a1 + 0x1CF) < *(_WORD *)&a1[2 * a2 + 0x1B2] && v16 >= 0x58 && sub_46034(a1, a2) )
      {
        return 5;
      }
      if ( *(__int16 *)&a1[2 * a2 + 0x1B2] > *(__int16 *)(a1 + 0x1D5) + 0x14 && v16 >= 0x50 && sub_45E64(a1, a2) )
      {
        return 4;
      }
    }
    return 0xE;
  }
  v13 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( v13 == *a1
         || v13 == a2
         || *(int *)((char *)&dword_A2F75 + 0x1EE * v13) == 0xFFFFFFFF
         || a1[v13 + 0x1C0] != 2
         || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v13] != 3 )
    {
      if ( ++v13 >= SHIWORD(dword_A3CF2) )
      {
        goto LABEL_67;
      }
    }
    *a3 = v13;
    return 0xA;
  }
  else
  {
LABEL_67:
    v14 = 0;
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      while ( v14 == *a1
           || v14 == a2
           || *(int *)((char *)&dword_A2F75 + 0x1EE * v14) == 0xFFFFFFFF
           || a1[v14 + 0x1C0] != 3
           || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v14] != 2 )
      {
        if ( ++v14 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_76;
        }
      }
      *a3 = v14;
      return 7;
    }
    else
    {
LABEL_76:
      v15 = 0;
      if ( SHIWORD(dword_A3CF2) <= 0 )
      {
        goto LABEL_85;
      }
      while ( v15 == *a1
           || v15 == a2
           || *(int *)((char *)&dword_A2F75 + 0x1EE * v15) == 0xFFFFFFFF
           || a1[v15 + 0x1C0] != 2
           || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v15] != 1 )
      {
        if ( ++v15 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_85;
        }
      }
      *a3 = v15;
      return 9;
    }
  }
}
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3CF8: using guessed type int dword_A3CF8;
// A3D20: using guessed type char byte_A3D20;

//----- (00044A2C) --------------------------------------------------------
int __fastcall sub_44A2C(_BYTE *a1, int a2, char a3, _BYTE *a4)
{
  _BYTE *v4; // eax
  int result; // eax

  if ( *a1 != (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x263);
  }
  v4 = a4 + 1;
  switch ( a3 )
  {
    case 0:
      *a4 = 0;
      result = 1;
      break;
    case 1:
      *a4 = 1;
      *v4 = 2;
      result = 2;
      break;
    case 2:
      *a4 = 3;
      result = 1;
      break;
    case 3:
      *a4 = 4;
      *v4 = 5;
      result = 2;
      break;
    case 4:
      *a4 = 6;
      *v4 = 7;
      result = 2;
      break;
    case 5:
      *a4 = 8;
      *v4 = 9;
      result = 2;
      break;
    case 6:
      *a4 = 0xA;
      *v4 = 0xB;
      result = 2;
      break;
    case 7:
      *a4 = 0xC;
      *v4 = 0xD;
      result = 2;
      break;
    case 8:
      *a4 = 0xE;
      result = 1;
      break;
    case 9:
      *a4 = 0xF;
      *v4 = 0x10;
      result = 2;
      break;
    case 0xA:
      *a4 = 0x11;
      *v4 = 0x12;
      result = 2;
      break;
    case 0xB:
      *a4 = 0x13;
      *v4 = 0x14;
      result = 2;
      break;
    case 0xC:
      *a4 = 0x15;
      *v4 = 0x16;
      result = 2;
      break;
    case 0xD:
      *a4 = 0x1B;
      *v4 = 0x1C;
      result = 2;
      break;
    case 0xE:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x2CF);
      result = 0xE;
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x2D4);
      result = 0;
      break;
  }
  return result;
}

//----- (00044BCC) --------------------------------------------------------
char __fastcall sub_44BCC(int a1, __int16 *a2, char a3, int a4, int *a5)
{
  char result; // al
  int v7; // ebx
  __int16 v8; // di
  int v9; // ebx
  const char *v10; // edx
  int v11; // [esp+0h] [ebp-1B8h] BYREF

  *(_DWORD *)(a1 + 0x1EA) = a4;
  switch ( a3 )
  {
    case 2:
      result = 3;
      break;
    case 3:
      if ( *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) <= *(_WORD *)(a1 + 0x1D1) )
      {
        result = 5;
      }
      else
      {
        result = 4;
      }
      break;
    case 4:
      if ( *(__int16 *)(a1 + 2 * (__int16)a2 + 0x1B2) > *(__int16 *)(a1 + 0x1D5) + 0x14
        && sub_45E64((_BYTE *)a1, (__int16)a2) )
      {
        result = 6;
      }
      else
      {
        result = 7;
      }
      break;
    case 5:
      if ( *(_WORD *)(a1 + 0x1CF) < *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) && sub_46034((_BYTE *)a1, (__int16)a2) )
      {
        result = 8;
      }
      else
      {
        result = 9;
      }
      break;
    case 6:
      if ( *(__int16 *)(a1 + 2 * (__int16)a2 + 0x1B2) > *(__int16 *)(a1 + 0x1CF) + 0xA
        && sub_46208((_BYTE *)a1, (__int16)a2) )
      {
        result = 0xA;
      }
      else
      {
        result = 0xB;
      }
      break;
    case 7:
      if ( *(_BYTE *)(a4 + a1 + 0x1C0) != 2 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x336);
      }
      if ( *(__int16 *)(a1 + 2 * a4 + 0x1B2)
         + (__int16)(*(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) - word_A3143[0xF7 * (__int16)a2]) <= *(__int16 *)(a1 + 0x1CD) )
      {
        result = 0xD;
      }
      else
      {
        result = 0xC;
      }
      break;
    case 8:
      result = 0xE;
      break;
    case 9:
      if ( *(_BYTE *)(a1 + (__int16)a2 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x34A);
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) != 1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x34B);
      }
      if ( (__int16)(*(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) - *(_WORD *)(a1 + 2 * a4 + 0x1B2)) <= *(__int16 *)(a1 + 0x1D5) )
      {
        result = 0x10;
      }
      else
      {
        result = 0xF;
      }
      break;
    case 0xA:
      if ( *(_BYTE *)(a1 + (__int16)a2 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x361);
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x362);
      }
      v7 = a1 + 2 * (__int16)a2;
      v8 = *(_WORD *)(2 * a4 + a1 + 0x1B2);
      if ( (__int16)(*(_WORD *)(v7 + 0x1B2) - v8) <= 0
        || (__int16)(*(_WORD *)(v7 + 0x1B2) - word_A3143[0xF7 * (__int16)a2]) - (__int16)(v8 - word_A3143[0xF7 * a4]) <= 0 )
      {
        result = 0x12;
      }
      else
      {
        result = 0x11;
      }
      break;
    case 0xB:
      if ( *(_BYTE *)(a1 + (__int16)a2 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x384);
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) != 1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x385);
      }
      if ( *(__int16 *)(a1 + 2 * a4 + 0x1B2)
         - (__int16)(*(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) - word_A3143[0xF7 * (__int16)a2]) >= *(__int16 *)(a1 + 0x1C9) )
      {
        result = 0x14;
      }
      else
      {
        result = 0x13;
      }
      break;
    case 0xC:
      if ( !a4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x39D);
      }
      if ( a5 )
      {
        *a5 = a4;
      }
      if ( sub_45958((unsigned __int8 *)a1, 2, (__int16 *)a4, 0) )
      {
        if ( (unsigned __int16)sub_45848((unsigned __int8 *)a1, a4, (int)&v11, a2) )
        {
          if ( ((1 << *(_BYTE *)a1) & *(unsigned __int8 *)(a4 + 0x15)) != 0 )
          {
            result = 0x1A;
          }
          else if ( *(_WORD *)(a1 + 0x1D3) >= *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) )
          {
            result = 0x16;
          }
          else
          {
            result = 0x15;
          }
        }
        else if ( ((1 << *(_BYTE *)a1) & *(unsigned __int8 *)(a4 + 0x15)) != 0 )
        {
          result = 0x19;
        }
        else
        {
          result = 0x17;
        }
      }
      else
      {
        result = 0x18;
      }
      break;
    case 0xD:
      if ( *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) < *(_WORD *)(a1 + 0x1CB) )
      {
        result = 0x1C;
      }
      else
      {
        result = 0x1B;
      }
      break;
    case 0xE:
      v9 = 0x3CE;
      v10 = "..\\raceneg.cpp";
      goto LABEL_66;
    default:
      v9 = 0x3D3;
      v10 = "..\\raceneg.cpp";
LABEL_66:
      result = 0x1D;
      Q_AssertLogBreakExit_sub_261A8(0, v10, v9);
      break;
  }
  return result;
}
// A3143: using guessed type __int16 word_A3143[];

//----- (000450B0) --------------------------------------------------------
char __fastcall sub_450B0(unsigned __int8 *a1, __int16 a2, char a3, char a4, int a5, int a6)
{
  char *v7; // edi
  char *v9; // ebx
  char *v10; // edx
  unsigned __int8 *v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // edx
  char *v17; // edi
  unsigned __int8 *v18; // esi
  int v19; // eax
  int v20; // edx
  __int16 v21; // cx
  int v22; // edx
  int v23; // edx
  __int16 v24; // cx
  _BYTE v26[428]; // [esp+0h] [ebp-1D4h] BYREF
  int v27; // [esp+1ACh] [ebp-28h]
  int v28; // [esp+1B0h] [ebp-24h]
  char *v29; // [esp+1B4h] [ebp-20h]
  int v30; // [esp+1B8h] [ebp-1Ch]
  char *v31; // [esp+1BCh] [ebp-18h]
  char *v32; // [esp+1C0h] [ebp-14h]
  __int16 v33; // [esp+1C4h] [ebp-10h]

  v33 = a2;
  v30 = a2;
  v7 = &byte_A2F72[0x1EE * a2];
  v29 = &v7[a5];
  v28 = 0x1EE * a5;
  v32 = &byte_A2F72[0x1EE * a5];
  v31 = &v32[a2];
  v9 = &v7[2 * a5];
  v10 = &v32[2 * a2];
  v11 = &a1[2 * v30];
  switch ( a3 )
  {
    case 0:
      v11 = (unsigned __int8 *)*a1;
      v12 = v33;
      v11[(_DWORD)v7 + 0x1C0] = 1;
      a1[v12 + 0x1C0] = v11[(_DWORD)v7 + 0x1C0];
      *(_WORD *)&a1[2 * v33 + 0x1B2] = *(_WORD *)(a1 + 0x1D5);
      LOWORD(v11) = *(_WORD *)(v7 + 0x1D5);
      *(_WORD *)&v7[2 * *a1 + 0x1B2] = (_WORD)v11;
      return (char)v11;
    case 1:
      if ( a4 == 1 )
      {
        LOBYTE(v11) = v33;
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0x28;
      }
      return (char)v11;
    case 2:
      v13 = *a1;
      v14 = v33;
      v7[v13 + 0x1C0] = 2;
      a1[v14 + 0x1C0] = v7[v13 + 0x1C0];
      v11 = (unsigned __int8 *)*a1;
      *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] -= 0x28;
      return (char)v11;
    case 3:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 3;
      }
      if ( a4 == 4 )
      {
        v15 = *a1;
        v16 = v33;
        v7[v15 + 0x1C0] = 3;
        a1[v16 + 0x1C0] = v7[v15 + 0x1C0];
        *(_WORD *)&a1[2 * v16 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 0xA;
      }
      else
      {
        LOBYTE(v11) = v33;
        *(_WORD *)&a1[2 * v33 + 0x1B2] = *(_WORD *)(a1 + 0x1D1);
      }
      return (char)v11;
    case 4:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 5;
        dword_105248 = dword_A2F6C[0];
      }
      if ( a4 == 6 )
      {
        sub_45F60(a1, v33, 0);
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 5;
      }
      else
      {
        v20 = v33;
        v11 = &a1[2 * v33];
        v21 = *((_WORD *)v11 + 0xD9) - 2;
        *((_WORD *)v11 + 0xD9) = v21;
        if ( a1[v20 + 0x1C0] == 3 )
        {
          *((_WORD *)v11 + 0xD9) = v21 - 2;
        }
      }
      return (char)v11;
    case 5:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 8;
        dword_10524C = dword_A2F6C[0];
      }
      if ( a4 == 8 )
      {
        sub_46130(a1, v33, 0);
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 5;
      }
      else
      {
        v22 = v33;
        v11 = &a1[2 * v33];
        *((_WORD *)v11 + 0xD9) -= 3;
        if ( a1[v22 + 0x1C0] == 3 )
        {
          *((_WORD *)v11 + 0xD9) -= 3;
        }
      }
      return (char)v11;
    case 6:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 8;
        dword_105250 = dword_A2F6C[0];
      }
      if ( a4 == 0xA )
      {
        sub_46304(a1, v33, 0);
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 0xA;
      }
      else
      {
        v23 = v33;
        v11 = &a1[2 * v33];
        *((_WORD *)v11 + 0xD9) -= 2;
        if ( a1[v23 + 0x1C0] == 3 )
        {
          *((_WORD *)v11 + 0xD9) -= 2;
        }
      }
      return (char)v11;
    case 7:
      if ( a4 != 0xC )
      {
        goto LABEL_54;
      }
      *((_WORD *)v11 + 0xD9) += 5;
      if ( *((__int16 *)v10 + 0xD9) > *(int *)((char *)&dword_A313B + SHIWORD(v28)) - 0xA )
      {
        *((_WORD *)v11 + 0xD9) += 5;
        v29[0x1C0] = 1;
        v31[0x1C0] = 1;
        *((_WORD *)v9 + 0xD9) += 0xA;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] += 5;
        *((_WORD *)v10 + 0xD9) += 0xA;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
        *((_WORD *)v11 + 0xD9) += 0xF;
      }
      return (char)v11;
    case 8:
      v19 = *a1;
      v7[v19 + 0x1C0] = 1;
      a1[v30 + 0x1C0] = v7[v19 + 0x1C0];
      v11 = (unsigned __int8 *)*a1;
      *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] -= 0x1E;
      return (char)v11;
    case 9:
      if ( a4 == 0xF )
      {
        *((_WORD *)v11 + 0xD9) += 0xA;
        v29[0x1C0] = 2;
        v31[0x1C0] = 2;
        *((_WORD *)v9 + 0xD9) -= 0xF;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] += 0xA;
        *((_WORD *)v10 + 0xD9) -= 0x14;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
      }
      goto LABEL_38;
    case 0xA:
      if ( a4 == 0x11 )
      {
        *((_WORD *)v11 + 0xD9) += 0xF;
        v29[0x1C0] = 1;
        v31[0x1C0] = 1;
        *((_WORD *)v9 + 0xD9) -= 5;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] -= 5;
        *((_WORD *)v10 + 0xD9) -= 0xA;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
LABEL_41:
        *((_WORD *)v11 + 0xD9) -= 5;
      }
      else
      {
LABEL_38:
        *((_WORD *)v11 + 0xD9) -= 0xA;
      }
      break;
    case 0xB:
      if ( a4 != 0x13 )
      {
        goto LABEL_41;
      }
      *((_WORD *)v11 + 0xD9) += 5;
      v27 = *(_DWORD *)((char *)&unk_A3141 + SHIWORD(v28));
      if ( *((__int16 *)v10 + 0xD9) > v27 - 0xA )
      {
        *((_WORD *)v11 + 0xD9) += 5;
        v29[0x1C0] = 3;
        v31[0x1C0] = 3;
        *((_WORD *)v9 + 0xD9) += 0xA;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] += 5;
        *((_WORD *)v10 + 0xD9) += 0xF;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
        *((_WORD *)v11 + 0xD9) += 0xA;
      }
      break;
    case 0xC:
      if ( a4 == 0x15 || a4 == 0x1A )
      {
        LOBYTE(v11) = byte_104BEA;
        if ( v33 != (unsigned __int8)byte_104BEA )
        {
          if ( !a5 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x4FA);
          }
          v24 = sub_45848((unsigned __int8 *)v7, a5, (int)v26, (__int16 *)v7);
          if ( !v24 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x4FD);
          }
          sub_45A0C(v7, a5, (int)v26, v24);
          LOBYTE(v11) = v33;
          *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        }
      }
      else if ( a4 == 0x16 )
      {
LABEL_54:
        *((_WORD *)v11 + 0xD9) -= 5;
      }
      return (char)v11;
    case 0xD:
      if ( *a1 == (_BYTE)byte_104BEA )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 3;
      }
      if ( a4 == 0x1B )
      {
        v17 = &v7[*a1];
        v11 = (unsigned __int8 *)v33;
        v17[0x1C0] = 1;
        v18 = &a1[(_DWORD)v11];
        LOBYTE(v11) = v17[0x1C0];
        v18[0x1C0] = (unsigned __int8)v11;
      }
      else
      {
        LOBYTE(v11) = v33;
        *(_WORD *)&a1[2 * v33 + 0x1B2] -= 0x19;
      }
      return (char)v11;
    case 0xE:
      LOBYTE(v11) = 0;
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x515);
      return (char)v11;
    default:
      return (char)v11;
  }
  return (char)v11;
}
// A2F6C: using guessed type int dword_A2F6C[];
// A313B: using guessed type int dword_A313B;
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00045848) --------------------------------------------------------
int __usercall sub_45848@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>, int a3@<ebx>, __int16 *a4@<edi>)
{
  __int16 v5; // si
  int v6; // eax
  int v7; // ebx
  int v8; // ebx
  char v9; // al
  __int16 *v10; // ebx
  int v12[107]; // [esp+0h] [ebp-1CCh] BYREF
  int v13; // [esp+1ACh] [ebp-20h]
  int v14; // [esp+1B0h] [ebp-1Ch]
  int v15; // [esp+1B4h] [ebp-18h]
  size_t v16; // [esp+1B8h] [ebp-14h]

  v13 = a2;
  v14 = a3;
  LOWORD(v15) = 0;
  v5 = 0;
  v16 = sub_40224(a1, v12, 0);
  if ( (__int16)v16 > 0 )
  {
    do
    {
      v8 = v12[v5];
      v9 = *(_BYTE *)(v8 + 0x58);
      v10 = *(__int16 **)(v8 + 0x59);
      if ( v9 != 1 && v9 != 2 )
      {
        if ( v9 == 3 )
        {
          a4 = &word_A3D21[0x30 * v10[6]];
LABEL_8:
          if ( (unsigned __int8)byte_D5D47[0x64 * a4[2] + *(__int16 *)(v13 + 4)] < 3u )
          {
            v6 = 4 * (__int16)v15;
            v7 = v12[v5];
            LOWORD(v15) = v15 + 1;
            *(_DWORD *)(v14 + v6) = v7;
          }
          goto LABEL_10;
        }
        if ( v9 != 4 )
        {
          if ( v9 == 5 )
          {
            a4 = *(__int16 **)v10;
          }
          goto LABEL_8;
        }
        a4 = v10;
        if ( !sub_45958(a1, 2, v10, 0) )
        {
          goto LABEL_8;
        }
      }
LABEL_10:
      ++v5;
    }
    while ( v5 < (__int16)v16 );
  }
  return v15;
}
// A3D21: using guessed type __int16 word_A3D21[];
// 45848: using guessed type int var_1CC[107];

//----- (00045958) --------------------------------------------------------
int __fastcall sub_45958(unsigned __int8 *a1, char a2, __int16 *a3, _DWORD *a4)
{
  __int16 v6; // di
  int v7; // ecx
  __int16 v8; // bx
  int v9; // eax
  int v11[107]; // [esp+0h] [ebp-1C4h] BYREF
  int v12; // [esp+1ACh] [ebp-18h]
  _DWORD *v13; // [esp+1B0h] [ebp-14h]
  char v14; // [esp+1B4h] [ebp-10h]

  v14 = a2;
  v13 = a4;
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x54E);
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v12 = sub_1D794(a3, v11);
  while ( v8 < v12 )
  {
    v9 = v11[v8];
    if ( v9 && (*(_WORD *)(v9 + 0x56) == *a1 && v14 == 3 || a1[*(__int16 *)(v9 + 0x56) + 0x1C0] == v14) )
    {
      ++v6;
      v7 += *(_DWORD *)v9 * *(_DWORD *)(v9 + 0x8C);
    }
    ++v8;
  }
  if ( v13 )
  {
    *v13 = v7;
  }
  return v6;
}
// 45958: using guessed type int var_1C4[107];

//----- (00045A0C) --------------------------------------------------------
int __fastcall sub_45A0C(_BYTE *a1, int a2, int a3, __int16 a4)
{
  int result; // eax
  int v6; // edx

  if ( *a1 == (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x574);
  }
  for ( result = 0; (__int16)result < a4; *(_DWORD *)(v6 + 0x5E) = a2 )
  {
    *(_BYTE *)(*(_DWORD *)(a3 + 4 * (__int16)result) + 0x5D) = 1;
    v6 = *(_DWORD *)(a3 + 4 * (__int16)result++);
  }
  return result;
}

//----- (00045A54) --------------------------------------------------------
unsigned int __fastcall sub_45A54(unsigned __int8 *a1, int a2, int a3)
{
  __int16 v5; // ax
  int v6; // edx
  __int16 i; // ax
  char *v8; // edi
  __int16 j; // si
  __int16 v10; // ax
  int v11; // edx
  __int16 v12; // dx
  char v13; // cl
  unsigned int v16; // [esp+0h] [ebp-2Ch]
  unsigned int v17; // [esp+4h] [ebp-28h]
  unsigned int v18; // [esp+8h] [ebp-24h]
  unsigned int v19; // [esp+14h] [ebp-18h]
  int v20; // [esp+18h] [ebp-14h]

  if ( *a1 != (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x58A);
  }
  v19 = 0;
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v20 = 0;
  if ( (byte_D8460[*(__int16 *)(a2 + 4)] & 1) != 0 )
  {
    return 0;
  }
  v5 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( v5 == (unsigned __int8)byte_104BEA
         || a1[v5 + 0x1C0]
         || ((1 << v5) & (*(unsigned __int8 *)(a2 + 0x14) | *(unsigned __int8 *)(a2 + 0x15))) == 0 )
    {
      if ( ++v5 >= SHIWORD(dword_A3CF2) )
      {
        goto LABEL_11;
      }
    }
    v20 = v5;
    a1[v5 + 0x1C0] = 1;
    v16 = 0xFFFFFFFF;
    *(_WORD *)&a1[2 * v5 + 0x1B2] = *(_WORD *)(a1 + 0x1D5);
    v6 = 0xF7 * v5;
    byte_A3132[2 * v6 + *a1] = 1;
    word_A3124[*a1 + v6] = word_A3147[0xF7 * v5];
  }
LABEL_11:
  if ( !v16 )
  {
    for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
    {
      if ( i != (unsigned __int8)byte_104BEA && a1[i + 0x1C0] == 2 )
      {
        if ( ((1 << i) & *(unsigned __int8 *)(a2 + 0x15)) != 0 )
        {
          v20 = i;
          v18 = 0xFFFFFFFF;
        }
        if ( !v18 && ((1 << i) & *(unsigned __int8 *)(a2 + 0x14)) != 0 )
        {
          v17 = 0xFFFFFFFF;
          v20 = i;
        }
      }
    }
  }
  if ( !v16 && !v18 && !v17 )
  {
    v8 = byte_A2F72;
    for ( j = 0; j < SHIWORD(dword_A3CF2); v8 += 0x1EE )
    {
      if ( j != (unsigned __int8)byte_104BEA )
      {
        v10 = 0;
        if ( SHIWORD(dword_A3CF2) > 0 )
        {
          v11 = *(unsigned __int8 *)(a2 + 0x15);
          while ( ((1 << j) & v11) == 0 || ((1 << v10) & v11) == 0 || v8[v10 + 0x1C0] != 2 )
          {
            if ( ++v10 >= SHIWORD(dword_A3CF2) )
            {
              goto LABEL_34;
            }
          }
          v19 = 0xFFFFFFFF;
        }
      }
LABEL_34:
      ++j;
    }
  }
  if ( v16 == 0xFFFFFFFF )
  {
    v12 = 4;
  }
  else if ( v18 == 0xFFFFFFFF )
  {
    v12 = 5;
  }
  else if ( v17 == 0xFFFFFFFF )
  {
    v12 = 6;
  }
  else if ( v19 == 0xFFFFFFFF )
  {
    v12 = 7;
  }
  else
  {
    v13 = byte_104BEA;
    *(_BYTE *)(a3 + 0x5D) = 0;
    *(_DWORD *)(a3 + 0x5E) = 0;
    if ( ((1 << v13) & *(unsigned __int8 *)(a2 + 0x17)) != 0 )
    {
      v12 = 3;
    }
    else
    {
      v12 = 0x14;
    }
  }
  byte_D8460[*(__int16 *)(a2 + 4)] |= 1u;
  sub_55AEC((int)&V_Type3_stru_10AE70, v12, a3, v20);
  return 0xFFFFFFFF;
}
// 45D0F: conditional instruction was optimized away because edx.4 is in (3..7|==14)
// A3124: using guessed type __int16 word_A3124[5];
// A3147: using guessed type __int16 word_A3147[];
// A3CF2: using guessed type int dword_A3CF2;

//----- (00045D50) --------------------------------------------------------
unsigned int __fastcall sub_45D50(unsigned __int8 *a1, int a2, int a3)
{
  unsigned int v5; // edx
  unsigned __int8 *v6; // eax
  unsigned __int8 v7; // cl
  __int16 v9; // [esp+2h] [ebp-14h]

  if ( *a1 != (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x61C);
  }
  v9 = *(_WORD *)(a3 + 0x56);
  v5 = 0xFFFFFFFF;
  if ( ((1 << v9) & *(unsigned __int8 *)(a2 + 0x15)) == 0 )
  {
    v6 = &a1[v9];
    v7 = v6[0x1C0];
    if ( v7 )
    {
      if ( v7 == 2 )
      {
        v5 = 9;
      }
    }
    else
    {
      v6[0x1C0] = 1;
      *(_WORD *)&a1[2 * v9 + 0x1B2] = *(_WORD *)(a1 + 0x1D5);
      byte_A3132[0x1EE * v9 + *a1] = 1;
      v5 = 8;
      word_A3124[0xF7 * v9 + *a1] = word_A3147[0xF7 * v9];
    }
  }
  if ( v5 == 0xFFFFFFFF || (byte_D8460[*(__int16 *)(a2 + 4)] & 1) != 0 )
  {
    return 0;
  }
  sub_55AEC((int)&V_Type3_stru_10AE70, v5, a3, v9);
  byte_D8460[*(__int16 *)(a2 + 4)] |= 1u;
  return 0xFFFFFFFF;
}
// A3124: using guessed type __int16 word_A3124[5];
// A3147: using guessed type __int16 word_A3147[];

//----- (00045E64) --------------------------------------------------------
unsigned int __fastcall sub_45E64(_BYTE *a1, __int16 a2)
{
  unsigned __int8 v2; // al
  int v3; // edx
  char *i; // eax
  float v7; // [esp+4h] [ebp-24h]
  __int16 v8; // [esp+8h] [ebp-20h]
  __int16 v9; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 v10; // [esp+10h] [ebp-18h]
  unsigned __int8 v11; // [esp+14h] [ebp-14h]

  if ( a1[a2 + 0x1C0] == 3 )
  {
    return 0xFFFFFFFF;
  }
  v9 = 0;
  v11 = 1 << *a1;
  v8 = 0;
  v2 = 1 << a2;
  v3 = 0;
  v10 = v2;
  for ( i = (char *)&unk_A62A3; (__int16)v3 < word_A792F; i += 0x27 )
  {
    if ( (v11 & (unsigned __int8)i[0x20]) != 0 )
    {
      ++v9;
    }
    if ( (v10 & (unsigned __int8)i[0x20]) != 0 )
    {
      ++v8;
    }
    ++v3;
  }
  if ( v9 >= 5 )
  {
    if ( !v8 )
    {
      v8 = 1;
    }
    v7 = (float)v9;
    if ( v7 / (double)word_A792F > dbl_9259A )
    {
      return 0;
    }
    if ( v7 / (double)v8 > dbl_925A2 )
    {
      return 0;
    }
    return 0xFFFFFFFF;
  }
  return 0;
}
// 9259A: using guessed type double dbl_9259A;
// 925A2: using guessed type double dbl_925A2;
// A792F: using guessed type __int16 word_A792F;

//----- (00045F60) --------------------------------------------------------
void __fastcall sub_45F60(_BYTE *a1, __int16 a2, int a3)
{
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // ebp
  __int64 v10; // rtt
  unsigned __int8 v11; // dh
  char *v12; // eax
  unsigned __int8 v13; // dl
  int i; // ecx
  int v16; // [esp+4h] [ebp-14h]

  v5 = 0;
  v6 = 0;
  if ( a1[a2 + 0x1C0] == 3 )
  {
    v7 = rand();
    v8 = v7;
    v9 = 6;
  }
  else
  {
    v7 = rand();
    v8 = v7;
    v9 = 3;
  }
  LODWORD(v10) = v7;
  HIDWORD(v10) = v8 >> 0x1F;
  v16 = v10 % v9 + 1;
  v11 = 1 << *a1;
  v12 = (char *)&unk_A62A3;
  v13 = 1 << byte_A2F72[0x1EE * a2];
  for ( i = 0; (__int16)i < word_A792F; v12 += 0x27 )
  {
    if ( a3 || (v11 & (unsigned __int8)v12[0x20]) == 0 )
    {
      if ( (v13 & (unsigned __int8)v12[0x20]) != 0 && v5 < v16 && (v11 & (unsigned __int8)v12[0x20]) == 0 )
      {
        ++v5;
        v12[0x20] |= v11;
      }
    }
    else if ( v6 < v16 && (v13 & (unsigned __int8)v12[0x20]) == 0 )
    {
      ++v6;
      v12[0x20] |= v13;
    }
    ++i;
  }
  JUMPOUT(0x449E7);
}
// 45FD6: control flows out of bounds to 449E7
// A792F: using guessed type __int16 word_A792F;

//----- (00046034) --------------------------------------------------------
unsigned int __fastcall sub_46034(_BYTE *a1, __int16 a2)
{
  unsigned __int8 v2; // al
  int v3; // edx
  __int16 *i; // eax
  float v7; // [esp+4h] [ebp-24h]
  __int16 v8; // [esp+8h] [ebp-20h]
  __int16 v9; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 v10; // [esp+10h] [ebp-18h]
  unsigned __int8 v11; // [esp+14h] [ebp-14h]

  if ( a1[a2 + 0x1C0] == 3 )
  {
    return 0xFFFFFFFF;
  }
  v9 = 0;
  v11 = 1 << *a1;
  v8 = 0;
  v2 = 1 << a2;
  v3 = 0;
  v10 = v2;
  for ( i = word_A3D21; (__int16)v3 < word_A62A1; i += 0x30 )
  {
    if ( (v11 & *((_BYTE *)i + 0x17)) != 0 )
    {
      ++v9;
    }
    if ( (v10 & *((_BYTE *)i + 0x17)) != 0 )
    {
      ++v8;
    }
    ++v3;
  }
  if ( v9 >= 3 )
  {
    if ( !v8 )
    {
      v8 = 1;
    }
    v7 = (float)v9;
    if ( v7 / (double)word_A62A1 > dbl_925AA )
    {
      return 0;
    }
    if ( v7 / (double)v8 > dbl_925B2 )
    {
      return 0;
    }
    return 0xFFFFFFFF;
  }
  return 0;
}
// 925AA: using guessed type double dbl_925AA;
// 925B2: using guessed type double dbl_925B2;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00046130) --------------------------------------------------------
void __fastcall sub_46130(_BYTE *a1, __int16 a2, int a3)
{
  int v5; // esi
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // ebp
  __int64 v10; // rtt
  unsigned __int8 v11; // dh
  __int16 *v12; // eax
  unsigned __int8 v13; // dl
  int i; // ecx
  int v16; // [esp+4h] [ebp-14h]

  v5 = 0;
  v6 = 0;
  if ( a1[a2 + 0x1C0] == 3 )
  {
    v7 = rand();
    v8 = v7;
    v9 = 4;
  }
  else
  {
    v7 = rand();
    v8 = v7;
    v9 = 2;
  }
  LODWORD(v10) = v7;
  HIDWORD(v10) = v8 >> 0x1F;
  v16 = v10 % v9 + 1;
  v11 = 1 << *a1;
  v12 = word_A3D21;
  v13 = 1 << byte_A2F72[0x1EE * a2];
  for ( i = 0; (__int16)i < word_A62A1; v12 += 0x30 )
  {
    if ( a3 || (v11 & *((_BYTE *)v12 + 0x17)) == 0 )
    {
      if ( (v13 & *((_BYTE *)v12 + 0x17)) != 0 && v5 < v16 && (v11 & *((_BYTE *)v12 + 0x17)) == 0 )
      {
        *((_BYTE *)v12 + 0x16) |= v11;
        ++v5;
        *((_BYTE *)v12 + 0x17) |= v11;
      }
    }
    else if ( v6 < v16 && (v13 & *((_BYTE *)v12 + 0x17)) == 0 )
    {
      *((_BYTE *)v12 + 0x16) |= v13;
      ++v6;
      *((_BYTE *)v12 + 0x17) |= v13;
    }
    ++i;
  }
  JUMPOUT(0x449E7);
}
// 461A6: control flows out of bounds to 449E7
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00046208) --------------------------------------------------------
unsigned int __fastcall sub_46208(_BYTE *a1, __int16 a2)
{
  unsigned __int8 v2; // al
  __int16 v3; // dx
  char *v4; // eax
  float v7; // [esp+0h] [ebp-20h]
  __int16 v8; // [esp+8h] [ebp-18h]
  __int16 v9; // [esp+Ch] [ebp-14h]
  unsigned __int8 v10; // [esp+10h] [ebp-10h]
  unsigned __int8 v11; // [esp+14h] [ebp-Ch]

  if ( a1[a2 + 0x1C0] == 3 )
  {
    return 0xFFFFFFFF;
  }
  v8 = 0;
  v11 = 1 << *a1;
  v9 = 0;
  v2 = 1 << a2;
  v3 = 0;
  v10 = v2;
  v4 = byte_10525A;
  while ( v3 < (int)(unsigned __int16)word_105258 )
  {
    if ( (v11 & (unsigned __int8)v4[0x48]) != 0 )
    {
      ++v8;
    }
    if ( (v10 & (unsigned __int8)v4[0x48]) != 0 )
    {
      ++v9;
    }
    ++v3;
    v4 += 0x4B;
  }
  if ( v8 >= 5 )
  {
    if ( !v9 )
    {
      v9 = 1;
    }
    v7 = (float)v8;
    if ( v7 / (double)(unsigned __int16)word_105258 > dbl_925BA )
    {
      return 0;
    }
    if ( v7 / (double)v9 > dbl_925C2 )
    {
      return 0;
    }
    return 0xFFFFFFFF;
  }
  return 0;
}
// 925BA: using guessed type double dbl_925BA;
// 925C2: using guessed type double dbl_925C2;

//----- (00046304) --------------------------------------------------------
int __fastcall sub_46304(_BYTE *a1, __int16 a2, int a3)
{
  int v4; // ebx
  int v5; // esi
  unsigned __int8 v6; // cl
  __int64 i; // rax
  int v10; // [esp+Ch] [ebp-2Ch]
  __int16 v11; // [esp+18h] [ebp-20h]
  __int16 v12; // [esp+20h] [ebp-18h]
  unsigned __int8 v13; // [esp+24h] [ebp-14h]

  v4 = 0;
  v5 = 0;
  if ( a1[a2 + 0x1C0] == 3 )
  {
    v10 = rand() % 2 + 1;
  }
  else
  {
    v10 = 1;
  }
  v13 = 1 << *a1;
  v6 = 1 << byte_A2F72[0x1EE * a2];
  v11 = (unsigned __int8)*a1;
  v12 = (unsigned __int8)byte_A2F72[0x1EE * a2];
  for ( i = (unsigned int)byte_10525A; (unsigned __int16)word_105258 > SWORD2(i); LODWORD(i) = i + 0x4B )
  {
    if ( a3 || (*(_BYTE *)(i + 0x48) & v13) == 0 )
    {
      if ( (v6 & *(_BYTE *)(i + 0x48)) != 0 && v4 < v10 && (v13 & *(_BYTE *)(i + 0x48)) == 0 )
      {
        *(_BYTE *)(i + 0x48) |= v13;
        if ( (unsigned __int16)word_106FA6[v11] == SWORD2(i) )
        {
          word_106FA6[v11] = 0xFFFF;
        }
        ++v4;
      }
    }
    else if ( v5 < v10 && (*(_BYTE *)(i + 0x48) & v6) == 0 )
    {
      *(_BYTE *)(i + 0x48) |= v6;
      if ( (unsigned __int16)word_106FA6[v12] == SWORD2(i) )
      {
        word_106FA6[v12] = 0xFFFF;
      }
      ++v5;
    }
    ++WORD2(i);
  }
  return i;
}
// 106FA6: using guessed type __int16 word_106FA6[7];

//----- (00046470) --------------------------------------------------------
_WORD *sub_46470()
{
  return sub_46480((int)&word_105258, 0);
}

//----- (00046480) --------------------------------------------------------
_WORD *__fastcall sub_46480(int a1, const char *a2)
{
  _WORD *v2; // esi
  int v3; // ebx
  _WORD *v4; // eax
  const char *v5; // eax
  unsigned int v6; // ebp
  _WORD *v7; // edi
  FILE *v8; // edx
  _WORD *v9; // ebx
  int v10; // edx
  _WORD *v11; // ebx
  int i; // eax
  int v13; // eax
  int v14; // ecx
  char *v15; // edx
  char v16; // al
  int k; // edi
  int v18; // ebp
  int v19; // ecx
  _WORD *result; // eax
  _WORD *v21; // esi
  _WORD *v22; // [esp+0h] [ebp-34h]
  fpos_t v23; // [esp+4h] [ebp-30h] BYREF
  fpos_t pos; // [esp+8h] [ebp-2Ch] BYREF
  int v25; // [esp+Ch] [ebp-28h] BYREF
  int v26; // [esp+10h] [ebp-24h] BYREF
  _WORD *v27; // [esp+14h] [ebp-20h]
  int j; // [esp+18h] [ebp-1Ch]
  FILE *fp; // [esp+1Ch] [ebp-18h]

  v2 = (_WORD *)a1;
  *(_DWORD *)(a1 + 0x1D6A) = 0;
  v3 = a1 + 0x1D4C;
  *(_DWORD *)(a1 + 0x1D6E) = 0;
  do
  {
    a1 += 0x4B;
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 - 1) = *(_BYTE *)a1;
  }
  while ( a1 != v3 );
  if ( !dword_105254 )
  {
    v4 = v2;
    do
    {
      v4 = (_WORD *)((char *)v4 + 0x4B);
      *((_BYTE *)v4 + 0xFFFFFFFA) = 0xFF;
    }
    while ( v4 != v2 + 0xEA6 );
    *v2 = 0;
    if ( a2 )
    {
      v5 = a2;
    }
    else
    {
      v5 = "restree.txt";
    }
    fp = sub_1BB10(v5, &v23);
    if ( fp )
    {
      fscanf(fp, "%d", &v25);
      *v2 = v25;
      if ( (unsigned __int16)*v2 > 0x64u )
      {
        *v2 = 0x64;
      }
      v6 = 0xFFFFFFEC;
      j = 0;
      v22 = v2 + 1;
      v7 = v2;
      while ( (unsigned __int16)*v2 > j )
      {
        v8 = fp;
        fscanf(fp, "%s", v22);
        fscanf(v8, "%d %d", &v25, &v26);
        *((_BYTE *)v7 + 0x4C) = v25;
        if ( j > 0xA )
        {
          v26 *= v6;
        }
        if ( v26 > 0xFDE8 )
        {
          v26 = 0xFDE8;
        }
        v9 = v7;
        v10 = 0;
        v7[0x1F] = v26;
        do
        {
          fscanf(fp, "%d", &v25);
          *((_BYTE *)v9 + 0x40) = v25;
          if ( v25 == 0xFF )
          {
            v11 = v7;
            i = 0;
            goto LABEL_25;
          }
          ++v10;
          v9 = (_WORD *)((char *)v9 + 1);
        }
        while ( v10 < 5 );
        v11 = v7;
        for ( i = 0; i < 0x3C; ++i )
        {
LABEL_25:
          if ( *((_BYTE *)v11 + i + 2) == 0x5E )
          {
            *((_BYTE *)v11 + i + 2) = 0x20;
          }
        }
        v6 += 2;
        v7 = (_WORD *)((char *)v7 + 0x4B);
        v22 = (_WORD *)((char *)v22 + 0x4B);
        ++j;
      }
      v27 = v2;
      for ( j = 0; (unsigned __int16)*v2 > j; ++j )
      {
        v18 = (int)v27;
        for ( k = 0; k < 5; ++k )
        {
          v19 = *(unsigned __int8 *)(v18 + 0x40);
          if ( v19 == 0xFF )
          {
            break;
          }
          v13 = 0;
          v14 = 0x4B * v19;
          while ( 1 )
          {
            v15 = (char *)v2 + v14 + v13;
            if ( (unsigned __int8)v15[0x45] == 0xFF )
            {
              break;
            }
            if ( ++v13 >= 4 )
            {
              goto LABEL_31;
            }
          }
          v16 = j;
          v15[0x46] = 0xFF;
          v15[0x45] = v16;
LABEL_31:
          ++v18;
        }
        v27 = (_WORD *)((char *)v27 + 0x4B);
      }
      fgetpos(fp, &pos);
      if ( pos >= v23 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\research.cpp", 0x86);
      }
      fclose(fp);
    }
    dword_105254 = 0xFFFFFFFF;
  }
  result = v2;
  v21 = v2 + 7;
  do
  {
    ++result;
    result[0xEA6] = 0xFFFF;
    result[0xEAD] = 0;
  }
  while ( result != v21 );
  return result;
}
// 105254: using guessed type int dword_105254;

//----- (000466FC) --------------------------------------------------------
int __fastcall sub_466FC(unsigned int a1)
{
  int v2; // esi
  int v3; // ecx
  _WORD *i; // esi
  int v5; // eax
  int v6; // ebx
  unsigned int j; // esi
  int result; // eax
  int v9; // eax
  int v10; // eax
  int v11; // ebx
  char v12; // dl
  int v13; // edx
  int v14; // eax
  __int64 v15[3]; // [esp+8h] [ebp-3Ch]
  int v16; // [esp+20h] [ebp-24h]
  int v17; // [esp+24h] [ebp-20h]
  int v18; // [esp+28h] [ebp-1Ch]

  v2 = 0;
  v18 = 0;
  while ( SHIWORD(dword_A3CF2) > v18 )
  {
    v2 += 2;
    ++v18;
    *(_WORD *)((char *)v15 + v2 + 6) = 0;
  }
  v3 = 0;
  for ( i = &unk_BB1B3; ; i = (_WORD *)((char *)i + 0x7B) )
  {
    v18 = v3;
    if ( SHIWORD(dword_CA1ED) <= v3 )
    {
      break;
    }
    v5 = *((unsigned __int8 *)i + 0x57);
    if ( v5 < SHIWORD(dword_A3CF2) )
    {
      if ( (_BYTE)v5 != (_BYTE)byte_104BEA && byte_A3D20 == 2 && (unsigned __int16)i[0x23] < 0xFu )
      {
        ++*((_WORD *)&v15[1] + v5);
      }
      *((_WORD *)&v15[1] + *((unsigned __int8 *)i + 0x57)) += i[0x23];
    }
    v3 = v18 + 1;
  }
  v6 = 0;
  for ( j = a1; ; j += 2 )
  {
    v18 = v6;
    result = SHIWORD(dword_A3CF2);
    if ( SHIWORD(dword_A3CF2) <= v6 )
    {
      break;
    }
    if ( *(unsigned __int16 *)(j + 0x1D4E) == 0xFFFF )
    {
      *(_WORD *)(j + 0x1D5C) = 0;
    }
    else
    {
      v9 = *((unsigned __int16 *)&v15[1] + v6);
      v17 = (unsigned __int16)v9;
      if ( (_WORD)v9 )
      {
        v16 = v9 + 1;
        v17 = (int)pow((double)(v9 + 1), 0.85);
      }
      v10 = 0x4B * *(unsigned __int16 *)(j + 0x1D4E);
      *(_WORD *)(j + 0x1D5C) += v17;
      if ( *(_WORD *)(j + 0x1D5C) >= *(_WORD *)(a1 + v10 + 0x3E) )
      {
        v11 = *(unsigned __int16 *)(j + 0x1D4E);
        v12 = 1 << v18;
        *(_BYTE *)(a1 + 0x4B * (unsigned __int16)v11 + 0x4A) |= 1 << v18;
        *(_BYTE *)(a1 + 0x4B * *(unsigned __int16 *)(j + 0x1D4E) + 0x4B) |= v12;
        v13 = v18;
        *(_WORD *)(j + 0x1D4E) = 0xFFFF;
        v14 = (unsigned __int8)byte_104BEA;
        *(_WORD *)(j + 0x1D5C) = 0;
        if ( v14 == v13 )
        {
          sub_55AEC((int)&V_Type3_stru_10AE70, 0, v11, 0);
          sub_468BC(a1);
        }
      }
    }
    v6 = v18 + 1;
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;
// CA1ED: using guessed type int dword_CA1ED;

//----- (000468BC) --------------------------------------------------------
unsigned int __fastcall sub_468BC(unsigned int result)
{
  unsigned int v1; // esi

  v1 = result;
  if ( !*(_DWORD *)(result + 0x1D6E) )
  {
    result = sub_46900((char *)result, byte_104BEA);
    if ( result == 0xFFFFFFFF )
    {
      result = sub_55AEC((int)&V_Type3_stru_10AE70, 0x15, 0, 0);
      *(_DWORD *)(v1 + 0x1D6E) = 0xFFFFFFFF;
    }
  }
  return result;
}

//----- (00046900) --------------------------------------------------------
unsigned int __fastcall sub_46900(char *a1, char a2)
{
  int v2; // edx

  v2 = 1 << a2;
  if ( (v2 & a1[0x4A]) != 0 && (v2 & a1[0x95]) != 0 && (v2 & a1[0xE0]) != 0 && (v2 & a1[0x12B]) != 0 )
  {
    return 0xFFFFFFFF;
  }
  else
  {
    return 0;
  }
}

//----- (0004694C) --------------------------------------------------------
unsigned int __fastcall sub_4694C(int a1, unsigned __int16 a2, __int16 a3)
{
  char v4; // di
  unsigned int v5; // ebp
  int i; // eax

  v4 = a3;
  if ( a3 == 0xFFFFFFFF )
  {
    v4 = byte_104BEA;
  }
  v5 = 0xFFFFFFFF;
  if ( ((1 << v4) & *(char *)(a1 + 0x4B * a2 + 0x4A)) == 0 )
  {
    for ( i = 0; i < 5; ++i )
    {
      if ( *(unsigned __int8 *)(a1 + 0x4B * a2 + i + 0x40) == 0xFF )
      {
        break;
      }
      if ( ((1 << v4) & *(char *)(a1 + 0x4B * *(unsigned __int8 *)(a1 + 0x4B * a2 + i + 0x40) + 0x4A)) == 0 )
      {
        v5 = 0;
      }
    }
  }
  return v5;
}

//----- (000469F0) --------------------------------------------------------
int __fastcall sub_469F0(int a1, unsigned __int16 a2)
{
  int v3; // edx
  _WORD *v4; // eax
  int v5; // ebx
  int v7; // [esp+14h] [ebp-10h]

  if ( a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\research.cpp", 0x116);
  }
  v3 = 0;
  v4 = &unk_BB1B3;
  v7 = 0;
  while ( v3 < SHIWORD(dword_CA1ED) )
  {
    v5 = *((unsigned __int8 *)v4 + 0x57);
    if ( v5 == a2 )
    {
      LOWORD(v5) = v4[0x23];
      v7 += v5;
    }
    v4 = (_WORD *)((char *)v4 + 0x7B);
    ++v3;
  }
  if ( v7 )
  {
    return (int)pow((double)(v7 + 1), 0.85);
  }
  return v7;
}
// A3CF2: using guessed type int dword_A3CF2;
// CA1ED: using guessed type int dword_CA1ED;

//----- (00046A94) --------------------------------------------------------
__int16 __fastcall sub_46A94(unsigned __int16 *a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 *v4; // ebx
  unsigned __int16 v5; // dx
  int i; // eax
  unsigned __int16 v7; // cx
  int v8; // edi
  char *v9; // esi
  char v10; // dl
  __int16 v12[100]; // [esp+0h] [ebp-E0h]
  int v13; // [esp+C8h] [ebp-18h]
  int v14; // [esp+CCh] [ebp-14h]

  LOWORD(v14) = a2;
  v13 = a3;
  if ( a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\research.cpp", 0x12D);
  }
  v4 = a1;
  v5 = 0;
  for ( i = 0; i < *a1; ++i )
  {
    if ( i != a1[(unsigned __int16)v14 + 0xEA7] && ((1 << v14) & (char)v4[0x25]) == 0 )
    {
      v7 = v5++;
      v12[v7] = i;
    }
    v4 = (unsigned __int16 *)((char *)v4 + 0x4B);
  }
  if ( v5 )
  {
    v8 = (unsigned __int16)v12[rand() % v5];
    v9 = (char *)a1 + 0x4B * (unsigned __int16)v8;
    v10 = (1 << v14) | v9[0x4B];
    v9[0x4A] |= 1 << v14;
    v9[0x4B] = v10;
    LOWORD(i) = v14;
    if ( (unsigned __int16)v14 == (unsigned __int8)byte_104BEA )
    {
      LOWORD(i) = sub_55AEC((int)&V_Type3_stru_10AE70, 0x16, v8, v13);
    }
  }
  return i;
}
// A3CF2: using guessed type int dword_A3CF2;
// 46A94: using guessed type __int16 var_E0[100];

//----- (00046BB0) --------------------------------------------------------
int __fastcall sub_46BB0(_WORD *a1, unsigned int count, int a3)
{
  int result; // eax
  _BYTE v5[7536]; // [esp+0h] [ebp-1D80h] BYREF
  __int16 v6; // [esp+1D70h] [ebp-10h]

  if ( a3 != 0xFFFFFFFF )
  {
    return sub_1C098(count, (int)a1, 0x1D72u);
  }
  sub_46480((int)v5, 0);
  result = sub_1BF94((P_Type1)count, v5, 0x1D72u);
  qmemcpy(a1, v5, 0x1D70u);
  a1[0xEB8] = v6;
  return result;
}

//----- (00046C10) --------------------------------------------------------
int __fastcall sub_46C10(int a1)
{
  sub_46480(a1, 0);
  return a1;
}

//----- (00046C20) --------------------------------------------------------
int __fastcall sub_46C20(int a1, int a2, int a3)
{
  int result; // eax

  result = 0xFFFF;
  if ( a3 > 0 )
  {
    result = (a1 - a2 - 1) / a3 + 1;
  }
  if ( result < 1 )
  {
    return 1;
  }
  return result;
}

//----- (00046C48) --------------------------------------------------------
void *__fastcall sub_46C48(int a1, char a2)
{
  void *v3; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  void *v9; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96004);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    v5 = a1 + 0x143;
    *(_DWORD *)(v5 - 0x9C) = off_96018;
    v6 = sub_1A9E0(v5);
    v7 = ((int (__fastcall *)(int, _DWORD, int))locret_1B66C)(v6 - 0x98, 0, a1);
    v8 = (void *)sub_2C848(v7 - 0xAB, 1);
    v9 = v8;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v8);
    }
    return v9;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 96018: using guessed type int (*off_96018[5])();

//----- (00046CAC) --------------------------------------------------------
int __fastcall sub_46CAC(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  double v6; // st7
  int v7; // ebx
  int v8; // ebx
  FILE *v9; // eax
  FILE *v10; // esi
  int v11; // edx
  int v12; // ebx
  int v13; // eax
  int result; // eax
  int v15; // esi
  int v16; // edi
  int v17; // ecx
  int v18; // eax
  int i; // ebx
  int v20; // edx
  int v21; // edx
  int v22; // edx
  int v23; // ebp
  float *v24; // ebx
  int v25; // edi
  int v26; // ecx
  float v27; // [esp-4h] [ebp-124h]
  char v28[100]; // [esp+0h] [ebp-120h] BYREF
  char s[100]; // [esp+64h] [ebp-BCh] BYREF
  int v30; // [esp+C8h] [ebp-58h] BYREF
  int v31; // [esp+CCh] [ebp-54h] BYREF
  int v32; // [esp+D0h] [ebp-50h] BYREF
  int v33; // [esp+D4h] [ebp-4Ch]
  int v34; // [esp+D8h] [ebp-48h]
  int v35; // [esp+DCh] [ebp-44h]
  float *v36; // [esp+E0h] [ebp-40h]
  int v37; // [esp+E4h] [ebp-3Ch]
  int v38; // [esp+E8h] [ebp-38h]
  int v39; // [esp+ECh] [ebp-34h]
  int v40; // [esp+F0h] [ebp-30h]
  int v41; // [esp+F4h] [ebp-2Ch]
  int v42; // [esp+F8h] [ebp-28h]
  int v43; // [esp+FCh] [ebp-24h]
  float v44; // [esp+100h] [ebp-20h]
  int v45; // [esp+104h] [ebp-1Ch]

  v5 = a1 + 0x143;
  *(_WORD *)(v5 + 0x898) = 0xFFFF;
  v39 = 0;
  do
  {
    *(_DWORD *)v5 = 0;
    v6 = (double)v39;
    *(_DWORD *)(v5 + 8) = 0;
    v7 = v39;
    *(float *)(v5 + 4) = v6;
    v8 = v7 + 1;
    v5 += 0xC;
    v39 = v8;
  }
  while ( v8 < 0x64 );
  sub_1B808((_DWORD *)(a1 + 0xAB), 0, v8, a4, 0x41F00000, 0x3F800000, 0x47C35000, 0x140);
  *(_DWORD *)(a1 + 0xDF) = 0;
  *(_DWORD *)(a1 + 0xE3) = 0;
  *(_DWORD *)(a1 + 0xE7) = 0xC3160000;
  v9 = sub_1BB10("reswin.txt", 0);
  v10 = v9;
  if ( v9 )
  {
    fscanf(v9, "%d", &v30);
    if ( (unsigned __int16)word_105258 == v30 )
    {
      v11 = a1 + 0x143;
      v12 = 0;
      while ( v12 < (unsigned __int16)word_105258 )
      {
        v11 += 0xC;
        fscanf(v10, "%d %d %d", &v30, &v31, &v32);
        ++v12;
        v33 = v31;
        v13 = v32;
        *(float *)(v11 - 0xC) = (float)v30;
        v34 = v13;
        *(float *)(v11 - 8) = (float)v33;
        *(float *)(v11 - 4) = (float)v34;
      }
    }
    return fclose(v10);
  }
  else
  {
    if ( dword_105254 != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\reswin.cpp", 0x76);
    }
    memset(s, 0xFF, sizeof(s));
    v15 = 0;
    do
    {
      v16 = 0;
      v41 = 0xFFFFFFFF;
      v45 = 0;
      while ( v16 < (unsigned __int16)word_105258 )
      {
        if ( (unsigned __int8)s[v16] == 0xFF )
        {
          v17 = v45;
          v18 = 0;
          for ( i = 0; i < 5; ++i )
          {
            v20 = (unsigned __int8)byte_105298[v17];
            if ( v20 == 0xFF )
            {
              break;
            }
            v21 = (unsigned __int8)s[v20];
            if ( v21 == 0xFF )
            {
              v41 = 0;
              LOBYTE(v18) = 0xFF;
              break;
            }
            if ( v21 >= v18 )
            {
              v18 = v21 + 1;
              if ( v21 + 1 >= v15 )
              {
                v15 = v21 + 2;
              }
            }
            ++v17;
          }
          s[v16] = v18;
        }
        ++v16;
        v45 += 0x4B;
      }
    }
    while ( !v41 );
    memset(v28, 0, sizeof(v28));
    for ( result = 0; result < (unsigned __int16)word_105258; ++result )
    {
      v22 = (unsigned __int8)s[result];
      ++v28[v22];
    }
    v42 = 0;
    if ( v15 > 0 )
    {
      v38 = 0;
      v36 = (float *)(a1 + 0x143);
      v37 = 0xF0;
      do
      {
        v43 = 4;
        v44 = (float)v37;
        v23 = (unsigned __int8)v28[v42];
        if ( v42 % 2 && (unsigned __int8)v28[v42] > 2u )
        {
          --v23;
        }
        else if ( (unsigned __int8)v28[v42] > 1u )
        {
          v43 = 0x17;
        }
        v24 = v36;
        v25 = 0;
        v26 = 0;
        v40 = v38;
        while ( v26 < (unsigned __int16)word_105258 )
        {
          if ( (unsigned __int8)s[v26] == v42 )
          {
            v35 = 0xF * (v25 & 1) + v40;
            v24[1] = (float)v35;
            v24[2] = (float)v43;
            v27 = v44;
            *v24 = 0.0;
            sub_532AC(v24, v27);
            v35 = 0x168 / v23;
            ++v25;
            v43 = 0x17;
            v44 = (double)(0x168 / v23) + v44;
          }
          v24 += 3;
          ++v26;
        }
        result = v42 + 1;
        v37 += 0x1E;
        v38 += 0x1E;
        v42 = result;
      }
      while ( v15 > result );
    }
  }
  return result;
}
// 105254: using guessed type int dword_105254;
// 46CAC: using guessed type char s[100];
// 46CAC: using guessed type char var_120[100];

//----- (00047088) --------------------------------------------------------
int __fastcall sub_47088(int a1)
{
  int v1; // ebp
  int v2; // ecx
  int v3; // edi
  int v4; // esi
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int result; // eax
  int v10; // [esp+4h] [ebp-20h]
  int v11; // [esp+8h] [ebp-1Ch]

  v11 = 0xFFFF;
  v1 = dword_D8648 - *(_DWORD *)(a1 + 8);
  v2 = (unsigned __int16)word_105258 - 1;
  v10 = dword_D864C - *(_DWORD *)(a1 + 0xC);
  if ( v2 >= 0 )
  {
    v3 = a1 + 2 * v2;
    while ( 1 )
    {
      v4 = *(unsigned __int16 *)(v3 + 0x913);
      if ( sub_4694C((int)&word_105258, v4, 0xFFFFFFFF) )
      {
        v5 = a1 + 2 * v4;
        v6 = *(__int16 *)(v5 + 0x5F3);
        if ( v1 > v6 - 0x19 && v1 < v6 + 0x19 )
        {
          v7 = *(__int16 *)(v5 + 0x6BB);
          if ( v7 - 0x19 < v10 && v7 + 0x19 > v10 )
          {
            break;
          }
        }
      }
      --v2;
      v3 -= 2;
      if ( v2 < 0 )
      {
        goto LABEL_12;
      }
    }
    v11 = v4;
  }
LABEL_12:
  result = v11;
  if ( (_WORD)v11 != *(_WORD *)(a1 + 0x9DB) )
  {
    *(_WORD *)(a1 + 0x9DB) = v11;
    dword_106FD0 = 0xFFFFFFFF;
    dword_106FD4 = 0xFFFFFFFF;
  }
  return result;
}
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;
// 106FD0: using guessed type int dword_106FD0;
// 106FD4: using guessed type int dword_106FD4;

//----- (00047224) --------------------------------------------------------
unsigned int __fastcall sub_47224(int a1, unsigned __int16 a2, int a3, unsigned int a4)
{
  int v8; // edx
  char v9; // cl
  int v10; // eax
  char v11; // bh
  int v12; // edx
  char v13; // cl
  int v14; // eax
  char v15; // ch
  int v16; // eax
  unsigned __int8 v17; // cl
  int v18; // eax
  int v19; // edx
  char v20; // cl
  int v21; // eax
  char v22; // bh
  int v23; // ebx
  int v24; // ebx
  int v25; // eax
  double v26; // st7
  int v27; // edx
  int v28; // edx
  __int16 v29; // ax
  float v31; // [esp+10h] [ebp-14h]
  float v32; // [esp+10h] [ebp-14h]
  float v33; // [esp+14h] [ebp-10h]
  int v34; // [esp+14h] [ebp-10h]

  if ( a2 < 6u )
  {
    if ( a2 < 2u )
    {
      if ( a2 != 1 )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFED8);
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDC);
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEBC[(unsigned __int8)byte_104BEA]);
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
      dword_106FD8 = 0;
      dword_106FCC = 0xFFFFFFFF;
      dword_106FD0 = 0xFFFFFFFF;
      *(_WORD *)(a1 + 0x9DB) = 0xFFFF;
      sub_2F424(a1, 1, a3, a4);
      sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x3A, 0, 0, 0);
      return 0;
    }
    if ( a2 <= 2u )
    {
      v8 = 0;
      v9 = 1 << byte_104BEA;
      v10 = 0;
      while ( v8 < (unsigned __int16)word_105258 )
      {
        v11 = byte_1052A3[v10];
        v10 += 0x4B;
        ++v8;
        *((_BYTE *)&word_105258 + v10) = ~v9 & v11;
      }
      sub_2F424(a1, a2, a3, a4);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      return 0;
    }
    if ( a2 > 3u )
    {
      if ( !*(_DWORD *)(a1 + 0x35) )
      {
        return 0;
      }
      HIWORD(v28) = 0;
      sub_47088(a1);
      LOWORD(v28) = *(_WORD *)(a1 + 0x9DB);
      if ( (unsigned __int16)v28 == 0xFFFF
        || ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v28) >> 0x18)) != 0
        || !sub_4694C((int)&word_105258, v28, 0xFFFFFFFF) )
      {
        return 0;
      }
      sub_4FB90((int)&unk_10914C, 0);
      dword_106FD4 = 0xFFFFFFFF;
      v29 = *(_WORD *)(a1 + 0x9DB);
      dword_106FD0 = 0xFFFFFFFF;
      word_106FA6[(unsigned __int8)byte_104BEA] = v29;
      return 0;
    }
    if ( a4 < 0x2E )
    {
      if ( a4 < 0xD )
      {
        if ( a4 == 0xC && flt_12FC1C > dbl_92664 )
        {
          flt_12FC1C = flt_12FC1C * dbl_9266C;
          sub_47088(a1);
          return 0;
        }
        goto LABEL_60;
      }
      if ( a4 <= 0xD )
      {
        if ( flt_12FC1C < (double)flt_92658 )
        {
          flt_12FC1C = flt_12FC1C * dbl_9265C;
          sub_47088(a1);
          return 0;
        }
        goto LABEL_60;
      }
      if ( a4 >= 0x20 )
      {
        if ( a4 <= 0x20 )
        {
          if ( !dword_A0CFC )
          {
            goto LABEL_60;
          }
          v12 = 0;
          v13 = 1 << byte_104BEA;
          v14 = 0;
          while ( v12 < (unsigned __int16)word_105258 )
          {
            v15 = *((_BYTE *)&dword_10529F + v14 + 3);
            v14 += 0x4B;
            ++v12;
            *((_BYTE *)&dword_105254 + v14 + 3) = v13 | v15;
          }
        }
        else
        {
          if ( a4 != 0x21 || !dword_A0CFC )
          {
            goto LABEL_60;
          }
          v19 = 0;
          v20 = 1 << byte_104BEA;
          v21 = 0;
          while ( v19 < (unsigned __int16)word_105258 )
          {
            v22 = *((_BYTE *)&dword_10529F + v21 + 3);
            v21 += 0x4B;
            ++v19;
            *((_BYTE *)&dword_105254 + v21 + 3) = ~v20 & v22;
          }
        }
        v16 = (unsigned __int8)byte_104BEA;
        word_106FA6[(unsigned __int8)byte_104BEA] = 0xFFFF;
        word_106FB4[v16] = 0;
        sub_47088(a1);
        return 0;
      }
    }
    else
    {
      if ( a4 > 0x2E )
      {
        if ( a4 < 0x49 )
        {
          if ( a4 < 0x32 )
          {
            goto LABEL_60;
          }
          if ( a4 <= 0x32 )
          {
            dword_106FC2 = ~dword_106FC2;
            sub_5A320(0x14);
            dword_106FCC = 0xFFFFFFFF;
            dword_106FD4 = 0xFFFFFFFF;
            sub_47088(a1);
            return 0;
          }
          if ( a4 != 0x47 )
          {
            goto LABEL_60;
          }
        }
        else if ( a4 > 0x49 )
        {
          if ( a4 >= 0x4F && (a4 <= 0x4F || a4 == 0x51) )
          {
            v24 = *(_DWORD *)(a1 + 0xA7);
            *(_DWORD *)(a1 + 0xE3) = 0x49742400;
            (*(void (__fastcall **)(int, _DWORD))(v24 + 0xC))(a1, 0);
            sub_47088(a1);
            return 0;
          }
          goto LABEL_60;
        }
        v23 = *(_DWORD *)(a1 + 0xA7);
        *(_DWORD *)(a1 + 0xE3) = 0xC2C80000;
        (*(void (__fastcall **)(int, _DWORD))(v23 + 0xC))(a1, 0);
        sub_47088(a1);
        return 0;
      }
      if ( dword_A0CFC && (unsigned __int16)word_106FA6[(unsigned __int8)byte_104BEA] != 0xFFFF )
      {
        v17 = byte_104BEA;
        v18 = 0x4B * (unsigned __int16)word_106FA6[(unsigned __int8)byte_104BEA];
        *((_BYTE *)&dword_10529F + v18 + 3) |= 1 << byte_104BEA;
        word_106FA6[v17] = 0xFFFF;
        word_106FB4[v17] = 0;
        sub_47088(a1);
        return 0;
      }
    }
LABEL_60:
    sub_47088(a1);
    return 0;
  }
  if ( a2 <= 6u )
  {
    sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 8);
    sub_47088(a1);
    if ( (*(_DWORD *)(a1 + 0x3D) & *(_DWORD *)(a1 + 0x35) & *(_DWORD *)(a1 + 0x39)) == 0xFFFFFFFF )
    {
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
    }
    return 0xFFFFFFFF;
  }
  if ( a2 < 0x32u )
  {
    if ( a2 <= 7u )
    {
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
      sub_47088(a1);
      if ( (*(_DWORD *)(a1 + 0x3D) & *(_DWORD *)(a1 + 0x35) & *(_DWORD *)(a1 + 0x39)) == 0xFFFFFFFF )
      {
        (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0x10))();
      }
      return 0xFFFFFFFF;
    }
    if ( a2 != 8 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    goto LABEL_60;
  }
  if ( a2 <= 0x35u )
  {
    if ( a2 == 0x32 )
    {
      if ( (dword_106FD8 & 4) != 0 )
      {
        if ( (dword_106FD8 & 8) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xF7;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFB;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 & 0xF3 | 4;
      }
    }
    if ( a2 == 0x33 )
    {
      if ( (dword_106FD8 & 4) != 0 )
      {
        if ( (dword_106FD8 & 8) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFB;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 | 8;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 | 0xC;
      }
    }
    if ( a2 == 0x34 )
    {
      if ( (dword_106FD8 & 1) != 0 )
      {
        if ( (dword_106FD8 & 2) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFD;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFE;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 & 0xFC | 1;
      }
    }
    if ( a2 == 0x35 )
    {
      if ( (dword_106FD8 & 1) != 0 )
      {
        if ( (dword_106FD8 & 2) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFE;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 | 2;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 | 3;
      }
    }
    if ( a3 != 4 )
    {
      return 0;
    }
    v25 = 4;
    if ( a2 == 0x34 || a2 == 0x35 )
    {
      v25 = 1;
    }
    sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 1, 0x38, v25, 0);
    return 0;
  }
  else
  {
    if ( a2 < 0x38u )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( a2 > 0x38u )
    {
      if ( a2 != 0x3A )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      if ( (dword_106FD8 & 4) != 0 )
      {
        v33 = 3.0;
        if ( (dword_106FD8 & 8) != 0 )
        {
          v33 = -3.0;
        }
        *(float *)&v34 = v33 * flt_12FC1C;
        sub_53564((float *)(a1 + 0x11F), a2, a3, 0xFFFFFFFF, v34);
        dword_106FD4 = 0xFFFFFFFF;
      }
      if ( (dword_106FD8 & 1) != 0 )
      {
        v31 = -2.0;
        if ( (dword_106FD8 & 2) != 0 )
        {
          v31 = 2.0;
        }
        v32 = v31 * flt_12FC1C;
        v26 = *(float *)(a1 + 0xE3) + v32;
        dword_106FD4 = 0xFFFFFFFF;
        *(float *)(a1 + 0xE3) = v26;
      }
      if ( dword_106FD4 == 0xFFFFFFFF )
      {
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
        return 0;
      }
      return 0;
    }
    v27 = *(_DWORD *)(a1 + 0x41);
    dword_106FD8 &= ~a3;
    sub_567BC((int)&V_Type3_stru_10AE70, v27, 0xFFFFFFFF);
    return 0;
  }
}
// 92658: using guessed type float flt_92658;
// 9265C: using guessed type double dbl_9265C;
// 92664: using guessed type double dbl_92664;
// 9266C: using guessed type double dbl_9266C;
// A0CFC: using guessed type int dword_A0CFC;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFED8: using guessed type __int16 word_FFED8;
// FFEDC: using guessed type __int16 word_FFEDC;
// FFEDE: using guessed type __int16 word_FFEDE;
// 105254: using guessed type int dword_105254;
// 10529F: using guessed type int dword_10529F;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];
// 106FC2: using guessed type int dword_106FC2;
// 106FCC: using guessed type int dword_106FCC;
// 106FD0: using guessed type int dword_106FD0;
// 106FD4: using guessed type int dword_106FD4;
// 106FD8: using guessed type int dword_106FD8;
// 12FC1C: using guessed type float flt_12FC1C;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00047A64) --------------------------------------------------------
int __fastcall sub_47A64(const void *a1, const void *a2)
{
  unsigned __int16 v2; // si
  BOOL v3; // edx

  v2 = *(_WORD *)a2;
  v3 = *(float *)(dword_106FDC + 4 * *(unsigned __int16 *)a2) > (double)*(float *)(dword_106FDC
                                                                                 + 4 * *(unsigned __int16 *)a1);
  if ( *(float *)(dword_106FDC + 4 * v2) < (double)*(float *)(dword_106FDC + 4 * *(unsigned __int16 *)a1) )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}
// 106FDC: using guessed type int dword_106FDC;

//----- (00047ABC) --------------------------------------------------------
__int16 __fastcall sub_47ABC(int a1)
{
  T_Type5 *v2; // esi
  int v3; // ecx
  int v4; // edx
  int v5; // ebx
  float v6; // eax
  float *v7; // ecx
  int v8; // esi
  int v9; // edi
  int v10; // ebx
  int v11; // edx
  int v12; // eax
  char v13; // bl
  unsigned __int16 v14; // dx
  int v15; // edx
  int v16; // eax
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  __int16 v20; // ax
  int v21; // eax
  int v22; // esi
  unsigned __int16 v23; // dx
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // ebx
  char *sub_1CEA8; // eax
  int v29; // esi
  int v30; // eax
  int v31; // eax
  int v32; // ebx
  unsigned __int16 v33; // di
  int v34; // eax
  int v35; // edi
  int v36; // esi
  int v37; // eax
  int v38; // edx
  int v39; // ebx
  int v40; // eax
  int v41; // edx
  char *v42; // edi
  char *v43; // esi
  char v44; // al
  char v45; // al
  int v46; // eax
  char *v47; // eax
  int v48; // esi
  char *v49; // eax
  char *v50; // eax
  int v51; // esi
  unsigned __int16 v52; // dx
  unsigned __int16 v53; // ax
  int v54; // ebp
  int v55; // eax
  int v56; // eax
  const char *v57; // edi
  char *v58; // eax
  int v59; // esi
  int v60; // ebp
  int v61; // esi
  char *v62; // eax
  unsigned __int16 v63; // di
  __int16 v64; // dx
  char *v65; // eax
  int v66; // esi
  unsigned __int16 v67; // dx
  int v68; // eax
  int v69; // eax
  int v70; // esi
  char *v71; // eax
  char *v72; // eax
  int v74; // [esp-20h] [ebp-170h]
  int v75; // [esp-1Ch] [ebp-16Ch]
  int v76; // [esp-1Ch] [ebp-16Ch]
  int v77; // [esp-1Ch] [ebp-16Ch]
  int v78; // [esp-18h] [ebp-168h]
  int v79; // [esp-18h] [ebp-168h]
  int v80; // [esp-18h] [ebp-168h]
  void (__noreturn *v81)(); // [esp-Ch] [ebp-15Ch]
  __int16 v82; // [esp-Ch] [ebp-15Ch]
  __int16 v83; // [esp-Ch] [ebp-15Ch]
  void (__noreturn *v84)(); // [esp-Ch] [ebp-15Ch]
  __int16 v85; // [esp-Ch] [ebp-15Ch]
  __int16 v86; // [esp-Ch] [ebp-15Ch]
  __int16 v87; // [esp-Ch] [ebp-15Ch]
  void (__noreturn *v88)(); // [esp-8h] [ebp-158h]
  int v89; // [esp-8h] [ebp-158h]
  int v90; // [esp-8h] [ebp-158h]
  int v91; // [esp-8h] [ebp-158h]
  void (__noreturn *v92)(); // [esp-8h] [ebp-158h]
  char *v93; // [esp-8h] [ebp-158h]
  int v94; // [esp-4h] [ebp-154h]
  const void *v95; // [esp-4h] [ebp-154h]
  int v96; // [esp-4h] [ebp-154h]
  int v97; // [esp-4h] [ebp-154h]
  int v98; // [esp-4h] [ebp-154h]
  char *v99; // [esp-4h] [ebp-154h]
  char *v100; // [esp-4h] [ebp-154h]
  char v101[100]; // [esp+0h] [ebp-150h]
  char s[80]; // [esp+64h] [ebp-ECh] BYREF
  T_Type5 v103; // [esp+B4h] [ebp-9Ch] BYREF
  T_Type5 v104; // [esp+C8h] [ebp-88h] BYREF
  int v105[2]; // [esp+DCh] [ebp-74h] BYREF
  int v106; // [esp+E4h] [ebp-6Ch]
  int v107; // [esp+E8h] [ebp-68h] BYREF
  int v108; // [esp+ECh] [ebp-64h] BYREF
  float v109; // [esp+F0h] [ebp-60h]
  int v110; // [esp+F4h] [ebp-5Ch]
  int a2; // [esp+F8h] [ebp-58h]
  int v112; // [esp+FCh] [ebp-54h]
  int v113; // [esp+100h] [ebp-50h]
  float *v114; // [esp+104h] [ebp-4Ch]
  float v115; // [esp+108h] [ebp-48h]
  int v116; // [esp+10Ch] [ebp-44h]
  int v117; // [esp+110h] [ebp-40h]
  int v118; // [esp+114h] [ebp-3Ch]
  int v119; // [esp+118h] [ebp-38h]
  int v120; // [esp+11Ch] [ebp-34h]
  int v121; // [esp+120h] [ebp-30h]
  int v122; // [esp+124h] [ebp-2Ch]
  int v123; // [esp+128h] [ebp-28h]
  int v124; // [esp+12Ch] [ebp-24h]
  int **v125; // [esp+130h] [ebp-20h]
  int v126; // [esp+134h] [ebp-1Ch]
  int v127; // [esp+138h] [ebp-18h]

  v103 = *(T_Type5 *)(a1 + 4);
  v2 = (T_Type5 *)(a1 + 4);
  sub_5E9D0((P_Type5)(a1 + 4), 0);
  sub_552CC(&V_Type3_stru_10AE70, v2);
  v3 = a1;
  v4 = 0;
  v115 = *(float *)(a1 + 0x147);
  v109 = v115;
  for ( a2 = 0; ; ++a2 )
  {
    v5 = a2;
    if ( (unsigned __int16)word_105258 <= a2 )
    {
      break;
    }
    v4 = (unsigned __int16)a2;
    if ( sub_4694C((int)&word_105258, a2, 0xFFFFFFFF) )
    {
      if ( *(float *)(v3 + 0x147) < (double)v109 )
      {
        v109 = *(float *)(v3 + 0x147);
      }
      if ( *(float *)(v3 + 0x147) > (double)v115 )
      {
        v115 = *(float *)(v3 + 0x147);
      }
    }
    v3 += 0xC;
  }
  if ( *(float *)(a1 + 0xE3) >= (double)v109 )
  {
    if ( *(float *)(a1 + 0xE3) <= (double)v115 )
    {
      goto LABEL_14;
    }
    v6 = v115;
  }
  else
  {
    v6 = v109;
  }
  *(float *)(a1 + 0xE3) = v6;
LABEL_14:
  sub_1B864(a1 + 0xAB, v4, v5, v3);
  a2 = 0;
  v7 = (float *)(a1 + 0x143);
  v8 = a1 + 0x6BB;
  v9 = a1 + 0x5F3;
  v114 = (float *)(a1 + 0xEB);
  v119 = a1;
  v117 = a1;
  while ( (unsigned __int16)word_105258 > a2 )
  {
    v105[0] = 0;
    v105[1] = 0;
    v106 = 0;
    sub_53384(v7, v114, (float *)v105);
    v94 = v8;
    v10 = a2;
    v7 += 3;
    v8 += 2;
    *(_DWORD *)(v117 + 0x783) = v106;
    v11 = v119;
    sub_533D4((float *)v105, *(float *)(a1 + 0xD3), 0xEB, 0xF0, v9, v94);
    *(_WORD *)(v11 + 0x913) = a2;
    v9 += 2;
    a2 = v10 + 1;
    v119 = v11 + 2;
    v117 += 4;
  }
  dword_106FDC = a1 + 0x783;
  qsort((void *)(a1 + 0x913), (unsigned __int16)word_105258, 2u, sub_47A64);
  v12 = a1;
  a2 = 0;
  while ( (unsigned __int16)word_105258 > a2 )
  {
    v13 = a2;
    v14 = *(_WORD *)(v12 + 0x913);
    v12 += 2;
    ++a2;
    v101[v14] = v13;
  }
  v126 = (unsigned __int16)word_106FA6[(unsigned __int8)byte_104BEA];
  a2 = 0;
  v125 = (int **)(a1 + 4);
  v118 = a1;
  while ( 1 )
  {
    LOWORD(v26) = word_105258;
    if ( (unsigned __int16)word_105258 <= a2 )
    {
      break;
    }
    v123 = *(unsigned __int16 *)(v118 + 0x913);
    if ( sub_4694C((int)&word_105258, v123, 0xFFFFFFFF) )
    {
      v120 = (int)((*(float *)(a1 + 4 * v123 + 0x783) + *(float *)(a1 + 0xE7)) * flt_92697);
      if ( v120 >= (int)0xFFFFFFFD )
      {
        if ( v120 > 3 )
        {
          v120 = 3;
        }
      }
      else
      {
        v120 = 0xFFFFFFFD;
      }
      v95 = (const void *)(((v120 + 3) << 8) + 0x100 + dword_D8D8F);
      v120 += 3;
      sub_5D007(v95);
      v121 = 0;
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v123) >> 0x18)) != 0 )
      {
        v121 = 0x14;
      }
      else if ( (unsigned __int16)v126 == v123 )
      {
        v15 = v123 ^ (unsigned __int16)v126;
        LOBYTE(v15) = byte_104BEA;
        v16 = 0x12 * (unsigned __int16)word_106FB4[v15] / *(unsigned __int16 *)((char *)&word_105296 + 0x4B * v123) + 2;
        v121 = v16;
        if ( v16 >= (int)0xFFFFFFEF )
        {
          if ( v16 > 0x11 )
          {
            v121 = 0x11;
          }
        }
        else
        {
          v121 = 0xFFFFFFEF;
        }
      }
      v17 = 0x4B * v123;
      v122 = 2 * v123 + a1;
      v18 = 0;
      v124 = 4 * v123 + a1;
      while ( 1 )
      {
        v19 = (unsigned __int8)byte_105298[v17];
        if ( v19 == 0xFF )
        {
          break;
        }
        if ( sub_4694C((int)&word_105258, (unsigned __int8)byte_105298[v17], 0xFFFFFFFF) )
        {
          v112 = (int)(((*(float *)(v124 + 0x783) + *(float *)(a1 + 4 * v19 + 0x783)) * flt_9269B + *(float *)(a1 + 0xE7))
                     * flt_92697);
          if ( v112 <= 3 )
          {
            if ( v112 < (int)0xFFFFFFFD )
            {
              v112 = 0xFFFFFFFD;
            }
          }
          else
          {
            v112 = 3;
          }
          v20 = 0x6B - v112;
          if ( v19 == *(unsigned __int16 *)(a1 + 0x9DB) )
          {
            v20 = 0xF3;
          }
          sub_5C001(
            v125,
            *(__int16 *)(v122 + 0x5F3),
            *(__int16 *)(v122 + 0x6BB) - 0x1B,
            *(__int16 *)(a1 + 2 * v19 + 0x5F3),
            *(__int16 *)(a1 + 2 * v19 + 0x6BB) + 0x1B,
            0,
            (void (__fastcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v20);
          ++v18;
          ++v17;
          if ( v18 >= 5 )
          {
            break;
          }
        }
        else
        {
          ++v18;
          ++v17;
          if ( v18 >= 5 )
          {
            break;
          }
        }
      }
      if ( v121 )
      {
        v121 = (v121 << 0x10) / 0x14;
        v88 = (void (__noreturn *)())v121;
        v81 = (void (__noreturn *)())v121;
        v78 = *(__int16 *)(a1 + 2 * v123 + 0x6BB);
        v75 = *(__int16 *)(a1 + 2 * v123 + 0x5F3);
        v74 = v123;
        v21 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
        sub_5D631((P_Type5)v125, v21, v74, v75, v78, (int)byte_D8DA0, 0, v81, v88, 1);
      }
      v22 = 1;
      if ( (unsigned __int16)v126 == v123
        && ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v123) >> 0x18)) == 0 )
      {
        v22 = 0;
      }
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v123 + 1) >> 0x18)) != 0 )
      {
        v22 = 3;
      }
      if ( *(unsigned __int16 *)(a1 + 0x9DB) == v123 )
      {
        v22 = 2;
      }
      v23 = sub_1B270((int)dword_12FC20, "data\\resring.shp", 0xFFFFFFFF);
      v24 = a1 + 2 * v123;
      v96 = *(__int16 *)(v24 + 0x6BB);
      v89 = *(__int16 *)(v24 + 0x5F3);
      v25 = sub_1B084((unsigned int)dword_12FC20, v23);
      if ( v22 == 2 )
      {
        sub_5CB3C((P_Type5)v125, v25, 2, v89, v96);
      }
      else
      {
        sub_5D026((P_Type5)v125, v25, v22, v89, v96);
      }
    }
    v118 += 2;
    ++a2;
  }
  v27 = dword_106FD0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
  if ( v27 == 0xFFFFFFFF )
  {
    v103.rect.y2 = 0x1AA;
    v103.rect.x1 = 0x1E5;
    v103.rect.y1 = 7;
    v103.rect.x2 = 0x278;
    sub_5E9D0(&v103, 0);
    sub_552CC(&V_Type3_stru_10AE70, &v103);
    v127 = 0xFFFF;
    if ( (unsigned __int16)v126 != 0xFFFF )
    {
      v127 = (unsigned __int16)v126;
    }
    if ( *(unsigned __int16 *)(a1 + 0x9DB) != 0xFFFF )
    {
      v127 = *(unsigned __int16 *)(a1 + 0x9DB);
    }
    LOWORD(v26) = v127;
    if ( (unsigned __int16)v127 != 0xFFFF )
    {
      *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v103;
      v110 = 0xFFFFFFFF;
      v104 = v103;
      if ( (_WORD)v127 == (_WORD)v126 )
      {
        if ( (_WORD)v127 != *(_WORD *)(a1 + 0x9DB) )
        {
          v110 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
        }
        v82 = v110;
        sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7A);// 122: "Current Project:"
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xA, sub_1CEA8, 2, v82, 0xFFFFFFFF, 0x82);
      }
      v29 = (unsigned __int16)v127;
      v113 = 0x46;
      v104.rect.y2 = 0x78;
      v30 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
      sub_2BC40(&v104, v30, (unsigned __int16)v29, &v107, &v108);
      v97 = v108;
      v90 = v107;
      v31 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
      sub_5CB3C(&v104, v31, (unsigned __int16)v29, v90, v97);
      v32 = 1;
      v33 = sub_1B270((int)dword_12FC20, "data\\resring.shp", 0xFFFFFFFF);
      if ( (_WORD)v29 == (_WORD)v126
        && ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v29) >> 0x18)) == 0 )
      {
        v32 = 0;
      }
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int16)v127 + 1) >> 0x18)) != 0 )
      {
        v32 = 3;
      }
      if ( (_WORD)v127 == *(_WORD *)(a1 + 0x9DB) )
      {
        v32 = 2;
      }
      v98 = v108;
      v91 = v107;
      v34 = sub_1B084((unsigned int)dword_12FC20, v33);
      sub_5CB3C(&v104, v34, v32, v91, v98);
      v36 = 0x4B * (unsigned __int16)v127;
      v113 += 0x19;
      v35 = v113;
      v37 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v113, &byte_10525A[v36], 2, v110, 0xFFFFFFFF, 0x82);
      v38 = *(int *)((char *)&dword_10529F + v36) >> 0x18;
      v113 = v35 + v37;
      if ( ((1 << byte_104BEA) & v38) == 0 )
      {
        v39 = sub_469F0((int)&word_105258, (unsigned __int8)byte_104BEA);
        v40 = sub_46C20(
                *(unsigned __int16 *)((char *)&word_105296 + v36),
                (unsigned __int16)word_106FB4[(unsigned __int8)byte_104BEA],
                v39);
        v41 = v40;
        if ( v40 == 0xFFFF )
        {
          v42 = s;
          v43 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7B);// 123: "(No Progress)"
          do
          {
            v44 = *v43;
            *v42 = *v43;
            if ( !v44 )
            {
              break;
            }
            v45 = v43[1];
            v43 += 2;
            v42[1] = v45;
            v42 += 2;
          }
          while ( v45 );
        }
        else
        {
          if ( v40 == 1 )
          {
            v46 = 0x1C;                                // 28: ""
          }
          else
          {
            v46 = 0x1D;                                // 29: "s"
          }
          v99 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v46);
          v47 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7C);// 124: "(%d day%s)"
          sprintf(s, v47, v41, v99);
        }
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v113, s, 2, v110, 0xFFFFFFFF, 0x82);
      }
      v48 = 0x8E;
      for ( a2 = 0; a2 < 0x27; ++a2 )
      {
        if ( (unsigned __int8)byte_103FA1[0x28 * a2] == (unsigned __int16)v127 )
        {
          if ( v48 == 0x8E )
          {
            v83 = v110;
            v49 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7D);// 125: "Allows"
            v48 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x8E, v49, 2, v83, 0xFFFFFFFF, 0x82) + 0x98;
          }
          v50 = (char *)&dword_103F9A[0xA * a2 + 3];
          if ( (_BYTE)a2 == 0x17 )
          {
            v50 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7E);// 126: "Ships: Small and Medium Hulls"
          }
          v51 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v48, v50, 2, v110, 0xFFFFFFFF, 0x82) + v48;
          v116 = (int)sub_10000;
          v104.rect.y1 = v51 + 1;
          v52 = word_FFEDC;
          v104.rect.y2 = v51 + 0x48;
          v53 = a2;
          if ( (_BYTE)a2 == 0x17 )
          {
            v116 = 0x8000;
            v52 = word_FFEBC[(unsigned __int8)byte_104BEA];
            v53 = 0;
          }
          v54 = v53;
          v55 = sub_1B084((unsigned int)dword_12FC20, v52);
          sub_2BC40(&v104, v55, v54, &v107, &v108);
          v92 = (void (__noreturn *)())v116;
          v84 = (void (__noreturn *)())v116;
          v79 = v108;
          v76 = v107;
          v56 = sub_1B084((unsigned int)dword_12FC20, v52);
          v48 = v51 + 0x48;
          sub_5D631(&v104, v56, v54, v76, v79, (int)byte_D8DA0, 0, v84, v92, 0);
        }
      }
      v57 = (const char *)&unk_107020;
      for ( a2 = 0; a2 < 0x4C; ++a2 )
      {
        if ( (unsigned __int8)byte_107055[0x6A * a2] == (unsigned __int16)v127 )
        {
          if ( v48 == 0x8E )
          {
            v85 = v110;
            v58 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7D);// 125: "Allows"
            v48 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x8E, v58, 2, v85, 0xFFFFFFFF, 0x82) + 0x98;
          }
          v59 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v48, v57, 2, v110, 0xFFFFFFFF, 0x82) + v48;
          v104.rect.y1 = v59 + 1;
          v60 = v59 + 0x48;
          v104.rect.y2 = v59 + 0x48;
          v61 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFED8);
          sub_2BC40(&v104, v61, a2, &v107, &v108);
          sub_5CB3C(&v104, v61, a2, v107, v108);
          v48 = v60;
        }
        v57 += 0x6A;
      }
      v26 = (unsigned __int16)v127;
      if ( (unsigned __int16)v127 == 0x13 || (unsigned __int16)v127 == 0x1F )
      {
        if ( v48 == 0x8E )
        {
          v86 = v110;
          v62 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7D);// 125: "Allows"
          v48 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x8E, v62, 2, v86, 0xFFFFFFFF, 0x82) + 0x98;
        }
        v63 = 2;
        v64 = v127;
        v65 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7F);// 127: "Large Ship Hull"
        if ( v64 == 0x1F )
        {
          v63 = 3;
          v65 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x80);// 128: "Gigantic Ship Hull"
        }
        v66 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v48, v65, 2, v110, 0xFFFFFFFF, 0x82) + v48;
        v104.rect.y1 = v66 + 1;
        v67 = word_FFEBC[(unsigned __int8)byte_104BEA];
        v104.rect.y2 = v66 + 0x48;
        v68 = sub_1B084((unsigned int)dword_12FC20, v67);
        sub_2BC40(&v104, v68, v63, &v107, &v108);
        v80 = v108;
        v77 = v107;
        v69 = sub_1B084((unsigned int)dword_12FC20, v67);
        LOWORD(v26) = (unsigned __int16)sub_5D631(
                                          &v104,
                                          v69,
                                          v63,
                                          v77,
                                          v80,
                                          (int)byte_D8DA0,
                                          0,
                                          (void (__noreturn *)())0x8000,
                                          (void (__noreturn *)())0x8000,
                                          0);
      }
    }
    dword_106FD0 = 0;
  }
  v70 = dword_106FCC;
  if ( dword_106FCC == 0xFFFFFFFF )
  {
    v103.rect.x1 = 7;
    v103.rect.x2 = 0x1DC;
    v103.rect.y2 = 0x25;
    v103.rect.y1 = 7;
    sub_552CC(&V_Type3_stru_10AE70, &v103);
    sub_53E38(&v103, 3, 3, (unsigned __int8)byte_104BEA);
    v71 = (char *)&unk_92696;
    if ( dword_106FC2 == v70 )
    {
      v71 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x81);  // 129: "(Self Managed)"
    }
    v100 = v71;
    v93 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
    v72 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x82);    // 130: "%s Knowledge %s"
    sprintf(s, v72, v93, v100);
    v87 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v103;
    LOWORD(v26) = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, s, 3, v87, 0xFF, 0);
    dword_106FCC = 0;
  }
  dword_106FD4 = 0;
  return v26;
}
// 10000: using guessed type void __noreturn sub_10000();
// 92697: using guessed type float flt_92697;
// 9269B: using guessed type float flt_9269B;
// D8D8F: using guessed type int dword_D8D8F;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFED8: using guessed type __int16 word_FFED8;
// FFEDC: using guessed type __int16 word_FFEDC;
// FFEDE: using guessed type __int16 word_FFEDE;
// 103F9A: using guessed type int dword_103F9A[];
// 105296: using guessed type __int16 word_105296;
// 10529F: using guessed type int dword_10529F;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];
// 106FC2: using guessed type int dword_106FC2;
// 106FCC: using guessed type int dword_106FCC;
// 106FD0: using guessed type int dword_106FD0;
// 106FD4: using guessed type int dword_106FD4;
// 106FDC: using guessed type int dword_106FDC;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 47ABC: using guessed type char var_150[100];

//----- (00048B14) --------------------------------------------------------
int __fastcall sub_48B14(int a1, unsigned int count, int a3)
{
  void *v5; // edx

  v5 = (void *)(a1 + 0xAB);
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, v5, 0x98u);
  }
  else
  {
    return sub_1C098(count, (int)v5, 0x98u);
  }
}

//----- (00048B40) --------------------------------------------------------
int __fastcall sub_48B40(T_TypeA2 *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // eax
  int v5; // edx

  sub_2C830(a1);
  v4 = sub_1B4F0(a1[1].a.a);
  v5 = _wcpp_2_ctor_array_(v4 + 0x26, 0x64, &unk_959D8) - 0x143;
  *(_DWORD *)(v5 + 0xA7) = off_96018;
  sub_46CAC(v5, v5, (int)&unk_959D8, a4);
  return v5;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 96018: using guessed type int (*off_96018[5])();

//----- (00048B90) --------------------------------------------------------
_DWORD *__fastcall sub_48B90(_DWORD *a1)
{
  a1[0x1B] = 0;
  a1[0x1C] = 0;
  a1[0x1D] = 0;
  a1[0x1E] = 0;
  a1[0x1F] = 0;
  a1[0x20] = 0;
  *(_DWORD *)((char *)a1 + 0x9E) = 0;
  *(_DWORD *)((char *)a1 + 0xA2) = 0;
  *(_DWORD *)((char *)a1 + 0xA6) = 0;
  sub_48C5C((int)a1, 0);
  return a1;
}

//----- (00048C5C) --------------------------------------------------------
int __fastcall sub_48C5C(int a1, char a2)
{
  sub_48EAC(a1);
  return sub_49148(a1, a2);
}

//----- (00048C84) --------------------------------------------------------
FILE *sub_48C84()
{
  FILE *result; // eax
  FILE *v1; // esi
  unsigned int v2; // ecx
  char *v3; // edx
  int i; // ebp
  signed int v5; // ebx
  unsigned int v6; // kr04_4
  char *v7; // eax
  int v8; // eax
  char v9[200]; // [esp+0h] [ebp-104h] BYREF
  char v10; // [esp+C8h] [ebp-3Ch] BYREF
  int v11; // [esp+CCh] [ebp-38h] BYREF
  int v12; // [esp+D0h] [ebp-34h] BYREF
  int v13; // [esp+D4h] [ebp-30h] BYREF
  int v14; // [esp+D8h] [ebp-2Ch] BYREF
  int v15; // [esp+DCh] [ebp-28h] BYREF
  int v16; // [esp+E0h] [ebp-24h] BYREF
  int v17; // [esp+E4h] [ebp-20h] BYREF
  int v18; // [esp+E8h] [ebp-1Ch] BYREF

  result = sub_1BB10("gizmos.txt", 0);
  v1 = result;
  if ( result )
  {
    v2 = 0;
    do
    {
      fgets(v9, 0xC8, v1);
      if ( v9[0] == 0x23 )
      {
        v2 = 0xFFFFFFFF;
      }
    }
    while ( !v2 );
    v3 = (char *)&unk_107020;
    for ( i = 0; i < 0x4C; ++i )
    {
      fscanf(v1, "%s", v3);
      v5 = 0;
      v6 = strlen(v3) + 1;
      if ( (int)(v6 - 1) > 0 )
      {
        v7 = v3;
        do
        {
          if ( *v7 == 0x5E )
          {
            *v7 = 0x20;
          }
          ++v5;
          ++v7;
        }
        while ( v5 < (int)(v6 - 1) );
      }
      fscanf(v1, "%d %d %d %d %d %d %d %d %d", &v10, &v11, &v12, &v13, &v14, &v15, &v16, &v17, &v18);
      v3[0x32] = v10;
      *(_DWORD *)(v3 + 0x36) = v11;
      *(_DWORD *)(v3 + 0x3A) = v12;
      *(_DWORD *)(v3 + 0x3E) = v13;
      *(_DWORD *)(v3 + 0x42) = v14;
      *(_DWORD *)(v3 + 0x46) = v15;
      *(_DWORD *)(v3 + 0x4A) = v16;
      *(_DWORD *)(v3 + 0x4E) = v17;
      v3[0x35] = v18;
      fscanf(v1, "%d", &v18);
      *(_WORD *)(v3 + 0x33) = 0;
      while ( v18 != 0xFF )
      {
        LOWORD(v5) = *(_WORD *)(v3 + 0x33);
        v5 |= 1 << v18;
        *(_WORD *)(v3 + 0x33) = v5;
        fscanf(v1, "%d", &v18);
      }
      *(_DWORD *)(v3 + 0x66) = 0;
      v8 = *(_DWORD *)(v3 + 0x66);
      *(_DWORD *)(v3 + 0x62) = v8;
      *(_DWORD *)(v3 + 0x5E) = v8;
      *(_DWORD *)(v3 + 0x5A) = v8;
      *(_DWORD *)(v3 + 0x56) = v8;
      *(_DWORD *)(v3 + 0x52) = v8;
      switch ( v3[0x32] )
      {
        case 0:
          *(_DWORD *)(v3 + 0x52) = *(_DWORD *)(v3 + 0x3E);
          break;
        case 1:
          *(_DWORD *)(v3 + 0x56) = *(_DWORD *)(v3 + 0x3E);
          break;
        case 2:
          *(_DWORD *)(v3 + 0x5E) = *(_DWORD *)(v3 + 0x3E);
          break;
        case 3:
          *(_DWORD *)(v3 + 0x62) = *(_DWORD *)(v3 + 0x3E);
          break;
        case 4:
          *(_DWORD *)(v3 + 0x66) = *(_DWORD *)(v3 + 0x36);
          break;
        default:
          break;
      }
      v3 += 0x6A;
    }
    return (FILE *)fclose(v1);
  }
  else
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0xBE);
  }
  return result;
}
// 48C84: using guessed type char var_104[200];

//----- (00048EAC) --------------------------------------------------------
int __fastcall sub_48EAC(int result)
{
  int v1; // ebx
  char *v2; // ebx
  int v3; // ecx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char v6; // al
  char v7; // al
  int v8; // ebp
  char v9; // dl
  int v10; // esi
  int v11; // ebx
  char v12; // di
  int v13; // ecx
  char v14; // dl
  int v15; // ebp
  int v16; // esi
  double v17; // st7
  int v18; // ebx
  int v19; // [esp+0h] [ebp-3Ch]
  int v20; // [esp+4h] [ebp-38h]
  int v21; // [esp+Ch] [ebp-30h]
  int v22; // [esp+10h] [ebp-2Ch]
  char v23; // [esp+14h] [ebp-28h]
  float v24; // [esp+1Ch] [ebp-20h]
  float v25; // [esp+1Ch] [ebp-20h]
  float v26; // [esp+20h] [ebp-1Ch]

  *(_DWORD *)(result + 0x15E) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 0x10) = 0;
  *(_DWORD *)(result + 0x20) = 0;
  *(_DWORD *)(result + 0x24) = 0;
  *(_DWORD *)(result + 0x18) = 0;
  *(_DWORD *)(result + 0x1C) = 0;
  *(_DWORD *)(result + 0x30) = 0;
  *(_DWORD *)(result + 0x28) = 0;
  *(_DWORD *)(result + 0x2C) = 0;
  *(_BYTE *)(result + 0x34) = 0;
  *(_WORD *)(result + 0x56) = 0xFFFF;
  *(_BYTE *)(result + 0x58) = 0;
  *(_DWORD *)(result + 0x90) = 0;
  *(_DWORD *)(result + 0x8C) = 1;
  *(_BYTE *)(result + 0x5D) = 0;
  *(_DWORD *)(result + 0x5E) = 0;
  *(_DWORD *)(result + 0x88) = *(_DWORD *)(result + 0x90);
  v1 = result;
  *(_DWORD *)(result + 0x98) = *(_DWORD *)(result + 0x8C);
  do
  {
    v1 += 7;
    *(_BYTE *)(v1 + 0xA4) = 0xFF;
    *(_WORD *)(v1 + 0xA5) = 0;
    *(_DWORD *)(v1 + 0xA7) = 0;
  }
  while ( v1 != result + 0xAF );
  if ( !dword_10701C )
  {
    v2 = (char *)&unk_108F98;
    v3 = 0x83;
    do
    {
      v4 = v2;
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3);
      do
      {
        v6 = *sub_1CEA8;
        *v4 = *sub_1CEA8;
        if ( !v6 )
        {
          break;
        }
        v7 = sub_1CEA8[1];
        sub_1CEA8 += 2;
        v4[1] = v7;
        v4 += 2;
      }
      while ( v7 );
      v2 += 0x14;
      ++v3;
    }
    while ( v2 != (char *)&unk_108F98 + 0x50 );
    sub_48C84();
    word_107018 = 0;
    v8 = 0;
    result = 0;
    do
    {
      v9 = 1;
      v10 = (unsigned __int8)byte_969B8[v8];
      v11 = 0;
      if ( byte_969B8[v8] )
      {
        v12 = byte_969C8[v8];
        do
        {
          if ( ((unsigned __int8)v9 & (unsigned __int8)v12) != 0 )
          {
            ++word_107018;
          }
          ++v11;
          v9 *= 2;
        }
        while ( v11 < v10 );
      }
      ++v8;
    }
    while ( v8 < 0xE );
    v22 = 0;
    v21 = 0;
    do
    {
      v13 = *(int *)((char *)&off_9699E + SHIWORD(v21));
      v24 = (float)word_107018;
      v20 = 0;
      v25 = v24 / (double)(v13 - 1);
      v19 = 0;
      v26 = v25;
      do
      {
        if ( v13 <= 0 )
        {
          break;
        }
        v14 = 1;
        v15 = (unsigned __int8)byte_969B8[v20];
        v16 = 0;
        if ( byte_969B8[v20] )
        {
          v23 = byte_969C8[v20];
          do
          {
            if ( ((unsigned __int8)v23 & (unsigned __int8)v14) != 0 )
            {
              v17 = v26 + 1.0;
              v18 = v22 + v19;
              v26 = v17;
              if ( v17 < v25 )
              {
                if ( v13 == 1 && v25 + flt_926DB < v26 )
                {
                  v13 = 0;
                  byte_106FE0[v18] |= v14;
                }
              }
              else
              {
                --v13;
                v26 = v26 - v25;
                byte_106FE0[v18] |= v14;
              }
            }
            ++v16;
            v14 *= 2;
          }
          while ( v16 < v15 );
        }
        result = v20 + 1;
        v19 += 4;
        v20 = result;
      }
      while ( result < 0xE );
      v21 += 2;
      ++v22;
    }
    while ( v22 < 4 );
    dword_10701C = 0xFFFFFFFF;
  }
  return result;
}
// 926DB: using guessed type float flt_926DB;
// 9699E: using guessed type void *off_9699E;
// 107018: using guessed type __int16 word_107018;
// 10701C: using guessed type int dword_10701C;

//----- (00049148) --------------------------------------------------------
int __fastcall sub_49148(int a1, char a2)
{
  _BYTE *v3; // edi
  char *v4; // esi
  char v5; // al
  char v6; // al
  int v7; // edx
  int result; // eax

  *(_BYTE *)(a1 + 0xAA) = a2;
  if ( a2 >= 4 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x131);
  }
  *(_DWORD *)(a1 + 0x15A) = *(int *)((char *)&off_9699E + 2 * *(char *)(a1 + 0xAA)) >> 0x10;
  if ( !*(_BYTE *)(a1 + 0x34) || *(_WORD *)(a1 + 0x56) != (unsigned __int8)byte_104BEA )
  {
    v3 = (_BYTE *)(a1 + 0x34);
    v4 = (char *)&unk_108F98 + 0x14 * *(char *)(a1 + 0xAA);
    do
    {
      v5 = *v4;
      *v3 = *v4;
      if ( !v5 )
      {
        break;
      }
      v6 = v4[1];
      v4 += 2;
      v3[1] = v6;
      v3 += 2;
    }
    while ( v6 );
  }
  v7 = *(__int16 *)(a1 + 0x56);
  *(_DWORD *)(a1 + 0x8C) = 0xA * (*(char *)(a1 + 0xAA) + 1);
  *(_DWORD *)(a1 + 0x14) = 0;
  if ( byte_A310F[0x1EE * v7] == 1 )
  {
    *(_DWORD *)(a1 + 0x8C) *= 2;
  }
  result = *(_DWORD *)(a1 + 0x8C);
  *(_DWORD *)(a1 + 0x98) = result;
  return result;
}
// 9699E: using guessed type void *off_9699E;

//----- (000492AC) --------------------------------------------------------
unsigned int __fastcall sub_492AC(_DWORD *a1, char a2, int a3)
{
  char v3; // ch

  if ( a3 > *(_DWORD *)((char *)a1 + 0x15A) )
  {
    return 0;
  }
  v3 = *((_BYTE *)a1 + 7 * a3 + 0xAB);
  if ( a2 == v3 )
  {
    return 0;
  }
  if ( v3 == (char)0xFF )
  {
    ++*(_DWORD *)((char *)a1 + 0x15E);
  }
  *((_BYTE *)a1 + 7 * a3 + 0xAB) = a2;
  sub_496E0(a1);
  return 0xFFFFFFFF;
}

//----- (000492F8) --------------------------------------------------------
unsigned int __fastcall sub_492F8(_DWORD *a1, int a2)
{
  char *v2; // edx

  v2 = (char *)a1 + 7 * a2;
  if ( v2[0xAB] == (char)0xFF )
  {
    return 0;
  }
  --*(_DWORD *)((char *)a1 + 0x15E);
  v2[0xAB] = 0xFF;
  sub_496E0(a1);
  return 0xFFFFFFFF;
}

//----- (00049328) --------------------------------------------------------
unsigned int __fastcall sub_49328(int a1, char a2)
{
  int v2; // esi
  unsigned int v4; // edi
  int v5; // edx

  v2 = a1;
  v4 = 0xFFFFFFFF;
  v5 = 0;
  if ( *(int *)(a1 + 0x15A) > 0 )
  {
    while ( *(_BYTE *)(a1 + 0xAB) == 0xFF || a2 != byte_107052[0x6A * *(char *)(a1 + 0xAB)] )
    {
      ++v5;
      a1 += 7;
      if ( v5 >= *(_DWORD *)(v2 + 0x15A) )
      {
        return v4;
      }
    }
    return v5;
  }
  return v4;
}

//----- (0004937C) --------------------------------------------------------
unsigned int __fastcall sub_4937C(int a1, char a2)
{
  unsigned int v4; // esi
  int v5; // edx
  int v6; // eax
  int i; // edx

  v4 = 0xFFFFFFFF;
  v5 = *(_DWORD *)(a1 + 0x15A);
  v6 = 0;
  if ( v5 > 0 )
  {
    for ( i = a1; a2 != *(_BYTE *)(i + 0xAB); i += 7 )
    {
      if ( ++v6 >= *(_DWORD *)(a1 + 0x15A) )
      {
        return v4;
      }
    }
    return v6;
  }
  return v4;
}

//----- (000493BC) --------------------------------------------------------
void __fastcall sub_493BC(int a1, char a2)
{
  int v3; // edi
  int v4; // esi
  int v5; // ebp
  char v6; // bl
  _BYTE *v7; // edi
  char *v8; // esi
  char v9; // al
  char v10; // al

  if ( a2 != *(_BYTE *)(a1 + 0xAA) && *(int *)((char *)&off_9699E + 2 * a2) >> 0x10 >= *(_DWORD *)(a1 + 0x15E) )
  {
    v3 = 0;
    v4 = 0;
    if ( *(int *)(a1 + 0x15A) > 0 )
    {
      v5 = a1;
      do
      {
        v6 = *(_BYTE *)(v5 + 0xAB);
        if ( v6 != (char)0xFF )
        {
          sub_492F8((_DWORD *)a1, v4);
          sub_492AC((_DWORD *)a1, v6, v3++);
        }
        ++v4;
        v5 += 7;
      }
      while ( v4 < *(_DWORD *)(a1 + 0x15A) );
    }
    sub_49148(a1, a2);
    v7 = (_BYTE *)(a1 + 0x34);
    v8 = (char *)&unk_108F98 + 0x14 * *(char *)(a1 + 0xAA);
    do
    {
      v9 = *v8;
      *v7 = *v8;
      if ( !v9 )
      {
        break;
      }
      v10 = v8[1];
      v8 += 2;
      v7[1] = v10;
      v7 += 2;
    }
    while ( v10 );
    sub_496E0((_DWORD *)a1);
  }
  JUMPOUT(0x4948C);
}
// 4948B: control flows out of bounds to 4948C
// 9699E: using guessed type void *off_9699E;

//----- (00049494) --------------------------------------------------------
int __fastcall sub_49494(int a1, float *a2)
{
  double v3; // st7
  int result; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  int v7[3]; // [esp+0h] [ebp-3Ch] BYREF
  float v8; // [esp+Ch] [ebp-30h]
  float v9; // [esp+10h] [ebp-2Ch]
  float v10; // [esp+14h] [ebp-28h]
  float v11; // [esp+18h] [ebp-24h] BYREF
  float v12; // [esp+1Ch] [ebp-20h]
  float v13; // [esp+20h] [ebp-1Ch]
  int v14; // [esp+24h] [ebp-18h]
  int *v15; // [esp+28h] [ebp-14h]

  if ( sub_35BB4((int)a2, a1) )
  {
    v5 = sub_4937C(a1, 0x43);
    if ( v5 != 0xFFFFFFFF )
    {
      v6 = a1 + 7 * v5;
      if ( *(_WORD *)(v6 + 0xAC) )
      {
        *(_DWORD *)(a1 + 0x88) += dword_108C28;
        --*(_WORD *)(v6 + 0xAC);
      }
    }
    result = *(__int16 *)(a1 + 0x56);
    if ( result == (unsigned __int8)byte_104BEA && *(_BYTE *)(a1 + 0x5D) == 3 )
    {
      result = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
      if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10 )
      {
        result = sub_55AEC((int)&V_Type3_stru_10AE70, 0x10, a1, *(_DWORD *)(a1 + 0x5E));
      }
      *(_BYTE *)(a1 + 0x5D) = 0;
      *(_DWORD *)(a1 + 0x5E) = 0;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 0x58) = 4;
    v11 = (float)(rand() % 0x3E8 - 0x1F4);
    v12 = (float)(rand() % 0x3E8 - 0x1F4);
    v14 = rand() % 0x3E8 - 0x1F4;
    v13 = (float)v14;
    sub_53054(&v11, 250.0);
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    v15 = v7;
    v8 = *a2 + v11;
    v9 = a2[1] + v12;
    v3 = a2[2];
    *(float *)v7 = v8;
    v10 = v3 + v13;
    *(float *)&v7[1] = v9;
    *(float *)&v7[2] = v10;
    return sub_496BC(a1, v7);
  }
  return result;
}
// 108C28: using guessed type int dword_108C28;

//----- (0004960C) --------------------------------------------------------
unsigned int __fastcall sub_4960C(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 0xC) + *(_DWORD *)(a1 + 8) <= 0 && byte_A310F[0x1EE * *(__int16 *)(a1 + 0x56)] != 0x12
    || (*(_BYTE *)(a2 + 0x23) & 2) != 0 )
  {
    return 0;
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (00049648) --------------------------------------------------------
unsigned int __fastcall sub_49648(int a1, __int16 **a2)
{
  unsigned int result; // eax
  __int16 *v4; // esi

  result = sub_4960C(a1, (int)a2);
  if ( result )
  {
    if ( *(_BYTE *)(a1 + 0x58) == 3 )
    {
      v4 = &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(a1 + 0x59) + 0xC)];
    }
    else
    {
      v4 = *(__int16 **)(a1 + 0x59);
    }
    result = sub_1D538((int)v4, a1);
    *(_BYTE *)(a1 + 0x58) = 5;
    *(_DWORD *)(a1 + 0x9E) = 0;
    *(_DWORD *)(a1 + 0x59) = a2;
    if ( v4 == *a2 )
    {
      *(_DWORD *)(a1 + 0xA2) = 0x3F800000;
    }
    else
    {
      *(_DWORD *)(a1 + 0xA2) = 0;
    }
  }
  return result;
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (000496BC) --------------------------------------------------------
int __fastcall sub_496BC(int a1, _DWORD *a2)
{
  int v2; // eax

  *(_DWORD *)(a1 + 0x9E) = *a2;
  v2 = a1 + 0x9E;
  *(_DWORD *)(v2 + 4) = a2[1];
  *(_DWORD *)(v2 + 8) = a2[2];
  return sub_53440((float *)v2);
}

//----- (000496E0) --------------------------------------------------------
void __fastcall sub_496E0(_DWORD *a1)
{
  int v2; // eax
  int v3; // esi
  int v4; // edi
  _DWORD *v5; // ebx
  char *v6; // eax
  char v7; // al
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]

  *a1 = 0;
  a1[1] = 0;
  v2 = a1[5];
  a1[8] = 0;
  a1[9] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[0xA] = 0;
  v3 = 0;
  a1[0xB] = 0;
  v9 = 0;
  a1[0xC] = 0;
  v8 = 0;
  v4 = *(_DWORD *)((char *)a1 + 0x15A);
  a1[4] = v2;
  if ( v4 > 0 )
  {
    v5 = a1;
    do
    {
      if ( *((_BYTE *)v5 + 0xAB) != 0xFF )
      {
        v6 = (char *)&unk_107020 + 0x6A * *((char *)v5 + 0xAB);
        *a1 += *(_DWORD *)(v6 + 0x52);
        a1[1] += *(_DWORD *)(v6 + 0x56);
        a1[4] += *(_DWORD *)(v6 + 0x5E);
        a1[8] += *(_DWORD *)(v6 + 0x62);
        a1[6] += *(_DWORD *)(v6 + 0x66);
        if ( v6[0x32] == 2 )
        {
          a1[7] += *(_DWORD *)(v6 + 0x36);
        }
        v7 = *((_BYTE *)v5 + 0xAB);
        switch ( v7 )
        {
          case 'G':
            a1[0xA] = 0xFFFFFFFF;
            break;
          case '+':
            ++v9;
            break;
          case ',':
            ++v8;
            break;
          case '*':
            ++a1[9];
            break;
        }
      }
      ++v3;
      v5 = (_DWORD *)((char *)v5 + 7);
    }
    while ( v3 < *(_DWORD *)((char *)a1 + 0x15A) );
  }
  a1[2] = (int)(sqrt((double)v9) * dbl_926EB);
  a1[3] = (int)(sqrt((double)v8) * dbl_926F3);
}
// 926EB: using guessed type double dbl_926EB;
// 926F3: using guessed type double dbl_926F3;

//----- (00049828) --------------------------------------------------------
int __fastcall sub_49828(int a1)
{
  int v2; // ecx
  __int16 v3; // dx
  int v4; // eax
  int v5; // ecx
  int v6; // edx

  if ( *(_BYTE *)(a1 + 0x58) != 1 && *(_BYTE *)(a1 + 0x58) != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x260);
  }
  if ( !*(_DWORD *)(a1 + 0x59) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x261);
  }
  v2 = *(_DWORD *)(a1 + 0x59);
  if ( *(_WORD *)(a1 + 0x56) != *(unsigned __int8 *)(v2 + 0x57) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x265);
  }
  if ( *(_BYTE *)(a1 + 0x58) == 1 )
  {
    *(_DWORD *)(a1 + 0x52) = dword_A2F6C[0];
    if ( *(_WORD *)(a1 + 0x56) == (unsigned __int8)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11 )
    {
      v3 = 0x11;
LABEL_15:
      sub_55AEC((int)&V_Type3_stru_10AE70, v3, a1, v2);
    }
  }
  else if ( *(_WORD *)(a1 + 0x56) == (unsigned __int8)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11 )
  {
    v3 = 0x12;
    goto LABEL_15;
  }
  v4 = *(_DWORD *)(a1 + 0x59);
  *(_BYTE *)(a1 + 0x58) = 3;
  v5 = *(__int16 *)(v4 + 0xC);
  sub_1D3E8((int)&word_A3D21[0x30 * v5], a1, 0);
  v6 = *(char *)(a1 + 0xAA);
  sub_49148(a1, v6);
  return sub_4A6AC(a1, v6, 0, v5);
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00049940) --------------------------------------------------------
__int16 __fastcall sub_49940(int a1)
{
  int v2; // esi
  int v3; // eax
  __int16 *v4; // eax
  int v5; // eax

  if ( !*(_BYTE *)(a1 + 0x58) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x288);
  }
  switch ( *(_BYTE *)(a1 + 0x58) )
  {
    case 1:
    case 2:
      v2 = *(_DWORD *)(a1 + 0x59);
      if ( *(_WORD *)(v2 + 0x52) >= *(_WORD *)(v2 + 0x1A) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x297);
      }
      if ( sub_35A70(v2, *(_WORD *)(v2 + 0x52)) != (char *)a1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x29A);
      }
      v3 = 0x30 * *(__int16 *)(v2 + 0xC);
      *(_BYTE *)(a1 + 0x58) = 4;
      v4 = &word_A3D21[v3];
      *(_DWORD *)(a1 + 0x59) = v4;
      sub_1D538((int)v4, a1);
      v5 = *(unsigned __int16 *)(v2 + 0x52);
      *(_BYTE *)(v2 + 0x54) = 0xFF;
      if ( (unsigned __int16)v5 != 0xFFFF )
      {
        *(_BYTE *)(*(_DWORD *)(v2 + 0x10) + 4 * v5 + 1) = 0xFF;
        *(_WORD *)(v2 + 0x52) = 0xFFFF;
      }
      break;
    case 3:
      sub_35C38(*(_DWORD *)(a1 + 0x59), a1);
      if ( *(_BYTE *)(a1 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x2B0);
      }
      goto LABEL_12;
    case 4:
LABEL_12:
      sub_1D538(*(_DWORD *)(a1 + 0x59), a1);
      break;
    default:
      return sub_20720((int)&dword_A2F6C, a1);
  }
  return sub_20720((int)&dword_A2F6C, a1);
}
// A2F6C: using guessed type int dword_A2F6C;
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00049A40) --------------------------------------------------------
int __fastcall sub_49A40(int a1, int a2)
{
  char *v3; // ebx
  __int16 i; // si
  int result; // eax

  v3 = (char *)(a1 + 0xAB);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 0x15A) )
    {
      break;
    }
    if ( *v3 != (char)0xFF && byte_107052[0x6A * *v3] == 1 && a2 != *(_DWORD *)(v3 + 3) )
    {
      sub_49A8C(a1, v3);
    }
    v3 += 7;
  }
  return result;
}

//----- (00049A8C) --------------------------------------------------------
char *__fastcall sub_49A8C(int a1, char *a2)
{
  char *result; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ebx

  if ( *a2 == (char)0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x2D3);
  }
  result = (char *)&unk_107020 + 0x6A * *a2;
  if ( (*(_WORD *)(result + 0x33) & 0x20) != 0 )
  {
    if ( *(_DWORD *)(a2 + 3) == 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0x88) += *(_DWORD *)(result + 0x36);
      if ( result[0x32] == 1 )
      {
        result = *(char **)(result + 0x56);
        v5 = *(_DWORD *)(a1 + 0x90) - (_DWORD)result;
        *(_DWORD *)(a1 + 0x90) = v5;
        if ( v5 < 0 )
        {
          *(_DWORD *)(a1 + 0x90) = 0;
        }
      }
      *(_DWORD *)(a2 + 3) = 0;
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 0x88);
      v7 = *(_DWORD *)(result + 0x36);
      if ( v6 >= v7 )
      {
        *(_DWORD *)(a1 + 0x88) = v6 - v7;
        if ( result[0x32] == 1 )
        {
          result = *(char **)(result + 0x56);
          *(_DWORD *)(a1 + 0x90) += result;
        }
        *(_DWORD *)(a2 + 3) = 0xFFFFFFFF;
      }
    }
  }
  return result;
}

//----- (00049B3C) --------------------------------------------------------
int __fastcall sub_49B3C(int a1, int a2)
{
  char v3; // cl
  int result; // eax

  v3 = *(_BYTE *)(a1 + 0x62);
  result = 0;
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      result = sub_4A0D0(a1, a2);
    }
  }
  else
  {
    result = sub_49CC4(a1, a2);
  }
  *(_DWORD *)(a1 + 0x84) = result;
  return result;
}

//----- (00049B68) --------------------------------------------------------
int __fastcall sub_49B68(int a1, int a2)
{
  __int16 i; // dx
  bool v5; // zf
  int v6; // ebx
  char v7; // al
  float v9; // [esp+8h] [ebp-20h]
  float v10; // [esp+10h] [ebp-18h]

  v10 = -1.0;
  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    v6 = a1 + 7 * i;
    v7 = *(_BYTE *)(v6 + 0xAB);
    v9 = -1.0;
    if ( v7 != (char)0xFF && v7 < 0x4C && (!*(int *)((char *)&dword_107062 + 0x6A * v7) || *(_WORD *)(v6 + 0xAC)) )
    {
      if ( v7 > (char)0xFFFFFFFF && v7 < 9 )
      {
LABEL_35:
        v9 = (double)(0x20 * *(int *)((char *)&dword_10705A + 0x6A * v7)) * dbl_9275B;
        goto LABEL_25;
      }
      if ( a2 != 1 )
      {
        if ( a2 != 2 || (unsigned __int8)v7 < 0x2Fu )
        {
          goto LABEL_25;
        }
        if ( (unsigned __int8)v7 > 0x2Fu )
        {
          v5 = v7 == 0x46;
          goto LABEL_24;
        }
LABEL_4:
        v9 = (double)(0x20 * *(int *)((char *)&dword_10705A + 0x6A * v7)) * dbl_92763;
        goto LABEL_25;
      }
      if ( (unsigned __int8)v7 < 0x30u )
      {
        if ( (unsigned __int8)v7 < 0x25u )
        {
          if ( (unsigned __int8)v7 >= 0x21u && (unsigned __int8)v7 <= 0x23u )
          {
            goto LABEL_35;
          }
        }
        else
        {
          if ( (unsigned __int8)v7 <= 0x26u )
          {
            goto LABEL_35;
          }
          if ( v7 == 0x2F )
          {
            goto LABEL_4;
          }
        }
      }
      else
      {
        if ( (unsigned __int8)v7 <= 0x32u )
        {
          goto LABEL_35;
        }
        if ( (unsigned __int8)v7 < 0x3Du )
        {
          v5 = v7 == 0x36;
LABEL_24:
          if ( v5 )
          {
            goto LABEL_35;
          }
        }
        else
        {
          if ( (unsigned __int8)v7 <= 0x3Du )
          {
            goto LABEL_35;
          }
          if ( (unsigned __int8)v7 >= 0x40u )
          {
            if ( (unsigned __int8)v7 <= 0x40u )
            {
              goto LABEL_35;
            }
            v5 = v7 == 0x42;
            goto LABEL_24;
          }
        }
      }
LABEL_25:
      if ( v9 > (double)v10 )
      {
        v10 = v9;
      }
      continue;
    }
  }
  return (int)v10;
}
// 9275B: using guessed type double dbl_9275B;
// 92763: using guessed type double dbl_92763;
// 10705A: using guessed type int dword_10705A;
// 107062: using guessed type int dword_107062;

//----- (00049CC4) --------------------------------------------------------
int __fastcall sub_49CC4(int a1, int a2)
{
  char v4; // dh
  int v5; // ebx
  int *v6; // edx
  int *v7; // edx
  float *v8; // edx
  double v9; // st7
  double v10; // st7
  int v11; // eax
  double v12; // st6
  char v13; // dl
  int v15[3]; // [esp+8h] [ebp-C0h] BYREF
  float v16; // [esp+14h] [ebp-B4h]
  float v17; // [esp+18h] [ebp-B0h]
  float v18; // [esp+1Ch] [ebp-ACh]
  int v19[3]; // [esp+20h] [ebp-A8h] BYREF
  float v20; // [esp+2Ch] [ebp-9Ch]
  float v21; // [esp+30h] [ebp-98h]
  float v22; // [esp+34h] [ebp-94h]
  float v23; // [esp+38h] [ebp-90h]
  int v24; // [esp+3Ch] [ebp-8Ch]
  int v25; // [esp+40h] [ebp-88h]
  float v26; // [esp+44h] [ebp-84h] BYREF
  int v27; // [esp+48h] [ebp-80h]
  int v28; // [esp+4Ch] [ebp-7Ch]
  int v29[3]; // [esp+50h] [ebp-78h] BYREF
  float v30; // [esp+5Ch] [ebp-6Ch]
  float v31; // [esp+60h] [ebp-68h]
  float v32; // [esp+64h] [ebp-64h]
  float v33; // [esp+68h] [ebp-60h]
  int v34; // [esp+6Ch] [ebp-5Ch]
  int v35; // [esp+70h] [ebp-58h]
  float v36; // [esp+74h] [ebp-54h]
  int v37; // [esp+78h] [ebp-50h]
  int v38; // [esp+7Ch] [ebp-4Ch]
  float v39; // [esp+80h] [ebp-48h] BYREF
  float v40; // [esp+84h] [ebp-44h]
  float v41; // [esp+88h] [ebp-40h]
  int *v42; // [esp+8Ch] [ebp-3Ch]
  int *v43; // [esp+90h] [ebp-38h]
  int *v44; // [esp+94h] [ebp-34h]
  float *v45; // [esp+98h] [ebp-30h]
  float *v46; // [esp+9Ch] [ebp-2Ch]
  float v47; // [esp+A4h] [ebp-24h]
  float v48; // [esp+A8h] [ebp-20h]
  int v49; // [esp+ACh] [ebp-1Ch]
  float v50; // [esp+B0h] [ebp-18h]

  if ( *(_BYTE *)(a1 + 0x58) != 4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x370);
  }
  v20 = 0.0;
  v21 = 0.0;
  v22 = 0.0;
  v4 = *(_BYTE *)(a1 + 0x67);
  v5 = 1;
  switch ( v4 )
  {
    case 3:
      v20 = *(float *)(a1 + 0x6C);
      v21 = *(float *)(a1 + 0x70);
      v22 = *(float *)(a1 + 0x74);
      break;
    case 1:
      v6 = *(int **)(a1 + 0x68);
      v20 = *(float *)v6;
      v21 = *((float *)v6 + 1);
      v22 = *((float *)v6 + 2);
      break;
    case 2:
      v7 = *(int **)(a1 + 0x68);
      v20 = *((float *)v7 + 5);
      v21 = *((float *)v7 + 6);
      v22 = *((float *)v7 + 7);
      v8 = *(float **)(a1 + 0x68);
      if ( *(_DWORD *)(a1 + 0x59) == *(_DWORD *)v8 )
      {
        v20 = v8[2];
        v21 = v8[3];
        v22 = v8[4];
      }
      break;
    default:
      v5 = 0;
      break;
  }
  if ( (v5 & 1) != 0 )
  {
    v45 = &v26;
    v16 = 0.0;
    v17 = 0.0;
    v18 = 0.0;
    v16 = v20 - *(float *)(a1 + 0x9E);
    v17 = v21 - *(float *)(a1 + 0xA2);
    v18 = v22 - *(float *)(a1 + 0xA6);
    v26 = v16;
    *(float *)&v27 = v17;
    *(float *)&v28 = v18;
    v50 = sqrt(v17 * v17 + v16 * v16 + v18 * v18) * flt_92777;
    v48 = (float)*(int *)(a1 + 0x94);
    v47 = v50;
    if ( v50 > (double)v48 )
    {
      v50 = v48;
    }
    v49 = (int)((double)*(int *)(a1 + 0x1C) * (v50 + 1.0) / (double)*(int *)(a1 + 0x10));
    if ( v49 < 1 )
    {
      v49 = 1;
    }
    if ( v49 > *(_DWORD *)(a1 + 0x88) )
    {
      v9 = (double)*(int *)(a1 + 0x88) * v50 / (double)v49;
      v49 = *(_DWORD *)(a1 + 0x88);
      v50 = v9;
    }
    if ( v50 == v47 )
    {
      LOBYTE(v5) = v5 | 8;
    }
    sub_53000(&v26);
    v42 = v15;
    v36 = v26 * v50;
    *(float *)v15 = v36;
    *(float *)&v37 = *(float *)&v27 * v50;
    v15[1] = v37;
    *(float *)&v38 = v50 * *(float *)&v28;
    v15[2] = v38;
    v33 = v36 * flt_9277B;
    v43 = v19;
    *(float *)&v34 = *(float *)&v37 * flt_9277B;
    *(float *)v19 = v33;
    *(float *)&v35 = flt_9277B * *(float *)&v38;
    v19[1] = v34;
    v19[2] = v35;
    v23 = v33 * flt_9277F;
    v44 = v29;
    *(float *)&v24 = *(float *)&v34 * flt_9277F;
    *(float *)v29 = v23;
    *(float *)&v25 = flt_9277F * *(float *)&v35;
    v29[1] = v24;
    v29[2] = v25;
    v26 = v23;
    v30 = 0.0;
    v27 = v24;
    v31 = 0.0;
    v28 = v25;
    v32 = 0.0;
    v46 = &v39;
    v30 = *(float *)(a1 + 0x9E) + v23;
    v31 = *(float *)(a1 + 0xA2) + *(float *)&v24;
    v10 = *(float *)(a1 + 0xA6);
    v39 = v30;
    v32 = v10 + *(float *)&v25;
    v40 = v31;
    v41 = v32;
    *(float *)(a1 + 0x78) = v30;
    *(float *)(a1 + 0x7C) = v40;
    *(float *)(a1 + 0x80) = v41;
    sub_53440((float *)(a1 + 0x78));
    if ( a2 == 1 )
    {
      v11 = v49;
      *(float *)(a1 + 0x9E) = *(float *)(a1 + 0x78);
      *(_DWORD *)(a1 + 0xA2) = *(_DWORD *)(a1 + 0x7C);
      *(_DWORD *)(a1 + 0xA6) = *(_DWORD *)(a1 + 0x80);
      v12 = (double)*(int *)(a1 + 0x94) - v50;
      *(_DWORD *)(a1 + 0x88) -= v11;
      *(_DWORD *)(a1 + 0x94) = (int)v12;
      if ( (v5 & 8) != 0 )
      {
        v13 = *(_BYTE *)(a1 + 0x67);
        if ( v13 == 1 )
        {
          sub_49494(a1, *(float **)(a1 + 0x68));
        }
        else if ( v13 == 2 )
        {
          sub_49648(a1, *(__int16 ***)(a1 + 0x68));
        }
      }
    }
  }
  return v5;
}
// 92777: using guessed type float flt_92777;
// 9277B: using guessed type float flt_9277B;
// 9277F: using guessed type float flt_9277F;

//----- (0004A0D0) --------------------------------------------------------
int __fastcall sub_4A0D0(int a1, int a2)
{
  char *v2; // ecx
  unsigned int v3; // esi
  int v4; // ebx
  char v5; // cl

  v2 = *(char **)(a1 + 0x63);
  v3 = 0xFFFFFFFF;
  v4 = 0;
  if ( *(int *)((char *)&dword_107062 + 0x6A * *v2) )
  {
    if ( *(_WORD *)(v2 + 1) )
    {
      if ( a2 == 1 )
      {
        --*(_WORD *)(v2 + 1);
      }
    }
    else
    {
      v3 = 0;
    }
  }
  if ( v3 == 0xFFFFFFFF )
  {
    v5 = *(_BYTE *)(a1 + 0x67);
    switch ( v5 )
    {
      case 0:
        return sub_4B944(a1, a2);
      case 2:
        return sub_4CAB8(a1, a2);
      case 1:
        return sub_4C7FC(a1, a2);
      case 5:
        return sub_4CDF8(a1, a2);
    }
  }
  return v4;
}
// 107062: using guessed type int dword_107062;

//----- (0004A144) --------------------------------------------------------
int __fastcall sub_4A144(int a1)
{
  int v2; // ebx
  unsigned __int16 i; // ax
  int v4; // edx

  v2 = 0;
  for ( i = 0; i < *(int *)(a1 + 0x15A); ++i )
  {
    v4 = a1 + 7 * i;
    if ( *(_BYTE *)(v4 + 0xAB) != 0xFF )
    {
      v2 += *(int *)((char *)&dword_107066 + 0x6A * *(char *)(v4 + 0xAB));
    }
  }
  return v2;
}
// 107066: using guessed type int dword_107066;

//----- (0004A18C) --------------------------------------------------------
int __fastcall sub_4A18C(int a1)
{
  int v1; // edx
  int v3[7]; // [esp+0h] [ebp-1Ch]

  v3[0] = dword_969D8[0];
  v3[1] = dword_969D8[1];
  v3[2] = dword_969D8[2];
  v3[3] = dword_969D8[3];
  v1 = v3[*(char *)(a1 + 0xAA)];
  return v1 + sub_4A144(a1);
}
// 969D8: using guessed type _DWORD dword_969D8[4];
// 4A18C: using guessed type int var_1C[7];

//----- (0004A1CC) --------------------------------------------------------
int __fastcall sub_4A1CC(int a1, __int16 a2)
{
  int v3; // ecx
  int v4; // edi
  unsigned __int16 i; // dx
  signed int v6; // eax
  int v7; // ebp
  char v10; // [esp+6h] [ebp-28h]
  char v11; // [esp+Ah] [ebp-24h]
  char v12; // [esp+Eh] [ebp-20h]
  char v13; // [esp+12h] [ebp-1Ch]
  char v14; // [esp+16h] [ebp-18h]

  if ( a2 < 0 || a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x408);
  }
  v10 = sub_4A36C(a1, 0, a2);
  v11 = sub_4A36C(a1, 4, a2);
  v14 = sub_4A36C(a1, 2, a2);
  v3 = 0;
  v13 = sub_4A36C(a1, 1, a2);
  v12 = 0x2B;
  v4 = 0;
  if ( sub_4A404(a1, 0x2C) )
  {
    v12 = 0x2C;
  }
  for ( i = 0; i < *(int *)(a1 + 0x15A); ++i )
  {
    if ( *(_BYTE *)(a1 + 7 * i + 0xAB) != 0xFF )
    {
      v6 = 0xFFFFFFFF;
      switch ( byte_107052[0x6A * i] )
      {
        case 0:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v10);
          break;
        case 1:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v13);
          break;
        case 2:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v14);
          break;
        case 4:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v11);
          break;
        default:
          break;
      }
      if ( *(_BYTE *)(a1 + 7 * i + 0xAB) == 0x2B && v12 == 0x2C )
      {
        ++v4;
        ++v3;
      }
      else if ( v6 != 0xFFFFFFFF )
      {
        v7 = *(int *)((char *)&dword_10705E + 0x6A * *(char *)(a1 + 7 * i + 0xAB));
        ++v4;
        if ( v6 > v7 )
        {
          v3 += v6 - v7;
        }
      }
    }
  }
  if ( v4 <= 0 )
  {
    return 0;
  }
  else
  {
    return 0xA * v3 / v4;
  }
}
// A3CF2: using guessed type int dword_A3CF2;
// 10705E: using guessed type int dword_10705E;

//----- (0004A36C) --------------------------------------------------------
char __fastcall sub_4A36C(int a1, char a2, __int16 a3)
{
  char v3; // di
  __int16 v4; // bx
  __int16 i; // ax
  char v7; // [esp+4h] [ebp-14h]

  v3 = a3;
  if ( a3 < 0 || a3 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x45F);
  }
  v4 = 0;
  v7 = 0xFF;
  for ( i = 0; i < 0x4C; ++i )
  {
    if ( byte_107052[0x6A * i] == a2
      && ((1 << v3) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_107055[0x6A * i]) >> 0x18)) != 0
      && v4 <= *(int *)((char *)&dword_10705E + 0x6A * i) )
    {
      v7 = i;
      v4 = *((_WORD *)&dword_10705E + 0x35 * i);
    }
  }
  return v7;
}
// A3CF2: using guessed type int dword_A3CF2;
// 10529F: using guessed type int dword_10529F;
// 10705E: using guessed type int dword_10705E;

//----- (0004A404) --------------------------------------------------------
int __fastcall sub_4A404(int a1, char a2)
{
  if ( SHIWORD(dword_A3CF2) <= *(__int16 *)(a1 + 0x56) || *(__int16 *)(a1 + 0x56) < 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x476);
  }
  return (((1 << *(_WORD *)(a1 + 0x56)) & (*(int *)((char *)&dword_10529F
                                                  + 0x4B * (unsigned __int8)byte_107055[0x6A * a2]) >> 0x18)) == 0)
       - 1;
}
// A3CF2: using guessed type int dword_A3CF2;
// 10529F: using guessed type int dword_10529F;

//----- (0004A480) --------------------------------------------------------
_BYTE *__fastcall sub_4A480(int a1, unsigned __int16 a2, int a3)
{
  _BYTE *v5; // ecx
  int v6; // edi
  __int16 i; // bx

  if ( !*(_DWORD *)(a1 + 0x88) )
  {
    return 0;
  }
  v5 = (_BYTE *)(a1 + 0xAB);
  *(_BYTE *)(a1 + 0x62) = 1;
  v6 = 0;
  if ( a2 )
  {
    if ( a2 <= 2u )
    {
      *(_BYTE *)(a1 + 0x67) = 1;
      *(_DWORD *)(a1 + 0x68) = a3;
    }
    else if ( a2 == 3 )
    {
      *(_BYTE *)(a1 + 0x67) = 0;
      *(_DWORD *)(a1 + 0x68) = a3;
    }
    else
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x4A3);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 0x67) = 2;
    *(_DWORD *)(a1 + 0x68) = a3;
  }
  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    if ( *v5 != 0xFF && (!byte_107052[0x6A * (char)*v5] || *(_BYTE *)(a1 + 0x67) == 1 && *v5 == 0x46) )
    {
      *(_DWORD *)(a1 + 0x63) = v5;
      if ( (sub_49B3C(a1, 0) & 1) != 0 )
      {
        return v5;
      }
    }
    v5 += 7;
  }
  return (_BYTE *)v6;
}

//----- (0004A534) --------------------------------------------------------
unsigned int __fastcall sub_4A534(int a1, char a2)
{
  __int16 i; // ax

  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    if ( a2 == *(_BYTE *)(7 * i + a1 + 0xAB) )
    {
      return 0xFFFFFFFF;
    }
  }
  return 0;
}

//----- (0004A564) --------------------------------------------------------
unsigned int __fastcall sub_4A564(int a1)
{
  __int16 i; // ax
  int v3; // edx

  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    v3 = a1 + 7 * i;
    if ( !byte_107052[0x6A * *(char *)(v3 + 0xAB)]
      && (!*(int *)((char *)&dword_107062 + 0x6A * *(char *)(v3 + 0xAB)) || *(_WORD *)(v3 + 0xAC)) )
    {
      return 0xFFFFFFFF;
    }
  }
  return 0;
}
// 107062: using guessed type int dword_107062;

//----- (0004A5B8) --------------------------------------------------------
int __fastcall sub_4A5B8(int result)
{
  int v1; // edx
  char *v2; // ebx
  int i; // esi
  char *v4; // edx
  int v5; // ecx
  int v6; // edi

  if ( (*(_WORD *)(result + 0x9C) & 1) != 0 )
  {
    *(_DWORD *)(result + 0x94) = 0;
  }
  else
  {
    if ( (*(_WORD *)(result + 0x9C) & 2) != 0 )
    {
      v1 = dword_108A80 + *(_DWORD *)(result + 0x10);
    }
    else
    {
      v1 = *(_DWORD *)(result + 0x10);
    }
    *(_DWORD *)(result + 0x94) = v1;
  }
  *(_DWORD *)(result + 0x90) = 0;
  v2 = (char *)(result + 0xAB);
  for ( i = 0; i < *(_DWORD *)(result + 0x15A); v2 += 7 )
  {
    if ( *v2 != (char)0xFF )
    {
      v4 = (char *)&unk_107020 + 0x6A * *v2;
      if ( (*(_WORD *)(v4 + 0x33) & 0x20) != 0 && *(_DWORD *)(v2 + 3) == 0xFFFFFFFF )
      {
        v5 = *(_DWORD *)(result + 0x88);
        v6 = *(_DWORD *)(v4 + 0x36);
        if ( v5 >= v6 )
        {
          *(_DWORD *)(result + 0x88) = v5 - v6;
          if ( v4[0x32] == 1 )
          {
            *(_DWORD *)(result + 0x90) += *(_DWORD *)(v4 + 0x56);
          }
        }
      }
    }
    ++i;
  }
  if ( (*(_WORD *)(result + 0x9C) & 8) != 0 )
  {
    *(_DWORD *)(result + 0x90) = 0;
  }
  return result;
}
// 108A80: using guessed type int dword_108A80;

//----- (0004A6AC) --------------------------------------------------------
int __fastcall sub_4A6AC(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  int v6; // edx
  int v7; // ebx
  char *v8; // eax
  int v9; // edx
  float *v10; // eax
  float *v11; // ebx
  double v12; // st7
  int v13; // eax
  double v14; // st7
  int v15; // edi
  unsigned __int8 *v16; // eax
  float v18; // [esp+8h] [ebp-3Ch]
  int v19; // [esp+Ch] [ebp-38h]
  int v20; // [esp+10h] [ebp-34h]
  int v21[5]; // [esp+14h] [ebp-30h] BYREF
  float v22; // [esp+28h] [ebp-1Ch]
  float v23; // [esp+2Ch] [ebp-18h]
  int v24; // [esp+3Ch] [ebp-8h]

  v24 = a4;
  *(_WORD *)(a1 + 0x9C) = 0;
  v5 = sub_4A8FC(a1);
  v6 = 0;
  v7 = *(_DWORD *)(a1 + 0x15A);
  *(_DWORD *)(a1 + 0x88) = v5;
  v8 = (char *)(a1 + 0xAB);
  if ( v7 > 0 )
  {
    do
    {
      if ( *v8 != (char)0xFF )
      {
        *(_WORD *)(v8 + 1) = *((_WORD *)&dword_107062 + 0x35 * *v8);
      }
      ++v6;
      v8 += 7;
    }
    while ( v6 < *(_DWORD *)(a1 + 0x15A) );
  }
  if ( *(_BYTE *)(a1 + 0x58) == 5 )
  {
    v9 = *(_DWORD *)(a1 + 0x59);
    v10 = *(float **)(v9 + 4);
    v11 = *(float **)v9;
    v21[3] = (int)v21;
    v18 = v11[2] - v10[2];
    *(float *)&v19 = v11[3] - v10[3];
    *(float *)&v20 = v11[4] - v10[4];
    *(float *)v21 = v18;
    v21[1] = v19;
    v21[2] = v20;
    v12 = sqrt(*(float *)&v19 * *(float *)&v19 + v18 * v18 + *(float *)&v20 * *(float *)&v20);
    v13 = *(_DWORD *)(a1 + 0xC) + *(_DWORD *)(a1 + 8);
    v22 = v12;
    v21[4] = v13;
    LOBYTE(v11) = *(_BYTE *)(v9 + 0x23);
    v23 = (float)v13;
    if ( ((unsigned __int8)v11 & 1) != 0 )
    {
      v23 = v23 * flt_927BF;
    }
    if ( byte_A310F[0x1EE * *(__int16 *)(a1 + 0x56)] == 0x12 )
    {
      if ( v23 < 1.0 )
      {
        v23 = 1.0;
      }
      v23 = v23 * flt_927C3;
    }
    v14 = *(float *)(a1 + 0x9E) + v23;
    *(float *)(a1 + 0x9E) = v14;
    if ( v14 > v22 )
    {
      *(float *)(a1 + 0x9E) = v22;
    }
    if ( *(float *)(a1 + 0x9E) == v22 )
    {
      if ( (*(_DWORD *)(a1 + 0xA2) & 0x7FFFFFFF) != 0 )
      {
        v15 = *(_DWORD *)(*(_DWORD *)(a1 + 0x59) + 4);
      }
      else
      {
        v15 = **(_DWORD **)(a1 + 0x59);
      }
      v16 = (unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA];
      if ( *(_WORD *)(a1 + 0x56) == (unsigned __int8)byte_104BEA )
      {
        sub_45A54(v16, v15, a1);
      }
      else if ( ((1 << byte_104BEA) & (*(unsigned __int8 *)(v15 + 0x14) | *(unsigned __int8 *)(v15 + 0x15))) != 0 )
      {
        sub_45D50(v16, v15, a1);
      }
      sub_1D3E8(v15, a1, 0);
      if ( *(_BYTE *)(a1 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x55A);
      }
    }
  }
  return sub_4A5B8(a1);
}
// 927BF: using guessed type float flt_927BF;
// 927C3: using guessed type float flt_927C3;
// 107062: using guessed type int dword_107062;

//----- (0004A8CC) --------------------------------------------------------
int __fastcall __spoils<> sub_4A8CC(int a1)
{
  int result; // eax

  result = (dword_A2F6C - *(_DWORD *)(a1 + 0x52)) / 0x64;
  if ( result < 0 )
  {
    return 0;
  }
  if ( result > 0xA )
  {
    return 0xA;
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C;

//----- (0004A8FC) --------------------------------------------------------
int __fastcall sub_4A8FC(int a1)
{
  int v2; // [esp+4h] [ebp-Ch]
  float v3; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 0x18);
  v3 = (double)sub_4A8CC(a1) * flt_927C7 + 1.0;
  if ( v3 >= 1.0 )
  {
    if ( v3 > (double)flt_927CB )
    {
      v3 = 2.0;
    }
  }
  else
  {
    v3 = 1.0;
  }
  return (int)((double)v2 * v3);
}
// 927C7: using guessed type float flt_927C7;
// 927CB: using guessed type float flt_927CB;

//----- (0004A988) --------------------------------------------------------
int __fastcall sub_4A988(int a1)
{
  int v1; // ebx
  int v2; // esi
  int v3; // ecx
  char *v4; // edx

  v1 = 0;
  v2 = 0;
  if ( *(int *)(a1 + 0x15A) > 0 )
  {
    v3 = a1;
    do
    {
      if ( *(_WORD *)(v3 + 0xAC) == 1 && *(_BYTE *)(v3 + 0xAB) != 0xFF )
      {
        v4 = (char *)&unk_107020 + 0x6A * *(char *)(v3 + 0xAB);
        v1 += *(_DWORD *)(v4 + 0x46);
        switch ( v4[0x32] )
        {
          case 0:
            v1 += *(_DWORD *)(v4 + 0x3A) / 5 + 0xA * *(_DWORD *)(v4 + 0x3E);
            break;
          case 1:
            v1 += 5 * *(_DWORD *)(v4 + 0x3E);
            break;
          case 2:
            v1 += 2 * *(_DWORD *)(v4 + 0x3E);
            break;
          case 3:
            v1 += *(_DWORD *)(v4 + 0x3E);
            break;
          case 5:
            v1 += *(_DWORD *)(v4 + 0x3A) / 5 + 5 * *(_DWORD *)(v4 + 0x3E);
            break;
          default:
            break;
        }
      }
      ++v2;
      v3 += 7;
    }
    while ( v2 < *(_DWORD *)(a1 + 0x15A) );
  }
  return (4 * *(_DWORD *)(a1 + 0x8C) + 0xA * sub_4A8FC(a1) + v1) / 0xA;
}

//----- (0004AA78) --------------------------------------------------------
int __fastcall sub_4AA78(int a1, int a2)
{
  int v3; // eax

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x5B6);
  }
  if ( *(_BYTE *)(a1 + 0x58) != 4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x5B7);
  }
  v3 = *(_DWORD *)(a1 + 0x59);
  if ( a2 == v3 )
  {
    return 0;
  }
  *(_BYTE *)(a1 + 0x5D) = 1;
  *(_DWORD *)(a1 + 0x5E) = a2;
  return (unsigned __int8)byte_D5D47[0x64 * *(__int16 *)(v3 + 4) + *(__int16 *)(a2 + 4)];
}

//----- (0004AAEC) --------------------------------------------------------
int __fastcall sub_4AAEC(int a1, int a2)
{
  int v2; // eax
  unsigned int v3; // ebp
  int v4; // eax
  int v5; // esi
  int v6; // ecx
  double v7; // st7
  int v8; // edx
  _BYTE *i; // edx
  int v10; // eax
  int v11; // ebx
  unsigned int v12; // eax
  int v13; // edi
  int v14; // ecx
  float *v15; // esi
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  int v20[107]; // [esp+8h] [ebp-218h] BYREF
  float v21; // [esp+1B4h] [ebp-6Ch]
  float v22; // [esp+1B8h] [ebp-68h]
  float v23; // [esp+1BCh] [ebp-64h]
  float v24; // [esp+1C0h] [ebp-60h]
  float v25; // [esp+1C4h] [ebp-5Ch]
  float v26; // [esp+1C8h] [ebp-58h]
  int v27[3]; // [esp+1CCh] [ebp-54h] BYREF
  int v28[3]; // [esp+1D8h] [ebp-48h] BYREF
  int v29; // [esp+1E4h] [ebp-3Ch]
  int v30; // [esp+1E8h] [ebp-38h]
  int *v31; // [esp+1ECh] [ebp-34h]
  int v32; // [esp+1F0h] [ebp-30h]
  int v33; // [esp+1F4h] [ebp-2Ch]
  int *v34; // [esp+1F8h] [ebp-28h]
  float v35; // [esp+1FCh] [ebp-24h]
  int v36; // [esp+200h] [ebp-20h]
  float *v37; // [esp+204h] [ebp-1Ch]
  float v38; // [esp+208h] [ebp-18h]

  v29 = a1;
  v36 = a2;
  v30 = 0;
  if ( *(_BYTE *)(a1 + 0x58) == 4 )
  {
    v2 = sub_1D794(*(__int16 **)(a1 + 0x59), v20);
    if ( v2 > 0 )
    {
      v3 = 0;
      v32 = 4 * v2;
      v37 = (float *)(v29 + 0x9E);
      while ( 1 )
      {
        v4 = v20[v3 / 4];
        if ( *(__int16 *)(v4 + 0x56) == v36 && *(_BYTE *)(v4 + 0x58) == 4 )
        {
          v5 = 0;
          v31 = v27;
          v21 = 0.0;
          v22 = 0.0;
          v23 = 0.0;
          v21 = *v37 - *(float *)(v4 + 0x9E);
          v22 = v37[1] - *(float *)(v4 + 0xA2);
          v23 = v37[2] - *(float *)(v4 + 0xA6);
          *(float *)v27 = v21;
          *(float *)&v27[1] = v22;
          *(float *)&v27[2] = v23;
          v6 = 0;
          v7 = sqrt(v22 * v22 + v21 * v21 + v23 * v23);
          v8 = v20[v3 / 4];
          v38 = v7;
          for ( i = (_BYTE *)(v8 + 0xAB); ; i += 7 )
          {
            v10 = v20[v3 / 4];
            if ( v6 >= *(_DWORD *)(v10 + 0x15A) )
            {
              break;
            }
            if ( *i != 0xFF )
            {
              v11 = 0x6A * (char)*i;
              if ( byte_107052[v11] == 3 )
              {
                v33 = 0x20 * *(int *)((char *)&dword_10705A + 0x6A * (char)*i);
                if ( (double)v33 >= v38 )
                {
                  v5 += *(int *)((char *)&dword_107082 + v11);
                }
              }
            }
            ++v6;
          }
          if ( v5 > 0 && v5 > 2 * *(_DWORD *)(v29 + 0x24) )
          {
            v12 = sub_4937C(v10, 0x29);
            v30 = 1;
            if ( v12 != 0xFFFFFFFF )
            {
              break;
            }
          }
        }
        v3 += 4;
        if ( (int)v3 >= v32 )
        {
          goto LABEL_20;
        }
      }
      v30 = 2;
    }
LABEL_20:
    if ( !v30 )
    {
      v13 = 0;
      v14 = 0;
      v15 = (float *)(v29 + 0x9E);
      while ( 1 )
      {
        v16 = *(_DWORD *)(v29 + 0x59);
        if ( v13 >= *(__int16 *)(v16 + 0x5A) )
        {
          break;
        }
        v17 = *(_DWORD *)(v14 + v16 + 0x46);
        if ( *(unsigned __int8 *)(v17 + 0x57) == v36 )
        {
          v34 = v28;
          v24 = 0.0;
          v25 = 0.0;
          v26 = 0.0;
          v24 = *v15 - *(float *)v17;
          v25 = v15[1] - *(float *)(v17 + 4);
          v26 = v15[2] - *(float *)(v17 + 8);
          *(float *)v28 = v24;
          *(float *)&v28[1] = v25;
          *(float *)&v28[2] = v26;
          v35 = sqrt(v25 * v25 + v24 * v24 + v26 * v26);
          v18 = (unsigned __int16)sub_35930(v17, 0x10);
          if ( v18 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(v17 + 0x10) + 4 * v18 + 2) & 1) != 0 && v35 < (double)flt_927E7 )
          {
            return 1;
          }
        }
        v14 += 4;
        ++v13;
      }
    }
  }
  return v30;
}
// 927E7: using guessed type float flt_927E7;
// 10705A: using guessed type int dword_10705A;
// 107082: using guessed type int dword_107082;

//----- (0004AE8C) --------------------------------------------------------
__int64 __fastcall sub_4AE8C(int a1, unsigned int a2, int a3)
{
  _DWORD *v4; // edx
  unsigned __int8 v5; // al
  __int64 result; // rax
  int v7; // ebp
  int v8; // ebp
  int v9[13]; // [esp+0h] [ebp-3BCh] BYREF
  _WORD v10[59]; // [esp+34h] [ebp-388h] BYREF
  char v11; // [esp+AAh] [ebp-312h]
  char v12[175]; // [esp+ABh] [ebp-311h] BYREF
  int v13; // [esp+15Ah] [ebp-262h]
  int v14; // [esp+15Eh] [ebp-25Eh]
  int v15[13]; // [esp+164h] [ebp-258h] BYREF
  char v16[28]; // [esp+198h] [ebp-224h] BYREF
  __int16 v17; // [esp+1B4h] [ebp-208h]
  int v18; // [esp+1B6h] [ebp-206h]
  char v19[7]; // [esp+1BAh] [ebp-202h]
  char v20; // [esp+1C1h] [ebp-1FBh]
  int v21; // [esp+1C2h] [ebp-1FAh]
  char v22; // [esp+1C6h] [ebp-1F6h]
  int v23; // [esp+1C7h] [ebp-1F5h]
  char v24; // [esp+1CBh] [ebp-1F1h]
  int v25; // [esp+1CCh] [ebp-1F0h]
  int v26; // [esp+1D0h] [ebp-1ECh]
  int v27; // [esp+1D4h] [ebp-1E8h]
  int v28; // [esp+1D8h] [ebp-1E4h]
  int v29; // [esp+1DCh] [ebp-1E0h]
  int v30; // [esp+1E0h] [ebp-1DCh]
  int v31; // [esp+1E4h] [ebp-1D8h]
  int v32; // [esp+1E8h] [ebp-1D4h]
  int v33; // [esp+1ECh] [ebp-1D0h]
  int v34; // [esp+1F0h] [ebp-1CCh]
  int v35; // [esp+1F4h] [ebp-1C8h]
  int v36; // [esp+1F8h] [ebp-1C4h]
  int v37; // [esp+1FCh] [ebp-1C0h]
  _WORD v38[3]; // [esp+200h] [ebp-1BCh]
  int v39; // [esp+206h] [ebp-1B6h]
  int v40; // [esp+20Ah] [ebp-1B2h]
  char v41; // [esp+20Eh] [ebp-1AEh]
  int v42; // [esp+2BEh] [ebp-FEh]
  int v43; // [esp+2C2h] [ebp-FAh]
  char v44[105]; // [esp+2C8h] [ebp-F4h] BYREF
  char v45[105]; // [esp+334h] [ebp-88h] BYREF
  int v46; // [esp+3A0h] [ebp-1Ch]
  _DWORD *v47; // [esp+3A4h] [ebp-18h]
  unsigned int count; // [esp+3A8h] [ebp-14h]

  count = a2;
  v46 = a1 + 0xAB;
  v47 = (_DWORD *)(a1 + 0x9E);
  if ( a3 == 0xFFFFFFFF )
  {
    sub_48B90(v15);
    sub_1BF94((P_Type1)count, v15, 0x162u);
    *(_DWORD *)a1 = v15[0];
    *(_DWORD *)(a1 + 4) = v15[1];
    *(_DWORD *)(a1 + 8) = v15[2];
    *(_DWORD *)(a1 + 0xC) = v15[3];
    *(_DWORD *)(a1 + 0x10) = v15[4];
    *(_DWORD *)(a1 + 0x14) = v15[5];
    *(_DWORD *)(a1 + 0x18) = v15[6];
    *(_DWORD *)(a1 + 0x1C) = v15[7];
    *(_DWORD *)(a1 + 0x20) = v15[8];
    *(_DWORD *)(a1 + 0x24) = v15[9];
    *(_DWORD *)(a1 + 0x28) = v15[0xA];
    *(_DWORD *)(a1 + 0x2C) = v15[0xB];
    *(_DWORD *)(a1 + 0x30) = v15[0xC];
    qmemcpy((void *)(a1 + 0x34), v16, 0x1Cu);
    *(_WORD *)(a1 + 0x50) = v17;
    *(_DWORD *)(a1 + 0x52) = v18;
    *(_WORD *)(a1 + 0x56) = *(_WORD *)v19;
    *(_BYTE *)(a1 + 0x58) = v19[2];
    *(_DWORD *)(a1 + 0x59) = *(_DWORD *)&v19[3];
    *(_BYTE *)(a1 + 0x5D) = v20;
    *(_DWORD *)(a1 + 0x5E) = v21;
    *(_BYTE *)(a1 + 0x62) = v22;
    *(_DWORD *)(a1 + 0x63) = v23;
    *(_BYTE *)(a1 + 0x67) = v24;
    *(_DWORD *)(a1 + 0x68) = v25;
    *(_DWORD *)(a1 + 0x6C) = v26;
    *(_DWORD *)(a1 + 0x70) = v27;
    *(_DWORD *)(a1 + 0x74) = v28;
    *(_DWORD *)(a1 + 0x78) = v29;
    *(_DWORD *)(a1 + 0x7C) = v30;
    *(_DWORD *)(a1 + 0x80) = v31;
    *(_DWORD *)(a1 + 0x84) = v32;
    *(_DWORD *)(a1 + 0x88) = v33;
    *(_DWORD *)(a1 + 0x8C) = v34;
    *(_DWORD *)(a1 + 0x90) = v35;
    *(_DWORD *)(a1 + 0x94) = v36;
    *(_DWORD *)(a1 + 0x98) = v37;
    *(_WORD *)(a1 + 0x9C) = v38[0];
    v4 = v47;
    *v47 = *(_DWORD *)&v38[1];
    v4[1] = v39;
    v4[2] = v40;
    *(_BYTE *)(a1 + 0xAA) = v41;
    _wcpp_2_assign_array_(sub_4B780);
    *(_DWORD *)(a1 + 0x15A) = v42;
    *(_DWORD *)(a1 + 0x15E) = v43;
    switch ( *(_BYTE *)(a1 + 0x5D) )
    {
      case 0:
      case 7:
        *(_DWORD *)(a1 + 0x5E) = 0;
        break;
      case 1:
        *(_DWORD *)(a1 + 0x5E) = &word_A3D21[0x30 * *(_DWORD *)(a1 + 0x5E)];
        break;
      case 2:
      case 3:
        *(_DWORD *)(a1 + 0x5E) = (char *)&unk_BB1B3 + 0x7B * *(_DWORD *)(a1 + 0x5E);
        break;
      case 4:
      case 5:
      case 6:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x642);
        break;
      default:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x647);
        break;
    }
    v5 = *(_BYTE *)(a1 + 0x58);
    if ( v5 < 3u )
    {
      if ( !v5 )
      {
LABEL_16:
        qmemcpy(v45, "InVoid", sizeof(v45));
        sub_2620C("Bad m_LocationType: %s", (char)&v45[0xF * *(_BYTE *)(a1 + 0x58)]);
        sub_261B8(0, "..\\ship.cpp", 0x67A);
        LODWORD(result) = v15;
        HIDWORD(result) = 0;
        return result;
      }
    }
    else
    {
      if ( v5 > 4u )
      {
        if ( v5 == 5 )
        {
          *(_DWORD *)(a1 + 0x59) = (char *)&unk_A62A3 + 0x27 * *(_DWORD *)(a1 + 0x59);
          LODWORD(result) = v15;
          HIDWORD(result) = 0;
          return result;
        }
        goto LABEL_16;
      }
      if ( v5 == 4 )
      {
        *(_DWORD *)(a1 + 0x59) = &word_A3D21[0x30 * *(_DWORD *)(a1 + 0x59)];
        LODWORD(result) = v15;
        HIDWORD(result) = 0;
        return result;
      }
    }
    *(_DWORD *)(a1 + 0x59) = (char *)&unk_BB1B3 + 0x7B * *(_DWORD *)(a1 + 0x59);
    LODWORD(result) = v15;
    HIDWORD(result) = 0;
    return result;
  }
  v9[0] = *(_DWORD *)a1;
  v9[1] = *(_DWORD *)(a1 + 4);
  v9[2] = *(_DWORD *)(a1 + 8);
  v9[3] = *(_DWORD *)(a1 + 0xC);
  v9[4] = *(_DWORD *)(a1 + 0x10);
  v9[5] = *(_DWORD *)(a1 + 0x14);
  v9[6] = *(_DWORD *)(a1 + 0x18);
  v9[7] = *(_DWORD *)(a1 + 0x1C);
  v9[8] = *(_DWORD *)(a1 + 0x20);
  v9[9] = *(_DWORD *)(a1 + 0x24);
  v9[0xA] = *(_DWORD *)(a1 + 0x28);
  v9[0xB] = *(_DWORD *)(a1 + 0x2C);
  v9[0xC] = *(_DWORD *)(a1 + 0x30);
  qmemcpy(v10, (const void *)(a1 + 0x34), 0x6Au);
  *(_DWORD *)&v10[0x35] = *v47;
  *(_DWORD *)&v10[0x37] = v47[1];
  *(_DWORD *)&v10[0x39] = v47[2];
  v11 = *(_BYTE *)(a1 + 0xAA);
  _wcpp_2_copy_array_(v12, v46, 0x19, &unk_96038);
  v13 = *(_DWORD *)(a1 + 0x15A);
  v14 = *(_DWORD *)(a1 + 0x15E);
  switch ( *(_BYTE *)(a1 + 0x5D) )
  {
    case 0:
    case 7:
      break;
    case 1:
      *(_DWORD *)&v10[0x15] = *(__int16 *)(*(_DWORD *)(a1 + 0x5E) + 4);
      break;
    case 2:
    case 3:
      *(_DWORD *)&v10[0x15] = (*(_DWORD *)(a1 + 0x5E) - (int)&unk_BB1B3) / 0x7B;
      break;
    case 4:
    case 5:
    case 6:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x6A7);
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x6AC);
      break;
  }
  switch ( *(_BYTE *)(a1 + 0x58) )
  {
    case 1:
    case 2:
      *(_DWORD *)((char *)&v10[0x12] + 1) = (*(_DWORD *)(a1 + 0x59) - (int)&unk_BB1B3) / 0x7B;
      break;
    case 3:
      v7 = *(_DWORD *)(a1 + 0x59);
      if ( !v7 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x6C0);
      }
      *(_DWORD *)((char *)&v10[0x12] + 1) = (v7 - (int)&unk_BB1B3) / 0x7B;
      break;
    case 4:
      *(_DWORD *)((char *)&v10[0x12] + 1) = *(__int16 *)(*(_DWORD *)(a1 + 0x59) + 4);
      break;
    case 5:
      v8 = *(_DWORD *)(a1 + 0x59);
      if ( !v8 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x6CF);
      }
      *(_DWORD *)((char *)&v10[0x12] + 1) = (v8 - (int)&unk_A62A3) / 0x27;
      break;
    default:
      qmemcpy(v44, "InVoid", sizeof(v44));
      sub_2620C("Bad m_LocationType: %s", (char)&v44[0xF * *(_BYTE *)(a1 + 0x58)]);
      sub_261B8(0, "..\\ship.cpp", 0x6EE);
      break;
  }
  sub_1C098(count, (int)v9, 0x162u);
  LODWORD(result) = v9;
  HIDWORD(result) = 0;
  return result;
}
// 78B30: using guessed type _DWORD __stdcall _wcpp_2_assign_array_(_DWORD);
// 78B54: using guessed type int __fastcall _wcpp_2_copy_array_(_DWORD, _DWORD, _DWORD, _DWORD);
// A3D21: using guessed type __int16 word_A3D21[];
// 4AE8C: using guessed type char var_311[175];

//----- (0004B5C0) --------------------------------------------------------
int __fastcall sub_4B5C0(int result, int a2)
{
  *(_BYTE *)result = *(_BYTE *)a2;
  *(_WORD *)(result + 1) = *(_WORD *)(a2 + 1);
  *(_DWORD *)(result + 3) = *(_DWORD *)(a2 + 3);
  return result;
}

//----- (0004B5E0) --------------------------------------------------------
int __fastcall sub_4B5E0(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // eax
  int result; // eax

  *a1 = *(_DWORD *)a2;
  a1[1] = *(_DWORD *)(a2 + 4);
  a1[2] = *(_DWORD *)(a2 + 8);
  a1[3] = *(_DWORD *)(a2 + 0xC);
  a1[4] = *(_DWORD *)(a2 + 0x10);
  a1[5] = *(_DWORD *)(a2 + 0x14);
  a1[6] = *(_DWORD *)(a2 + 0x18);
  a1[7] = *(_DWORD *)(a2 + 0x1C);
  a1[8] = *(_DWORD *)(a2 + 0x20);
  a1[9] = *(_DWORD *)(a2 + 0x24);
  a1[0xA] = *(_DWORD *)(a2 + 0x28);
  a1[0xB] = *(_DWORD *)(a2 + 0x2C);
  a1[0xC] = *(_DWORD *)(a2 + 0x30);
  qmemcpy(a1 + 0xD, (const void *)(a2 + 0x34), 0x29u);
  v2 = (char *)a1 + 0x59;
  v2[4] = *(_BYTE *)(a2 + 0x5D);
  v2 += 4;
  *(_DWORD *)(v2 + 1) = *(_DWORD *)(a2 + 0x5E);
  v2[5] = *(_BYTE *)(a2 + 0x62);
  *(_DWORD *)(v2 + 6) = *(_DWORD *)(a2 + 0x63);
  v2[0xA] = *(_BYTE *)(a2 + 0x67);
  *(_DWORD *)(v2 + 0xB) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(v2 + 0xF) = *(_DWORD *)(a2 + 0x6C);
  *(_DWORD *)(v2 + 0x13) = *(_DWORD *)(a2 + 0x70);
  *(float *)(v2 + 0x17) = *(float *)(a2 + 0x74);
  *(_DWORD *)(v2 + 0x1B) = *(_DWORD *)(a2 + 0x78);
  *(_DWORD *)(v2 + 0x1F) = *(_DWORD *)(a2 + 0x7C);
  *(_DWORD *)(v2 + 0x23) = *(_DWORD *)(a2 + 0x80);
  *(_DWORD *)(v2 + 0x27) = *(_DWORD *)(a2 + 0x84);
  v2 += 0xFFFFFFA3;
  *((_DWORD *)v2 + 0x22) = *(_DWORD *)(a2 + 0x88);
  *((_DWORD *)v2 + 0x23) = *(_DWORD *)(a2 + 0x8C);
  *((_DWORD *)v2 + 0x24) = *(_DWORD *)(a2 + 0x90);
  *((_DWORD *)v2 + 0x25) = *(_DWORD *)(a2 + 0x94);
  *((_DWORD *)v2 + 0x26) = *(_DWORD *)(a2 + 0x98);
  *((_WORD *)v2 + 0x4E) = *(_WORD *)(a2 + 0x9C);
  v2 += 0x9E;
  *(_DWORD *)v2 = *(_DWORD *)(a2 + 0x9E);
  *((_DWORD *)v2 + 1) = *(_DWORD *)(a2 + 0xA2);
  *((_DWORD *)v2 + 2) = *(_DWORD *)(a2 + 0xA6);
  v2 += 0xFFFFFF62;
  v2[0xAA] = *(_BYTE *)(a2 + 0xAA);
  v3 = _wcpp_2_copy_array_(v2 + 0xAB, a2 + 0xAB, 0x19, &unk_96038);
  *(_DWORD *)(v3 + 0xAF) = *(_DWORD *)(a2 + 0x15A);
  result = v3 - 0xAB;
  *(_DWORD *)(result + 0x15E) = *(_DWORD *)(a2 + 0x15E);
  return result;
}
// 78B54: using guessed type int __fastcall _wcpp_2_copy_array_(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004B780) --------------------------------------------------------
int __fastcall sub_4B780(int result, int a2)
{
  *(_BYTE *)result = *(_BYTE *)a2;
  *(_WORD *)(result + 1) = *(_WORD *)(a2 + 1);
  *(_DWORD *)(result + 3) = *(_DWORD *)(a2 + 3);
  return result;
}

//----- (0004B7A0) --------------------------------------------------------
int __fastcall sub_4B7A0(int a1, int a2, int a3, __int16 a4)
{
  int v5; // edi
  int v6; // ebp
  int v7; // ebx
  char v8; // dh
  __int16 *v9; // ecx
  int v10; // ebx
  int v11; // ebx
  int v12; // edx
  int v13; // ebx
  int v16; // [esp+Ch] [ebp-14h]

  v16 = 0;
  if ( a4 < 0 || a4 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x2F);
  }
  if ( *(__int16 *)(a1 + 0x56) < 0 || SHIWORD(dword_A3CF2) <= *(__int16 *)(a1 + 0x56) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x30);
  }
  v5 = a3;
  v6 = 0;
  if ( (*(_WORD *)(a1 + 0x9C) & 0x10) != 0 )
  {
    v5 = 0;
  }
  v7 = *(_DWORD *)(a1 + 0x90);
  if ( v5 > v7 )
  {
    v5 = *(_DWORD *)(a1 + 0x90);
    v6 = a3 - v7;
    LOBYTE(v16) = 2;
  }
  if ( v6 >= *(_DWORD *)(a1 + 0x8C) )
  {
    v6 = *(_DWORD *)(a1 + 0x8C);
    LOBYTE(v16) = v16 | 4;
  }
  if ( a2 == 1 )
  {
    v8 = *(_BYTE *)(a1 + 0x58);
    v9 = 0;
    if ( v8 == 4 )
    {
      v9 = *(__int16 **)(a1 + 0x59);
    }
    else if ( v8 == 3 || v8 == 1 || v8 == 2 )
    {
      v9 = &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(a1 + 0x59) + 0xC)];
    }
    if ( !v9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x53);
    }
    sub_433E0((int)&byte_A2F72[0x1EE * *(__int16 *)(a1 + 0x56)], a4, (int)v9);
    v10 = *(_DWORD *)(a1 + 0x8C) - v6;
    *(_DWORD *)(a1 + 0x90) -= v5;
    *(_DWORD *)(a1 + 0x8C) = v10;
    if ( v10 < 1 )
    {
      v11 = *(_DWORD *)(a1 + 0xA7);
      v12 = *(_DWORD *)(a1 + 0x54);
      sub_49940(a1);
      v13 = v11 >> 0x18;
      if ( v12 >> 0x10 == (unsigned __int8)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10 )
      {
        sub_55AEC((int)&V_Type3_stru_10AE70, 0xC, v13, (int)v9);
      }
    }
  }
  return v16;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];

//----- (0004B944) --------------------------------------------------------
int __fastcall sub_4B944(int a1, int a2)
{
  _BYTE *v3; // eax
  unsigned int v4; // ecx
  char *v5; // edi
  int v6; // esi
  double v7; // st7
  __int16 v8; // ax
  BOOL v9; // eax
  int v10; // ebx
  int v11; // eax
  double v13; // st7
  double v14; // st7
  double v15; // st7
  double v16; // st7
  double v17; // st7
  int v18; // eax
  unsigned int v19; // edx
  int v20; // ebx
  double v21; // st7
  double v22; // st7
  double v23; // st7
  int v24; // ebx
  int v25; // eax
  int v26; // esi
  int v27; // eax
  int v28; // eax
  int v29; // ebp
  float *v30; // ebx
  unsigned int v31; // edx
  int v32; // ecx
  double v33; // st7
  double v34; // st7
  int v35; // ecx
  int v36; // ebx
  int v37; // ebp
  int v38; // eax
  int v39; // edx
  int v40; // ebx
  char v41; // cl
  _BYTE *v42; // eax
  int v43; // ebp
  int i; // edx
  int v45; // eax
  char v46; // ch
  _BYTE *v47; // edx
  int v48; // ebp
  int v49; // eax
  int v50; // ebx
  char v51; // bh
  int v52; // edi
  int v53; // ebx
  _BYTE *v54; // ecx
  char v55; // dh
  int v56; // edx
  char v57; // al
  float *v58; // ebx
  float *v59; // edx
  char v60; // ch
  float x_4; // [esp+4h] [ebp-524h]
  int v62[107]; // [esp+8h] [ebp-520h] BYREF
  int v63[132]; // [esp+1B4h] [ebp-374h] BYREF
  float v64; // [esp+3C4h] [ebp-164h] BYREF
  float v65; // [esp+3C8h] [ebp-160h]
  float v66; // [esp+3CCh] [ebp-15Ch]
  float v67; // [esp+3D0h] [ebp-158h] BYREF
  float v68; // [esp+3D4h] [ebp-154h]
  float v69; // [esp+3D8h] [ebp-150h]
  float v70; // [esp+3DCh] [ebp-14Ch] BYREF
  float v71; // [esp+3E0h] [ebp-148h]
  float v72; // [esp+3E4h] [ebp-144h]
  float v73; // [esp+3E8h] [ebp-140h]
  float v74; // [esp+3ECh] [ebp-13Ch]
  float v75; // [esp+3F0h] [ebp-138h]
  float v76; // [esp+3F4h] [ebp-134h] BYREF
  float v77; // [esp+3F8h] [ebp-130h]
  float v78; // [esp+3FCh] [ebp-12Ch]
  float v79; // [esp+400h] [ebp-128h]
  float v80; // [esp+404h] [ebp-124h]
  float v81; // [esp+408h] [ebp-120h]
  float v82; // [esp+40Ch] [ebp-11Ch] BYREF
  float v83; // [esp+410h] [ebp-118h]
  float v84; // [esp+414h] [ebp-114h]
  float v85; // [esp+418h] [ebp-110h]
  float v86; // [esp+41Ch] [ebp-10Ch]
  float v87; // [esp+420h] [ebp-108h]
  float v88; // [esp+424h] [ebp-104h] BYREF
  float v89; // [esp+428h] [ebp-100h]
  float v90; // [esp+42Ch] [ebp-FCh]
  float v91; // [esp+430h] [ebp-F8h]
  float v92; // [esp+434h] [ebp-F4h]
  float v93; // [esp+438h] [ebp-F0h]
  float v94; // [esp+43Ch] [ebp-ECh]
  float v95; // [esp+440h] [ebp-E8h]
  float v96; // [esp+444h] [ebp-E4h]
  int v97[3]; // [esp+448h] [ebp-E0h] BYREF
  float v98; // [esp+454h] [ebp-D4h]
  float v99; // [esp+458h] [ebp-D0h]
  float v100; // [esp+45Ch] [ebp-CCh]
  float v101; // [esp+460h] [ebp-C8h] BYREF
  float v102; // [esp+464h] [ebp-C4h]
  float v103; // [esp+468h] [ebp-C0h]
  float v104; // [esp+46Ch] [ebp-BCh]
  float v105; // [esp+470h] [ebp-B8h]
  float v106; // [esp+474h] [ebp-B4h]
  float v107; // [esp+478h] [ebp-B0h]
  float v108; // [esp+47Ch] [ebp-ACh]
  float v109; // [esp+480h] [ebp-A8h]
  float v110; // [esp+484h] [ebp-A4h]
  float v111; // [esp+488h] [ebp-A0h]
  float v112; // [esp+48Ch] [ebp-9Ch]
  float v113; // [esp+490h] [ebp-98h] BYREF
  float v114; // [esp+494h] [ebp-94h]
  float v115; // [esp+498h] [ebp-90h]
  float v116; // [esp+49Ch] [ebp-8Ch]
  int v117; // [esp+4A0h] [ebp-88h]
  int v118; // [esp+4A4h] [ebp-84h]
  int *v119; // [esp+4A8h] [ebp-80h]
  float *v120; // [esp+4ACh] [ebp-7Ch]
  float *v121; // [esp+4B0h] [ebp-78h]
  float *v122; // [esp+4B4h] [ebp-74h]
  float *v123; // [esp+4B8h] [ebp-70h]
  float *v124; // [esp+4BCh] [ebp-6Ch]
  float *v125; // [esp+4C0h] [ebp-68h]
  float *v126; // [esp+4C8h] [ebp-60h]
  float *v127; // [esp+4CCh] [ebp-5Ch]
  int v128; // [esp+4D0h] [ebp-58h]
  int v129; // [esp+4D4h] [ebp-54h]
  int v130; // [esp+4D8h] [ebp-50h]
  float v131; // [esp+4DCh] [ebp-4Ch]
  float v132; // [esp+4E0h] [ebp-48h]
  float v133; // [esp+4E4h] [ebp-44h]
  int v134; // [esp+4E8h] [ebp-40h]
  int v135; // [esp+4ECh] [ebp-3Ch]
  int v136; // [esp+4F0h] [ebp-38h]
  float v137; // [esp+4F4h] [ebp-34h]
  float v138; // [esp+4F8h] [ebp-30h]
  float v139; // [esp+4FCh] [ebp-2Ch]
  float v140; // [esp+500h] [ebp-28h]
  int v141; // [esp+508h] [ebp-20h]
  char v142; // [esp+50Ch] [ebp-1Ch]
  char v143; // [esp+510h] [ebp-18h]

  v129 = a2;
  v3 = *(_BYTE **)(a1 + 0x63);
  v134 = 0;
  v128 = 0xFFFFFFFF;
  v4 = 0xFFFFFFFF;
  LOBYTE(v3) = *v3;
  v130 = 0;
  v142 = (char)v3;
  if ( (_BYTE)v3 == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0xA2);
  }
  v5 = (char *)&unk_107020 + 0x6A * v142;
  if ( *(_DWORD *)(v5 + 0x36) > *(_DWORD *)(a1 + 0x88) )
  {
    v128 = 0;
  }
  else
  {
    v130 = *(_DWORD *)(v5 + 0x36);
  }
  v6 = *(_DWORD *)(a1 + 0x68);
  if ( !v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0xAD);
  }
  if ( *(_BYTE *)(a1 + 0x58) != 4 || *(_BYTE *)(v6 + 0x58) != 4 || *(_DWORD *)(a1 + 0x59) != *(_DWORD *)(v6 + 0x59) )
  {
    goto LABEL_18;
  }
  if ( *(_DWORD *)(v5 + 0x3A) )
  {
    v119 = v97;
    v104 = 0.0;
    v105 = 0.0;
    v106 = 0.0;
    v104 = *(float *)(v6 + 0x9E) - *(float *)(a1 + 0x9E);
    v105 = *(float *)(v6 + 0xA2) - *(float *)(a1 + 0xA2);
    v106 = *(float *)(v6 + 0xA6) - *(float *)(a1 + 0xA6);
    *(float *)v97 = v104;
    *(float *)&v97[1] = v105;
    *(float *)&v97[2] = v106;
    v7 = sqrt(v105 * v105 + v104 * v104 + v106 * v106);
    v141 = 0x20 * *(_DWORD *)(v5 + 0x3A);
    v8 = *(_WORD *)(a1 + 0x9C);
    v131 = v7;
    v133 = (float)v141;
    if ( (v8 & 4) != 0 )
    {
      v133 = v133 * flt_928C7;
    }
    if ( v131 > (double)v133 )
    {
      v4 = 0;
    }
    if ( v142 == 0x2F && v133 * dbl_928CB > v131 )
    {
LABEL_18:
      v4 = 0;
    }
  }
  v9 = v128 && v4 && v6 != a1 && (*(_WORD *)(v5 + 0x33) & 1) != 0;
  v134 |= v9;
  if ( (v134 & 1) == 0 )
  {
    return v134;
  }
  *(_DWORD *)(a1 + 0x78) = *(_DWORD *)(v6 + 0x9E);
  *(_DWORD *)(a1 + 0x7C) = *(_DWORD *)(v6 + 0xA2);
  *(_DWORD *)(a1 + 0x80) = *(_DWORD *)(v6 + 0xA6);
  v10 = 0;
  if ( !v5[0x32] )
  {
    v10 = *(_DWORD *)(v5 + 0x52);
  }
  if ( v142 == 0x2F )
  {
    v10 = *(_DWORD *)(v5 + 0x4A);
  }
  if ( v10 )
  {
    v11 = sub_4B7A0(v6, v129, v10, *(_WORD *)(a1 + 0x56));
    v134 |= v11;
  }
  else
  {
    LOBYTE(v134) = v134 | 0x10;
  }
  if ( v129 != 1 )
  {
    return v134;
  }
  v56 = *(_DWORD *)(a1 + 0x88) - v130;
  v57 = v142;
  *(_DWORD *)(a1 + 0x88) = v56;
  if ( (unsigned __int8)v57 < 0x32u )
  {
    if ( (unsigned __int8)v57 < 0x25u )
    {
      if ( (unsigned __int8)v57 >= 0x22u )
      {
        if ( (unsigned __int8)v57 <= 0x22u )
        {
          *(_DWORD *)(v6 + 0x52) = dword_A2F6C;
          return v134;
        }
        else
        {
          if ( v57 == 0x23 )
          {
            *(_DWORD *)(v6 + 0x88) = 0;
          }
          return v134;
        }
      }
      if ( v57 == 0x21 )
      {
        v55 = *(_BYTE *)(v6 + 0x9C);
        *(_DWORD *)(v6 + 0x94) = 0;
        *(_BYTE *)(v6 + 0x9C) = v55 | 1;
        return v134;
      }
      return v134;
    }
    if ( (unsigned __int8)v57 > 0x25u )
    {
      if ( (unsigned __int8)v57 < 0x2Du )
      {
        if ( v57 != 0x28 )
        {
          return v134;
        }
        v28 = sub_1D794(*(__int16 **)(a1 + 0x59), v62);
        v29 = 0;
        if ( v28 > 0 )
        {
          v30 = (float *)(v6 + 0x9E);
          v31 = 0;
          v135 = 4 * v28;
          do
          {
            v32 = v62[v31 / 4];
            if ( v6 != v32 )
            {
              v125 = &v82;
              v79 = 0.0;
              v80 = 0.0;
              v81 = 0.0;
              v79 = *(float *)(v32 + 0x9E) - *v30;
              v80 = *(float *)(v32 + 0xA2) - *(float *)(v6 + 0xA2);
              v81 = *(float *)(v32 + 0xA6) - *(float *)(v6 + 0xA6);
              v82 = v79;
              v83 = v80;
              v84 = v81;
              v33 = sqrt(v80 * v80 + v79 * v79 + v81 * v81);
              v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
              v137 = (float)v141;
              if ( v33 < v137 )
              {
                sub_53054(&v82, v137);
                v91 = 0.0;
                v92 = 0.0;
                v93 = 0.0;
                v123 = &v70;
                v91 = *v30 + v82;
                v92 = *(float *)(v6 + 0xA2) + v83;
                v34 = *(float *)(v6 + 0xA6);
                v70 = v91;
                v93 = v34 + v84;
                v71 = v92;
                v35 = v62[v31 / 4];
                v72 = v93;
                *(float *)(v35 + 0x9E) = v91;
                *(float *)(v35 + 0xA2) = v71;
                *(float *)(v35 + 0xA6) = v72;
              }
            }
            v31 += 4;
            ++v29;
          }
          while ( (int)v31 < v135 );
        }
      }
      else
      {
        if ( (unsigned __int8)v57 <= 0x2Du )
        {
          v121 = &v64;
          v94 = 0.0;
          v95 = 0.0;
          v96 = 0.0;
          v94 = *(float *)(v6 + 0x9E) - *(float *)(a1 + 0x9E);
          v95 = *(float *)(v6 + 0xA2) - *(float *)(a1 + 0xA2);
          v13 = *(float *)(v6 + 0xA6) - *(float *)(a1 + 0xA6);
          v64 = v94;
          v96 = v13;
          v65 = v95;
          v66 = v96;
          v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
          x_4 = (float)v141;
          sub_53054(&v64, x_4);
          v120 = &v76;
          v110 = 0.0;
          v111 = 0.0;
          v112 = 0.0;
          v110 = *(float *)(v6 + 0x9E) + v64;
          v111 = *(float *)(v6 + 0xA2) + v65;
          v14 = *(float *)(v6 + 0xA6) + v66;
          v76 = v110;
          v112 = v14;
          v77 = v111;
          v78 = v112;
          *(float *)(v6 + 0x9E) = v110;
          *(float *)(v6 + 0xA2) = v77;
          *(float *)(v6 + 0xA6) = v78;
          return v134;
        }
        if ( (unsigned __int8)v57 >= 0x30u )
        {
          if ( (unsigned __int8)v57 > 0x30u )
          {
            v60 = *(_BYTE *)(v6 + 0x9C);
            *(_DWORD *)(v6 + 0x90) = 0;
            *(_BYTE *)(v6 + 0x9C) = v60 | 8;
            return v134;
          }
          v52 = *(_DWORD *)(v6 + 0x15A);
          v53 = 0;
          v54 = (_BYTE *)(v6 + 0xAB);
          while ( v53 < v52 )
          {
            if ( *v54 == 0x47 || *v54 == 0x49 )
            {
              sub_492F8((_DWORD *)v6, v53);
            }
            ++v53;
            v52 = *(_DWORD *)(v6 + 0x15A);
            v54 += 7;
          }
        }
      }
      return v134;
    }
LABEL_84:
    v143 = 0;
    if ( v142 == 0x42 )
    {
      v143 = 5;
    }
    v47 = (_BYTE *)(v6 + 0xAB);
    v48 = 0;
    v49 = 0;
    if ( *(int *)(v6 + 0x15A) > 0 )
    {
      v50 = 0;
      do
      {
        if ( *v47 != 0xFF && byte_107052[0x6A * (char)*v47] == v143 )
        {
          ++v50;
          ++v48;
          v63[v50 + 0x6A] = v49;
        }
        ++v49;
        v47 += 7;
      }
      while ( v49 < *(_DWORD *)(v6 + 0x15A) );
    }
    if ( v48 )
    {
      sub_492F8((_DWORD *)v6, v63[dword_A2F6C % v48 + 0x6B]);
      return v134;
    }
    return v134;
  }
  if ( (unsigned __int8)v57 <= 0x32u )
  {
LABEL_74:
    v41 = 5;
    if ( v142 == 0x32 )
    {
      v41 = 0;
    }
    v42 = (_BYTE *)(v6 + 0xAB);
    v43 = 0;
    for ( i = 0; i < *(_DWORD *)(v6 + 0x15A); v42 += 7 )
    {
      if ( *v42 != 0xFF && v41 == byte_107052[0x6A * (char)*v42] )
      {
        ++v43;
      }
      ++i;
    }
    v45 = *(_DWORD *)(v6 + 0x8C) - v43;
    *(_DWORD *)(v6 + 0x8C) = v45;
    if ( v45 < 1 )
    {
      v46 = v134 | 4;
      sub_49940(v6);
      LOBYTE(v134) = v46;
      return v134;
    }
    return v134;
  }
  v58 = (float *)(v6 + 0x9E);
  if ( (unsigned __int8)v57 < 0x3Du )
  {
    v59 = (float *)(a1 + 0x9E);
    if ( (unsigned __int8)v57 < 0x36u )
    {
      if ( v57 != 0x34 )
      {
        return v134;
      }
      v126 = &v113;
      v73 = 0.0;
      v74 = 0.0;
      v75 = 0.0;
      v73 = *v58 - *v59;
      v74 = *(float *)(v6 + 0xA2) - *(float *)(a1 + 0xA2);
      v75 = *(float *)(v6 + 0xA6) - *(float *)(a1 + 0xA6);
      v113 = v73;
      v114 = v74;
      v115 = v75;
      v15 = sqrt(v74 * v74 + v73 * v73 + v75 * v75);
      v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
      v16 = v15 - (double)v141;
      v132 = v16;
      if ( v16 < flt_928D3 )
      {
        v132 = 64.0;
      }
      sub_53054(&v113, v132);
      v98 = 0.0;
      v99 = 0.0;
      v100 = 0.0;
      v127 = &v101;
      v98 = *(float *)(a1 + 0x9E) + v113;
      v99 = *(float *)(a1 + 0xA2) + v114;
      v17 = *(float *)(a1 + 0xA6);
      v101 = v98;
      v100 = v17 + v115;
      v102 = v99;
      v103 = v100;
      *(float *)(v6 + 0x9E) = v98;
      *(float *)(v6 + 0xA2) = v102;
      *(float *)(v6 + 0xA6) = v103;
      return v134;
    }
    if ( (unsigned __int8)v57 > 0x36u )
    {
      if ( (unsigned __int8)v57 <= 0x37u )
      {
        v116 = *v59;
        v117 = *(_DWORD *)(a1 + 0xA2);
        v118 = *(_DWORD *)(a1 + 0xA6);
        *v59 = *v58;
        *(_DWORD *)(a1 + 0xA2) = *(_DWORD *)(v6 + 0xA2);
        *(_DWORD *)(a1 + 0xA6) = *(_DWORD *)(v6 + 0xA6);
        *v58 = v116;
        *(_DWORD *)(v6 + 0xA2) = v117;
        *(_DWORD *)(v6 + 0xA6) = v118;
        return v134;
      }
      if ( v57 != 0x3B )
      {
        return v134;
      }
      v25 = *(_DWORD *)(v6 + 0x98) - *(_DWORD *)(v6 + 0x8C);
      if ( v25 > *(_DWORD *)(v5 + 0x4A) )
      {
        v25 = *(_DWORD *)(v5 + 0x4A);
      }
      *(_DWORD *)(v6 + 0x8C) += v25;
      v26 = *(_DWORD *)(a1 + 0x8C) - v25;
      *(_DWORD *)(a1 + 0x8C) = v26;
      if ( v26 < 1 )
      {
        sub_49940(a1);
        return v134;
      }
      return v134;
    }
    goto LABEL_74;
  }
  if ( (unsigned __int8)v57 <= 0x3Du )
  {
    sub_49940(v6);
    v51 = v134 | 4;
    sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - (a1 + 0xAB)) / 7);
    LOBYTE(v134) = v51;
    return v134;
  }
  if ( (unsigned __int8)v57 < 0x42u )
  {
    if ( v57 != 0x40 )
    {
      return v134;
    }
    v36 = *(_DWORD *)(v6 + 0x15E);
    if ( !v36 )
    {
      return v134;
    }
    v37 = dword_A2F6C % v36;
    v38 = 0;
    v39 = 0;
    if ( *(int *)(v6 + 0x15A) <= 0 )
    {
      return v134;
    }
    v40 = v6;
    do
    {
      if ( *(_BYTE *)(v40 + 0xAB) != 0xFF )
      {
        if ( v39 == v37 )
        {
          sub_492F8((_DWORD *)v6, v38);
          return v134;
        }
        ++v39;
      }
      ++v38;
      v40 += 7;
    }
    while ( v38 < *(_DWORD *)(v6 + 0x15A) );
    return v134;
  }
  if ( (unsigned __int8)v57 <= 0x42u )
  {
    goto LABEL_84;
  }
  if ( (unsigned __int8)v57 < 0x44u )
  {
    return v134;
  }
  if ( (unsigned __int8)v57 > 0x44u )
  {
    if ( v57 != 0x4A )
    {
      return v134;
    }
    v18 = sub_1D794(*(__int16 **)(a1 + 0x59), v63);
    if ( v18 > 0 )
    {
      v19 = 0;
      v136 = 4 * v18;
      do
      {
        v20 = v63[v19 / 4];
        if ( v6 != v20 )
        {
          v122 = &v88;
          v107 = 0.0;
          v108 = 0.0;
          v109 = 0.0;
          v107 = *(float *)(v20 + 0x9E) - *(float *)(v6 + 0x9E);
          v108 = *(float *)(v20 + 0xA2) - *(float *)(v6 + 0xA2);
          v109 = *(float *)(v20 + 0xA6) - *(float *)(v6 + 0xA6);
          v88 = v107;
          v89 = v108;
          v90 = v109;
          v21 = sqrt(v108 * v108 + v107 * v107 + v109 * v109);
          v141 = 0x20 * *(_DWORD *)(v5 + 0x4E);
          v138 = v21;
          v139 = (float)v141;
          if ( v138 > (double)v139 )
          {
            v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
            v22 = v138 - (double)v141;
            v140 = v22;
            if ( v22 < v139 )
            {
              v140 = v139;
            }
            sub_53054(&v88, v140);
            v124 = &v67;
            v85 = 0.0;
            v86 = 0.0;
            v87 = 0.0;
            v85 = *(float *)(v6 + 0x9E) + v88;
            v86 = *(float *)(v6 + 0xA2) + v89;
            v23 = *(float *)(v6 + 0xA6);
            v67 = v85;
            v87 = v23 + v90;
            v68 = v86;
            v24 = v63[v19 / 4];
            v69 = v87;
            *(float *)(v24 + 0x9E) = v85;
            *(float *)(v24 + 0xA2) = v68;
            *(float *)(v24 + 0xA6) = v69;
          }
        }
        v19 += 4;
      }
      while ( (int)v19 < v136 );
    }
    return v134;
  }
  v27 = *(_DWORD *)(v6 + 0x18) - *(_DWORD *)(v6 + 0x88);
  if ( v27 > v56 )
  {
    v27 = v56;
  }
  *(_DWORD *)(v6 + 0x88) += v27;
  *(_DWORD *)(a1 + 0x88) -= v27;
  return v134;
}
// 928C7: using guessed type float flt_928C7;
// 928CB: using guessed type double dbl_928CB;
// 928D3: using guessed type float flt_928D3;
// A2F6C: using guessed type int dword_A2F6C;

//----- (0004C7FC) --------------------------------------------------------
int __fastcall sub_4C7FC(int a1, int a2)
{
  char v2; // cl
  char *v3; // esi
  unsigned int v4; // edi
  int v5; // ebp
  int v6; // eax
  int v7; // ebp
  float *v8; // edx
  double v9; // st7
  __int16 v10; // ax
  BOOL v11; // eax
  unsigned __int8 *v13; // esi
  int v14; // edi
  float v15; // [esp+8h] [ebp-60h]
  float v16; // [esp+Ch] [ebp-5Ch]
  float v17; // [esp+10h] [ebp-58h]
  int v18[3]; // [esp+14h] [ebp-54h] BYREF
  float v19; // [esp+20h] [ebp-48h]
  float v20; // [esp+24h] [ebp-44h]
  float v21; // [esp+28h] [ebp-40h]
  int *v22; // [esp+2Ch] [ebp-3Ch]
  int v23; // [esp+30h] [ebp-38h]
  int v24; // [esp+34h] [ebp-34h]
  float v25; // [esp+38h] [ebp-30h]
  int v26; // [esp+3Ch] [ebp-2Ch]
  int v27; // [esp+40h] [ebp-28h]
  float v28; // [esp+44h] [ebp-24h]
  int v29; // [esp+48h] [ebp-20h]
  _DWORD *v30; // [esp+4Ch] [ebp-1Ch]
  int v31; // [esp+50h] [ebp-18h]

  v30 = (_DWORD *)a1;
  v24 = a2;
  v2 = **(_BYTE **)(a1 + 0x63);
  v29 = 0;
  v26 = 0;
  v3 = (char *)&unk_107020 + 0x6A * v2;
  v4 = 0xFFFFFFFF;
  v5 = *(_DWORD *)(a1 + 0x88);
  v6 = *(_DWORD *)(v3 + 0x36);
  v27 = 0xFFFFFFFF;
  if ( v6 > v5 )
  {
    v27 = 0;
  }
  else
  {
    v26 = v6;
  }
  v7 = v30[0x1A];
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x217);
  }
  v15 = *(float *)v7;
  v16 = *(float *)(v7 + 4);
  v8 = (float *)v30;
  v17 = *(float *)(v7 + 8);
  v30[0x1E] = *(_DWORD *)v7;
  v8[0x1F] = v16;
  v8[0x20] = v17;
  if ( *(_DWORD *)(v3 + 0x3A) )
  {
    v22 = v18;
    v19 = 0.0;
    v20 = 0.0;
    v21 = 0.0;
    v19 = v15 - *(float *)((char *)v30 + 0x9E);
    v20 = v16 - *(float *)((char *)v30 + 0xA2);
    v21 = v17 - *(float *)((char *)v30 + 0xA6);
    *(float *)v18 = v19;
    *(float *)&v18[1] = v20;
    *(float *)&v18[2] = v21;
    v9 = sqrt(v20 * v20 + v19 * v19 + v21 * v21);
    v23 = 0x20 * *(_DWORD *)(v3 + 0x3A);
    v10 = *((_WORD *)v30 + 0x4E);
    v25 = v9;
    v28 = (float)v23;
    if ( (v10 & 4) != 0 )
    {
      v28 = v28 * flt_928E6;
    }
    if ( v25 > (double)v28 )
    {
      v4 = 0;
    }
    if ( v2 == 0x2F && v28 * dbl_928EA > v25 )
    {
      v4 = 0;
    }
  }
  v11 = v27 && v4 && (*(_WORD *)(v3 + 0x33) & 0xC) != 0;
  v29 |= v11;
  if ( (v29 & 1) == 0 || v24 != 1 )
  {
    return v29;
  }
  v30[0x22] -= v26;
  if ( !v3[0x32] )
  {
    sub_36A5C(v7, *(_DWORD *)(v3 + 0x52), *((_WORD *)v30 + 0x2B));
    return v29;
  }
  if ( v2 != 0x46 )
  {
    return v29;
  }
  v13 = *(unsigned __int8 **)(v7 + 0x10);
  v14 = 0;
  v31 = 0;
  while ( v14 < *(unsigned __int16 *)(v7 + 0x18) && v31 < 5 )
  {
    if ( *v13 != 0xFF
      && (*((_WORD *)v13 + 1) & 1) != 0
      && !(*(int *)((char *)&dword_103F9A[0xA * v13[1]] + 2) >> 0x18)
      && sub_34B0C(v7, (unsigned __int16)v14, 0xFFu, 1u) == 0xFFFFFFFF )
    {
      ++v31;
    }
    ++v14;
    v13 += 4;
  }
  sub_492F8(v30, (*(_DWORD *)((char *)v30 + 0x63) - ((int)v30 + 0xAB)) / 7);
  return v29;
}
// 928E6: using guessed type float flt_928E6;
// 928EA: using guessed type double dbl_928EA;
// 103F9A: using guessed type int dword_103F9A[];

//----- (0004CAB8) --------------------------------------------------------
int __fastcall sub_4CAB8(int a1, int a2)
{
  unsigned __int8 v3; // cl
  char *v4; // ebp
  int v5; // edx
  int v6; // eax
  int v7; // esi
  double v8; // st7
  int v9; // eax
  BOOL v10; // eax
  float *v12; // eax
  float *v13; // edx
  float *v14; // eax
  int v15; // ebx
  int v16; // edx
  char *v17; // eax
  int v18; // ecx
  int v19[3]; // [esp+8h] [ebp-78h] BYREF
  int v20[3]; // [esp+14h] [ebp-6Ch] BYREF
  float v21; // [esp+20h] [ebp-60h]
  float v22; // [esp+24h] [ebp-5Ch]
  float v23; // [esp+28h] [ebp-58h]
  float v24; // [esp+2Ch] [ebp-54h]
  float v25; // [esp+30h] [ebp-50h]
  float v26; // [esp+34h] [ebp-4Ch]
  float v27; // [esp+38h] [ebp-48h]
  float v28; // [esp+3Ch] [ebp-44h]
  float v29; // [esp+40h] [ebp-40h]
  int *v30; // [esp+44h] [ebp-3Ch]
  int v31; // [esp+48h] [ebp-38h]
  int *v32; // [esp+4Ch] [ebp-34h]
  float v33; // [esp+50h] [ebp-30h]
  int v34; // [esp+54h] [ebp-2Ch]
  int v35; // [esp+58h] [ebp-28h]
  int v36; // [esp+5Ch] [ebp-24h]
  int v37; // [esp+60h] [ebp-20h]
  int v38; // [esp+64h] [ebp-1Ch]
  float v39; // [esp+68h] [ebp-18h]

  v34 = a2;
  v3 = **(_BYTE **)(a1 + 0x63);
  v38 = 0;
  v37 = 0xFFFFFFFF;
  v4 = (char *)&unk_107020 + 0x6A * (char)v3;
  v35 = 0;
  v5 = *(_DWORD *)(a1 + 0x88);
  v6 = *(_DWORD *)(v4 + 0x36);
  v36 = 0xFFFFFFFF;
  if ( v6 > v5 )
  {
    v36 = 0;
  }
  else
  {
    v35 = v6;
  }
  v7 = *(_DWORD *)(a1 + 0x68);
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x275);
  }
  v27 = *(float *)(v7 + 0x14);
  v28 = *(float *)(v7 + 0x18);
  v29 = *(float *)(v7 + 0x1C);
  if ( *(_DWORD *)v7 == *(_DWORD *)(a1 + 0x59) )
  {
    v27 = *(float *)(v7 + 8);
    v28 = *(float *)(v7 + 0xC);
    v29 = *(float *)(v7 + 0x10);
  }
  *(float *)(a1 + 0x78) = v27;
  *(float *)(a1 + 0x7C) = v28;
  *(float *)(a1 + 0x80) = v29;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  v30 = v19;
  v24 = v27 - *(float *)(a1 + 0x9E);
  v25 = v28 - *(float *)(a1 + 0xA2);
  v26 = v29 - *(float *)(a1 + 0xA6);
  *(float *)v19 = v24;
  *(float *)&v19[1] = v25;
  *(float *)&v19[2] = v26;
  v8 = sqrt(v25 * v25 + v24 * v24 + v26 * v26);
  v9 = *(_DWORD *)(v4 + 0x3A);
  v33 = v8;
  if ( v9 )
  {
    v31 = 0x20 * v9;
    if ( (double)(0x20 * v9) < v33 )
    {
      v37 = 0;
    }
  }
  v10 = v36 && v37 && (*(_WORD *)(v4 + 0x33) & 2) != 0;
  v38 |= v10;
  if ( v34 != 1 || (v38 & 1) == 0 )
  {
    return v38;
  }
  *(_DWORD *)(a1 + 0x88) -= v35;
  if ( !v4[0x32] && *(int *)(v4 + 0x52) > 1 )
  {
    *(_BYTE *)(v7 + 0x23) &= ~2u;
    return v38;
  }
  if ( v3 < 0x33u )
  {
    if ( v3 == 0x20 )
    {
      *(_BYTE *)(v7 + 0x23) |= 2u;
      return v38;
    }
    return v38;
  }
  if ( v3 <= 0x33u )
  {
    v13 = *(float **)(v7 + 4);
    v14 = *(float **)v7;
    v32 = v20;
    v15 = 0;
    v21 = 0.0;
    v22 = 0.0;
    v23 = 0.0;
    v21 = v14[2] - v13[2];
    v22 = v14[3] - v13[3];
    v23 = v14[4] - v13[4];
    *(float *)v20 = v21;
    *(float *)&v20[1] = v22;
    *(float *)&v20[2] = v23;
    v16 = 0;
    v39 = sqrt(v22 * v22 + v21 * v21 + v23 * v23);
    v17 = (char *)&unk_CA1F1;
    do
    {
      if ( v16 >= SHIWORD(dword_D35E5) )
      {
        break;
      }
      if ( *((__int16 *)v17 + 0x2B) != 0xFFFFFFFF )
      {
        if ( v17[0x58] == 5 && v7 == *(_DWORD *)(v17 + 0x59) )
        {
          *(float *)(v17 + 0x9E) = v39;
        }
        ++v16;
      }
      ++v15;
      v17 += 0x162;
    }
    while ( v15 < 0x6B );
    goto LABEL_37;
  }
  if ( v3 < 0x3Cu )
  {
    return v38;
  }
  if ( v3 <= 0x3Cu )
  {
    v18 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 == *(_DWORD *)(a1 + 0x59) )
    {
      v18 = *(_DWORD *)(v7 + 4);
    }
    sub_1D538(*(_DWORD *)(a1 + 0x59), a1);
    *(_BYTE *)(a1 + 0x58) = 5;
    *(_DWORD *)(a1 + 0x59) = v7;
    sub_1D3E8(v18, a1, 0);
LABEL_37:
    sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - (a1 + 0xAB)) / 7);
    return v38;
  }
  if ( v3 != 0x3E )
  {
    return v38;
  }
  v12 = *(float **)v7;
  if ( *(_DWORD *)v7 == *(_DWORD *)(a1 + 0x59) )
  {
    v12 = *(float **)(v7 + 4);
  }
  *((_BYTE *)v12 + 0x17) |= 1 << *(_BYTE *)(a1 + 0x56);
  return v38;
}
// D35E5: using guessed type int dword_D35E5;

//----- (0004CDF8) --------------------------------------------------------
int __fastcall sub_4CDF8(int a1, int a2)
{
  unsigned __int8 *v3; // ecx
  int v4; // ebp
  unsigned __int8 v5; // cl
  char *v6; // edi
  double v8; // st7
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // edx
  int v12; // eax
  double v13; // st7
  double v14; // st7
  int v15; // edi
  int v16; // ebp
  int v17; // eax
  int v18; // eax
  unsigned int v19; // ebp
  int v20; // edx
  double v21; // st7
  int v22; // edx
  int v23; // ecx
  int i; // edx
  int v25; // eax
  char v26; // bh
  int v27; // ebx
  int v28; // eax
  int v29; // ebp
  int v30; // eax
  int v31; // ecx
  int v32; // edx
  int v33; // ebp
  int v34; // eax
  float *v35; // edx
  unsigned int v36; // ebx
  int v37; // ecx
  double v38; // st7
  double v39; // st7
  int v40; // ecx
  int v41; // eax
  int v42[107]; // [esp+8h] [ebp-770h] BYREF
  int v43[107]; // [esp+1B4h] [ebp-5C4h] BYREF
  int v44[107]; // [esp+360h] [ebp-418h] BYREF
  int v45[107]; // [esp+50Ch] [ebp-26Ch] BYREF
  float v46; // [esp+6B8h] [ebp-C0h]
  float v47; // [esp+6BCh] [ebp-BCh]
  float v48; // [esp+6C0h] [ebp-B8h]
  float v49; // [esp+6C4h] [ebp-B4h] BYREF
  float v50; // [esp+6C8h] [ebp-B0h]
  float v51; // [esp+6CCh] [ebp-ACh]
  float v52; // [esp+6D0h] [ebp-A8h] BYREF
  float v53; // [esp+6D4h] [ebp-A4h]
  float v54; // [esp+6D8h] [ebp-A0h]
  float v55; // [esp+6DCh] [ebp-9Ch] BYREF
  float v56; // [esp+6E0h] [ebp-98h]
  float v57; // [esp+6E4h] [ebp-94h]
  float v58; // [esp+6E8h] [ebp-90h]
  float v59; // [esp+6ECh] [ebp-8Ch]
  float v60; // [esp+6F0h] [ebp-88h]
  float v61; // [esp+6F4h] [ebp-84h]
  float v62; // [esp+6F8h] [ebp-80h]
  float v63; // [esp+6FCh] [ebp-7Ch]
  int v64[3]; // [esp+700h] [ebp-78h] BYREF
  float v65; // [esp+70Ch] [ebp-6Ch]
  float v66; // [esp+710h] [ebp-68h]
  float v67; // [esp+714h] [ebp-64h]
  float *v68; // [esp+718h] [ebp-60h]
  float *v69; // [esp+71Ch] [ebp-5Ch]
  int *v70; // [esp+720h] [ebp-58h]
  float *v71; // [esp+728h] [ebp-50h]
  int v72; // [esp+730h] [ebp-48h]
  int v73; // [esp+734h] [ebp-44h]
  int v74; // [esp+738h] [ebp-40h]
  int v75; // [esp+73Ch] [ebp-3Ch]
  int v76; // [esp+740h] [ebp-38h]
  int v77; // [esp+744h] [ebp-34h]
  int v78; // [esp+748h] [ebp-30h]
  float v79; // [esp+74Ch] [ebp-2Ch]
  float v80; // [esp+750h] [ebp-28h]
  float *v81; // [esp+754h] [ebp-24h]
  float v82; // [esp+758h] [ebp-20h]
  float v83; // [esp+75Ch] [ebp-1Ch]
  int v84; // [esp+760h] [ebp-18h]

  v77 = a2;
  v3 = *(unsigned __int8 **)(a1 + 0x63);
  v4 = 0;
  v73 = 0;
  v5 = *v3;
  v72 = 0xFFFFFFFF;
  if ( v5 == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x2EA);
  }
  v6 = (char *)&unk_107020 + 0x6A * (char)v5;
  if ( *(_DWORD *)(v6 + 0x36) > *(_DWORD *)(a1 + 0x88) )
  {
    v72 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(v6 + 0x36);
  }
  v73 |= v72 != 0;
  if ( (v73 & 1) == 0 )
  {
    return v73;
  }
  if ( v77 != 1 )
  {
    return v73;
  }
  *(_DWORD *)(a1 + 0x88) -= v4;
  if ( v5 < 0x39u )
  {
    if ( v5 < 0x27u )
    {
      if ( v5 >= 0x24u )
      {
        if ( v5 <= 0x24u )
        {
          sub_1D538(*(_DWORD *)(a1 + 0x59), a1);
          v17 = *(int *)((char *)&dword_A2F79 + 0x1EE * *(__int16 *)(a1 + 0x56));
          *(_DWORD *)(a1 + 0x59) = v17;
          sub_1D3E8(v17, a1, 0);
          return v73;
        }
        if ( v5 == 0x26 )
        {
          v28 = sub_1D794(*(__int16 **)(a1 + 0x59), v43);
          v78 = 0;
          if ( v28 > 0 )
          {
            v29 = 0;
            v75 = 4 * v28;
            do
            {
              v30 = v43[v29 / 4u];
              v31 = *(__int16 *)(a1 + 0x56);
              v32 = *(__int16 *)(v30 + 0x56);
              if ( v32 != v31 && byte_A3132[0x1EE * v31 + v32] == 2 )
              {
                sub_4B7A0(v30, v77, *(_DWORD *)(v6 + 0x4A), v31);
              }
              v29 += 4;
              ++v78;
            }
            while ( v29 < v75 );
          }
          sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - (a1 + 0xAB)) / 7);
          return v73;
        }
      }
    }
    else if ( v5 <= 0x27u )
    {
      v33 = 0;
      v34 = sub_1D794(*(__int16 **)(a1 + 0x59), v42);
      if ( v34 > 0 )
      {
        v35 = (float *)(a1 + 0x9E);
        v36 = 0;
        v76 = 4 * v34;
        do
        {
          v37 = v42[v36 / 4];
          if ( a1 != v37 )
          {
            v71 = &v55;
            v46 = 0.0;
            v47 = 0.0;
            v48 = 0.0;
            v46 = *(float *)(v37 + 0x9E) - *v35;
            v47 = *(float *)(v37 + 0xA2) - *(float *)(a1 + 0xA2);
            v48 = *(float *)(v37 + 0xA6) - *(float *)(a1 + 0xA6);
            v55 = v46;
            v56 = v47;
            v57 = v48;
            v38 = sqrt(v47 * v47 + v46 * v46 + v48 * v48);
            v84 = 0x20 * *(_DWORD *)(v6 + 0x4A);
            v79 = (float)v84;
            if ( v38 < v79 )
            {
              sub_53054(&v55, v79);
              v58 = 0.0;
              v59 = 0.0;
              v60 = 0.0;
              v68 = &v52;
              v58 = *v35 + v55;
              v59 = *(float *)(a1 + 0xA2) + v56;
              v39 = *(float *)(a1 + 0xA6);
              v52 = v58;
              v60 = v39 + v57;
              v53 = v59;
              v40 = v42[v36 / 4];
              v54 = v60;
              *(float *)(v40 + 0x9E) = v58;
              *(float *)(v40 + 0xA2) = v53;
              *(float *)(v40 + 0xA6) = v54;
            }
          }
          v36 += 4;
          ++v33;
        }
        while ( (int)v36 < v76 );
      }
    }
    else
    {
      if ( v5 < 0x35u )
      {
        if ( v5 == 0x2E )
        {
          v69 = &v49;
          v65 = 0.0;
          v66 = 0.0;
          v67 = 0.0;
          v65 = -*(float *)(a1 + 0x9E);
          v66 = -*(float *)(a1 + 0xA2);
          v8 = -*(float *)(a1 + 0xA6);
          v49 = v65;
          v67 = v8;
          v50 = v66;
          v51 = v67;
          *(float *)(a1 + 0x9E) = v65;
          *(float *)(a1 + 0xA2) = v50;
          *(float *)(a1 + 0xA6) = v51;
        }
        return v73;
      }
      if ( v5 <= 0x35u )
      {
        *(_DWORD *)(a1 + 0x8C) -= *(_DWORD *)(v6 + 0x4A);
        v23 = *(_DWORD *)(a1 + 0x8C);
        *(_DWORD *)(a1 + 0x88) += *(_DWORD *)(v6 + 0x4E);
        if ( v23 < 1 )
        {
          goto LABEL_29;
        }
      }
      else
      {
        if ( v5 != 0x38 )
        {
          return v73;
        }
        v9 = sub_1D794(*(__int16 **)(a1 + 0x59), v44);
        if ( v9 > 0 )
        {
          v10 = 4 * v9;
          v11 = 0;
          do
          {
            v12 = v44[v11 / 4];
            if ( *(_BYTE *)(v12 + 0x58) == 4 )
            {
              v13 = sqrt(
                      *(float *)(v12 + 0xA2) * *(float *)(v12 + 0xA2)
                    + *(float *)(v12 + 0x9E) * *(float *)(v12 + 0x9E)
                    + *(float *)(v12 + 0xA6) * *(float *)(v12 + 0xA6));
              v84 = 0x20 * *(_DWORD *)(v6 + 0x4E);
              v80 = v13;
              v82 = (float)v84;
              if ( v80 > (double)v82 )
              {
                v84 = 0x20 * *(_DWORD *)(v6 + 0x4A);
                v14 = v80 - (double)v84;
                v83 = v14;
                if ( v14 < v82 )
                {
                  v83 = v82;
                }
                sub_53054((float *)(v44[v11 / 4] + 0x9E), v83);
              }
            }
            v11 += 4;
          }
          while ( (int)v11 < v10 );
        }
      }
    }
    return v73;
  }
  if ( v5 <= 0x39u )
  {
    *(_BYTE *)(a1 + 0x9C) |= 4u;
    return v73;
  }
  if ( v5 < 0x41u )
  {
    if ( v5 <= 0x3Au )
    {
      v15 = *(_DWORD *)(v6 + 0x4A) + *(_DWORD *)(a1 + 0x8C);
      v16 = *(_DWORD *)(a1 + 0x98);
      *(_DWORD *)(a1 + 0x8C) = v15;
      if ( v15 > v16 )
      {
        *(_DWORD *)(a1 + 0x8C) = v16;
        return v73;
      }
    }
    else
    {
      if ( v5 != 0x3F )
      {
        return v73;
      }
      v41 = sub_49328(a1, 2);
      if ( v41 != 0xFFFFFFFF )
      {
        sub_492F8((_DWORD *)a1, v41);
        *(_BYTE *)(a1 + 0x9C) |= 2u;
        return v73;
      }
    }
    return v73;
  }
  v25 = a1 + 0xAB;
  if ( v5 <= 0x41u )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); v25 += 7 )
    {
      v26 = *(_BYTE *)v25;
      if ( *(_BYTE *)v25 != 0xFF && v26 != 0x41 )
      {
        v27 = 0x6A * v26;
        if ( *(int *)((char *)&dword_107062 + v27) )
        {
          *(_WORD *)(v25 + 1) = *(_WORD *)((char *)&dword_107062 + v27);
        }
      }
      ++i;
    }
    return v73;
  }
  if ( v5 >= 0x48u )
  {
    if ( v5 > 0x48u )
    {
      if ( v5 == 0x4B )
      {
        v22 = *(_DWORD *)(a1 + 0x63);
        *(_DWORD *)(a1 + 0x88) += *(_DWORD *)(v6 + 0x4A);
        sub_492F8((_DWORD *)a1, (v22 - v25) / 7);
      }
      return v73;
    }
    v18 = sub_1D794(*(__int16 **)(a1 + 0x59), v45);
    if ( v18 > 0 )
    {
      v19 = 0;
      v81 = (float *)(a1 + 0x9E);
      v74 = 4 * v18;
      do
      {
        v20 = v45[v19 / 4];
        if ( a1 != v20 )
        {
          v61 = 0.0;
          v62 = 0.0;
          v63 = 0.0;
          v70 = v64;
          v61 = *(float *)(v20 + 0x9E) - *v81;
          v62 = *(float *)(v20 + 0xA2) - v81[1];
          v63 = *(float *)(v20 + 0xA6) - v81[2];
          *(float *)v64 = v61;
          *(float *)&v64[1] = v62;
          *(float *)&v64[2] = v63;
          v21 = sqrt(v62 * v62 + v61 * v61 + v63 * v63);
          v84 = 0x20 * *(_DWORD *)(v6 + 0x3A);
          if ( (double)v84 >= v21 )
          {
            sub_4B7A0(v45[v19 / 4], v77, *(_DWORD *)(v6 + 0x4A), *(_WORD *)(a1 + 0x56));
          }
        }
        v19 += 4;
      }
      while ( (int)v19 < v74 );
    }
LABEL_29:
    sub_49940(a1);
    return v73;
  }
  if ( v5 == 0x45 )
  {
    *(_BYTE *)(a1 + 0x9C) |= 0x10u;
    sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - v25) / 7);
  }
  return v73;
}
// A2F79: using guessed type int dword_A2F79;
// 107062: using guessed type int dword_107062;

//----- (0004D700) --------------------------------------------------------
_DWORD *sub_4D700()
{
  _DWORD *result; // eax

  _wcpp_2_mod_register_(&unk_96AC0);
  result = sub_48B90(&dword_108FE8);
  dword_96AC8 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96AC8: using guessed type int dword_96AC8;
// 108FE8: using guessed type int dword_108FE8;

//----- (0004D724) --------------------------------------------------------
int __fastcall sub_4D724(T_Type5 *a1, int a2, int a3, int a4)
{
  int v5; // eax
  T_Rect *p_rect; // esi

  if ( a4 )
  {
    sub_5E9D0(a1, 0x96);
  }
  v5 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFED8);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x34);
  }
  sub_5CB3C(a1, v5, a3, 0x3F, 0x2D);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  p_rect = &a1->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = p_rect->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = p_rect->y1;
  return sub_2B8A8(
           (int)&V_Type3_stru_10AE70.z1[0x3026],
           0x3F,
           2,
           (const char *)&unk_107020 + 0x6A * a3,
           8,
           0xFFFFFFFF,
           0xFF,
           0x7A);
}
// FFED8: using guessed type __int16 word_FFED8;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0004D7A8) --------------------------------------------------------
unsigned int __fastcall sub_4D7A8(int a1, int a2, int a3)
{
  unsigned int v3; // ebx
  int v4; // esi
  int v5; // ecx
  int v6; // edi
  char v7; // al
  int i; // edx
  char v9; // al
  int j; // edx
  int v13; // [esp+4h] [ebp-20h]
  int v14; // [esp+8h] [ebp-1Ch]
  int v15; // [esp+Ch] [ebp-18h]
  int v16; // [esp+10h] [ebp-14h]

  v3 = 0xFFFFFFFF;
  v4 = a2 - 0x94;
  v5 = a1 - 0x16F;
  if ( a2 - 0x94 > 0 )
  {
    v15 = (v4 - v5 / 2 + 0x12) / 2 / 0x12;
    v14 = (v5 / 2 + v4 - 0x12) / 2 / 0x12;
    v13 = (unsigned __int8)byte_969A8[v15];
    if ( v15 < 0xE
      && v14 >= v13
      && v13 + (unsigned __int8)byte_969B8[v15] > v14
      && ((1 << (v14 - v13)) & (unsigned __int8)byte_106FE0[4 * v15 + a3]) != 0 )
    {
      v6 = 0;
      if ( v15 > 0 )
      {
        v16 = a3;
        do
        {
          v7 = 1;
          for ( i = 0; i < (unsigned __int8)byte_969B8[v6]; ++i )
          {
            if ( ((unsigned __int8)v7 & (unsigned __int8)byte_106FE0[v16]) != 0 )
            {
              ++v3;
            }
            v7 *= 2;
          }
          ++v6;
          v16 += 4;
        }
        while ( v6 < v15 );
      }
      v9 = 1;
      for ( j = 0; j <= v14 - v13; v9 *= 2 )
      {
        if ( ((unsigned __int8)v9 & (unsigned __int8)byte_106FE0[4 * v15 + a3]) != 0 )
        {
          ++v3;
        }
        ++j;
      }
    }
  }
  return v3;
}

//----- (0004D92C) --------------------------------------------------------
char *__fastcall sub_4D92C(int a1)
{
  char *v1; // edx

  sub_2C830((P_TypeA2)a1);
  v1 = (char *)sub_48B90((_DWORD *)(a1 + 0xCD)) + 0xFFFFFF33;
  *(_DWORD *)(v1 + 0xA7) = off_9607C;
  v1[0xBB] = 0xFF;
  v1[0xBC] = 0;
  *(_DWORD *)(v1 + 0xBD) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0xC1) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0xC5) = 0;
  *(_DWORD *)(v1 + 0xAB) = 0;
  *(_DWORD *)(v1 + 0xC9) = 0;
  sub_4DA5C((int)v1);
  return v1;
}
// 9607C: using guessed type int (*off_9607C[5])();

//----- (0004DA08) --------------------------------------------------------
void *__fastcall sub_4DA08(int a1, char a2, int a3, int a4)
{
  void *v5; // eax
  int v7; // eax
  void *v8; // eax
  void *v9; // ebx

  if ( (a2 & 4) != 0 )
  {
    v5 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96068);
    operator delete[](v5);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_9607C;
    v7 = sub_48C58(a4);
    v8 = (void *)sub_2C848(v7 - 0xCD, 1);
    v9 = v8;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v8);
    }
    return v9;
  }
}
// 48C58: using guessed type int __cdecl sub_48C58(_DWORD);
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 9607C: using guessed type int (*off_9607C[5])();

//----- (0004DA5C) --------------------------------------------------------
int __fastcall sub_4DA5C(int result)
{
  if ( dword_96ACC )
  {
    *(_DWORD *)(result + 0xB7) = 0x4C;
    dword_96ACC = 0;
  }
  return result;
}
// 96ACC: using guessed type int dword_96ACC;

//----- (0004DA7C) --------------------------------------------------------
int __fastcall sub_4DA7C(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v6; // [esp+8h] [ebp-10h]

  sub_4DA5C(a1);
  *(_DWORD *)(a1 + 0xAB) = a2;
  *(_DWORD *)(a1 + 0xC9) = a3;
  if ( a3 == 0xFFFFFFFF )
  {
    v6 = *(_DWORD *)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xCD) = *(_DWORD *)v6;
    *(_DWORD *)(a1 + 0xD1) = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(a1 + 0xD5) = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(a1 + 0xD9) = *(_DWORD *)(v6 + 0xC);
    *(_DWORD *)(a1 + 0xDD) = *(_DWORD *)(v6 + 0x10);
    *(_DWORD *)(a1 + 0xE1) = *(_DWORD *)(v6 + 0x14);
    *(_DWORD *)(a1 + 0xE5) = *(_DWORD *)(v6 + 0x18);
    *(_DWORD *)(a1 + 0xE9) = *(_DWORD *)(v6 + 0x1C);
    *(_DWORD *)(a1 + 0xED) = *(_DWORD *)(v6 + 0x20);
    *(_DWORD *)(a1 + 0xF1) = *(_DWORD *)(v6 + 0x24);
    *(_DWORD *)(a1 + 0xF5) = *(_DWORD *)(v6 + 0x28);
    *(_DWORD *)(a1 + 0xF9) = *(_DWORD *)(v6 + 0x2C);
    *(_DWORD *)(a1 + 0xFD) = *(_DWORD *)(v6 + 0x30);
    qmemcpy((void *)(a1 + 0x101), (const void *)(v6 + 0x34), 0x29u);
    *(_DWORD *)(a1 + 0x126) = *(_DWORD *)(v6 + 0x59);
    *(_DWORD *)(a1 + 0x126) = *(_DWORD *)(v6 + 0x59);
    *(_BYTE *)(a1 + 0x12A) = *(_BYTE *)(v6 + 0x5D);
    *(_DWORD *)(a1 + 0x12B) = *(_DWORD *)(v6 + 0x5E);
    *(_BYTE *)(a1 + 0x12F) = *(_BYTE *)(v6 + 0x62);
    *(_DWORD *)(a1 + 0x130) = *(_DWORD *)(v6 + 0x63);
    *(_BYTE *)(a1 + 0x134) = *(_BYTE *)(v6 + 0x67);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x139) = *(_DWORD *)(v6 + 0x6C);
    *(_DWORD *)(a1 + 0x13D) = *(_DWORD *)(v6 + 0x70);
    *(_DWORD *)(a1 + 0x141) = *(_DWORD *)(v6 + 0x74);
    *(float *)(a1 + 0x145) = *(float *)(v6 + 0x78);
    *(_DWORD *)(a1 + 0x149) = *(_DWORD *)(v6 + 0x7C);
    *(float *)(a1 + 0x14D) = *(float *)(v6 + 0x80);
    *(_DWORD *)(a1 + 0x151) = *(_DWORD *)(v6 + 0x84);
    *(_DWORD *)(a1 + 0x155) = *(_DWORD *)(v6 + 0x88);
    *(_DWORD *)(a1 + 0x159) = *(_DWORD *)(v6 + 0x8C);
    *(_DWORD *)(a1 + 0x15D) = *(_DWORD *)(v6 + 0x90);
    *(_DWORD *)(a1 + 0x161) = *(_DWORD *)(v6 + 0x94);
    *(_DWORD *)(a1 + 0x165) = *(_DWORD *)(v6 + 0x98);
    *(_WORD *)(a1 + 0x169) = *(_WORD *)(v6 + 0x9C);
    *(float *)(a1 + 0x16B) = *(float *)(v6 + 0x9E);
    *(_DWORD *)(a1 + 0x16F) = *(_DWORD *)(v6 + 0xA2);
    *(float *)(a1 + 0x173) = *(float *)(v6 + 0xA6);
    *(_BYTE *)(a1 + 0x177) = *(_BYTE *)(v6 + 0xAA);
    _wcpp_2_assign_array_(sub_4B780);
    *(_DWORD *)(a1 + 0x227) = *(_DWORD *)(v6 + 0x15A);
    *(_DWORD *)(a1 + 0x22B) = *(_DWORD *)(v6 + 0x15E);
  }
  result = a4;
  *(_DWORD *)(a1 + 0x233) = a4;
  return result;
}
// 78B30: using guessed type _DWORD __stdcall _wcpp_2_assign_array_(_DWORD);

//----- (0004DD14) --------------------------------------------------------
char __fastcall sub_4DD14(int a1)
{
  int v2; // eax
  int v3; // edi
  int v4; // ebp
  int v5; // eax
  int v6; // edx
  unsigned __int16 v7; // ax

  LOBYTE(v2) = sub_2ED4C(*(_DWORD *)(a1 + 0xC5));
  v3 = 0;
  if ( *(int *)(a1 + 0xB7) > 0 )
  {
    v4 = 0;
    do
    {
      LOBYTE(v2) = byte_107052[v4];
      if ( (_BYTE)v2 == *(_BYTE *)(a1 + 0xBC) )
      {
        v5 = (unsigned __int8)byte_107055[v4];
        if ( v5 == 0xFF
          || (v6 = *(int *)((char *)&dword_10529F + 0x4B * v5) >> 0x18,
              v2 = 1 << byte_104BEA,
              ((1 << byte_104BEA) & v6) != 0) )
        {
          v7 = sub_2EA8C(*(_DWORD *)(a1 + 0xC5), (const char *)a1, 0xFFFFFFFF, 0);
          LOBYTE(v2) = sub_2EC50(*(_DWORD *)(a1 + 0xC5), v7, v3);
        }
      }
      ++v3;
      v4 += 0x6A;
    }
    while ( v3 < *(_DWORD *)(a1 + 0xB7) );
  }
  return v2;
}
// 10529F: using guessed type int dword_10529F;

//----- (0004DDB0) --------------------------------------------------------
unsigned int __fastcall sub_4DDB0(int a1, __int16 a2, int a3, int a4)
{
  char v5; // al
  int v6; // ebx
  int v7; // ebx
  unsigned int result; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // ecx
  double v12; // st7
  double v13; // st7
  int i; // esi
  int v15; // edi
  int v16; // edx
  int v17; // ebx
  int v18; // edx
  int v19; // ebx

  if ( (unsigned __int16)a2 < 0x32u )
  {
    if ( (unsigned __int16)a2 >= 5u )
    {
      if ( (unsigned __int16)a2 <= 5u )
      {
        if ( *(_DWORD *)(a1 + 0x35)
          && a3 >= *(_DWORD *)(a1 + 8)
          && a3 <= *(_DWORD *)(a1 + 0x10)
          && a4 >= *(_DWORD *)(a1 + 0xC)
          && a4 <= *(_DWORD *)(a1 + 0x14) )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          if ( dword_96AD0 >= 0 )
          {
            if ( !*(_DWORD *)(a1 + 0xAB) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x1D8);
            }
            if ( sub_492F8(*(_DWORD **)(a1 + 0xAB), dword_96AD0) )
            {
              v18 = *(__int16 *)(a1 + 0x59);
              if ( v18 != 0xFFFFFFFF )
              {
                sub_4FB90((int)&unk_10914C, v18);
              }
              *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
              v19 = *(_DWORD *)(a1 + 0xA7);
              *(_DWORD *)(a1 + 0x22F) = 0xFFFFFFFF;
              (*(void (**)(void))(v19 + 0xC))();
            }
          }
          return 0xFFFFFFFF;
        }
      }
      else
      {
        if ( (unsigned __int16)a2 < 7u )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 8);
          if ( *(_DWORD *)(a1 + 0x39) && *(_DWORD *)(a1 + 0x35) && (dword_96AD0 >= 0 || *(_DWORD *)(a1 + 0x3D)) )
          {
            dword_96AD0 = 0xFFFFFFFF;
            (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          }
          else
          {
            dword_96AD0 = 0xFFFFFFFF;
          }
          return 0xFFFFFFFF;
        }
        if ( (unsigned __int16)a2 <= 7u )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
          if ( (*(_DWORD *)(a1 + 0x3D) & *(_DWORD *)(a1 + 0x35) & *(_DWORD *)(a1 + 0x39)) == 0xFFFFFFFF )
          {
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0x10))();
          }
          return 0xFFFFFFFF;
        }
        if ( a2 != 8 )
        {
          return sub_2F424(a1, a2, a3, a4);
        }
        if ( *(_DWORD *)(a1 + 0x233) != 0xFFFFFFFF )
        {
          if ( !*(_DWORD *)(a1 + 0xAB) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x13D);
          }
          dword_96AD0 = sub_4D7A8(a3, a4, *(char *)(*(_DWORD *)(a1 + 0xAB) + 0xAA));
          (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          return 0;
        }
      }
      return 0;
    }
    if ( (unsigned __int16)a2 < 2u )
    {
      if ( a2 == 1 )
      {
        if ( *(_DWORD *)(a1 + 0xAB) )
        {
          sub_4DA5C(a1);
        }
        else
        {
          *(_DWORD *)(a1 + 0xAB) = &dword_108FE8;
        }
        *(_DWORD *)(a1 + 0xC1) = 0xFFFFFFFF;
        v9 = 0;
        *(_DWORD *)(a1 + 0x22F) = 0;
        v10 = sub_56DA8((int)&V_Type3_stru_10AE70, "GIZLIST", 0);
        *(_DWORD *)(a1 + 0xC5) = v10;
        if ( !v10 )
        {
          v9 = 0x153;
          Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x153);
        }
        *(_DWORD *)(*(_DWORD *)(a1 + 0xC5) + 0xAB) = 0;
        sub_2F1C8(*(_DWORD *)(a1 + 0xC5), (int)sub_4D724);
        *(_WORD *)(*(_DWORD *)(a1 + 0xC5) + 0x8C9) = 0x40;
        sub_2E9CC(*(_DWORD *)(a1 + 0xC5), 0);
        *(_BYTE *)(*(_DWORD *)(a1 + 0xC5) + 0xC6) = 0xF2;
        if ( *(_BYTE *)(a1 + 0xBB) == 0xFF )
        {
          sub_4E644(a1, 4, v9, a4);
        }
        else
        {
          sub_4DD14(a1);
        }
        *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
        sub_2D258(a1, a2);
        return 0;
      }
    }
    else
    {
      if ( (unsigned __int16)a2 <= 2u )
      {
        *(_DWORD *)(a1 + 0x39) = 0;
        *(_DWORD *)(a1 + 0x35) = 0;
        v11 = *(_DWORD *)(a1 + 0xAB);
        dword_96AD0 = 0xFFFFFFFF;
        if ( &dword_108FE8 != (int *)v11 )
        {
          dword_108FE8 = *(_DWORD *)v11;
          dword_108FEC = *(_DWORD *)(v11 + 4);
          dword_108FF0 = *(_DWORD *)(v11 + 8);
          dword_108FF4 = *(_DWORD *)(v11 + 0xC);
          dword_108FF8 = *(_DWORD *)(v11 + 0x10);
          dword_108FFC = *(_DWORD *)(v11 + 0x14);
          dword_109000 = *(_DWORD *)(v11 + 0x18);
          dword_109004 = *(_DWORD *)(v11 + 0x1C);
          dword_109008 = *(_DWORD *)(v11 + 0x20);
          dword_10900C = *(_DWORD *)(v11 + 0x24);
          dword_109010 = *(_DWORD *)(v11 + 0x28);
          dword_109014 = *(_DWORD *)(v11 + 0x2C);
          dword_109018 = *(_DWORD *)(v11 + 0x30);
          qmemcpy(&unk_10901C, (const void *)(v11 + 0x34), 0x1Eu);
          dword_10903A = *(_DWORD *)(v11 + 0x52);
          word_10903E = *(_WORD *)(v11 + 0x56);
          byte_109040 = *(_BYTE *)(v11 + 0x58);
          dword_109041 = *(_DWORD *)(v11 + 0x59);
          dword_109041 = *(_DWORD *)(v11 + 0x59);
          dword_109041 = *(_DWORD *)(v11 + 0x59);
          byte_109045 = *(_BYTE *)(v11 + 0x5D);
          dword_109046 = *(_DWORD *)(v11 + 0x5E);
          byte_10904A = *(_BYTE *)(v11 + 0x62);
          dword_10904B = *(_DWORD *)(v11 + 0x63);
          byte_10904F = *(_BYTE *)(v11 + 0x67);
          dword_109050 = *(_DWORD *)(v11 + 0x68);
          dword_109050 = *(_DWORD *)(v11 + 0x68);
          dword_109050 = *(_DWORD *)(v11 + 0x68);
          dword_109050 = *(_DWORD *)(v11 + 0x68);
          flt_109054 = *(float *)(v11 + 0x6C);
          dword_109058 = *(_DWORD *)(v11 + 0x70);
          flt_10905C = *(float *)(v11 + 0x74);
          flt_109060 = *(float *)(v11 + 0x78);
          dword_109064 = *(_DWORD *)(v11 + 0x7C);
          v12 = *(float *)(v11 + 0x80);
          dword_10906C = *(_DWORD *)(v11 + 0x84);
          dword_109070 = *(_DWORD *)(v11 + 0x88);
          dword_109074 = *(_DWORD *)(v11 + 0x8C);
          dword_109078 = *(_DWORD *)(v11 + 0x90);
          dword_10907C = *(_DWORD *)(v11 + 0x94);
          dword_109080 = *(_DWORD *)(v11 + 0x98);
          word_109084 = *(_WORD *)(v11 + 0x9C);
          flt_109068 = v12;
          flt_109086 = *(float *)(v11 + 0x9E);
          dword_10908A = *(_DWORD *)(v11 + 0xA2);
          v13 = *(float *)(v11 + 0xA6);
          byte_109092 = *(_BYTE *)(v11 + 0xAA);
          flt_10908E = v13;
          _wcpp_2_assign_array_(sub_4B780);
          dword_109142 = *(_DWORD *)(v11 + 0x15A);
          dword_109146 = *(_DWORD *)(v11 + 0x15E);
        }
        for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x6B); ++i )
        {
          v15 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * (__int16)i) + 0xA7);
          (*(void (**)(void))(v15 + 8))();
        }
        if ( !*(_DWORD *)(a1 + 0x22F) )
        {
          *(_DWORD *)(a1 + 0xAB) = 0;
          return 0;
        }
        return 0;
      }
      if ( a2 == 4 )
      {
        result = *(_DWORD *)(a1 + 0x35);
        if ( !result )
        {
          return result;
        }
        if ( a3 >= *(_DWORD *)(a1 + 8)
          && a3 <= *(_DWORD *)(a1 + 0x10)
          && a4 >= *(_DWORD *)(a1 + 0xC)
          && a4 <= *(_DWORD *)(a1 + 0x14) )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          if ( dword_96AD0 >= 0 )
          {
            if ( !*(_DWORD *)(a1 + 0xAB) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x1B2);
            }
            if ( sub_492AC(*(_DWORD **)(a1 + 0xAB), *(_BYTE *)(a1 + 0xBB), dword_96AD0) )
            {
              v16 = *(__int16 *)(a1 + 0x59);
              if ( v16 != 0xFFFFFFFF )
              {
                sub_4FB90((int)&unk_10914C, v16);
              }
              *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
              v17 = *(_DWORD *)(a1 + 0xA7);
              *(_DWORD *)(a1 + 0x22F) = 0xFFFFFFFF;
              (*(void (**)(void))(v17 + 0xC))();
            }
          }
          return 0xFFFFFFFF;
        }
        return 0;
      }
    }
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 0x32u )
  {
    if ( *(_DWORD *)(a1 + 0x233) != 0xFFFFFFFF )
    {
      if ( sub_4E69C(a1) )
      {
        *(_DWORD *)(a1 + 0xC1) = 0xFFFFFFFF;
      }
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      return 0;
    }
    return 0;
  }
  if ( (unsigned __int16)a2 >= 0x36u )
  {
    if ( (unsigned __int16)a2 <= 0x36u )
    {
      sub_4E644(a1, 2, a3, a4);
      return 0;
    }
    if ( (unsigned __int16)a2 < 0x39u )
    {
      if ( a2 == 0x37 )
      {
        sub_4E644(a1, 4, a3, a4);
        return 0;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 <= 0x39u )
    {
      sub_4E644(a1, 5, a3, a4);
      return 0;
    }
    if ( (unsigned __int16)a2 < 0x1C01u )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 > 0x1C01u )
    {
      if ( a2 == 0x1C02 )
      {
        v7 = (char)sub_2ECA4(*(_DWORD *)(a1 + 0xC5), a3);
        sub_56B60((int)&V_Type3_stru_10AE70, 5, v7, 4);
        return 0xFFFFFFFF;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    v5 = sub_2ECA4(*(_DWORD *)(a1 + 0xC5), a3);
    if ( v5 != *(_BYTE *)(a1 + 0xBB) )
    {
      v6 = *(_DWORD *)(a1 + 0xA7);
      *(_BYTE *)(a1 + 0xBB) = v5;
      (*(void (__fastcall **)(int, _DWORD))(v6 + 0xC))(a1, 0);
    }
    return 0;
  }
  if ( (unsigned __int16)a2 < 0x34u )
  {
    sub_4E644(a1, 0, a3, a4);
    return 0;
  }
  else
  {
    if ( (unsigned __int16)a2 <= 0x34u )
    {
      sub_4E644(a1, 1, a3, a4);
    }
    else
    {
      sub_4E644(a1, 3, a3, a4);
    }
    return 0;
  }
}
// 78B30: using guessed type _DWORD __stdcall _wcpp_2_assign_array_(_DWORD);
// 96AD0: using guessed type int dword_96AD0;
// 108FE8: using guessed type int dword_108FE8;
// 108FEC: using guessed type int dword_108FEC;
// 108FF0: using guessed type int dword_108FF0;
// 108FF4: using guessed type int dword_108FF4;
// 108FF8: using guessed type int dword_108FF8;
// 108FFC: using guessed type int dword_108FFC;
// 109000: using guessed type int dword_109000;
// 109004: using guessed type int dword_109004;
// 109008: using guessed type int dword_109008;
// 10900C: using guessed type int dword_10900C;
// 109010: using guessed type int dword_109010;
// 109014: using guessed type int dword_109014;
// 109018: using guessed type int dword_109018;
// 10903A: using guessed type int dword_10903A;
// 10903E: using guessed type __int16 word_10903E;
// 109040: using guessed type char byte_109040;
// 109041: using guessed type int dword_109041;
// 109045: using guessed type char byte_109045;
// 109046: using guessed type int dword_109046;
// 10904A: using guessed type char byte_10904A;
// 10904B: using guessed type int dword_10904B;
// 10904F: using guessed type char byte_10904F;
// 109050: using guessed type int dword_109050;
// 109054: using guessed type float flt_109054;
// 109058: using guessed type int dword_109058;
// 10905C: using guessed type float flt_10905C;
// 109060: using guessed type float flt_109060;
// 109064: using guessed type int dword_109064;
// 109068: using guessed type float flt_109068;
// 10906C: using guessed type int dword_10906C;
// 109070: using guessed type int dword_109070;
// 109074: using guessed type int dword_109074;
// 109078: using guessed type int dword_109078;
// 10907C: using guessed type int dword_10907C;
// 109080: using guessed type int dword_109080;
// 109084: using guessed type __int16 word_109084;
// 109086: using guessed type float flt_109086;
// 10908A: using guessed type int dword_10908A;
// 10908E: using guessed type float flt_10908E;
// 109092: using guessed type char byte_109092;
// 109142: using guessed type int dword_109142;
// 109146: using guessed type int dword_109146;

//----- (0004E644) --------------------------------------------------------
int __fastcall sub_4E644(int result, char a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // eax

  v4 = result;
  if ( a2 >= 0 && a2 < 6 && a2 != *(_BYTE *)(result + 0xBC) )
  {
    *(_BYTE *)(result + 0xBC) = a2;
    sub_4DD14(result);
    v5 = *(_DWORD *)(v4 + 0xC5);
    *(_BYTE *)(v4 + 0xBB) = 0xFF;
    if ( *(_WORD *)(v5 + 0x8C7) )
    {
      *(_BYTE *)(v4 + 0xBB) = sub_2ECA4(v5, 0);
    }
    return (*(int (__cdecl **)(int))(*(_DWORD *)(v4 + 0xA7) + 0xC))(a4);
  }
  return result;
}

//----- (0004E69C) --------------------------------------------------------
unsigned int __fastcall sub_4E69C(int a1)
{
  unsigned int v2; // ebp
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // eax
  int v6; // eax

  v2 = 0;
  v3 = *(char *)(*(_DWORD *)(a1 + 0xAB) + 0xAA);
  v4 = 0;
  if ( !*(_DWORD *)(a1 + 0xC9) )
  {
    while ( !v4 )
    {
      if ( ++v3 >= 4 )
      {
        v3 = 0;
      }
      if ( (v3 != 2 || ((1 << byte_104BEA) & SHIBYTE(dword_105830)) != 0)
        && (v3 != 3 || ((1 << byte_104BEA) & SHIBYTE(dword_105BB4)) != 0) )
      {
        v5 = *(_DWORD *)(a1 + 0xAB);
        if ( v3 == *(char *)(v5 + 0xAA) )
        {
          v4 = 0xFFFFFFFF;
          v2 = 0;
        }
        else
        {
          sub_493BC(v5, v3);
          if ( v6 )
          {
            v4 = 0xFFFFFFFF;
            v2 = 0xFFFFFFFF;
            *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
          }
        }
      }
    }
  }
  return v2;
}
// 4E739: variable 'v6' is possibly undefined
// 105830: using guessed type int dword_105830;
// 105BB4: using guessed type int dword_105BB4;

//----- (0004E758) --------------------------------------------------------
void __fastcall sub_4E758(_DWORD *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  int v3; // edi
  int v4; // esi
  int v5; // eax
  unsigned __int16 v6; // dx
  unsigned __int16 v7; // ax
  char v8; // bh
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  _DWORD *v12; // ebx
  int v13; // edx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  char *sub_1CEA8; // eax
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // edi
  int v22; // esi
  int v23; // [esp-Ch] [ebp-7Eh]
  int v24; // [esp-Ch] [ebp-7Eh]
  __int16 v25; // [esp-Ch] [ebp-7Eh]
  int v26; // [esp-8h] [ebp-7Ah]
  int v27; // [esp-8h] [ebp-7Ah]
  int v28; // [esp-8h] [ebp-7Ah]
  int v29; // [esp-4h] [ebp-76h]
  char s[52]; // [esp+0h] [ebp-72h] BYREF
  char v31[52]; // [esp+34h] [ebp-3Eh] BYREF
  T_Type5 v32; // [esp+68h] [ebp-Ah] BYREF
  T_Type5 v33; // [esp+7Ch] [ebp+Ah] BYREF
  int v34[5]; // [esp+90h] [ebp+1Eh]
  T_Type5 a2; // [esp+A4h] [ebp+32h] BYREF
  _DWORD *v36; // [esp+B8h] [ebp+46h]
  int v37; // [esp+BCh] [ebp+4Ah]
  int v38; // [esp+C0h] [ebp+4Eh]
  int v39; // [esp+C4h] [ebp+52h]
  int v40; // [esp+C8h] [ebp+56h]
  int v41; // [esp+CCh] [ebp+5Ah]
  unsigned int v42; // [esp+D0h] [ebp+5Eh]
  int i; // [esp+D4h] [ebp+62h]
  int v44; // [esp+D8h] [ebp+66h]
  int v45; // [esp+DCh] [ebp+6Ah]
  int v46; // [esp+E0h] [ebp+6Eh]
  int v47; // [esp+E4h] [ebp+72h]
  int v48; // [esp+E8h] [ebp+76h]
  unsigned int v49; // [esp+ECh] [ebp+7Ah]
  unsigned __int8 v50; // [esp+F0h] [ebp+7Eh]

  v36 = a1;
  if ( !*(_DWORD *)((char *)a1 + 0xAB) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x24A);
  }
  v1 = *(char *)(*(_DWORD *)((char *)v36 + 0xAB) + 0xAA);
  v32.a = &V_Type6_stru_D8654;
  v32.rect.x1 = 0x14A;
  v32.rect.y1 = 0x72;
  v32.rect.x2 = 0x1DC;
  v32.rect.y2 = 0x1D8;
  v41 = v1;
  sub_5E9D0(&v32, 0);
  v32.rect.y2 = 0x1D8;
  v32.rect.x2 = 0x149;
  v32.rect.x1 = 7;
  v32.rect.y1 = 0x159;
  v2 = sub_5E9D0(&v32, 0);
  LOWORD(v2) = word_FFED8;
  v38 = 0;
  v49 = v2;
  for ( i = 0; i < 0xE; ++i )
  {
    v3 = 0x12 * (i + (unsigned __int8)byte_969A8[i]) + 0xA6;
    v4 = 0x24 * ((unsigned __int8)byte_969A8[i] - i) + 0x193;
    v5 = (unsigned __int8)byte_969B8[i];
    v50 = 1;
    v47 = v5;
    v37 = 0;
    if ( v5 > 0 )
    {
      v46 = v41;
      v39 = 7 * v38;
      while ( (v50 & (unsigned __int8)byte_106FE0[v46]) == 0 )
      {
LABEL_12:
        v50 *= 2;
        v4 += 0x24;
        v3 += 0x12;
        if ( ++v37 >= v47 )
        {
          goto LABEL_4;
        }
      }
      if ( dword_96AD0 >= 0 && dword_96AD0 == v38 )
      {
        if ( *((_BYTE *)v36 + 0xBB) != 0xFF )
        {
          v29 = v3;
          v26 = v4;
          v23 = *((char *)v36 + 0xBB);
          v6 = v49;
LABEL_23:
          v9 = sub_1B084((unsigned int)dword_12FC20, v6);
          sub_5CB3C((P_Type5)&V_Type6_stru_D8654.pane, v9, v23, v26, v29);
          v39 += 7;
          ++v38;
          goto LABEL_12;
        }
        v29 = v3;
        v26 = v4;
        v7 = *((_WORD *)v36 + 0xC);
        v23 = 1;
      }
      else
      {
        if ( !*(_DWORD *)((char *)v36 + 0xAB) )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x28D);
        }
        v8 = *(_BYTE *)(v39 + *(_DWORD *)((char *)v36 + 0xAB) + 0xAB);
        if ( v8 != (char)0xFF )
        {
          if ( v8 >= 0x4C )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x291);
          }
          v29 = v3;
          v26 = v4;
          v23 = *(char *)(v39 + *(_DWORD *)((char *)v36 + 0xAB) + 0xAB);
          v6 = v49;
          goto LABEL_23;
        }
        v29 = v3;
        v26 = v4;
        v7 = *((_WORD *)v36 + 0xC);
        v23 = 0;
      }
      v6 = v7;
      goto LABEL_23;
    }
LABEL_4:
    v41 += 4;
  }
  sub_55274(&V_Type3_stru_10AE70, v36[2], v36[3], v36[4], v36[5]);
  if ( *((_BYTE *)v36 + 0xBB) != 0xFF )
  {
    a2.a = &V_Type6_stru_D8654;
    a2.rect.y2 = 105;
    a2.rect.x1 = 315;
    a2.rect.y1 = 7;
    a2.rect.x2 = 476;
    sub_5E9D0(&a2, 0xF2);
    v27 = (a2.rect.x2 - a2.rect.x1) >> 1;
    v24 = *((char *)v36 + 0xBB);
    v10 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v49);
    sub_5CB3C(&a2, v10, v24, v27, 0x3A);
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x302E] = a2;
    sprintf(s, "%s", (const char *)&unk_107020 + 0x6A * *((char *)v36 + 0xBB));
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 3, 3, s, 0x42, 0xF3, 0xFF, 0);
    sub_552CC(&V_Type3_stru_10AE70, &a2);
  }
  if ( *(_DWORD *)((char *)v36 + 0xC1) )
  {
    v32.a = &V_Type6_stru_D8654;
    v32.rect.x2 = 321;
    v32.rect.x1 = 7;
    v32.rect.y1 = 114;
    v32.rect.y2 = 336;
    sub_5E9D0(&v32, 0);
    v11 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFECA[(unsigned __int8)byte_104BEA]);
    if ( !v11 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x2CB);
    }
    sub_5CB3C(&v32, v11, *(char *)(*(_DWORD *)((char *)v36 + 0xAB) + 0xAA), 0, 0);
    *(_DWORD *)((char *)v36 + 0xC1) = 0;
  }
  if ( *(_DWORD *)((char *)v36 + 0xBD) )
  {
    v32.a = &V_Type6_stru_D8654;
    v32.rect.x2 = 304;
    v32.rect.x1 = 7;
    v32.rect.y1 = 7;
    v32.rect.y2 = 102;
    sub_5E9D0(&v32, 0);
    sub_552CC(&V_Type3_stru_10AE70, &v32);
    sub_53E38(&v32, 3, 3, (unsigned __int8)byte_104BEA);
    qmemcpy(v31, &unk_96AD4, 0x32u);
    if ( *(int **)((char *)v36 + 0xAB) != &dword_108FE8 && *(_DWORD *)((char *)v36 + 0x22F) == 0xFFFFFFFF )
    {
      v12 = v36;
      v13 = dword_D3664;
      v14 = sub_4A18C(*(_DWORD *)((char *)v36 + 0xAB));
      if ( *(_DWORD *)((char *)v12 + 0xC9) == 0xFFFFFFFF )
      {
        v14 = sub_4EE00((int)v12);
      }
      v15 = sub_46C20(v14, *(unsigned __int16 *)(v13 + 0x50), *(unsigned __int16 *)(v13 + 0x44));
      if ( v15 != 0xFFFF )
      {
        if ( v15 == 1 )
        {
          v16 = 0x1C;                                  // 28: ""
        }
        else
        {
          v16 = 0x1D;                                  // 29: "s"
        }
        Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v16);
        sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x87);// 135: " (%d Day%s)"
        sprintf(v31, sub_1CEA8);
      }
    }
    sprintf(
      s,
      "%s \"%s\"%s",
      &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
      (const char *)(*(_DWORD *)((char *)v36 + 0xAB) + 0x34),
      v31);
    v25 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v32;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 3, s, 2, v25, 0xFFFFFFFF, 0);
    v44 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE6);
    v34[0] = **(_DWORD **)((char *)v36 + 0xAB);
    v34[1] = *(_DWORD *)(*(_DWORD *)((char *)v36 + 0xAB) + 4);
    v34[2] = *(_DWORD *)(*(_DWORD *)((char *)v36 + 0xAB) + 0x10);
    v34[3] = *(_DWORD *)(*(_DWORD *)((char *)v36 + 0xAB) + 0x20);
    v18 = *(_DWORD *)((char *)v36 + 0xAB);
    v40 = 7;
    v19 = *(_DWORD *)(v18 + 0x18);
    v33 = v32;
    v34[4] = v19;
    v48 = 0x14;
    v42 = 0;
    do
    {
      v33.rect.x2 = v33.rect.x1 + 0x27;
      v20 = v34[v42 / 4];
      v21 = 0x28;
      if ( v20 > 0 )
      {
        v33.rect.x2 += (0xE * v20 - (__CFSHL__((0xE * v20) >> 0x1F, 2) + 4 * ((0xE * v20) >> 0x1F))) >> 2;
      }
      v22 = 0;
      v45 = v40;
      do
      {
        v28 = v21;
        ++v22;
        v21 += 0xE;
        sub_5CB3C(&v33, v44, v45, v28, v48);
      }
      while ( v22 < 0xF );
      v48 += 0xE;
      v42 += 4;
      ++v40;
    }
    while ( v42 != 0x14 );
    *(_DWORD *)((char *)v36 + 0xBD) = 0;
  }
  sub_2D218(v36);
}
// 96AD0: using guessed type int dword_96AD0;
// FFECA: using guessed type __int16 word_FFECA[7];
// FFED8: using guessed type __int16 word_FFED8;
// FFEE6: using guessed type __int16 word_FFEE6;
// 108FE8: using guessed type int dword_108FE8;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0004EE00) --------------------------------------------------------
int __fastcall sub_4EE00(int a1)
{
  int v2; // ebx
  int v3; // ecx
  int v4; // ecx

  v2 = 0x2710;
  if ( *(_DWORD *)(a1 + 0xC9) == 0xFFFFFFFF )
  {
    if ( *(_DWORD *)(a1 + 0xAB) )
    {
      v3 = sub_4A144(*(_DWORD *)(a1 + 0xAB));
      v4 = v3 - sub_4A144(a1 + 0xCD);
      v2 = 0x1E;
      if ( v4 > 0 )
      {
        return v4 + 0x1E;
      }
    }
  }
  return v2;
}

//----- (0004EE50) --------------------------------------------------------
char *sub_4EE50()
{
  char *result; // eax

  _wcpp_2_mod_register_(&unk_96B08);
  result = sub_4EE74((int)&unk_10914C);
  dword_96B10 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96B10: using guessed type int dword_96B10;

//----- (0004EE74) --------------------------------------------------------
char *__fastcall sub_4EE74(int a1)
{
  T_Type1 *v1; // eax
  char *v2; // ecx
  char *result; // eax

  v1 = (T_Type1 *)(a1 + 0x240);
  Q_InitFileInfo_sub_1BB78(v1);
  v2 = &v1[0xFFFFFFFD].fname[0xF8];
  *(_DWORD *)(v2 + 0x207) = 0;
  *(_DWORD *)(v2 + 0x20B) = 0;
  *(_DWORD *)(v2 + 0x20F) = 0;
  *(_DWORD *)(v2 + 0x213) = 0;
  *(_DWORD *)(v2 + 0x217) = 0;
  *(_DWORD *)(v2 + 0x223) = 0;
  *(_DWORD *)(v2 + 0x227) = 0;
  *(_DWORD *)(v2 + 0x22B) = 0xFFFFFFFF;
  *v2 = 0;
  v2[0xFF] = 0;
  v2[0x1FE] = 0;
  *(_DWORD *)(v2 + 0x21B) = 0;
  *(_DWORD *)(v2 + 0x21F) = 0;
  *((_DWORD *)v2 + 0x8E) = 0;
  *((_DWORD *)v2 + 0x8F) = 0;
  *(_WORD *)&v1[1].fname[0x20] = 0;
  *(_WORD *)&v1[9].fname[0xB0] = 0;
  *(_WORD *)&v1[9].fname[0xB2] = 0;
  memset(&v1[8].fname[0xD0], 0, 0x84u);
  memset(v2 + 0xC68, 0, 0x40u);
  memset(v2 + 0x37A, 0, 0x380u);
  *((_WORD *)v2 + 0x37D) = 0;
  v2[0x6FE] = 0x64;
  v2[0x6FF] = 0x7F;
  *((_WORD *)v2 + 0x380) = 0;
  result = v2;
  *((_WORD *)v2 + 0x5D9) = 0;
  return result;
}

//----- (0004EF94) --------------------------------------------------------
int __fastcall sub_4EF94(int a1)
{
  sub_4FE8C(a1);
  Q_CloseFileAndDelete_sub_1BBC8((P_Type1)(a1 + 0x240));
  return a1;
}

//----- (0004EFB0) --------------------------------------------------------
LONG __fastcall Q_StartSoundSystem_sub_4EFB0(int a1, int aDIG, int aMID)
{
  LONG result; // eax

  AIL_startup();
  *(_DWORD *)(a1 + 0x20F) = 0xFFFFFFFF;
  if ( aDIG == TRUE )
  {
    result = AIL_install_DIG_INI();
    *(_DWORD *)(a1 + 0x21F) = result;
    if ( !result )
    {
      return result;
    }
    sub_4F5E8(a1, 8);
    sub_4FF94((_DWORD *)a1);
    *(_DWORD *)(a1 + 0x20B) = TRUE;
  }
  if ( aMID == TRUE )
  {
    result = AIL_install_MDI_INI();
    *(_DWORD *)(a1 + 0x21B) = result;
    if ( !result )
    {
      return result;
    }
    sub_4F184(a1, 8);
    *(_DWORD *)(a1 + 0x207) = TRUE;
  }
  return 0xFFFFFFFF;
}

//----- (0004F088) --------------------------------------------------------
HMDIDRIVER __fastcall sub_4F088(char *path, char *a2, char *a3, char *a4)
{
  char *v7; // edi
  char v8; // al
  char v9; // al
  const char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  char *v15; // edi
  char v16; // al
  char v17; // al
  char *v18; // esi
  char *v19; // edi
  char v20; // al
  char v21; // al
  HMDIDRIVER result; // eax
  IO_PARMS v24; // [esp+0h] [ebp-24h] BYREF

  v7 = path;
  do
  {
    v8 = *a2;
    *v7 = *a2;
    if ( !v8 )
    {
      break;
    }
    v9 = a2[1];
    a2 += 2;
    v7[1] = v9;
    v7 += 2;
  }
  while ( v9 );
  v10 = "\\";
  v11 = &path[strlen(path)];
  do
  {
    v12 = *v10;
    *v11 = *v10;
    if ( !v12 )
    {
      break;
    }
    v13 = v10[1];
    v10 += 2;
    v11[1] = v13;
    v11 += 2;
  }
  while ( v13 );
  v15 = &path[strlen(path)];
  do
  {
    v16 = *a3;
    *v15 = *a3;
    if ( !v16 )
    {
      break;
    }
    v17 = a3[1];
    a3 += 2;
    v15[1] = v17;
    v15 += 2;
  }
  while ( v17 );
  v18 = a4;
  v19 = path + 0x1FE;
  do
  {
    v20 = *v18;
    *v19 = *v18;
    if ( !v20 )
    {
      break;
    }
    v21 = v18[1];
    v18 += 2;
    v19[1] = v21;
    v19 += 2;
  }
  while ( v21 );
  AIL_set_GTL_filename_prefix(path + 0x1FE);
  memset(&v24, 0, sizeof(v24));
  v24.IO = 0x240;
  v24.IRQ = 9;
  result = AIL_install_MDI_driver_file(path, &v24);
  *(_DWORD *)(path + 0x21B) = result;
  if ( result )
  {
    sub_4F184((int)path, 8);
    result = (HMDIDRIVER)0xFFFFFFFF;
    *(_DWORD *)(path + 0x207) = 0xFFFFFFFF;
  }
  return result;
}

//----- (0004F184) --------------------------------------------------------
int __fastcall sub_4F184(int a1, int a2)
{
  __int16 i; // si
  HSEQUENCE sequence_handle; // edx
  int v6; // eax

  if ( *(_WORD *)(a1 + 0xCA8) )
  {
    return 0;
  }
  if ( a2 > 8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0xDA);
  }
  for ( i = 0; i < a2; ++i )
  {
    sequence_handle = AIL_allocate_sequence_handle(*(HMDIDRIVER *)(a1 + 0x21B));
    v6 = a1 + 8 * i;
    *(_DWORD *)(v6 + 0xC68) = sequence_handle;
    if ( !sequence_handle )
    {
      break;
    }
    *(_DWORD *)(v6 + 0xC6C) = 0;
  }
  *(_WORD *)(a1 + 0xCA8) = i;
  return *(__int16 *)(a1 + 0xCA8);
}

//----- (0004F32C) --------------------------------------------------------
void __fastcall sub_4F32C(int a1, __int16 a2, int a3)
{
  int v4; // [esp+0h] [ebp-14h]

  if ( *(_DWORD *)(a1 + 0x217) != 0xFFFFFFFF && *(_DWORD *)(a1 + 0x207) )
  {
    if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xCA8) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x12A);
    }
    if ( !*(_DWORD *)(a1 + 8 * a2 + 0xC6C) )
    {
      sprintf("Thank you for playing Ascendancy.", "Attempt play Sequence Track %d with NULL data.\n\n", a2);
      Q_debugbreak_exit_sub_2624C();
    }
    v4 = a1 + 8 * a2;
    if ( AIL_sequence_status(*(HSEQUENCE *)(v4 + 0xC68)) == 4 )
    {
      if ( a3 != 0xFFFFFFFF )
      {
        return;
      }
      AIL_stop_sequence(*(HSEQUENCE *)(v4 + 0xC68));
    }
    AIL_start_sequence(*(HSEQUENCE *)(a1 + 8 * a2 + 0xC68));
  }
}
// 4F3A4: conditional instruction was optimized away because ecx.4!=0

//----- (0004F45C) --------------------------------------------------------
void __fastcall sub_4F45C(int a1, __int16 a2)
{
  int v2; // esi

  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xCA8) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x152);
  }
  v2 = 8 * a2 + a1;
  if ( *(_DWORD *)(v2 + 0xC6C) )
  {
    AIL_end_sequence(*(HSEQUENCE *)(v2 + 0xC68));
  }
}

//----- (0004F4D4) --------------------------------------------------------
void __fastcall sub_4F4D4(int a1, __int16 a2)
{
  int v2; // esi

  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xCA8) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x166);
  }
  v2 = a1 + 8 * a2;
  if ( *(_DWORD *)(v2 + 0xC6C) )
  {
    AIL_end_sequence(*(HSEQUENCE *)(v2 + 0xC68));
    if ( *(_DWORD *)(v2 + 0xC6C) )
    {
      off_987B0(*(_DWORD *)(v2 + 0xC6C));
    }
  }
}
// 987B0: using guessed type int (__fastcall *off_987B0)(_DWORD);

//----- (0004F534) --------------------------------------------------------
HDIGDRIVER __fastcall sub_4F534(_DWORD *a1, char *a2, char *a3)
{
  BYTE *v5; // edx
  char *v6; // edi
  char v7; // al
  char v8; // al
  const char *v9; // esi
  char *v10; // edi
  char v11; // al
  char v12; // al
  char *v14; // edi
  char v15; // al
  char v16; // al
  HDIGDRIVER result; // eax
  const char *v18; // [esp-4h] [ebp-14h]

  v5 = (char *)a1 + 0xFF;
  v6 = (char *)a1 + 0xFF;
  v18 = (char *)a1 + 0xFF;
  do
  {
    v7 = *a2;
    *v6 = *a2;
    if ( !v7 )
    {
      break;
    }
    v8 = a2[1];
    a2 += 2;
    v6[1] = v8;
    v6 += 2;
  }
  while ( v8 );
  v9 = "\\";
  v10 = (char *)&v18[strlen(v18)];
  do
  {
    v11 = *v9;
    *v10 = *v9;
    if ( !v11 )
    {
      break;
    }
    v12 = v9[1];
    v9 += 2;
    v10[1] = v12;
    v10 += 2;
  }
  while ( v12 );
  v14 = (char *)&v18[strlen(v18)];
  do
  {
    v15 = *a3;
    *v14 = *a3;
    if ( !v15 )
    {
      break;
    }
    v16 = a3[1];
    a3 += 2;
    v14[1] = v16;
    v14 += 2;
  }
  while ( v16 );
  result = AIL_install_DIG_driver_file(v5, 0);
  *(_DWORD *)((char *)a1 + 0x21F) = result;
  if ( result )
  {
    sub_4F5E8((int)a1, 8);
    sub_4FF94(a1);
    result = (HDIGDRIVER)0xFFFFFFFF;
    *(_DWORD *)((char *)a1 + 0x20B) = 0xFFFFFFFF;
  }
  return result;
}

//----- (0004F5E8) --------------------------------------------------------
int __fastcall sub_4F5E8(int a1, int a2)
{
  __int16 i; // si
  HSAMPLE sample_handle; // eax

  if ( *(_WORD *)(a1 + 0x378) )
  {
    return 0;
  }
  if ( a2 > 8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x199);
  }
  for ( i = 0; i < a2; ++i )
  {
    sample_handle = AIL_allocate_sample_handle(*(HDIGDRIVER *)(a1 + 0x21F));
    *(_DWORD *)(a1 + 4 * i + 0x358) = sample_handle;
    if ( !sample_handle )
    {
      break;
    }
  }
  *(_WORD *)(a1 + 0x378) = i;
  return *(__int16 *)(a1 + 0x378);
}

//----- (0004F65C) --------------------------------------------------------
int __fastcall sub_4F65C(int a1, const char *a2)
{
  SAMPLE *v5; // esi
  LONG v6; // ecx
  char *v7; // eax
  int v8; // edx
  int v9; // ebx
  __int16 v10; // si
  int v11; // ecx
  int v12; // eax
  DIG_DRIVER *v13; // [esp-Ch] [ebp-80h]
  char v14[80]; // [esp+0h] [ebp-74h] BYREF
  int v15; // [esp+50h] [ebp-24h] BYREF
  int v16; // [esp+54h] [ebp-20h]
  int v17; // [esp+58h] [ebp-1Ch]
  FILE *fp; // [esp+5Ch] [ebp-18h]

  if ( *(_DWORD *)(a1 + 0x20B) != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1B4);
  }
  if ( *(__int16 *)(a1 + 0x378) <= 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1B5);
  }
  if ( !*(_DWORD *)(a1 + 0x20B) || *(__int16 *)(a1 + 0x378) < 8 )
  {
    return 0;
  }
  if ( *(_DWORD *)(a1 + 0x223) == 0xFFFFFFFF )
  {
    return 0xFFFFFFFF;
  }
  v5 = *(SAMPLE **)(a1 + 0x358);
  AIL_init_sample(v5);
  AIL_set_sample_type(v5, 0, 0);
  AIL_set_sample_playback_rate(v5, 0x5622);
  v13 = *(DIG_DRIVER **)(a1 + 0x21F);
  v16 = 0xC800;
  v6 = AIL_minimum_sample_buffer_size(v13, 0x5622, 0);
  if ( v6 >= 0xC800 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1C9);
  }
  if ( v6 > v16 )
  {
    v16 = v6;
  }
  v7 = (char *)sub_2628C(2 * v16, 4, "DigitalMusicBuf");
  v8 = v16;
  *(_DWORD *)(a1 + 0x238) = v7;
  v9 = *(_DWORD *)(a1 + 0x238);
  *(_DWORD *)(a1 + 0x23C) = &v7[v8];
  if ( !v9 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1D0);
  }
  if ( !*(_DWORD *)(a1 + 0x238) )
  {
    return 0;
  }
  if ( a2 )
  {
    fp = sub_1BB10(a2, 0);
    if ( !fp )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1DB);
    }
    if ( !fp )
    {
      return 0;
    }
    fscanf(fp, "%d", &v15);
    if ( v15 > 0x20 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1E2);
    }
    v10 = 0;
    v17 = a1 + 0x37A;
    while ( v10 < v15 )
    {
      fscanf(fp, "%s", v14);
      if ( strlen(v14) >= 0x18 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1E8);
      }
      v11 = 0x1C * v10;
      strncpy((char *)(v11 + v17), v14, 0x18u);
      *(_BYTE *)(v11 + a1 + 0x391) = 0;
      ++v10;
      *(_DWORD *)(v11 + a1 + 0x392) = 0;
    }
    *(_WORD *)(a1 + 0x6FA) = v15;
    fclose(fp);
  }
  *(_DWORD *)(a1 + 0x223) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x22B) = 0;
  *(_DWORD *)(a1 + 0x233) = 0;
  v12 = v16;
  *(_BYTE *)(a1 + 0x237) = 0;
  *(_DWORD *)(a1 + 0x22F) = v12;
  return 0xFFFFFFFF;
}

//----- (0004F8CC) --------------------------------------------------------
unsigned int __fastcall sub_4F8CC(int a1, __int16 a2, int a3)
{
  unsigned int result; // eax
  SAMPLE *v5; // ebp
  BOOL v6; // ebp

  if ( *(_DWORD *)(a1 + 0x22B) == 0xFFFFFFFF || !*(_DWORD *)(a1 + 0x20B) )
  {
    return 0;
  }
  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0x6FA) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x200);
  }
  if ( *(__int16 *)(a1 + 0x6FC) != 0xFFFFFFFF )
  {
    *(_DWORD *)(a1 + 0x1C * *(__int16 *)(a1 + 0x6FC) + 0x392) = sub_1BEA0((int *)(a1 + 0x240));
  }
  sub_4FA1C(a1);
  v5 = *(SAMPLE **)(a1 + 0x358);
  AIL_init_sample(v5);
  AIL_set_sample_type(v5, 0, 0);
  AIL_set_sample_playback_rate(v5, 0x5622);
  sub_4FF4C(a1, *(_BYTE *)(a1 + 0x6FE));
  v6 = Q_CfilePreload_sub_1BBFC((P_Type1)(a1 + 0x240), (const char *)(0x1C * a2 + a1 + 0x37A), 0x200, 0);
  if ( v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x214);
  }
  if ( v6 )
  {
    return 0;
  }
  if ( a3 == 0xFFFFFFFF )
  {
    sub_1BF0C((int *)(a1 + 0x240), *(_DWORD *)(a1 + 0x1C * a2 + 0x392));
  }
  *(_DWORD *)(a1 + 0x227) = 0xFFFFFFFF;
  result = 0xFFFFFFFF;
  *(_WORD *)(a1 + 0x6FC) = a2;
  return result;
}

//----- (0004FA1C) --------------------------------------------------------
int __fastcall sub_4FA1C(int result)
{
  int v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // ebx
  SAMPLE *v5; // [esp-10h] [ebp-14h]

  v1 = result;
  if ( *(_DWORD *)(result + 0x227) == 0xFFFFFFFF )
  {
    v5 = *(SAMPLE **)(result + 0x358);
    *(_DWORD *)(result + 0x227) = 0;
    AIL_stop_sample(v5);
    v2 = sub_1BEA0((int *)(v1 + 0x240));
    v3 = *(__int16 *)(v1 + 0x6FC);
    v4 = v2;
    result = 7 * v3;
    *(_DWORD *)(v1 + 0x1C * v3 + 0x392) = v4;
  }
  return result;
}

//----- (0004FAB4) --------------------------------------------------------
void __fastcall sub_4FAB4(int a1)
{
  SAMPLE *v2; // edi
  LONG v3; // eax
  signed int v4; // ebx
  int v5; // eax
  ULONG v6; // edx

  if ( *(_DWORD *)(a1 + 0x22B) != 0xFFFFFFFF && *(_DWORD *)(a1 + 0x20B) )
  {
    v2 = *(SAMPLE **)(a1 + 0x358);
    v3 = AIL_sample_buffer_ready(v2);
    if ( v3 != 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0x233) = 0;
      *(_BYTE *)(a1 + 0x237) = v3;
    }
    v4 = *(_DWORD *)(a1 + 0x22F) - *(_DWORD *)(a1 + 0x233);
    if ( v4 > 0x1400 )
    {
      v4 = 0x1400;
    }
    if ( v4 )
    {
      v5 = sub_1BF94(
             (P_Type1)(a1 + 0x240),
             (void *)(*(_DWORD *)(a1 + 0x233) + *(_DWORD *)(a1 + 4 * *(char *)(a1 + 0x237) + 0x238)),
             v4);
      v6 = v5 + *(_DWORD *)(a1 + 0x233);
      *(_DWORD *)(a1 + 0x233) = v6;
      if ( v5 )
      {
        AIL_load_sample_buffer(v2, *(char *)(a1 + 0x237), *(void **)(a1 + 4 * *(char *)(a1 + 0x237) + 0x238), v6);
      }
      else
      {
        sub_1BECC((int *)(a1 + 0x240), 0, 0);
        sub_4FA1C(a1);
      }
    }
  }
}

//----- (0004FB90) --------------------------------------------------------
int __fastcall sub_4FB90(int result, __int16 a2)
{
  int v2; // ebp
  int i; // edi
  SAMPLE *v4; // esi
  int v5; // edx
  int v6; // [esp+0h] [ebp-1Ch]
  int v7; // [esp+4h] [ebp-18h]

  v7 = result;
  if ( *(_DWORD *)(result + 0x213) != 0xFFFFFFFF )
  {
    if ( *(_DWORD *)(result + 0x20B) )
    {
      result = sub_50140(result, a2);
      v6 = result;
      if ( result )
      {
        v2 = 1;
        for ( i = v7 + 4; ; i += 4 )
        {
          result = *(__int16 *)(v7 + 0x378);
          if ( v2 >= result )
          {
            break;
          }
          v4 = *(SAMPLE **)(i + 0x358);
          if ( AIL_sample_status(v4) != 4 )
          {
            AIL_init_sample(v4);
            AIL_set_sample_type(v4, *(__int16 *)(v6 + 0x10), 0);
            AIL_set_sample_address(v4, *(void **)(v6 + 8), *(_DWORD *)(v6 + 0xC));
            AIL_set_sample_playback_rate(v4, *(__int16 *)(v6 + 0x12));
            AIL_set_sample_volume(v4, *(char *)(v7 + 0x6FF));
            AIL_set_sample_loop_count(v4, 1);
            AIL_start_sample(v4);
            v5 = 0;
            *(_DWORD *)v6 = v4;
            result = v7 + 0xBB4;
            do
            {
              if ( result != v6 && v4 == *(SAMPLE **)result )
              {
                *(_DWORD *)result = 0;
              }
              ++v5;
              result += 0x16;
            }
            while ( v5 < 6 );
            return result;
          }
          ++v2;
        }
      }
    }
  }
  return result;
}

//----- (0004FE8C) --------------------------------------------------------
void __fastcall sub_4FE8C(int result)
{
  __int16 i; // bx
  int v3; // edi
  int j; // ebp
  SAMPLE *v5; // [esp-4h] [ebp-1Ch]

  if ( *(_DWORD *)(result + 0x20F) == 0xFFFFFFFF )
  {
    for ( i = 0; i < *(__int16 *)(result + 0xCA8); ++i )
    {
      sub_4F4D4(result, i);
    }
    v3 = result;
    for ( j = 0; j < *(__int16 *)(result + 0x378); ++j )
    {
      v5 = *(SAMPLE **)(v3 + 0x358);
      v3 += 4;
      AIL_stop_sample(v5);
    }
    sub_262CC(*(void **)(result + 0xBB8));
    AIL_shutdown();
    *(_DWORD *)(result + 0x20F) = 0;
  }
}

//----- (0004FF08) --------------------------------------------------------
void __fastcall __spoils<> sub_4FF08(int a1)
{
  sub_4FF1C(a1);
  sub_4FF28(a1);
}

//----- (0004FF1C) --------------------------------------------------------
void __fastcall __spoils<> sub_4FF1C(int result)
{
  *(_DWORD *)(result + 0x217) = 0xFFFFFFFF;
}

//----- (0004FF28) --------------------------------------------------------
void __fastcall __spoils<> sub_4FF28(int result)
{
  *(_DWORD *)(result + 0x213) = 0xFFFFFFFF;
}

//----- (0004FF4C) --------------------------------------------------------
void __fastcall sub_4FF4C(int a1, char a2)
{
  if ( a2 >= 0 )
  {
    *(_BYTE *)(a1 + 0x6FE) = a2;
  }
  AIL_set_sample_volume(*(HSAMPLE *)(a1 + 0x358), *(char *)(a1 + 0x6FE));
}

//----- (0004FF94) --------------------------------------------------------
int __fastcall sub_4FF94(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int v2; // esi
  int v3; // edi
  FILE *v4; // ebp
  char *v5; // eax
  int v6; // edx
  char *v7; // ecx
  int v8; // ebx
  int v9; // edi
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // esi
  int v14; // edx
  int v15; // ebx
  int v17; // [esp-4h] [ebp-2Ch]
  int v18; // [esp+0h] [ebp-28h] BYREF
  int v19; // [esp+4h] [ebp-24h] BYREF
  _DWORD *v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]

  v20 = a1;
  v1 = a1;
  v2 = 0;
  v3 = 0;
  v4 = sub_1BB10("soundfx.txt", 0);
  v21 = 0;
  do
  {
    fscanf(v4, "%d %d", &v18, &v19);
    v1[0x314] = v2;
    v1[0x317] = v2 + v18 - 1;
    v1[0x311] = v19;
    v21 += v19 * v18;
    if ( v3 > 0 && v1[0x311] < v1[0x310] )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x347);
    }
    ++v1;
    ++v3;
    v2 += v18;
  }
  while ( v3 < 3 );
  if ( v2 != 6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x34D);
  }
  v5 = (char *)sub_2628C(v21, 1, "SFX CACHE");
  v6 = (int)v20;
  v7 = v5;
  v8 = 0;
  v9 = (int)v20;
  v10 = v20 + 0x2ED;
  do
  {
    *v10 = 0;
    *((_WORD *)v10 + 8) = 0;
    *((_WORD *)v10 + 9) = 0x5622;
    *((_WORD *)v10 + 0xA) = 0xFFFF;
    if ( v8 > *(_DWORD *)(v6 + 0xC5C) )
    {
      v6 += 4;
    }
    *(_DWORD *)(v9 + 0xBB8) = v7;
    v9 += 0x16;
    ++v8;
    v10 = (_DWORD *)((char *)v10 + 0x16);
    v7 += *(_DWORD *)(v6 + 0xC44);
  }
  while ( v8 < 6 );
  fscanf(v4, "%d", &v18);
  v11 = (int)v20;
  *((_WORD *)v20 + 0x380) = v18;
  if ( *(unsigned __int16 *)(v11 + 0x700) >= 0x64u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x369);
  }
  v12 = (int)v20;
  v13 = (int)v20;
  v14 = 0;
  v15 = (int)v20 + 0x702;
  while ( v14 < *(unsigned __int16 *)(v13 + 0x700) )
  {
    v17 = v15;
    v12 += 2;
    ++v14;
    v15 += 0xA;
    fscanf(v4, "%s", v17);
    *(_WORD *)(v12 + 0xAE8) = 0xFFFF;
  }
  return fclose(v4);
}

//----- (00050140) --------------------------------------------------------
int __fastcall sub_50140(int a1, __int16 a2)
{
  int v4; // edx
  int v5; // ecx
  int k; // eax
  int m; // ecx
  int v8; // edi
  int v9; // ecx
  int v10; // eax
  unsigned int v11; // edx
  int v12; // edx
  int v13; // ecx
  int v14; // ebp
  int v15; // eax
  int v16; // ebp
  int v17; // edi
  int v18; // eax
  int v19; // ebp
  int v20; // ecx
  int i; // eax
  int j; // ecx
  unsigned __int16 v23; // di
  int v24; // edx
  T_Type1 v25; // [esp+0h] [ebp-178h] BYREF
  char s[52]; // [esp+118h] [ebp-60h] BYREF
  int v27; // [esp+14Ch] [ebp-2Ch]
  int v28; // [esp+150h] [ebp-28h]
  int v29; // [esp+154h] [ebp-24h]
  int v30; // [esp+158h] [ebp-20h]
  int v31; // [esp+15Ch] [ebp-1Ch]
  int v32; // [esp+160h] [ebp-18h]

  LOWORD(v32) = a2;
  if ( *(_DWORD *)(a1 + 0x213) == 0xFFFFFFFF || !*(_DWORD *)(a1 + 0x20B) )
  {
    return 0;
  }
  if ( (v32 & 0x8000u) != 0 || (__int16)v32 >= (int)*(unsigned __int16 *)(a1 + 0x700) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x37B);
  }
  v28 = 0;
  if ( (v32 & 0x8000u) != 0 || (__int16)v32 >= (int)*(unsigned __int16 *)(a1 + 0x700) )
  {
    return v28;
  }
  v4 = *(__int16 *)(a1 + 2 * (__int16)v32 + 0xAEA);
  if ( v4 == 0xFFFFFFFF )
  {
    sprintf(s, "data\\%s.voc", (const char *)(a1 + 0x702 + 0xA * (__int16)v32));
    Q_InitFileInfo_sub_1BB78(&v25);
    Q_CfilePreload_sub_1BBFC(&v25, s, 0x200, 0);
    v11 = 0;
    v30 = sub_1BE28(&v25);
    v9 = 0;
    v10 = a1;
    while ( v30 >= *(_DWORD *)(v10 + 0xC44) )
    {
      ++v9;
      v10 += 4;
      if ( v9 >= 3 )
      {
        goto LABEL_23;
      }
    }
    v11 = 0xFFFFFFFF;
LABEL_23:
    if ( v11 != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x3AD);
    }
    v12 = v9;
    v13 = *(_DWORD *)(a1 + 4 * v9 + 0xC50);
    v27 = 0xFFFFFFFF;
    v14 = a1 + 4 * v12;
    v15 = a1 + 0x16 * v13;
    if ( v13 <= *(_DWORD *)(v14 + 0xC5C) )
    {
      while ( *(__int16 *)(v15 + 0xBC8) != 0xFFFFFFFF )
      {
        ++v13;
        v15 += 0x16;
        if ( v13 > *(_DWORD *)(v14 + 0xC5C) )
        {
          goto LABEL_30;
        }
      }
      v27 = v13;
    }
LABEL_30:
    if ( v27 == 0xFFFFFFFF )
    {
      v31 = a1;
      v16 = 0;
      v29 = 4 * v12;
      while ( v16 < *(unsigned __int16 *)(a1 + 0xBB2) )
      {
        v17 = *(__int16 *)(a1 + 2 * *(unsigned __int16 *)(v31 + 0xC38) + 0xAEA);
        if ( v17 >= *(_DWORD *)(a1 + v29 + 0xC50) && v17 <= *(_DWORD *)(a1 + v29 + 0xC5C) )
        {
          v18 = a1 + 0x16 * v17;
          if ( !*(_DWORD *)(v18 + 0xBB4) || AIL_sample_status(*(HSAMPLE *)(v18 + 0xBB4)) != 4 )
          {
            v27 = v17;
            break;
          }
        }
        ++v16;
        v31 += 2;
      }
    }
    if ( v27 != 0xFFFFFFFF )
    {
      v19 = *(__int16 *)(0x16 * v27 + a1 + 0xBB4 + 0x14);
      v28 = 0x16 * v27 + a1 + 0xBB4;
      if ( v19 != 0xFFFFFFFF )
      {
        v20 = a1;
        for ( i = 0; i < *(unsigned __int16 *)(a1 + 0xBB2) && *(unsigned __int16 *)(v20 + 0xC38) != v19; ++i )
        {
          v20 += 2;
        }
        for ( j = a1 + 2 * i; ; *(_WORD *)(j + 0xC36) = *(_WORD *)(j + 0xC38) )
        {
          v23 = *(_WORD *)(a1 + 0xBB2);
          if ( i >= v23 )
          {
            break;
          }
          j += 2;
          ++i;
        }
        *(_WORD *)(a1 + 0xBB2) = v23 - 1;
        *(_WORD *)(a1 + 2 * v19 + 0xAEA) = 0xFFFF;
      }
      sub_1BF1C(&v25, *(void **)(v28 + 4));
      v24 = v28;
      *(_DWORD *)(v28 + 8) = *(_DWORD *)(v28 + 4) + 0x2A;
      *(_DWORD *)(v24 + 0xC) = v30 - 0x2B;
      *(_WORD *)(v24 + 0x14) = v32;
      *(_WORD *)(a1 + 2 * (__int16)v32 + 0xAEA) = v27;
      LOWORD(v24) = *(_WORD *)(a1 + 0xBB2);
      *(_WORD *)(a1 + 0xBB2) = v24 + 1;
      *(_WORD *)(a1 + 2 * (unsigned __int16)v24 + 0xC38) = v32;
    }
    Q_CloseFileAndDelete_sub_1BBC8(&v25);
    return v28;
  }
  v5 = a1;
  v28 = 0x16 * v4 + a1 + 0xBB4;
  for ( k = 0; k < *(unsigned __int16 *)(a1 + 0xBB2) && *(unsigned __int16 *)(v5 + 0xC38) != (__int16)v32; ++k )
  {
    v5 += 2;
  }
  for ( m = a1 + 2 * k; ; *(_WORD *)(m + 0xC36) = *(_WORD *)(m + 0xC38) )
  {
    v8 = *(unsigned __int16 *)(a1 + 0xBB2);
    if ( k >= (unsigned __int16)v8 )
    {
      break;
    }
    m += 2;
    ++k;
  }
  *(_WORD *)(a1 + 2 * v8 + 0xC36) = v32;
  return v28;
}

//----- (00050530) --------------------------------------------------------
unsigned __int16 __fastcall sub_50530(T_Type5 *a1, int a2, int a3, int a4)
{
  __int16 *v6; // esi
  int v7; // eax
  int v8; // ecx
  int v9; // edi
  const char *v10; // ecx
  __int16 v11; // ax
  T_Rect *p_rect; // esi
  T_Rect *v13; // esi
  int v14; // edx
  char *sub_1CEA8; // eax
  T_Rect *v16; // esi
  int v17; // ebx
  P_Type5 v18; // esi
  __int16 v19; // cx
  char *v20; // eax
  unsigned int v21; // edx
  char *v22; // edi
  char *v23; // esi
  char v24; // al
  char v25; // al
  int v26; // eax
  char *v27; // eax
  char *v28; // eax
  char *v29; // edi
  char *v30; // esi
  char v31; // al
  char v32; // al
  char *v33; // esi
  char *v34; // edi
  char v35; // al
  char v36; // al
  int v37; // ebx
  T_Rect *v38; // esi
  int v39; // esi
  unsigned __int16 v40; // di
  int *v41; // eax
  int v42; // eax
  int v43; // eax
  int *v44; // eax
  int v45; // eax
  int *v46; // eax
  int v47; // eax
  int v48; // edi
  int *v49; // eax
  int i; // esi
  unsigned __int16 result; // ax
  int v52; // eax
  int v53; // [esp-10h] [ebp-F4h]
  int v54; // [esp-10h] [ebp-F4h]
  int v55; // [esp-10h] [ebp-F4h]
  int v56; // [esp-10h] [ebp-F4h]
  int v57; // [esp-8h] [ebp-ECh]
  __int16 x_4; // [esp+4h] [ebp-E0h]
  __int16 x_4a; // [esp+4h] [ebp-E0h]
  __int16 x_4b; // [esp+4h] [ebp-E0h]
  int x_4c; // [esp+4h] [ebp-E0h]
  __int64 v62; // [esp+8h] [ebp-DCh]
  unsigned __int64 v63; // [esp+8h] [ebp-DCh]
  __int64 v64; // [esp+8h] [ebp-DCh]
  int v65; // [esp+Ch] [ebp-D8h]
  char s[100]; // [esp+10h] [ebp-D4h] BYREF
  char v67[60]; // [esp+74h] [ebp-70h] BYREF
  int v68; // [esp+B0h] [ebp-34h]
  int v69; // [esp+B4h] [ebp-30h]
  int v70; // [esp+B8h] [ebp-2Ch]
  int v71; // [esp+BCh] [ebp-28h]
  P_Type5 v72; // [esp+C0h] [ebp-24h]
  int v73; // [esp+C4h] [ebp-20h]
  char *string; // [esp+C8h] [ebp-1Ch]
  int v75; // [esp+CCh] [ebp-18h]
  int *v76; // [esp+D0h] [ebp-14h]
  int v77; // [esp+D4h] [ebp-10h]

  v72 = a1;
  v6 = &word_A3D21[0x30 * *(__int16 *)(a2 + 0xC)];
  v7 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B2A);
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x41);
  }
  sub_5CB3C(v72, v7, *(_DWORD *)v6, 0x4B, 0x4B);
  v8 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B2C);
  if ( !v8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x45);
  }
  sub_5CB3C(v72, v8, *(unsigned __int16 *)(a2 + 0x14) + 5 * *(unsigned __int16 *)(a2 + 0x16), 0xC8, 0x4B);
  v73 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  v70 = v73;
  if ( a4 )
  {
    if ( dword_D8648 >= 0x96 )
    {
      v73 = 0xF3;
    }
    else
    {
      v70 = 0xF3;
    }
  }
  v9 = *((unsigned __int8 *)v6 + 0x14);
  if ( v9 == 1 << byte_104BEA
    || v6 == *(__int16 **)((char *)&dword_A2F79 + 0x1EE * (unsigned __int8)byte_104BEA)
    && ((1 << byte_104BEA) & v9) != 0 )
  {
    sub_53E38(v72, 4, 0xA, (unsigned __int8)byte_104BEA);
  }
  v10 = (const char *)&word_A3D21[0x30 * *(__int16 *)(a2 + 0xC) + 0xE];
  v11 = v70;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v72->a;
  p_rect = &v72->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v72->rect.x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = p_rect->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = p_rect->y1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x78, 0x12, v10, 0, v11, 0xFF, 0);
  string = (char *)(a2 + 0x24);
  x_4 = v73;
  v71 = (__int16)v73;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v72->a;
  v13 = &v72->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v72->rect.x1;
  v13 = (T_Rect *)((char *)v13 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v13->x1;
  v13 = (T_Rect *)((char *)v13 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v13->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v13->y1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x113, 0xF, (const char *)(a2 + 0x24), 0, x_4, 0xFF, 0);
  v14 = sub_2B4F4(&V_Type3_stru_10AE70.z1[0x3046], string) + 0x127;
  HIDWORD(v62) = dword_10469C[*(unsigned __int16 *)(a2 + 0x16)];
  LODWORD(v62) = dword_104688[*(unsigned __int16 *)(a2 + 0x14)];
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x88);// 136: "(%s %s Planet)"
  sprintf(s, sub_1CEA8, v62);
  x_4a = v71;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v72->a;
  v16 = &v72->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v72->rect.x1;
  v16 = (T_Rect *)((char *)v16 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = v16->x1;
  v16 = (T_Rect *)((char *)v16 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = v16->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v16->y1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], v14, 0x10, s, 0, x_4a, 0xFF, 0);
  v17 = *(_DWORD *)(a2 + 0x5A);
  v68 = 0x1E;
  if ( v17 == 0xFFFFFFFF )
  {
    v18 = v72;
    v19 = v71;
    v20 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x89);    // 137: "Self-Managed"
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v18->a;
    v18 = (P_Type5)((char *)v18 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v18->a;
    v18 = (P_Type5)((char *)v18 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = v18->a;
    v18 = (P_Type5)((char *)v18 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = v18->a;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v18->rect.x1;
    v68 = 0x27;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x113, 0x1E, v20, 0, v19, 0xFF, 0);
  }
  if ( *(_BYTE *)(a2 + 0x54) == 0xFF )
  {
    v29 = s;
    v30 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8D);    // 141: "No Project"
    do
    {
      v31 = *v30;
      *v29 = *v30;
      if ( !v31 )
      {
        break;
      }
      v32 = v30[1];
      v30 += 2;
      v29[1] = v32;
      v29 += 2;
    }
    while ( v32 );
    if ( *(_WORD *)(a2 + 0x42) == *(_WORD *)(a2 + 0x4C) )
    {
      v33 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8E);  // 142: "   (No Free Population)"
      v34 = &s[strlen(s)];
      do
      {
        v35 = *v33;
        *v34 = *v33;
        if ( !v35 )
        {
          break;
        }
        v36 = v33[1];
        v33 += 2;
        v34[1] = v36;
        v34 += 2;
      }
      while ( v36 );
    }
    v73 = 0xF3;
  }
  else
  {
    qmemcpy(v67, &unk_96B30, sizeof(v67));
    if ( (word_103FA2[0x14 * *(unsigned __int8 *)(a2 + 0x54)] & 2) == 0 )
    {
      v21 = (unsigned __int16)sub_358BC(a2);
      if ( (unsigned __int16)v21 == 0xFFFF )
      {
        v22 = v67;
        v23 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8A);// 138: " - No Progress"
        do
        {
          v24 = *v23;
          *v22 = *v23;
          if ( !v24 )
          {
            break;
          }
          v25 = v23[1];
          v23 += 2;
          v22[1] = v25;
          v22 += 2;
        }
        while ( v25 );
      }
      else
      {
        if ( v21 == 1 )
        {
          v26 = 0x1C;                                  // 28: ""
        }
        else
        {
          v26 = 0x1D;                                  // 29: "s"
        }
        v63 = __PAIR64__((unsigned int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v26), v21);
        v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8B);// 139: " - %d day%s until completion"
        sprintf(v67, v27, v63);
      }
    }
    HIDWORD(v64) = v67;
    LODWORD(v64) = &dword_103F9A[0xA * *(unsigned __int8 *)(a2 + 0x54) + 3];
    v28 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8C);    // 140: "Building %s%s"
    sprintf(s, v28, v64);
  }
  v37 = v68;
  x_4b = v73;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v72->a;
  v38 = &v72->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v72->rect.x1;
  v38 = (T_Rect *)((char *)v38 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = v38->x1;
  v38 = (T_Rect *)((char *)v38 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = v38->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v38->y1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x113, v37, s, 0, x_4b, 0xFF, 0);
  v39 = 0;
  v68 = 0x19;
  v40 = word_FFEDC;
  v75 = (unsigned __int16)word_96B6C;
  do
  {
    v41 = (int *)(unsigned __int16)sub_35930(a2, *((_BYTE *)&v75 + v39));
    if ( v41 != (int *)0xFFFF )
    {
      v41 = (int *)(*(_WORD *)(*(_DWORD *)(a2 + 0x10) + 4 * (_DWORD)v41 + 2) & 1);
      if ( v41 )
      {
        v57 = v68;
        v53 = *((unsigned __int8 *)&v75 + v39);
        v42 = sub_1B084((unsigned int)dword_12FC20, v40);
        v41 = sub_5D631(
                v72,
                v42,
                v53,
                0xF5,
                v57,
                (int)byte_D8DA0,
                0,
                (void (__noreturn *)())0x4000,
                (void (__noreturn *)())0x4000,
                0);
        v68 += 0x19;
      }
    }
    ++v39;
  }
  while ( v39 < 2 );
  LOWORD(v41) = word_FFEEC;
  v76 = v41;
  string = (char *)*(unsigned __int16 *)(a2 + 0x46);
  string = (char *)(int)pow((double)(int)string, 0.75);
  v77 = (int)string;
  if ( (unsigned __int16)string > 0x14u )
  {
    v77 = 0x14;
  }
  v54 = (unsigned __int16)v77;
  v43 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
  v44 = sub_5D631(
          v72,
          v43,
          v54,
          0x118,
          0x3C,
          (int)byte_D8DA0,
          0,
          (void (__noreturn *)())0x8000,
          (void (__noreturn *)())0x8000,
          0);
  LOWORD(v44) = word_FFEEE;
  v76 = v44;
  string = (char *)*(unsigned __int16 *)(a2 + 0x44);
  string = (char *)(int)pow((double)(int)string, 0.75);
  v77 = (int)string;
  if ( (unsigned __int16)string > 0x14u )
  {
    v77 = 0x14;
  }
  v55 = (unsigned __int16)v77;
  v45 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
  v46 = sub_5D631(
          v72,
          v45,
          v55,
          0x15E,
          0x3C,
          (int)byte_D8DA0,
          0,
          (void (__noreturn *)())0x8000,
          (void (__noreturn *)())0x8000,
          0);
  LOWORD(v46) = word_FFEF0;
  v76 = v46;
  LOWORD(v46) = *(_WORD *)(a2 + 0x48);
  v77 = (int)v46;
  if ( (unsigned __int16)v46 > 0x14u )
  {
    v77 = 0x14;
  }
  v56 = (unsigned __int16)v77;
  v47 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
  v48 = 0x1EA;
  v49 = sub_5D631(
          v72,
          v47,
          v56,
          0x1A4,
          0x3C,
          (int)byte_D8DA0,
          0,
          (void (__noreturn *)())0x8000,
          (void (__noreturn *)())0x8000,
          0);
  LOWORD(v49) = word_FFEF8;
  v69 = 0x3C;
  v76 = v49;
  v77 = 6;
  for ( i = 0; ; ++i )
  {
    result = *(_WORD *)(a2 + 0x4A);
    if ( i >= result )
    {
      break;
    }
    if ( i == *(unsigned __int16 *)(a2 + 0x4C) )
    {
      v77 = 7;
    }
    if ( i == *(unsigned __int16 *)(a2 + 0x42) )
    {
      v77 = 8;
    }
    v65 = v69;
    x_4c = (unsigned __int16)v77;
    v52 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
    sub_5CB3C(v72, v52, x_4c, v48, v65);
    v48 += 5;
    if ( i % 0xA == 9 )
    {
      v48 = 0x1EA;
      v69 += 5;
    }
  }
  return result;
}
// 96B2A: using guessed type __int16 word_96B2A;
// 96B2C: using guessed type __int16 word_96B2C;
// 96B6C: using guessed type __int16 word_96B6C;
// A2F79: using guessed type int dword_A2F79;
// A3D21: using guessed type __int16 word_A3D21[];
// D8648: using guessed type int dword_D8648;
// FFEDC: using guessed type __int16 word_FFEDC;
// FFEEC: using guessed type __int16 word_FFEEC;
// FFEEE: using guessed type __int16 word_FFEEE;
// FFEF0: using guessed type __int16 word_FFEF0;
// FFEF8: using guessed type __int16 word_FFEF8;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 104688: using guessed type int dword_104688[4];
// 10469C: using guessed type int dword_10469C[10];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 50530: using guessed type char s[100];

//----- (00050D70) --------------------------------------------------------
unsigned int __fastcall sub_50D70(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // eax
  int v6; // esi
  char *v7; // eax
  int v8; // eax
  int *v9; // ecx
  char *v10; // eax
  int v11; // eax
  int v12; // edx
  float *v13; // esi
  float *v14; // eax
  int v15; // ebx
  double v16; // st7
  char v17; // ah
  char *v18; // edi
  unsigned int v19; // esi
  float *v20; // eax
  int v21; // eax
  char *v22; // eax
  int v23; // esi
  char *sub_1CEA8; // eax
  int v25; // eax
  int v26; // esi
  char *v27; // eax
  int v28; // eax
  char v29; // bh
  int v30; // edx
  char *v31; // eax
  char *v32; // esi
  char *v33; // edi
  char v34; // al
  char v35; // al
  int v36; // edi
  int v37; // esi
  int v38; // eax
  int v39; // ecx
  int v40; // eax
  int v41; // edi
  int v42; // esi
  int v43; // edi
  int v44; // eax
  int v45; // edi
  int v46; // eax
  int v47; // ebx
  __int16 v48; // si
  int v49; // eax
  unsigned int result; // eax
  int v51; // [esp-4h] [ebp-174h]
  __int16 v52; // [esp-4h] [ebp-174h]
  int v53; // [esp-4h] [ebp-174h]
  int v54; // [esp-4h] [ebp-174h]
  unsigned __int64 x; // [esp+0h] [ebp-170h]
  int xa; // [esp+0h] [ebp-170h]
  __int16 x_4; // [esp+4h] [ebp-16Ch]
  int x_4a; // [esp+4h] [ebp-16Ch]
  int x_4b; // [esp+4h] [ebp-16Ch]
  char s[200]; // [esp+8h] [ebp-168h] BYREF
  T_Type5 v61; // [esp+D0h] [ebp-A0h] BYREF
  int v62[5]; // [esp+E4h] [ebp-8Ch]
  int v63[3]; // [esp+F8h] [ebp-78h] BYREF
  float v64; // [esp+104h] [ebp-6Ch]
  float v65; // [esp+108h] [ebp-68h]
  float v66; // [esp+10Ch] [ebp-64h]
  int v67[2]; // [esp+110h] [ebp-60h]
  int v68[2]; // [esp+118h] [ebp-58h]
  int v69[3]; // [esp+120h] [ebp-50h]
  int v70; // [esp+12Ch] [ebp-44h]
  float v71; // [esp+130h] [ebp-40h]
  float v72; // [esp+134h] [ebp-3Ch]
  int v73; // [esp+138h] [ebp-38h]
  int v74; // [esp+13Ch] [ebp-34h]
  int v75; // [esp+140h] [ebp-30h]
  int *v76; // [esp+144h] [ebp-2Ch]
  unsigned int v77; // [esp+148h] [ebp-28h]
  unsigned int v78; // [esp+14Ch] [ebp-24h]
  int v79; // [esp+150h] [ebp-20h]
  int v80; // [esp+154h] [ebp-1Ch]
  __int64 v81; // [esp+158h] [ebp-18h]
  int v82; // [esp+160h] [ebp-10h]

  v74 = a2;
  v5 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B6E);
  sub_5CB3C((P_Type5)a1, v5, *(char *)(a2 + 0xAA), 0x41, 0x32);
  HIDWORD(v81) = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  if ( a4 )
  {
    HIDWORD(v81) = 0xF3;
  }
  switch ( *(_BYTE *)(v74 + 0x58) )
  {
    case 1:
      v23 = *(_DWORD *)(v74 + 0x59);
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x93);// 147: "Under Construction at %s"
      sprintf(s, sub_1CEA8, v23 + 0x24);
      v25 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B72);
      sub_5CB3C(
        (P_Type5)a1,
        v25,
        *(unsigned __int16 *)(v23 + 0x14) + 5 * *(unsigned __int16 *)(v23 + 0x16),
        0x24E,
        0x31);
      break;
    case 2:
      v26 = *(_DWORD *)(v74 + 0x59);
      v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x94);  // 148: "Being Refitted at %s"
      sprintf(s, v27, v26 + 0x24);
      v28 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B72);
      sub_5CB3C(
        (P_Type5)a1,
        v28,
        5 * *(unsigned __int16 *)(v26 + 0x16) + *(unsigned __int16 *)(v26 + 0x14),
        0x24E,
        0x31);
      break;
    case 3:
      v6 = *(_DWORD *)(v74 + 0x59);
      v7 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8F);   // 143: "Orbiting %s"
      sprintf(s, v7, v6 + 0x24);
      v8 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B72);
      sub_5CB3C((P_Type5)a1, v8, *(unsigned __int16 *)(v6 + 0x14) + 5 * *(unsigned __int16 *)(v6 + 0x16), 0x24E, 0x31);
      break;
    case 4:
      v9 = *(int **)(v74 + 0x59);
      v10 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x90);  // 144: "in %s System"
      sprintf(s, v10, v9 + 7);
      v11 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B70);
      sub_5CB3C((P_Type5)a1, v11, *v9, 0x24E, 0x31);
      break;
    case 5:
      v12 = *(_DWORD *)(v74 + 0x59);
      v13 = *(float **)(v12 + 4);
      v14 = *(float **)v12;
      v69[2] = (int)v63;
      v64 = 0.0;
      v65 = 0.0;
      v66 = 0.0;
      v64 = v14[2] - v13[2];
      v65 = v14[3] - v13[3];
      v66 = v14[4] - v13[4];
      *(float *)v63 = v64;
      *(float *)&v63[1] = v65;
      *(float *)&v63[2] = v66;
      v15 = v74;
      v16 = sqrt(v65 * v65 + v64 * v64 + v66 * v66);
      v70 = *(_DWORD *)(v15 + 0xC) + *(_DWORD *)(v74 + 8);
      v71 = v16;
      v17 = *(_BYTE *)(v12 + 0x23);
      v72 = (float)v70;
      if ( (v17 & 1) != 0 )
      {
        v72 = v72 * flt_92C3A;
      }
      if ( byte_A310F[0x1EE * *(__int16 *)(v74 + 0x56)] == 0x12 )
      {
        if ( v72 < 1.0 )
        {
          v72 = 1.0;
        }
        v72 = v72 * flt_92C3E;
      }
      v70 = (int)((v71 - *(float *)(v74 + 0x9E)) / v72);
      v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x91);  // 145: "Unknown"
      if ( (*(_DWORD *)(v74 + 0xA2) & 0x7FFFFFFF) != 0 )
      {
        v20 = *(float **)(v12 + 4);
      }
      else
      {
        v20 = *(float **)v12;
      }
      if ( ((1 << byte_104BEA) & *((unsigned __int8 *)v20 + 0x17)) != 0 )
      {
        v18 = (char *)(v20 + 7);
      }
      if ( v70 )
      {
        v21 = 0x1D;                                    // 29: "s"
      }
      else
      {
        v21 = 0x1C;                                    // 28: ""
      }
      v19 = v70 + 1;
      x = __PAIR64__((unsigned int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v21), v19);
      v22 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x92);  // 146: "In Starlane to %s System\nETA - %d Day%s"
      sprintf(s, v22, v18, x);
      break;
    default:
      sprintf(s, "Bad m_LocationType");
      break;
  }
  v29 = *(_BYTE *)(v74 + 0x5D);
  if ( v29 && v29 != 7 && *(_BYTE *)(v74 + 0x58) == 4 )
  {
    v30 = v74;
    v31 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x95);    // 149: "\nMoving to Planet"
    if ( *(_BYTE *)(v30 + 0x5D) == 1 )
    {
      v31 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x96);  // 150: "\nMoving to Starlane"
    }
    v32 = v31;
    v33 = &s[strlen(s)];
    do
    {
      v34 = *v32;
      *v33 = *v32;
      if ( !v34 )
      {
        break;
      }
      v35 = v32[1];
      v32 += 2;
      v33[1] = v35;
      v33 += 2;
    }
    while ( v35 );
  }
  v51 = *(int *)((char *)&v81 + 2) >> 0x10;
  v70 = *(int *)((char *)&v81 + 2) >> 0x10;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x17C, 5, s, 0, v51, 0xFF, 0x8E);
  sprintf(s, "%s", (const char *)(v74 + 0x34));
  v52 = v70;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  v36 = 0x103;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x96, 5, s, 0, v52, 0xFF, 0);
  v37 = 0;
  v73 = sub_4A8CC(v74);
  do
  {
    if ( v37 >= v73 )
    {
      break;
    }
    x_4 = *(_WORD *)(v74 + 0x56);
    v39 = v36;
    ++v37;
    v40 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE6);
    v36 += 9;
    sub_53EB8((P_Type5)a1, v40, 6, v39, 6, x_4);
  }
  while ( v37 < 9 );
  v62[0] = *(_DWORD *)v74;
  v62[1] = *(_DWORD *)(v74 + 4);
  v62[2] = *(_DWORD *)(v74 + 0x10);
  v62[3] = *(_DWORD *)(v74 + 0x20);
  v38 = *(_DWORD *)(v74 + 0x18);
  v80 = 0x19;
  v62[4] = v38;
  v77 = 0;
  v61 = *(T_Type5 *)a1;
  LOWORD(v38) = word_FFEE6;
  v82 = v38;
  v75 = 7;
  do
  {
    v61.rect.x2 = v61.rect.x1 + 0x95;
    v41 = v62[v77 / 4];
    v42 = 0x96;
    if ( v41 > 0 )
    {
      v61.rect.x2 += (0xE * v41 - (__CFSHL__((0xE * v41) >> 0x1F, 2) + 4 * ((0xE * v41) >> 0x1F))) >> 2;
    }
    v43 = 0;
    v79 = v75;
    do
    {
      x_4a = v80;
      xa = v42;
      v53 = v79;
      v44 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v82);
      ++v43;
      v42 += 0xE;
      sub_5CB3C(&v61, v44, v53, xa, x_4a);
    }
    while ( v43 < 0xE );
    v80 += 0xE;
    v77 += 4;
    ++v75;
  }
  while ( v77 != 0x14 );
  v69[0] = *(_DWORD *)(v74 + 0x8C);
  v45 = 0x15E;
  v69[1] = *(_DWORD *)(v74 + 0x88);
  v46 = *(_DWORD *)(v74 + 0x98);
  v78 = 0;
  v68[0] = v46;
  v76 = (int *)0x16B;
  v68[1] = sub_4A8FC(v74);
  v67[1] = 0xB;
  v67[0] = 8;
  do
  {
    result = v78;
    if ( v68[v78 / 4] > 0 )
    {
      if ( v69[v78 / 4] >= 0 )
      {
        v47 = v68[v78 / 4];
        if ( v69[v78 / 4] > v47 )
        {
          v69[v78 / 4] = v47;
        }
      }
      else
      {
        v69[v78 / 4] = 0;
      }
      v48 = 0;
      LODWORD(v81) = v78;
      while ( v48 < 7 )
      {
        x_4b = 0xE * v48 + 5;
        v54 = *(int *)((char *)v67 + v81);
        v49 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v82);
        ++v48;
        sub_5CB3C((P_Type5)a1, v49, v54, v45, x_4b);
      }
      result = sub_2BB74(
                 (int **)a1,
                 (int *)v45,
                 (int *)4,
                 v76,
                 (int *)(0x66 - 0x62 * *(int *)((char *)v69 + v81) / *(int *)((char *)v68 + v81)),
                 0,
                 0xFFFFFFFF);
    }
    v45 += 0xE;
    v76 = (int *)((char *)v76 + 0xE);
    v78 += 4;
  }
  while ( v78 != 8 );
  return result;
}
// 92C3A: using guessed type float flt_92C3A;
// 92C3E: using guessed type float flt_92C3E;
// 96B6E: using guessed type __int16 word_96B6E;
// 96B70: using guessed type __int16 word_96B70;
// 96B72: using guessed type __int16 word_96B72;
// FFEE6: using guessed type __int16 word_FFEE6;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 50D70: using guessed type char s[200];

//----- (00051610) --------------------------------------------------------
unsigned int __fastcall sub_51610(T_Type5 *a1, int a2, int a3, int a4)
{
  int v5; // eax
  int v6; // eax

  if ( a4 == 0xFFFFFFFF )
  {
    sub_5E9D0(a1, 0x96);
  }
  v5 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
  sub_5CB3C(a1, v5, a2, 0x38, 0x37);
  v6 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE2);
  return sub_5CB3C(a1, v6, 7, 0x38, 0x37);
}
// FFEE2: using guessed type __int16 word_FFEE2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00051674) --------------------------------------------------------
T_TypeA2 *__fastcall sub_51674(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_96128;
  sub_516D4((int)a1);
  return a1;
}
// 96128: using guessed type int (*off_96128[5])();

//----- (00051690) --------------------------------------------------------
int __fastcall sub_51690(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_960E4);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_96128;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 96128: using guessed type int (*off_96128[5])();

//----- (000516D4) --------------------------------------------------------
int __fastcall sub_516D4(int result)
{
  *(_DWORD *)(result + 0xAB) = 0;
  return result;
}

//----- (000516E0) --------------------------------------------------------
void __fastcall sub_516E0(_DWORD *a1)
{
  __int16 *v1; // eax
  int v2; // ebx
  int i; // edx
  int v4; // eax
  int v5; // eax
  char *v6; // eax
  unsigned __int8 v7; // al
  _DWORD *v8; // esi
  char *v9; // [esp-14h] [ebp-6Ch]
  int v10; // [esp-10h] [ebp-68h]
  char *v11; // [esp-Ch] [ebp-64h]
  char *sub_1CEA8; // [esp-4h] [ebp-5Ch]
  char s[80]; // [esp+0h] [ebp-58h] BYREF
  P_Type5 p_rect; // [esp+50h] [ebp-8h]
  _DWORD *v15; // [esp+54h] [ebp-4h]

  v15 = a1;
  v1 = word_A3D21;
  v2 = 0;
  for ( i = 0; (__int16)i < word_A62A1; v1 += 0x30 )
  {
    if ( *((unsigned __int8 *)v1 + 0x14) == 1 << byte_104BEA
      && v1 != *(__int16 **)((char *)&dword_A2F79 + 0x1EE * (unsigned __int8)byte_104BEA) )
    {
      ++v2;
    }
    ++i;
  }
  if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*(int *)((char *)&dword_A2F79 + 0x1EE * (unsigned __int8)byte_104BEA)
                                                + 0x14)) != 0 )
  {
    ++v2;
  }
  if ( v2 == 1 )
  {
    v4 = 0x1C;
  }
  else
  {
    v4 = 0x1D;
  }
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v4);
  if ( *(_WORD *)(*(_DWORD *)((char *)v15 + 0xAB) + 0x8C7) == 1 )
  {
    v5 = 0x1C;
  }
  else
  {
    v5 = 0x1D;
  }
  v11 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v5);
  v10 = *(unsigned __int16 *)(*(_DWORD *)((char *)v15 + 0xAB) + 0x8C7);
  v9 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
  v6 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x97);
  sprintf(s, v6, v9, v10, v11, v2, sub_1CEA8);
  v7 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  p_rect = (P_Type5)&CONTAINING_RECORD(v15, T_Type5, a)->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v15[1];
  v8 = v15 + 2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v15[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *++v8;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *++v8;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v8[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x19, 9, s, 2, 4 * v7 + 0x13, 0xFF, 0);
  sub_53E38(p_rect, 3, 3, (unsigned __int8)byte_104BEA);
  sub_2D218(v15);
}
// A2F79: using guessed type int dword_A2F79;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00051894) --------------------------------------------------------
unsigned int __fastcall sub_51894(int a1, __int16 a2, __int16 a3, int a4)
{
  int v6; // eax
  __int16 i; // di
  char *v8; // esi
  unsigned __int16 v9; // ax
  int v10; // eax

  if ( (unsigned __int16)a2 < 2u )
  {
    if ( a2 != 1 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( !*(_DWORD *)(a1 + 0xAB) )
    {
      v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "STATPLANLST", 0);
      *(_DWORD *)(a1 + 0xAB) = v6;
      if ( !v6 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x1CB);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x8D;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_50530);
      sub_2F1D8(*(_DWORD *)(a1 + 0xAB), (int)sub_10A14);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC5) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xBB) = 0xFFFFFFFF;
    }
    if ( (unsigned __int16)word_96B2C == 0xFFFF )
    {
      word_96B2C = sub_1B270((int)dword_12FC20, "DATA\\planets.shp", 0);
      if ( (unsigned __int16)word_96B2C == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x1D9);
      }
    }
    if ( (unsigned __int16)word_96B2A == 0xFFFF )
    {
      word_96B2A = sub_1B270((int)dword_12FC20, "DATA\\suns.shp", 0);
      if ( (unsigned __int16)word_96B2A == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x1E0);
      }
    }
    sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
    for ( i = 0; i < SHIWORD(dword_CA1ED); ++i )
    {
      v8 = (char *)&unk_BB1B3 + 0x7B * i;
      if ( v8[0x57] == (_BYTE)byte_104BEA )
      {
        v9 = sub_2EA8C(*(_DWORD *)(a1 + 0xAB), v8, 0x96, 0);
        sub_2EC50(*(_DWORD *)(a1 + 0xAB), v9, *(_DWORD *)(v8 + 0x67));
      }
    }
    sub_2F1E0(*(_DWORD *)(a1 + 0xAB));
    sub_2ECDC(*(_DWORD *)(a1 + 0xAB), *(_WORD *)(a1 + 0xAF));
    return sub_2F424(a1, a2, a3, a4);
  }
  else if ( (unsigned __int16)a2 <= 2u )
  {
    *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
    return sub_2F424(a1, a2, a3, a4);
  }
  else
  {
    if ( a2 != 0x1C01 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    v10 = sub_2ED14(*(_DWORD *)(a1 + 0xAB), a3);
    if ( dword_D8648 <= 0x96 )
    {
      dword_D3660 = (int)&word_A3D21[0x30 * *(__int16 *)(v10 + 0xC)];
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 1);
    }
    else
    {
      dword_D3664 = v10;
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
    }
    *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
    return 0;
  }
}
// 96B2A: using guessed type __int16 word_96B2A;
// 96B2C: using guessed type __int16 word_96B2C;
// A3D21: using guessed type __int16 word_A3D21[];
// CA1ED: using guessed type int dword_CA1ED;
// D3660: using guessed type int dword_D3660;
// D8648: using guessed type int dword_D8648;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00051B64) --------------------------------------------------------
T_TypeA2 *__fastcall sub_51B64(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_96110;
  sub_516D4((int)a1);
  return a1;
}
// 96110: using guessed type int (*off_96110[5])();

//----- (00051B80) --------------------------------------------------------
int __fastcall sub_51B80(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_960D0);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_96110;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 96110: using guessed type int (*off_96110[5])();

//----- (00051BC4) --------------------------------------------------------
void __fastcall sub_51BC4(_DWORD *a1)
{
  signed int v1; // eax
  int v2; // edx
  const char *v3; // eax
  char *sub_1CEA8; // eax
  unsigned __int8 v5; // al
  _DWORD *v6; // esi
  char *v7; // [esp-10h] [ebp-68h]
  int v8; // [esp-Ch] [ebp-64h]
  const char *v9; // [esp-8h] [ebp-60h]
  char s[80]; // [esp+0h] [ebp-58h] BYREF
  _DWORD *v11; // [esp+50h] [ebp-8h]
  P_Type5 p_rect; // [esp+54h] [ebp-4h]

  v11 = a1;
  v1 = sub_3EFE0((int)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
  v2 = v1;
  if ( v1 >= 0 )
  {
    if ( v1 > 0x64 )
    {
      v2 = 0x64;
    }
  }
  else
  {
    v2 = 0;
  }
  if ( *(_WORD *)(*(_DWORD *)((char *)v11 + 0xAB) + 0x8C7) == 1 )
  {
    v3 = (const char *)&unk_92C97;
  }
  else
  {
    v3 = "s";
  }
  v9 = v3;
  v8 = *(unsigned __int16 *)(*(_DWORD *)((char *)v11 + 0xAB) + 0x8C7);
  v7 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x98);// Static text 152
  sprintf(s, sub_1CEA8, v7, v8, v9, v2);
  v5 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  p_rect = (P_Type5)&CONTAINING_RECORD(v11, T_Type5, a)->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v11[1];
  v6 = v11 + 2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v11[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *++v6;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *++v6;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v6[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x19, 9, s, 2, 4 * v5 + 0x13, 0xFF, 0);
  sub_53E38(p_rect, 3, 3, (unsigned __int8)byte_104BEA);
  sub_2D218(v11);
}

//----- (00051D24) --------------------------------------------------------
unsigned int __fastcall sub_51D24(int a1, __int16 a2, int a3, int a4)
{
  unsigned int result; // eax
  int v6; // eax
  signed int v7; // ebp
  int v8; // esi
  unsigned __int16 v9; // ax
  int v10; // ecx
  int v11; // ebx
  __int16 v12; // dx
  int v13; // eax
  int v14; // esi
  int v15; // eax
  int v16[107]; // [esp+0h] [ebp-1C8h] BYREF
  int v17; // [esp+1ACh] [ebp-1Ch]
  int v18; // [esp+1B0h] [ebp-18h]
  __int16 v19; // [esp+1B4h] [ebp-14h]
  __int16 i; // [esp+1B8h] [ebp-10h]

  v19 = a2;
  v18 = a3;
  v17 = a4;
  if ( (unsigned __int16)a2 < 2u )
  {
    if ( a2 != 1 )
    {
      return sub_2F424(a1, v19, v18, v17);
    }
    if ( !*(_DWORD *)(a1 + 0xAB) )
    {
      v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "STATSHIPLST", 0);
      *(_DWORD *)(a1 + 0xAB) = v6;
      if ( !v6 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x259);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x6A;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_50D70);
      sub_2F1D8(*(_DWORD *)(a1 + 0xAB), (int)sub_10A14);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC5) = 0;
    }
    word_96B6E = word_FFEBC[(unsigned __int8)byte_104BEA];
    if ( (unsigned __int16)word_96B72 == 0xFFFF )
    {
      word_96B72 = sub_1B270((int)dword_12FC20, "DATA\\planets.shp", 0);
      if ( (unsigned __int16)word_96B72 == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x269);
      }
    }
    if ( (unsigned __int16)word_96B70 == 0xFFFF )
    {
      word_96B70 = sub_1B270((int)dword_12FC20, "DATA\\suns.shp", 0);
      if ( (unsigned __int16)word_96B70 == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x270);
      }
    }
    sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
    v7 = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], v16, 0);
    for ( i = 0; i < v7; ++i )
    {
      v8 = v16[i];
      v9 = sub_2EA8C(*(_DWORD *)(a1 + 0xAB), (const char *)v8, 0x64, 0);
      sub_2EC50(*(_DWORD *)(a1 + 0xAB), v9, *(_DWORD *)(v8 + 0x52));
    }
    v10 = v17;
    sub_2F1E0(*(_DWORD *)(a1 + 0xAB));
    v11 = v18;
    sub_2ECDC(*(_DWORD *)(a1 + 0xAB), *(_WORD *)(a1 + 0xAF));
    return sub_2F424(a1, v19, v11, v10);
  }
  else if ( (unsigned __int16)a2 <= 2u )
  {
    v12 = v19;
    *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
    return sub_2F424(a1, v12, a3, a4);
  }
  else
  {
    if ( a2 != 0x1C01 )
    {
      return sub_2F424(a1, v19, v18, v17);
    }
    v13 = sub_2ED14(*(_DWORD *)(a1 + 0xAB), v18);
    v14 = v13;
    if ( a4 == 5 )
    {
      v15 = sub_56DA8((int)&V_Type3_stru_10AE70, "SHIPDESSCREEN", 0);
      sub_4DA7C(v15, v14, 0, 0xFFFFFFFF);
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 8, 1);
      *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
      return 0xFFFFFFFF;
    }
    else
    {
      switch ( *(_BYTE *)(v13 + 0x58) )
      {
        case 1:
        case 2:
        case 3:
          dword_D3664 = *(_DWORD *)(v13 + 0x59);
          sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
          *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
          result = 0xFFFFFFFF;
          break;
        case 4:
          dword_D3660 = *(_DWORD *)(v13 + 0x59);
          sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 1);
          *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
          result = 0xFFFFFFFF;
          break;
        case 5:
          sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
          result = 0xFFFFFFFF;
          break;
        default:
          result = 0;
          break;
      }
    }
  }
  return result;
}
// 96B6E: using guessed type __int16 word_96B6E;
// 96B70: using guessed type __int16 word_96B70;
// 96B72: using guessed type __int16 word_96B72;
// D3660: using guessed type int dword_D3660;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 51D24: using guessed type int var_1C8[107];

//----- (000520EC) --------------------------------------------------------
T_TypeA2 *__fastcall sub_520EC(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_960F8;
  sub_5214C((int)a1);
  return a1;
}
// 960F8: using guessed type int (*off_960F8[5])();

//----- (00052108) --------------------------------------------------------
int __fastcall sub_52108(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_960BC);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_960F8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 960F8: using guessed type int (*off_960F8[5])();

//----- (0005214C) --------------------------------------------------------
int __fastcall sub_5214C(int result)
{
  *(_DWORD *)(result + 0xAF) = 0;
  *(_DWORD *)(result + 0xAB) = 0;
  *(_WORD *)(result + 0xB3) = 0;
  *(_WORD *)(result + 0xB5) = 0;
  return result;
}

//----- (00052174) --------------------------------------------------------
int __fastcall sub_52174(int a1)
{
  char *v1; // ecx
  int v2; // esi
  FILE *v3; // edi

  *(_DWORD *)(a1 + 0xAF) = &unk_109DF8;
  v1 = *(char **)(a1 + 0xAF);
  v2 = 0;
  v3 = sub_1BB10("newgame.txt", 0);
  do
  {
    fgets(v1, 0xC7, v3);
    ++v2;
    v1 += 0xC8;
  }
  while ( v2 < 0x15 );
  return fclose(v3);
}

//----- (000521C0) --------------------------------------------------------
void __fastcall sub_521C0(int a1, int edx0)
{
  char *sub_1CEA8; // eax
  int v4; // edi
  int v5; // ecx
  int v6; // ecx
  unsigned __int16 v7; // ax
  int v8; // eax
  int v9; // ebx
  char *v10; // eax
  int v11; // eax
  int v12; // edx
  int i; // ebx
  char *v14; // eax
  int v15; // ebx
  int j; // edx
  char *v17; // eax
  int v18; // ebx
  int k; // edx
  char *v20; // eax
  char *v21; // eax
  __int16 m; // si
  int v23; // ebx
  int v24; // eax
  int v25; // [esp-Ch] [ebp-15Ch]
  int v26; // [esp-Ch] [ebp-15Ch]
  int v27; // [esp-8h] [ebp-158h]
  int v28; // [esp-4h] [ebp-154h]
  int v29; // [esp-4h] [ebp-154h]
  char s[280]; // [esp+0h] [ebp-150h] BYREF
  T_Type5 v31; // [esp+118h] [ebp-38h] BYREF
  int a2[3]; // [esp+12Ch] [ebp-24h]
  int v33; // [esp+138h] [ebp-18h]

  v33 = edx0;
  sub_52714(a1);
  v31.a = *(P_Type6 *)(a1 + 4);
  v31.rect.x1 = 0x1F6;
  v31.rect.y1 = 7;
  v31.rect.x2 = 0x278;
  v31.rect.y2 = 0x24;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x99);// 153: "Player Species"
  sprintf(s, sub_1CEA8);
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v31;
  v4 = v33;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, s, 3, 0xF3, 0xFF, 0x6E);
  if ( !v4 )
  {
    v31 = *(T_Type5 *)(a1 + 4);
    sub_5E9D0((P_Type5)(a1 + 4), 0);
    v31.rect.y2 = 0x23;
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v31;
    sub_2B8A8(
      (int)&V_Type3_stru_10AE70.z1[0x3046],
      0,
      0,
      &byte_1050A4[0x14 * *(__int16 *)(a1 + 0xB3)],
      3,
      (unsigned __int8)byte_96779[*(__int16 *)(a1 + 0xB5)],
      0xFF,
      0);
    v5 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
    if ( !v5 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x325);
    }
    sub_5CB3C((P_Type5)(a1 + 4), v5, *(__int16 *)(a1 + 0xB3), 0x4B, 0x55);
    v6 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE2);
    if ( !v6 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x329);
    }
    sub_5CB3C((P_Type5)(a1 + 4), v6, *(__int16 *)(a1 + 0xB5), 0x4B, 0x55);
    v7 = sub_1B270((int)dword_12FC20, "DATA\\smhome.shp", 0xFFFFFFFF);
    if ( v7 == 0xFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x334);
    }
    v25 = *(__int16 *)(a1 + 0xB3);
    v8 = sub_1B084((unsigned int)dword_12FC20, v7);
    sub_5CB3C((P_Type5)(a1 + 4), v8, v25, 0x48, 0xCD);
    sub_53E38((P_Type5)(a1 + 4), 0x6B, 0xC1, (unsigned __int8)byte_104BEA);
    if ( !*(_DWORD *)(a1 + 0xAF) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x340);
    }
    if ( *(__int16 *)(a1 + 0xB3) >= 0x15 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x341);
    }
    v9 = *(__int16 *)(a1 + 0xB3);
    v28 = *(_DWORD *)(a1 + 0xAF) + 0xC8 * v9;
    v10 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x9A);    // 154: "The %s %s"
    sprintf(s, v10, &byte_1050A4[0x14 * v9], v28);
    v31.rect.y1 = 0x109;
    v31.rect.y2 = *(_DWORD *)(a1 + 0x14);
    v11 = *(__int16 *)(a1 + 0xB5);
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x302E] = v31;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0, 0, s, 0, (unsigned __int8)byte_96779[v11], 0xFF, 0x96);
    v12 = 0x9B;                                        // 155: "Vacuous"
    for ( i = 0; i != 0x14; *(_DWORD *)&s[i + 0xEC] = v14 )
    {
      i += 4;
      v14 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v12++);
    }
    v15 = 0xA0;                                        // 160: "Peaceful"
    for ( j = 0; j != 0xC; *(int *)((char *)&v31.rect.y2 + j) = (int)v17 )
    {
      j += 4;
      v17 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v15++);
    }
    v18 = 0xA3;                                        // 163: "Three"
    for ( k = 0; k != 0x14; *(_DWORD *)&s[k + 0x100] = v20 )
    {
      k += 4;
      v20 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v18++);
    }
    v31.rect.x1 = 0x11;
    v31.rect.y1 = 0x145;
    v31.rect.x2 = 0x144;
    v31.rect.y2 = 0x172;
    v29 = a2[*(__int16 *)(a1 + 0xBB)];
    v27 = *(_DWORD *)&s[4 * *(__int16 *)(a1 + 0xB9) + 0xF8];
    v26 = *(_DWORD *)&s[4 * *(__int16 *)(a1 + 0xB7) + 0xF0];
    v21 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xA8);    // 168: "%s Star Cluster\n%s Species\n%s Atmosphere"
    sprintf(s, v21, v26, v27, v29);
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v31;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, s, 0x82, 0xFFFFFFFF, 0, 0xFA);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
    v31.a = (P_Type6)V_Type6_stru_D8654.pane.window;
    v31.rect.x2 = 0x18B;
    v31.rect.y2 = 0x1CF;
    v31.rect.x1 = 0x17D;
    v31.rect.y1 = 0x1B1;
    for ( m = 0; m < 7; ++m )
    {
      v23 = *(int *)(a1 + 0xB1) >> 0x10;
      v24 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE0);
      sub_53F40(&v31, v24, v23, 0, 0, m);
      if ( m == *(_WORD *)(a1 + 0xB5) )
      {
        sub_2BB74((int **)&v31, 0, 0, (int *)0xE, (int *)0x18, 0xF3u, 0);
      }
      v31.rect.x1 += 0x10;
      v31.rect.x2 += 0x10;
    }
    sub_55274(&V_Type3_stru_10AE70, 0x17B, 0x1A4, 0x1ED, 0x1D8);
  }
}
// FFEE0: using guessed type __int16 word_FFEE0;
// FFEE2: using guessed type __int16 word_FFEE2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 521C0: using guessed type int a2[3];

//----- (000526D8) --------------------------------------------------------
unsigned int sub_526D8()
{
  if ( dword_D8648 <= 0x1F6 || dword_D8648 >= 0x278 || dword_D864C <= 0x17D || dword_D864C >= 0x1D8 )
  {
    return 0;
  }
  else
  {
    return 0xFFFFFFFF;
  }
}
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;

//----- (00052714) --------------------------------------------------------
int __fastcall sub_52714(int a1)
{
  char v1; // dl
  int v2; // eax
  int v3; // edi
  int *v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  char v8; // ah
  _DWORD *v9; // ebp
  int v10; // eax
  int v11; // eax
  char *sub_1CEA8; // eax
  int v14; // [esp-20h] [ebp-60h]
  T_Type5 v15; // [esp+0h] [ebp-40h] BYREF
  int v16; // [esp+14h] [ebp-2Ch]
  int v17; // [esp+18h] [ebp-28h]
  int v18; // [esp+1Ch] [ebp-24h]
  int v19; // [esp+20h] [ebp-20h]
  int i; // [esp+24h] [ebp-1Ch]

  v16 = a1;
  v15.a = (P_Type6)V_Type6_stru_D8654.pane.window;
  v15.rect.x1 = 0x1F6;
  v15.rect.y1 = 0x17D;
  v15.rect.x2 = 0x278;
  v1 = 0xF2;
  v15.rect.y2 = 0x1D8;
  if ( sub_526D8() == 0xFFFFFFFF )
  {
    v1 = 0x96;
  }
  sub_5E9D0(&v15, v1);
  sub_55274(&V_Type3_stru_10AE70, 0x1F6, 0x17D, 0x278, 0x1D8);
  v18 = sub_56E18((int)&V_Type3_stru_10AE70, "COSMOSWnd", 3, 0);
  if ( !v18 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x3BB);
  }
  HIWORD(v2) = HIWORD(v18);
  v3 = 0;
  LOWORD(v2) = *(_WORD *)(v18 + 0x572);
  v4 = (int *)(v18 + 0x172);
  for ( i = v2; (__int16)v3 < (__int16)i; ++v4 )
  {
    v7 = *v4;
    v8 = *(_BYTE *)(*v4 + 4);
    v19 = (int)(*(float *)(*v4 + 0xD) + flt_92D77);
    if ( !v8 )
    {
      v5 = 3;
      v9 = *(_DWORD **)v7;
      if ( v19 <= 0xDC )
      {
        if ( v19 <= 0 )
        {
          if ( v19 > (int)0xFFFFFF24 )
          {
            v5 = 2;
          }
        }
        else
        {
          v5 = 1;
        }
      }
      else
      {
        v5 = 0;
      }
      v6 = *(__int16 *)(v7 + 7);
      v17 = 5;
      sub_5CB3C(&v15, *(_DWORD *)(v18 + 0xAB), 4 * *v9 + v5, *(__int16 *)(v7 + 5) / 5 + 5, v6 / 5 + 5);
    }
    ++v3;
  }
  v14 = *(__int16 *)(v16 + 0xB3);
  v10 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
  sub_5D631(
    &v15,
    v10,
    v14,
    0x62,
    0x24,
    (int)byte_D8DA0,
    0,
    (void (__noreturn *)())0x8000,
    (void (__noreturn *)())0x8000,
    0);
  v11 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
  sub_53EB8(&v15, v11, 3, 0x62, 0x24, 0);
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xA9);
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v15;
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x41, 0x50, sub_1CEA8, 0xC, 0xFFFFFFFF, 0xFF, 0);
}
// 92D77: using guessed type float flt_92D77;
// FFEF2: using guessed type __int16 word_FFEF2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0005294C) --------------------------------------------------------
unsigned int __fastcall sub_5294C(int a1, __int16 dx0, int a3, int a4)
{
  int v6; // eax
  int v7; // edx
  int v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // edx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  __int16 i; // si
  int v15; // eax
  int v16; // eax
  int v17; // eax
  __int16 v18; // bx
  __int16 v19; // edx^2
  int v20; // ecx
  int v21; // ebx
  __int16 v22; // dx
  int v23; // ecx
  int v24; // ebx
  int v25; // ebx
  _WORD v26[3]; // [esp+0h] [ebp-42h]
  int v27; // [esp+6h] [ebp-3Ch]
  int v28; // [esp+Ah] [ebp-38h]
  int v29; // [esp+Eh] [ebp-34h]
  int v30; // [esp+12h] [ebp-30h]
  T_Type5 a2; // [esp+16h] [ebp-2Ch] BYREF
  int v32; // [esp+2Ah] [ebp-18h]
  int v33; // [esp+2Eh] [ebp-14h]
  __int16 v34; // [esp+32h] [ebp-10h]

  v34 = dx0;
  v33 = a3;
  v32 = a4;
  *(_DWORD *)&v26[1] = dword_96B74[0];
  v27 = dword_96B74[1];
  v28 = dword_96B74[2];
  v29 = dword_96B74[3];
  v30 = dword_96B74[4];
  if ( (unsigned __int16)dx0 < 0x1F5u )
  {
    if ( (unsigned __int16)dx0 < 2u )
    {
      if ( dx0 == 1 )
      {
        sub_54048("resume.gam", 1, a3, a4);
        dword_96BC0 = 0xFFFFFFFF;
        v12 = *(_DWORD *)(a1 + 0xAB);
        dword_12FC10 = 0;
        if ( !v12 )
        {
          v13 = sub_56DA8((int)&V_Type3_stru_10AE70, "RACELIST", 0);
          *(_DWORD *)(a1 + 0xAB) = v13;
          if ( !v13 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x463);
          }
          *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
          *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x6D;
          sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_51610);
          sub_2E9CC(*(_DWORD *)(a1 + 0xAB), 0);
          *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC6) = 0xF2;
        }
        sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
        for ( i = 0; i < 0x15; ++i )
        {
          sub_2EA8C(*(_DWORD *)(a1 + 0xAB), (const char *)i, 0x73, 0);
        }
        v15 = *(_DWORD *)(a1 + 0x67);
        *(_WORD *)(a1 + 0xB7) = 2;
        *(_DWORD *)(*(_DWORD *)v15 + 0x72) = 2;
        v16 = *(_DWORD *)(a1 + 0x67);
        *(_WORD *)(a1 + 0xB9) = 5;
        *(_DWORD *)(*(_DWORD *)(v16 + 4) + 0x72) = 7;
        v17 = *(_DWORD *)(a1 + 0x67);
        *(_WORD *)(a1 + 0xBB) = 1;
        *(_DWORD *)(*(_DWORD *)(v17 + 8) + 0x72) = 0xB;
        v18 = *(_WORD *)(a1 + 0xB9);
        byte_A3D20 = 1;
        *(_WORD *)(a1 + 0xB3) = 0;
        sub_1E10C((int)dword_A2F6C, v26[2 * *(__int16 *)(a1 + 0xB7) + 1], v18, *(_WORD *)(a1 + 0xB3));
        *(_WORD *)(a1 + 0xB5) = 0;
        LOBYTE(byte_104BEA) = 0;
        LOBYTE(byte_A2F73) = 0;
        sub_1EE08((int)dword_A2F6C, *(_WORD *)(a1 + 0xB5));
        a2.a = *(P_Type6 *)(a1 + 4);
        a2.rect.y2 = 0x1D8;
        a2.rect.x1 = 0x17B;
        a2.rect.y1 = 0x1A4;
        a2.rect.x2 = 0x1ED;
        sub_5E9D0(&a2, 0xF2);
        sub_552CC(&V_Type3_stru_10AE70, &a2);
        v19 = v34;
        v20 = v32;
        v21 = v33;
        sub_52174(a1);
        return sub_2F424(a1, v19, v21, v20);
      }
    }
    else
    {
      if ( (unsigned __int16)dx0 <= 2u )
      {
        return sub_2F424(a1, v34, a3, a4);
      }
      if ( (unsigned __int16)dx0 >= 4u )
      {
        if ( (unsigned __int16)dx0 <= 5u )
        {
          if ( a3 <= 0x17B || a3 >= 0x1ED || a4 <= 0x1A4 || a4 >= 0x1D8 )
          {
            if ( sub_526D8() == 0xFFFFFFFF )
            {
              sub_4FB90((int)&unk_10914C, 0);
              sub_1F404((int)dword_A2F6C);
              sub_1F038((int)dword_A2F6C);
              v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "BatModeWnd", 0);
              v7 = v6 + 0x190;
              do
              {
                v6 += 4;
                *(_DWORD *)(v6 + 0x137A) = 0;
              }
              while ( v6 != v7 );
              v8 = sub_56DA8((int)&V_Type3_stru_10AE70, "COSMOSWnd", 0);
              sub_2280C(v8, (int)"COSMOSWnd", 0, a4);
              v9 = (_DWORD *)(sub_56DA8((int)&V_Type3_stru_10AE70, "RESWIN", 0) + 0x11F);
              v9[1] = 0;
              v9[2] = 0;
              v10 = v9 + 3;
              *v9 = 0x3F800000;
              v9[3] = 0;
              v9[4] = 0x3F800000;
              v9 += 6;
              v10[2] = 0;
              *v9 = 0;
              v9[1] = 0;
              v9[2] = 0x3F800000;
              v11 = sub_56DA8((int)&V_Type3_stru_10AE70, "RACECONTROLS", 0);
              if ( !v11 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x444);
              }
              sub_2DD70(v11);
              byte_A3D20 = *(_BYTE *)(a1 + 0xBB);
              sub_1EEA4((int)dword_A2F6C);
              dword_96BC0 = 0;
              sub_56B60((int)&V_Type3_stru_10AE70, 1, 0xC, 0);
              return 0xFFFFFFFF;
            }
            else
            {
              return 0;
            }
          }
          else
          {
            sub_4FB90((int)&unk_10914C, 0);
            *(_WORD *)(a1 + 0xB5) = (a3 - 0x17B - (__CFSHL__((a3 - 0x17B) >> 0x1F, 4) + 0x10 * ((a3 - 0x17B) >> 0x1F))) >> 4;
            sub_1EE08((int)dword_A2F6C, *(_WORD *)(a1 + 0xB5));
            (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(
              *(_DWORD *)&v26[1],
              v27,
              v28,
              v29,
              v30);
            return 0xFFFFFFFF;
          }
        }
        if ( dx0 == 0xC )
        {
          if ( a3 > 0x17B && a3 < 0x1ED && a4 > 0x1A4 && a4 < 0x1D8 )
          {
            sub_56B60((int)&V_Type3_stru_10AE70, 5, (int)"pcolor", 0);
            return 0xFFFFFFFF;
          }
          if ( sub_526D8() == 0xFFFFFFFF )
          {
            sub_56B60((int)&V_Type3_stru_10AE70, 5, (int)"beghelp", 0);
            return 0xFFFFFFFF;
          }
        }
      }
    }
    return sub_2F424(a1, v34, v33, v32);
  }
  if ( (unsigned __int16)dx0 <= 0x1F5u )
  {
    if ( ++*(_WORD *)(a1 + 0xB7) == 5 )
    {
      *(_WORD *)(a1 + 0xB7) = 0;
    }
    v23 = *(__int16 *)(a1 + 0xB3);
    v24 = *(__int16 *)(a1 + 0xB9);
    sub_1E10C((int)dword_A2F6C, v26[2 * *(__int16 *)(a1 + 0xB7) + 1], v24, v23);
    sub_24D30(*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC), dword_96BAC, v24, v23);
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    *(_DWORD *)(**(_DWORD **)(a1 + 0x67) + 0x72) = *(__int16 *)(a1 + 0xB7);
    (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(**(_DWORD **)(a1 + 0x67) + 0xA7) + 0xC))(
      *(_DWORD *)&v26[1],
      v27,
      v28,
      v29,
      v30);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)dx0 < 0x1F9u )
  {
    if ( dx0 == 0x1F7 )
    {
      if ( ++*(_WORD *)(a1 + 0xB9) == 8 )
      {
        *(_WORD *)(a1 + 0xB9) = 3;
      }
      v25 = *(__int16 *)(a1 + 0xB3);
      sub_1E70C((int)dword_A2F6C, *(_WORD *)(a1 + 0xB9), v25);
      sub_24D30(*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC), dword_96BAC, v25, a4);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4) + 0x72) = *(__int16 *)(a1 + 0xB9) + 2;
      (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4) + 0xA7) + 0xC))(
        *(_DWORD *)&v26[1],
        v27,
        v28,
        v29,
        v30);
      return 0xFFFFFFFF;
    }
    return sub_2F424(a1, v34, v33, v32);
  }
  if ( (unsigned __int16)dx0 <= 0x1F9u )
  {
    if ( ++*(_WORD *)(a1 + 0xBB) == 3 )
    {
      *(_WORD *)(a1 + 0xBB) = 0;
    }
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 8) + 0x72) = *(__int16 *)(a1 + 0xBB) + 0xA;
    (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 8) + 0xA7) + 0xC))(
      *(_DWORD *)&v26[1],
      v27,
      v28,
      v29,
      v30);
    return 0xFFFFFFFF;
  }
  else
  {
    if ( (unsigned __int16)dx0 <= 0x1FAu || dx0 != 0x1C01 )
    {
      return sub_2F424(a1, v34, v33, v32);
    }
    if ( *(__int16 *)(a1 + 0xB3) != a3 )
    {
      v22 = *(_WORD *)(a1 + 0xB9);
      *(_WORD *)(a1 + 0xB3) = v33;
      sub_1E70C((int)dword_A2F6C, v22, *(_WORD *)(a1 + 0xB3));
      (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(
        *(_DWORD *)&v26[1],
        v27,
        v28,
        v29,
        v30);
    }
    return 0xFFFFFFFF;
  }
}
// 96B74: using guessed type _DWORD dword_96B74[5];
// 96BAC: using guessed type int dword_96BAC;
// 96BC0: using guessed type int dword_96BC0;
// A2F6C: using guessed type int dword_A2F6C[];
// A3D20: using guessed type char byte_A3D20;
// 12FC10: using guessed type int dword_12FC10;

//----- (00053000) --------------------------------------------------------
void __fastcall sub_53000(float *a1)
{
  double v2; // st7
  float v3; // [esp+Ch] [ebp-8h]

  v3 = sqrt(a1[1] * a1[1] + *a1 * *a1 + a1[2] * a1[2]);
  if ( v3 > 0.0 )
  {
    v2 = 1.0 / v3;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = v2 * a1[2];
  }
}

//----- (00053054) --------------------------------------------------------
void __fastcall sub_53054(float *a1, float a2)
{
  sub_53000(a1);
  *a1 = *a1 * a2;
  a1[1] = a1[1] * a2;
  a1[2] = a2 * a1[2];
}

//----- (00053078) --------------------------------------------------------
unsigned int __fastcall sub_53078(_DWORD *a1)
{
  if ( (*a1 & 0x7FFFFFFF) != 0 || (a1[1] & 0x7FFFFFFF) != 0 || (a1[2] & 0x7FFFFFFF) != 0 )
  {
    return 0;
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (0005309C) --------------------------------------------------------
double __fastcall sub_5309C(float *a1, float *a2)
{
  double x; // st7
  float v4; // [esp+8h] [ebp-4h]
  float v5; // [esp+8h] [ebp-4h]

  v4 = a1[1] * a2[1] + *a1 * *a2 + a1[2] * a2[2];
  v5 = v4 / sqrt(a1[1] * a1[1] + *a1 * *a1 + a1[2] * a1[2]);
  x = v5 / sqrt(a2[1] * a2[1] + *a2 * *a2 + a2[2] * a2[2]);
  return acos(x) * flt_96144;
}
// 96144: using guessed type float flt_96144;

//----- (00053114) --------------------------------------------------------
float *__fastcall sub_53114(float *result, float *a2)
{
  float v2; // [esp+0h] [ebp-1Ch]
  float v3; // [esp+4h] [ebp-18h]
  float v4; // [esp+8h] [ebp-14h]

  v2 = *result;
  v3 = result[1];
  v4 = result[2];
  *result = v3 * a2[1] + *result * *a2 + v4 * a2[2];
  result[1] = v3 * a2[4] + v2 * a2[3] + v4 * a2[5];
  result[2] = v3 * a2[7] + v2 * a2[6] + v4 * a2[8];
  return result;
}

//----- (0005323C) --------------------------------------------------------
int __fastcall sub_5323C(int result, float a2)
{
  int v5; // edx
  double v6; // st7
  double x; // [esp+0h] [ebp-20h]
  float v8; // [esp+Ch] [ebp-14h]

  v5 = result;
  if ( (LODWORD(a2) & 0x7FFFFFFF) != 0 )
  {
    x = a2 * flt_96140;
    v8 = cos(x);
    v6 = sin(x);
    result = *(int *)(v5 + 4);
    *(float *)(v5 + 4) = *(float *)&result * v8 - *(float *)(v5 + 8) * v6;
    *(float *)(v5 + 8) = v6 * *(float *)&result + *(float *)(v5 + 8) * v8;
  }
  return result;
}
// 96140: using guessed type float flt_96140;

//----- (000532AC) --------------------------------------------------------
float *__fastcall sub_532AC(float *result, float a2)
{
  float *v5; // edx
  double v6; // st7
  double x; // [esp+0h] [ebp-20h]
  float v8; // [esp+8h] [ebp-18h]
  float v9; // [esp+Ch] [ebp-14h]

  v5 = result;
  if ( (LODWORD(a2) & 0x7FFFFFFF) != 0 )
  {
    x = a2 * flt_96140;
    v9 = cos(x);
    v6 = sin(x);
    result = *(float **)v5;
    v8 = *v5;
    *v5 = v5[2] * v6 + *v5 * v9;
    v5[2] = v5[2] * v9 - v6 * v8;
  }
  return result;
}
// 96140: using guessed type float flt_96140;

//----- (00053318) --------------------------------------------------------
float *__fastcall sub_53318(float *result, float a2)
{
  float *v5; // edx
  double v6; // st7
  double x; // [esp+0h] [ebp-20h]
  float v8; // [esp+8h] [ebp-18h]
  float v9; // [esp+Ch] [ebp-14h]

  v5 = result;
  if ( (LODWORD(a2) & 0x7FFFFFFF) != 0 )
  {
    x = a2 * flt_96140;
    v9 = cos(x);
    v6 = sin(x);
    result = *(float **)v5;
    v8 = *v5;
    *v5 = *v5 * v9 - v5[1] * v6;
    v5[1] = v6 * v8 + v5[1] * v9;
  }
  return result;
}
// 96140: using guessed type float flt_96140;

//----- (00053384) --------------------------------------------------------
float *__fastcall sub_53384(float *result, float *a2, float *a3)
{
  *a3 = a2[1] * result[1] + *a2 * *result + a2[2] * result[2] + a2[3];
  a3[1] = a2[5] * result[1] + a2[4] * *result + a2[6] * result[2] + a2[7];
  a3[2] = a2[9] * result[1] + a2[8] * *result + a2[0xA] * result[2] + a2[0xB];
  return result;
}

//----- (000533D4) --------------------------------------------------------
int __fastcall sub_533D4(float *a1, float a2, int a3, int a4, int a5, int a6)
{
  double v9; // st5
  double v10; // st7
  int result; // eax

  v9 = 1.0 / a1[2];
  v10 = a2 * a1[1] * v9 + dbl_92DD4;
  *(_WORD *)a5 = (int)(*a1 * a2 * v9 + dbl_92DD4);
  *(_WORD *)a6 = (int)v10;
  *(_WORD *)a5 += a3;
  result = a4;
  *(_WORD *)a6 += a4;
  return result;
}
// 92DD4: using guessed type double dbl_92DD4;

//----- (00053440) --------------------------------------------------------
int __fastcall sub_53440(float *a1)
{
  int v1; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // ett
  int v6; // edx
  int v7; // eax
  int v8; // ett
  int v9; // edx
  int v10; // eax
  int result; // eax
  int v12; // ett

  v1 = dword_96B88;
  if ( *a1 < 0.0 )
  {
    v3 = -dword_96B88;
    v4 = -dword_96B88;
  }
  else
  {
    v3 = dword_96B88;
    v4 = dword_96B88;
  }
  v5 = (int)((double)((v4 - (v3 >> 0x1F)) >> 1) + *a1);
  *a1 = (float)(dword_96B88 * (v5 / dword_96B88));
  if ( a1[1] < 0.0 )
  {
    v6 = -v1;
    v7 = -v1;
  }
  else
  {
    v6 = v1;
    v7 = v1;
  }
  v8 = (int)((double)((v7 - (v6 >> 0x1F)) >> 1) + a1[1]);
  a1[1] = (float)(v1 * (v8 / v1));
  if ( a1[2] < 0.0 )
  {
    v9 = -v1;
    v10 = -v1;
  }
  else
  {
    v9 = v1;
    v10 = v1;
  }
  v12 = (int)((double)((v10 - (v9 >> 0x1F)) >> 1) + a1[2]);
  result = v12 / v1;
  a1[2] = (float)(v1 * (v12 / v1));
  dword_96B88 = v1;
  return result;
}
// 96B88: using guessed type int dword_96B88;

//----- (0005353C) --------------------------------------------------------
void __fastcall sub_5353C(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_5323C((int)(a1 + 6), *(float *)&a5);
    sub_53644(a1, (int)a1, a5, a4);
  }
}

//----- (00053564) --------------------------------------------------------
void __fastcall sub_53564(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_532AC(a1 + 6, *(float *)&a5);
    sub_53754(a1, (int)a1, a5, a4);
  }
}

//----- (0005358C) --------------------------------------------------------
void __fastcall sub_5358C(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_53318(a1 + 3, *(float *)&a5);
    sub_53864(a1, (int)a1, a5, a4);
  }
}

//----- (000535B4) --------------------------------------------------------
void __fastcall sub_535B4(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_5323C((int)(a1 + 6), *(float *)&a5);
    sub_5323C((int)(a1 + 3), *(float *)&a5);
    sub_53864(a1, (int)a1, a5, a4);
  }
}

//----- (000535E4) --------------------------------------------------------
void __fastcall sub_535E4(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_532AC(a1 + 6, *(float *)&a5);
    sub_532AC(a1 + 3, *(float *)&a5);
    sub_53864(a1, (int)a1, a5, a4);
  }
}

//----- (00053644) --------------------------------------------------------
void __fastcall sub_53644(float *a1, int a2, int a3, int a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6
  float v9; // [esp+0h] [ebp-48h]
  float v10; // [esp+4h] [ebp-44h]
  float v11; // [esp+8h] [ebp-40h]
  float v12; // [esp+Ch] [ebp-3Ch] BYREF
  float v13; // [esp+10h] [ebp-38h]
  float v14; // [esp+14h] [ebp-34h]
  float v15; // [esp+18h] [ebp-30h]
  float v16; // [esp+1Ch] [ebp-2Ch]
  float v17; // [esp+20h] [ebp-28h]
  float v18; // [esp+24h] [ebp-24h] BYREF
  float v19; // [esp+28h] [ebp-20h]
  float v20; // [esp+2Ch] [ebp-1Ch]
  float *v21; // [esp+30h] [ebp-18h]
  float *v22; // [esp+34h] [ebp-14h]
  int v23; // [esp+40h] [ebp-8h]

  v23 = a4;
  sub_53000(a1);
  v21 = &v12;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v15 = a1[7] * a1[2] - a1[8] * a1[1];
  v16 = a1[8] * *a1 - a1[6] * a1[2];
  v5 = a1[6] * a1[1];
  v6 = a1[7] * *a1;
  v12 = v15;
  v17 = v5 - v6;
  v13 = v16;
  v14 = v17;
  a1[3] = v15;
  a1[4] = v13;
  a1[5] = v14;
  sub_53000(a1 + 3);
  v22 = &v18;
  v9 = a1[1] * a1[5] - a1[2] * a1[4];
  v10 = a1[2] * a1[3] - *a1 * a1[5];
  v7 = *a1 * a1[4];
  v8 = a1[1] * a1[3];
  v18 = v9;
  v11 = v7 - v8;
  v19 = v10;
  v20 = v11;
  a1[6] = v9;
  a1[7] = v19;
  a1[8] = v20;
  sub_53000(a1 + 6);
}

//----- (00053754) --------------------------------------------------------
void __fastcall sub_53754(float *a1, int a2, int a3, int a4)
{
  float *v5; // edx
  double v6; // st7
  double v7; // st6
  double v8; // st7
  double v9; // st6
  float v10; // [esp+0h] [ebp-48h]
  float v11; // [esp+4h] [ebp-44h]
  float v12; // [esp+8h] [ebp-40h]
  float v13; // [esp+Ch] [ebp-3Ch] BYREF
  float v14; // [esp+10h] [ebp-38h]
  float v15; // [esp+14h] [ebp-34h]
  float v16; // [esp+18h] [ebp-30h]
  float v17; // [esp+1Ch] [ebp-2Ch]
  float v18; // [esp+20h] [ebp-28h]
  float v19; // [esp+24h] [ebp-24h] BYREF
  float v20; // [esp+28h] [ebp-20h]
  float v21; // [esp+2Ch] [ebp-1Ch]
  float *v22; // [esp+30h] [ebp-18h]
  float *v23; // [esp+34h] [ebp-14h]
  int v24; // [esp+40h] [ebp-8h]

  v24 = a4;
  v5 = a1 + 3;
  sub_53000(a1 + 3);
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  v22 = &v13;
  v16 = v5[1] * a1[8] - v5[2] * a1[7];
  v17 = v5[2] * a1[6] - *v5 * a1[8];
  v6 = *v5 * a1[7];
  v7 = v5[1] * a1[6];
  v13 = v16;
  v18 = v6 - v7;
  v14 = v17;
  v15 = v18;
  *a1 = v16;
  a1[1] = v14;
  a1[2] = v15;
  sub_53000(a1);
  v23 = &v19;
  v10 = a1[1] * v5[2] - a1[2] * v5[1];
  v11 = a1[2] * *v5 - *a1 * v5[2];
  v8 = *a1 * v5[1];
  v9 = a1[1] * *v5;
  v19 = v10;
  v12 = v8 - v9;
  v20 = v11;
  v21 = v12;
  a1[6] = v10;
  a1[7] = v20;
  a1[8] = v21;
  sub_53000(a1 + 6);
}

//----- (00053864) --------------------------------------------------------
void __fastcall sub_53864(float *a1, int a2, int a3, int a4)
{
  float *v5; // edx
  float *v6; // ecx
  double v7; // st7
  double v8; // st6
  double v9; // st7
  double v10; // st6
  float v11; // [esp+0h] [ebp-48h]
  float v12; // [esp+4h] [ebp-44h]
  float v13; // [esp+8h] [ebp-40h]
  float v14; // [esp+Ch] [ebp-3Ch] BYREF
  float v15; // [esp+10h] [ebp-38h]
  float v16; // [esp+14h] [ebp-34h]
  float v17; // [esp+18h] [ebp-30h]
  float v18; // [esp+1Ch] [ebp-2Ch]
  float v19; // [esp+20h] [ebp-28h]
  float v20; // [esp+24h] [ebp-24h] BYREF
  float v21; // [esp+28h] [ebp-20h]
  float v22; // [esp+2Ch] [ebp-1Ch]
  float *v23; // [esp+30h] [ebp-18h]
  float *v24; // [esp+34h] [ebp-14h]
  int v25; // [esp+40h] [ebp-8h]

  v25 = a4;
  v5 = a1 + 6;
  v6 = a1 + 3;
  sub_53000(a1 + 6);
  v17 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v23 = &v14;
  v17 = v6[1] * v5[2] - v6[2] * v5[1];
  v18 = v6[2] * *v5 - *v6 * v5[2];
  v7 = *v6 * v5[1];
  v8 = v6[1] * *v5;
  v14 = v17;
  v19 = v7 - v8;
  v15 = v18;
  v16 = v19;
  *a1 = v17;
  a1[1] = v15;
  a1[2] = v16;
  sub_53000(a1);
  v24 = &v20;
  v11 = v5[1] * a1[2] - v5[2] * a1[1];
  v12 = v5[2] * *a1 - *v5 * a1[2];
  v9 = *v5 * a1[1];
  v10 = v5[1] * *a1;
  v20 = v11;
  v13 = v9 - v10;
  v21 = v12;
  v22 = v13;
  *v6 = v11;
  v6[1] = v21;
  v6[2] = v22;
  sub_53000(v6);
}

//----- (00053B08) --------------------------------------------------------
float *__fastcall sub_53B08(float *result, float *a2, float *a3, float *a4)
{
  *result = a3[1] * a2[1] + *a3 * *a2 + a3[2] * a2[2];
  result[1] = a3[4] * a2[1] + a3[3] * *a2 + a3[5] * a2[2];
  result[2] = a3[7] * a2[1] + a3[6] * *a2 + a3[8] * a2[2];
  result[4] = a3[1] * a2[4] + *a3 * a2[3] + a3[2] * a2[5];
  result[5] = a3[3] * a2[3] + a3[4] * a2[4] + a3[5] * a2[5];
  result[6] = a3[6] * a2[3] + a3[7] * a2[4] + a3[8] * a2[5];
  result[8] = a3[1] * a2[7] + *a3 * a2[6] + a3[2] * a2[8];
  result[9] = a3[3] * a2[6] + a3[4] * a2[7] + a3[5] * a2[8];
  result[0xA] = a3[6] * a2[6] + a3[7] * a2[7] + a3[8] * a2[8];
  result[3] = a4[1] * a2[1] + *a4 * *a2 + a4[2] * a2[2];
  result[7] = a4[1] * a2[4] + *a4 * a2[3] + a4[2] * a2[5];
  result[0xB] = a4[1] * a2[7] + *a4 * a2[6] + a4[2] * a2[8];
  return result;
}

//----- (00053D22) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int16 __usercall sub_53D22@<ax>(char _CF@<cf>, bool _ZF@<zf>, char _SF@<sf>, char _OF@<of>, int a5@<edx>, __int16 a6)
{
  unsigned int v6; // kr00_4
  __int16 result; // ax
  __int16 v8; // [esp-Ah] [ebp-16h]
  void *retaddr; // [esp+10h] [ebp+4h]

  v6 = __readeflags();
  _disable();
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  dword_53D1C = a5;
  word_53D0C = 0x100;
  word_53CEA = 0;
  word_53D06 = 0x4F01;
  word_53D02 = a6;
  word_53D0E = 0;
  __asm { pushfw }
  word_53D0A = v8;
  __asm
  {
    int     31h; DPMI Services   ax=func xxxxh
    int     31h; DPMI Services   ax=func xxxxh
  }
  result = 0;
  _ZF = (BYTE1(retaddr) & 2) == 0;
  _disable();
  if ( !_ZF )
  {
    _enable();
  }
  __writeeflags(v6);
  return result;
}
// 53D37: write access to const memory at 53D1C has been detected
// 53D3D: write access to const memory at 53D0C has been detected
// 53D43: write access to const memory at 53CEA has been detected
// 53D51: write access to const memory at 53D06 has been detected
// 53D5A: write access to const memory at 53D02 has been detected
// 53D60: write access to const memory at 53D0E has been detected
// 53D6D: write access to const memory at 53D0A has been detected
// 53D6D: variable 'v8' is possibly undefined
// 53CEA: using guessed type __int16 word_53CEA;
// 53D02: using guessed type __int16 word_53D02;
// 53D06: using guessed type __int16 word_53D06;
// 53D0A: using guessed type __int16 word_53D0A;
// 53D0C: using guessed type __int16 word_53D0C;
// 53D0E: using guessed type __int16 word_53D0E;
// 53D1C: using guessed type int dword_53D1C;

//----- (00053DC0) --------------------------------------------------------
int __fastcall sub_53DC0(int a1, int a2, int a3)
{
  int result; // eax

  _wcpp_2_mod_register_(&unk_96B8C);
  result = sub_54344((int)&V_Type3_stru_10AE70, 1, a3);
  dword_96B94 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96B94: using guessed type int dword_96B94;

//----- (00053DE4) --------------------------------------------------------
void sub_53DE4()
{
  ++dword_132B58;
}
// 132B58: using guessed type int dword_132B58;

//----- (00053DEC) --------------------------------------------------------
int Q_CheckFreeMemory_sub_53DEC()
{
  int v0; // edx
  int v1; // ecx
  unsigned int v2; // edi
  void *v3; // eax

  v0 = 0x2000000;
  v1 = 0;
  v2 = 0;
  do
  {
    v3 = malloc(v1 + v0);
    if ( v3 )
    {
      v1 += v0;
    }
    if ( v1 == 0x2000000 || v0 < 0x1000 )
    {
      v2 = 0xFFFFFFFF;
    }
    free(v3);
    v0 >>= 1;
  }
  while ( !v2 );
  return v1;
}

//----- (00053E38) --------------------------------------------------------
unsigned int __fastcall sub_53E38(P_Type5 a1, int a2, int a3, __int16 a4)
{
  int v5; // ebp

  if ( a4 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD0);
  }
  v5 = sub_1B084((unsigned int)&unk_12FC20, (unsigned __int16)word_FFEE0);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD5);
  }
  return sub_53EB8(a1, v5, *((unsigned __int8 *)&byte_A2F73 + 0x1EE * a4), a2, a3, a4);
}
// A3CF2: using guessed type int dword_A3CF2;
// FFEE0: using guessed type __int16 word_FFEE0;

//----- (00053EB8) --------------------------------------------------------
unsigned int __fastcall sub_53EB8(P_Type5 a1, int a2, int a3, int a4, int a5, __int16 a6)
{
  __int16 v9; // ax
  char v10; // dl
  int v11; // ecx

  v9 = 0;
  v10 = 4 * byte_A2F74[0x1EE * a6] + 0x13;
  while ( v9 < 4 )
  {
    v11 = 0x13 - v9++;
    *(_BYTE *)(v11 + *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3022]) = v10--;
  }
  sub_5D007(*(const void **)&V_Type3_stru_10AE70.z1[0x3022]);
  return sub_5D026(a1, a2, a3, a4, a5);
}

//----- (00053F40) --------------------------------------------------------
unsigned int __fastcall sub_53F40(T_Type5 *a1, int a2, int a3, int a4, int a5, char a6)
{
  __int16 v8; // ax
  char v9; // dl
  int v10; // ecx

  v8 = 0;
  v9 = 4 * a6 + 0x13;
  while ( v8 < 4 )
  {
    v10 = 0x13 - v8++;
    *(_BYTE *)(v10 + *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3022]) = v9--;
  }
  sub_5D007(*(const void **)&V_Type3_stru_10AE70.z1[0x3022]);
  return sub_5D026(a1, a2, a3, a4, a5);
}

//----- (00053FB0) --------------------------------------------------------
T_Type1 *__fastcall sub_53FB0(const char *a1, int a2, int a3, int a4)
{
  char *sub_1CEA8; // eax
  T_Type1 *result; // eax
  T_Type1 v6; // [esp-118h] [ebp-198h] BYREF
  char v7[120]; // [esp+0h] [ebp-80h] BYREF
  int v8; // [esp+78h] [ebp-8h]

  v8 = a4;
  Q_InitFileInfo_sub_1BB78(&v6);
  if ( Q_CfilePreload_sub_1BBFC(&v6, a1, 0x200, 0) )
  {
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAA);
    sub_556CC((int)&V_Type3_stru_10AE70, (int)sub_1CEA8);
  }
  else
  {
    sub_1BF94(&v6, v7, 0x74u);
    sub_21AA0((int)&dword_A2F6C, (unsigned int)&v6);
    sub_56BE8((int)&V_Type3_stru_10AE70, 0xD, 0, 0, 0);
    sub_5A294(&V_Type3_stru_10AE70);
  }
  result = &v6;
  Q_CloseFileAndDelete_sub_1BBC8(&v6);
  return result;
}
// 54033: returning address of temporary local variable '%0x4'
// A2F6C: using guessed type int dword_A2F6C;
// 53FB0: using guessed type char var_80[120];

//----- (00054048) --------------------------------------------------------
void __fastcall sub_54048(const char *a1, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  int v12; // ebx
  char *sub_1CEA8; // eax
  T_Type1 v14; // [esp-118h] [ebp-198h] BYREF
  int v15[2]; // [esp+0h] [ebp-80h] BYREF
  int v16[30]; // [esp+8h] [ebp-78h]

  v16[0x1C] = a4;
  v16[0x1B] = a2;
  Q_InitFileInfo_sub_1BB78(&v14);
  if ( sub_1BCA8(&v14, a1) )
  {
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAA);
    sub_556CC((int)&V_Type3_stru_10AE70, (int)sub_1CEA8);
    Q_CloseFileAndDelete_sub_1BBC8(&v14);
  }
  else
  {
    v15[0] = dword_A2F6C[0];
    v15[1] = SHIWORD(dword_A3CF2);
    v4 = 0;
    v5 = 0;
    v16[0] = (unsigned __int8)byte_104BEA;
    v6 = 0;
    while ( v4 < SHIWORD(dword_A3CF2) )
    {
      v6 += 0x1EE;
      ++v5;
      ++v4;
      v16[v5] = (unsigned __int8)V_StaticStrings_dword_A0D04.buffer[v6 + 0x1D61];
    }
    v7 = 0;
    v8 = 0;
    v9 = 0;
    while ( v7 < SHIWORD(dword_A3CF2) )
    {
      v9 += 0x1EE;
      ++v8;
      ++v7;
      v16[v8 + 7] = (unsigned __int8)V_StaticStrings_dword_A0D04.buffer[v9 + 0x1D62];
    }
    v10 = 0;
    v11 = 0;
    while ( v10 < SHIWORD(dword_A3CF2) )
    {
      v12 = *(_DWORD *)((char *)&unk_A312F + 0x1EE * (unsigned __int8)byte_104BEA + v10);
      ++v11;
      ++v10;
      v16[v11 + 0xE] = v12 >> 0x18;
    }
    v16[0x16] = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], 0, 0);
    v16[0x17] = sub_402E0(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
    v16[0x18] = sub_40664(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
    sub_1C098((unsigned int)&v14, (int)v15, 0x74u);
    sub_21374((int)dword_A2F6C, (unsigned int)&v14);
    sub_5A294(&V_Type3_stru_10AE70);
    Q_CloseFileAndDelete_sub_1BBC8(&v14);
  }
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3CF2: using guessed type int dword_A3CF2;

//----- (00054208) --------------------------------------------------------
unsigned int __fastcall sub_54208(int a1, int a2, int a3, int a4)
{
  unsigned int result; // eax
  char *v5; // [esp+0h] [ebp-3Ch] BYREF
  int v6; // [esp+4h] [ebp-38h]
  int v7; // [esp+8h] [ebp-34h]
  int v8; // [esp+Ch] [ebp-30h]
  int v9; // [esp+10h] [ebp-2Ch]
  int v10[10]; // [esp+14h] [ebp-28h] BYREF

  v10[8] = a4;
  v5 = byte_D8DA0;
  v6 = *(_DWORD *)(a1 + 0xC) - *(_DWORD *)(a1 + 4);
  v7 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
  v8 = 0;
  v9 = 0;
  if ( v7 * v6 >= (int)&loc_27100 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x13E);
  }
  v10[3] = v6;
  v10[4] = v7;
  v10[0] = (int)&v5;
  v10[1] = 0;
  v10[2] = 0;
  result = sub_5EAAF((int **)a1, 0, 0, v10, 0, 0, 0xFFFFFFFF);
  if ( result )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x147);
  }
  return result;
}

//----- (000542B0) --------------------------------------------------------
unsigned int __fastcall sub_542B0(_DWORD *a1, int a2, int a3, int *a4)
{
  char *v5; // [esp+0h] [ebp-3Ch] BYREF
  int *v6; // [esp+4h] [ebp-38h]
  int *v7; // [esp+8h] [ebp-34h]
  int v8; // [esp+Ch] [ebp-30h]
  int v9; // [esp+10h] [ebp-2Ch]
  int *v10[10]; // [esp+14h] [ebp-28h] BYREF

  v10[8] = a4;
  v5 = byte_D8DA0;
  v6 = (int *)(a1[3] - a1[1]);
  v7 = (int *)(a1[4] - a1[2]);
  v8 = 0;
  v9 = 0;
  if ( (int)v7 * (int)v6 >= (int)&loc_27100 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x158);
  }
  v10[3] = v6;
  v10[4] = v7;
  v10[0] = (int *)&v5;
  v10[1] = 0;
  v10[2] = 0;
  return sub_5EAAF(v10, 0, 0, a1, 0, 0, 0xFFFFFFFF);
}

//----- (00054344) --------------------------------------------------------
int __fastcall sub_54344(int a1, int a2, int a3)
{
  _DWORD *v4; // eax
  int v5; // edx

  v4 = (_DWORD *)(a1 + 0x3026);
  sub_2B2C0(v4);
  v4 += 8;
  sub_2B2C0(v4);
  v5 = sub_1ACC0((int)v4 + 0x21D6A, a1, a3) - 0x24DB0;
  sub_54448(v5);
  return v5;
}

//----- (00054374) --------------------------------------------------------
char *__fastcall sub_54374(int a1)
{
  __int16 i; // cx
  int v3; // eax
  int v4; // eax
  __int16 j; // dx
  int v6; // eax
  int v7; // edx
  T_Type3 *v8; // eax
  int v9; // eax
  void **v10; // eax

  for ( i = 0; i < 0x400; ++i )
  {
    v3 = a1 + 0xC * i;
    if ( *(_DWORD *)(v3 + 4) )
    {
      sub_2627C(*(void **)(v3 + 4));
    }
    v4 = *(_DWORD *)(a1 + 0xC * i + 4);
    if ( v4 )
    {
      (**(void (***)(void))(v4 + 0xA7))();
    }
  }
  for ( j = 0; j < 6; ++j )
  {
    v6 = a1 + 4 * j;
    if ( *(_DWORD *)(v6 + 0x300E) )
    {
      sub_2627C(*(void **)(v6 + 0x300E));
    }
    operator delete[](*(void **)(a1 + 4 * j + 0x300E));
  }
  if ( *(_DWORD *)(a1 + 0x48A6) == 0xFFFFFFFF )
  {
    v7 = 0xFFFFFFFF;
    v8 = (T_Type3 *)a1;
LABEL_17:
    sub_59934(v8, v7, a1);
    goto LABEL_18;
  }
  if ( *(_DWORD *)(a1 + 0x48AA) == 0xFFFFFFFF )
  {
    v8 = (T_Type3 *)a1;
    v7 = 0;
    goto LABEL_17;
  }
LABEL_18:
  sub_54664(a1);
  v9 = sub_1ACF4(a1 + 0x24DB0);
  v10 = sub_2B2E0((void **)(v9 - 0x21D6A));
  return (char *)sub_2B2E0(v10 + 0xFFFFFFF8) + 0xFFFFCFDA;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (00054448) --------------------------------------------------------
void *__fastcall sub_54448(int a1)
{
  int v2; // eax
  __int16 i; // ax
  int v4; // edx

  v2 = a1 + 0x3066;
  *(_WORD *)(v2 + 0x11C0) = 0;
  *(_WORD *)(v2 - 0x66) = 0;
  *(_WORD *)(v2 + 0x11C2) = 0xFFFF;
  *(_WORD *)(v2 + 0x16F0) = 0;
  *(_WORD *)(v2 + 0x16F2) = 0;
  *(_WORD *)(v2 + 0x1446) = 0;
  *(_WORD *)(v2 + 0x15A8) = 0;
  *(_WORD *)(v2 + 0x16CA) = 0;
  *(_DWORD *)(v2 - 0x64) = 0xFFFFFFFF;
  *(_DWORD *)(v2 + 0x16CC) = 0xFFFFFFFF;
  *(_WORD *)(v2 + 0x16F4) = 0;
  *(_WORD *)(v2 + 0x16F6) = 0;
  *(_DWORD *)((char *)&loc_21D46 + v2) = 0x3F800000;
  dword_132B58 = 0;
  memset((void *)v2, 0, 0x11C0u);
  memset((void *)a1, 0, 0x3000u);
  memset((void *)(a1 + 0x44AE), 0, 0x160u);
  memset((void *)(a1 + 0x4610), 0, 0x120u);
  memset((void *)(a1 + 0x300E), 0, 0x18u);
  memset((void *)(a1 + 0x4736), 0xFFFFFFFF, 0x20u);
  for ( i = 0; i < 0x20; ++i )
  {
    v4 = 0x8E * i;
    *(_WORD *)(a1 + v4 + 0x3066) = 0xFFFF;
    *(_WORD *)(a1 + v4 + 0x30EA) = 0xFFFF;
  }
  *(_DWORD *)(a1 + 0x489E) = 0;
  *(_DWORD *)(a1 + 0x48A2) = 0;
  *(_DWORD *)(a1 + 0x24D9C) = 0;
  *(_DWORD *)(a1 + 0x24DA0) = 0;
  *(_DWORD *)((char *)&loc_24DA4 + a1) = 0;
  *(_DWORD *)(a1 + 0x24DA8) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x48A6) = 0;
  *(_DWORD *)(a1 + 0x48AA) = 0;
  *(_DWORD *)(a1 + 0x48AE) = 0;
  memset((void *)(a1 + 0x21D82), 0x10, 0);
  *(_DWORD *)(a1 + 0x21D82) = 0x3C;
  *(_WORD *)(a1 + 0x24D96) = 0;
  return memset((char *)&loc_21D96 + a1, 0, 0x3000u);
}
// 132B58: using guessed type int dword_132B58;

//----- (000545EC) --------------------------------------------------------
unsigned int __fastcall sub_545EC(P_Type3 a1)
{
  int v2; // ebx
  HTIMER v3; // eax
  HTIMER v4; // edi

  v2 = *(_DWORD *)&a1->z2[0x122];
  dword_132B58 = 0;
  if ( v2 == 0xFFFFFFFF )
  {
    v3 = AIL_register_timer(sub_53DE4);
    *(_DWORD *)&a1->z2[0x122] = v3;
    if ( v3 == 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x1E5);
    }
    v4 = *(_DWORD *)&a1->z2[0x122];
    if ( v4 == 0xFFFFFFFF )
    {
      return 0;
    }
    AIL_set_timer_frequency(v4, 0x64u);
    AIL_start_timer(*(_DWORD *)&a1->z2[0x122]);
  }
  return 0xFFFFFFFF;
}
// 132B58: using guessed type int dword_132B58;

//----- (00054664) --------------------------------------------------------
void __fastcall sub_54664(int a1)
{
  if ( *(_DWORD *)(a1 + 0x4732) != 0xFFFFFFFF )
  {
    AIL_stop_timer(*(_DWORD *)(a1 + 0x4732));
    AIL_release_timer_handle(*(_DWORD *)(a1 + 0x4732));
    *(_DWORD *)(a1 + 0x4732) = 0xFFFFFFFF;
  }
}

//----- (0005469C) --------------------------------------------------------
int __fastcall sub_5469C(P_Type3 a1, int a2, int a3, int a4)
{
  int v5; // edi
  unsigned int v6; // eax
  _DWORD *v7; // ecx
  int v8; // eax
  unsigned int v9; // eax
  int v10; // ebx
  __int16 v11; // ax
  int v12; // eax
  int aaa; // edx
  int v14; // eax
  unsigned int v15; // esi
  int v16; // ebx
  char v17; // dl
  int result; // eax
  int v19; // [esp-4h] [ebp-30h]
  char s[44]; // [esp+0h] [ebp-2Ch] BYREF

  if ( a1->aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    ++*(_DWORD *)&a1->z3[8];
  }
  v5 = ::a3;
  *(_DWORD *)&a1->z3[4] = 0xFFFFFFFF;
  if ( !v5 || *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) || *(_DWORD *)&a1->z2[0x28E] )
  {
    if ( *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) )
    {
      a3 = ::a3;
      if ( !::a3 )
      {
        a2 = 0;
        *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) = ::a3;
        Q_GSYSTEM_CPP_sub_2C7D0(&V_Type6_stru_D8654, 0, a3);
        a4 = *(_DWORD *)&a1->z1[0x3002];
        if ( a4 != 0xFFFFFFFF )
        {
          sub_56D30((int)a1, a4, 6, 0, 0);
          a3 = 7;
          a2 = *(_DWORD *)&a1->z1[0x3002];
          a4 = 0;
          sub_56D30((int)a1, a2, 7, 0, 0);
        }
      }
    }
  }
  else
  {
    a2 = 1;
    a3 = 0;
    *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) = 0xFFFFFFFF;
    Q_GSYSTEM_CPP_sub_2C7D0(&V_Type6_stru_D8654, 1, 0);
  }
  v6 = 0xFFFFFFFF;
  if ( !*(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) && !*(_DWORD *)&a1->z2[0x28E] )
  {
    a2 = *(__int16 *)&a1->z1[0x4228];
    if ( *(_WORD *)&a1->z1[0x4228] )
    {
      a2 = dword_D864C;
      if ( dword_D864C )
      {
        if ( dword_D864C == 0x1DF )
        {
          a4 = dword_D8648;
          if ( dword_D8648 )
          {
            if ( dword_D8648 == 0x27F )
            {
              v6 = 3;
            }
          }
          else
          {
            v6 = 2;
          }
        }
      }
      else if ( dword_D8648 )
      {
        if ( dword_D8648 == 0x27F )
        {
          v6 = 1;
        }
      }
      else
      {
        v6 = 0;
      }
    }
  }
  if ( v6 != *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] )
  {
    a2 = 0;
    *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] = v6;
    if ( v6 != 0xFFFFFFFF )
    {
      a2 = v6 + 4;
    }
    a4 = 0;
    a3 = 0;
    sub_5A270(a1, a2, 0, 0);
  }
  if ( dword_D8644 == 0xFFFFFFFF )
  {
    if ( dword_D8644 == a1->aaa && *(_DWORD *)&a1->z3[4] )
    {
      a4 = 0;
      a2 = 0;
      a3 = 1;
      sub_59C80(a1, 0, 1, 0, dword_D8648, dword_D864C, 0);
      *(_DWORD *)&a1->z3[4] = 0;
    }
    sub_5691C((int)a1);
  }
  if ( !*(_DWORD *)&a1->z2[0x28E] )
  {
    if ( *(_WORD *)&a1->z2[0x120] )
    {
      sub_56824((int)a1);
    }
    if ( a1->counter1 )
    {
      sub_56694((int)a1);
    }
  }
  if ( dword_D85FC == 0xFFFFFFFF )
  {
    if ( dword_D85FC == a1->aaa && (!dword_D8600 || word_D8620 != 0x13 && word_D8620 != 0x19) )
    {
      a3 = 3;
      a4 = SHIWORD(dword_D8622);
      a2 = 0;
      sub_59C80(
        a1,
        0,
        3,
        SHIWORD(dword_D8622),
        (unsigned __int16)word_D8620,
        (unsigned __int16)dword_D8622,
        dword_D8600);
    }
    if ( a1->bbb == 0xFFFFFFFF && dword_D8604 && word_D8620 == 0x19 )
    {
      v19 = dword_132B1C;
      a1->bbb = 0;
      sprintf(s, "info%02d", v19);
      v7 = (_DWORD *)sub_56DA8((int)a1, "HELPWINDOW", 0);
      sub_2FCB0(v7, byte_132B20, s);
      a2 = (int)v7;
      a3 = 0;
      sub_552F8((int)a1);
      dword_D8600 = 0;
      dword_132B14 = dword_D862C;
      v8 = dword_D8630;
      a1->bbb = 0xFFFFFFFF;
      dword_132B18 = v8;
      a4 = 0;
      word_D8620 = 0;
      ++dword_132B1C;
    }
    v9 = 0xFFFFFFFF;
    if ( dword_D8600 == 0xFFFFFFFF || (a2 = (unsigned __int16)word_D8620, word_D8620 == 1) )
    {
      v9 = sub_54D64((int)a1, a2, a3);
    }
    if ( v9 == 0xFFFFFFFF )
    {
      a4 = (unsigned __int16)word_D8620;
      sub_56BE8((int)a1, 3, (unsigned __int16)dword_D8622, (unsigned __int16)word_D8620, 0);
    }
  }
  v10 = dword_D8638;
  if ( dword_D8638 == 0xFFFFFFFF )
  {
    if ( dword_D8638 == a1->aaa && !dword_D8600 )
    {
      v11 = 0;
      if ( dword_D862C && ::a3 )
      {
        v11 = 1;
      }
      a4 = v11;
      v10 = 2;
      sub_59C80(a1, 0, 2, v11, 0, dword_D862C, 0);
    }
    if ( dword_D862C )
    {
      if ( *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] == 0xFFFFFFFF )
      {
        if ( dword_D8600 == 0xFFFFFFFF )
        {
          v10 = dword_D864C;
          a4 = dword_D8648;
          dword_132B10 = sub_5BF2B((int **)&V_Type6_stru_D8654.pane, dword_D8648, dword_D864C);
          v12 = *(_DWORD *)&a1->z1[(_DWORD)&loc_21D90 + 2];
          if ( *(_DWORD *)(v12 + 0x39) )
          {
            a4 = 0;
            v10 = 0;
            (*(void (**)(void))(*(_DWORD *)(v12 + 0xA7) + 8))();
          }
        }
        else if ( *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) != 0xFFFFFFFF || *(_DWORD *)&a1->z2[0x28E] )
        {
          a4 = dword_D864C;
          v10 = dword_D8648;
          sub_56BE8((int)a1, 4, dword_D8648, dword_D864C, 0);
        }
        else
        {
          a4 = dword_D864C;
          v10 = dword_D8648;
          sub_56BE8((int)a1, 0xC, dword_D8648, dword_D864C, 0);
        }
      }
      else if ( *(_DWORD *)&a1->z2[0x28E] )
      {
        *(_DWORD *)&a1->z2[0x28E] = 0;
        *(_DWORD *)&a1->z2[0x292] = 0xFFFFFFFF;
      }
      else
      {
        sub_4FB90((int)&unk_10914C, 0);
        a4 = 0;
        v10 = 0;
        sub_5A270(a1, 0, 0, 0);
        *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] = 0xFFFFFFFF;
        sub_570AC((int)a1, 0xFFFFFFFF);
      }
    }
  }
  if ( dword_D863C == 0xFFFFFFFF )
  {
    aaa = a1->aaa;
    if ( aaa == dword_D863C )
    {
      a4 = 0;
      aaa ^= dword_D863C;
      v10 = 2;
      sub_59C80(a1, aaa, 2, 0, 1, dword_D8630, 0);
    }
    if ( dword_D8630 )
    {
      if ( *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) == 0xFFFFFFFF )
      {
        *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) = 0;
        sub_2C744(&V_Type6_stru_D8654, aaa, v10, a4);
      }
      else
      {
        sub_56BE8((int)a1, 5, dword_D8648, dword_D864C, 0);
      }
    }
  }
  while ( *(__int16 *)&a1->z1[0x44AC] > 0 )
  {
    sub_55E80((int)a1);
  }
  if ( *(_WORD *)&a1->z2[0x14A] && *(_WORD *)&a1->z1[0x4228] == 1 && !*(_DWORD *)&a1->z2[0x28E] )
  {
    sub_55B74((int)a1);
  }
  if ( *(_DWORD *)&a1->z1[(_DWORD)&loc_24D9B + 1] == 0xFFFFFFFF
    && !*(_WORD *)&a1->z2[0x14A]
    && !*(_DWORD *)&a1->z2[0x28E] )
  {
    sub_56B60((int)a1, 7, 0, 0);
  }
  if ( dword_10936F == 0xFFFFFFFF && !dword_109377 )
  {
    if ( !dword_109373 )
    {
      v14 = *(__int16 *)&a1->z1[0x4228];
      if ( v14 != 7 && v14 != 0xD && v14 != 6 )
      {
        LOWORD(v15) = 0xFFFF;
        v16 = 0;
        if ( word_96BB0 != 0xFFFFFFFF && dword_1094DE[7 * word_96BB0] )
        {
          v16 = 0xFFFFFFFF;
          LOWORD(v15) = word_96BB0;
          dword_96BB4 = dword_109377;
        }
        if ( (__int16)v15 == 0xFFFFFFFF )
        {
          if ( word_96BB0 == 0xFFFFFFFF )
          {
            LOWORD(v15) = 0;
          }
          else
          {
            v15 = (dword_D8648 + dword_132B58) % 5u;
            if ( (_WORD)v15 == word_96BB0 )
            {
              v15 = (word_96BB0 + 1) % 5;
            }
          }
        }
        sub_4F8CC((int)&unk_10914C, v15, v16);
        word_96BB0 = v15;
      }
    }
    if ( dword_96BB4 != 0xFFFFFFFF )
    {
      v17 = dword_96BB4++;
      sub_4FF4C((int)&unk_10914C, v17);
      if ( dword_96BB4 == 0x64 )
      {
        dword_96BB4 = 0xFFFFFFFF;
      }
    }
  }
  do
  {
    if ( dword_10936F == 0xFFFFFFFF && dword_10936F == dword_109373 )
    {
      if ( dword_109373 == dword_109377 )
      {
        sub_4FA1C((int)&unk_10914C);
      }
      else
      {
        sub_4FAB4((int)&unk_10914C);
      }
    }
  }
  while ( (unsigned int)(dword_132B58 - dword_132B34) < 3 );
  result = dword_132B58;
  dword_132B34 = dword_132B58;
  return result;
}
// 96BB0: using guessed type __int16 word_96BB0;
// 96BB4: using guessed type int dword_96BB4;
// D85FC: using guessed type int dword_D85FC;
// D8600: using guessed type int dword_D8600;
// D8604: using guessed type int dword_D8604;
// D8620: using guessed type __int16 word_D8620;
// D8622: using guessed type int dword_D8622;
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;
// 10936F: using guessed type int dword_10936F;
// 109373: using guessed type int dword_109373;
// 109377: using guessed type int dword_109377;
// 1094DE: using guessed type int dword_1094DE[218];
// 132B10: using guessed type int dword_132B10;
// 132B14: using guessed type int dword_132B14;
// 132B18: using guessed type int dword_132B18;
// 132B1C: using guessed type int dword_132B1C;
// 132B34: using guessed type int dword_132B34;
// 132B58: using guessed type int dword_132B58;

//----- (00054D64) --------------------------------------------------------
unsigned int __fastcall sub_54D64(int a1, int a2, int a3)
{
  if ( (unsigned __int16)word_D8620 >= 0x20u )
  {
    if ( (unsigned __int16)word_D8620 <= 0x20u )
    {
      if ( dword_A0CFC == 0xFFFFFFFF )
      {
        dword_132B5C = ~dword_132B5C;
      }
    }
    else
    {
      if ( (unsigned __int16)word_D8620 >= 0x26u )
      {
        if ( (unsigned __int16)word_D8620 <= 0x26u )
        {
          if ( !*(_DWORD *)(a1 + 0x489E) && *(_WORD *)(a1 + 0x4228) != 8 )
          {
            sub_56E9C((P_Type3)a1, 4, 0xFFFFFFFF);
            return 0;
          }
        }
        else
        {
          if ( (unsigned __int16)word_D8620 >= 0x31u )
          {
            if ( (unsigned __int16)word_D8620 <= 0x31u )
            {
              dword_10935F = ~dword_10935F;
              return 0;
            }
            if ( word_D8620 == 0x32 )
            {
              dword_109377 = ~dword_109377;
              return 0;
            }
            return 0xFFFFFFFF;
          }
          if ( word_D8620 != 0x2D )
          {
            return 0xFFFFFFFF;
          }
          if ( !*(_DWORD *)(a1 + 0x489E) )
          {
            dword_96774 = 0;
            return 0;
          }
        }
        return 0;
      }
      if ( (unsigned __int16)word_D8620 > 0x21u )
      {
        if ( word_D8620 != 0x22 )
        {
          return 0xFFFFFFFF;
        }
        sub_1B4D0((char *)&loc_24DAD + a1 + 3);
        sub_31C18(*(_DWORD *)((char *)&loc_27C93 + a1 + 1), *(_DWORD *)((char *)&loc_27C93 + a1 + 5));
        sub_1ACE8((int)&loc_24DAD + a1 + 3);
        return 0;
      }
      if ( dword_A0CFC == 0xFFFFFFFF )
      {
        if ( dword_A0CFC == *(_DWORD *)((char *)&loc_24D98 + a1) )
        {
          *(_DWORD *)((char *)&loc_24D98 + a1) = 0;
        }
        else
        {
          *(_DWORD *)((char *)&loc_24D98 + a1) = dword_A0CFC;
        }
        return 0;
      }
    }
    return 0;
  }
  if ( (unsigned __int16)word_D8620 < 0x12u )
  {
    if ( word_D8620 )
    {
      if ( (unsigned __int16)word_D8620 > 1u )
      {
        if ( word_D8620 != 0x11 )
        {
          return 0xFFFFFFFF;
        }
        if ( dword_A0CFC == 0xFFFFFFFF )
        {
          sub_552F8(a1);
          return 0;
        }
        return 0;
      }
      if ( *(_DWORD *)(a1 + 0x489E) )
      {
        *(_DWORD *)(a1 + 0x489E) = 0;
        *(_DWORD *)(a1 + 0x48A2) = 0;
        return 0;
      }
      if ( *(_WORD *)(a1 + 0x4228) != 0x11 )
      {
        sub_570AC(a1, 0xFFFFFFFF);
        return 0;
      }
    }
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)word_D8620 <= 0x12u )
  {
    if ( dword_A0CFC == 0xFFFFFFFF )
    {
      *(_DWORD *)((char *)&loc_24D9E + a1 + 2) = ~*(_DWORD *)((char *)&loc_24D9E + a1 + 2);
      return 0;
    }
    return 0;
  }
  if ( (unsigned __int16)word_D8620 < 0x19u )
  {
    if ( word_D8620 != 0x13 )
    {
      return 0xFFFFFFFF;
    }
    if ( *(_DWORD *)(a1 + 0x48AA) || dword_A0CFC != 0xFFFFFFFF )
    {
      return 0;
    }
    if ( *(_DWORD *)(a1 + 0x48A6) )
    {
      sub_59934((T_Type3 *)a1, dword_A0CFC, dword_A0CFC);
    }
    else
    {
      srand(0);
      *(_DWORD *)((char *)&loc_24DAA + a1 + 2) = 0x3F800000;
      sub_59908(a1);
    }
    return 0;
  }
  else
  {
    if ( (unsigned __int16)word_D8620 > 0x19u )
    {
      if ( word_D8620 != 0x1F )
      {
        return 0xFFFFFFFF;
      }
      if ( !*(_DWORD *)(a1 + 0x489E) && *(_WORD *)(a1 + 0x4228) != 8 )
      {
        sub_56E9C((P_Type3)a1, 2, 0xFFFFFFFF);
      }
      return 0;
    }
    if ( *(_DWORD *)(a1 + 0x48A6) || dword_A0CFC != 0xFFFFFFFF )
    {
      return 0;
    }
    if ( *(_DWORD *)(a1 + 0x48AA) )
    {
      sub_59934((T_Type3 *)a1, 0, a3);
    }
    else
    {
      sub_59988((P_Type3)a1, "WINEVENT.BIN", 0);
    }
    return 0;
  }
}
// 96774: using guessed type int dword_96774;
// A0CFC: using guessed type int dword_A0CFC;
// D8620: using guessed type __int16 word_D8620;
// 10935F: using guessed type int dword_10935F;
// 109377: using guessed type int dword_109377;
// 132B5C: using guessed type int dword_132B5C;

//----- (0005508C) --------------------------------------------------------
unsigned int __fastcall sub_5508C(P_Type3 a1)
{
  int v1; // esi
  unsigned int v2; // ebx
  int v3; // ebx
  unsigned int result; // eax
  char s[40]; // [esp+0h] [ebp-2Ch] BYREF
  P_Type3 v6; // [esp+28h] [ebp-4h]

  v6 = a1;
  if ( *(_DWORD *)((char *)&loc_24D98 + (_DWORD)a1) == 0xFFFFFFFF )
  {
    if ( ++dword_10AE60 == 0xA )
    {
      v1 = dword_10AE68;
      dword_10AE64 = dword_132B58;
      dword_10AE68 = dword_132B58;
      v2 = dword_132B58 - v1;
      dword_10AE60 = 0;
      if ( dword_132B58 == v1 )
      {
        v2 = 1;
      }
      sprintf("FPS DUDE", "FPS %lu  %lu", 0x3E8 / v2, v2);
    }
    sub_2B3E0(&V_Type3_stru_10AE70.z1[0x3046], 0x19, 0xA, 0x96, 0x1E);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, "FPS DUDE", 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
  }
  if ( dword_132B5C )
  {
    v3 = 0;
    if ( dword_D864C < 0xF0 )
    {
      v3 = 0x1CC;
    }
    sprintf(s, "(%d,%d)", dword_D8648, dword_D864C);
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v3, s, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
  }
  if ( dword_D8628 == 1 )
  {
    sub_65E2B(*(_DWORD **)&v6->z1[0x3006]);
  }
  else
  {
    sub_5BA38(*(_DWORD **)&v6->z1[0x3006]);
  }
  result = sub_5B71C(*(_DWORD *)&v6->z1[0x3006]);
  if ( dword_132B60 == 0xFFFFFFFF )
  {
    result = sub_2C5E4((int)&V_Type6_stru_D8654, dword_132B64);
    if ( ++dword_132B64 > 0x40 )
    {
      dword_132B64 = 0;
      dword_132B60 = 0;
    }
  }
  return result;
}
// D8628: using guessed type int dword_D8628;
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;
// 10AE60: using guessed type int dword_10AE60;
// 10AE64: using guessed type int dword_10AE64;
// 10AE68: using guessed type int dword_10AE68;
// 132B58: using guessed type int dword_132B58;
// 132B5C: using guessed type int dword_132B5C;
// 132B60: using guessed type int dword_132B60;
// 132B64: using guessed type int dword_132B64;

//----- (00055214) --------------------------------------------------------
void __fastcall sub_55214(int eax0, int a2, int a3, int a4, int a5)
{
  T_Type5 v5; // [esp+0h] [ebp-24h] BYREF
  P_Type3 a1; // [esp+14h] [ebp-10h]

  a1 = (P_Type3)eax0;
  v5.rect.x1 = a2;
  v5.rect.y2 = a5;
  v5.rect.y1 = a3;
  v5.rect.x2 = a4;
  v5.a = *(P_Type6 *)(eax0 + 0x300A);
  sub_5E9D0(&v5, 0);
  sub_55274(a1, a2, a3, a4, a5);
}

//----- (00055274) --------------------------------------------------------
void __fastcall sub_55274(P_Type3 a1, int x1, int y1, int x2, int y2)
{
  if ( sub_5B7C2(*(_DWORD **)&a1->z1[0x3006], *(_DWORD *)&a1->z1[0x300A], x1, y1, x2, y2) == 0xFFFFFFFF )
  {
    sub_5B71C(*(_DWORD *)&a1->z1[0x3006]);
    sub_5B7C2(*(_DWORD **)&a1->z1[0x3006], *(_DWORD *)&a1->z1[0x300A], 0, 0, 639, 479);
  }
}

//----- (000552CC) --------------------------------------------------------
void __fastcall sub_552CC(P_Type3 a1, P_Type5 a2)
{
  if ( a2 )
  {
    sub_55274(a1, a2->rect.x1, a2->rect.y1, a2->rect.x2, a2->rect.y2);
  }
  else
  {
    sub_55274(a1, 0, 0, 639, 479);
  }
}

//----- (000552F8) --------------------------------------------------------
int __fastcall sub_552F8(unsigned int a1, int a2, int a3)
{
  int v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // ecx
  __int16 v8; // di
  __int16 i; // cx
  __int16 j; // si
  int v11; // edx
  int *v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // edi
  int result; // eax
  _DWORD v17[5]; // [esp+0h] [ebp-30h] BYREF
  int v18; // [esp+14h] [ebp-1Ch]
  int *v19; // [esp+18h] [ebp-18h]
  int v20; // [esp+1Ch] [ebp-14h]

  v20 = a2;
  v19 = (int *)a3;
  if ( *(_DWORD *)(a1 + 0x489E) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x4CC);
  }
  v4 = dword_A0D00;
  v18 = *(_DWORD *)((char *)&loc_24D9B + a1 + 1);
  *(_DWORD *)((char *)&loc_24D9B + a1 + 1) = 0;
  if ( !v4 )
  {
    v5 = sub_56DA8(a1, "NEXTTURNCONT", 0);
    v6 = *(_DWORD *)(v5 + 0xA7);
    *(_DWORD *)(v5 + 0xAB) = 0;
    (*(void (**)(void))(v6 + 0xC))();
  }
  v7 = *(_DWORD *)(a1 + 0x3002);
  if ( v7 != 0xFFFFFFFF )
  {
    sub_56D30(a1, v7, 6, 0, 0);
  }
  *(_DWORD *)(a1 + 0x3002) = 0xFFFFFFFF;
  memset(byte_132B38, 1, sizeof(byte_132B38));
  sub_56BE8(a1, 0xF, 0, 0, 0xFFFFFFFF);
  if ( dword_96BB8 == 0xFFFFFFFF )
  {
    sub_54208(v20 + 4, 0xF, 0, 0);
  }
  if ( sub_57220(a1, *(_DWORD *)(v20 + 0x41), *(_WORD *)(a1 + 0x4228)) != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x4EE);
  }
  v8 = *(_WORD *)(v20 + 0x6B);
  for ( i = 0; i < v8; ++i )
  {
    if ( sub_57220(a1, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v20 + 0x67) + 4 * i) + 0x41), *(_WORD *)(a1 + 0x4228)) != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x4F4);
    }
  }
  (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(v20 + 0xA7) + 8))(v20, 0xC8, 0, 0);
  (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(v20 + 0xA7) + 8))(v20, 1, 0, 0);
  sub_55618(a1, (const char *)2);
  (*(void (__fastcall **)(int))(*(_DWORD *)(v20 + 0xA7) + 8))(v20);
  for ( j = 0; j < v8; ++j )
  {
    v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v20 + 0x67) + 4 * j) + 0x41);
    sub_57310(a1, v11, *(_WORD *)(a1 + 0x4228), (int)v19);
  }
  v12 = v19;
  v17[0] = *(_DWORD *)(v20 + 4);
  v17[1] = *(_DWORD *)(v20 + 8);
  v17[2] = *(_DWORD *)(v20 + 0xC);
  v17[3] = *(_DWORD *)(v20 + 0x10);
  v17[4] = *(_DWORD *)(v20 + 0x14);
  v13 = *(__int16 *)(a1 + 0x4228);
  v14 = *(_DWORD *)(v20 + 0x41);
  sub_57310(a1, v14, v13, (int)v19);
  v15 = dword_96BB8;
  *(_DWORD *)(a1 + 0x3002) = 0xFFFFFFFF;
  if ( v15 == 0xFFFFFFFF )
  {
    sub_542B0(v17, v14, v13, v12);
  }
  sub_56BE8(a1, 0xE, 0, 0, 0xFFFFFFFF);
  sub_552CC((P_Type3)a1, 0);
  if ( dword_A0D00 == 0xFFFFFFFF )
  {
    *(_DWORD *)((char *)&loc_24D9B + a1 + 1) = v18;
  }
  result = *(_DWORD *)(a1 + 0x48A2);
  dword_96BB8 = 0xFFFFFFFF;
  return result;
}
// 96BB8: using guessed type int dword_96BB8;
// A0D00: using guessed type int dword_A0D00;

//----- (00055618) --------------------------------------------------------
unsigned int __fastcall sub_55618(unsigned int result, const char *a2)
{
  int v2; // ecx
  int v3; // ebx

  v2 = result;
  if ( *(_DWORD *)(result + 0x489E) )
  {
    a2 = "..\\winmgr.cpp";
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x57E);
  }
  *(_DWORD *)(v2 + 0x489E) = 0xFFFFFFFF;
  v3 = dword_96774;
  *(_DWORD *)(v2 + 0x48A2) = 0;
  if ( v3 == 0xFFFFFFFF )
  {
    do
    {
      if ( *(_DWORD *)(v2 + 0x489E) != 0xFFFFFFFF )
      {
        break;
      }
      if ( V_Type3_stru_10AE70.bbb == 0xFFFFFFFF )
      {
        sub_59B80((int)&V_Type3_stru_10AE70);
      }
      else
      {
        sub_2656C((__int16)&unk_D85F8);
      }
      sub_5469C(&V_Type3_stru_10AE70, (int)a2, v3, v2);
      result = sub_5508C(&V_Type3_stru_10AE70);
      if ( V_Type3_stru_10AE70.bbb )
      {
        result = sub_59A54((int)&V_Type3_stru_10AE70);
      }
    }
    while ( dword_96774 == 0xFFFFFFFF );
  }
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D85FC = 0;
  return result;
}
// 96774: using guessed type int dword_96774;
// D85FC: using guessed type int dword_D85FC;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;

//----- (000556CC) --------------------------------------------------------
int __fastcall sub_556CC(int a1, int a2)
{
  T_TypeA3 *v3; // eax
  T_TypeA1 *v4; // ecx
  T_TypeA2 *v5; // eax
  T_TypeA1 *v6; // edx
  char *p_g; // edi
  char *sub_1CEA8; // esi
  char v9; // al
  char v10; // al
  int v11; // eax

  v3 = (T_TypeA3 *)operator new(0xB3u);
  if ( v3 )
  {
    sub_2FA18(v3);
  }
  v4 = (T_TypeA1 *)sub_2625C(v3, 2, "MSGBOX");
  sub_2C978(v4);
  v4->k = 0;
  *(_DWORD *)&v4->c[4] = 0x32;
  *(_DWORD *)&v4->c[0xC] = 0x12C;
  v4[1].b = a2;
  *(_DWORD *)v4->c = *(_DWORD *)&v4->c[4];
  *(_DWORD *)&v4->c[8] = *(_DWORD *)&v4->c[0xC];
  v4->b = *(_DWORD *)(a1 + 0x300A);
  v5 = (T_TypeA2 *)operator new(0xABu);
  if ( v5 )
  {
    sub_2C830(v5);
  }
  v6 = (T_TypeA1 *)sub_2625C(v5, 2, "MSGBOXBUTTON");
  sub_2C978(v6);
  p_g = &v6->g;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);// 30: "OK"
  do
  {
    v9 = *sub_1CEA8;
    *p_g = *sub_1CEA8;
    if ( !v9 )
    {
      break;
    }
    v10 = sub_1CEA8[1];
    sub_1CEA8 += 2;
    p_g[1] = v10;
    p_g += 2;
  }
  while ( v10 );
  *(_DWORD *)&v6->c[4] = 0x104;
  *(_DWORD *)&v6->c[0xC] = 0x122;
  *(_DWORD *)v6->c = *(_DWORD *)&v6->c[4];
  *(_DWORD *)&v6->c[8] = *(_DWORD *)&v6->c[0xC];
  v11 = *(_DWORD *)(a1 + 0x300A);
  v6->k = 0xFFFFFFFF;
  v6->m = 0xC9;
  v6->b = v11;
  v6->v = v4->l;
  sub_2C990((int)v4, (int)v6);
  return sub_552F8(a1);
}

//----- (000557D4) --------------------------------------------------------
const char *__fastcall sub_557D4(T_Type3 *eax0, char *s2, const char *a3, __int16 a4)
{
  T_TypeA2 *v4; // eax
  char *v5; // ebp
  int v6; // ebx
  int v7; // eax
  P_Type3 v8; // eax
  T_TypeA2 *v9; // eax
  T_TypeA1 *v10; // ebx
  char *p_g; // edi
  char *sub_1CEA8; // esi
  char v13; // al
  char v14; // al
  char *v15; // eax
  int v16; // eax
  T_TypeA2 *v17; // eax
  P_TypeA1 v18; // edx
  P_TypeA1 v19; // edx
  int v20; // eax
  int v21; // ebx
  int v22; // ebx
  int v23; // eax
  int v24; // eax
  T_Type5 v26; // [esp+0h] [ebp-3Ch] BYREF
  T_TypeA1 *v27; // [esp+14h] [ebp-28h]
  int v28; // [esp+18h] [ebp-24h]
  const char *v29; // [esp+1Ch] [ebp-20h]
  int v30; // [esp+20h] [ebp-1Ch]
  P_Type3 a1; // [esp+24h] [ebp-18h]
  P_TypeA1 v32; // [esp+28h] [ebp-14h]
  __int16 v33; // [esp+2Ch] [ebp-10h]

  a1 = eax0;
  v29 = a3;
  v33 = a4;
  v30 = sub_2B594((int *)&V_Type3_stru_10AE70.z1[0x3046]);
  v28 = 5 * v30 + 5;
  v4 = (T_TypeA2 *)operator new(0xABu);
  if ( v4 )
  {
    sub_2C830(v4);
  }
  v5 = (char *)sub_2625C(v4, 2, "INPUTBOX");
  sub_2C978((P_TypeA1)v5);
  strncpy(v5 + 0x20, s2, 0x13u);
  v6 = v28;
  *((_DWORD *)v5 + 2) = 0xF2;
  *((_DWORD *)v5 + 4) = 0x18D;
  v7 = (0x1E0 - v6) / 2;
  v5[0x33] = 0;
  *(_WORD *)(v5 + 0x5B) = 0xFFFF;
  *((_DWORD *)v5 + 3) = v7;
  *((_DWORD *)v5 + 5) = v6 + v7;
  v8 = a1;
  *(_WORD *)(v5 + 0x5D) = 5;
  *((_DWORD *)v5 + 1) = *(_DWORD *)&v8->z1[0x300A];
  v9 = (T_TypeA2 *)operator new(0xABu);
  if ( v9 )
  {
    sub_2C830(v9);
  }
  v10 = (T_TypeA1 *)sub_2625C(v9, 2, "MSGBOXBUTTON");
  v27 = v10;
  sub_2C978(v10);
  p_g = &v10->g;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
  do
  {
    v13 = *sub_1CEA8;
    *p_g = *sub_1CEA8;
    if ( !v13 )
    {
      break;
    }
    v14 = sub_1CEA8[1];
    sub_1CEA8 += 2;
    p_g[1] = v14;
    p_g += 2;
  }
  while ( v14 );
  v10->s = 0xFFFF;
  v10->t = 2;
  v15 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
  *(_DWORD *)v10->c = *((_DWORD *)v5 + 4) - sub_2B4F4(&V_Type3_stru_10AE70.z1[0x3046], v15) - 0xA;
  *(_DWORD *)&v10->c[8] = *((_DWORD *)v5 + 4) - 3;
  *(_DWORD *)&v10->c[4] = *((_DWORD *)v5 + 5) - v30 - 5;
  *(_DWORD *)&v10->c[0xC] = *((_DWORD *)v5 + 5) - 2;
  v16 = *(_DWORD *)&a1->z1[0x300A];
  v10->k = 0xFFFFFFFF;
  v10->u = 0xFFFFFFFF;
  v10->m = 0xC9;
  v10->b = v16;
  v10->v = *(_DWORD *)(v5 + 0x41);
  sub_2C990((int)v5, (int)v10);
  v17 = (T_TypeA2 *)operator new(0xC1u);
  if ( v17 )
  {
    v17 = sub_2F48C(v17);
  }
  v32 = (P_TypeA1)sub_2625C(v17, 2, "EDITWND");
  if ( !v32 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x5F7);
  }
  sub_2C978(v32);
  v18 = v32;
  *(_DWORD *)v32->c = *((_DWORD *)v5 + 2) + 0xF;
  *(_DWORD *)&v18->c[8] = *((_DWORD *)v5 + 4) - 0xF;
  v19 = v32;
  v20 = v30 + *((_DWORD *)v5 + 3) + 8;
  v21 = v30;
  *(_DWORD *)&v32->c[4] = v20;
  *(_DWORD *)&v19->c[0xC] = v21 + v20 + 8;
  v19->b = *(_DWORD *)&a1->z1[0x300A];
  v22 = v33;
  v23 = *(_DWORD *)(v5 + 0x41);
  v19->m = 0;
  v19->v = v23;
  sub_2F9A4((int)v19, v29, v22);
  sub_2C990((int)v5, (int)v32);
  v26 = *(T_Type5 *)(v5 + 4);
  dword_96BB8 = 0;
  v26.rect.x1 -= 8;
  v26.rect.x2 += 8;
  v26.rect.y1 -= 8;
  v26.rect.y2 += 7;
  sub_54208((int)&v26, (int)&v26, v22, 0);
  sub_552CC(a1, &v26);
  v24 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEEA);
  sub_5CB3C(&v26, v24, 1, 0, 0);
  sub_552F8((unsigned int)a1, (int)v5, 0);
  sub_542B0(&v26, (int)&v26, 0, 0);
  sub_552CC(a1, &v26);
  sub_57530((int)a1, v27->l, 0);
  sub_57530((int)a1, v32->l, 0);
  sub_57530((int)a1, *(_DWORD *)(v5 + 0x41), 0);
  return v29;
}
// 96BB8: using guessed type int dword_96BB8;
// FFEEA: using guessed type __int16 word_FFEEA;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00055AEC) --------------------------------------------------------
unsigned int __fastcall sub_55AEC(int a1, __int16 a2, int a3, int a4)
{
  int v6; // edx

  if ( dword_A0D00 == 0xFFFFFFFF )
  {
    return 0;
  }
  v6 = *(__int16 *)(a1 + 0x475A);
  if ( v6 == 0x20 )
  {
    return 0;
  }
  *(_WORD *)(a1 + 0xA * v6 + 0x475E) = a2;
  *(_DWORD *)(a1 + 0xA * *(__int16 *)(a1 + 0x475A) + 0x4760) = a3;
  *(_DWORD *)(a1 + 0xA * (__int16)(*(_WORD *)(a1 + 0x475A))++ + 0x4764) = a4;
  return 0xFFFFFFFF;
}
// A0D00: using guessed type int dword_A0D00;

//----- (00055B74) --------------------------------------------------------
char __fastcall sub_55B74(int a1)
{
  __int16 *v1; // esi
  int v2; // eax
  __int16 v3; // di
  int v4; // ebp
  __int16 *v5; // ebp
  __int16 *v6; // ebp
  unsigned int v7; // ecx
  bool v8; // zf
  __int16 v9; // dx
  __int16 v10; // bx
  int v12; // [esp+8h] [ebp-20h]
  int v13; // [esp+Ch] [ebp-1Ch]

  v1 = (__int16 *)a1;
  if ( dword_10AE6C == 0xFFFFFFFF )
  {
    return a1;
  }
  a1 = *(__int16 *)(a1 + 0x475A);
  if ( !a1 )
  {
    return a1;
  }
  a1 = v1[0x2114];
  if ( a1 != 1 )
  {
    return a1;
  }
  v2 = sub_56DA8((int)v1, "EVENTWIN", 0);
  if ( !v2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x63B);
  }
  sub_26874(v2, &v1[5 * v1[0x23AE] + 0x23AF]);
  dword_10AE6C = 0xFFFFFFFF;
  v12 = 0;
  if ( !dword_A0D00 )
  {
    v12 = sub_552F8((int)v1);
  }
  LOBYTE(a1) = v12;
  v3 = 0;
  dword_10AE6C = 0;
  if ( !v12 )
  {
    goto LABEL_47;
  }
  v6 = &v1[5 * v1[0x23AE]];
  v7 = v6[0x23AF];
  a1 = *((_DWORD *)v6 + 0x11D8);
  v13 = *((_DWORD *)v6 + 0x11D9);
  if ( v7 < 9 )
  {
    if ( v7 >= 3 )
    {
      goto LABEL_16;
    }
    if ( !v6[0x23AF] )
    {
      v8 = 1;
      goto LABEL_45;
    }
    if ( v7 > 1 )
    {
      v3 = 0xD;
      byte_968DD = *((_DWORD *)v6 + 0x11D8);
      goto LABEL_47;
    }
    goto LABEL_10;
  }
  if ( v7 <= 9 )
  {
    goto LABEL_16;
  }
  if ( v7 >= 0x14 )
  {
    if ( v7 > 0x14 )
    {
      if ( v7 < 0x17 )
      {
        v8 = v7 == 0x16;
      }
      else
      {
        if ( v7 <= 0x17 )
        {
          LOBYTE(a1) = *((_DWORD *)v6 + 0x11D9);
          v3 = 0xD;
          byte_968DD = a1;
          goto LABEL_47;
        }
        v8 = v7 == 0x19;
      }
LABEL_45:
      if ( v8 )
      {
        v3 = 0x14;
      }
      goto LABEL_47;
    }
LABEL_16:
    v4 = *((_DWORD *)v6 + 0x11D8);
    if ( *(_BYTE *)(a1 + 0x58) != 4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x6A8);
    }
    LOBYTE(a1) = v13;
    v5 = *(__int16 **)(v4 + 0x59);
    if ( (v7 == 4 || v7 == 8) && v12 != 2 )
    {
      v3 = 0xD;
      if ( sub_45958((unsigned __int8 *)&byte_A2F72[0x1EE * v13], 2, v5, 0) )
      {
        byte_A315B[0x1EE * v13] = 1;
        *(int *)((char *)&dword_A315C + 0x1EE * v13) = (int)v5;
      }
      else
      {
        byte_A315B[0x1EE * v13] = 0;
      }
      LOBYTE(a1) = v13;
      byte_968DD = v13;
    }
    else
    {
      v3 = 0x10;
      dword_D3660 = (int)v5;
    }
    goto LABEL_47;
  }
  if ( v7 >= 0x10 )
  {
    if ( v7 <= 0x12 )
    {
      v3 = 0x11;
      dword_D3664 = *((_DWORD *)v6 + 0x11D9);
    }
    else if ( v12 == 1 )
    {
      v3 = 0x10;
      dword_D3660 = *((_DWORD *)v6 + 0x11D8);
    }
    else if ( v13 == 7 )
    {
      LOBYTE(a1) = sub_56B60((int)v1, 7, 0, 0);
    }
    else
    {
      *(_DWORD *)((char *)v1 + (_DWORD)&loc_24D9B + 1) = 0xFFFFFFFF;
    }
    goto LABEL_47;
  }
  if ( v7 == 0xF )
  {
LABEL_10:
    v3 = 0x11;
    dword_D3664 = *((_DWORD *)v6 + 0x11D8);
  }
LABEL_47:
  v9 = v1[0x23AE] + 1;
  v10 = v1[0x23AD];
  v1[0x23AE] = v9;
  if ( v9 == v10 )
  {
    v1[0x23AE] = 0;
    v1[0x23AD] = 0;
  }
  if ( v3 )
  {
    LOBYTE(a1) = sub_56B60((int)v1, 1, v3, 1);
  }
  return a1;
}
// 968DD: using guessed type char byte_968DD;
// A0D00: using guessed type int dword_A0D00;
// A315C: using guessed type int dword_A315C;
// D3660: using guessed type int dword_D3660;
// 10AE6C: using guessed type int dword_10AE6C;

//----- (00055E80) --------------------------------------------------------
__int16 __fastcall sub_55E80(int a1)
{
  int v1; // ebp
  char *v2; // edx
  int v3; // ecx
  int v4; // ebx
  int v5; // ecx
  __int16 i; // si
  _DWORD *v7; // ecx
  int v8; // esi
  char v9; // bl
  char *v10; // edi
  char *v11; // esi
  char v12; // al
  char v13; // al
  int v14; // esi
  char v15; // dl
  char *v16; // edi
  char *v17; // esi
  char v18; // al
  char v19; // al
  __int16 v20; // ax
  char format[600]; // [esp+0h] [ebp-53Ch] BYREF
  char v23[600]; // [esp+258h] [ebp-2E4h] BYREF
  char s[28]; // [esp+4B0h] [ebp-8Ch] BYREF
  char v25[28]; // [esp+4CCh] [ebp-70h] BYREF
  char v26[28]; // [esp+4E8h] [ebp-54h] BYREF
  int v27; // [esp+504h] [ebp-38h]
  int v28; // [esp+508h] [ebp-34h]
  int v29; // [esp+50Ch] [ebp-30h]
  int v30; // [esp+510h] [ebp-2Ch]
  int v31; // [esp+514h] [ebp-28h]
  _DWORD *v32; // [esp+518h] [ebp-24h]
  int v33; // [esp+51Ch] [ebp-20h]
  int v34; // [esp+520h] [ebp-1Ch]

  v1 = a1;
  HIWORD(v2) = 0;
  qmemcpy((void *)(a1 + 0x436C), (const void *)(a1 + 0x422C), 0x140u);
  LOWORD(a1) = *(_WORD *)(a1 + 0x44AC);
  LOWORD(v34) = 0;
  v33 = (unsigned __int16)a1;
  *(_WORD *)(v1 + 0x44AC) = 0;
  if ( (__int16)a1 > 0 )
  {
    do
    {
      a1 = 0xA * (__int16)v34;
      LOWORD(v2) = *(_WORD *)(a1 + v1 + 0x436C);
      v3 = *(_DWORD *)(a1 + v1 + 0x436E);
      v31 = *(_DWORD *)(a1 + v1 + 0x4372);
      LOWORD(a1) = (_WORD)v2;
      switch ( (__int16)v2 )
      {
        case 0:
          break;
        case 1:
          v2 = (char *)(__int16)v3;
          LOWORD(a1) = (unsigned __int16)sub_56E9C((P_Type3)v1, v3, (v31 == 0) - 1);
          break;
        case 2:
          HIWORD(v2) = 0;
          dword_96774 = 0;
          break;
        case 3:
          HIWORD(v2) = 0xFFFF;
          LOWORD(a1) = sub_570AC(v1, 0xFFFFFFFF);
          break;
        case 4:
          if ( !*(_DWORD *)(v1 + 0x48A6) && !*(_DWORD *)(v1 + 0x48AA) )
          {
            v2 = "WINEVENT.BIN";
            LOWORD(a1) = sub_59988((P_Type3)v1, "WINEVENT.BIN", 0xFFFFFFFF);
          }
          break;
        case 5:
          switch ( v31 )
          {
            case 1:
              v2 = "ABILITYWIN";
              v32 = (_DWORD *)sub_56DA8(v1, "ABILITYWIN", 0);
              LOWORD(a1) = sub_33884(v32, (int)"ABILITYWIN", 0, v3);
              break;
            case 2:
              v7 = (_DWORD *)sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = v7;
              sprintf(s, "STATE%02d", *(__int16 *)(v1 + 0x4228));
              v2 = "help.txt";
              LOWORD(a1) = sub_2FCB0(v7, "help.txt", s);
              break;
            case 3:
              v2 = "help.txt";
              v32 = (_DWORD *)sub_56DA8(v1, "HELPWINDOW", 0);
              LOWORD(a1) = sub_2FCB0(v32, "help.txt", "NOINTRO");
              break;
            case 4:
              sprintf(v25, "gizmo%02d", v3);
              v2 = "gizhelp.txt";
              v8 = sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = (_DWORD *)v8;
              sub_2FCB0((_DWORD *)v8, "gizhelp.txt", v25);
              v9 = *(_BYTE *)(v8 + 0xC95);
              v30 = v8 + 0xC95;
              v27 = v8 + 0xCB0;
              if ( v9 != 1 )
              {
                v2 = "..\\winmgr.cpp";
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x784);
              }
              if ( *(_BYTE *)v27 )
              {
                v2 = "..\\winmgr.cpp";
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x785);
              }
              v10 = format;
              v11 = *(char **)(v30 + 5);
              do
              {
                v12 = *v11;
                *v10 = *v11;
                if ( !v12 )
                {
                  break;
                }
                v13 = v11[1];
                v11 += 2;
                v10[1] = v13;
                v10 += 2;
              }
              while ( v13 );
              sprintf(*(char **)(v30 + 5), format, (char *)&unk_107020 + 0x6A * v3);
              a1 = v27;
              *(_WORD *)(v27 + 1) = 0x1C;
              *(_WORD *)(a1 + 3) = v3;
              break;
            case 5:
              sprintf(v26, "plitem%02d", v3);
              v14 = sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = (_DWORD *)v14;
              sub_2FCB0((_DWORD *)v14, "planhelp.txt", v26);
              v15 = *(_BYTE *)(v14 + 0xC95);
              v29 = v14 + 0xC95;
              v28 = v14 + 0xCB0;
              if ( v15 != 1 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x79F);
              }
              if ( *(_BYTE *)v28 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x7A0);
              }
              v16 = v23;
              v17 = *(char **)(v29 + 5);
              do
              {
                v18 = *v17;
                *v16 = *v17;
                if ( !v18 )
                {
                  break;
                }
                v19 = v17[1];
                v17 += 2;
                v16[1] = v19;
                v16 += 2;
              }
              while ( v19 );
              v2 = *(char **)(v29 + 5);
              sprintf(v2, v23, &dword_103F9A[0xA * v3 + 3]);
              if ( v3 == 0x17 )
              {
                v2 = (char *)v28;
                v20 = (unsigned __int8)byte_104BEA;
                *(_WORD *)(v28 + 3) = 0;
                LOWORD(a1) = v20 + 0xE;
                *(_WORD *)(v2 + 1) = a1;
              }
              else
              {
                a1 = v28;
                *(_WORD *)(v28 + 1) = 0x1E;
                *(_WORD *)(a1 + 3) = v3;
              }
              break;
            default:
              v2 = "HELPWINDOW";
              a1 = sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = (_DWORD *)a1;
              if ( v3 )
              {
                v2 = "help.txt";
                LOWORD(a1) = sub_2FCB0((_DWORD *)a1, "help.txt", (char *)v3);
              }
              break;
          }
          if ( !*(_DWORD *)(v1 + 0x489E) )
          {
            HIWORD(v2) = HIWORD(v32);
            LOWORD(a1) = sub_552F8(v1);
          }
          if ( v31 == 1 )
          {
            v2 = *(char **)(sub_56DA8(v1, "COSMOSWnd", 0) + 0x41);
            LOWORD(a1) = sub_56D30(v1, (int)v2, 0xD, 0, 0);
          }
          break;
        case 6:
          *(_DWORD *)(v1 + 0x489E) = 0;
          *(_DWORD *)(v1 + 0x48A2) = v3;
          break;
        case 7:
          v4 = sub_20B3C((int)dword_A2F6C);
          if ( v4 )
          {
            v5 = 7;
            if ( *(_DWORD *)((char *)&loc_24D9B + v1 + 1) == 0xFFFFFFFF )
            {
              v5 = 8;
            }
            HIWORD(v2) = 0;
            LOWORD(a1) = sub_55AEC(v1, 0x13, v4, v5);
          }
          else
          {
            sub_20C94((int)dword_A2F6C, (int)v2, 0, v3);
            if ( *(_DWORD *)((char *)&loc_24D9E + v1 + 2) == 0xFFFFFFFF )
            {
              for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
              {
                if ( i != (unsigned __int8)byte_104BEA )
                {
                  sub_46130(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], i, 0xFFFFFFFF);
                  sub_45F60(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], i, 0xFFFFFFFF);
                }
              }
            }
            HIWORD(v2) = 0;
            sub_56BE8(v1, 0xD, 0, 0, 0);
            LOWORD(a1) = sub_5508C((P_Type3)v1);
          }
          break;
        case 8:
          a1 = sub_20B3C((int)dword_A2F6C);
          if ( !a1 || dword_A0D00 )
          {
            *(_DWORD *)((char *)&loc_24D9B + v1 + 1) = ~*(_DWORD *)((char *)&loc_24D9B + v1 + 1);
          }
          else
          {
            HIWORD(v2) = 0;
            LOWORD(a1) = sub_55AEC(v1, 0x13, a1, (__int16)v2);
          }
          break;
        default:
          v2 = "..\\winmgr.cpp";
          LOWORD(a1) = 0;
          Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x7D7);
          break;
      }
      LOWORD(v34) = v34 + 1;
    }
    while ( (__int16)v34 < (__int16)v33 );
  }
  return a1;
}
// 96774: using guessed type int dword_96774;
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// A3CF2: using guessed type int dword_A3CF2;
// 103F9A: using guessed type int dword_103F9A[];

//----- (00056400) --------------------------------------------------------
void __fastcall sub_56400(T_Type3 *a1, int a2, __int16 a3, int a4, int a5, int a6)
{
  __int16 i; // kr00_2
  int v9; // eax

  if ( a1->counter1 == 0x10 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x7ED);
  }
  if ( a1->aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    a6 = 0;
  }
  for ( i = 0; i < 0x10; ++i )
  {
    if ( !a1->b1[i].a )
    {
      a1->b1[i].a = a2;
      a1->b1[i].c = a4;
      a1->b1[i].b = a3;
      a1->b1[i].d = a5;
      v9 = dword_132B58;
      a1->b1[i].e = a6;
      a1->b1[i].f = a6 + v9;
      ++a1->counter1;
      break;
    }
  }
  sub_59C80(a1, a2, 4, a3, a4, a5, 0);
}
// 132B58: using guessed type int dword_132B58;

//----- (000564C0) --------------------------------------------------------
void __fastcall sub_564C0(T_Type3 *a1, int a2, __int16 a3)
{
  __int16 i; // dx
  char *v6; // ebx

  for ( i = 0; i < 0x10; ++i )
  {
    v6 = &a1->z1[0x16 * i];
    if ( a2 == *(_DWORD *)(v6 + 0x44AE) && (a3 == 0xFFFFFFFF || a3 == *((_WORD *)v6 + 0x2259)) )
    {
      a1->b1[i].a = 0;
      --a1->counter1;
    }
  }
  sub_59C80(a1, a2, 5, a3, 0, 0, 0);
}

//----- (00056528) --------------------------------------------------------
int __fastcall sub_56528(int a1, int a2, __int16 a3)
{
  __int16 i; // ax
  int v6; // edx

  for ( i = 0; i < 0x10; ++i )
  {
    v6 = a1 + 0x16 * i;
    if ( a2 == *(_DWORD *)(v6 + 0x44AE) && a3 == *(_WORD *)(v6 + 0x44B2) )
    {
      return *(_DWORD *)(v6 + 0x44BC);
    }
  }
  return 0xFFFF;
}

//----- (00056564) --------------------------------------------------------
unsigned int __fastcall sub_56564(int a1, int a2, __int16 a3, int a4)
{
  __int16 i; // dx
  int v7; // eax

  for ( i = 0; i < 0x10; ++i )
  {
    v7 = a1 + 0x16 * i;
    if ( a2 == *(_DWORD *)(v7 + 0x44AE) && a3 == *(_WORD *)(v7 + 0x44B2) )
    {
      *(_DWORD *)(v7 + 0x44BC) = a4;
      return 0xFFFFFFFF;
    }
  }
  return 0;
}

//----- (00056694) --------------------------------------------------------
int __fastcall sub_56694(int a1)
{
  int v2; // eax
  __int16 v3; // di
  int result; // eax
  int v5; // esi
  void (__fastcall *v6)(_DWORD, _DWORD); // edx
  int v7; // [esp+4h] [ebp-20h]
  __int16 v8; // [esp+8h] [ebp-1Ch]

  v2 = a1 + 0x44AE;
  v3 = *(_WORD *)(v2 + 0x160);
  v8 = 0;
  v7 = v2;
  while ( 1 )
  {
    result = v8;
    if ( v8 >= 0x10 || v3 <= 0 )
    {
      break;
    }
    v5 = 0x16 * v8 + v7;
    v6 = *(void (__fastcall **)(_DWORD, _DWORD))v5;
    if ( *(_DWORD *)v5 )
    {
      if ( (unsigned int)dword_132B58 >= *(_DWORD *)(v5 + 0x12) )
      {
        if ( *(_WORD *)(v5 + 4) == 0x29A )
        {
          v6(*(_DWORD *)(v5 + 6), *(_DWORD *)(v5 + 0xA));
        }
        else
        {
          sub_56D30(a1, (int)v6, *(__int16 *)(v5 + 4), *(_DWORD *)(v5 + 6), *(_DWORD *)(v5 + 0xA));
        }
        *(_DWORD *)(v5 + 0x12) += *(_DWORD *)(v5 + 0xE);
      }
      --v3;
    }
    ++v8;
  }
  return result;
}
// 132B58: using guessed type int dword_132B58;

//----- (00056728) --------------------------------------------------------
void __fastcall sub_56728(int a1, int a2, int a3, __int16 a4, int a5, int a6)
{
  __int16 i; // kr00_2

  if ( *(_WORD *)(a1 + 0x4730) == 0x10 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x8C6);
  }
  for ( i = 0; i < 0x10; ++i )
  {
    if ( !*(_DWORD *)(a1 + 0x12 * i + 0x4610) )
    {
      *(_DWORD *)(a1 + 0x12 * i + 0x4610) = a2;
      *(_DWORD *)(a1 + 0x12 * i + 0x4614) = a3;
      *(_WORD *)(a1 + 0x12 * i + 0x4618) = a4;
      *(_DWORD *)(a1 + 0x12 * i + 0x461A) = a5;
      *(_DWORD *)(a1 + 0x12 * i + 0x461E) = a6;
      ++*(_WORD *)(a1 + 0x4730);
      break;
    }
  }
  sub_59C80((T_Type3 *)a1, a2, 6, a4, a5, a6, a3);
}

//----- (000567BC) --------------------------------------------------------
void __fastcall sub_567BC(int a1, int a2, __int16 a3)
{
  __int16 i; // dx
  int v6; // ebx

  for ( i = 0; i < 0x10; ++i )
  {
    v6 = a1 + 0x12 * i;
    if ( a2 == *(_DWORD *)(v6 + 0x4610) && (a3 == 0xFFFFFFFF || a3 == *(_WORD *)(v6 + 0x4618)) )
    {
      *(_DWORD *)(0x12 * i + a1 + 0x4610) = 0;
      --*(_WORD *)(a1 + 0x4730);
    }
  }
  sub_59C80((T_Type3 *)a1, a2, 7, a3, 0, 0, 0);
}

//----- (00056824) --------------------------------------------------------
void __fastcall sub_56824(int a1)
{
  int v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  __int16 i; // [esp+8h] [ebp-20h]
  __int16 v8; // [esp+Ch] [ebp-1Ch]

  v8 = *(_WORD *)(a1 + 0x4730);
  v6 = 0;
  v5 = 0;
  if ( dword_D8638 == 0xFFFFFFFF )
  {
    v6 = 1;
  }
  if ( dword_D863C == 0xFFFFFFFF )
  {
    LOBYTE(v6) = v6 | 2;
  }
  if ( dword_D8644 == 0xFFFFFFFF )
  {
    LOBYTE(v5) = 4;
  }
  for ( i = 0; i < 0x10 && v8 > 0; ++i )
  {
    v2 = a1 + 0x12 * i;
    v3 = *(_DWORD *)(v2 + 0x4610);
    if ( v3 )
    {
      if ( (v6 & *(_DWORD *)(v2 + 0x4614)) != 0 )
      {
        sub_56D30(
          a1,
          *(_DWORD *)(v2 + 0x4610),
          *(__int16 *)(v2 + 0x4618),
          *(_DWORD *)(v2 + 0x461A),
          *(_DWORD *)(v2 + 0x461E));
      }
      v4 = a1 + 0x12 * i;
      if ( (v5 & *(_DWORD *)(v4 + 0x4614)) != 0 )
      {
        sub_56D30(a1, v3, *(__int16 *)(v4 + 0x4618), dword_D8648, dword_D864C);
      }
      --v8;
    }
  }
  JUMPOUT(0x55E3D);
}
// 5688A: control flows out of bounds to 55E3D
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;

//----- (0005691C) --------------------------------------------------------
int __fastcall sub_5691C(int result)
{
  int v1; // esi
  int v2; // edi
  int v3; // edx
  int v4; // ebp
  int v5; // ecx
  __int16 v6; // dx
  int v7; // ebx
  int v8; // edx
  __int16 v9; // cx
  int v10; // eax
  _DWORD *v11; // edx
  unsigned int v12; // [esp+4h] [ebp-28h]
  int v13; // [esp+8h] [ebp-24h]
  int v14; // [esp+Ch] [ebp-20h]
  __int16 v15; // [esp+10h] [ebp-1Ch]

  v1 = result;
  v2 = dword_D8648;
  v3 = *(_DWORD *)(result + 0x3002);
  v4 = dword_D864C;
  if ( v3 == 0xFFFFFFFF )
  {
    goto LABEL_17;
  }
  v5 = *(_DWORD *)(result + 0xC * v3 + 4);
  if ( dword_D8648 > *(_DWORD *)(v5 + 0x10)
    || dword_D8648 < *(_DWORD *)(v5 + 8)
    || dword_D864C > *(_DWORD *)(v5 + 0x14)
    || dword_D864C < *(_DWORD *)(v5 + 0xC) )
  {
    sub_56D30(result, *(_DWORD *)(result + 0x3002), 8, dword_D8648, dword_D864C);
    result = sub_56D30(v1, *(_DWORD *)(v1 + 0x3002), 6, 0, 0);
    *(_DWORD *)(v1 + 0x3002) = 0xFFFFFFFF;
LABEL_17:
    v8 = *(__int16 *)(v1 + 0x4228);
    if ( v8 >= 0 )
    {
      v9 = 0x1F;
      v12 = 0;
      v15 = *(_WORD *)(v1 + 0x8E * v8 + 0x3068);
      while ( 1 )
      {
        result = v15;
        if ( v15 <= 0 || v12 )
        {
          break;
        }
        if ( v9 < 0 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x992);
        }
        v10 = *(_DWORD *)(v1 + 0x8E * *(__int16 *)(v1 + 0x4228) + 4 * v9 + 0x306A);
        v13 = v10;
        if ( v10 )
        {
          v11 = *(_DWORD **)(v1 + 0xC * v10 + 4);
          if ( *(_DWORD *)((char *)v11 + 0xA3) == 0xFFFFFFFF
            && v2 <= v11[4]
            && v2 >= v11[2]
            && v4 <= v11[5]
            && v4 >= v11[3]
            && *(_DWORD *)((char *)v11 + 0x35) == 0xFFFFFFFF )
          {
            v12 = 0xFFFFFFFF;
          }
          --v15;
        }
        --v9;
      }
      if ( v12 == 0xFFFFFFFF )
      {
        *(_DWORD *)(v1 + 0x3002) = v13;
        return sub_56D30(v1, v13, 7, 0, 0);
      }
    }
    return result;
  }
  result = *(__int16 *)(v5 + 0x6B);
  if ( *(_WORD *)(v5 + 0x6B) )
  {
    v6 = 0;
    if ( *(__int16 *)(v5 + 0x6B) > 0 )
    {
      while ( 1 )
      {
        result = *(_DWORD *)(*(_DWORD *)(v5 + 0x67) + 4 * v6);
        v14 = result;
        if ( *(_DWORD *)(result + 0x35) )
        {
          v7 = *(_DWORD *)(result + 0x10);
          result += 4;
          if ( dword_D8648 <= v7
            && dword_D8648 >= *(_DWORD *)(result + 4)
            && dword_D864C <= *(_DWORD *)(result + 0x10)
            && dword_D864C >= *(_DWORD *)(result + 8) )
          {
            break;
          }
        }
        if ( ++v6 >= *(__int16 *)(v5 + 0x6B) )
        {
          return result;
        }
      }
      sub_56D30(v1, *(_DWORD *)(v1 + 0x3002), 8, dword_D8648, dword_D864C);
      sub_56D30(v1, *(_DWORD *)(v1 + 0x3002), 6, 0, 0);
      sub_56D30(v1, *(_DWORD *)(v14 + 0x41), 7, 0, 0);
      result = *(_DWORD *)(v14 + 0x41);
      *(_DWORD *)(v1 + 0x3002) = result;
    }
  }
  return result;
}
// 56B46: variable 'v13' is possibly undefined
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;

//----- (00056B60) --------------------------------------------------------
int __fastcall sub_56B60(int a1, __int16 a2, int a3, int a4)
{
  int v5; // edx
  int result; // eax

  if ( *(_WORD *)(a1 + 0x44AC) == 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x9B5);
  }
  *(_WORD *)(a1 + 0xA * *(__int16 *)(a1 + 0x44AC) + 0x422C) = a2;
  *(_DWORD *)(a1 + 0xA * *(__int16 *)(a1 + 0x44AC) + 0x422E) = a3;
  v5 = *(__int16 *)(a1 + 0x44AC);
  result = 5 * v5;
  *(_DWORD *)(a1 + 0xA * v5 + 0x4232) = a4;
  ++*(_WORD *)(a1 + 0x44AC);
  return result;
}

//----- (00056BE8) --------------------------------------------------------
int __fastcall sub_56BE8(int result, __int16 a2, int a3, int a4, int a5)
{
  int v5; // edi
  int v6; // edx
  __int16 v7; // si
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  unsigned int v11; // edx
  __int16 v13; // [esp+Ch] [ebp-10h]

  v5 = result;
  v6 = *(__int16 *)(result + 0x4228);
  if ( v6 >= 0 )
  {
    v7 = 0x1F;
    v8 = 0;
    v13 = *(_WORD *)(result + 0x8E * v6 + 0x3068);
    while ( 1 )
    {
      result = v13;
      if ( v13 <= 0 || v8 )
      {
        break;
      }
      if ( v7 < 0 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x9EA);
      }
      v9 = *(_DWORD *)(v5 + 0x8E * *(__int16 *)(v5 + 0x4228) + 4 * v7 + 0x306A);
      if ( v9 )
      {
        v10 = *(_DWORD *)(v5 + 0xC * v9 + 4);
        if ( !a5 || byte_132B38[v7] )
        {
          if ( (*(_DWORD *)(v10 + 0x35) || a2 == 1 || a2 == 0xE) && (!*(_DWORD *)(v10 + 0x63) || a2 > 2) )
          {
            v11 = 0xFFFFFFFF;
          }
          else
          {
            v11 = 0;
          }
          if ( v11 )
          {
            if ( a5 )
            {
              byte_132B38[v7] = 1;
            }
            v8 = (*(int (**)(void))(*(_DWORD *)(v10 + 0xA7) + 8))();
          }
          else if ( a5 )
          {
            byte_132B38[v7] = 0;
          }
        }
        --v13;
      }
      --v7;
    }
  }
  return result;
}

//----- (00056D30) --------------------------------------------------------
int __fastcall sub_56D30(int a1, int a2, int a3, int a4, int a5)
{
  if ( *(__int16 *)(a1 + 0x4228) >= 0 )
  {
    return (*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xC * a2 + 4) + 0xA7) + 8))();
  }
  else
  {
    return 0;
  }
}

//----- (00056D70) --------------------------------------------------------
int __fastcall sub_56D70(int a1, char *a2, __int16 a3, int a4, int a5)
{
  int result; // eax
  int v7; // [esp+0h] [ebp-Eh] BYREF

  result = sub_56DA8(a1, a2, (_WORD *)&v7 + 1);
  if ( result )
  {
    sub_56D30(a1, SHIWORD(v7), a3, a4, a5);
    return 0xFFFFFFFF;
  }
  return result;
}

//----- (00056DA8) --------------------------------------------------------
int __fastcall sub_56DA8(int a1, char *s1, _WORD *a3)
{
  __int16 v5; // si
  __int16 i; // cx
  int v7; // edx

  v5 = 0;
  for ( i = 0; ; ++i )
  {
    if ( i >= 0x400 || v5 > *(__int16 *)(a1 + 0x3000) )
    {
      return 0;
    }
    v7 = *(_DWORD *)(a1 + 0xC * i + 4);
    if ( v7 )
    {
      ++v5;
      if ( !strncmp(s1, (const char *)(v7 + 0x20), 0xAu) )
      {
        break;
      }
    }
  }
  if ( a3 )
  {
    *a3 = i;
  }
  return *(_DWORD *)(a1 + 0xC * i + 4);
}

//----- (00056E18) --------------------------------------------------------
int __fastcall sub_56E18(int a1, char *s1, __int16 a3, _WORD *a4)
{
  __int16 i; // cx
  int v7; // eax
  int v8; // edi
  int v9; // edx

  if ( a3 < *(__int16 *)(a1 + 0x4226) )
  {
    for ( i = 0; ; ++i )
    {
      v7 = a1 + 0x8E * a3;
      if ( i >= *(__int16 *)(v7 + 0x3068) )
      {
        break;
      }
      v8 = *(_DWORD *)(v7 + 4 * i + 0x306A);
      v9 = *(_DWORD *)(a1 + 0xC * v8 + 4);
      if ( v9 && !strncmp(s1, (const char *)(v9 + 0x20), 0xAu) )
      {
        if ( a4 )
        {
          *a4 = v8;
        }
        return *(_DWORD *)(a1 + 0xC * v8 + 4);
      }
    }
  }
  return 0;
}

//----- (00056E9C) --------------------------------------------------------
P_Type3 __fastcall sub_56E9C(P_Type3 a1, __int16 a2, int a3)
{
  P_Type3 v3; // esi
  int v5; // ebx
  int v6; // edx
  int v7; // edx
  int v8; // ebx
  int v9; // eax
  __int16 v10; // ax
  int v11; // eax
  int v12; // eax

  v3 = a1;
  if ( a2 != *(_WORD *)&a1->z1[0x4228] )
  {
    if ( a2 < 0 || a2 >= 0x20 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xA9B);
    }
    v5 = *(__int16 *)&a1->z1[0x4228];
    if ( v5 >= 0 )
    {
      v6 = *(__int16 *)&a1->z1[0x8E * v5 + 0x3066];
      if ( v6 != 0xFFFFFFFF )
      {
        sub_4F45C((int)&unk_10914C, v6);
      }
    }
    v7 = *(__int16 *)&v3->z1[0x8E * a2 + 0x3066];
    if ( v7 != 0xFFFFFFFF )
    {
      sub_4F32C((int)&unk_10914C, v7, 0);
    }
    v8 = *(__int16 *)&v3->z1[0x4228];
    if ( v8 >= 0 && *(_DWORD *)&v3->z1[0x8E * v8 + 0x30F0] )
    {
      (*(void (__fastcall **)(_DWORD, char *))&v3->z1[0x8E * v8 + 0x30F0])(
        *(__int16 *)&v3->z1[0x4228],
        &v3->z1[0x8E * v8 + 0x3066]);
    }
    v9 = *(_DWORD *)&v3->z1[0x3002];
    if ( v9 != 0xFFFFFFFF )
    {
      sub_56D30((int)v3, v9, 6, 0, 0);
    }
    sub_56BE8((int)v3, 2, 0, 0, 0);
    if ( a3 == 0xFFFFFFFF && *(__int16 *)&v3->z1[0x4228] >= 0 )
    {
      v10 = *(_WORD *)&v3->z2[0x148];
      *(_WORD *)&v3->z2[0x148] = v10 + 1;
      *(_WORD *)&v3->z2[2 * v10 + 0x126] = *(_WORD *)&v3->z1[0x4228];
      if ( *(_WORD *)&v3->z2[0x148] == 0x10 )
      {
        *(_WORD *)&v3->z2[0x148] = 0;
      }
      ++*(_WORD *)&v3->z2[0x146];
    }
    *(_WORD *)&v3->z1[0x4228] = a2;
    if ( !*(_WORD *)&v3->z1[0x4228] && dword_96BC0 == 0xFFFFFFFF && !access("resume.gam", 0) )
    {
      sub_53FB0("resume.gam", 0, 0, 0);
    }
    v11 = *(_DWORD *)&v3->z1[0x3006];
    dword_96BC0 = 0;
    sub_5B71C(v11);
    sub_55214((int)v3, 0, 0, 0x27F, 0x1DF);
    v12 = 0x8E * a2;
    if ( *(_DWORD *)&v3->z1[v12 + 0x30EC] )
    {
      (*(void (__fastcall **)(_DWORD, char *))&v3->z1[v12 + 0x30EC])(a2, &v3->z1[v12 + 0x3066]);
    }
    sub_56BE8((int)v3, 1, 0, 0, 0);
    *(_DWORD *)&v3->z1[0x3002] = 0xFFFFFFFF;
    return (P_Type3)sub_5691C((int)v3);
  }
  return a1;
}
// 96BC0: using guessed type int dword_96BC0;

//----- (000570AC) --------------------------------------------------------
int __fastcall sub_570AC(int a1, int a2)
{
  __int16 v4; // dx
  int v5; // ecx

  if ( !*(_WORD *)(a1 + 0x4756) )
  {
    return 0;
  }
  if ( *(_WORD *)(a1 + 0x4758) )
  {
    v4 = *(_WORD *)(a1 + 0x4758) - 1;
  }
  else
  {
    v4 = 0xF;
  }
  v5 = v4;
  LOWORD(v5) = *(_WORD *)(a1 + 2 * v4 + 0x4736);
  if ( a2 == 0xFFFFFFFF )
  {
    *(_WORD *)(a1 + 0x4758) = v4;
    *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 0x4758) + 0x4736) = 0xFFFF;
    --*(_WORD *)(a1 + 0x4756);
    sub_56E9C((P_Type3)a1, v5, 0);
  }
  return v5;
}

//----- (000571B8) --------------------------------------------------------
int __fastcall sub_571B8(P_Type3 a1, P_TypeA1 a2)
{
  __int16 i; // dx
  int result; // eax
  char *v6; // ebx

  if ( a2 && *(_WORD *)&a1->z1[0x3000] != 1023 )
  {
    for ( i = 1; ; ++i )
    {
      result = i;
      if ( i >= 0x400 )
      {
        break;
      }
      v6 = &a1->z1[0xC * i];
      if ( !*(_DWORD *)v6 )
      {
        *(_DWORD *)v6 = 1;
        *((_DWORD *)v6 + 1) = a2;
        ++*(_WORD *)&a1->z1[0x3000];
        *(_DWORD *)a2->a = 0x12345678;
        return result;
      }
    }
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB37);
  }
  return 0;
}

//----- (00057220) --------------------------------------------------------
unsigned int __fastcall sub_57220(int a1, int a2, __int16 a3)
{
  int v6; // edx
  __int16 v8; // ax
  int v9; // ebx
  int v10; // edx

  if ( a3 < 0 || a3 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB42);
  }
  if ( a2 >= 0x400 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB43);
  }
  if ( !a2 )
  {
    return 0;
  }
  v6 = a1 + 0x8E * a3;
  if ( *(_WORD *)(v6 + 0x3068) == 0x20 )
  {
    return 0;
  }
  v8 = 0;
  if ( *(_WORD *)(v6 + 0x3068) )
  {
    while ( v8 < 0x20 )
    {
      v9 = a1 + 0x8E * a3;
      v10 = v9 + 4 * v8;
      if ( !*(_DWORD *)(v10 + 0x306A) )
      {
        *(_DWORD *)(v10 + 0x306A) = a2;
        ++*(_WORD *)(v9 + 0x3068);
        break;
      }
      ++v8;
    }
  }
  else
  {
    ++*(_WORD *)(a1 + 0x4226);
    *(_WORD *)(v6 + 0x3068) = 1;
    *(_DWORD *)(v6 + 0x306A) = a2;
  }
  ++*(_DWORD *)(0xC * a2 + a1);
  if ( v8 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB65);
  }
  return 0xFFFFFFFF;
}

//----- (00057310) --------------------------------------------------------
unsigned int __fastcall sub_57310(int a1, int a2, __int16 a3, int a4)
{
  __int16 i; // cx
  int v9; // edx
  int v10; // eax
  int v11; // ebx

  if ( a3 < 0 || a3 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB75);
  }
  if ( a2 >= 0x400 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB76);
  }
  if ( !a2 || !*(_WORD *)(a1 + 0x8E * a3 + 0x3068) )
  {
    return 0;
  }
  for ( i = 0; i < 0x20; ++i )
  {
    v9 = a1 + 0x8E * a3;
    v10 = v9 + 4 * i;
    v11 = *(_DWORD *)(v10 + 0x306A);
    if ( a2 == v11 )
    {
      *(_DWORD *)(v10 + 0x306A) = 0;
      --*(_WORD *)(v9 + 0x3068);
      --*(_DWORD *)(a1 + 0xC * v11);
      if ( a4 )
      {
        sub_57530(a1, a2, 0);
      }
      break;
    }
  }
  if ( i < 0x20 )
  {
    return 0xFFFFFFFF;
  }
  else
  {
    return 0;
  }
}

//----- (0005748C) --------------------------------------------------------
unsigned int __fastcall sub_5748C(int a1, __int16 a2, __int16 a3)
{
  int v3; // esi
  unsigned int result; // eax

  if ( a2 < 0 || a2 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xBA8);
  }
  v3 = 0x8E * a2 + a1;
  if ( *(unsigned __int16 *)(v3 + 0x30EA) != 0xFFFF )
  {
    return 0;
  }
  result = 0xFFFFFFFF;
  *(_WORD *)(v3 + 0x30EA) = a3;
  return result;
}

//----- (000574F0) --------------------------------------------------------
int __fastcall sub_574F0(P_Type3 a1, __int16 a2, int a3)
{
  int result; // eax

  result = 0x47 * a2;
  *(_DWORD *)&a1->z1[0x8E * a2 + 0x30EC] = a3;
  return result;
}

//----- (00057510) --------------------------------------------------------
int __fastcall sub_57510(int a1, __int16 a2, int a3)
{
  int result; // eax

  result = 0x47 * a2;
  *(_DWORD *)(a1 + 0x8E * a2 + 0x30F0) = a3;
  return result;
}

//----- (00057530) --------------------------------------------------------
int __fastcall sub_57530(int result, int a2, int a3)
{
  int v3; // esi
  int v5; // edx
  int v6; // edx
  int v7; // eax

  v3 = result;
  if ( a2 >= 0x400 )
  {
    result = 0;
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xBDB);
  }
  if ( a2 )
  {
    result = 3 * a2;
    v5 = *(_DWORD *)(v3 + 0xC * a2) - 1;
    *(_DWORD *)(v3 + 0xC * a2) = v5;
    if ( !v5 || a3 )
    {
      v6 = v3 + 0xC * a2;
      sub_2627C(*(void **)(v6 + 4));
      v7 = *(_DWORD *)(v6 + 4);
      if ( v7 )
      {
        (**(void (***)(void))(v7 + 0xA7))();
      }
      result = 3 * a2;
      *(_DWORD *)(v3 + 4 * result + 4) = 0;
      *(_DWORD *)(v3 + 4 * result) = 0;
      --*(_WORD *)(v3 + 0x3000);
    }
  }
  return result;
}

//----- (000575BC) --------------------------------------------------------
FILE *__fastcall sub_575BC(P_Type3 a1)
{
  void *v2; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // ecx
  _BYTE *v5; // edx
  int i; // eax
  void *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // ecx
  _BYTE *v10; // edx
  int j; // eax

  v2 = operator new[](0x100u);
  v3 = sub_2625C(v2, 1, "WMGR MAPFOCUS");
  v4 = v3;
  if ( !v3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xBF7);
  }
  v5 = v3;
  for ( i = 0; i < 0x100; ++i )
  {
    *v5++ = i;
  }
  v4[0xF2] = 0x96;
  *(_DWORD *)&a1->z1[0x3012] = v4;
  v7 = operator new[](0x100u);
  v8 = sub_2625C(v7, 1, "WMGR MAPRACES");
  v9 = v8;
  if ( !v8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xC01);
  }
  v10 = v8;
  for ( j = 0; j < 0x100; ++j )
  {
    *v10++ = j;
  }
  *(_DWORD *)&a1->z1[0x3022] = v9;
  *(_DWORD *)&a1->z1[0x3006] = sub_5B617(0x80u);
  return Q_WINMGR_CPP_sub_57670(a1, "windows.txt");
}

//----- (00057670) --------------------------------------------------------
FILE *__fastcall Q_WINMGR_CPP_sub_57670(P_Type3 a1, const char *a2)
{
  FILE *result; // eax
  FILE *v4; // esi
  signed int v5; // ecx
  _DWORD *v6; // eax
  char *v7; // ebx
  void *v8; // eax
  int v9; // edx
  char *v10; // ecx
  int v11; // edx
  _BYTE *v12; // ebp
  int v13; // ecx
  P_TypeA1 v14; // edx
  __int16 kk; // cx
  P_TypeA1 v16; // edx
  __int16 v17; // ax
  P_TypeA1 v18; // edx
  P_TypeA1 v19; // edx
  int y; // ecx
  _BYTE *v21; // ebp
  int v22; // ebx
  T_TypeA9 *v23; // eax
  char *v24; // ebp
  int v25; // eax
  int i; // ecx
  unsigned int v27; // ebx
  int j; // ecx
  int v29; // eax
  __int16 v30; // dx
  int v31; // eax
  __int16 v32; // bx
  char v33; // dh
  void *v34; // eax
  T_TypeA1 *v35; // ebp
  int v36; // eax
  __int16 k; // cx
  __int16 v38; // ax
  T_TypeA2 *v39; // eax
  T_TypeA1 *v40; // ebp
  int v41; // eax
  int n; // ecx
  int v43; // eax
  __int16 ii; // cx
  __int16 v45; // ax
  T_TypeA2 *v46; // eax
  T_TypeA1 *v47; // ebp
  int v48; // eax
  int jj; // ecx
  __int16 v50; // ax
  signed __int16 v51; // cx
  unsigned __int16 v52; // bx
  T_TypeA2 *v53; // eax
  T_TypeA1 *v54; // eax
  T_TypeA1 *v55; // ecx
  int v56; // eax
  void *v57; // eax
  T_TypeA1 *v58; // ebp
  int v59; // eax
  void *v60; // eax
  T_TypeA1 *v61; // eax
  _BYTE *p_g; // edx
  int v63; // ebp
  int v64; // eax
  int v65; // [esp-Ch] [ebp-3DCh]
  int v66; // [esp-Ch] [ebp-3DCh]
  int v67; // [esp-4h] [ebp-3D4h]
  int v68; // [esp-4h] [ebp-3D4h]
  char v69[128]; // [esp+0h] [ebp-3D0h] BYREF
  char v70[128]; // [esp+80h] [ebp-350h] BYREF
  char v71[128]; // [esp+100h] [ebp-2D0h] BYREF
  char v72[128]; // [esp+180h] [ebp-250h] BYREF
  char v73[128]; // [esp+200h] [ebp-1D0h] BYREF
  char v74[128]; // [esp+280h] [ebp-150h] BYREF
  char v75[52]; // [esp+300h] [ebp-D0h] BYREF
  char s1[52]; // [esp+334h] [ebp-9Ch] BYREF
  __int16 v77[8]; // [esp+368h] [ebp-68h] BYREF
  unsigned int v78; // [esp+378h] [ebp-58h] BYREF
  P_TypeA1 v79; // [esp+37Ch] [ebp-54h]
  int v80; // [esp+380h] [ebp-50h]
  int v81; // [esp+384h] [ebp-4Ch]
  int v82; // [esp+388h] [ebp-48h]
  void **v83; // [esp+38Ch] [ebp-44h]
  void **v84; // [esp+390h] [ebp-40h]
  _BYTE *v85; // [esp+394h] [ebp-3Ch]
  _BYTE *v86; // [esp+398h] [ebp-38h]
  int m; // [esp+39Ch] [ebp-34h]
  int v88; // [esp+3A0h] [ebp-30h] BYREF
  char v89; // [esp+3A4h] [ebp-2Ch] BYREF
  __int16 v90; // [esp+3A8h] [ebp-28h]
  unsigned int v91; // [esp+3ACh] [ebp-24h]
  int v92; // [esp+3B0h] [ebp-20h]
  int v93; // [esp+3B4h] [ebp-1Ch] BYREF
  int v94; // [esp+3B8h] [ebp-18h]

  result = sub_1BB10(a2, 0);
  v4 = result;
  if ( result )
  {
    fscanf(result, "%s %d", s1, &v78);
    v5 = Q_CheckFreeMemory_sub_53DEC();
    if ( v5 <= (int)v78 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xC27);
    }
    v6 = sub_1AD1C((int)&a1[1].z1[8], v5 - 200000);
    sub_2D2CC((int)v6, v5 - 200000, (int)&a1[1].z1[8], v5);
    v81 = (int)&a1[1].z1[8];
    v84 = (void **)&a1->z1[0x3046];
    v82 = (int)&a1[1].z1[8];
    v83 = (void **)&a1->z1[0x3026];
    while ( 1 )
    {
      fscanf(v4, "%s %d", s1, &v78);
      if ( v78 == 0xFFFFFFFF )
      {
        return (FILE *)fclose(v4);
      }
      v90 = v78;
      if ( v78 < 9 )
      {
        if ( v78 < 3 )
        {
          if ( !v78 )
          {
            goto LABEL_16;
          }
          if ( v78 <= 1 )
          {
            v23 = (T_TypeA9 *)operator new(0xA09u);
            if ( v23 )
            {
              sub_2AE80(v23);
            }
            v24 = (char *)sub_2625C(v23, 2, "FLIC");
            sub_2C978((P_TypeA1)v24);
            fscanf(v4, "%s %s", s1, v24 + 0x20);
            fscanf(v4, "%s", s1);
            fscanf(v4, "%s", s1);
            if ( strcmp(s1, "NONE") )
            {
              v25 = sub_56DA8((int)a1, s1, 0);
              if ( !v25 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xCF8);
              }
              *(_DWORD *)(v24 + 0x63) = *(_DWORD *)(v25 + 0x41);
              sub_2C990(v25, (int)v24);
            }
            fscanf(v4, "%s %d", s1, &v88);
            for ( i = 0; (__int16)i < (__int16)v88; ++i )
            {
              fscanf(v4, "%d", &v78);
              if ( !sub_57220((int)a1, *(_DWORD *)(v24 + 0x41), v78) )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xD02);
              }
            }
            fscanf(v4, "%s %d", s1, v24 + 8);
            fscanf(v4, "%s %d", s1, v24 + 0xC);
            fscanf(v4, "%s %d", s1, v24 + 0x10);
            fscanf(v4, "%s %d", s1, v24 + 0x14);
            fscanf(v4, "%s %s", s1, v74);
            sub_2AF04((int)v24, v74);
            fscanf(v4, "%s %d", s1, &v78);
            *(_WORD *)(v24 + 0xA01) = v78;
            fscanf(v4, "%s %d", s1, &v78);
            *(_WORD *)(v24 + 0xA03) = v78;
            fscanf(v4, "%s %d", s1, &v78);
            *(_WORD *)(v24 + 0xA05) = v78;
            fscanf(v4, "%s %d", s1, &v78);
            *(_WORD *)(v24 + 0xA07) = v78;
            fscanf(v4, "%s %d", s1, &v78);
            v27 = v78;
            if ( v78 != 0xFFFFFFFF )
            {
              *(_DWORD *)(v24 + 0x9E5) = 0xFFFFFFFF;
              *(_DWORD *)(v24 + 0x9E9) = v27;
            }
            fscanf(v4, "%s %d", s1, v24 + 0x45);
            fscanf(v4, "%s %d", s1, v24 + 0x47);
            fscanf(v4, "%s %d", s1, v24 + 0x4B);
            fscanf(v4, "%s %s", s1, v24 + 0x4F);
            fscanf(v4, "%s %d", s1, &v78);
            *(_WORD *)(v24 + 0x9F5) = v78;
            fscanf(v4, "%s %d", s1, &v78);
            if ( v78 )
            {
              *(_DWORD *)(v24 + 0x9F1) = 0xFFFFFFFF;
            }
            *((_DWORD *)v24 + 1) = *(_DWORD *)&a1->z1[0x300A];
          }
          else
          {
            v60 = operator new(0x596u);
            if ( v60 )
            {
              v60 = sub_224A4((int)v60);
            }
            v61 = (T_TypeA1 *)sub_2625C(v60, 2, "COSW");
            p_g = &v61->g;
            v63 = (int)v61;
            sub_2C978(v61);
            dword_96BAC = *(_DWORD *)(p_g + 0x21);
            fscanf(v4, "%s %s", s1, p_g);
            fscanf(v4, "%s", s1);
            fscanf(v4, "%s", s1);
            if ( strcmp(s1, "NONE") )
            {
              v64 = sub_56DA8((int)a1, s1, 0);
              if ( !v64 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD41);
              }
              *(_DWORD *)(v63 + 0x63) = *(_DWORD *)(v64 + 0x41);
              sub_2C990(v64, v63);
            }
            fscanf(v4, "%s %d", s1, &v88);
            for ( j = 0; (__int16)j < (__int16)v88; ++j )
            {
              fscanf(v4, "%d", &v78);
              if ( !sub_57220((int)a1, *(_DWORD *)(v63 + 0x41), v78) )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xD4B);
              }
            }
            fscanf(v4, "%s %d", s1, v63 + 8);
            fscanf(v4, "%s %d", s1, v63 + 0xC);
            fscanf(v4, "%s %d", s1, v63 + 0x10);
            fscanf(v4, "%s %d", s1, v63 + 0x14);
            fscanf(v4, "%s %d", s1, &v78);
            *(_BYTE *)(v63 + 0xBF) = v78;
            fscanf(v4, "%s %s", s1, v69);
            fscanf(v4, "%s %s", s1, v70);
            Q_COSWND_CPP_sub_22644(v63, v69, v70);
            fscanf(v4, "%s %d", s1, &v78);
            fscanf(v4, "%s %d", s1, &v89);
            fscanf(v4, "%s %d", s1, &v78);
            fscanf(v4, "%s %d", s1, &v78);
            fscanf(v4, "%s %d", s1, &v78);
            fscanf(v4, "%s %d", s1, &v78);
            fscanf(v4, "%s %d", s1, &v78);
            *(_DWORD *)(v63 + 0x57E) = v78;
            fscanf(v4, "%s %d", s1, v63 + 0x45);
            fscanf(v4, "%s %d", s1, v63 + 0x47);
            fscanf(v4, "%s %d", s1, v63 + 0x4B);
            fscanf(v4, "%s %s", s1, v63 + 0x4F);
            v29 = *(_DWORD *)&a1->z1[0x300A];
            *(_WORD *)(v63 + 0x18) = 0xFFFF;
            *(_DWORD *)(v63 + 0x1A) = 0;
            v30 = HIWORD(dword_A3CF2);
            *(_BYTE *)(v63 + 0xD9) = 0;
            *(_DWORD *)(v63 + 4) = v29;
            v31 = 0;
            if ( v30 > 0 )
            {
              do
              {
                v32 = HIWORD(dword_A3CF2);
                v33 = (1 << v31++) | *(_BYTE *)(v63 + 0xD9);
                *(_BYTE *)(v63 + 0xD9) = v33;
              }
              while ( (__int16)v31 < v32 );
            }
          }
        }
        else if ( v78 <= 3 )
        {
          v34 = operator new(0xB3u);
          if ( v34 )
          {
            v34 = (void *)sub_2D9C4((int)v34);
          }
          v35 = (T_TypeA1 *)sub_2625C(v34, 2, "CTW");
          sub_2DA68(v35);
          fscanf(v4, "%s %s", s1, &v35->g);
          fscanf(v4, "%s", s1);
          fscanf(v4, "%s", s1);
          if ( strcmp(s1, "NONE") )
          {
            v36 = sub_56DA8((int)a1, s1, 0);
            if ( !v36 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD8D);
            }
            v35->v = *(_DWORD *)(v36 + 0x41);
            sub_2C990(v36, (int)v35);
          }
          fscanf(v4, "%s %d", s1, &v88);
          for ( k = 0; k < (__int16)v88; ++k )
          {
            fscanf(v4, "%d", &v78);
            if ( !sub_57220((int)a1, v35->l, v78) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xD97);
            }
            if ( !k )
            {
              v38 = *(_WORD *)&a1->z1[0x8E * v78 + 0x30EA];
              v35->e = 0;
              v35->d = v38;
            }
          }
          fscanf(v4, "%s %d", s1, v35->c);
          fscanf(v4, "%s %d", s1, &v35->c[4]);
          fscanf(v4, "%s %d", s1, &v35->c[8]);
          fscanf(v4, "%s %d", s1, &v35->c[0xC]);
          fscanf(v4, "%s %d", s1, &v78);
          v35->f = v78;
          v35->r = 0;
          fscanf(v4, "%s %d", s1, &v35->m);
          fscanf(v4, "%s %d", s1, &v35->n);
          fscanf(v4, "%s %d", s1, &v35->o);
          fscanf(v4, "%s %s", s1, &v35->p);
          v35->b = *(_DWORD *)&a1->z1[0x300A];
          fscanf(v4, "%s %d", s1, &v93);
          if ( !sub_2DA80((int)v35, v93) )
          {
            Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xDB9);
          }
          for ( m = 0; (__int16)m < (__int16)v93; ++m )
          {
            fscanf(v4, "%s %d", s1, &v78);
            v77[0] = v78;
            fscanf(v4, "%d", &v78);
            v77[1] = v78;
            fscanf(v4, "%d", &v78);
            v77[3] = v78;
            fscanf(v4, "%d", &v78);
            v77[2] = v78;
            fscanf(v4, "%d", &v78);
            v77[4] = v78;
            fscanf(v4, "%d", &v78);
            v77[5] = v78;
            fscanf(v4, "%d", &v78);
            v77[6] = v78;
            if ( !sub_2DAC8((int)v35, 0, 0, (int)v77) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xDD4);
            }
          }
          LOWORD(v94) = 0;
          if ( SHIWORD(dword_A3CF2) > 0 )
          {
            do
            {
              sub_2DAC8((int)v35, 1 << v94, 1, 0);
              LOWORD(v94) = v94 + 1;
            }
            while ( (__int16)v94 < SHIWORD(dword_A3CF2) );
          }
        }
        else if ( v78 < 5 )
        {
          v39 = (T_TypeA2 *)operator new(0x504Eu);
          if ( v39 )
          {
            v39 = (T_TypeA2 *)sub_15ED4(v39);
          }
          v40 = (T_TypeA1 *)sub_2625C(v39, 2, "BM");
          sub_2C978(v40);
          fscanf(v4, "%s %s", s1, &v40->g);
          fscanf(v4, "%s", s1);
          fscanf(v4, "%s", s1);
          if ( strcmp(s1, "NONE") )
          {
            v41 = sub_56DA8((int)a1, s1, 0);
            if ( !v41 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xDE9);
            }
            v40->v = *(_DWORD *)(v41 + 0x41);
            sub_2C990(v41, (int)v40);
          }
          fscanf(v4, "%s %d", s1, &v88);
          for ( n = 0; (__int16)n < (__int16)v88; ++n )
          {
            fscanf(v4, "%d", &v78);
            if ( !sub_57220((int)a1, v40->l, v78) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xDF3);
            }
          }
          fscanf(v4, "%s %d", s1, v40->c);
          fscanf(v4, "%s %d", s1, &v40->c[4]);
          fscanf(v4, "%s %d", s1, &v40->c[8]);
          fscanf(v4, "%s %d", s1, &v40->c[0xC]);
          fscanf(v4, "%s %d", s1, &v78);
          BYTE2(v40[0x79].k) = v78;
          fscanf(v4, "%s %d", s1, &v78);
          *(_DWORD *)&v40[1].c[9] = v78;
          sub_18370((int)v40);
          fscanf(v4, "%s %d", s1, &v40->m);
          fscanf(v4, "%s %d", s1, &v40->n);
          fscanf(v4, "%s %d", s1, &v40->o);
          fscanf(v4, "%s %s", s1, &v40->p);
          v43 = *(_DWORD *)&a1->z1[0x300A];
          v40->d = 0xFFFF;
          v40->e = 0;
          v40->b = v43;
        }
        else
        {
          if ( v78 <= 7 )
          {
            goto LABEL_16;
          }
          v57 = operator new(0x237u);
          if ( v57 )
          {
            v57 = sub_4D92C((int)v57);
          }
          v58 = (T_TypeA1 *)sub_2625C(v57, 2, "SW");
          sub_2C978(v58);
          fscanf(v4, "%s %s", s1, &v58->g);
          fscanf(v4, "%s", s1);
          fscanf(v4, "%s", s1);
          if ( strcmp(s1, "NONE") )
          {
            v59 = sub_56DA8((int)a1, s1, 0);
            if ( !v59 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xE21);
            }
            v58->v = *(_DWORD *)(v59 + 0x41);
            sub_2C990(v59, (int)v58);
          }
          fscanf(v4, "%s %d", s1, &v88);
          for ( ii = 0; ii < (__int16)v88; ++ii )
          {
            fscanf(v4, "%d", &v78);
            if ( !sub_57220((int)a1, v58->l, v78) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xE2B);
            }
            if ( !ii )
            {
              v45 = *(_WORD *)&a1->z1[0x8E * v78 + 0x30EA];
              v58->e = 0;
              v58->d = v45;
            }
          }
          fscanf(v4, "%s %d", s1, &v78);
          if ( v78 )
          {
            v58->k = 0xFFFFFFFF;
          }
          fscanf(v4, "%s %d", s1, v58->c);
          fscanf(v4, "%s %d", s1, &v58->c[4]);
          fscanf(v4, "%s %d", s1, &v58->c[8]);
          fscanf(v4, "%s %d", s1, &v58->c[0xC]);
          fscanf(v4, "%s %d", s1, &v78);
          v58->r = v78;
          fscanf(v4, "%s %d", s1, &v58->m);
          fscanf(v4, "%s %d", s1, &v58->n);
          fscanf(v4, "%s %d", s1, &v58->o);
          fscanf(v4, "%s %s", s1, &v58->p);
          v58->b = *(_DWORD *)&a1->z1[0x300A];
        }
      }
      else
      {
        if ( v78 <= 9 )
        {
          goto LABEL_16;
        }
        if ( v78 < 0xE )
        {
          if ( v78 < 0xB )
          {
            v46 = (T_TypeA2 *)operator new(0x902u);
            if ( v46 )
            {
              v46 = sub_2E248(v46);
            }
            v47 = (T_TypeA1 *)sub_2625C(v46, 2, "LB");
            sub_2E3BC(v47);
            fscanf(v4, "%s %s", s1, &v47->g);
            fscanf(v4, "%s", s1);
            fscanf(v4, "%s", s1);
            if ( strcmp(s1, "NONE") )
            {
              v48 = sub_56DA8((int)a1, s1, 0);
              if ( !v48 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xE5E);
              }
              v47->v = *(_DWORD *)(v48 + 0x41);
              sub_2C990(v48, (int)v47);
            }
            fscanf(v4, "%s %d", s1, &v88);
            for ( jj = 0; (__int16)jj < (__int16)v88; ++jj )
            {
              fscanf(v4, "%d", &v78);
              if ( !sub_57220((int)a1, v47->l, v78) )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xE68);
              }
            }
            fscanf(v4, "%s %d", s1, &v78);
            if ( v78 )
            {
              v47->k = 0xFFFFFFFF;
            }
            fscanf(v4, "%s %d", s1, v47->c);
            fscanf(v4, "%s %d", s1, &v47->c[4]);
            fscanf(v4, "%s %d", s1, &v47->c[8]);
            fscanf(v4, "%s %d", s1, &v47->c[0xC]);
            fscanf(v4, "%s %d", s1, &v78);
            v47->f = v78;
            fscanf(v4, "%s %d", s1, &v78);
            v47->r = v78;
            fscanf(v4, "%s %d", s1, &v47->m);
            fscanf(v4, "%s %d", s1, &v47->n);
            fscanf(v4, "%s %d", s1, &v47->o);
            fscanf(v4, "%s %s", s1, &v47->p);
            v47->b = *(_DWORD *)&a1->z1[0x300A];
          }
          else
          {
            if ( v78 <= 0xC )
            {
              goto LABEL_16;
            }
            v53 = (T_TypeA2 *)operator new(0xC0u);
            if ( v53 )
            {
              v53 = sub_5A594(v53);
            }
            v54 = (T_TypeA1 *)sub_2625C(v53, 2, "DBGWND");
            v55 = v54;
            if ( !v54 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xE8E);
            }
            sub_5A5F4(v54);
            *(_DWORD *)&a1->z3[0x1D4E4] = v55;
            fscanf(v4, "%s %s", s1, &v55->g);
            fscanf(v4, "%s %d", s1, v55->c);
            fscanf(v4, "%s %d", s1, &v55->c[4]);
            fscanf(v4, "%s %d", s1, &v55->c[8]);
            fscanf(v4, "%s %d", s1, &v55->c[0xC]);
            fscanf(v4, "%s %d", s1, v55[1].c);
            fscanf(v4, "%s %d", s1, &v55[1].c[4]);
            fscanf(v4, "%s %d", s1, &v55[1].c[8]);
            fscanf(v4, "%s %d", s1, &v55[1].c[0xC]);
            fscanf(v4, "%s %s", s1, v75);
            v55->d = sub_1ADAC(v81, v75);
            v56 = *(_DWORD *)&a1->z1[0x300A];
            v55->b = v56;
            v55[1].b = v56;
          }
        }
        else
        {
          if ( v78 <= 0x1B )
          {
            goto LABEL_16;
          }
          if ( v78 < 0x64 )
          {
            if ( v78 >= 0x1D && v78 <= 0x20 )
            {
LABEL_16:
              if ( v78 )
              {
                switch ( v78 )
                {
                  case 5u:
                    v7 = "RW";
                    v8 = operator new(0xABu);
                    if ( v8 )
                    {
                      v8 = sub_25BF8((P_TypeA2)v8);
                    }
                    v9 = 2;
                    break;
                  case 6u:
                    v7 = "RSW";
                    v8 = operator new(0xB1u);
                    if ( v8 )
                    {
                      v8 = (void *)sub_25CB8((int)v8);
                    }
                    v9 = 2;
                    break;
                  case 7u:
                    v7 = "PW";
                    v8 = operator new(0x18Cu);
                    if ( v8 )
                    {
                      v8 = sub_372B0((T_TypeA2 *)v8, (int)v8, (int)"PW", 2);
                    }
                    v9 = 2;
                    break;
                  case 0xBu:
                    v7 = "LW";
                    v8 = operator new(0xFE0u);
                    if ( v8 )
                    {
                      v8 = sub_31200((T_TypeA2 *)v8);
                    }
                    v9 = 2;
                    break;
                  case 0xCu:
                    v7 = "IW";
                    v8 = operator new(0xAFu);
                    if ( v8 )
                    {
                      sub_33598((P_TypeA4)v8);
                    }
                    v9 = 2;
                    break;
                  case 9u:
                    v8 = operator new(0x9DDu);
                    v80 = 2;
                    if ( v8 )
                    {
                      sub_2C830((P_TypeA2)v8);
                      v10 = (char *)sub_1B4F0((char *)v8 + 0xAB) + 0xFFFFFF55 + 0x143;
                      v11 = _wcpp_2_ctor_array_(v10, 0x64, &unk_959D8) - 0x143;
                      *(_DWORD *)(v11 + 0xA7) = off_96018;
                      sub_46CAC(v11, v11, (int)&unk_959D8, (int)v10);
                      v8 = (void *)v11;
                    }
                    v9 = v80;
                    v7 = "RW";
                    break;
                  case 0xEu:
                    v7 = "PSW";
                    v8 = operator new(0xADu);
                    if ( v8 )
                    {
                      v8 = sub_39D80((T_TypeA2 *)v8);
                    }
                    v9 = 2;
                    break;
                  case 0xFu:
                    v7 = "NT";
                    v8 = operator new(0xAFu);
                    if ( v8 )
                    {
                      v8 = sub_2F2F4((T_TypeA2 *)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x10u:
                    v7 = "SW";
                    v8 = operator new(0xB1u);
                    if ( v8 )
                    {
                      v8 = sub_51674((T_TypeA2 *)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x11u:
                    v7 = "FW";
                    v8 = operator new(0xB1u);
                    if ( v8 )
                    {
                      v8 = sub_51B64((T_TypeA2 *)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x12u:
                    v7 = "NG";
                    v8 = operator new(0xBDu);
                    if ( v8 )
                    {
                      v8 = sub_520EC((T_TypeA2 *)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x13u:
                    v9 = 2;
                    v8 = operator new(0x108u);
                    if ( v8 )
                    {
                      sub_10A3C((P_TypeA8)v8);
                    }
                    v7 = "BC";
                    break;
                  case 0x14u:
                    v7 = "HW";
                    v8 = operator new(0xDAFu);
                    if ( v8 )
                    {
                      sub_2FC50((P_TypeA2)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x15u:
                    v9 = 2;
                    v8 = operator new(0xC3u);
                    if ( v8 )
                    {
                      sub_3201C((P_TypeA7)v8);
                    }
                    v7 = "NW";
                    break;
                  case 0x16u:
                    v7 = "AW";
                    v8 = operator new(0xDAFu);
                    if ( v8 )
                    {
                      sub_33830((P_TypeA6)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x17u:
                    v7 = "EW";
                    v8 = operator new(0xDB3u);
                    if ( v8 )
                    {
                      sub_267A0((P_TypeA5)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x18u:
                    v7 = "EW";
                    v8 = operator new(0xABu);
                    if ( v8 )
                    {
                      sub_27BF8((P_TypeA2)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x19u:
                    v7 = "TW";
                    v8 = operator new(0xAFu);
                    if ( v8 )
                    {
                      sub_2D464((P_TypeA4)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x1Au:
                    v7 = "MW";
                    v8 = operator new(0xB3u);
                    if ( v8 )
                    {
                      sub_2FA18((P_TypeA3)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x1Du:
                    v7 = "GSW";
                    v8 = operator new(0xABu);
                    if ( v8 )
                    {
                      sub_395EC((P_TypeA2)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x1Eu:
                    v7 = "EW";
                    v8 = operator new(0xABu);
                    if ( v8 )
                    {
                      sub_2712C((T_TypeA2 *)v8);
                    }
                    v9 = 2;
                    break;
                  case 0x1Fu:
                    v7 = "pcw";
                    v9 = 2;
                    v8 = operator new(0xABu);
                    if ( v8 )
                    {
                      sub_2C830((P_TypeA2)v8);
                      *(_DWORD *)((char *)v8 + 0xA7) = off_961DC;
                    }
                    break;
                  case 0x20u:
                    v7 = "miw";
                    v9 = 2;
                    v8 = operator new(0xABu);
                    if ( v8 )
                    {
                      sub_2C830((P_TypeA2)v8);
                      *(_DWORD *)((char *)v8 + 0xA7) = off_961C4;
                    }
                    break;
                  default:
                    goto LABEL_111;
                }
              }
              else
              {
                v7 = "GW";
                v8 = operator new(0xABu);
                if ( v8 )
                {
                  sub_2C830((P_TypeA2)v8);
                }
                v9 = 2;
              }
              v79 = (P_TypeA1)sub_2625C(v8, v9, v7);
LABEL_111:
              v12 = &v79->g;
              sub_2C978(v79);
              fscanf(v4, "%s %s", s1, v12);
              fscanf(v4, "%s", s1);
              fscanf(v4, "%s", s1);
              if ( strcmp(s1, "NONE") )
              {
                v13 = sub_56DA8((int)a1, s1, 0);
                if ( !v13 )
                {
                  sub_2620C("%s bad parent", (char)v12);
                  sub_261B8(0, "..\\winmgr.cpp", 0xC8D);
                }
                v14 = v79;
                v79->v = *(_DWORD *)(v13 + 0x41);
                sub_2C990(v13, (int)v14);
              }
              fscanf(v4, "%s %d", s1, &v88);
              for ( kk = 0; kk < (__int16)v88; ++kk )
              {
                fscanf(v4, "%d", &v78);
                if ( !sub_57220((int)a1, v79->l, v78) )
                {
                  Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xC97);
                }
                if ( !kk )
                {
                  v16 = v79;
                  v17 = *(_WORD *)&a1->z1[0x8E * v78 + 0x30EA];
                  v79->e = 0;
                  v16->d = v17;
                }
              }
              fscanf(v4, "%s %d", s1, &v78);
              if ( v78 )
              {
                v79->k = 0xFFFFFFFF;
              }
              if ( v90 == 0x19 )
              {
                fscanf(v4, "%s %d", s1, &v78);
                if ( v78 )
                {
                  v79[1].b = 0xFFFFFFFF;
                }
              }
              fscanf(v4, "%s %d", s1, v79->c);
              fscanf(v4, "%s %d", s1, &v79->c[4]);
              fscanf(v4, "%s %d", s1, &v79->c[8]);
              fscanf(v4, "%s %d", s1, &v79->c[0xC]);
              fscanf(v4, "%s %d", s1, &v78);
              v18 = v79;
              v79->f = v78;
              if ( v90 == 0xF )
              {
                fscanf(v4, "%s %d", s1, &v78);
                v18[1].b = v78;
              }
              fscanf(v4, "%s %d", s1, &v78);
              v19 = v79;
              v79->r = v78;
              fscanf(v4, "%s %d", s1, &v19->m);
              fscanf(v4, "%s %d", s1, &v19->n);
              fscanf(v4, "%s %d", s1, &v19->o);
              fscanf(v4, "%s %s", s1, &v19->p);
              fscanf(v4, "%s %d", s1, &v78);
              y = (int)v19->y;
              v92 = 0;
              v91 = v78;
              if ( (__int16)v78 > 0 )
              {
                v21 = &v19->y[9];
                v85 = &v19->y[0xB];
                v86 = &v19->y[5];
                do
                {
                  fscanf(v4, "%s %d", s1, &v78);
                  if ( v78 )
                  {
                    if ( v78 == 1 )
                    {
                      v68 = (int)v85;
                      v66 = (int)v86;
                      *(_BYTE *)y = 1;
                      fscanf(v4, "%s %d %d %d", s1, v66, v21, v68);
                      *(_DWORD *)(y + 1) = (unsigned __int16)sub_1B270((int)&unk_12FC20, s1, 0xFFFFFFFF);
                    }
                    else
                    {
                      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xCE1);
                    }
                  }
                  else
                  {
                    v67 = (int)v85;
                    v65 = (int)v86;
                    *(_BYTE *)y = 0;
                    fscanf(v4, "%s %d %d %d", s1, v65, v21, v67);
                    *(_DWORD *)(y + 1) = sub_2D334(s1);
                  }
                  v22 = (int)v85;
                  sub_2D400((int)v79, y);
                  v21 += 0xD;
                  y += 0xD;
                  v85 = (_BYTE *)(v22 + 0xD);
                  ++v92;
                  v86 += 0xD;
                }
                while ( (__int16)v92 < (__int16)v91 );
              }
              v79->b = *(_DWORD *)&a1->z1[0x300A];
            }
            else
            {
LABEL_262:
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xEF2);
            }
          }
          else if ( v78 <= 0x64 )
          {
            fscanf(v4, "%s %d", s1, &v78);
            fscanf(v4, "%s %s", s1, v72);
            v50 = sub_1ADAC(v82, v72);
            if ( !sub_5748C((int)a1, v78, v50) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xECA);
            }
          }
          else
          {
            if ( v78 < 0xC8 )
            {
              goto LABEL_262;
            }
            if ( v78 <= 0xC8 )
            {
              fscanf(v4, "%s %d", s1, &v78);
              v51 = 0;
              sub_2C08C((int)&V_Type6_stru_D8654, v78);
              while ( v51 < (int)v78 )
              {
                v52 = v51;
                fscanf(v4, "%s %s", s1, v71);
                ++v51;
                sub_2C0C0((int)&V_Type6_stru_D8654, v71, v52);
              }
            }
            else
            {
              if ( v78 != 0x12C )
              {
                goto LABEL_262;
              }
              fscanf(v4, "%s %s", s1, v73);
              if ( sub_2B360(v83, v73) != 0xFFFFFFFF )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xEE6);
              }
              *(_DWORD *)&a1->z1[0x3042] = 0;
              fscanf(v4, "%s %s", s1, v73);
              if ( sub_2B360(v84, v73) != 0xFFFFFFFF )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xEEB);
              }
              *(_DWORD *)&a1->z1[0x3062] = 0;
            }
          }
        }
      }
    }
  }
  return result;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 96018: using guessed type int (*off_96018[5])();
// 961C4: using guessed type int (*off_961C4[5])();
// 961DC: using guessed type int (*off_961DC[5])();
// 96BAC: using guessed type int dword_96BAC;
// A3CF2: using guessed type int dword_A3CF2;
// 57670: using guessed type char var_150[128];
// 57670: using guessed type char var_350[128];
// 57670: using guessed type char var_250[128];
// 57670: using guessed type char var_2D0[128];
// 57670: using guessed type char var_D0[52];
// 57670: using guessed type char anonymous_0[128];

//----- (00059828) --------------------------------------------------------
T_Type1 *__fastcall sub_59828(int a1, int a2, int a3, int a4)
{
  T_Type1 *result; // eax
  T_Type1 v6; // [esp-124h] [ebp-128h] BYREF
  int v7; // [esp-4h] [ebp-8h]

  v7 = a4;
  Q_InitFileInfo_sub_1BB78(&v6);
  if ( !Q_CfilePreload_sub_1BBFC(&v6, "ascend.cfg", 0x200, 0) )
  {
    sub_1BF94(&v6, &dword_10935F, 4u);
    sub_1BF94(&v6, &dword_109377, 4u);
    sub_1BF94(&v6, (char *)&loc_24DAA + a1 + 2, 4u);
  }
  result = &v6;
  Q_CloseFileAndDelete_sub_1BBC8(&v6);
  return result;
}
// 59886: returning address of temporary local variable '%0x0'
// 10935F: using guessed type int dword_10935F;
// 109377: using guessed type int dword_109377;

//----- (0005989C) --------------------------------------------------------
void __fastcall sub_5989C(P_Type3 a1, int a2, int a3, int a4)
{
  T_Type1 v5; // [esp-120h] [ebp-124h] BYREF
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]

  v7 = a4;
  v6 = a2;
  Q_InitFileInfo_sub_1BB78(&v5);
  if ( !sub_1BCA8(&v5, "ascend.cfg") )
  {
    sub_1C098((unsigned int)&v5, (int)&dword_10935F, 4u);
    sub_1C098((unsigned int)&v5, (int)&dword_109377, 4u);
    sub_1C098((unsigned int)&v5, (int)&a1->z1[(_DWORD)&loc_24DAA + 2], 4u);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v5);
}
// 10935F: using guessed type int dword_10935F;
// 109377: using guessed type int dword_109377;

//----- (00059908) --------------------------------------------------------
int __fastcall sub_59908(int result)
{
  if ( !*(_DWORD *)(result + 0x48A6) && !*(_DWORD *)(result + 0x48AA) )
  {
    *(_DWORD *)(result + 0x48A6) = 0xFFFFFFFF;
    *(_DWORD *)(result + 0x48BA) = 0;
    *(_DWORD *)(result + 0x48B6) = 0;
  }
  return result;
}

//----- (00059934) --------------------------------------------------------
void __fastcall sub_59934(T_Type3 *a1, int a2, int a3)
{
  if ( a1->aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    if ( a1->aaa == 0xFFFFFFFF )
    {
      a1->aaa = 0;
      sub_59DE0((int)a1, a2, a3, (int)a1);
      if ( a2 )
      {
        sub_59E88(a1, "WINEVENT.BIN", "WINEVENT.TXT");
      }
    }
    a1->bbb = 0;
  }
}

//----- (00059988) --------------------------------------------------------
unsigned int __fastcall sub_59988(P_Type3 a1, char *a2, int a3)
{
  char *v4; // edi
  char v6; // al
  char v7; // al
  const char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  int aaa; // ecx
  unsigned int result; // eax

  v4 = byte_132B20;
  do
  {
    v6 = *a2;
    *v4 = *a2;
    if ( !v6 )
    {
      break;
    }
    v7 = a2[1];
    a2 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  v8 = ".txt";
  v9 = &byte_132B20[strlen(byte_132B20) - 4];
  do
  {
    v10 = *v8;
    *v9 = *v8;
    if ( !v10 )
    {
      break;
    }
    v11 = v8[1];
    v8 += 2;
    v9[1] = v11;
    v9 += 2;
  }
  while ( v11 );
  dword_132B14 = dword_D862C;
  aaa = a1->aaa;
  dword_132B18 = dword_D8630;
  if ( aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    return 0;
  }
  result = sub_59CFC((int)a1, a2);
  if ( result )
  {
    a1->bbb = 0xFFFFFFFF;
    *(_DWORD *)&a1->z3[8] = 0;
    result = 0xFFFFFFFF;
    *(_DWORD *)&a1->z3[0x10] = 0;
    *(_DWORD *)a1->z3 = a3;
    dword_132B1C = 0;
  }
  return result;
}
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// 132B14: using guessed type int dword_132B14;
// 132B18: using guessed type int dword_132B18;
// 132B1C: using guessed type int dword_132B1C;

//----- (00059A54) --------------------------------------------------------
int __fastcall sub_59A54(int result)
{
  int v1; // ecx
  unsigned int v2; // edi
  int v3; // ebp
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // esi
  unsigned int v7; // eax
  int v8; // [esp+0h] [ebp-1Ch]

  v1 = result;
  if ( *(_DWORD *)(result + 0x48AA) )
  {
    v8 = dword_D8648;
    dword_D862C = dword_132B14;
    v2 = 0xFFFFFFFF;
    dword_D8630 = dword_132B18;
    v3 = dword_D864C;
    sub_2656C((__int16)&unk_D85F8);
    if ( dword_D85FC == 0xFFFFFFFF
      || dword_D8638 == 0xFFFFFFFF && dword_D862C
      || dword_D863C == 0xFFFFFFFF && dword_D8630 )
    {
      v4 = dword_D8648;
      *(_DWORD *)(v1 + 0x48AA) = 0;
      v3 = dword_D864C;
      v8 = v4;
      v5 = 0;
      if ( !*(_DWORD *)(v1 + 0x489E) )
      {
        v6 = (_DWORD *)sub_56DA8(v1, "HELPWINDOW", 0);
        sub_2FCB0(v6, "help.txt", "endtut");
        v5 = sub_552F8(v1);
      }
      if ( v5 )
      {
        v7 = time(0);
        srand(v7);
        v2 = 0;
        *(_DWORD *)((char *)&loc_24DAA + v1 + 2) = dword_96BBC;
      }
      else
      {
        *(_DWORD *)(v1 + 0x48AA) = 0xFFFFFFFF;
      }
    }
    if ( v2 )
    {
      dword_D864C = v3;
      dword_D8644 = 0;
      dword_D8648 = v8;
    }
    dword_132B14 = dword_D862C;
    result = dword_D8630;
    dword_132B18 = dword_D8630;
  }
  return result;
}
// 96BBC: using guessed type int dword_96BBC;
// D85FC: using guessed type int dword_D85FC;
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// D8648: using guessed type int dword_D8648;
// D864C: using guessed type int dword_D864C;
// 132B14: using guessed type int dword_132B14;
// 132B18: using guessed type int dword_132B18;

//----- (00059B80) --------------------------------------------------------
void __fastcall sub_59B80(int a1)
{
  int v2; // esi
  int v3; // eax
  int v4; // eax
  unsigned __int16 v5; // dx
  int v6; // edx
  int v7; // ebx

  v2 = a1 + 0x48C2;
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D8644 = 0;
  dword_D85FC = 0;
  while ( 1 )
  {
    v3 = 0x18 * *(_DWORD *)(a1 + 0x48BE);
    if ( *(_DWORD *)(a1 + 0x48B6) < *(_DWORD *)(a1 + v3 + 0x48C2) )
    {
      break;
    }
    v4 = v2 + v3;
    v5 = *(_WORD *)(v4 + 8);
    if ( !v5 )
    {
      goto LABEL_5;
    }
    if ( v5 <= 3u )
    {
      sub_265A8(v4);
    }
    else if ( v5 > 7u )
    {
LABEL_5:
      sprintf(
        "Thank you for playing Ascendancy.",
        "\nBad Trace Event: %d of %d\n\nEVENT[%d] HWND[%0d] MSG[%d] P1[%d] P2[%d]\n",
        *(_DWORD *)(a1 + 0x48BE),
        *(_DWORD *)(a1 + 0x48BA),
        *(__int16 *)(v4 + 8),
        *(_DWORD *)(v4 + 4),
        *(__int16 *)(v4 + 0xA),
        *(_DWORD *)(v4 + 0xC),
        *(_DWORD *)(v4 + 0x10));
      Q_debugbreak_exit_sub_2624C();
    }
    v6 = *(_DWORD *)(a1 + 0x48BE) + 1;
    v7 = *(_DWORD *)(a1 + 0x48BA);
    *(_DWORD *)(a1 + 0x48BE) = v6;
    if ( v6 >= v7 )
    {
      if ( *(_DWORD *)(a1 + 0x48AE) != 0xFFFFFFFF )
      {
        sub_59934((T_Type3 *)a1, 0, v7);
        return;
      }
      *(_DWORD *)(a1 + 0x48BE) = 0;
      *(_DWORD *)(a1 + 0x48B6) = 0;
    }
  }
}
// D85FC: using guessed type int dword_D85FC;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;

//----- (00059C80) --------------------------------------------------------
void __fastcall sub_59C80(T_Type3 *a1, int a2, __int16 a3, __int16 a4, int a5, int a6, int a7)
{
  char *v8; // edx
  int v9; // edi

  if ( a1->aaa == 0xFFFFFFFF && !a1->bbb )
  {
    v8 = &a1->z3[0x18 * *(_DWORD *)&a1->z3[0xC] + 0x14];
    *(_DWORD *)v8 = *(_DWORD *)&a1->z3[8];
    *((_DWORD *)v8 + 1) = a2;
    *((_WORD *)v8 + 4) = a3;
    *((_WORD *)v8 + 5) = a4;
    *((_DWORD *)v8 + 3) = a5;
    *((_DWORD *)v8 + 4) = a6;
    *((_DWORD *)v8 + 5) = a7;
    v9 = *(_DWORD *)&a1->z3[0xC] + 1;
    *(_DWORD *)&a1->z3[0xC] = v9;
    if ( v9 == 0x1388 )
    {
      sub_59934(a1, 0, a3);
    }
  }
}

//----- (00059CFC) --------------------------------------------------------
unsigned int __fastcall sub_59CFC(int a1, const char *a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // eax
  T_Type1 v6; // [esp+0h] [ebp-124h] BYREF

  Q_InitFileInfo_sub_1BB78(&v6);
  if ( *(_DWORD *)(a1 + 0x48A6) == 0xFFFFFFFF )
  {
    Q_CloseFileAndDelete_sub_1BBC8(&v6);
    return 0;
  }
  else
  {
    if ( Q_CfilePreload_sub_1BBFC(&v6, a2, 0x200, 0) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x104F);
    }
    if ( (unsigned int)sub_1BE28(&v6) > 0x1D4D0 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1052);
    }
    sub_1BF94(&v6, (void *)(a1 + 0x21D82), 0x10u);
    v4 = sub_1BF94(&v6, (void *)(a1 + 0x48C2), 0x1D4C0u);
    *(_DWORD *)(a1 + 0x48BA) = v4 / 0x18;
    if ( v4 % 0x18 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x1059);
    }
    v3 = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x48BE) = 0;
    Q_CloseFileAndDelete_sub_1BBC8(&v6);
  }
  return v3;
}

//----- (00059DE0) --------------------------------------------------------
void __fastcall sub_59DE0(int a1, int a2, int a3, int a4)
{
  T_Type1 v5; // [esp-124h] [ebp-128h] BYREF
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]

  v7 = a4;
  v6 = a2;
  Q_InitFileInfo_sub_1BB78(&v5);
  if ( *(_DWORD *)(a1 + 0x48A6) != 0xFFFFFFFF )
  {
    if ( Q_CfilePreload_sub_1BBFC(&v5, "WINEVENT.BIN", 0x21, 0) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x106C);
    }
    sub_1C098((unsigned int)&v5, a1 + 0x21D82, 0x10u);
    sub_1C098((unsigned int)&v5, a1 + 0x48C2, 0x18 * *(_DWORD *)(a1 + 0x48BA));
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v5);
}

//----- (00059E88) --------------------------------------------------------
char *__fastcall sub_59E88(T_Type3 *a1, char *a2, char *filename)
{
  char *result; // eax
  FILE *v5; // ecx
  __int16 i; // bx
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  char *v11; // edx
  const char *v12; // [esp-4h] [ebp-8h]

  result = filename;
  if ( !a1->aaa && !a1->bbb )
  {
    v5 = fopen(filename, "w");
    if ( !v5 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x107D);
    }
    if ( sub_59CFC((int)a1, a2) != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x1080);
    }
    for ( i = 0; i < *(_DWORD *)&a1->z3[0xC]; ++i )
    {
      v11 = &a1->z3[0x18 * i + 0x14];
      switch ( *((_WORD *)v11 + 4) )
      {
        case 1:
          fprintf(v5, " TIME[%05lu]  EVT_MOUSE_POS    : ", *(_DWORD *)v11);
          fprintf(v5, " Moved to (%03d,%03d)\n", *((_DWORD *)v11 + 3), *((_DWORD *)v11 + 4));
          break;
        case 2:
          fprintf(v5, " TIME[%05lu]  EVT_MOUSE_BUTTON :  ", *(_DWORD *)v11);
          if ( *((_DWORD *)v11 + 4) )
          {
            v7 = "DOWN";
          }
          else
          {
            v7 = "UP";
          }
          v12 = v7;
          if ( *((_DWORD *)v11 + 3) )
          {
            v8 = "Right";
          }
          else
          {
            v8 = "Left";
          }
          fprintf(v5, "%s Button %s\n", v8, v12);
          break;
        case 3:
          fprintf(v5, " TIME[%05lu]  EVT_KEYBOARD     : ", *(_DWORD *)v11);
          fprintf(v5, " '%c'  (%04d)\n", v11[0x10], *((_DWORD *)v11 + 3));
          break;
        case 4:
        case 5:
          if ( *((_WORD *)v11 + 4) == 4 )
          {
            v9 = "EVT_REQ_CONT";
          }
          else
          {
            v9 = "EVT_CAN_CONT";
          }
          fprintf(v5, " TIME[%05lu]  %-15s: ", *(_DWORD *)v11, v9);
          fprintf(
            v5,
            " HWND[%04d] MSG[%04d] P1[%04d] P2[%04d]\n",
            *((_DWORD *)v11 + 1),
            *((__int16 *)v11 + 5),
            *((_DWORD *)v11 + 3),
            *((_DWORD *)v11 + 4));
          break;
        case 6:
        case 7:
          if ( *((_WORD *)v11 + 4) == 6 )
          {
            v10 = "EVT_REQ_CHANGE";
          }
          else
          {
            v10 = "EVT_CAN_CHANGE";
          }
          fprintf(v5, " TIME[%05lu]  %-15s: ", *(_DWORD *)v11, v10);
          fprintf(
            v5,
            " HWND[%04d] MSG[%04d] P1[%04d] P2[%04d] F[%04d]\n",
            *((_DWORD *)v11 + 1),
            *((__int16 *)v11 + 5),
            *((_DWORD *)v11 + 3),
            *((_DWORD *)v11 + 4),
            *((_DWORD *)v11 + 5));
          break;
        default:
          fprintf(v5, " *** Unrecognized event type : %d\n", *((__int16 *)v11 + 4));
          break;
      }
    }
    return (char *)fclose(v5);
  }
  return result;
}

//----- (0005A094) --------------------------------------------------------
void __fastcall Q_WINMGR_CPP_sub_5A094(T_Type3 *a1, void *aData, int a3, char *a4)
{
  __int16 i; // kr00_2
  int v6; // eax
  char *text; // edi

  if ( a1->counter2 == 0x180 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x10CB);
  }
  for ( i = 0; i < 384; ++i )
  {
    if ( !a1->c[i].pData )
    {
      a1->c[i].pData = aData;
      a1->c[i].a = a3;
      text = a1->c[i].text;
      strncpy(text, a4, 19u);
      *(_BYTE *)(v6 + 0x20 * i + 138673) = 0;
      strupr(text);
      *(_DWORD *)(v6 + 0x20 * i + 0x21D9A) = dword_132B58;
      ++a1->counter2;
      return;
    }
  }
  Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x10DD);
}
// 132B58: using guessed type int dword_132B58;

//----- (0005A144) --------------------------------------------------------
void __fastcall Q_WINMGR_CPP_sub_5A144(P_Type3 a1, void *a2)
{
  __int16 i; // kr00_2

  if ( a2 )
  {
    for ( i = 0; i < 0x180; ++i )
    {
      if ( a2 == a1->c[i].pData )
      {
        a1->c[i].pData = 0;
        --a1->counter2;
        return;
      }
    }
    Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x10F1);
  }
}

//----- (0005A194) --------------------------------------------------------
char *__fastcall sub_5A194(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  __int16 v6; // dx
  __int16 v7; // ax
  int v8; // edx

  v6 = *(_WORD *)(a1 + 0x24D96);
  v7 = 0;
  if ( v6 <= 0 )
  {
    return 0;
  }
  while ( 1 )
  {
    v8 = a1 + 0x20 * v7;
    if ( a2 == *(_DWORD *)((char *)&loc_21DB2 + v8) )
    {
      break;
    }
    if ( ++v7 >= *(__int16 *)(a1 + 0x24D96) )
    {
      return 0;
    }
  }
  if ( a3 )
  {
    *a3 = *(_DWORD *)((char *)&loc_21D96 + v8);
  }
  if ( a4 )
  {
    *a4 = *(_DWORD *)(0x20 * v7 + a1 + 0x21D9A);
  }
  return (char *)&loc_21D96 + 0x20 * v7 + a1 + 8;
}

//----- (0005A270) --------------------------------------------------------
void __fastcall sub_5A270(T_Type3 *a1, int a2, int a3, int a4)
{
  if ( !a1->h || a4 == 0xFFFFFFFF )
  {
    Q_GSYSTEM_CPP_sub_2C7D0(&V_Type6_stru_D8654, a2, a3);
  }
}

//----- (0005A294) --------------------------------------------------------
void __fastcall sub_5A294(_DWORD *a1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // [esp+0h] [ebp-14h]

  v1 = a1;
  v2 = a1 + 0xC00;
  while ( 1 )
  {
    if ( *v1 )
    {
      (*(void (**)(void))(*(_DWORD *)(v1[1] + 0xA7) + 0x14))();
    }
    v1 += 3;
    if ( v1 == v2 )
    {
      JUMPOUT(0x56E0E);
    }
  }
}
// 5A2B3: control flows out of bounds to 56E0E

//----- (0005A320) --------------------------------------------------------
unsigned int __fastcall sub_5A320(__int16 a1)
{
  __int16 v1; // kr00_2
  unsigned int result; // eax
  unsigned __int16 v3; // cx
  int v4; // eax

  v1 = a1 - 1;
  result = (unsigned __int16)(a1 - 1);
  switch ( v1 )
  {
    case 0:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\1starmap.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 1:
    case 3:
    case 9:
    case 0xD:
    case 0xE:
    case 0x11:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\10status.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 2:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\3cfgnew.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 6:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\7racesel.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 7:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\8shipdes.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 8:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\9ENDGAME.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0xB:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\12start.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0xC:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\13negot.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0xF:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\16battle.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0x13:
      v3 = sub_1B270((int)&unk_12FC20, "DATA\\20res.tmp", 0xFFFFFFFF);
LABEL_12:
      if ( v3 == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1168);
      }
      v4 = sub_1B084((unsigned int)&unk_12FC20, v3);
      result = sub_5CB3C((P_Type5)&V_Type6_stru_D8654.pane, v4, 0, 0, 0);
      break;
    default:
      return result;
  }
  return result;
}

//----- (0005A47C) --------------------------------------------------------
int __fastcall sub_5A47C(T_Type5 *a1, const char *a2, int a3, int a4)
{
  char v5; // al
  T_Rect *p_rect; // esi
  __int16 v8; // [esp+2h] [ebp-10h]

  v5 = 0xF2;
  v8 = word_96BC4[a3];
  if ( a4 == 0xFFFFFFFF )
  {
    v5 = 0x96;
  }
  sub_5E9D0(a1, v5);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  p_rect = &a1->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = p_rect->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = p_rect->y1;
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 1, 1, a2, 0x40, v8, 0xFF, 0);
}
// 96BC4: using guessed type __int16 word_96BC4[8];

//----- (0005A4E4) --------------------------------------------------------
unsigned int __fastcall sub_5A4E4(_DWORD *a1, int a2, int a3, int a4)
{
  __int16 v5; // bx
  __int16 v6; // ax
  T_Type5 v8; // [esp+0h] [ebp-30h] BYREF
  char s[12]; // [esp+14h] [ebp-1Ch] BYREF
  int v10; // [esp+20h] [ebp-10h]

  v5 = 0xF3;
  v10 = a2;
  sprintf(s, "%03d", a2);
  v6 = 0xF2;
  if ( a2 == dword_132B10 )
  {
    v6 = 0xFE;
    v5 = 0;
  }
  if ( a4 )
  {
    v6 = 0xF1;
  }
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 1, 1, s, 0x40, v5, v6, 0);
  v8 = *(T_Type5 *)a1;
  v8.rect.x1 += 0x23;
  --v8.rect.y2;
  ++v8.rect.y1;
  return sub_5E9D0(&v8, v10);
}
// 132B10: using guessed type int dword_132B10;

//----- (0005A594) --------------------------------------------------------
T_TypeA2 *__fastcall sub_5A594(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_961AC;
  return result;
}
// 961AC: using guessed type int (*off_961AC[5])();

//----- (0005A5AC) --------------------------------------------------------
int __fastcall sub_5A5AC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_9615C);
    operator delete[](v3);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_961AC;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 961AC: using guessed type int (*off_961AC[5])();

//----- (0005A5F4) --------------------------------------------------------
int __fastcall sub_5A5F4(T_TypeA1 *a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0005A60C) --------------------------------------------------------
unsigned int __fastcall sub_5A60C(int a1, __int16 a2, __int16 a3, int a4)
{
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  char v16; // ah
  int v17; // eax
  int v18; // eax
  int v19; // ecx

  if ( (unsigned __int16)a2 < 0x3EBu )
  {
    if ( (unsigned __int16)a2 < 0xC8u )
    {
      if ( a2 && ((unsigned __int16)a2 <= 2u || (unsigned __int16)a2 >= 6u && (unsigned __int16)a2 <= 7u) )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      return 0;
    }
    if ( (unsigned __int16)a2 <= 0xC8u )
    {
      *(_BYTE *)(a1 + 0xBF) = 0;
      v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
      v7 = v6;
      if ( !v6 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x11D1);
      }
      sub_2ED4C(v6);
      *(_DWORD *)(v7 + 0xAB) = 0xFFFFFFFF;
      sub_2F1C8(v7, (int)sub_5A47C);
      if ( !*(_DWORD *)(v7 + 0x8E6) && !sub_2F228(v7, 0x2000u, 0) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x11D9);
      }
      sub_5AE68(a1, v7);
      return 0;
    }
    else if ( (unsigned __int16)a2 <= 0xCAu )
    {
      sub_56B60((int)&V_Type3_stru_10AE70, 6, a2, 0);
      return 0xFFFFFFFF;
    }
    else if ( a2 == 0x3EA )
    {
      if ( *(_BYTE *)(a1 + 0xBF) )
      {
        *(_BYTE *)(a1 + 0xBF) = 0;
        v8 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
        v9 = v8;
        if ( !v8 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x11F0);
        }
        *(_DWORD *)(v8 + 0xAB) = 0xFFFFFFFF;
        sub_2F1C8(v8, (int)sub_5A47C);
        sub_2ED4C(v9);
        sub_5AE68(a1, v9);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
    else
    {
      return 0;
    }
  }
  else if ( (unsigned __int16)a2 <= 0x3EBu )
  {
    if ( *(_BYTE *)(a1 + 0xBF) != 1 )
    {
      *(_BYTE *)(a1 + 0xBF) = 1;
      v10 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
      v11 = v10;
      if ( !v10 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1204);
      }
      *(_DWORD *)(v10 + 0xAB) = 0xFFFFFFFF;
      sub_2F1C8(v10, (int)sub_5A47C);
      sub_2ED4C(v11);
      sub_5AB2C(a1, v11);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  else if ( (unsigned __int16)a2 < 0x3EEu )
  {
    if ( (unsigned __int16)a2 <= 0x3ECu )
    {
      if ( *(_BYTE *)(a1 + 0xBF) != 2 )
      {
        *(_BYTE *)(a1 + 0xBF) = 2;
        v12 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
        v13 = v12;
        if ( !v12 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1218);
        }
        *(_DWORD *)(v12 + 0xAB) = 0xFFFFFFFF;
        sub_2F1C8(v12, (int)sub_5A47C);
        sub_2ED4C(v13);
        sub_5AF30(a1, v13);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
    else
    {
      if ( *(_BYTE *)(a1 + 0xBF) != 3 )
      {
        *(_BYTE *)(a1 + 0xBF) = 3;
        v18 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
        v19 = v18;
        if ( !v18 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x122B);
        }
        *(_DWORD *)(v18 + 0xAB) = 0;
        sub_2F1C8(v18, (int)sub_5A4E4);
        sub_2ED4C(v19);
        sub_5B200(a1, v19);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
  }
  else
  {
    if ( (unsigned __int16)a2 > 0x3EEu )
    {
      if ( (unsigned __int16)a2 >= 0x3F1u )
      {
        if ( (unsigned __int16)a2 <= 0x3F1u )
        {
          if ( *(_BYTE *)(a1 + 0xBF) == 3 )
          {
            v17 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
            if ( !v17 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1262);
            }
            sub_2ECDC(v17, dword_132B10);
            (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          }
          return 0xFFFFFFFF;
        }
        else if ( a2 == 0x1C01 )
        {
          v16 = *(_BYTE *)(a1 + 0xBF);
          if ( v16 == 3 )
          {
            if ( a4 == 5 )
            {
              *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = a3;
            }
          }
          else if ( v16 == 4 )
          {
            sub_4F8CC((int)&unk_10914C, a3, 0);
          }
          return 0xFFFFFFFF;
        }
        else
        {
          return 0;
        }
      }
      return 0;
    }
    if ( *(_BYTE *)(a1 + 0xBF) != 4 )
    {
      *(_BYTE *)(a1 + 0xBF) = 4;
      v14 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
      v15 = v14;
      if ( !v14 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x123E);
      }
      *(_DWORD *)(v14 + 0xAB) = 0xFFFFFFFF;
      sub_2F1C8(v14, (int)sub_5A47C);
      sub_2ED4C(v15);
      sub_5B244(a1, v15);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
}
// 132B10: using guessed type int dword_132B10;

//----- (0005AA08) --------------------------------------------------------
void __fastcall sub_5AA08(int a1)
{
  int v1; // eax
  char v2; // dl
  const char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char v7[20]; // [esp+0h] [ebp-18h] BYREF
  _DWORD *v8; // [esp+14h] [ebp-4h]

  v8 = (_DWORD *)a1;
  v1 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  sub_5CB3C((P_Type5)(v8 + 1), v1, 0, 0, 0);
  sub_5E9D0((P_Type5)((char *)v8 + 0xAB), 0xF2);
  v2 = *((_BYTE *)v8 + 0xBF);
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      v3 = "MEMORY    ";
    }
    else if ( v2 == 2 )
    {
      v3 = "CACHE     ";
    }
    else
    {
      v3 = "PALETTE   ";
    }
  }
  else
  {
    v3 = "WINDOWS   ";
  }
  v4 = v7;
  do
  {
    v5 = *v3;
    *v4 = *v3;
    if ( !v5 )
    {
      break;
    }
    v6 = v3[1];
    v3 += 2;
    v4[1] = v6;
    v4 += 2;
  }
  while ( v6 );
  sub_2B3E0(
    &V_Type3_stru_10AE70.z1[0x3046],
    *(_DWORD *)((char *)v8 + 0xAF),
    *(_DWORD *)((char *)v8 + 0xB3),
    *(_DWORD *)((char *)v8 + 0xB7),
    *(_DWORD *)((char *)v8 + 0xB3) + 0x32);
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 1, 1, v7, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
  sub_2D218(v8);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0005AB04) --------------------------------------------------------
int __fastcall sub_5AB04(const char **a1, const char **a2)
{
  return strncmp(*a1, *a2, 6u);
}

//----- (0005AB2C) --------------------------------------------------------
void __fastcall sub_5AB2C(int a1, int a2)
{
  int v2; // ebp
  int v3; // edi
  char *v4; // eax
  unsigned __int16 v5; // ax
  __int16 v6; // cx
  unsigned __int16 v7; // ax
  int v8; // edi
  unsigned __int16 v9; // ax
  unsigned __int16 v10; // ax
  int v11; // ecx
  unsigned __int16 v12; // ax
  int v13; // edi
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // ax
  unsigned __int16 v16; // ax
  char s[80]; // [esp+0h] [ebp-98h] BYREF
  struct _heapinfo v18; // [esp+50h] [ebp-48h] BYREF
  int v19; // [esp+60h] [ebp-38h] BYREF
  int v20; // [esp+64h] [ebp-34h] BYREF
  int v21; // [esp+68h] [ebp-30h]
  int v22; // [esp+6Ch] [ebp-2Ch]
  int v23; // [esp+70h] [ebp-28h]
  int v24; // [esp+74h] [ebp-24h]
  int v25; // [esp+78h] [ebp-20h]
  int v26; // [esp+7Ch] [ebp-1Ch]
  __int16 v27; // [esp+80h] [ebp-18h]

  *(_BYTE *)(a1 + 0xBF) = 1;
  v2 = 0;
  v22 = 0;
  v21 = 0;
  v23 = 0;
  LOWORD(v25) = 0;
  LOWORD(v26) = 0;
  v27 = 0;
  LOWORD(v24) = 0;
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x12A9);
  }
  HIWORD(v18._pentry) = 0;
  LODWORD(v18._pentry) = 0;
  while ( !heapwalk(&v18) )
  {
    if ( v18._useflag )
    {
      v2 += v18._size;
    }
    else
    {
      v3 = LODWORD(v18._pentry) + 4;
      v4 = sub_5A194((int)&V_Type3_stru_10AE70, LODWORD(v18._pentry) + 4, &v19, &v20);
      if ( v4 )
      {
        switch ( v19 )
        {
          case 1:
          case 4:
          case 5:
            sprintf(s, "%06lu S%07lu %s", v20, v18._size, v4);
            v9 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
            sub_2EC50(a2, v9, v19);
            break;
          case 2:
            sprintf(s, "%06lu S%07lu WND[%s]", v20, v18._size, (const char *)(v3 + 0x20));
            v5 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
            v6 = v24;
            sub_2EC50(a2, v5, v19);
            LOWORD(v24) = v6 + 1;
            v21 += v18._size;
            break;
          case 3:
            sprintf(s, "%06lu S%07lu %s", v20, v18._size, v4);
            v7 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
            v8 = v23;
            sub_2EC50(a2, v7, v19);
            v23 = v18._size + v8;
            LOWORD(v25) = v25 + 1;
            break;
          default:
            Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x12E3);
            break;
        }
      }
      else
      {
        ++v27;
      }
      v22 += v18._size;
      LOWORD(v26) = v26 + 1;
    }
  }
  sprintf(s, "** %d WNDS USING %lu BYTES", (__int16)v24, v21);
  v10 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  v11 = v23;
  sub_2EC50(a2, v10, 0);
  sprintf(s, "** %d SHAPES USING %lu BYTES", (__int16)v25, v11);
  v12 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  v13 = v22;
  sub_2EC50(a2, v12, 0);
  sprintf(s, "** %d ITEMS IN HEAP USE %lu BYTES", (__int16)v26, v13);
  v14 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v14, 0);
  sprintf(s, "** %d ITEMS ARE UNIDENTIFIED", v27);
  v15 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v15, 0);
  sprintf(s, "** TOTAL FREE IN HEAP %lu BYTES", v2);
  v16 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v16, 0);
  sub_2F1D8(a2, (int)sub_5AB04);
  sub_2F1E0(a2);
}

//----- (0005AE68) --------------------------------------------------------
int __fastcall sub_5AE68(int a1, int a2)
{
  int v3; // edx
  __int16 v4; // si
  __int16 v5; // di
  int result; // eax
  int v7; // eax
  int v8; // edx
  char v9; // bl
  char s[72]; // [esp+0h] [ebp-48h] BYREF

  v3 = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
  *(_BYTE *)(a1 + 0xBF) = 0;
  v4 = 0x1F;
  v5 = *(_WORD *)&V_Type3_stru_10AE70.z1[0x8E * v3 + 0x3068];
  while ( 1 )
  {
    result = v5;
    if ( v5 <= 0 )
    {
      break;
    }
    if ( v4 < 0 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x131E);
    }
    v7 = *(_DWORD *)&V_Type3_stru_10AE70.z1[0x8E * *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] + 0x306A + 4 * v4];
    if ( v7 )
    {
      v8 = *(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * v7);
      if ( *(_DWORD *)(v8 + 0x63) )
      {
        v9 = 0x43;
      }
      else
      {
        v9 = 0x20;
      }
      sprintf(s, "%c HWND%03d %s", v9, v7, (const char *)(v8 + 0x20));
      --v5;
      sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
    }
    --v4;
  }
  return result;
}

//----- (0005AF30) --------------------------------------------------------
unsigned int __fastcall sub_5AF30(int a1, int a2)
{
  int v3; // edi
  _DWORD *v4; // ebp
  int v5; // edx
  unsigned __int16 v6; // ax
  int v7; // ecx
  int v8; // ebp
  int v9; // edx
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // ax
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // ax
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // dx
  char s[100]; // [esp+0h] [ebp-94h] BYREF
  _DWORD *v18; // [esp+64h] [ebp-30h]
  const char *v19; // [esp+68h] [ebp-2Ch]
  const char *v20; // [esp+6Ch] [ebp-28h]
  _DWORD *v21; // [esp+70h] [ebp-24h]
  _DWORD *v22; // [esp+74h] [ebp-20h]
  _DWORD *v23; // [esp+78h] [ebp-1Ch]
  int v24; // [esp+7Ch] [ebp-18h]

  v3 = 0;
  v21 = dword_12FC20;
  v24 = 0;
  v19 = (const char *)&dword_12FC20[0x1F4];
  v22 = dword_12FC20;
  v4 = dword_12FC20;
  while ( *((__int16 *)v21 + 0x1771) > v24 )
  {
    sprintf(
      s,
      "%07d %s",
      dword_12FC20[*((unsigned __int16 *)v4 + 0x320) + 0xC8],
      &v19[0x32 * *((unsigned __int16 *)v4 + 0x320)]);
    v5 = v22[0xC8];
    strupr(s);
    v3 += v5;
    v4 = (_DWORD *)((char *)v4 + 2);
    v6 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
    v7 = v24;
    sub_2EC50(a2, v6, 1);
    v24 = v7 + 1;
    ++v22;
  }
  sub_2EA8C(a2, " ", 0xFFFFFFFF, 0);
  v20 = (const char *)(v21 + 0x1F4);
  v8 = 0;
  v18 = v21;
  v23 = v21;
  do
  {
    if ( *((_BYTE *)v18 + 0x7D0) )
    {
      sprintf(s, "%s", &v20[0x32 * v8]);
      v9 = v23[0xC8];
      strupr(s);
      v3 += v9;
      v10 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
      sub_2EC50(a2, v10, 0);
    }
    ++v8;
    v18 = (_DWORD *)((char *)v18 + 0x32);
    ++v23;
  }
  while ( v8 < 0xC8 );
  sub_2EA8C(a2, " ", 0xFFFFFFFF, 0);
  sprintf(s, "%03d ITEMS IN CACHE", *((__int16 *)v21 + 0x1770));
  v11 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v11, 0);
  sprintf(s, "%03d ITEMS LOADED", *((__int16 *)v21 + 0x1771));
  v12 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v12, 0);
  sub_2EA8C(a2, " ", 0xFFFFFFFF, 0);
  sprintf(s, "%07d TOTAL CACHE SIZE", v21[0xBBA]);
  v13 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v13, 0);
  sprintf(s, "%07d USED", v3);
  v14 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v14, 0);
  sprintf(s, "%07d FREE", v21[0xBBA] - v3);
  v15 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  return sub_2EC50(a2, v15, 0);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0005B200) --------------------------------------------------------
int __fastcall sub_5B200(int a1, int a2)
{
  __int16 i; // si
  int result; // eax

  *(_BYTE *)(a1 + 0xBF) = 3;
  for ( i = 0; i < 0x100; result = sub_2EA8C(a2, (const char *)i++, 0xFFFFFFFF, 0) )
  {
    ;
  }
  return result;
}

//----- (0005B244) --------------------------------------------------------
int __fastcall sub_5B244(int result, int a2)
{
  int i; // esi
  char s[96]; // [esp+0h] [ebp-60h] BYREF

  *(_BYTE *)(result + 0xBF) = 4;
  for ( i = 0; (__int16)i < word_109846; result = sub_2EA8C(a2, s, 0xFFFFFFFF, 0) )
  {
    sprintf(
      s,
      "%02d. %-24s (%d)",
      (__int16)i,
      (const char *)&unk_1094C6 + 0x1C * (__int16)i,
      *((_DWORD *)&unk_1094C6 + 7 * (__int16)i + 6));
    ++i;
  }
  return result;
}
// 109846: using guessed type __int16 word_109846;

//----- (0005B2B0) --------------------------------------------------------
int __fastcall sub_5B2B0(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96184);
    operator delete[](v3);
    return a1;
  }
  else
  {
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0005B2F0) --------------------------------------------------------
T_TypeA2 *__fastcall sub_5B2F0(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_961C4;
  return result;
}
// 961C4: using guessed type int (*off_961C4[5])();

//----- (0005B300) --------------------------------------------------------
int __fastcall sub_5B300(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96198);
    operator delete[](v3);
    return a1;
  }
  else
  {
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return (int)v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0005B340) --------------------------------------------------------
T_TypeA2 *__fastcall sub_5B340(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_961DC;
  return result;
}
// 961DC: using guessed type int (*off_961DC[5])();

//----- (0005B50C) --------------------------------------------------------
BOOL __fastcall sub_5B50C(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 != *a2 )
  {
    return 0;
  }
  if ( a1[4] < a2[2] )
  {
    return 0;
  }
  if ( a1[2] > a2[4] )
  {
    return 0;
  }
  if ( a1[3] < a2[1] )
  {
    return 0;
  }
  if ( a1[1] > a2[3] )
  {
    return 0;
  }
  if ( a1[1] < a2[1] )
  {
    return 0;
  }
  if ( a1[3] > a2[3] )
  {
    return 0;
  }
  if ( a1[2] >= a2[2] )
  {
    return a1[4] <= a2[4];
  }
  return 0;
}

//----- (0005B617) --------------------------------------------------------
_DWORD *__fastcall sub_5B617(size_t a1)
{
  _DWORD *ptr; // [esp+8h] [ebp-4h]

  ptr = malloc(0xCu);
  if ( !ptr )
  {
    return 0;
  }
  ptr[1] = calloc(a1, 4u);
  if ( ptr[1] )
  {
    *ptr = calloc(a1, 0x14u);
    if ( *ptr )
    {
      ptr[2] = a1;
      sub_5B71C((int)ptr);
      return ptr;
    }
    else
    {
      free((void *)ptr[1]);
      free(ptr);
      return 0;
    }
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (0005B71C) --------------------------------------------------------
unsigned int __fastcall sub_5B71C(int a1)
{
  unsigned int result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 8) )
    {
      break;
    }
    *(_DWORD *)(4 * i + *(_DWORD *)(a1 + 4)) = 0;
  }
  return result;
}

//----- (0005B7C2) --------------------------------------------------------
unsigned int __fastcall sub_5B7C2(_DWORD *a1, int a2, int x1, int y1, int x2, int y2)
{
  int *v9; // [esp+14h] [ebp-10h]
  int *v10; // [esp+18h] [ebp-Ch]
  unsigned int v11; // [esp+1Ch] [ebp-8h]
  unsigned int i; // [esp+20h] [ebp-4h]

  for ( i = 0; i < a1[2] && *(_DWORD *)(4 * i + a1[1]); ++i )
  {
    ;
  }
  if ( i == a1[2] )
  {
    return 0xFFFFFFFF;
  }
  *(_DWORD *)(4 * i + a1[1]) = 1;
  v10 = (int *)(0x14 * i + *a1);
  *v10 = a2;
  v10[1] = x1;
  v10[2] = y1;
  v10[3] = x2;
  v10[4] = y2;
  v11 = 0;
  v9 = (int *)*a1;
  while ( v11 < a1[2] )
  {
    if ( *(_DWORD *)(4 * v11 + a1[1]) && v10 != v9 && sub_5B50C(v10, v9) )
    {
      *(_DWORD *)(4 * i + a1[1]) = 2;
      return i;
    }
    ++v11;
    v9 += 5;
  }
  return i;
}

//----- (0005BA38) --------------------------------------------------------
unsigned int __fastcall sub_5BA38(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1[2] )
    {
      break;
    }
    if ( *(_DWORD *)(4 * i + a1[1]) == 1 )
    {
      VFX_pane_refresh(
        (PANE *)(0x14 * i + *a1),
        *(_DWORD *)(0x14 * i + *a1 + 4),
        *(_DWORD *)(0x14 * i + *a1 + 8),
        *(_DWORD *)(0x14 * i + *a1 + 0xC),
        *(_DWORD *)(0x14 * i + *a1 + 0x10));
    }
  }
  return result;
}

//----- (0005BAC0) --------------------------------------------------------
int __fastcall sub_5BAC0(_DWORD *a1, int a2)
{
  unsigned __int8 *v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  unsigned int m; // [esp+1Ch] [ebp-1Ch]
  BOOL v6; // [esp+20h] [ebp-18h]
  unsigned int k; // [esp+24h] [ebp-14h]
  unsigned int i; // [esp+28h] [ebp-10h]
  unsigned int j; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  unsigned int v11; // [esp+34h] [ebp-4h]

  v11 = a1[1] + 1;
  v10 = a1[2] + 1;
  v4 = 4 * v10;
  for ( i = 0; i < v10; ++i )
  {
    v3 = (unsigned __int8 *)(i * v11 + *a1);
    for ( j = 0; j < v11; j = k )
    {
      v6 = *v3 == a2;
      for ( k = j + 1; k < v11; ++k )
      {
        if ( (*++v3 == a2) != v6 )
        {
          break;
        }
      }
      for ( m = k - j; m > 0x7F; m -= 0x7F )
      {
        ++v4;
      }
      ++v4;
    }
  }
  return v4;
}

//----- (0005BBE4) --------------------------------------------------------
char *__fastcall sub_5BBE4(void **a1, char *a2, int a3)
{
  int v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *s2; // [esp+Ch] [ebp-34h]
  _DWORD *ptr; // [esp+18h] [ebp-28h]
  char *v11; // [esp+1Ch] [ebp-24h]
  unsigned __int8 *v12; // [esp+20h] [ebp-20h]
  unsigned int m; // [esp+24h] [ebp-1Ch]
  BOOL v14; // [esp+28h] [ebp-18h]
  bool v15; // [esp+28h] [ebp-18h]
  unsigned int k; // [esp+2Ch] [ebp-14h]
  unsigned int i; // [esp+30h] [ebp-10h]
  unsigned int j; // [esp+34h] [ebp-Ch]
  unsigned int v19; // [esp+38h] [ebp-8h]
  unsigned int v20; // [esp+3Ch] [ebp-4h]

  s2 = a2;
  v20 = (unsigned int)a1[1] + 1;
  v19 = (unsigned int)a1[2] + 1;
  if ( a2 == *a1 )
  {
    if ( sub_5BAC0(a1, a3) > v19 * v20 )
    {
      return 0;
    }
  }
  else if ( !a2 )
  {
    v3 = sub_5BAC0(a1, a3);
    s2 = (char *)malloc(v3);
    if ( !s2 )
    {
      return 0;
    }
  }
  ptr = malloc(4 * v19);
  if ( !ptr )
  {
    return 0;
  }
  v11 = s2;
  for ( i = 0; i < v19; ++i )
  {
    v12 = (unsigned __int8 *)*a1 + i * v20;
    ptr[i] = v11 - s2 + 4 * v19;
    for ( j = 0; j < v20; j = k )
    {
      v14 = *v12 == a3;
      for ( k = j + 1; k < v20; ++k )
      {
        if ( (*++v12 == a3) != v14 )
        {
          break;
        }
      }
      v15 = v14 << 7;
      for ( m = k - j; m > 0x7F; m -= 0x7F )
      {
        v4 = v11++;
        *v4 = v15 | 0x7F;
      }
      v5 = v11++;
      *v5 = m | v15;
    }
  }
  memmove(&s2[4 * v19], s2, v11 - s2);
  memmove(s2, ptr, 4 * v19);
  free(ptr);
  return s2;
}

//----- (0005BDDC) --------------------------------------------------------
void __fastcall sub_5BDDC(void *a1)
{
  free(a1);
}

//----- (0005BE08) --------------------------------------------------------
const char *__cdecl sub_5BE08(int (**a1)(void))
{
  char *v1; // eax
  char *v2; // edi
  char v3; // bl

  v1 = (char *)(*a1)();
  v2 = "MCGA.DLL";
  do
  {
    v3 = *v1;
    *v2++ = *v1++;
  }
  while ( v3 );
  return "MCGA.DLL";
}

//----- (0005BE31) --------------------------------------------------------
LONG __cdecl VFX_register_driver(void *DLLbase)
{
  LONG result; // eax

  qmemcpy(&VFX_describe_driver, DLLbase, 0x34u);
  return result;
}
// 5BE31: variable 'result' is possibly undefined

//----- (0005BE50) --------------------------------------------------------
unsigned int __cdecl sub_5BE50(int **a1, int a2, int a3, char a4)
{
  int *v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  unsigned int result; // eax
  int v13; // ecx
  int v14; // ebx
  _BYTE *v15; // ebx
  int v16; // [esp+Ch] [ebp-20h]
  int v17; // [esp+10h] [ebp-1Ch]
  int v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+18h] [ebp-14h]
  int v20; // [esp+20h] [ebp-Ch]
  int v21; // [esp+24h] [ebp-8h]
  int v22; // [esp+28h] [ebp-4h]

  v4 = *a1;
  v5 = (*a1)[1];
  v18 = v5 + 1;
  if ( (v5 + 1 < 0) ^ __OFADD__(1, v5) | (v5 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v6 = v4[2];
  v7 = v6 + 1;
  if ( (v6 + 1 < 0) ^ __OFADD__(1, v6) | (v6 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v8 = (int)a1[1];
  v17 = v8;
  if ( v8 <= 0 )
  {
    v8 = 0;
  }
  v22 = v8;
  v9 = (int)a1[2];
  v16 = v9;
  if ( v9 <= 0 )
  {
    v9 = 0;
  }
  v21 = v9;
  v10 = (int)a1[3];
  if ( v10 >= v18 - 1 )
  {
    v10 = v18 - 1;
  }
  v20 = v10;
  v11 = (int)a1[4];
  if ( v11 >= v7 - 1 )
  {
    v11 = v7 - 1;
  }
  if ( v20 < v22 || v11 < v21 )
  {
    return 0xFFFFFFFE;
  }
  v19 = *v4;
  v13 = v17 + a2;
  v14 = v16 + a3;
  if ( v17 + a2 < v22 || v13 > v20 || v14 < v21 || v14 > v11 )
  {
    return 0xFFFFFFFD;
  }
  v15 = (_BYTE *)(v13 + v19 + v18 * v14);
  result = (unsigned __int8)*v15;
  *v15 = a4;
  return result;
}

//----- (0005BF2B) --------------------------------------------------------
unsigned int __cdecl sub_5BF2B(int **a1, int a2, int a3)
{
  int *v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v12; // ecx
  int v13; // ebx
  int v14; // [esp+Ch] [ebp-20h]
  int v15; // [esp+10h] [ebp-1Ch]
  int v16; // [esp+14h] [ebp-18h]
  int v17; // [esp+18h] [ebp-14h]
  int v18; // [esp+20h] [ebp-Ch]
  int v19; // [esp+24h] [ebp-8h]
  int v20; // [esp+28h] [ebp-4h]

  v3 = *a1;
  v4 = (*a1)[1];
  v16 = v4 + 1;
  if ( (v4 + 1 < 0) ^ __OFADD__(1, v4) | (v4 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v5 = v3[2];
  v6 = v5 + 1;
  if ( (v5 + 1 < 0) ^ __OFADD__(1, v5) | (v5 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v7 = (int)a1[1];
  v15 = v7;
  if ( v7 <= 0 )
  {
    v7 = 0;
  }
  v20 = v7;
  v8 = (int)a1[2];
  v14 = v8;
  if ( v8 <= 0 )
  {
    v8 = 0;
  }
  v19 = v8;
  v9 = (int)a1[3];
  if ( v9 >= v16 - 1 )
  {
    v9 = v16 - 1;
  }
  v18 = v9;
  v10 = (int)a1[4];
  if ( v10 >= v6 - 1 )
  {
    v10 = v6 - 1;
  }
  if ( v18 < v20 || v10 < v19 )
  {
    return 0xFFFFFFFE;
  }
  v17 = *v3;
  v12 = v15 + a2;
  v13 = v14 + a3;
  if ( v15 + a2 < v20 || v12 > v18 || v13 < v19 || v13 > v10 )
  {
    return 0xFFFFFFFD;
  }
  else
  {
    return *(unsigned __int8 *)(v12 + v17 + v16 * v13);
  }
}

//----- (0005C001) --------------------------------------------------------
unsigned int __cdecl sub_5C001(
        int **a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        void (__fastcall *a7)(_DWORD, _DWORD, _DWORD, _DWORD))
{
  int *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int *v11; // eax
  int *v12; // eax
  int *v13; // eax
  int *v14; // eax
  signed int v16; // edx
  signed int v17; // ebx
  unsigned int v18; // eax
  unsigned __int64 v19; // rtt
  char v20; // dl
  int v21; // edx
  unsigned __int64 v22; // rtt
  unsigned __int64 v23; // rtt
  unsigned __int64 v24; // rtt
  unsigned __int64 v25; // rtt
  unsigned __int64 v26; // rtt
  unsigned __int64 v27; // rtt
  unsigned __int64 v28; // rtt
  unsigned __int64 v29; // rtt
  char *v30; // edi
  int v31; // esi
  unsigned int v32; // ecx
  char *v33; // edx
  unsigned __int64 v34; // kr00_8
  unsigned int v35; // ecx
  unsigned __int64 v36; // kr08_8
  unsigned int v37; // ecx
  unsigned __int64 v38; // kr10_8
  unsigned int v39; // ecx
  unsigned __int64 v43; // kr20_8
  unsigned int v44; // ecx
  unsigned __int64 v47; // kr28_8
  unsigned int v48; // ecx
  unsigned __int64 v51; // kr30_8
  unsigned int v52; // ecx
  int v55; // edi
  int v56; // esi
  int v57; // eax
  int v58; // esi
  char *v59; // edi
  char *v60; // kr40_4
  unsigned int v61; // ecx
  char *v62; // edi
  char *v63; // kr48_4
  unsigned int v64; // ecx
  char *v65; // edi
  unsigned int v66; // kr50_4
  unsigned int v67; // ecx
  char *v71; // edi
  char *v72; // kr60_4
  unsigned int v73; // ecx
  char *v76; // edi
  char *v77; // kr68_4
  unsigned int v78; // ecx
  char *v81; // edi
  char *v82; // kr70_4
  unsigned int v83; // ecx
  int v86; // edi
  int v87; // esi
  int v88; // eax
  unsigned int v89; // ecx
  char *v90; // edx
  _BYTE *v91; // edi
  bool v92; // cf
  char *v93; // edx
  unsigned int v94; // ecx
  _BYTE *v95; // edi
  char *v96; // edx
  unsigned int v97; // ecx
  _BYTE *v98; // edi
  char *v99; // edx
  unsigned int v100; // ecx
  char *v104; // edi
  char *v105; // edx
  unsigned int v106; // ecx
  char *v109; // edi
  char *v110; // edx
  unsigned int v111; // ecx
  char *v114; // edi
  char *v115; // edx
  unsigned int v116; // ecx
  int v119; // edi
  int v120; // esi
  int v121; // eax
  _BYTE *v122; // edi
  char *v123; // edx
  unsigned int v124; // ecx
  _BYTE *v125; // edi
  char *v126; // edx
  unsigned int v127; // ecx
  _BYTE *v128; // edi
  char *v129; // edx
  unsigned int v130; // ecx
  char *v134; // edi
  char *v135; // edx
  unsigned int v136; // ecx
  char *v139; // edi
  char *v140; // edx
  unsigned int v141; // ecx
  char *v144; // edi
  char *v145; // edx
  unsigned int v146; // ecx
  int v149; // edi
  int v150; // esi
  int v151; // eax
  int v152; // eax
  int v153; // eax
  int *v154; // eax
  int *v155; // eax
  int v156; // esi
  unsigned int v157; // ecx
  int v158; // eax
  int v159; // eax
  int *v160; // eax
  int *v161; // eax
  __int64 v162; // rax
  char *v163; // edi
  char *v164; // edi
  unsigned int v165; // ecx
  char *v166; // edi
  unsigned int v167; // ecx
  char *v168; // edi
  unsigned int v169; // ecx
  char *v173; // edi
  unsigned int v174; // ecx
  char *v177; // edi
  unsigned int v178; // ecx
  char *v181; // edi
  unsigned int v182; // ecx
  int v185; // edi
  int v186; // esi
  int v187; // ebx
  int v188; // [esp-24h] [ebp-88h]
  int v189; // [esp-24h] [ebp-88h]
  int v190; // [esp-24h] [ebp-88h]
  int v191; // [esp-24h] [ebp-88h]
  int v192; // [esp-24h] [ebp-88h]
  char *v193; // [esp-20h] [ebp-84h]
  char *v194; // [esp-20h] [ebp-84h]
  char *v195; // [esp-20h] [ebp-84h]
  char *v196; // [esp-20h] [ebp-84h]
  unsigned int v197; // [esp-1Ch] [ebp-80h]
  unsigned int v198; // [esp-1Ch] [ebp-80h]
  unsigned int v199; // [esp-1Ch] [ebp-80h]
  unsigned int v200; // [esp-1Ch] [ebp-80h]
  unsigned int v201; // [esp-1Ch] [ebp-80h]
  int *v202; // [esp+Ch] [ebp-58h]
  int *v203; // [esp+10h] [ebp-54h]
  int v204; // [esp+14h] [ebp-50h]
  int v205; // [esp+18h] [ebp-4Ch]
  int *v206; // [esp+1Ch] [ebp-48h]
  int *v207; // [esp+20h] [ebp-44h]
  int *v208; // [esp+24h] [ebp-40h]
  int *v209; // [esp+28h] [ebp-3Ch]
  int v210; // [esp+30h] [ebp-34h]
  int *v211; // [esp+34h] [ebp-30h]
  int *v212; // [esp+38h] [ebp-2Ch]
  int *v213; // [esp+3Ch] [ebp-28h]
  int *v214; // [esp+40h] [ebp-24h]
  unsigned int v215; // [esp+44h] [ebp-20h]
  int v216; // [esp+48h] [ebp-1Ch]
  int v217; // [esp+4Ch] [ebp-18h]
  signed int v218; // [esp+50h] [ebp-14h]
  int v219; // [esp+58h] [ebp-Ch]
  signed int v220; // [esp+5Ch] [ebp-8h]
  int savedregs; // [esp+64h] [ebp+0h] BYREF
  int *v222; // [esp+70h] [ebp+Ch]
  int v223; // [esp+74h] [ebp+10h]
  int *v224; // [esp+78h] [ebp+14h]
  int *v225; // [esp+7Ch] [ebp+18h]

  v7 = *a1;
  v8 = (*a1)[1];
  v204 = v8 + 1;
  if ( (v8 + 1 < 0) ^ __OFADD__(1, v8) | (v8 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v9 = v7[2];
  v10 = v9 + 1;
  if ( (v9 + 1 < 0) ^ __OFADD__(1, v9) | (v9 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v11 = a1[1];
  v203 = v11;
  if ( (int)v11 <= 0 )
  {
    v11 = 0;
  }
  v209 = v11;
  v12 = a1[2];
  v202 = v12;
  if ( (int)v12 <= 0 )
  {
    v12 = 0;
  }
  v208 = v12;
  v13 = a1[3];
  if ( (int)v13 >= v204 - 1 )
  {
    v13 = (int *)(v204 - 1);
  }
  v207 = v13;
  v14 = a1[4];
  if ( (int)v14 >= v10 - 1 )
  {
    v14 = (int *)(v10 - 1);
  }
  v206 = v14;
  if ( (int)v207 < (int)v209 || (int)v14 < (int)v208 )
  {
    return 0xFFFFFFFE;
  }
  v205 = *v7;
  v222 = (int *)((char *)v203 + a2);
  v224 = (int *)((char *)v203 + a4);
  v223 = (int)v202 + a3;
  v225 = (int *)((char *)v202 + a5);
  v219 = ((char *)v224 - (char *)v222) >> 0x1F;
  v220 = abs32((char *)v224 - (char *)v222);
  v217 = ((int)v225 - v223) >> 0x1F;
  v218 = abs32((int)v225 - v223);
  v214 = v222;
  v212 = v224;
  v213 = (int *)v223;
  v211 = v225;
  if ( v224 == v222 )
  {
    if ( (int)v222 >= (int)v209 && (int)v222 <= (int)v207 )
    {
      v152 = v223;
      if ( v223 <= (int)v225 )
      {
        v152 = (int)v225;
      }
      if ( v152 >= (int)v208 )
      {
        v153 = v223;
        if ( v223 >= (int)v225 )
        {
          v153 = (int)v225;
        }
        if ( v153 <= (int)v206 )
        {
          v154 = (int *)v223;
          if ( v223 <= (int)v208 )
          {
            v154 = v208;
          }
          if ( (int)v154 >= (int)v206 )
          {
            v154 = v206;
          }
          v213 = v154;
          v155 = v225;
          if ( (int)v225 <= (int)v208 )
          {
            v155 = v208;
          }
          if ( (int)v155 >= (int)v206 )
          {
            v155 = v206;
          }
          v214 = v222;
          v156 = (v217 ^ v204) - v217;
          v157 = abs32((char *)v155 - (char *)v213) + 1;
          goto LABEL_203;
        }
      }
    }
  }
  else
  {
    if ( v225 != (int *)v223 )
    {
      v216 = v217 ^ v219;
      v16 = v220;
      v17 = v218;
      v18 = 0xFFFFFFFF;
      if ( v220 != v218 )
      {
        if ( v220 >= v218 )
        {
          v16 = v218;
          v17 = v220;
        }
        LODWORD(v19) = 0;
        HIDWORD(v19) = v16;
        v18 = v19 / (unsigned int)v17;
      }
      v215 = v18;
      v210 = 0;
      while ( 1 )
      {
        v20 = __CFSHL__((char *)v214 - (char *)v209, 1)
            + __CFSHL__((char *)v207 - (char *)v214, 1)
            + __CFSHL__((char *)v214 - (char *)v209, 1);
        v21 = (unsigned __int8)(v20
                              + __CFSHL__((char *)v213 - (char *)v208, 1)
                              + v20
                              + __CFSHL__((char *)v206 - (char *)v213, 1)
                              + v20
                              + __CFSHL__((char *)v213 - (char *)v208, 1)
                              + v20);
        BYTE1(v21) += __CFSHL__((char *)v212 - (char *)v209, 1)
                    + BYTE1(v21)
                    + __CFSHL__((char *)v207 - (char *)v212, 1)
                    + BYTE1(v21)
                    + __CFSHL__((char *)v212 - (char *)v209, 1)
                    + BYTE1(v21);
        BYTE1(v21) += __CFSHL__((char *)v211 - (char *)v208, 1)
                    + BYTE1(v21)
                    + __CFSHL__((char *)v206 - (char *)v211, 1)
                    + BYTE1(v21)
                    + __CFSHL__((char *)v211 - (char *)v208, 1)
                    + BYTE1(v21);
        v210 |= v21;
        if ( !v21 )
        {
          break;
        }
        if ( ((unsigned __int8)v21 & BYTE1(v21)) != 0 )
        {
          return 2;
        }
        if ( v220 < v218 )
        {
          if ( (v21 & 8) != 0 )
          {
            v214 = v209;
            LODWORD(v22) = 0x80000000;
            HIDWORD(v22) = (char *)v209 - (char *)v222 - 1;
            v213 = (int *)(v223 + (v216 ^ (v22 / v18 - ((v22 % v18 == 0) - 1))) - v216);
          }
          else if ( (v21 & 4) != 0 )
          {
            v214 = v207;
            LODWORD(v23) = 0x80000000;
            HIDWORD(v23) = (char *)v222 - (char *)v207 - 1;
            v213 = (int *)(v223 + (~v216 ^ (v23 / v18 - ((v23 % v18 == 0) - 1))) + v216 + 1);
          }
          else if ( (v21 & 2) != 0 )
          {
            v213 = v208;
            v214 = (int *)((char *)v222
                         + (v216 ^ ((v18 * (unsigned __int64)((unsigned int)v208 - v223) + 0x80000000) >> 0x20))
                         - v216);
          }
          else if ( (v21 & 1) != 0 )
          {
            v213 = v206;
            v214 = (int *)((char *)v222
                         + (~v216 ^ ((v18 * (unsigned __int64)(unsigned int)(v223 - (_DWORD)v206) + 0x80000000) >> 0x20))
                         + v216
                         + 1);
          }
          else if ( (v21 & 0x800) != 0 )
          {
            v212 = v209;
            LODWORD(v26) = 0x80000000;
            HIDWORD(v26) = (char *)v222 - (char *)v209;
            v211 = (int *)(v223 + (~v216 ^ ((__PAIR64__(v26 / v18, v26 % v18) - 1) >> 0x20)) + v216 + 1);
          }
          else if ( (v21 & 0x400) != 0 )
          {
            v212 = v207;
            LODWORD(v27) = 0x80000000;
            HIDWORD(v27) = (char *)v207 - (char *)v222;
            v211 = (int *)(v223 + (v216 ^ ((__PAIR64__(v27 / v18, v27 % v18) - 1) >> 0x20)) - v216);
          }
          else if ( (v21 & 0x200) != 0 )
          {
            v211 = v208;
            v212 = (int *)((char *)v222
                         + (~v216 ^ ((v18 * (unsigned __int64)(unsigned int)(v223 - (_DWORD)v208) + 0x80000000) >> 0x20))
                         + v216
                         + 1);
          }
          else if ( (v21 & 0x100) != 0 )
          {
            v211 = v206;
            v212 = (int *)((char *)v222
                         + (v216 ^ ((v18 * (unsigned __int64)((unsigned int)v206 - v223) + 0x80000000) >> 0x20))
                         - v216);
          }
        }
        else if ( (v21 & 8) != 0 )
        {
          v214 = v209;
          v213 = (int *)(v223
                       + (v216 ^ ((v18 * (unsigned __int64)(unsigned int)((char *)v209 - (char *)v222) + 0x80000000) >> 0x20))
                       - v216);
        }
        else if ( (v21 & 4) != 0 )
        {
          v214 = v207;
          v213 = (int *)(v223
                       + (~v216 ^ ((v18 * (unsigned __int64)(unsigned int)((char *)v222 - (char *)v207) + 0x80000000) >> 0x20))
                       + v216
                       + 1);
        }
        else if ( (v21 & 2) != 0 )
        {
          v213 = v208;
          LODWORD(v24) = 0x80000000;
          HIDWORD(v24) = (char *)v208 - v223 - 1;
          v214 = (int *)((char *)v222 + (v216 ^ (v24 / v18 - ((v24 % v18 == 0) - 1))) - v216);
        }
        else if ( (v21 & 1) != 0 )
        {
          v213 = v206;
          LODWORD(v25) = 0x80000000;
          HIDWORD(v25) = v223 - (_DWORD)v206 - 1;
          v214 = (int *)((char *)v222 + (~v216 ^ (v25 / v18 - ((v25 % v18 == 0) - 1))) + v216 + 1);
        }
        else if ( (v21 & 0x800) != 0 )
        {
          v212 = v209;
          v211 = (int *)(v223
                       + (~v216 ^ ((v18 * (unsigned __int64)(unsigned int)((char *)v222 - (char *)v209) + 0x80000000) >> 0x20))
                       + v216
                       + 1);
        }
        else if ( (v21 & 0x400) != 0 )
        {
          v212 = v207;
          v211 = (int *)(v223
                       + (v216 ^ ((v18 * (unsigned __int64)(unsigned int)((char *)v207 - (char *)v222) + 0x80000000) >> 0x20))
                       - v216);
        }
        else if ( (v21 & 0x200) != 0 )
        {
          v211 = v208;
          LODWORD(v28) = 0x80000000;
          HIDWORD(v28) = v223 - (_DWORD)v208;
          v212 = (int *)((char *)v222 + (~v216 ^ ((__PAIR64__(v28 / v18, v28 % v18) - 1) >> 0x20)) + v216 + 1);
        }
        else if ( (v21 & 0x100) != 0 )
        {
          v211 = v206;
          LODWORD(v29) = 0x80000000;
          HIDWORD(v29) = (char *)v206 - v223;
          v212 = (int *)((char *)v222 + (v216 ^ ((__PAIR64__(v29 / v18, v29 % v18) - 1) >> 0x20)) - v216);
        }
      }
      v30 = (char *)v214 + v205 + v204 * (_DWORD)v213;
      v31 = (v217 ^ v204) - v217;
      if ( v220 != v218 )
      {
        if ( v220 > v218 )
        {
          v89 = abs32((char *)v212 - (char *)v214) + 1;
          v90 = (char *)(v18 * abs32((char *)v214 - (char *)v222) + 0x80000000);
          if ( v219 == 0xFFFFFFFF )
          {
            if ( a6 == 1 )
            {
              _EBX = a7;
              do
              {
                _AL = *v30;
                __asm { xlat }
                *v30 = _AL;
                v134 = v30 + 0xFFFFFFFF;
                v92 = __CFADD__(&savedregs, v90);
                v135 = (char *)&savedregs + (_DWORD)v90;
                if ( v92 )
                {
                  v134 += v31;
                }
                v136 = v89 - 1;
                if ( !v136 )
                {
                  break;
                }
                _AL = *v134;
                __asm { xlat }
                *v134 = _AL;
                v139 = v134 + 0xFFFFFFFF;
                v92 = __CFADD__(&savedregs, v135);
                v140 = (char *)&savedregs + (_DWORD)v135;
                if ( v92 )
                {
                  v139 += v31;
                }
                v141 = v136 - 1;
                if ( !v141 )
                {
                  break;
                }
                _AL = *v139;
                __asm { xlat }
                *v139 = _AL;
                v144 = v139 + 0xFFFFFFFF;
                v92 = __CFADD__(&savedregs, v140);
                v145 = (char *)&savedregs + (_DWORD)v140;
                if ( v92 )
                {
                  v144 += v31;
                }
                v146 = v141 - 1;
                if ( !v146 )
                {
                  break;
                }
                _AL = *v144;
                __asm { xlat }
                *v144 = _AL;
                v30 = v144 + 0xFFFFFFFF;
                v92 = __CFADD__(&savedregs, v145);
                v90 = (char *)&savedregs + (_DWORD)v145;
                if ( v92 )
                {
                  v30 += v31;
                }
                v89 = v146 - 1;
              }
              while ( v89 );
            }
            else if ( a6 > 1 )
            {
              v149 = (char *)v214 - (char *)a1[1];
              v150 = (char *)v213 - (char *)a1[2];
              v151 = 2 * v217 + 1;
              do
              {
                v200 = v89;
                v196 = v90;
                v191 = v151;
                a7(v151, v90, v215, v89);
                v151 = v191;
                v90 += v215;
                if ( __CFADD__(v215, v196) )
                {
                  --v150;
                }
                v149 += v191;
                --v89;
              }
              while ( v200 != 1 );
            }
            else
            {
              do
              {
                *v30 = (char)a7;
                v122 = v30 + 0xFFFFFFFF;
                v92 = __CFADD__(v18, v90);
                v123 = &v90[v18];
                if ( v92 )
                {
                  v122 += v31;
                }
                v124 = v89 - 1;
                if ( !v124 )
                {
                  break;
                }
                *v122 = (_BYTE)a7;
                v125 = v122 + 0xFFFFFFFF;
                v92 = __CFADD__(v18, v123);
                v126 = &v123[v18];
                if ( v92 )
                {
                  v125 += v31;
                }
                v127 = v124 - 1;
                if ( !v127 )
                {
                  break;
                }
                *v125 = (_BYTE)a7;
                v128 = v125 + 0xFFFFFFFF;
                v92 = __CFADD__(v18, v126);
                v129 = &v126[v18];
                if ( v92 )
                {
                  v128 += v31;
                }
                v130 = v127 - 1;
                if ( !v130 )
                {
                  break;
                }
                *v128 = (_BYTE)a7;
                v30 = v128 + 0xFFFFFFFF;
                v92 = __CFADD__(v18, v129);
                v90 = &v129[v18];
                if ( v92 )
                {
                  v30 += v31;
                }
                v89 = v130 - 1;
              }
              while ( v89 );
            }
          }
          else if ( a6 == 1 )
          {
            _EBX = a7;
            do
            {
              _AL = *v30;
              __asm { xlat }
              *v30 = _AL;
              v104 = v30 + 1;
              v92 = __CFADD__(&savedregs, v90);
              v105 = (char *)&savedregs + (_DWORD)v90;
              if ( v92 )
              {
                v104 += v31;
              }
              v106 = v89 - 1;
              if ( !v106 )
              {
                break;
              }
              _AL = *v104;
              __asm { xlat }
              *v104 = _AL;
              v109 = v104 + 1;
              v92 = __CFADD__(&savedregs, v105);
              v110 = (char *)&savedregs + (_DWORD)v105;
              if ( v92 )
              {
                v109 += v31;
              }
              v111 = v106 - 1;
              if ( !v111 )
              {
                break;
              }
              _AL = *v109;
              __asm { xlat }
              *v109 = _AL;
              v114 = v109 + 1;
              v92 = __CFADD__(&savedregs, v110);
              v115 = (char *)&savedregs + (_DWORD)v110;
              if ( v92 )
              {
                v114 += v31;
              }
              v116 = v111 - 1;
              if ( !v116 )
              {
                break;
              }
              _AL = *v114;
              __asm { xlat }
              *v114 = _AL;
              v30 = v114 + 1;
              v92 = __CFADD__(&savedregs, v115);
              v90 = (char *)&savedregs + (_DWORD)v115;
              if ( v92 )
              {
                v30 += v31;
              }
              v89 = v116 - 1;
            }
            while ( v89 );
          }
          else if ( a6 > 1 )
          {
            v119 = (char *)v214 - (char *)a1[1];
            v120 = (char *)v213 - (char *)a1[2];
            v121 = 2 * v217 + 1;
            do
            {
              v199 = v89;
              v195 = v90;
              v190 = v121;
              a7(v121, v90, v215, v89);
              v121 = v190;
              v90 += v215;
              if ( __CFADD__(v215, v195) )
              {
                ++v120;
              }
              v119 += v190;
              --v89;
            }
            while ( v199 != 1 );
          }
          else
          {
            do
            {
              *v30 = (char)a7;
              v91 = v30 + 1;
              v92 = __CFADD__(v18, v90);
              v93 = &v90[v18];
              if ( v92 )
              {
                v91 += v31;
              }
              v94 = v89 - 1;
              if ( !v94 )
              {
                break;
              }
              *v91 = (_BYTE)a7;
              v95 = v91 + 1;
              v92 = __CFADD__(v18, v93);
              v96 = &v93[v18];
              if ( v92 )
              {
                v95 += v31;
              }
              v97 = v94 - 1;
              if ( !v97 )
              {
                break;
              }
              *v95 = (_BYTE)a7;
              v98 = v95 + 1;
              v92 = __CFADD__(v18, v96);
              v99 = &v96[v18];
              if ( v92 )
              {
                v98 += v31;
              }
              v100 = v97 - 1;
              if ( !v100 )
              {
                break;
              }
              *v98 = (_BYTE)a7;
              v30 = v98 + 1;
              v92 = __CFADD__(v18, v99);
              v90 = &v99[v18];
              if ( v92 )
              {
                v30 += v31;
              }
              v89 = v100 - 1;
            }
            while ( v89 );
          }
        }
        else
        {
          v32 = abs32((char *)v211 - (char *)v213) + 1;
          v33 = (char *)(v18 * abs32((int)v213 - v223) + 0x80000000);
          if ( v219 == 0xFFFFFFFF )
          {
            v58 = v217 - (v217 ^ v204);
            if ( a6 == 1 )
            {
              _EBX = a7;
              do
              {
                _AL = *v30;
                __asm { xlat }
                *v30 = _AL;
                v72 = (char *)&savedregs + (_DWORD)v33;
                v71 = &v30[-((unsigned int)&v33[__PAIR64__(v58, &savedregs)] >> 0x20)];
                v73 = v32 - 1;
                if ( !v73 )
                {
                  break;
                }
                _AL = *v71;
                __asm { xlat }
                *v71 = _AL;
                v77 = (char *)&savedregs + (_DWORD)v72;
                v76 = &v71[-((unsigned int)&v72[__PAIR64__(v58, &savedregs)] >> 0x20)];
                v78 = v73 - 1;
                if ( !v78 )
                {
                  break;
                }
                _AL = *v76;
                __asm { xlat }
                *v76 = _AL;
                v82 = (char *)&savedregs + (_DWORD)v77;
                v81 = &v76[-((unsigned int)&v77[__PAIR64__(v58, &savedregs)] >> 0x20)];
                v83 = v78 - 1;
                if ( !v83 )
                {
                  break;
                }
                _AL = *v81;
                __asm { xlat }
                *v81 = _AL;
                v33 = (char *)&savedregs + (_DWORD)v82;
                v30 = &v81[-((unsigned int)&v82[__PAIR64__(v58, &savedregs)] >> 0x20)];
                v32 = v83 - 1;
              }
              while ( v32 );
            }
            else if ( a6 > 1 )
            {
              v86 = (char *)v214 - (char *)a1[1];
              v87 = (char *)v213 - (char *)a1[2];
              v88 = 2 * v217 + 1;
              do
              {
                v198 = v32;
                v194 = v33;
                v189 = v88;
                a7(v88, v33, v215, v32);
                v88 = v189;
                v33 += v215;
                if ( __CFADD__(v215, v194) )
                {
                  --v86;
                }
                v87 += v189;
                --v32;
              }
              while ( v198 != 1 );
            }
            else
            {
              do
              {
                *v30 = (char)a7;
                v60 = &v33[v18];
                v59 = &v30[-((unsigned int)&v33[__PAIR64__(v58, v18)] >> 0x20)];
                v61 = v32 - 1;
                if ( !v61 )
                {
                  break;
                }
                *v59 = (char)a7;
                v63 = &v60[v18];
                v62 = &v59[-((unsigned int)&v60[__PAIR64__(v58, v18)] >> 0x20)];
                v64 = v61 - 1;
                if ( !v64 )
                {
                  break;
                }
                *v62 = (char)a7;
                v66 = (unsigned int)&v63[v18];
                v65 = &v62[-((unsigned int)&v63[__PAIR64__(v58, v18)] >> 0x20)];
                v67 = v64 - 1;
                if ( !v67 )
                {
                  break;
                }
                *v65 = (char)a7;
                v33 = (char *)(v18 + v66);
                v30 = &v65[-((__PAIR64__(v58, v18) + v66) >> 0x20)];
                v32 = v67 - 1;
              }
              while ( v32 );
            }
          }
          else if ( a6 == 1 )
          {
            _EBX = a7;
            do
            {
              _AL = *v30;
              __asm { xlat }
              *v30 = _AL;
              v43 = __PAIR64__(v31, &savedregs) + __PAIR64__((unsigned int)v30, (unsigned int)v33);
              v44 = v32 - 1;
              if ( !v44 )
              {
                break;
              }
              _AL = *(_BYTE *)HIDWORD(v43);
              __asm { xlat }
              *(_BYTE *)HIDWORD(v43) = _AL;
              v47 = __PAIR64__(v31, &savedregs) + v43;
              v48 = v44 - 1;
              if ( !v48 )
              {
                break;
              }
              _AL = *(_BYTE *)HIDWORD(v47);
              __asm { xlat }
              *(_BYTE *)HIDWORD(v47) = _AL;
              v51 = __PAIR64__(v31, &savedregs) + v47;
              v52 = v48 - 1;
              if ( !v52 )
              {
                break;
              }
              _AL = *(_BYTE *)HIDWORD(v51);
              __asm { xlat }
              *(_BYTE *)HIDWORD(v51) = _AL;
              v30 = (char *)((__PAIR64__(v31, &savedregs) + v51) >> 0x20);
              v33 = (char *)&savedregs + v51;
              v32 = v52 - 1;
            }
            while ( v32 );
          }
          else if ( a6 > 1 )
          {
            v55 = (char *)v214 - (char *)a1[1];
            v56 = (char *)v213 - (char *)a1[2];
            v57 = 2 * v217 + 1;
            do
            {
              v197 = v32;
              v193 = v33;
              v188 = v57;
              a7(v57, v33, v215, v32);
              v57 = v188;
              v33 += v215;
              if ( __CFADD__(v215, v193) )
              {
                ++v55;
              }
              v56 += v188;
              --v32;
            }
            while ( v197 != 1 );
          }
          else
          {
            do
            {
              *v30 = (char)a7;
              v34 = __PAIR64__(v31, v18) + __PAIR64__((unsigned int)v30, (unsigned int)v33);
              v35 = v32 - 1;
              if ( !v35 )
              {
                break;
              }
              *(_BYTE *)HIDWORD(v34) = (_BYTE)a7;
              v36 = __PAIR64__(v31, v18) + v34;
              v37 = v35 - 1;
              if ( !v37 )
              {
                break;
              }
              *(_BYTE *)HIDWORD(v36) = (_BYTE)a7;
              v38 = __PAIR64__(v31, v18) + v36;
              v39 = v37 - 1;
              if ( !v39 )
              {
                break;
              }
              *(_BYTE *)HIDWORD(v38) = (_BYTE)a7;
              v30 = (char *)((__PAIR64__(v31, v18) + v38) >> 0x20);
              v33 = (char *)(v18 + v38);
              v32 = v39 - 1;
            }
            while ( v32 );
          }
        }
        return v210 != 0;
      }
      v156 = (v219 | (v219 + 1)) + (v217 ^ v204) - v217;
      v157 = abs32((char *)v212 - (char *)v214) + 1;
LABEL_203:
      v162 = v204 * (__int64)(int)v213;
      v163 = (char *)v214 + v205 + v162;
      if ( a6 == 1 )
      {
        _EBX = a7;
        do
        {
          _AL = *v163;
          __asm { xlat }
          *v163 = _AL;
          v173 = &v163[v156];
          v174 = v157 - 1;
          if ( !v174 )
          {
            break;
          }
          _AL = *v173;
          __asm { xlat }
          *v173 = _AL;
          v177 = &v173[v156];
          v178 = v174 - 1;
          if ( !v178 )
          {
            break;
          }
          _AL = *v177;
          __asm { xlat }
          *v177 = _AL;
          v181 = &v177[v156];
          v182 = v178 - 1;
          if ( !v182 )
          {
            break;
          }
          _AL = *v181;
          __asm { xlat }
          *v181 = _AL;
          v163 = &v181[v156];
          v157 = v182 - 1;
        }
        while ( v157 );
      }
      else if ( a6 > 1 )
      {
        v185 = (char *)v214 - (char *)a1[1];
        v186 = (char *)v213 - (char *)a1[2];
        LODWORD(v162) = v217 | (v225 != (int *)v223);
        v187 = v219 | (v224 != v222);
        do
        {
          v201 = v157;
          v192 = v162;
          a7(v162, HIDWORD(v162), v187, v157);
          LODWORD(v162) = v192;
          v186 += v192;
          v185 += v187;
          --v157;
        }
        while ( v201 != 1 );
      }
      else
      {
        do
        {
          *v163 = (char)a7;
          v164 = &v163[v156];
          v165 = v157 - 1;
          if ( !v165 )
          {
            break;
          }
          *v164 = (char)a7;
          v166 = &v164[v156];
          v167 = v165 - 1;
          if ( !v167 )
          {
            break;
          }
          *v166 = (char)a7;
          v168 = &v166[v156];
          v169 = v167 - 1;
          if ( !v169 )
          {
            break;
          }
          *v168 = (char)a7;
          v163 = &v168[v156];
          v157 = v169 - 1;
        }
        while ( v157 );
      }
      return v210 != 0;
    }
    if ( v223 >= (int)v208 && v223 <= (int)v14 )
    {
      v158 = (int)v222;
      if ( (int)v222 <= (int)v224 )
      {
        v158 = (int)v224;
      }
      if ( v158 >= (int)v209 )
      {
        v159 = (int)v222;
        if ( (int)v222 >= (int)v224 )
        {
          v159 = (int)v224;
        }
        if ( v159 <= (int)v207 )
        {
          v160 = v222;
          if ( (int)v222 <= (int)v209 )
          {
            v160 = v209;
          }
          if ( (int)v160 >= (int)v207 )
          {
            v160 = v207;
          }
          v214 = v160;
          v161 = v224;
          if ( (int)v224 <= (int)v209 )
          {
            v161 = v209;
          }
          if ( (int)v161 >= (int)v207 )
          {
            v161 = v207;
          }
          v213 = (int *)v223;
          v156 = v219 | (v219 + 1);
          v157 = abs32((char *)v161 - (char *)v214) + 1;
          goto LABEL_203;
        }
      }
    }
  }
  return 2;
}
// 5C9EF: variable 'v210' is possibly undefined

//----- (0005CB3C) --------------------------------------------------------
unsigned int __cdecl sub_5CB3C(P_Type5 a1, int a2, int a3, int a4, int a5)
{
  P_Type6 a; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int x1; // eax
  int y1; // eax
  int x2; // eax
  int y2; // eax
  unsigned __int8 *v14; // esi
  char v15; // dl
  __int16 v16; // dx
  char *v17; // edi
  int v18; // ecx
  unsigned __int8 v19; // al
  char v20; // cf
  unsigned __int8 v21; // al
  int v22; // eax
  char *v23; // edi
  unsigned __int8 v24; // al
  char v25; // cf
  unsigned __int8 v26; // al
  unsigned __int8 *v27; // esi
  unsigned __int8 v28; // al
  char v29; // cf
  int v30; // ecx
  _BYTE *v31; // esi
  int v32; // ecx
  char *v33; // edi
  int v34; // eax
  char v35; // cf
  int v36; // ecx
  int v37; // ecx
  char *v38; // edi
  char *v39; // esi
  char *v40; // esi
  unsigned __int8 v41; // al
  char v42; // cf
  unsigned __int8 v43; // al
  char v44; // cf
  unsigned __int8 v45; // al
  unsigned __int8 v46; // al
  unsigned __int8 *v47; // esi
  unsigned __int8 v48; // al
  char v49; // cf
  unsigned __int8 *v50; // esi
  unsigned __int8 v51; // al
  char v52; // cf
  unsigned __int8 *v53; // esi
  unsigned __int8 v54; // al
  char v55; // cf
  unsigned __int8 v56; // al
  char v57; // cf
  unsigned __int8 v58; // al
  unsigned __int8 v59; // al
  unsigned __int8 *v60; // esi
  unsigned __int8 v61; // al
  char v62; // cf
  __int64 v63; // rax
  _BYTE *v64; // esi
  int v65; // ecx
  char *v66; // edi
  char v67; // cf
  int v68; // edx
  int v69; // ecx
  char *v70; // edi
  char *v71; // esi
  char *v72; // esi
  unsigned __int8 v73; // al
  char v74; // cf
  unsigned __int8 v75; // al
  unsigned __int8 *v76; // esi
  unsigned __int8 v77; // al
  char v78; // cf
  unsigned __int8 v79; // al
  unsigned __int8 *v80; // esi
  unsigned __int8 v81; // al
  char v82; // cf
  unsigned __int8 *v83; // esi
  unsigned __int8 v84; // al
  char v85; // cf
  unsigned int v86; // [esp-8h] [ebp-64h]
  unsigned int v87; // [esp-8h] [ebp-64h]
  unsigned int v88; // [esp-8h] [ebp-64h]
  unsigned int v89; // [esp-8h] [ebp-64h]
  int v90; // [esp+Ch] [ebp-50h]
  int v91; // [esp+10h] [ebp-4Ch]
  int v92; // [esp+14h] [ebp-48h]
  int v93; // [esp+1Ch] [ebp-40h]
  int v94; // [esp+20h] [ebp-3Ch]
  int v95; // [esp+24h] [ebp-38h]
  int v96; // [esp+28h] [ebp-34h]
  _DWORD *v97; // [esp+2Ch] [ebp-30h]
  int v98; // [esp+30h] [ebp-2Ch]
  char *v99; // [esp+34h] [ebp-28h]
  char *v100; // [esp+38h] [ebp-24h]
  int v101; // [esp+3Ch] [ebp-20h]
  __int16 v102; // [esp+40h] [ebp-1Ch]
  int v103; // [esp+44h] [ebp-18h]
  int v104; // [esp+48h] [ebp-14h]
  int v105; // [esp+4Ch] [ebp-10h]
  int v106; // [esp+50h] [ebp-Ch]
  int v107; // [esp+70h] [ebp+14h]
  int v108; // [esp+74h] [ebp+18h]

  a = a1->a;
  v6 = *(_DWORD *)&a1->a->z1[4];
  v92 = v6 + 1;
  if ( (v6 + 1 < 0) ^ __OFADD__(1, v6) | (v6 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v7 = *(_DWORD *)&a->z1[8];
  v8 = v7 + 1;
  if ( (v7 + 1 < 0) ^ __OFADD__(1, v7) | (v7 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  x1 = a1->rect.x1;
  v91 = x1;
  if ( x1 <= 0 )
  {
    x1 = 0;
  }
  v96 = x1;
  y1 = a1->rect.y1;
  v90 = y1;
  if ( y1 <= 0 )
  {
    y1 = 0;
  }
  v95 = y1;
  x2 = a1->rect.x2;
  if ( x2 >= v92 - 1 )
  {
    x2 = v92 - 1;
  }
  v94 = x2;
  y2 = a1->rect.y2;
  if ( y2 >= v8 - 1 )
  {
    y2 = v8 - 1;
  }
  v93 = y2;
  if ( v94 < v96 || y2 < v95 )
  {
    return 0xFFFFFFFE;
  }
  v107 = v91 + a4;
  v108 = v90 + a5;
  v97 = (_DWORD *)(a2 + *(_DWORD *)(a2 + 8 * a3 + 8));
  v106 = v107 + v97[2];
  v105 = v108 + v97[3];
  v104 = v107 + v97[4];
  v103 = v108 + v97[5];
  v14 = (unsigned __int8 *)(v97 + 6);
  if ( v104 < v106 || v103 < v105 )
  {
    return 0xFFFFFFFC;
  }
  v15 = __CFSHL__(v106 - v96, 1) + __CFSHL__(v94 - v106, 1) + __CFSHL__(v106 - v96, 1);
  v16 = (unsigned __int8)(v15
                        + __CFSHL__(v105 - v95, 1)
                        + v15
                        + __CFSHL__(y2 - v105, 1)
                        + v15
                        + __CFSHL__(v105 - v95, 1)
                        + v15);
  HIBYTE(v16) += __CFSHL__(v104 - v96, 1)
               + HIBYTE(v16)
               + __CFSHL__(v94 - v104, 1)
               + HIBYTE(v16)
               + __CFSHL__(v104 - v96, 1)
               + HIBYTE(v16);
  HIBYTE(v16) += __CFSHL__(v103 - v95, 1)
               + HIBYTE(v16)
               + __CFSHL__(y2 - v103, 1)
               + HIBYTE(v16)
               + __CFSHL__(v103 - v95, 1)
               + HIBYTE(v16);
  v102 = v16;
  if ( ((unsigned __int8)v16 & HIBYTE(v16)) != 0 )
  {
    return 0xFFFFFFFD;
  }
  if ( v16 )
  {
    v17 = (char *)(v106 + *(_DWORD *)a->z1 + v92 * v105);
    v18 = v108 + v97[3];
LABEL_28:
    if ( v18 >= v95 )
    {
      v100 = v17;
      v101 = v18;
      v99 = &v17[v96 - v106];
      v98 = (int)&v17[v94 - v106];
      while ( 2 )
      {
        if ( v101 > v103 )
        {
          return 0;
        }
        HIWORD(v22) = HIWORD(v101);
        if ( v101 > v93 )
        {
          return 0;
        }
        v23 = v100;
        if ( (v102 & 8) != 0 )
        {
          v43 = *v14++;
          v44 = v43 & 1;
          v45 = v43 >> 1;
          if ( v44 | (v45 == 0) )
          {
            if ( v45 )
            {
              goto LABEL_64;
            }
            if ( v44 )
            {
              goto LABEL_52;
            }
            goto LABEL_103;
          }
LABEL_56:
          while ( 2 )
          {
            v30 = v45;
            v22 = v99 - v23;
            if ( v99 - v23 < v30 )
            {
              if ( v22 >= 0 )
              {
                v23 = v99;
                v30 -= v22;
              }
              if ( (v102 & 0x400) == 0 )
              {
                goto LABEL_41;
              }
              goto LABEL_81;
            }
            v23 += v30;
            v50 = v14 + 1;
            v51 = *v50;
            v14 = v50 + 1;
            v52 = v51 & 1;
            v45 = v51 >> 1;
            if ( !(v52 | (v45 == 0)) )
            {
              continue;
            }
            break;
          }
          if ( !v52 )
          {
            goto LABEL_103;
          }
          if ( !v45 )
          {
            goto LABEL_52;
          }
LABEL_64:
          while ( 1 )
          {
            v36 = v45;
            v22 = v99 - v23;
            if ( v99 - v23 < v36 )
            {
              break;
            }
            v23 += v36;
            v53 = &v14[v36];
            v54 = *v53;
            v14 = v53 + 1;
            v55 = v54 & 1;
            v45 = v54 >> 1;
            if ( !(v55 | (v45 == 0)) )
            {
              goto LABEL_56;
            }
            if ( !v45 )
            {
              if ( !v55 )
              {
                goto LABEL_103;
              }
              do
              {
LABEL_52:
                v46 = *v14;
                v47 = v14 + 1;
                v23 += v46;
                v48 = *v47;
                v14 = v47 + 1;
                v49 = v48 & 1;
                v45 = v48 >> 1;
                if ( !(v49 | (v45 == 0)) )
                {
                  goto LABEL_56;
                }
                if ( v45 )
                {
                  goto LABEL_64;
                }
              }
              while ( v49 );
              if ( !v49 )
              {
                goto LABEL_103;
              }
              goto LABEL_56;
            }
          }
          if ( v22 >= 0 )
          {
            v23 = v99;
            v36 -= v22;
            v14 += v22;
          }
          if ( (v102 & 0x400) == 0 )
          {
            while ( 1 )
            {
              v87 = v36;
              v37 = v36 & 3;
              qmemcpy(v23, v14, v37);
              v39 = (char *)&v14[v37];
              v38 = &v23[v37];
              qmemcpy(v38, v39, 4 * (v87 >> 2));
              v40 = &v39[4 * (v87 >> 2)];
              v23 = &v38[4 * (v87 >> 2)];
              v41 = *v40;
              v14 = (unsigned __int8 *)(v40 + 1);
              v42 = v41 & 1;
              LOBYTE(v22) = v41 >> 1;
              if ( !(v42 | ((_BYTE)v22 == 0)) )
              {
                goto LABEL_40;
              }
              if ( !(_BYTE)v22 )
              {
                break;
              }
LABEL_44:
              v36 = (unsigned __int8)v22;
            }
            if ( v42 )
            {
              do
              {
LABEL_36:
                v26 = *v14;
                v27 = v14 + 1;
                v23 += v26;
                v28 = *v27;
                v14 = v27 + 1;
                v29 = v28 & 1;
                LOBYTE(v22) = v28 >> 1;
                if ( !(v29 | ((_BYTE)v22 == 0)) )
                {
                  goto LABEL_40;
                }
                if ( (_BYTE)v22 )
                {
                  goto LABEL_44;
                }
              }
              while ( v29 );
              if ( !v29 )
              {
                goto LABEL_103;
              }
              while ( 1 )
              {
LABEL_40:
                v30 = (unsigned __int8)v22;
LABEL_41:
                LOBYTE(v22) = *v14;
                v31 = v14 + 1;
                v86 = v30;
                v32 = v30 & 3;
                memset(v23, v22, v32);
                v33 = &v23[v32];
                BYTE1(v22) = v22;
                v34 = __ROL4__(v22, 8);
                LOBYTE(v34) = BYTE1(v34);
                v22 = __ROL4__(v34, 8);
                LOBYTE(v22) = BYTE1(v22);
                memset32(v33, v22, v86 >> 2);
                v23 = &v33[4 * (v86 >> 2)];
                LOBYTE(v22) = *v31;
                v14 = v31 + 1;
                v35 = v22 & 1;
                LOBYTE(v22) = (unsigned __int8)v22 >> 1;
                if ( v35 | ((_BYTE)v22 == 0) )
                {
                  if ( v35 )
                  {
                    if ( !(_BYTE)v22 )
                    {
                      goto LABEL_36;
                    }
                    goto LABEL_44;
                  }
                  goto LABEL_103;
                }
              }
            }
            goto LABEL_103;
          }
          while ( 2 )
          {
            if ( (int)v23 > v98 )
            {
              while ( 1 )
              {
                v23 += v36;
                v83 = &v14[v36];
                v84 = *v83;
                v14 = v83 + 1;
                v85 = v84 & 1;
                v79 = v84 >> 1;
                if ( v85 | (v79 == 0) )
                {
                  if ( !v79 )
                  {
                    if ( !v85 )
                    {
                      goto LABEL_103;
                    }
                    goto LABEL_91;
                  }
                }
                else
                {
                  while ( 1 )
                  {
                    do
                    {
LABEL_95:
                      v30 = v79;
LABEL_96:
                      v23 += v30;
                      v80 = v14 + 1;
                      v81 = *v80;
                      v14 = v80 + 1;
                      v82 = v81 & 1;
                      v79 = v81 >> 1;
                    }
                    while ( !(v82 | (v79 == 0)) );
                    if ( !v82 )
                    {
                      goto LABEL_103;
                    }
                    if ( v79 )
                    {
                      break;
                    }
LABEL_91:
                    while ( 1 )
                    {
                      v75 = *v14;
                      v76 = v14 + 1;
                      v23 += v75;
                      v77 = *v76;
                      v14 = v76 + 1;
                      v78 = v77 & 1;
                      v79 = v77 >> 1;
                      if ( !(v78 | (v79 == 0)) )
                      {
                        break;
                      }
                      if ( v79 )
                      {
                        goto LABEL_99;
                      }
                      if ( !v78 )
                      {
                        if ( !v78 )
                        {
                          goto LABEL_103;
                        }
                        goto LABEL_95;
                      }
                    }
                  }
                }
LABEL_99:
                v36 = v79;
              }
            }
            v68 = (unsigned int)&v23[v36 - 1 - v98] & ~((int)&v23[v36 - 1 - v98] >> 0x1F);
            v89 = v36 - v68;
            v69 = (v36 - v68) & 3;
            qmemcpy(v23, v14, v69);
            v71 = (char *)&v14[v69];
            v70 = &v23[v69];
            qmemcpy(v70, v71, 4 * (v89 >> 2));
            v23 = &v70[4 * (v89 >> 2) + v68];
            v72 = &v71[4 * (v89 >> 2) + v68];
            v73 = *v72;
            v14 = (unsigned __int8 *)(v72 + 1);
            v74 = v73 & 1;
            v58 = v73 >> 1;
            if ( v74 | (v58 == 0) )
            {
              if ( v58 )
              {
LABEL_85:
                v36 = v58;
                continue;
              }
              if ( v74 )
              {
                goto LABEL_76;
              }
              goto LABEL_103;
            }
            break;
          }
        }
        else
        {
          if ( (v102 & 0x400) == 0 )
          {
            v24 = *v14++;
            v25 = v24 & 1;
            LOBYTE(v22) = v24 >> 1;
            if ( v25 | ((_BYTE)v22 == 0) )
            {
              if ( !(_BYTE)v22 )
              {
                if ( !v25 )
                {
                  goto LABEL_103;
                }
                goto LABEL_36;
              }
              goto LABEL_44;
            }
            goto LABEL_40;
          }
          v56 = *v14++;
          v57 = v56 & 1;
          v58 = v56 >> 1;
          if ( v57 | (v58 == 0) )
          {
            if ( v58 )
            {
              goto LABEL_85;
            }
            if ( v57 )
            {
              goto LABEL_76;
            }
            goto LABEL_103;
          }
        }
        do
        {
LABEL_80:
          v30 = v58;
LABEL_81:
          if ( (int)v23 > v98 )
          {
            goto LABEL_96;
          }
          v63 = (int)&v23[v30 - 1 - v98];
          HIDWORD(v63) = v63 & ~HIDWORD(v63);
          LOBYTE(v63) = *v14;
          v64 = v14 + 1;
          v88 = v30 - HIDWORD(v63);
          v65 = (v30 - HIDWORD(v63)) & 3;
          memset(v23, v63, v65);
          v66 = &v23[v65];
          BYTE1(v63) = v63;
          LODWORD(v63) = __ROL4__(v63, 8);
          LOBYTE(v63) = BYTE1(v63);
          LODWORD(v63) = __ROL4__(v63, 8);
          LOBYTE(v63) = BYTE1(v63);
          memset32(v66, v63, v88 >> 2);
          v23 = &v66[4 * (v88 >> 2) + HIDWORD(v63)];
          LOBYTE(v63) = *v64;
          v14 = v64 + 1;
          v67 = v63 & 1;
          v58 = (unsigned __int8)v63 >> 1;
        }
        while ( !(v67 | (v58 == 0)) );
        if ( v67 )
        {
          if ( v58 )
          {
            goto LABEL_85;
          }
          do
          {
LABEL_76:
            v59 = *v14;
            v60 = v14 + 1;
            v23 += v59;
            v61 = *v60;
            v14 = v60 + 1;
            v62 = v61 & 1;
            v58 = v61 >> 1;
            if ( !(v62 | (v58 == 0)) )
            {
              goto LABEL_80;
            }
            if ( v58 )
            {
              goto LABEL_85;
            }
          }
          while ( v62 );
          if ( !v62 )
          {
            goto LABEL_103;
          }
          goto LABEL_80;
        }
LABEL_103:
        v100 += v92;
        v99 += v92;
        v98 += v92;
        ++v101;
        continue;
      }
    }
    while ( 1 )
    {
      v19 = *v14++;
      v20 = v19 & 1;
      v21 = v19 >> 1;
      if ( v20 | (v21 == 0) )
      {
        if ( v21 )
        {
          v14 = &v14[v21 - 1];
        }
        else if ( !v20 )
        {
          v17 += v92;
          ++v18;
          goto LABEL_28;
        }
      }
      ++v14;
    }
  }
  sub_5CF40(a1, v97, v107 - a1->rect.x1, v108 - a1->rect.y1);
  return 0;
}

//----- (0005CF40) --------------------------------------------------------
int __cdecl sub_5CF40(P_Type5 a1, _DWORD *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // ebx
  char *v6; // edi
  char *v7; // edx
  int v8; // eax
  bool v9; // cc
  int v10; // eax
  int v11; // ebx
  unsigned __int8 *v12; // esi
  unsigned __int8 v13; // al
  char v14; // cf
  unsigned __int8 v15; // al
  unsigned __int8 *v16; // esi
  unsigned __int8 v17; // al
  char v18; // cf
  unsigned int v19; // ecx
  _BYTE *v20; // esi
  int v21; // ecx
  char *v22; // edi
  int v23; // eax
  char v24; // cf
  int v25; // ecx
  char *v26; // edi
  char *v27; // esi
  int v28; // ecx
  char *v29; // esi
  unsigned __int8 v30; // al
  char v31; // cf
  unsigned int v33; // [esp-8h] [ebp-14h]
  int v34; // [esp+1Ch] [ebp+10h]
  int v35; // [esp+20h] [ebp+14h]
  int v36; // [esp+24h] [ebp+18h]

  v34 = a1->rect.x1 + a3;
  v35 = a1->rect.y1 + a4;
  v4 = *(_DWORD *)&a1->a->z1[4];
  v36 = v4 + 1;
  if ( !((v4 + 1 < 0) ^ __OFADD__(1, v4) | (v4 == 0xFFFFFFFF)) )
  {
    v5 = a2[3];
    v6 = (char *)(v36 * (v35 + v5) + v34 + a2[2] + *(_DWORD *)a1->a);
    v7 = v6;
    v8 = a2[5] + 1;
    v9 = v8 <= v5;
    v10 = v8 - v5;
    v11 = v10;
    if ( !v9 )
    {
      v12 = (unsigned __int8 *)(a2 + 6);
      do
      {
        v13 = *v12++;
        v14 = v13 & 1;
        LOBYTE(v10) = v13 >> 1;
        if ( !(v14 | ((_BYTE)v10 == 0)) )
        {
          goto LABEL_11;
        }
        if ( (_BYTE)v10 )
        {
          goto LABEL_14;
        }
        if ( v14 )
        {
          do
          {
LABEL_7:
            v15 = *v12;
            v16 = v12 + 1;
            v6 += v15;
            v17 = *v16;
            v12 = v16 + 1;
            v18 = v17 & 1;
            LOBYTE(v10) = v17 >> 1;
            if ( !(v18 | ((_BYTE)v10 == 0)) )
            {
              goto LABEL_11;
            }
            if ( (_BYTE)v10 )
            {
              goto LABEL_14;
            }
          }
          while ( v18 );
          if ( v18 )
          {
            while ( 1 )
            {
              do
              {
LABEL_11:
                v19 = (unsigned __int8)v10;
                LOBYTE(v10) = *v12;
                v20 = v12 + 1;
                v33 = v19;
                v21 = v19 & 3;
                memset(v6, v10, v21);
                v22 = &v6[v21];
                BYTE1(v10) = v10;
                v23 = __ROL4__(v10, 8);
                LOBYTE(v23) = BYTE1(v23);
                v10 = __ROL4__(v23, 8);
                LOBYTE(v10) = BYTE1(v10);
                memset32(v22, v10, v33 >> 2);
                v6 = &v22[4 * (v33 >> 2)];
                LOBYTE(v10) = *v20;
                v12 = v20 + 1;
                v24 = v10 & 1;
                LOBYTE(v10) = (unsigned __int8)v10 >> 1;
              }
              while ( !(v24 | ((_BYTE)v10 == 0)) );
              if ( !v24 )
              {
                break;
              }
              if ( !(_BYTE)v10 )
              {
                goto LABEL_7;
              }
LABEL_14:
              while ( 1 )
              {
                v25 = v10 & 3;
                qmemcpy(v6, v12, v25);
                v27 = (char *)&v12[v25];
                v26 = &v6[v25];
                v28 = (unsigned __int8)v10 >> 2;
                qmemcpy(v26, v27, 4 * v28);
                v29 = &v27[4 * v28];
                v6 = &v26[4 * v28];
                v30 = *v29;
                v12 = (unsigned __int8 *)(v29 + 1);
                v31 = v30 & 1;
                LOBYTE(v10) = v30 >> 1;
                if ( !(v31 | ((_BYTE)v10 == 0)) )
                {
                  break;
                }
                if ( !(_BYTE)v10 )
                {
                  if ( v31 )
                  {
                    goto LABEL_7;
                  }
                  goto LABEL_17;
                }
              }
            }
          }
        }
LABEL_17:
        v7 += v36;
        v6 = v7;
        --v11;
      }
      while ( v11 );
    }
  }
  return 0;
}

//----- (0005D007) --------------------------------------------------------
void __cdecl sub_5D007(const void *a1)
{
  qmemcpy(byte_98464, a1, sizeof(byte_98464));
}

//----- (0005D026) --------------------------------------------------------
unsigned int __cdecl sub_5D026(P_Type5 a1, int a2, int a3, int a4, int a5)
{
  P_Type6 a; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int x1; // eax
  int y1; // eax
  int x2; // eax
  int y2; // eax
  unsigned __int8 *v14; // esi
  char v15; // dl
  __int16 v16; // dx
  char *v17; // edi
  int v18; // ecx
  unsigned __int8 v19; // al
  char v20; // cf
  unsigned __int8 v21; // al
  char *v22; // edi
  unsigned __int8 v23; // al
  char v24; // cf
  unsigned __int8 v25; // al
  unsigned __int8 v26; // al
  unsigned __int8 *v27; // esi
  unsigned __int8 v28; // al
  char v29; // cf
  int v30; // ecx
  int v31; // eax
  _BYTE *v32; // esi
  int v33; // ecx
  char *v34; // edi
  int v35; // eax
  int v36; // eax
  char v37; // cf
  int v38; // ecx
  int v39; // eax
  unsigned __int8 v40; // al
  char v41; // cf
  unsigned __int8 v42; // al
  char v43; // cf
  unsigned __int8 v44; // al
  unsigned __int8 v45; // al
  unsigned __int8 *v46; // esi
  unsigned __int8 v47; // al
  char v48; // cf
  int v49; // eax
  unsigned __int8 *v50; // esi
  unsigned __int8 v51; // al
  char v52; // cf
  int v53; // eax
  unsigned __int8 *v54; // esi
  unsigned __int8 v55; // al
  char v56; // cf
  unsigned __int8 v57; // al
  char v58; // cf
  unsigned __int8 v59; // al
  unsigned __int8 v60; // al
  unsigned __int8 *v61; // esi
  unsigned __int8 v62; // al
  char v63; // cf
  int v64; // edx
  int v65; // eax
  _BYTE *v66; // esi
  int v67; // ecx
  char *v68; // edi
  int v69; // eax
  int v70; // eax
  char v71; // cf
  int v72; // edx
  int v73; // ecx
  int v74; // eax
  unsigned __int8 *v75; // esi
  unsigned __int8 v76; // al
  char v77; // cf
  unsigned __int8 v78; // al
  unsigned __int8 *v79; // esi
  unsigned __int8 v80; // al
  char v81; // cf
  unsigned __int8 v82; // al
  unsigned __int8 *v83; // esi
  unsigned __int8 v84; // al
  char v85; // cf
  unsigned __int8 *v86; // esi
  unsigned __int8 v87; // al
  char v88; // cf
  unsigned int v89; // [esp-8h] [ebp-64h]
  unsigned int v90; // [esp-8h] [ebp-64h]
  int v91; // [esp+Ch] [ebp-50h]
  int v92; // [esp+10h] [ebp-4Ch]
  int v93; // [esp+14h] [ebp-48h]
  int v94; // [esp+1Ch] [ebp-40h]
  int v95; // [esp+20h] [ebp-3Ch]
  int v96; // [esp+24h] [ebp-38h]
  int v97; // [esp+28h] [ebp-34h]
  _DWORD *v98; // [esp+2Ch] [ebp-30h]
  int v99; // [esp+30h] [ebp-2Ch]
  char *v100; // [esp+34h] [ebp-28h]
  char *v101; // [esp+38h] [ebp-24h]
  int v102; // [esp+3Ch] [ebp-20h]
  __int16 v103; // [esp+40h] [ebp-1Ch]
  int v104; // [esp+44h] [ebp-18h]
  int v105; // [esp+48h] [ebp-14h]
  int v106; // [esp+4Ch] [ebp-10h]
  int v107; // [esp+50h] [ebp-Ch]
  int v108; // [esp+70h] [ebp+14h]
  int v109; // [esp+74h] [ebp+18h]

  a = a1->a;
  v6 = *(_DWORD *)&a1->a->z1[4];
  v93 = v6 + 1;
  if ( (v6 + 1 < 0) ^ __OFADD__(1, v6) | (v6 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v7 = *(_DWORD *)&a->z1[8];
  v8 = v7 + 1;
  if ( (v7 + 1 < 0) ^ __OFADD__(1, v7) | (v7 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  x1 = a1->rect.x1;
  v92 = x1;
  if ( x1 <= 0 )
  {
    x1 = 0;
  }
  v97 = x1;
  y1 = a1->rect.y1;
  v91 = y1;
  if ( y1 <= 0 )
  {
    y1 = 0;
  }
  v96 = y1;
  x2 = a1->rect.x2;
  if ( x2 >= v93 - 1 )
  {
    x2 = v93 - 1;
  }
  v95 = x2;
  y2 = a1->rect.y2;
  if ( y2 >= v8 - 1 )
  {
    y2 = v8 - 1;
  }
  v94 = y2;
  if ( v95 < v97 || y2 < v96 )
  {
    return 0xFFFFFFFE;
  }
  v108 = v92 + a4;
  v109 = v91 + a5;
  v98 = (_DWORD *)(a2 + *(_DWORD *)(a2 + 8 * a3 + 8));
  v107 = v108 + v98[2];
  v106 = v109 + v98[3];
  v105 = v108 + v98[4];
  v104 = v109 + v98[5];
  v14 = (unsigned __int8 *)(v98 + 6);
  if ( v105 < v107 || v104 < v106 )
  {
    return 0xFFFFFFFC;
  }
  v15 = __CFSHL__(v107 - v97, 1) + __CFSHL__(v95 - v107, 1) + __CFSHL__(v107 - v97, 1);
  v16 = (unsigned __int8)(v15
                        + __CFSHL__(v106 - v96, 1)
                        + v15
                        + __CFSHL__(y2 - v106, 1)
                        + v15
                        + __CFSHL__(v106 - v96, 1)
                        + v15);
  HIBYTE(v16) += __CFSHL__(v105 - v97, 1)
               + HIBYTE(v16)
               + __CFSHL__(v95 - v105, 1)
               + HIBYTE(v16)
               + __CFSHL__(v105 - v97, 1)
               + HIBYTE(v16);
  HIBYTE(v16) += __CFSHL__(v104 - v96, 1)
               + HIBYTE(v16)
               + __CFSHL__(y2 - v104, 1)
               + HIBYTE(v16)
               + __CFSHL__(v104 - v96, 1)
               + HIBYTE(v16);
  v103 = v16;
  if ( ((unsigned __int8)v16 & HIBYTE(v16)) != 0 )
  {
    return 0xFFFFFFFD;
  }
  if ( v16 )
  {
    v17 = (char *)(v107 + *(_DWORD *)a->z1 + v93 * v106);
    v18 = v109 + v98[3];
LABEL_28:
    if ( v18 >= v96 )
    {
      v101 = v17;
      v102 = v18;
      v100 = &v17[v97 - v107];
      v99 = (int)&v17[v95 - v107];
      while ( 2 )
      {
        if ( v102 > v104 || v102 > v94 )
        {
          return 0;
        }
        v22 = v101;
        if ( (v103 & 8) != 0 )
        {
          v42 = *v14++;
          v43 = v42 & 1;
          v44 = v42 >> 1;
          if ( v43 | (v44 == 0) )
          {
            if ( v44 )
            {
              goto LABEL_69;
            }
            if ( v43 )
            {
              goto LABEL_57;
            }
            goto LABEL_113;
          }
LABEL_61:
          while ( 2 )
          {
            v30 = v44;
            v49 = v100 - v22;
            if ( v100 - v22 < v30 )
            {
              if ( v49 >= 0 )
              {
                v22 = v100;
                v30 -= v49;
              }
              if ( (v103 & 0x400) == 0 )
              {
                goto LABEL_41;
              }
              goto LABEL_86;
            }
            v22 += v30;
            v50 = v14 + 1;
            v51 = *v50;
            v14 = v50 + 1;
            v52 = v51 & 1;
            v44 = v51 >> 1;
            if ( !(v52 | (v44 == 0)) )
            {
              continue;
            }
            break;
          }
          if ( !v52 )
          {
            goto LABEL_113;
          }
          if ( !v44 )
          {
            goto LABEL_57;
          }
LABEL_69:
          while ( 1 )
          {
            v38 = v44;
            v53 = v100 - v22;
            if ( v100 - v22 < v38 )
            {
              break;
            }
            v22 += v38;
            v54 = &v14[v38];
            v55 = *v54;
            v14 = v54 + 1;
            v56 = v55 & 1;
            v44 = v55 >> 1;
            if ( !(v56 | (v44 == 0)) )
            {
              goto LABEL_61;
            }
            if ( !v44 )
            {
              if ( !v56 )
              {
                goto LABEL_113;
              }
              do
              {
LABEL_57:
                v45 = *v14;
                v46 = v14 + 1;
                v22 += v45;
                v47 = *v46;
                v14 = v46 + 1;
                v48 = v47 & 1;
                v44 = v47 >> 1;
                if ( !(v48 | (v44 == 0)) )
                {
                  goto LABEL_61;
                }
                if ( v44 )
                {
                  goto LABEL_69;
                }
              }
              while ( v48 );
              if ( !v48 )
              {
                goto LABEL_113;
              }
              goto LABEL_61;
            }
          }
          if ( v53 >= 0 )
          {
            v22 = v100;
            v38 -= v53;
            v14 += v53;
          }
          if ( (v103 & 0x400) == 0 )
          {
            while ( 1 )
            {
              v39 = 0;
              if ( v38 )
              {
                if ( v38 < 4 )
                {
                  do
                  {
LABEL_49:
                    LOBYTE(v39) = *v14;
                    *v22 = byte_98464[v39];
                    ++v14;
                    ++v22;
                    --v38;
                  }
                  while ( v38 );
                }
                else
                {
                  while ( 1 )
                  {
                    LOBYTE(v39) = *v14;
                    *v22 = byte_98464[v39];
                    LOBYTE(v39) = v14[1];
                    v22[1] = byte_98464[v39];
                    LOBYTE(v39) = v14[2];
                    v22[2] = byte_98464[v39];
                    LOBYTE(v39) = v14[3];
                    v22[3] = byte_98464[v39];
                    v14 += 4;
                    v22 += 4;
                    v38 -= 4;
                    if ( !v38 )
                    {
                      break;
                    }
                    if ( v38 < 4 )
                    {
                      goto LABEL_49;
                    }
                  }
                }
              }
              v40 = *v14++;
              v41 = v40 & 1;
              v25 = v40 >> 1;
              if ( !(v41 | (v25 == 0)) )
              {
                goto LABEL_40;
              }
              if ( !v25 )
              {
                break;
              }
LABEL_44:
              v38 = v25;
            }
            if ( v41 )
            {
              do
              {
LABEL_36:
                v26 = *v14;
                v27 = v14 + 1;
                v22 += v26;
                v28 = *v27;
                v14 = v27 + 1;
                v29 = v28 & 1;
                v25 = v28 >> 1;
                if ( !(v29 | (v25 == 0)) )
                {
                  goto LABEL_40;
                }
                if ( v25 )
                {
                  goto LABEL_44;
                }
              }
              while ( v29 );
              if ( !v29 )
              {
                goto LABEL_113;
              }
              while ( 1 )
              {
LABEL_40:
                v30 = v25;
LABEL_41:
                v31 = *v14;
                v32 = v14 + 1;
                LOBYTE(v31) = byte_98464[v31];
                v89 = v30;
                v33 = v30 & 3;
                memset(v22, v31, v33);
                v34 = &v22[v33];
                BYTE1(v31) = v31;
                v35 = __ROL4__(v31, 8);
                LOBYTE(v35) = BYTE1(v35);
                v36 = __ROL4__(v35, 8);
                LOBYTE(v36) = BYTE1(v36);
                memset32(v34, v36, v89 >> 2);
                v22 = &v34[4 * (v89 >> 2)];
                LOBYTE(v36) = *v32;
                v14 = v32 + 1;
                v37 = v36 & 1;
                v25 = (unsigned __int8)v36 >> 1;
                if ( v37 | (v25 == 0) )
                {
                  if ( v37 )
                  {
                    if ( !v25 )
                    {
                      goto LABEL_36;
                    }
                    goto LABEL_44;
                  }
                  goto LABEL_113;
                }
              }
            }
            goto LABEL_113;
          }
          while ( 2 )
          {
            if ( (int)v22 > v99 )
            {
              while ( 1 )
              {
                v22 += v38;
                v86 = &v14[v38];
                v87 = *v86;
                v14 = v86 + 1;
                v88 = v87 & 1;
                v82 = v87 >> 1;
                if ( v88 | (v82 == 0) )
                {
                  if ( !v82 )
                  {
                    if ( !v88 )
                    {
                      goto LABEL_113;
                    }
                    goto LABEL_101;
                  }
                }
                else
                {
                  while ( 1 )
                  {
                    do
                    {
LABEL_105:
                      v30 = v82;
LABEL_106:
                      v22 += v30;
                      v83 = v14 + 1;
                      v84 = *v83;
                      v14 = v83 + 1;
                      v85 = v84 & 1;
                      v82 = v84 >> 1;
                    }
                    while ( !(v85 | (v82 == 0)) );
                    if ( !v85 )
                    {
                      goto LABEL_113;
                    }
                    if ( v82 )
                    {
                      break;
                    }
LABEL_101:
                    while ( 1 )
                    {
                      v78 = *v14;
                      v79 = v14 + 1;
                      v22 += v78;
                      v80 = *v79;
                      v14 = v79 + 1;
                      v81 = v80 & 1;
                      v82 = v80 >> 1;
                      if ( !(v81 | (v82 == 0)) )
                      {
                        break;
                      }
                      if ( v82 )
                      {
                        goto LABEL_109;
                      }
                      if ( !v81 )
                      {
                        if ( !v81 )
                        {
                          goto LABEL_113;
                        }
                        goto LABEL_105;
                      }
                    }
                  }
                }
LABEL_109:
                v38 = v82;
              }
            }
            v72 = (unsigned int)&v22[v38 - 1 - v99] & ~((int)&v22[v38 - 1 - v99] >> 0x1F);
            v73 = v38 - v72;
            v74 = 0;
            if ( v73 )
            {
              if ( v73 < 4 )
              {
                do
                {
LABEL_96:
                  LOBYTE(v74) = *v14;
                  *v22 = byte_98464[v74];
                  ++v14;
                  ++v22;
                  --v73;
                }
                while ( v73 );
              }
              else
              {
                while ( 1 )
                {
                  LOBYTE(v74) = *v14;
                  *v22 = byte_98464[v74];
                  LOBYTE(v74) = v14[1];
                  v22[1] = byte_98464[v74];
                  LOBYTE(v74) = v14[2];
                  v22[2] = byte_98464[v74];
                  LOBYTE(v74) = v14[3];
                  v22[3] = byte_98464[v74];
                  v14 += 4;
                  v22 += 4;
                  v73 -= 4;
                  if ( !v73 )
                  {
                    break;
                  }
                  if ( v73 < 4 )
                  {
                    goto LABEL_96;
                  }
                }
              }
            }
            v22 += v72;
            v75 = &v14[v72];
            v76 = *v75;
            v14 = v75 + 1;
            v77 = v76 & 1;
            v59 = v76 >> 1;
            if ( v77 | (v59 == 0) )
            {
              if ( v59 )
              {
LABEL_90:
                v38 = v59;
                continue;
              }
              if ( v77 )
              {
                goto LABEL_81;
              }
              goto LABEL_113;
            }
            break;
          }
        }
        else
        {
          if ( (v103 & 0x400) == 0 )
          {
            v23 = *v14++;
            v24 = v23 & 1;
            v25 = v23 >> 1;
            if ( v24 | (v25 == 0) )
            {
              if ( !v25 )
              {
                if ( !v24 )
                {
                  goto LABEL_113;
                }
                goto LABEL_36;
              }
              goto LABEL_44;
            }
            goto LABEL_40;
          }
          v57 = *v14++;
          v58 = v57 & 1;
          v59 = v57 >> 1;
          if ( v58 | (v59 == 0) )
          {
            if ( v59 )
            {
              goto LABEL_90;
            }
            if ( v58 )
            {
              goto LABEL_81;
            }
            goto LABEL_113;
          }
        }
        do
        {
LABEL_85:
          v30 = v59;
LABEL_86:
          if ( (int)v22 > v99 )
          {
            goto LABEL_106;
          }
          v64 = (unsigned int)&v22[v30 - 1 - v99] & ~((int)&v22[v30 - 1 - v99] >> 0x1F);
          v65 = *v14;
          v66 = v14 + 1;
          LOBYTE(v65) = byte_98464[v65];
          v90 = v30 - v64;
          v67 = (v30 - v64) & 3;
          memset(v22, v65, v67);
          v68 = &v22[v67];
          BYTE1(v65) = v65;
          v69 = __ROL4__(v65, 8);
          LOBYTE(v69) = BYTE1(v69);
          v70 = __ROL4__(v69, 8);
          LOBYTE(v70) = BYTE1(v70);
          memset32(v68, v70, v90 >> 2);
          v22 = &v68[4 * (v90 >> 2) + v64];
          LOBYTE(v70) = *v66;
          v14 = v66 + 1;
          v71 = v70 & 1;
          v59 = (unsigned __int8)v70 >> 1;
        }
        while ( !(v71 | (v59 == 0)) );
        if ( v71 )
        {
          if ( v59 )
          {
            goto LABEL_90;
          }
          do
          {
LABEL_81:
            v60 = *v14;
            v61 = v14 + 1;
            v22 += v60;
            v62 = *v61;
            v14 = v61 + 1;
            v63 = v62 & 1;
            v59 = v62 >> 1;
            if ( !(v63 | (v59 == 0)) )
            {
              goto LABEL_85;
            }
            if ( v59 )
            {
              goto LABEL_90;
            }
          }
          while ( v63 );
          if ( !v63 )
          {
            goto LABEL_113;
          }
          goto LABEL_85;
        }
LABEL_113:
        v101 += v93;
        v100 += v93;
        v99 += v93;
        ++v102;
        continue;
      }
    }
    while ( 1 )
    {
      v19 = *v14++;
      v20 = v19 & 1;
      v21 = v19 >> 1;
      if ( v20 | (v21 == 0) )
      {
        if ( v21 )
        {
          v14 = &v14[v21 - 1];
        }
        else if ( !v20 )
        {
          v17 += v93;
          ++v18;
          goto LABEL_28;
        }
      }
      ++v14;
    }
  }
  sub_5D4FE(a1, v98, v108 - a1->rect.x1, v109 - a1->rect.y1);
  return 0;
}

//----- (0005D4FE) --------------------------------------------------------
int __cdecl sub_5D4FE(P_Type5 a1, _DWORD *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // ebx
  char *v6; // edi
  char *v7; // edx
  int v8; // eax
  bool v9; // cc
  int v10; // ebx
  unsigned __int8 *v11; // esi
  unsigned __int8 v12; // al
  char v13; // cf
  unsigned __int8 v14; // al
  unsigned __int8 v15; // al
  unsigned __int8 *v16; // esi
  unsigned __int8 v17; // al
  char v18; // cf
  unsigned int v19; // ecx
  int v20; // eax
  _BYTE *v21; // esi
  int v22; // ecx
  char *v23; // edi
  int v24; // eax
  int v25; // eax
  char v26; // cf
  int v27; // ecx
  int v28; // eax
  unsigned __int8 v29; // al
  char v30; // cf
  unsigned int v32; // [esp-8h] [ebp-14h]
  int v33; // [esp+1Ch] [ebp+10h]
  int v34; // [esp+20h] [ebp+14h]
  int v35; // [esp+24h] [ebp+18h]

  v33 = a1->rect.x1 + a3;
  v34 = a1->rect.y1 + a4;
  v4 = *(_DWORD *)&a1->a->z1[4];
  v35 = v4 + 1;
  if ( !((v4 + 1 < 0) ^ __OFADD__(1, v4) | (v4 == 0xFFFFFFFF)) )
  {
    v5 = a2[3];
    v6 = (char *)(v35 * (v34 + v5) + v33 + a2[2] + *(_DWORD *)a1->a);
    v7 = v6;
    v8 = a2[5] + 1;
    v9 = v8 <= v5;
    v10 = v8 - v5;
    if ( !v9 )
    {
      v11 = (unsigned __int8 *)(a2 + 6);
      while ( 1 )
      {
        v12 = *v11++;
        v13 = v12 & 1;
        v14 = v12 >> 1;
        if ( !(v13 | (v14 == 0)) )
        {
          goto LABEL_11;
        }
        if ( v14 )
        {
          break;
        }
        if ( v13 )
        {
          goto LABEL_7;
        }
LABEL_22:
        v7 += v35;
        v6 = v7;
        if ( !--v10 )
        {
          return 0;
        }
      }
      do
      {
LABEL_14:
        v27 = v14;
        v28 = 0;
        if ( v27 < 4 )
        {
          do
          {
LABEL_18:
            LOBYTE(v28) = *v11;
            *v6 = byte_98464[v28];
            ++v11;
            ++v6;
            --v27;
          }
          while ( v27 );
        }
        else
        {
          while ( 1 )
          {
            LOBYTE(v28) = *v11;
            *v6 = byte_98464[v28];
            LOBYTE(v28) = v11[1];
            v6[1] = byte_98464[v28];
            LOBYTE(v28) = v11[2];
            v6[2] = byte_98464[v28];
            LOBYTE(v28) = v11[3];
            v6[3] = byte_98464[v28];
            v11 += 4;
            v6 += 4;
            v27 -= 4;
            if ( !v27 )
            {
              break;
            }
            if ( v27 < 4 )
            {
              goto LABEL_18;
            }
          }
        }
        v29 = *v11++;
        v30 = v29 & 1;
        v14 = v29 >> 1;
        if ( !(v30 | (v14 == 0)) )
        {
          goto LABEL_11;
        }
      }
      while ( v14 );
      if ( !v30 )
      {
        goto LABEL_22;
      }
      while ( 1 )
      {
LABEL_7:
        v15 = *v11;
        v16 = v11 + 1;
        v6 += v15;
        v17 = *v16;
        v11 = v16 + 1;
        v18 = v17 & 1;
        v14 = v17 >> 1;
        if ( !(v18 | (v14 == 0)) )
        {
          goto LABEL_11;
        }
        if ( v14 )
        {
          goto LABEL_14;
        }
        if ( !v18 )
        {
          if ( !v18 )
          {
            goto LABEL_22;
          }
          do
          {
LABEL_11:
            v19 = v14;
            v20 = *v11;
            v21 = v11 + 1;
            LOBYTE(v20) = byte_98464[v20];
            v32 = v19;
            v22 = v19 & 3;
            memset(v6, v20, v22);
            v23 = &v6[v22];
            BYTE1(v20) = v20;
            v24 = __ROL4__(v20, 8);
            LOBYTE(v24) = BYTE1(v24);
            v25 = __ROL4__(v24, 8);
            LOBYTE(v25) = BYTE1(v25);
            memset32(v23, v25, v32 >> 2);
            v6 = &v23[4 * (v32 >> 2)];
            LOBYTE(v25) = *v21;
            v11 = v21 + 1;
            v26 = v25 & 1;
            v14 = (unsigned __int8)v25 >> 1;
          }
          while ( !(v26 | (v14 == 0)) );
          if ( !v26 )
          {
            goto LABEL_22;
          }
          if ( v14 )
          {
            goto LABEL_14;
          }
        }
      }
    }
  }
  return 0;
}
// 5D5B6: conditional instruction was optimized away because ecx.4 is in (1..FF)

//----- (0005D631) --------------------------------------------------------
int *__cdecl sub_5D631(
        P_Type5 a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        void (__noreturn *a8)(),
        void (__noreturn *a9)(),
        char a10)
{
  int *v10; // ebp
  unsigned int v11; // eax
  int v12; // eax
  int *z1; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int x1; // eax
  int y1; // eax
  int x2; // eax
  int y2; // eax
  int *result; // eax
  int *v22; // ebx
  int v23; // esi
  int *v24; // edi
  int v25; // ecx
  unsigned __int64 v26; // rt0
  int v27; // edx
  int *v28; // ebx
  int *v29; // esi
  int v30; // ecx
  int v31; // edx
  int v32; // ecx
  __int64 v33; // rt0
  int *v34; // ebx
  int *v35; // esi
  int v36; // ecx
  int v37; // edx
  int v38; // ecx
  __int64 v39; // rt0
  int v40; // eax
  bool v41; // cc
  char *v42; // edi
  int v43; // ecx
  int v44; // ecx
  int v45; // eax
  int v46; // ebx
  int v47; // ecx
  int v48; // edx
  unsigned int v49; // esi
  int v50; // edi
  int v51; // et0
  int v52; // et1
  int v53; // et2
  int v54; // eax
  int v55; // ebx
  int v56; // ebx
  __int64 v57; // rt0
  int v58; // eax
  unsigned int v59; // edx
  unsigned int v60; // ecx
  __int64 v61; // rt0
  int v62; // ebx
  int v63; // eax
  __int16 v64; // dx
  int v65; // ecx
  int v66; // eax
  int v67; // ecx
  int v68; // ecx
  int v69; // eax
  int v70; // eax
  _BYTE *v71; // esi
  int v72; // eax
  _BYTE *v73; // edi
  __int64 v74; // rcx
  int v75; // edx
  int v76; // eax
  int v77; // eax
  int v78; // edx
  int v79; // ebp
  int v80; // ebp
  int v81; // edx
  __int64 v82; // rcx
  _BYTE *v83; // esi
  int v84; // edx
  __int64 v85; // rcx
  _BYTE *v86; // esi
  unsigned int v87; // edx
  __int64 v88; // rcx
  _BYTE *v89; // esi
  unsigned int v90; // edx
  __int64 v91; // rcx
  _BYTE *v92; // esi
  unsigned int v93; // edx
  __int64 v94; // rcx
  _BYTE *v95; // esi
  int v96; // edx
  __int64 v97; // rcx
  _BYTE *v98; // esi
  int v99; // edx
  __int64 v100; // rcx
  _BYTE *v101; // esi
  unsigned int v102; // edx
  __int64 v103; // rcx
  _BYTE *v104; // esi
  _BYTE *v105; // esi
  int v106; // ebx
  bool v107; // zf
  int v109; // ecx
  _DWORD *v110; // ebx
  _DWORD *v111; // esi
  int v112; // ecx
  __int64 v113; // rt0
  _DWORD *v114; // ebx
  _DWORD *v115; // edi
  int v116; // ecx
  __int64 v117; // rt0
  unsigned int v118; // [esp+0h] [ebp-120h]
  int v119; // [esp+0h] [ebp-120h]
  int v120; // [esp+0h] [ebp-120h]
  int v121; // [esp+0h] [ebp-120h]
  int v122; // [esp+0h] [ebp-120h]
  unsigned int v123; // [esp+4h] [ebp-11Ch]
  int *v124; // [esp+4h] [ebp-11Ch]
  int v125; // [esp+8h] [ebp-118h]
  unsigned int v126; // [esp+Ch] [ebp-114h]
  int v127; // [esp+10h] [ebp-110h]
  int v128; // [esp+14h] [ebp-10Ch]
  int v129; // [esp+18h] [ebp-108h]
  int v130; // [esp+18h] [ebp-108h]
  int *v131; // [esp+1Ch] [ebp-104h]
  int v132; // [esp+30h] [ebp-F0h]
  int v133; // [esp+34h] [ebp-ECh]
  int v134; // [esp+38h] [ebp-E8h]
  int v135; // [esp+3Ch] [ebp-E4h]
  int v136; // [esp+40h] [ebp-E0h]
  int v137; // [esp+44h] [ebp-DCh]
  int v138; // [esp+48h] [ebp-D8h]
  int v139; // [esp+4Ch] [ebp-D4h]
  int v140; // [esp+64h] [ebp-BCh]
  int v141; // [esp+68h] [ebp-B8h]
  int v142; // [esp+6Ch] [ebp-B4h]
  int v143; // [esp+70h] [ebp-B0h]
  int v144; // [esp+74h] [ebp-ACh]
  int v145; // [esp+78h] [ebp-A8h]
  int v146; // [esp+7Ch] [ebp-A4h]
  unsigned int v147; // [esp+80h] [ebp-A0h]
  int v148; // [esp+84h] [ebp-9Ch]
  int v149; // [esp+88h] [ebp-98h]
  int v150; // [esp+8Ch] [ebp-94h]
  int v151; // [esp+90h] [ebp-90h]
  int v152; // [esp+94h] [ebp-8Ch]
  int v153; // [esp+98h] [ebp-88h]
  int v154; // [esp+9Ch] [ebp-84h]
  int v155; // [esp+A0h] [ebp-80h]
  int *v156; // [esp+A4h] [ebp-7Ch]
  int *v157; // [esp+A8h] [ebp-78h]
  int *v158; // [esp+ACh] [ebp-74h]
  int *v159; // [esp+B0h] [ebp-70h]
  int *v160; // [esp+B4h] [ebp-6Ch]
  int *v161; // [esp+B8h] [ebp-68h]
  int *v162; // [esp+BCh] [ebp-64h]
  int v163; // [esp+C4h] [ebp-5Ch]
  int v164; // [esp+C8h] [ebp-58h]
  int v165; // [esp+CCh] [ebp-54h]
  int v166; // [esp+D0h] [ebp-50h]
  int v167; // [esp+D4h] [ebp-4Ch]
  int v168; // [esp+D8h] [ebp-48h]
  int v169; // [esp+DCh] [ebp-44h]
  int v170; // [esp+E0h] [ebp-40h] BYREF
  int v171; // [esp+E4h] [ebp-3Ch]
  int v172; // [esp+E8h] [ebp-38h] BYREF
  int v173; // [esp+ECh] [ebp-34h]
  int v174; // [esp+F0h] [ebp-30h] BYREF
  int v175; // [esp+F4h] [ebp-2Ch]
  T_Type5 v176; // [esp+F8h] [ebp-28h] BYREF
  int v177; // [esp+10Ch] [ebp-14h] BYREF
  int v178; // [esp+110h] [ebp-10h]
  int v179; // [esp+114h] [ebp-Ch]
  int savedregs; // [esp+120h] [ebp+0h] BYREF

  v10 = &savedregs;
  if ( a8 == sub_10000 && a9 == sub_10000 && !a7 )
  {
    if ( (a10 & 1) != 0 )
    {
      return (int *)sub_5D026(a1, a2, a3, a4, a5);
    }
    else
    {
      return (int *)sub_5CB3C(a1, a2, a3, a4, a5);
    }
  }
  else
  {
    LOWORD(v11) = sub_610E8(a2, a3);
    v169 = HIWORD(v11) - 1;
    v168 = (unsigned __int16)v11 - 1;
    v176.a = (P_Type6)&v177;
    v177 = a6;
    v176.rect.x1 = 0;
    dword_98570 = 0;
    dword_985AC = 0;
    v176.rect.y1 = 0;
    dword_98574 = 0;
    dword_98588 = 0;
    v178 = v169;
    v176.rect.x2 = v169;
    dword_98584 = v169;
    dword_98598 = v169;
    v179 = v168;
    v176.rect.y2 = v168;
    dword_9859C = v168;
    dword_985B0 = v168;
    LOWORD(v12) = sub_6111C(a2, a3);
    v171 = -(__int16)v12;
    v170 = -(v12 >> 0x10);
    if ( (a10 & 2) == 0 )
    {
      sub_5E9D0(&v176, 0xFF);
      if ( (a10 & 1) != 0 )
      {
        sub_5D026(&v176, a2, a3, v170, v171);
      }
      else
      {
        sub_5CB3C(&v176, a2, a3, v170, v171);
      }
    }
    z1 = (int *)a1->a->z1;
    v14 = *(_DWORD *)&a1->a->z1[4];
    v134 = v14 + 1;
    if ( (v14 + 1 < 0) ^ __OFADD__(1, v14) | (v14 == 0xFFFFFFFF) )
    {
      return (int *)0xFFFFFFFF;
    }
    v15 = z1[2];
    v16 = v15 + 1;
    if ( (v15 + 1 < 0) ^ __OFADD__(1, v15) | (v15 == 0xFFFFFFFF) )
    {
      return (int *)0xFFFFFFFF;
    }
    else
    {
      x1 = a1->rect.x1;
      v133 = x1;
      if ( x1 <= 0 )
      {
        x1 = 0;
      }
      v139 = x1;
      y1 = a1->rect.y1;
      v132 = y1;
      if ( y1 <= 0 )
      {
        y1 = 0;
      }
      v138 = y1;
      x2 = a1->rect.x2;
      if ( x2 >= v134 - 1 )
      {
        x2 = v134 - 1;
      }
      v137 = x2;
      y2 = a1->rect.y2;
      if ( y2 >= v16 - 1 )
      {
        y2 = v16 - 1;
      }
      v136 = y2;
      if ( v137 < v139 || v136 < v138 )
      {
        return (int *)0xFFFFFFFE;
      }
      else
      {
        v135 = *z1;
        v167 = a4 - v170;
        v166 = a5 - v171;
        v174 = 0;
        v175 = 0;
        sub_60579(&v174, &v172, &v170, a7, (int)a8, (int)a9);
        dword_98564 = v167 + v172;
        dword_98568 = v166 + v173;
        v174 = v169;
        v175 = 0;
        sub_60579(&v174, &v172, &v170, a7, (int)a8, (int)a9);
        dword_98564 += v133;
        dword_98578 = v133 + v167 + v172;
        dword_98568 += v132;
        dword_9857C = v132 + v166 + v173;
        v174 = v169;
        v175 = v168;
        sub_60579(&v174, &v172, &v170, a7, (int)a8, (int)a9);
        dword_9858C = v167 + v172;
        dword_98590 = v166 + v173;
        v174 = 0;
        v175 = v168;
        sub_60579(&v174, &v172, &v170, a7, (int)a8, (int)a9);
        dword_9858C += v133;
        dword_985A0 = v133 + v167 + v172;
        dword_98590 += v132;
        dword_985A4 = v132 + v166 + v173;
        v164 = v177;
        v165 = v178 + 1;
        v22 = &dword_98564;
        v162 = &dword_98564;
        v161 = &dword_98564 + 0x14;
        v23 = 0x7FFF;
        v24 = (int *)0xFFFF8000;
        v25 = 0xF;
        do
        {
          HIDWORD(v26) = (unsigned int)(*v22 - v139) >> 0x1F;
          LODWORD(v26) = v137 - *v22;
          HIDWORD(v26) = v26 >> 0x1F;
          LODWORD(v26) = v22[1] - v138;
          HIDWORD(v26) = v26 >> 0x1F;
          LODWORD(v26) = v136 - v22[1];
          v27 = v26 >> 0x1F;
          result = (int *)v22[1];
          if ( (int)result <= v23 )
          {
            v23 = v22[1];
            v160 = v22;
          }
          if ( (int)result >= (int)v24 )
          {
            v24 = result;
          }
          v25 &= v27;
          v22 += 5;
        }
        while ( v22 != v161 );
        if ( !v25 )
        {
          result = v160;
          v157 = v160;
          v156 = v160;
          v152 = v23;
          if ( v24 != (int *)v23 )
          {
            while ( 1 )
            {
              v28 = v157;
              v159 = v157;
              v29 = v157 + 0xFFFFFFFB;
              if ( (int)(v157 + 0xFFFFFFFB) < (int)v162 )
              {
                v29 = v161 + 0xFFFFFFFB;
              }
              v157 = v29;
              v30 = v29[1];
              v31 = v28[1];
              if ( v31 >= v138 || v30 > v138 )
              {
                v32 = v30 - v31;
                if ( v32 )
                {
                  break;
                }
              }
            }
            v155 = v32;
            LODWORD(v33) = 0;
            HIDWORD(v33) = (*v29 - *v28) << 0x10;
            v145 = (v33 >> 0x10) / (v32 << 0x10);
            LODWORD(v33) = 0;
            HIDWORD(v33) = (v29[3] - v28[3]) << 0x10;
            v143 = (v33 >> 0x10) / (v32 << 0x10);
            LODWORD(v33) = 0;
            HIDWORD(v33) = (v29[4] - v28[4]) << 0x10;
            v141 = (v33 >> 0x10) / (v32 << 0x10);
            v151 = (*v28 << 0x10) + 0x8000;
            v149 = (v28[3] << 0x10) + 0x8000;
            v147 = (v28[4] << 0x10) + 0x8000;
            while ( 1 )
            {
              v34 = v156;
              v158 = v156;
              v35 = v156 + 5;
              if ( (int)(v156 + 5) >= (int)v161 )
              {
                v35 = v162;
              }
              v156 = v35;
              v36 = v35[1];
              v37 = v34[1];
              if ( v37 >= v138 || v36 > v138 )
              {
                v38 = v36 - v37;
                if ( v38 )
                {
                  break;
                }
              }
            }
            v154 = v38;
            LODWORD(v39) = 0;
            HIDWORD(v39) = (*v35 - *v34) << 0x10;
            v144 = (v39 >> 0x10) / (v38 << 0x10);
            LODWORD(v39) = 0;
            HIDWORD(v39) = (v35[3] - v34[3]) << 0x10;
            v142 = (v39 >> 0x10) / (v38 << 0x10);
            LODWORD(v39) = 0;
            HIDWORD(v39) = (v35[4] - v34[4]) << 0x10;
            v140 = (v39 >> 0x10) / (v38 << 0x10);
            v150 = (*v34 << 0x10) + 0x8000;
            v148 = (v34[3] << 0x10) + 0x8000;
            v146 = (v34[4] << 0x10) + 0x8000;
            v40 = v136 - v152;
            v41 = (int)v24 <= v136;
            v42 = (char *)v24 - v136;
            if ( v41 )
            {
              v40 += (int)v42;
            }
            v153 = v40;
            if ( v138 > v152 )
            {
              v153 -= v138 - v152;
              v152 = v138;
              v43 = v138 - v159[1];
              v155 -= v43;
              v43 <<= 0x10;
              v151 += (unsigned __int64)(v43 * (__int64)v145) >> 0x10;
              v149 += (unsigned __int64)(v43 * (__int64)v143) >> 0x10;
              v147 += (unsigned __int64)(v43 * (__int64)v141) >> 0x10;
              v44 = v138 - v158[1];
              v154 -= v44;
              v44 <<= 0x10;
              v150 += (unsigned __int64)(v44 * (__int64)v144) >> 0x10;
              v148 += (unsigned __int64)(v44 * (__int64)v142) >> 0x10;
              v146 += (unsigned __int64)(v44 * (__int64)v140) >> 0x10;
            }
            v163 = v135 + v134 * v152;
            v45 = v151;
            v46 = v150;
            v47 = v149;
            v48 = v148;
            v49 = v147;
            v50 = v146;
            while ( 1 )
            {
              v131 = (int *)v45;
              v129 = v46;
              v128 = v47;
              v127 = v48;
              v126 = v49;
              v125 = v50;
              if ( v46 <= v45 )
              {
                v51 = v45;
                v45 = v46;
                v46 = v51;
                v52 = v47;
                v47 = v48;
                v48 = v52;
                v53 = v49;
                v49 = v50;
                v50 = v53;
              }
              v54 = v45 >> 0x10;
              if ( v54 <= v10[0xFFFFFFC9] )
              {
                v55 = v46 >> 0x10;
                if ( v55 >= v10[0xFFFFFFCB] )
                {
                  v10[0xFFFFFFD0] = v54;
                  v10[0xFFFFFFCF] = v55;
                  v10[0xFFFFFFCC] = v47;
                  v56 = v55 - v54;
                  if ( v56 )
                  {
                    LODWORD(v57) = 0;
                    HIDWORD(v57) = v48 - v47;
                    v58 = (v57 >> 0x10) / (v56 << 0x10);
                    v10[0xFFFFFFCE] = v58;
                    v59 = HIWORD(v58);
                    v60 = 1;
                    if ( (v58 & 0x80000000) != 0 )
                    {
                      v60 = 0xFFFFFFFF;
                      v59 = (HIWORD(v58) | 0xFFFF0000) - (((unsigned __int16)v58 == 0) - 1);
                    }
                    v123 = v59 + v60;
                    v118 = v59;
                    LODWORD(v61) = 0;
                    HIDWORD(v61) = v50 - v49;
                    v62 = v56 << 0x10;
                    v63 = (v61 >> 0x10) / v62;
                    v10[0xFFFFFFCD] = v63;
                    HIDWORD(v61) = (v61 >> 0x10) % v62;
                    LODWORD(v61) = v63;
                    v64 = HIWORD(v63);
                    v65 = v10[0xFFFFFFEB];
                    if ( (((unsigned __int64)v61 >> 0x10) & 0x8000) != 0 )
                    {
                      v65 = -v65;
                      v64 = HIWORD(v63) - (((unsigned __int16)v63 == 0) - 1);
                    }
                    v66 = (__int16)(v64 * v10[0xFFFFFFEB]);
                    dword_985B4[0] = v66 + v118;
                    dword_985B8 = v65 + v66 + v118;
                    dword_985BC = v66 + v123;
                    dword_985C0 = v65 + v66 + v123;
                    v67 = v10[0xFFFFFFCB];
                    v41 = v67 <= v10[0xFFFFFFD0];
                    v68 = v67 - v10[0xFFFFFFD0];
                    if ( !v41 )
                    {
                      v10[0xFFFFFFD0] += v68;
                      v109 = v68 << 0x10;
                      v10[0xFFFFFFCC] += (unsigned __int64)(v109 * (__int64)v10[0xFFFFFFCE]) >> 0x10;
                      v49 += (unsigned __int64)(v109 * (__int64)v10[0xFFFFFFCD]) >> 0x10;
                    }
                    v69 = v10[0xFFFFFFCF];
                    v41 = v69 <= v10[0xFFFFFFC9];
                    v70 = v69 - v10[0xFFFFFFC9];
                    if ( !v41 )
                    {
                      v10[0xFFFFFFCF] -= v70;
                    }
                  }
                  LODWORD(v74) = v49;
                  v71 = (_BYTE *)(v10[0xFFFFFFEA] + v10[0xFFFFFFEB] * HIWORD(v49) + HIWORD(v10[0xFFFFFFCC]));
                  v72 = v10[0xFFFFFFD0];
                  v73 = (_BYTE *)(v72 + v10[0xFFFFFFE9]);
                  HIDWORD(v74) = v10[0xFFFFFFCF] - v72;
                  v124 = v10;
                  v75 = v10[0xFFFFFFCC];
                  v76 = v10[0xFFFFFFCE];
                  if ( v76 < 0 )
                  {
                    v76 = -v76;
                    v75 = ~v75;
                  }
                  v77 = v76 << 0x10;
                  v78 = v75 << 0x10;
                  v79 = v10[0xFFFFFFCD];
                  if ( v79 < 0 )
                  {
                    v79 = -v79;
                    LODWORD(v74) = ~(_DWORD)v74;
                  }
                  v80 = v79 << 0x10;
                  LODWORD(v74) = (_DWORD)v74 << 0x10;
                  v119 = HIDWORD(v74);
                  if ( SHIDWORD(v74) < 5 )
                  {
LABEL_78:
                    if ( *v71 != 0xFF )
                    {
                      *v73 = *v71;
                    }
                    HIDWORD(v74) = ((unsigned int)v77 + (unsigned __int64)(unsigned int)v78) >> 0x20;
                    v96 = v77 + v78;
                    v97 = __PAIR64__(HIDWORD(v74), v80) + v74;
                    v98 = &v71[dword_985B4[HIDWORD(v97)]];
                    v120 = v119 - 1;
                    if ( v120 >= 0 )
                    {
                      if ( *v98 != 0xFF )
                      {
                        v73[1] = *v98;
                      }
                      HIDWORD(v97) = ((unsigned int)v77 + (unsigned __int64)(unsigned int)v96) >> 0x20;
                      v99 = v77 + v96;
                      v100 = __PAIR64__(HIDWORD(v97), v80) + v97;
                      v101 = &v98[dword_985B4[HIDWORD(v100)]];
                      v121 = v120 - 1;
                      if ( v121 >= 0 )
                      {
                        if ( *v101 != 0xFF )
                        {
                          v73[2] = *v101;
                        }
                        HIDWORD(v100) = ((unsigned int)v77 + (unsigned __int64)(unsigned int)v99) >> 0x20;
                        v102 = v77 + v99;
                        v103 = __PAIR64__(HIDWORD(v100), v80) + v100;
                        v104 = &v101[dword_985B4[HIDWORD(v103)]];
                        v122 = v121 - 1;
                        if ( v122 >= 0 )
                        {
                          if ( *v104 != 0xFF )
                          {
                            v73[3] = *v104;
                          }
                          HIDWORD(v103) = ((unsigned int)v77 + (unsigned __int64)v102) >> 0x20;
                          v105 = &v104[dword_985B4[(__PAIR64__(HIDWORD(v103), v80) + v103) >> 0x20]];
                          if ( v122 - 1 >= 0 && *v105 != 0xFF )
                          {
                            v73[4] = *v105;
                          }
                        }
                      }
                    }
                  }
                  else
                  {
                    while ( 1 )
                    {
                      if ( *v71 != 0xFF )
                      {
                        *v73 = *v71;
                      }
                      HIDWORD(v74) = ((unsigned int)v77 + (unsigned __int64)(unsigned int)v78) >> 0x20;
                      v81 = v77 + v78;
                      v82 = __PAIR64__(HIDWORD(v74), v80) + v74;
                      v83 = &v71[dword_985B4[HIDWORD(v82)]];
                      if ( *v83 != 0xFF )
                      {
                        v73[1] = *v83;
                      }
                      HIDWORD(v82) = ((unsigned int)v77 + (unsigned __int64)(unsigned int)v81) >> 0x20;
                      v84 = v77 + v81;
                      v85 = __PAIR64__(HIDWORD(v82), v80) + v82;
                      v86 = &v83[dword_985B4[HIDWORD(v85)]];
                      if ( *v86 != 0xFF )
                      {
                        v73[2] = *v86;
                      }
                      HIDWORD(v85) = ((unsigned int)v77 + (unsigned __int64)(unsigned int)v84) >> 0x20;
                      v87 = v77 + v84;
                      v88 = __PAIR64__(HIDWORD(v85), v80) + v85;
                      v89 = &v86[dword_985B4[HIDWORD(v88)]];
                      if ( *v89 != 0xFF )
                      {
                        v73[3] = *v89;
                      }
                      HIDWORD(v88) = ((unsigned int)v77 + (unsigned __int64)v87) >> 0x20;
                      v90 = v77 + v87;
                      v91 = __PAIR64__(HIDWORD(v88), v80) + v88;
                      v92 = &v89[dword_985B4[HIDWORD(v91)]];
                      if ( *v92 != 0xFF )
                      {
                        v73[4] = *v92;
                      }
                      HIDWORD(v91) = ((unsigned int)v77 + (unsigned __int64)v90) >> 0x20;
                      v93 = v77 + v90;
                      v94 = __PAIR64__(HIDWORD(v91), v80) + v91;
                      v95 = &v92[dword_985B4[HIDWORD(v94)]];
                      if ( *v95 != 0xFF )
                      {
                        v73[5] = *v95;
                      }
                      HIDWORD(v94) = ((unsigned int)v77 + (unsigned __int64)v93) >> 0x20;
                      v78 = v77 + v93;
                      v74 = __PAIR64__(HIDWORD(v94), v80) + v94;
                      v71 = &v95[dword_985B4[HIDWORD(v74)]];
                      v73 += 6;
                      v119 -= 6;
                      if ( v119 < 0 )
                      {
                        break;
                      }
                      if ( v119 < 5 )
                      {
                        goto LABEL_78;
                      }
                    }
                  }
                  v10 = v124;
                }
              }
              v10[0xFFFFFFE9] += v10[0xFFFFFFC6];
              v106 = v129;
              result = v131;
              v107 = v10[0xFFFFFFDE] == 1;
              if ( --v10[0xFFFFFFDE] < 0 )
              {
                break;
              }
              if ( v107 )
              {
                v45 = (int)v131 + v10[0xFFFFFFD6];
                v47 = v10[0xFFFFFFD4] + v128;
                v49 = v10[0xFFFFFFD2] + v126;
                v46 = v10[0xFFFFFFD5] + v129;
                v48 = v10[0xFFFFFFD3] + v127;
                v50 = v10[0xFFFFFFD1] + v125;
              }
              else
              {
                v107 = v10[0xFFFFFFE0]-- == 1;
                if ( v107 )
                {
                  v110 = (_DWORD *)v10[0xFFFFFFE2];
                  v10[0xFFFFFFE4] = (int)v110;
                  v111 = v110 + 0xFFFFFFFB;
                  if ( (int)(v110 + 0xFFFFFFFB) < v10[0xFFFFFFE7] )
                  {
                    v111 = (_DWORD *)(v10[0xFFFFFFE6] - 0x14);
                  }
                  v10[0xFFFFFFE2] = (int)v111;
                  v112 = (v111[1] == v110[1]) + v111[1] - v110[1];
                  v10[0xFFFFFFE0] = v112;
                  LODWORD(v113) = 0;
                  HIDWORD(v113) = (*v111 - *v110) << 0x10;
                  v10[0xFFFFFFD6] = (v113 >> 0x10) / (v112 << 0x10);
                  LODWORD(v113) = 0;
                  HIDWORD(v113) = (v111[3] - v110[3]) << 0x10;
                  v10[0xFFFFFFD4] = (v113 >> 0x10) / (v10[0xFFFFFFE0] << 0x10);
                  LODWORD(v113) = 0;
                  HIDWORD(v113) = (v111[4] - v110[4]) << 0x10;
                  v10[0xFFFFFFD2] = (v113 >> 0x10) / (v10[0xFFFFFFE0] << 0x10);
                  v45 = (*v110 << 0x10) + 0x8000;
                  v47 = (v110[3] << 0x10) + 0x8000;
                  v49 = (v110[4] << 0x10) + 0x8000;
                  v106 = v129;
                }
                else
                {
                  v45 = (int)v131 + v10[0xFFFFFFD6];
                  v47 = v10[0xFFFFFFD4] + v128;
                  v49 = v10[0xFFFFFFD2] + v126;
                }
                v107 = v10[0xFFFFFFDF]-- == 1;
                if ( v107 )
                {
                  v130 = v47;
                  v114 = (_DWORD *)v10[0xFFFFFFE1];
                  v10[0xFFFFFFE3] = (int)v114;
                  v115 = v114 + 5;
                  if ( (int)(v114 + 5) >= v10[0xFFFFFFE6] )
                  {
                    v115 = (_DWORD *)v10[0xFFFFFFE7];
                  }
                  v10[0xFFFFFFE1] = (int)v115;
                  v116 = (v115[1] == v114[1]) + v115[1] - v114[1];
                  v10[0xFFFFFFDF] = v116;
                  LODWORD(v117) = 0;
                  HIDWORD(v117) = (*v115 - *v114) << 0x10;
                  v10[0xFFFFFFD5] = (v117 >> 0x10) / (v116 << 0x10);
                  LODWORD(v117) = 0;
                  HIDWORD(v117) = (v115[3] - v114[3]) << 0x10;
                  v10[0xFFFFFFD3] = (v117 >> 0x10) / (v10[0xFFFFFFDF] << 0x10);
                  LODWORD(v117) = 0;
                  HIDWORD(v117) = (v115[4] - v114[4]) << 0x10;
                  v10[0xFFFFFFD1] = (v117 >> 0x10) / (v10[0xFFFFFFDF] << 0x10);
                  v48 = (v114[3] << 0x10) + 0x8000;
                  v50 = (v114[4] << 0x10) + 0x8000;
                  v46 = (*v114 << 0x10) + 0x8000;
                  v47 = v130;
                }
                else
                {
                  v46 = v10[0xFFFFFFD5] + v106;
                  v48 = v10[0xFFFFFFD3] + v127;
                  v50 = v10[0xFFFFFFD1] + v125;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 5D66D: variable 'v11' is possibly undefined
// 5D6F9: variable 'v12' is possibly undefined
// 10000: using guessed type void __noreturn sub_10000();
// 98564: using guessed type int dword_98564;
// 98568: using guessed type int dword_98568;
// 98570: using guessed type int dword_98570;
// 98574: using guessed type int dword_98574;
// 98578: using guessed type int dword_98578;
// 9857C: using guessed type int dword_9857C;
// 98584: using guessed type int dword_98584;
// 98588: using guessed type int dword_98588;
// 9858C: using guessed type int dword_9858C;
// 98590: using guessed type int dword_98590;
// 98598: using guessed type int dword_98598;
// 9859C: using guessed type int dword_9859C;
// 985A0: using guessed type int dword_985A0;
// 985A4: using guessed type int dword_985A4;
// 985AC: using guessed type int dword_985AC;
// 985B0: using guessed type int dword_985B0;
// 985B4: using guessed type int dword_985B4[];
// 985B8: using guessed type int dword_985B8;
// 985BC: using guessed type int dword_985BC;
// 985C0: using guessed type int dword_985C0;

//----- (0005E1DD) --------------------------------------------------------
int __cdecl sub_5E1DD(int a1, int a2, int a3, int a4, char a5, int *a6)
{
  int v6; // ebx
  int v7; // eax
  bool v8; // cc
  int v9; // ebx
  unsigned __int8 *v10; // esi
  int v11; // edx
  int v12; // edi
  unsigned __int8 v13; // al
  char v14; // cf
  unsigned __int8 v15; // al
  unsigned __int8 v16; // al
  unsigned __int8 *v17; // esi
  unsigned __int8 v18; // al
  char v19; // cf
  unsigned __int8 *v20; // esi
  unsigned __int8 v21; // al
  char v22; // cf
  unsigned __int8 *v23; // esi
  unsigned __int8 v24; // al
  char v25; // cf
  int v26; // ebx
  int v27; // ebx
  signed int v29; // [esp+Ch] [ebp-24h]
  signed int v30; // [esp+10h] [ebp-20h]
  int v31; // [esp+14h] [ebp-1Ch]
  int v32; // [esp+18h] [ebp-18h]
  int v33; // [esp+24h] [ebp-Ch]
  _DWORD *v34; // [esp+2Ch] [ebp-4h]

  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v34 = (_DWORD *)(a1 + *(_DWORD *)(a1 + 8 * a2 + 8));
  v6 = v34[3];
  v33 = a4 + v6;
  v7 = v34[5] + 1;
  v8 = v7 <= v6;
  v9 = v7 - v6;
  if ( !v8 )
  {
    v10 = (unsigned __int8 *)(v34 + 6);
    v32 = 0x7FFFFFFF;
    v31 = 0x7FFFFFFF;
    v30 = 0x80000000;
    v29 = 0x80000000;
    v11 = v33;
    do
    {
      v12 = a3 + v34[2];
      v13 = *v10++;
      v14 = v13 & 1;
      v15 = v13 >> 1;
      if ( !(v14 | (v15 == 0)) )
      {
        goto LABEL_10;
      }
      if ( v15 )
      {
        goto LABEL_21;
      }
      if ( v14 )
      {
        do
        {
LABEL_6:
          v16 = *v10;
          v17 = v10 + 1;
          v12 += v16;
          v18 = *v17;
          v10 = v17 + 1;
          v19 = v18 & 1;
          v15 = v18 >> 1;
          if ( !(v19 | (v15 == 0)) )
          {
            goto LABEL_10;
          }
          if ( v15 )
          {
            goto LABEL_21;
          }
        }
        while ( v19 );
        if ( v19 )
        {
          while ( 1 )
          {
            do
            {
LABEL_10:
              v20 = v10 + 1;
              if ( v32 >= v12 )
              {
                v32 = v12;
              }
              v12 += v15;
              if ( v30 <= v12 )
              {
                v30 = v12;
              }
              if ( v31 >= v11 )
              {
                v31 = v11;
              }
              if ( v29 <= v11 )
              {
                v29 = v11;
              }
              v21 = *v20;
              v10 = v20 + 1;
              v22 = v21 & 1;
              v15 = v21 >> 1;
            }
            while ( !(v22 | (v15 == 0)) );
            if ( !v22 )
            {
              break;
            }
            if ( !v15 )
            {
              goto LABEL_6;
            }
            while ( 1 )
            {
LABEL_21:
              v23 = &v10[v15];
              if ( v32 >= v12 )
              {
                v32 = v12;
              }
              v12 += v15;
              if ( v30 <= v12 )
              {
                v30 = v12;
              }
              if ( v31 >= v11 )
              {
                v31 = v11;
              }
              if ( v29 <= v11 )
              {
                v29 = v11;
              }
              v24 = *v23;
              v10 = v23 + 1;
              v25 = v24 & 1;
              v15 = v24 >> 1;
              if ( !(v25 | (v15 == 0)) )
              {
                break;
              }
              if ( !v15 )
              {
                if ( v25 )
                {
                  goto LABEL_6;
                }
                goto LABEL_32;
              }
            }
          }
        }
      }
LABEL_32:
      ++v11;
      --v9;
    }
    while ( v9 );
  }
  if ( (a5 & 1) != 0 )
  {
    v26 = 2 * a3 - v30;
    v30 = 2 * a3 - v32;
    v32 = v26;
  }
  if ( (a5 & 2) != 0 )
  {
    v27 = 2 * a4 - v29;
    v29 = 2 * a4 - v31;
    v31 = v27;
  }
  *a6 = v32;
  a6[1] = v31;
  a6[2] = v30;
  a6[3] = v29;
  return 0;
}

//----- (0005E66A) --------------------------------------------------------
void __cdecl sub_5E66A(int a1, char a2, int a3)
{
  char *v3; // esi
  char v4; // al
  int v5; // ecx
  char v6; // ah
  char v7; // al
  char v8; // al
  char v9; // al
  char v10; // al
  char v11; // al
  char v12; // al
  char v13; // al
  char v14; // al
  char v15; // al
  char v16; // al
  int v17; // [esp+Ch] [ebp-4h]

  v3 = (char *)dword_96C1D;
  dword_96C21 = dword_96C1D;
  sub_5E7F3(0, 0, a3);
  v17 = 5;
  if ( a1 )
  {
    v4 = *v3++;
    v5 = a1 - 1;
    v6 = v4;
    if ( v4 == a2 )
    {
      goto LABEL_18;
    }
LABEL_3:
    v17 = 1;
    if ( v5 )
    {
      v7 = *v3++;
      --v5;
      v8 = v6 ^ v7;
      v6 ^= v8;
      if ( !v8 )
      {
        goto LABEL_15;
      }
      if ( v6 == a2 )
      {
LABEL_12:
        dword_96C21 = (int)v3;
        sub_5E7F3(1, 1, a3);
        goto LABEL_18;
      }
      while ( v5 )
      {
        v9 = *v3++;
        --v5;
        v10 = v6 ^ v9;
        v6 ^= v10;
        if ( v6 == a2 )
        {
          goto LABEL_12;
        }
        if ( !v10 )
        {
          if ( !v5 )
          {
            break;
          }
          v11 = *v3++;
          --v5;
          v12 = v6 ^ v11;
          v6 ^= v12;
          if ( v6 == a2 )
          {
            goto LABEL_12;
          }
          if ( !v12 )
          {
            dword_96C21 = (int)v3;
            sub_5E7F3(1, 3, a3);
            do
            {
LABEL_15:
              v17 = 2;
              if ( !v5 )
              {
                goto LABEL_21;
              }
              v13 = *v3++;
              --v5;
              v14 = v6 ^ v13;
            }
            while ( !v14 );
            v6 ^= v14;
            dword_96C21 = (int)v3;
            sub_5E7F3(2, 1, a3);
            if ( v6 == a2 )
            {
              do
              {
LABEL_18:
                v17 = 3;
                if ( !v5 )
                {
                  goto LABEL_21;
                }
                v15 = *v3++;
                --v5;
                v16 = v6 ^ v15;
              }
              while ( !v16 );
              v6 ^= v16;
              dword_96C21 = (int)v3;
              sub_5E7F3(3, 1, a3);
            }
            goto LABEL_3;
          }
        }
      }
    }
  }
LABEL_21:
  dword_96C21 = (int)v3;
  sub_5E7F3(v17, 0, a3);
  sub_5E7F3(4, 0, a3);
}
// 96C1D: using guessed type int dword_96C1D;
// 96C21: using guessed type int dword_96C21;

//----- (0005E7F3) --------------------------------------------------------
void __cdecl __spoils<edx> sub_5E7F3(int a1, int a2, int a3)
{
  _BYTE *v3; // esi
  char *v4; // edi
  int v5; // ebx
  int v6; // ecx
  _BYTE *v7; // edi
  int v8; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  _BYTE *v12; // edi
  int v13; // ebx
  int v14; // ecx
  _BYTE *v15; // edi
  int v16; // ebx
  int v17; // eax
  int v18; // eax
  unsigned int v19; // ecx
  char *v20; // edi

  v3 = (_BYTE *)dword_96C29;
  v4 = (char *)dword_96C25;
  switch ( a1 )
  {
    case 2:
      v5 = dword_96C19;
      if ( dword_96C19 )
      {
        do
        {
          v6 = v5;
          if ( v5 >= 0xFF )
          {
            v6 = 0xFF;
          }
          v5 -= v6;
          if ( dword_96C15 )
          {
            *v4 = 1;
            v7 = v4 + 1;
            *v7 = v6;
            v4 = v7 + 1;
          }
          else
          {
            v4 += 2;
          }
          v3 += v6;
        }
        while ( v5 );
        dword_96C19 = 0;
      }
      v8 = dword_96C21 - (_DWORD)v3 - a2;
      v9 = (int)&v3[a3 - dword_96C1D];
      if ( v9 < dword_96C3D )
      {
        dword_96C3D = (int)&v3[a3 - dword_96C1D];
      }
      v10 = v8 + v9 - 1;
      if ( v10 <= dword_96C45 )
      {
        goto LABEL_19;
      }
      dword_96C45 = v10;
      while ( v8 )
      {
LABEL_19:
        v11 = v8;
        if ( v8 >= 0x7F )
        {
          v11 = 0x7F;
        }
        if ( dword_96C15 )
        {
          *v4 = 2 * v11;
          v12 = v4 + 1;
          *v12 = *v3;
          v4 = v12 + 1;
        }
        else
        {
          v4 += 2;
        }
        v3 += v11;
        v8 -= v11;
      }
      break;
    case 1:
      v13 = dword_96C19;
      if ( dword_96C19 )
      {
        do
        {
          v14 = v13;
          if ( v13 >= 0xFF )
          {
            v14 = 0xFF;
          }
          v13 -= v14;
          if ( dword_96C15 )
          {
            *v4 = 1;
            v15 = v4 + 1;
            *v15 = v14;
            v4 = v15 + 1;
          }
          else
          {
            v4 += 2;
          }
          v3 += v14;
        }
        while ( v13 );
        dword_96C19 = 0;
      }
      v16 = dword_96C21 - (_DWORD)v3 - a2;
      v17 = (int)&v3[a3 - dword_96C1D];
      if ( v17 < dword_96C3D )
      {
        dword_96C3D = (int)&v3[a3 - dword_96C1D];
      }
      v18 = v16 + v17 - 1;
      if ( v18 <= dword_96C45 )
      {
        goto LABEL_39;
      }
      dword_96C45 = v18;
      while ( v16 )
      {
LABEL_39:
        v19 = v16;
        if ( v16 >= 0x7F )
        {
          v19 = 0x7F;
        }
        if ( dword_96C15 )
        {
          *v4 = 2 * v19 + 1;
          v20 = v4 + 1;
          qmemcpy(v20, v3, v19);
          v3 += v19;
          v4 = &v20[v19];
        }
        else
        {
          v3 += v19;
          v4 += v19 + 1;
        }
        v16 -= v19;
      }
      break;
    case 3:
      dword_96C19 = dword_96C21 - dword_96C29 - a2;
      break;
    case 4:
      if ( dword_96C15 )
      {
        *(_BYTE *)dword_96C25 = 0;
      }
      ++v4;
      break;
    case 0:
      dword_96C19 = 0;
      v3 = (_BYTE *)dword_96C21;
      dword_96C29 = dword_96C21;
      break;
  }
  dword_96C25 = (int)v4;
  dword_96C29 = (int)v3;
}
// 96C15: using guessed type int dword_96C15;
// 96C19: using guessed type int dword_96C19;
// 96C1D: using guessed type int dword_96C1D;
// 96C21: using guessed type int dword_96C21;
// 96C25: using guessed type int dword_96C25;
// 96C29: using guessed type int dword_96C29;
// 96C3D: using guessed type int dword_96C3D;
// 96C45: using guessed type int dword_96C45;

//----- (0005E9D0) --------------------------------------------------------
unsigned int __cdecl sub_5E9D0(P_Type5 a1, char a2)
{
  P_Type6 v1; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int x1; // eax
  int y1; // eax
  int x2; // eax
  int y2; // eax
  int v11; // eax
  char *v12; // edi
  unsigned int v13; // ebx
  int v14; // eax
  int i; // edx
  int v16; // ecx
  char *v17; // edi
  int v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-10h]
  int v20; // [esp+20h] [ebp-Ch]
  int v21; // [esp+24h] [ebp-8h]
  int v22; // [esp+28h] [ebp-4h]

  v1 = a1->a;
  v3 = *(_DWORD *)&a1->a->z1[4];
  v18 = v3 + 1;
  if ( (v3 + 1 < 0) ^ __OFADD__(1, v3) | (v3 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v4 = *(_DWORD *)&v1->z1[8];
  v5 = v4 + 1;
  if ( (v4 + 1 < 0) ^ __OFADD__(1, v4) | (v4 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  x1 = a1->rect.x1;
  if ( x1 <= 0 )
  {
    x1 = 0;
  }
  v22 = x1;
  y1 = a1->rect.y1;
  if ( y1 <= 0 )
  {
    y1 = 0;
  }
  v21 = y1;
  x2 = a1->rect.x2;
  if ( x2 >= v18 - 1 )
  {
    x2 = v18 - 1;
  }
  v20 = x2;
  y2 = a1->rect.y2;
  if ( y2 >= v5 - 1 )
  {
    y2 = v5 - 1;
  }
  v19 = y2;
  if ( v20 < v22 || y2 < v21 )
  {
    return 0xFFFFFFFE;
  }
  v11 = v22 + *(_DWORD *)v1->z1 + v18 * v21;
  v12 = (char *)v11;
  v13 = v20 + 1 - v22;
  LOBYTE(v11) = a2;
  BYTE1(v11) = a2;
  v14 = v11 << 0x10;
  LOBYTE(v14) = a2;
  BYTE1(v14) = a2;
  for ( i = v21; i <= v19; ++i )
  {
    v16 = v13 & 3;
    memset(v12, v14, v16);
    v17 = &v12[v16];
    memset32(v17, v14, v13 >> 2);
    v12 = &v17[4 * (v13 >> 2) + v18 - v13];
  }
  return 0;
}

//----- (0005EAAF) --------------------------------------------------------
unsigned int __cdecl sub_5EAAF(int **a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7)
{
  int *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  _DWORD *v16; // ebx
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // esi
  int v33; // edi
  int v34; // esi
  int v35; // edi
  char *v36; // esi
  char *v37; // edi
  int v38; // eax
  int v39; // edx
  int v40; // ecx
  char *v41; // esi
  char *v42; // edi
  int v43; // eax
  int v44; // edx
  int v45; // ecx
  char *v46; // edi
  int v47; // [esp+Ch] [ebp-9Ch]
  int v48; // [esp+10h] [ebp-98h]
  int v49; // [esp+14h] [ebp-94h]
  int v50; // [esp+1Ch] [ebp-8Ch]
  int v51; // [esp+20h] [ebp-88h]
  int v52; // [esp+24h] [ebp-84h]
  int v53; // [esp+28h] [ebp-80h]
  int v54; // [esp+2Ch] [ebp-7Ch]
  int v55; // [esp+30h] [ebp-78h]
  int v56; // [esp+34h] [ebp-74h]
  int v57; // [esp+38h] [ebp-70h]
  int v58; // [esp+3Ch] [ebp-6Ch]
  int v59; // [esp+40h] [ebp-68h]
  int v60; // [esp+44h] [ebp-64h]
  int v61; // [esp+48h] [ebp-60h]
  int v62; // [esp+4Ch] [ebp-5Ch]
  unsigned int v63; // [esp+50h] [ebp-58h]
  int v64; // [esp+58h] [ebp-50h]
  unsigned int v65; // [esp+58h] [ebp-50h]
  int v66; // [esp+5Ch] [ebp-4Ch]
  int v67; // [esp+60h] [ebp-48h]
  int v68; // [esp+64h] [ebp-44h]
  int v69; // [esp+6Ch] [ebp-3Ch]
  unsigned int v70; // [esp+6Ch] [ebp-3Ch]
  int v71; // [esp+70h] [ebp-38h]
  int v72; // [esp+74h] [ebp-34h]
  int v73; // [esp+78h] [ebp-30h]
  int v74; // [esp+7Ch] [ebp-2Ch]
  int v75; // [esp+80h] [ebp-28h]
  int v76; // [esp+84h] [ebp-24h]
  int v77; // [esp+8Ch] [ebp-1Ch]
  int v78; // [esp+90h] [ebp-18h]
  int v79; // [esp+94h] [ebp-14h]
  int v80; // [esp+98h] [ebp-10h]
  int v81; // [esp+9Ch] [ebp-Ch]
  int v82; // [esp+A0h] [ebp-8h]
  int v83; // [esp+A4h] [ebp-4h]

  v7 = *a1;
  v8 = (*a1)[1];
  v57 = v8 + 1;
  if ( (v8 + 1 < 0) ^ __OFADD__(1, v8) | (v8 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v9 = v7[2];
  v10 = v9 + 1;
  if ( (v9 + 1 < 0) ^ __OFADD__(1, v9) | (v9 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v11 = (int)a1[1];
  v55 = v11;
  if ( v11 <= 0 )
  {
    v11 = 0;
  }
  v61 = v11;
  v12 = (int)a1[2];
  v54 = v12;
  if ( v12 <= 0 )
  {
    v12 = 0;
  }
  v60 = v12;
  v13 = (int)a1[3];
  if ( v13 >= v57 - 1 )
  {
    v13 = v57 - 1;
  }
  v59 = v13;
  v14 = (int)a1[4];
  if ( v14 >= v10 - 1 )
  {
    v14 = v10 - 1;
  }
  v58 = v14;
  if ( v59 < v61 || v14 < v60 )
  {
    return 0xFFFFFFFE;
  }
  v56 = *v7;
  v74 = v61 - v55;
  v72 = v59 - v55;
  v73 = v60 - v54;
  v71 = v14 - v54;
  v16 = (_DWORD *)*a4;
  v17 = *(_DWORD *)(*a4 + 4);
  v49 = v17 + 1;
  if ( (v17 + 1 < 0) ^ __OFADD__(1, v17) | (v17 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v18 = v16[2];
  v19 = v18 + 1;
  if ( (v18 + 1 < 0) ^ __OFADD__(1, v18) | (v18 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v20 = a4[1];
  v48 = v20;
  if ( v20 <= 0 )
  {
    v20 = 0;
  }
  v53 = v20;
  v21 = a4[2];
  v47 = v21;
  if ( v21 <= 0 )
  {
    v21 = 0;
  }
  v52 = v21;
  v22 = a4[3];
  if ( v22 >= v49 - 1 )
  {
    v22 = v49 - 1;
  }
  v51 = v22;
  v23 = a4[4];
  if ( v23 >= v19 - 1 )
  {
    v23 = v19 - 1;
  }
  v50 = v23;
  if ( v51 < v53 || v23 < v52 )
  {
    return 0xFFFFFFFE;
  }
  v67 = v51 - v48;
  v68 = v52 - v47;
  v66 = v23 - v47;
  v76 = a2 - a5;
  v75 = a3 - a6;
  v24 = v61 - v55;
  if ( v74 <= a2 - a5 + v53 - v48 )
  {
    v24 = a2 - a5 + v53 - v48;
  }
  v83 = v24;
  v25 = v60 - v54;
  if ( v73 <= v75 + v68 )
  {
    v25 = v75 + v68;
  }
  v82 = v25;
  v26 = v59 - v55;
  if ( v72 >= v76 + v67 )
  {
    v26 = v76 + v67;
  }
  v81 = v26;
  v27 = v58 - v54;
  if ( v71 >= v75 + v66 )
  {
    v27 = v75 + v66;
  }
  v80 = v27;
  if ( v81 < v83 || v27 < v82 )
  {
    return 0xFFFFFFFD;
  }
  v28 = v53 - v48;
  if ( v53 - v48 <= v74 - v76 )
  {
    v28 = v74 - v76;
  }
  v79 = v28;
  v29 = v52 - v47;
  if ( v68 <= v73 - v75 )
  {
    v29 = v73 - v75;
  }
  v78 = v29;
  v30 = v51 - v48;
  if ( v67 >= v72 - v76 )
  {
    v30 = v72 - v76;
  }
  v77 = v30;
  v31 = v50 - v47;
  if ( v66 >= v71 - v75 )
  {
    v31 = v71 - v75;
  }
  v63 = v81 + 1 - v83;
  v32 = v55 + v56 + v57 * v54;
  v33 = v48 + *v16 + v49 * v47;
  if ( v82 <= v78 )
  {
    v34 = v57 * v80 + v32;
    v35 = v49 * v31 + v33;
    v69 = -v57;
    v64 = -v49;
  }
  else
  {
    v34 = v57 * v82 + v32;
    v35 = v49 * v78 + v33;
    v69 = v57;
    v64 = v49;
  }
  if ( v83 <= v79 )
  {
    v36 = (char *)(v81 + v34);
    v37 = (char *)(v77 + v35);
    v70 = v63 + v69;
    v65 = v63 + v64;
    v62 = 3;
  }
  else
  {
    v36 = (char *)(v83 + v34);
    v37 = (char *)(v79 + v35);
    v70 = v69 - v63;
    v65 = v64 - v63;
    v62 = 0;
  }
  v38 = a7;
  if ( (a7 & 0xFFFFFF00) != 0 )
  {
    v39 = v80 + 1 - v82;
    do
    {
      v40 = v63 & 3;
      qmemcpy(v37, v36, v40);
      v41 = &v36[v40 - v62];
      v42 = &v37[v40 - v62];
      qmemcpy(v42, v41, 4 * (v63 >> 2));
      v36 = &v41[4 * (v63 >> 2) + v62 + v70];
      v37 = &v42[4 * (v63 >> 2) + v62 + v65];
      --v39;
    }
    while ( v39 );
  }
  else
  {
    BYTE1(v38) = a7;
    v43 = v38 << 0x10;
    LOBYTE(v43) = a7;
    BYTE1(v43) = a7;
    v44 = v80 + 1 - v82;
    do
    {
      v45 = v63 & 3;
      memset(v37, v43, v45);
      v46 = &v37[v45 - v62];
      memset32(v46, v43, v63 >> 2);
      v37 = &v46[4 * (v63 >> 2) + v62 + v65];
      --v44;
    }
    while ( v44 );
  }
  return 0;
}

//----- (0005F048) --------------------------------------------------------
unsigned int __cdecl sub_5F048(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        void (__fastcall *a6)(_DWORD, _DWORD, _DWORD, _DWORD))
{
  unsigned int result; // eax
  int *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ebx
  int v16; // edi
  int v17; // edx
  int v18; // edi
  int v19; // edx
  int v20; // edi
  int v21; // edx
  int v22; // edi
  int v23; // edx
  int v24; // edi
  int v25; // edx
  int v26; // edi
  int v27; // edx
  int v28; // edi
  int v29; // edx
  int v30; // edi
  int v31; // edx
  int v32; // [esp-8h] [ebp-68h]
  int v33; // [esp+Ch] [ebp-54h]
  int v34; // [esp+10h] [ebp-50h]
  int v35; // [esp+14h] [ebp-4Ch]
  int v36; // [esp+18h] [ebp-48h]
  int v37; // [esp+1Ch] [ebp-44h]
  int v38; // [esp+20h] [ebp-40h]
  int v39; // [esp+24h] [ebp-3Ch]
  int v40; // [esp+28h] [ebp-38h]
  signed int v41; // [esp+34h] [ebp-2Ch]
  int v42; // [esp+34h] [ebp-2Ch]
  int v43; // [esp+38h] [ebp-28h]
  int v44; // [esp+3Ch] [ebp-24h]
  int v45; // [esp+40h] [ebp-20h]
  int v46; // [esp+44h] [ebp-1Ch]
  int v47; // [esp+48h] [ebp-18h]
  int v48; // [esp+4Ch] [ebp-14h]
  int v49; // [esp+50h] [ebp-10h]
  int v50; // [esp+54h] [ebp-Ch]
  int v51; // [esp+58h] [ebp-8h]
  int v52; // [esp+5Ch] [ebp-4h]

  if ( !a4 || !a5 )
  {
    return sub_5C001((int **)a1, a2 - a4, a3 - a5, a4 + a2, a5 + a3, 0, a6);
  }
  v7 = *(int **)a1;
  v8 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v35 = v8 + 1;
  if ( (v8 + 1 < 0) ^ __OFADD__(1, v8) | (v8 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v9 = v7[2];
  v10 = v9 + 1;
  if ( (v9 + 1 < 0) ^ __OFADD__(1, v9) | (v9 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v11 = *(_DWORD *)(a1 + 4);
  v34 = v11;
  if ( v11 <= 0 )
  {
    v11 = 0;
  }
  v40 = v11;
  v12 = *(_DWORD *)(a1 + 8);
  v33 = v12;
  if ( v12 <= 0 )
  {
    v12 = 0;
  }
  v39 = v12;
  v13 = *(_DWORD *)(a1 + 0xC);
  if ( v13 >= v35 - 1 )
  {
    v13 = v35 - 1;
  }
  v38 = v13;
  v14 = *(_DWORD *)(a1 + 0x10);
  if ( v14 >= v10 - 1 )
  {
    v14 = v10 - 1;
  }
  v37 = v14;
  if ( v38 < v40 || v14 < v39 )
  {
    return 0xFFFFFFFE;
  }
  v36 = *v7;
  v52 = v34 + a2;
  v51 = v33 + a3;
  v50 = 0;
  v49 = a5;
  v46 = v49 * v49;
  v45 = 2 * v49 * v49;
  v48 = a4 * a4;
  v47 = 2 * a4 * a4;
  v44 = 0;
  v43 = a5 * v47;
  v41 = v49 * v49 + ((unsigned int)(a4 * a4) >> 2) - a5 * a4 * a4;
  v15 = a5;
  while ( v44 - v43 < 0 )
  {
    v16 = v50 + v52;
    v17 = v49 + v51;
    if ( v50 + v52 >= v40 && v16 <= v38 && v17 >= v39 && v17 <= v14 )
    {
      *(_BYTE *)(v16 + v36 + v35 * v17) = (_BYTE)a6;
    }
    v18 = v50 + v52;
    v19 = v51 - v49;
    if ( v50 + v52 >= v40 && v18 <= v38 && v19 >= v39 && v19 <= v14 )
    {
      *(_BYTE *)(v18 + v36 + v35 * v19) = (_BYTE)a6;
    }
    v20 = v52 - v50;
    v21 = v49 + v51;
    if ( v52 - v50 >= v40 && v20 <= v38 && v21 >= v39 && v21 <= v14 )
    {
      *(_BYTE *)(v20 + v36 + v35 * v21) = (_BYTE)a6;
    }
    v22 = v52 - v50;
    v23 = v51 - v49;
    if ( v52 - v50 >= v40 && v22 <= v38 && v23 >= v39 && v23 <= v14 )
    {
      *(_BYTE *)(v22 + v36 + v35 * v23) = (_BYTE)a6;
    }
    if ( v41 >= 0 )
    {
      --v49;
      --v15;
      v43 -= v47;
      v41 -= v43;
    }
    ++v50;
    v44 += v45;
    v41 += v46 + v44;
  }
  v42 = ((v48 - v46 + ((v48 - v46) >> 1) - v44 - v43) >> 1) + v41;
  do
  {
    v32 = v15;
    v24 = v50 + v52;
    v25 = v49 + v51;
    if ( v50 + v52 >= v40 && v24 <= v38 && v25 >= v39 && v25 <= v37 )
    {
      *(_BYTE *)(v24 + v36 + v35 * v25) = (_BYTE)a6;
    }
    v26 = v50 + v52;
    v27 = v51 - v49;
    if ( v50 + v52 >= v40 && v26 <= v38 && v27 >= v39 && v27 <= v37 )
    {
      *(_BYTE *)(v26 + v36 + v35 * v27) = (_BYTE)a6;
    }
    v28 = v52 - v50;
    v29 = v49 + v51;
    if ( v52 - v50 >= v40 && v28 <= v38 && v29 >= v39 && v29 <= v37 )
    {
      *(_BYTE *)(v28 + v36 + v35 * v29) = (_BYTE)a6;
    }
    v30 = v52 - v50;
    v31 = v51 - v49;
    if ( v52 - v50 >= v40 && v30 <= v38 && v31 >= v39 && v31 <= v37 )
    {
      *(_BYTE *)(v30 + v36 + v35 * v31) = (_BYTE)a6;
    }
    if ( v42 < 0 )
    {
      ++v50;
      v44 += v45;
      v42 += v44;
    }
    --v49;
    v43 -= v47;
    result = v43 - v48;
    v42 -= v43 - v48;
    --v15;
  }
  while ( v32 - 1 >= 0 );
  return result;
}

//----- (0005F389) --------------------------------------------------------
unsigned int __cdecl sub_5F389(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        void (__fastcall *a6)(_DWORD, _DWORD, _DWORD, _DWORD))
{
  unsigned int result; // eax
  int *v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  __int16 v15; // ax
  int v16; // ebx
  int v17; // edi
  int v18; // edi
  int v19; // edx
  char *v20; // edi
  unsigned int v21; // ecx
  int v22; // edx
  char *v23; // edi
  unsigned int v24; // ecx
  int v25; // edi
  int v26; // edi
  int v27; // edx
  char *v28; // edi
  unsigned int v29; // ecx
  int v30; // edx
  char *v31; // edi
  unsigned int v32; // ecx
  int v33; // [esp+Ch] [ebp-54h]
  int v34; // [esp+10h] [ebp-50h]
  int v35; // [esp+14h] [ebp-4Ch]
  int v36; // [esp+18h] [ebp-48h]
  int v37; // [esp+1Ch] [ebp-44h]
  int v38; // [esp+20h] [ebp-40h]
  int v39; // [esp+24h] [ebp-3Ch]
  int v40; // [esp+28h] [ebp-38h]
  int v41; // [esp+2Ch] [ebp-34h]
  int v42; // [esp+2Ch] [ebp-34h]
  int v43; // [esp+30h] [ebp-30h]
  int v44; // [esp+30h] [ebp-30h]
  signed int v45; // [esp+34h] [ebp-2Ch]
  int v46; // [esp+34h] [ebp-2Ch]
  int v47; // [esp+38h] [ebp-28h]
  int v48; // [esp+3Ch] [ebp-24h]
  int v49; // [esp+40h] [ebp-20h]
  int v50; // [esp+44h] [ebp-1Ch]
  int v51; // [esp+48h] [ebp-18h]
  int v52; // [esp+4Ch] [ebp-14h]
  int v53; // [esp+50h] [ebp-10h]
  int v54; // [esp+54h] [ebp-Ch]
  int v55; // [esp+58h] [ebp-8h]
  int v56; // [esp+5Ch] [ebp-4h]
  int v57; // [esp+7Ch] [ebp+1Ch]

  if ( !a4 || !a5 )
  {
    return sub_5C001((int **)a1, a2 - a4, a3 - a5, a4 + a2, a5 + a3, 0, a6);
  }
  v7 = *(int **)a1;
  v8 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v35 = v8 + 1;
  if ( (v8 + 1 < 0) ^ __OFADD__(1, v8) | (v8 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v9 = v7[2];
  v10 = v9 + 1;
  if ( (v9 + 1 < 0) ^ __OFADD__(1, v9) | (v9 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v11 = *(_DWORD *)(a1 + 4);
  v34 = v11;
  if ( v11 <= 0 )
  {
    v11 = 0;
  }
  v40 = v11;
  v12 = *(_DWORD *)(a1 + 8);
  v33 = v12;
  if ( v12 <= 0 )
  {
    v12 = 0;
  }
  v39 = v12;
  v13 = *(_DWORD *)(a1 + 0xC);
  if ( v13 >= v35 - 1 )
  {
    v13 = v35 - 1;
  }
  v38 = v13;
  v14 = *(_DWORD *)(a1 + 0x10);
  if ( v14 >= v10 - 1 )
  {
    v14 = v10 - 1;
  }
  v37 = v14;
  if ( v38 < v40 || v14 < v39 )
  {
    return 0xFFFFFFFE;
  }
  v36 = *v7;
  LOBYTE(v15) = (_BYTE)a6;
  HIBYTE(v15) = (_BYTE)a6;
  LOWORD(v57) = v15;
  HIWORD(v57) = v15;
  v56 = v34 + a2;
  v55 = v33 + a3;
  v54 = 0;
  v53 = a5;
  v50 = v53 * v53;
  v49 = 2 * v53 * v53;
  v52 = a4 * a4;
  v51 = 2 * a4 * a4;
  v48 = 0;
  v47 = a5 * v51;
  v45 = v53 * v53 + ((unsigned int)(a4 * a4) >> 2) - a5 * a4 * a4;
  v16 = a5;
  while ( v48 - v47 < 0 )
  {
    v17 = v54 + v56;
    if ( v54 + v56 >= v40 )
    {
      if ( v17 >= v38 )
      {
        v17 = v38;
      }
      v41 = v17;
      v18 = v56 - v54;
      if ( v56 - v54 <= v38 )
      {
        if ( v18 <= v40 )
        {
          v18 = v40;
        }
        v43 = v18;
        v19 = v53 + v55;
        if ( v53 + v55 >= v39 )
        {
          if ( v19 <= v37 )
          {
            v20 = (char *)(v18 + v36 + v35 * v19);
            v21 = (unsigned int)(v41 - v43 + 1) >> 2;
            memset32(v20, v57, v21);
            memset(&v20[4 * v21], v15, ((_BYTE)v41 - (_BYTE)v43 + 1) & 3);
          }
          v22 = v55 - v53;
          if ( v55 - v53 >= v39 && v22 <= v37 )
          {
            v23 = (char *)(v43 + v36 + v35 * v22);
            v24 = (unsigned int)(v41 - v43 + 1) >> 2;
            memset32(v23, v57, v24);
            memset(&v23[4 * v24], v15, ((_BYTE)v41 - (_BYTE)v43 + 1) & 3);
          }
        }
      }
    }
    if ( v45 >= 0 )
    {
      --v53;
      --v16;
      v47 -= v51;
      v45 -= v47;
    }
    ++v54;
    v48 += v49;
    v45 += v50 + v48;
  }
  v46 = ((v52 - v50 + ((v52 - v50) >> 1) - v48 - v47) >> 1) + v45;
  do
  {
    v25 = v54 + v56;
    if ( v54 + v56 >= v40 )
    {
      if ( v25 >= v38 )
      {
        v25 = v38;
      }
      v42 = v25;
      v26 = v56 - v54;
      if ( v56 - v54 <= v38 )
      {
        if ( v26 <= v40 )
        {
          v26 = v40;
        }
        v44 = v26;
        v27 = v53 + v55;
        if ( v53 + v55 >= v39 )
        {
          if ( v27 <= v37 )
          {
            v28 = (char *)(v26 + v36 + v35 * v27);
            v29 = (unsigned int)(v42 - v44 + 1) >> 2;
            memset32(v28, v57, v29);
            memset(&v28[4 * v29], v57, ((_BYTE)v42 - (_BYTE)v44 + 1) & 3);
          }
          v30 = v55 - v53;
          if ( v55 - v53 >= v39 && v30 <= v37 )
          {
            v31 = (char *)(v44 + v36 + v35 * v30);
            v32 = (unsigned int)(v42 - v44 + 1) >> 2;
            memset32(v31, v57, v32);
            memset(&v31[4 * v32], v57, ((_BYTE)v42 - (_BYTE)v44 + 1) & 3);
          }
        }
      }
    }
    if ( v46 < 0 )
    {
      ++v54;
      v48 += v49;
      v46 += v48;
    }
    --v53;
    v47 -= v51;
    result = v47 - v52;
    v46 -= v47 - v52;
    --v16;
  }
  while ( v16 >= 0 );
  return result;
}

//----- (0006049B) --------------------------------------------------------
int __cdecl sub_6049B(int a1, int *a2, int *a3)
{
  int i; // ebx
  unsigned int v4; // ebx
  int result; // eax
  int v6; // edx
  unsigned int v7; // ebx
  unsigned int v8; // ebx

  for ( i = a1; i < 0; i += 0xE10 )
  {
    ;
  }
  while ( i > 0xE10 )
  {
    i -= 0xE10;
  }
  if ( (unsigned int)i > 0x708 )
  {
    v7 = 0xE10 - i;
    if ( v7 > 0x384 )
    {
      v8 = 4 * (0x708 - v7);
      result = -(int)off_5F687[v8 / 4];
    }
    else
    {
      v8 = 4 * v7;
      result = (int)off_5F687[v8 / 4];
    }
    v6 = -dword_60497[v8 / 0xFFFFFFFC];
  }
  else
  {
    if ( (unsigned int)i > 0x384 )
    {
      v4 = 4 * (0x708 - i);
      result = -(int)off_5F687[v4 / 4];
    }
    else
    {
      v4 = 4 * i;
      result = (int)off_5F687[v4 / 4];
    }
    v6 = dword_60497[v4 / 0xFFFFFFFC];
  }
  *a2 = result;
  *a3 = v6;
  return result;
}
// 5F687: using guessed type void (__noreturn *off_5F687[3])();
// 60497: using guessed type int dword_60497[];

//----- (00060579) --------------------------------------------------------
int __cdecl sub_60579(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6)
{
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int result; // eax
  int v11; // [esp+14h] [ebp-18h]
  int v12; // [esp+18h] [ebp-14h]
  int v13; // [esp+20h] [ebp-Ch]
  int v14; // [esp+24h] [ebp-8h] BYREF
  int v15; // [esp+28h] [ebp-4h] BYREF

  sub_6049B(a4, &v15, &v14);
  v6 = v15 * ((unsigned __int64)(a5 * (__int64)((*a1 - *a3) << 0x10) + 0x8000) >> 0x20) + 0x8000;
  LOWORD(v6) = (unsigned __int64)(v15
                                * (__int64)(int)((unsigned __int64)(a5 * (__int64)((*a1 - *a3) << 0x10) + 0x8000) >> 0x20)
                                + 0x8000) >> 0x20;
  v13 = __ROR4__(v6, 0x10);
  v7 = v14 * ((unsigned __int64)(a5 * (__int64)((*a1 - *a3) << 0x10) + 0x8000) >> 0x20) + 0x8000;
  LOWORD(v7) = (unsigned __int64)(v14
                                * (__int64)(int)((unsigned __int64)(a5 * (__int64)((*a1 - *a3) << 0x10) + 0x8000) >> 0x20)
                                + 0x8000) >> 0x20;
  v12 = __ROR4__(v7, 0x10);
  v8 = v15 * ((unsigned __int64)(a6 * (__int64)((a1[1] - a3[1]) << 0x10) + 0x8000) >> 0x20) + 0x8000;
  LOWORD(v8) = (unsigned __int64)(v15
                                * (__int64)(int)((unsigned __int64)(a6 * (__int64)((a1[1] - a3[1]) << 0x10) + 0x8000) >> 0x20)
                                + 0x8000) >> 0x20;
  v11 = __ROR4__(v8, 0x10);
  v9 = v14 * ((unsigned __int64)(a6 * (__int64)((a1[1] - a3[1]) << 0x10) + 0x8000) >> 0x20) + 0x8000;
  LOWORD(v9) = (unsigned __int64)(v14
                                * (__int64)(int)((unsigned __int64)(a6 * (__int64)((a1[1] - a3[1]) << 0x10) + 0x8000) >> 0x20)
                                + 0x8000) >> 0x20;
  result = __ROR4__(v9, 0x10);
  *a2 = *a3 + v13 - result;
  a2[1] = a3[1] + v12 + v11;
  return result;
}

//----- (00060640) --------------------------------------------------------
int __cdecl sub_60640(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (00060653) --------------------------------------------------------
int __cdecl sub_60653(int a1, int a2)
{
  return *(_DWORD *)(a1 + *(_DWORD *)(a1 + 4 * a2 + 0x10));
}

//----- (00060673) --------------------------------------------------------
unsigned int __cdecl sub_60673(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v15; // edx
  _DWORD *v16; // esi
  int v17; // ecx
  char *v18; // esi
  int v19; // eax
  bool v20; // of
  int v21; // eax
  char v22; // cc
  int v23; // eax
  int v24; // eax
  _BYTE *v25; // edi
  char v26; // cf
  unsigned int i; // ecx
  int v31; // [esp+Ch] [ebp-30h]
  int v32; // [esp+10h] [ebp-2Ch]
  int v33; // [esp+14h] [ebp-28h]
  int v34; // [esp+1Ch] [ebp-20h]
  int v35; // [esp+20h] [ebp-1Ch]
  int v36; // [esp+24h] [ebp-18h]
  int v37; // [esp+28h] [ebp-14h]
  int v38; // [esp+30h] [ebp-Ch]
  int v39; // [esp+34h] [ebp-8h]
  int v40; // [esp+38h] [ebp-4h]
  int v41; // [esp+48h] [ebp+Ch]
  int v42; // [esp+4Ch] [ebp+10h]

  v6 = (_DWORD *)*a1;
  v7 = *(_DWORD *)(*a1 + 4);
  v33 = v7 + 1;
  if ( (v7 + 1 < 0) ^ __OFADD__(1, v7) | (v7 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v8 = v6[2];
  v9 = v8 + 1;
  if ( (v8 + 1 < 0) ^ __OFADD__(1, v8) | (v8 == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  v10 = a1[1];
  v32 = v10;
  if ( v10 <= 0 )
  {
    v10 = 0;
  }
  v37 = v10;
  v11 = a1[2];
  v31 = v11;
  if ( v11 <= 0 )
  {
    v11 = 0;
  }
  v36 = v11;
  v12 = a1[3];
  if ( v12 >= v33 - 1 )
  {
    v12 = v33 - 1;
  }
  v35 = v12;
  v13 = a1[4];
  if ( v13 >= v9 - 1 )
  {
    v13 = v9 - 1;
  }
  v34 = v13;
  if ( v35 < v37 || v13 < v36 )
  {
    return 0xFFFFFFFE;
  }
  v41 = v32 + a2;
  v42 = v31 + a3;
  v15 = *(_DWORD *)(a4 + 8);
  v16 = (_DWORD *)(a4 + *(_DWORD *)(a4 + 4 * a5 + 0x10));
  v39 = 0;
  v17 = *v16;
  v40 = *v16;
  if ( !*v16 )
  {
    return v39 + v40;
  }
  v18 = (char *)(v16 + 1);
  v19 = v35 + 1 - v17 - v41;
  if ( v19 < 0 )
  {
    v20 = __OFADD__(v19, v17);
    v17 = v35 + 1 - v41;
    if ( (v17 < 0) ^ v20 | (v35 + 1 == v41) )
    {
      return v39 + v40;
    }
  }
  v21 = v41 - v37;
  if ( v41 - v37 < 0 )
  {
    v22 = (v21 + v17 < 0) ^ __OFADD__(v21, v17) | (v21 + v17 == 0);
    v17 += v21;
    if ( v22 )
    {
      return v39 + v40;
    }
    v18 -= v21;
    v41 = v37;
  }
  v23 = v34 + 1 - v15 - v42;
  if ( v23 < 0 )
  {
    v20 = __OFADD__(v23, v15);
    v15 = v34 + 1 - v42;
    if ( (v15 < 0) ^ v20 | (v34 + 1 == v42) )
    {
      return v39 + v40;
    }
  }
  v24 = v42 - v36;
  if ( v42 - v36 >= 0 )
  {
    goto LABEL_27;
  }
  v22 = (v24 + v15 < 0) ^ __OFADD__(v24, v15) | (v24 + v15 == 0);
  v15 += v24;
  if ( v22 )
  {
    return v39 + v40;
  }
  v42 = v36;
  v18 -= v40 * v24;
LABEL_27:
  v25 = (_BYTE *)(v41 + *v6 + v33 * v42);
  v39 = v17;
  v40 -= v17;
  v38 = v33 - v17;
  if ( a6 )
  {
    if ( v17 )
    {
      _EBX = a6;
      while ( 1 )
      {
        _AL = *v18;
        __asm { xlat }
        if ( _AL != (char)0xFF )
        {
          *v25 = _AL;
        }
        ++v18;
        ++v25;
        if ( !--v17 )
        {
          v17 = v39;
          v18 += v40;
          v25 += v38;
          if ( !--v15 )
          {
            break;
          }
        }
      }
    }
    return v39 + v40;
  }
  do
  {
    v26 = v17 & 1;
    for ( i = (unsigned int)v17 >> 1; i; --i )
    {
      *(_WORD *)v25 = *(_WORD *)v18;
      v18 += 2;
      v25 += 2;
    }
    qmemcpy(v25, v18, v26);
    v17 = v39;
    v18 += v40 + v26;
    v25 += v38 + v26;
    --v15;
  }
  while ( v15 );
  return v39 + v40;
}

//----- (00060806) --------------------------------------------------------
unsigned int __cdecl sub_60806(_DWORD *a1, int a2, int a3, int a4, _BYTE *a5, int a6)
{
  unsigned int result; // eax

  do
  {
    result = sub_60673(a1, a2, a3, a4, (unsigned __int8)*a5, a6);
    a2 += result;
    ++a5;
  }
  while ( *a5 );
  return result;
}

//----- (0006083D) --------------------------------------------------------
int __cdecl sub_6083D(PANE *a1, int a2, char *a3, int a4)
{
  WINDOW *window; // ebx
  LONG x_max; // eax
  LONG y_max; // eax
  int v7; // ecx
  LONG x0; // eax
  LONG y0; // eax
  LONG x1; // eax
  LONG y1; // eax
  int result; // eax
  char *v13; // esi
  int v14; // ecx
  char v15; // cc
  unsigned int v16; // edx
  int v17; // ecx
  LONG v18; // [esp+Ch] [ebp-24h]
  LONG v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  LONG v21; // [esp+1Ch] [ebp-14h]
  LONG v22; // [esp+20h] [ebp-10h]
  LONG v23; // [esp+24h] [ebp-Ch]
  LONG v24; // [esp+28h] [ebp-8h]
  LONG v25; // [esp+2Ch] [ebp-4h]
  int v26; // [esp+3Ch] [ebp+Ch]

  window = a1->window;
  x_max = a1->window->x_max;
  v20 = x_max + 1;
  if ( (x_max + 1 < 0) ^ __OFADD__(1, x_max) | (x_max == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  y_max = window->y_max;
  v7 = y_max + 1;
  if ( (y_max + 1 < 0) ^ __OFADD__(1, y_max) | (y_max == 0xFFFFFFFF) )
  {
    return 0xFFFFFFFF;
  }
  x0 = a1->x0;
  v19 = x0;
  if ( x0 <= 0 )
  {
    x0 = 0;
  }
  v24 = x0;
  y0 = a1->y0;
  v18 = y0;
  if ( y0 <= 0 )
  {
    y0 = 0;
  }
  v23 = y0;
  x1 = a1->x1;
  if ( x1 >= v20 - 1 )
  {
    x1 = v20 - 1;
  }
  v22 = x1;
  y1 = a1->y1;
  if ( y1 >= v7 - 1 )
  {
    y1 = v7 - 1;
  }
  v21 = y1;
  if ( v22 < v24 || y1 < v23 )
  {
    return 0xFFFFFFFE;
  }
  v25 = v19;
  v26 = v18 + a2;
  v13 = a3;
  v14 = a4;
  result = v22 - v19 + 1 - a4;
  if ( result >= 0 || (v14 = v22 - v19 + 1, !((v14 < 0) ^ __OFADD__(v14 - a4, a4) | (v14 == 0))) )
  {
    result = v19 - v24;
    if ( v19 - v24 < 0 )
    {
      v15 = (result + v14 < 0) ^ __OFADD__(result, v14) | (result + v14 == 0);
      v14 += result;
      if ( v15 )
      {
        return result;
      }
      v13 = &a3[-result];
      v25 = v24;
    }
    result = v21 - v26;
    if ( v21 - v26 >= 0 )
    {
      result = v26 - v23;
      if ( v26 - v23 >= 0 )
      {
        result = (int)&window->buffer[v20 * v26 + v25];
        v16 = v14;
        v17 = v14 & 3;
        qmemcpy((void *)result, v13, v17);
        qmemcpy((void *)(result + v17), &v13[v17], 4 * (v16 >> 2));
      }
    }
  }
  return result;
}

//----- (00060940) --------------------------------------------------------
int __cdecl sub_60940(int a1, int a2)
{
  return sub_6094C(a1, a2);
}
// 6094C: using guessed type _DWORD __cdecl sub_6094C(_DWORD, _DWORD);

//----- (0006094C) --------------------------------------------------------
_BYTE *__cdecl sub_6094C(_WORD *a1, int a2)
{
  _BYTE *i; // esi
  bool v3; // zf
  int v4; // ecx
  _WORD *v5; // edi
  _BYTE *v6; // eax
  _BYTE *v7; // esi
  unsigned __int16 v8; // ax
  char v9; // t0

  for ( i = (_BYTE *)(a2 + 0xC); ; i = &v7[v8 + 2] )
  {
    while ( 1 )
    {
      v3 = *i == 0;
      if ( *i )
      {
        break;
      }
      ++i;
    }
    v4 = 2;
    v5 = a1;
    v6 = i;
    do
    {
      if ( !v4 )
      {
        break;
      }
      v3 = *(_WORD *)i == *v5;
      i += 2;
      ++v5;
      --v4;
    }
    while ( v3 );
    if ( v3 )
    {
      break;
    }
    v7 = v6 + 6;
    v8 = *((_WORD *)v6 + 3);
    v9 = v8;
    LOBYTE(v8) = HIBYTE(v8);
    HIBYTE(v8) = v9;
  }
  return v6 + 8;
}

//----- (00060C87) --------------------------------------------------------
int __usercall sub_60C87@<eax>(int a1@<ecx>, _DWORD *a2@<edi>)
{
  int v2; // ebx
  int result; // eax

  v2 = 0;
  *a2 = a1 + 2;
  result = 2 * a1;
  a2[1] = 2 * a1;
  while ( v2 < a1 )
  {
    *((_BYTE *)a2 + v2 + 0x102E) = v2;
    *((_BYTE *)a2 + v2 + 0x202E) = v2;
    *((_WORD *)a2 + v2++ + 0x1817) = 0xFFFF;
  }
  while ( v2 < 0x1000 )
  {
    *((_WORD *)a2 + v2++ + 0x1817) = 0xFFFE;
  }
  return result;
}

//----- (00060CCF) --------------------------------------------------------
int __usercall sub_60CCF@<eax>(int a1@<edi>, unsigned __int8 *a2@<esi>)
{
  unsigned __int8 v2; // al
  int result; // eax

  if ( !*(_DWORD *)(a1 + 0x10) )
  {
    v2 = *a2++;
    *(_DWORD *)(a1 + 0x10) = v2;
  }
  result = *a2;
  --*(_DWORD *)(a1 + 0x10);
  return result;
}

//----- (00060CE8) --------------------------------------------------------
int __usercall sub_60CE8@<eax>(int a1@<edx>, int a2@<edi>, unsigned __int8 *a3@<esi>)
{
  int v3; // ebx

  if ( !*(_DWORD *)(a2 + 0x18) )
  {
    *(_DWORD *)(a2 + 0x14) = sub_60CCF(a2, a3);
    *(_DWORD *)(a2 + 0x18) = 8;
  }
  if ( *(_DWORD *)(a2 + 0x18) < a1 )
  {
    *(_DWORD *)(a2 + 0x14) |= sub_60CCF(a2, a3) << *(_DWORD *)(a2 + 0x18);
    *(_DWORD *)(a2 + 0x18) += 8;
  }
  v3 = (unsigned __int8)byte_9844D[a1] & *(_DWORD *)(a2 + 0x14);
  *(_DWORD *)(a2 + 0x18) -= a1;
  *(_DWORD *)(a2 + 0x14) >>= a1;
  return v3;
}

//----- (00060D2E) --------------------------------------------------------
int __usercall sub_60D2E@<eax>(int a1@<ecx>, _DWORD *a2@<edi>)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]

  *((_WORD *)a2 + *a2 + 0x1817) = a1;
  *((_BYTE *)a2 + *a2 + 0x202E) = *((_BYTE *)a2 + v3 + 0x102E);
  *((_BYTE *)a2 + *a2 + 0x102E) = *((_BYTE *)a2 + a1 + 0x102E);
  result = ++*a2;
  if ( *a2 == a2[1] && (int)a2[7] < 0xC )
  {
    ++a2[7];
    a2[1] *= 2;
  }
  return result;
}
// 60D3B: variable 'v3' is possibly undefined

//----- (00060D74) --------------------------------------------------------
int __usercall sub_60D74@<eax>(int result@<eax>, int a2@<edi>)
{
  byte_9714D[(*(_DWORD *)(a2 + 8))++] = result;
  if ( !--*(_DWORD *)(a2 + 0x20) )
  {
    sub_6083D(dword_98460, *(_DWORD *)(a2 + 0xC), byte_9714D, *(_DWORD *)(a2 + 0x24));
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 0x20) = *(_DWORD *)(a2 + 0x24);
    if ( *(_BYTE *)(a2 + 0x2C) )
    {
      *(_DWORD *)(a2 + 0xC) += (unsigned __int8)byte_98456[*(unsigned __int8 *)(a2 + 0x2D)];
      result = *(_DWORD *)(a2 + 0xC);
      if ( result >= *(_DWORD *)(a2 + 0x28) )
      {
        result = (unsigned __int8)byte_9845B[(unsigned __int8)++*(_BYTE *)(a2 + 0x2D)];
        *(_DWORD *)(a2 + 0xC) = result;
      }
    }
    else
    {
      result = ++*(_DWORD *)(a2 + 0xC);
      if ( result >= *(_DWORD *)(a2 + 0x28) )
      {
        *(_DWORD *)(a2 + 0xC) = 0;
      }
    }
  }
  return result;
}

//----- (00060DF1) --------------------------------------------------------
int __cdecl sub_60DF1(PANE *a1, int a2, int a3)
{
  int v3; // esi
  char v4; // al
  unsigned __int8 *v5; // esi
  unsigned __int8 v6; // al
  unsigned __int8 *v7; // esi
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // ebx
  unsigned __int8 v13; // al
  int v14; // ebx
  int v15; // ecx
  unsigned __int8 *v16; // esi
  int v18; // [esp-14h] [ebp-38h]
  int v19; // [esp-14h] [ebp-38h]
  unsigned __int8 *v20; // [esp-10h] [ebp-34h]
  int v21; // [esp-Ch] [ebp-30h]
  int v22; // [esp-8h] [ebp-2Ch]
  int v23; // [esp-8h] [ebp-2Ch]
  int v24; // [esp+Ch] [ebp-18h]
  int v25; // [esp+10h] [ebp-14h]
  int v26; // [esp+14h] [ebp-10h]
  int v27; // [esp+18h] [ebp-Ch]
  int v28; // [esp+1Ch] [ebp-8h]
  int v29; // [esp+20h] [ebp-4h]

  dword_98460 = a1;
  memset((void *)a3, 0, 2u);
  memset((void *)(a3 + 2), 0, 0x2Cu);
  v24 = *(unsigned __int8 *)(a2 + 0xB);
  v3 = a2 + 0xD;
  if ( *(char *)(a2 + 0xA) < 0 )
  {
    v3 += 3 * (1 << ((*(_BYTE *)(a2 + 0xA) & 7) + 1));
  }
  *(_DWORD *)(a3 + 0x24) = *(unsigned __int16 *)(v3 + 5);
  *(_DWORD *)(a3 + 0x28) = *(unsigned __int16 *)(v3 + 7);
  v4 = *(_BYTE *)(v3 + 9);
  *(_BYTE *)(a3 + 0x2C) = v4;
  *(_BYTE *)(a3 + 0x2C) &= 0x40u;
  v5 = (unsigned __int8 *)(v3 + 0xA);
  if ( v4 < 0 )
  {
    v5 += 3 * (1 << ((v4 & 7) + 1));
  }
  *(_DWORD *)(a3 + 0x10) = 0;
  v6 = *v5;
  v7 = v5 + 1;
  v22 = v6;
  v29 = 1 << v6;
  v28 = (1 << v6) + 1;
  *(_DWORD *)(a3 + 0x1C) = v6 + 1;
  sub_60C87(1 << v6, (_DWORD *)a3);
  v26 = 0xFFFF;
  v25 = 0;
  *(_BYTE *)(a3 + 0x2D) = 0;
  *(_DWORD *)(a3 + 0x20) = *(_DWORD *)(a3 + 0x24);
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 0xC) = 0;
  v8 = 8;
  v9 = v22;
  do
  {
    v21 = v8;
    v10 = *(_DWORD *)(a3 + 0x1C);
    if ( v10 > 8 )
    {
      v18 = *(_DWORD *)(a3 + 0x1C);
      v12 = sub_60CE8(8, a3, v7);
      v11 = v12 | (sub_60CE8(v18 - 8, a3, v7) << 8);
    }
    else
    {
      v11 = sub_60CE8(v10, a3, v7);
    }
    v27 = v11;
    v8 = v21;
    if ( v11 == v29 )
    {
      sub_60C87(v29, (_DWORD *)a3);
      v8 = v21;
      *(_DWORD *)(a3 + 0x1C) = v9 + 1;
      v26 = 0xFFFF;
    }
    else if ( v11 == v28 )
    {
      do
      {
        while ( *(_DWORD *)(a3 + 0x10) )
        {
          ++v7;
          --*(_DWORD *)(a3 + 0x10);
        }
        v13 = *v7++;
        *(_DWORD *)(a3 + 0x10) = v13;
      }
      while ( *(_DWORD *)(a3 + 0x10) );
      v25 = 0xFFFF;
    }
    else
    {
      if ( *(_WORD *)(a3 + 2 * v11 + 0x302E) == 0xFFFE )
      {
        sub_60D2E(v26, (_DWORD *)a3);
        v8 = v21;
      }
      else if ( v26 != 0xFFFF )
      {
        sub_60D2E(v26, (_DWORD *)a3);
        v8 = v21;
      }
      v23 = v9;
      v14 = v27;
      v20 = v7;
      v15 = 0;
      v16 = (unsigned __int8 *)(a3 + 0x2E);
      do
      {
        *v16++ = *(_BYTE *)(v14 + a3 + 0x202E);
        ++v15;
        v14 = *(unsigned __int16 *)(a3 + 2 * v14 + 0x302E);
      }
      while ( v14 != 0xFFFF );
      do
      {
        --v16;
        v19 = v15;
        sub_60D74(*v16, a3);
        --v15;
      }
      while ( v19 != 1 );
      v7 = v20;
      v9 = v23;
      v26 = v27;
    }
  }
  while ( !v25 );
  return v24;
}
// 60FB9: conditional instruction was optimized away because edx.4==8

//----- (000610E8) --------------------------------------------------------
__int16 __cdecl sub_610E8(int a1, int a2)
{
  int v2; // esi

  v2 = a1 + *(_DWORD *)(8 * a2 + a1 + 8);
  return *(_WORD *)(v2 + 0x14) - *(_WORD *)(v2 + 0xC) + 1;
}

//----- (0006111C) --------------------------------------------------------
__int16 __cdecl sub_6111C(int a1, int a2)
{
  return *(_WORD *)(a1 + *(_DWORD *)(8 * a2 + a1 + 8) + 0xC);
}

//----- (00061223) --------------------------------------------------------
int __cdecl sub_61223(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (000615ED) --------------------------------------------------------
void __cdecl sub_615ED(P_Type6 a1, int a2, unsigned int a3)
{
  int v3; // ecx
  unsigned __int8 *v4; // esi
  char *v5; // edi
  LONG color; // eax
  int v7; // ecx
  int v8; // ebx
  int i; // edx
  char v10; // ah
  char v11; // al
  bool v12; // cc
  char v13; // al
  char *v14; // edi
  __int16 v15; // ax
  unsigned int j; // ecx
  int v17; // esi
  int v18; // ecx
  int v19; // ebx
  int k; // edx
  char v21; // al
  int v22; // [esp+Ch] [ebp-10h]
  char v23; // [esp+14h] [ebp-8h]
  unsigned int v24; // [esp+18h] [ebp-4h]

  memset(byte_97E4D, 0, 0x100u);
  v3 = (*(_DWORD *)&a1->z1[4] + 1) * (*(_DWORD *)&a1->z1[8] + 1);
  v4 = *(unsigned __int8 **)a1->z1;
  v5 = byte_9744D;
  v24 = 0xFFFFFFFF;
  do
  {
    color = *v4++;
    if ( !byte_97E4D[color] )
    {
      byte_97E4D[color] |= 1u;
      *v5++ = color;
      ++v24;
      VFX_DAC_read(color, (RGB *)&byte_9714D[3 * color]);
    }
    --v3;
  }
  while ( v3 );
  v23 = 0;
  v7 = v24;
  do
  {
    v8 = 3 * (unsigned __int8)byte_9744D[v7];
    for ( i = 2; i >= 0; --i )
    {
      v10 = 0xFF;
      v11 = byte_9714D[v8];
      v12 = v11 < *(_BYTE *)(v8 + a2);
      v13 = v11 - *(_BYTE *)(v8 + a2);
      if ( v12 )
      {
        v10 = 1;
        v13 = -v13;
      }
      byte_97E4D[v8] = v10;
      byte_9754D[v8] = v13;
      if ( v13 > v23 )
      {
        v23 = v13;
      }
      ++v8;
    }
    --v7;
  }
  while ( v7 >= 0 );
  v14 = byte_9814D;
  LOBYTE(v15) = (unsigned __int8)v23 >> 1;
  for ( j = v24 >> 1; j; --j )
  {
    HIBYTE(v15) = (unsigned __int8)v23 >> 1;
    *(_WORD *)v14 = v15;
    v14 += 2;
  }
  memset(v14, v15, v24 & 1);
  v17 = (unsigned __int8)v23;
  if ( v23 )
  {
    v22 = 0x8000;
    do
    {
      v18 = v24;
      do
      {
        v19 = 3 * (unsigned __int8)byte_9744D[v18];
        for ( k = 2; k >= 0; --k )
        {
          v21 = byte_9754D[k + v19] + byte_9814D[k + v19];
          if ( v21 >= v23 )
          {
            v21 -= v23;
            byte_9714D[k + v19] += byte_97E4D[k + v19];
          }
          byte_9814D[k + v19] = v21;
        }
        VFX_DAC_write((unsigned __int8)byte_9744D[v18--], (RGB *)&byte_9714D[v19]);
      }
      while ( v18 >= 0 );
      v22 += ((unsigned __int64)a3 << 0x10) / (unsigned __int8)v23;
      if ( SHIWORD(v22) >= 1 )
      {
        do
        {
          VFX_wait_vblank_leading();
          --HIWORD(v22);
        }
        while ( HIWORD(v22) );
      }
      --v17;
    }
    while ( v17 );
  }
}

//----- (00061800) --------------------------------------------------------
int __cdecl sub_61800(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // ebx
  int v4; // ecx
  int result; // eax
  int v6; // edi
  bool v7; // cc
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  _DWORD *v11; // ebx
  unsigned int v12; // eax
  int v13; // esi
  signed int v14; // edi
  int v15; // ecx
  unsigned __int64 v16; // rt0
  int v17; // edx
  _DWORD *v18; // ebx
  _DWORD *v19; // esi
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  __int64 v23; // rt0
  _DWORD *v24; // ebx
  _DWORD *v25; // esi
  int v26; // ecx
  int v27; // edx
  int v28; // ecx
  __int64 v29; // rt0
  int v30; // eax
  int v31; // edi
  int v32; // ecx
  int v33; // ecx
  int v34; // edi
  int v35; // eax
  int v36; // ebx
  int v37; // edx
  int v38; // et0
  int v39; // eax
  int v40; // ecx
  char *v41; // edi
  int v42; // eax
  unsigned int v43; // edx
  int v44; // ecx
  bool v45; // zf
  int v46; // edx
  int v47; // et1
  int v48; // eax
  int v49; // edx
  int v50; // ecx
  char *v51; // edi
  int v52; // edx
  int v53; // eax
  unsigned int v54; // edx
  int v55; // ecx
  bool v56; // zf
  _DWORD *v57; // ebx
  _DWORD *v58; // esi
  __int64 v59; // rt0
  _DWORD *v60; // ebx
  _DWORD *v61; // esi
  __int64 v62; // rt0
  int v63; // [esp-Ch] [ebp-18h]
  int v64; // [esp-Ch] [ebp-18h]
  int v65; // [esp-8h] [ebp-14h]
  int v66; // [esp-8h] [ebp-14h]
  int v67; // [esp-8h] [ebp-14h]

  v3 = (_DWORD *)*a1;
  dword_985D0 = *(_DWORD *)(*a1 + 4) + 1;
  v4 = v3[1];
  if ( v4 >= a1[3] )
  {
    v4 = a1[3];
  }
  result = a1[1];
  v6 = 0;
  if ( result >= 0 )
  {
    v6 = a1[1];
  }
  v7 = v4 < v6;
  v8 = v4 - v6;
  if ( !v7 )
  {
    dword_985C4 = v8;
    v9 = v3[2];
    if ( v9 >= a1[4] )
    {
      v9 = a1[4];
    }
    result = 0;
    if ( (int)a1[2] >= 0 )
    {
      result = a1[2];
    }
    v7 = v9 < result;
    v10 = v9 - result;
    if ( !v7 )
    {
      dword_985C8 = v10;
      dword_985CC = *v3 + v6 + dword_985D0 * result;
      v11 = (_DWORD *)a3;
      dword_985E8 = a3;
      dword_985EC = a3 + 0x18 * a2;
      v12 = (unsigned int)(*(_DWORD *)(a3 + 8) + 0x8000) >> 0x10;
      BYTE1(v12) = (unsigned int)(*(_DWORD *)(a3 + 8) + 0x8000) >> 0x10;
      dword_9866C = v12 | (v12 << 0x10);
      dword_985E4 = 0;
      v13 = 0x7FFF;
      v14 = 0xFFFF8000;
      v15 = 0xF;
      do
      {
        HIDWORD(v16) = *v11 >> 0x1F;
        LODWORD(v16) = dword_985C4 - *v11;
        dword_985E4 |= v16 >> 0x1F;
        HIDWORD(v16) = v16 >> 0x1F;
        LODWORD(v16) = v11[1];
        HIDWORD(v16) = v16 >> 0x1F;
        LODWORD(v16) = dword_985C8 - v16;
        v17 = v16 >> 0x1F;
        result = v11[1];
        if ( result <= v13 )
        {
          v13 = v11[1];
          dword_985F0 = (int)v11;
        }
        if ( result >= v14 )
        {
          v14 = result;
        }
        v15 &= v17;
        v11 += 6;
      }
      while ( v11 != (_DWORD *)dword_985EC );
      if ( !v15 )
      {
        result = dword_985F0;
        dword_985FC = dword_985F0;
        dword_98600 = dword_985F0;
        dword_98610 = v13;
        if ( v14 != v13 )
        {
          while ( 1 )
          {
            v18 = (_DWORD *)dword_985FC;
            dword_985F4 = dword_985FC;
            v19 = (_DWORD *)(dword_985FC - 0x18);
            if ( dword_985FC - 0x18 < dword_985E8 )
            {
              v19 = (_DWORD *)(dword_985EC - 0x18);
            }
            dword_985FC = (int)v19;
            v20 = v19[1];
            v21 = v18[1];
            if ( v21 >= 0 || v20 > 0 )
            {
              v22 = v20 - v21;
              if ( v22 )
              {
                break;
              }
            }
          }
          dword_98604 = v22;
          LODWORD(v23) = 0;
          HIDWORD(v23) = (*v19 - *v18) << 0x10;
          dword_98634 = (v23 >> 0x10) / (v22 << 0x10);
          dword_98614 = (*v18 << 0x10) + 0x8000;
          while ( 1 )
          {
            v24 = (_DWORD *)dword_98600;
            dword_985F8 = dword_98600;
            v25 = (_DWORD *)(dword_98600 + 0x18);
            if ( dword_98600 + 0x18 >= dword_985EC )
            {
              v25 = (_DWORD *)dword_985E8;
            }
            dword_98600 = (int)v25;
            v26 = v25[1];
            v27 = v24[1];
            if ( v27 >= 0 || v26 > 0 )
            {
              v28 = v26 - v27;
              if ( v28 )
              {
                break;
              }
            }
          }
          dword_98608 = v28;
          LODWORD(v29) = 0;
          HIDWORD(v29) = (*v25 - *v24) << 0x10;
          dword_98638 = (v29 >> 0x10) / (v28 << 0x10);
          dword_98618 = (*v24 << 0x10) + 0x8000;
          v30 = dword_985C8 - dword_98610;
          v7 = v14 <= dword_985C8;
          v31 = v14 - dword_985C8;
          if ( v7 )
          {
            v30 += v31;
          }
          dword_9860C = v30;
          if ( dword_98610 < 0 )
          {
            dword_9860C += dword_98610;
            dword_98610 = 0;
            v32 = -*(_DWORD *)(dword_985F4 + 4);
            dword_98604 += *(_DWORD *)(dword_985F4 + 4);
            dword_98614 += (unsigned __int64)((v32 << 0x10) * (__int64)dword_98634) >> 0x10;
            v33 = -*(_DWORD *)(dword_985F8 + 4);
            dword_98608 += *(_DWORD *)(dword_985F8 + 4);
            dword_98618 += (unsigned __int64)((v33 << 0x10) * (__int64)dword_98638) >> 0x10;
          }
          v34 = dword_985D0 * dword_98610 + dword_985CC;
          v35 = dword_98614;
          v36 = dword_98618;
          if ( !dword_985E4 )
          {
            goto LABEL_35;
          }
          while ( 1 )
          {
            while ( 1 )
            {
LABEL_45:
              v66 = v35;
              v64 = v34;
              v46 = v36;
              if ( v36 <= v35 )
              {
                v47 = v35;
                v35 = v36;
                v46 = v47;
              }
              v48 = v35 >> 0x10;
              v49 = v46 >> 0x10;
              if ( v48 <= dword_985C4 && v49 >= 0 )
              {
                v50 = v49 - v48 + 1;
                v51 = (char *)(v48 + v34);
                if ( v48 < 0 )
                {
                  v51 -= v48;
                  v50 = v49 + 1;
                }
                v7 = v49 <= dword_985C4;
                v52 = v49 - dword_985C4;
                if ( !v7 )
                {
                  v50 -= v52;
                }
                v53 = dword_9866C;
                v54 = v50;
                v55 = v50 & 3;
                memset(v51, dword_9866C, v55);
                memset32(&v51[v55], v53, v54 >> 2);
              }
              result = v66;
              v34 = dword_985D0 + v64;
              v56 = dword_9860C-- == 1;
              if ( dword_9860C < 0 )
              {
                return result;
              }
              if ( !v56 )
              {
                break;
              }
              v35 = dword_98634 + v66;
              v36 += dword_98638;
            }
            if ( --dword_98604 )
            {
              v35 = dword_98634 + v66;
              goto LABEL_58;
            }
LABEL_61:
            v67 = v36;
            v57 = (_DWORD *)dword_985FC;
            dword_985F4 = dword_985FC;
            v58 = (_DWORD *)(dword_985FC - 0x18);
            if ( dword_985FC - 0x18 < dword_985E8 )
            {
              v58 = (_DWORD *)(dword_985EC - 0x18);
            }
            dword_985FC = (int)v58;
            dword_98604 = (v58[1] == v57[1]) + v58[1] - v57[1];
            LODWORD(v59) = 0;
            HIDWORD(v59) = (*v58 - *v57) << 0x10;
            dword_98634 = (v59 >> 0x10) / (dword_98604 << 0x10);
            v35 = (*v57 << 0x10) + 0x8000;
            v36 = v67;
            if ( !dword_985E4 )
            {
              break;
            }
LABEL_58:
            if ( !--dword_98608 )
            {
              goto LABEL_65;
            }
            v36 += dword_98638;
          }
          while ( --dword_98608 )
          {
            for ( v36 += dword_98638; ; v36 += dword_98638 )
            {
LABEL_35:
              v65 = v35;
              v63 = v34;
              v37 = v36;
              if ( v36 <= v35 )
              {
                v38 = v35;
                v35 = v36;
                v37 = v38;
              }
              v39 = v35 >> 0x10;
              v40 = (v37 >> 0x10) - v39 + 1;
              v41 = (char *)(v39 + v34);
              v42 = dword_9866C;
              v43 = v40;
              v44 = v40 & 3;
              memset(v41, dword_9866C, v44);
              memset32(&v41[v44], v42, v43 >> 2);
              result = v65;
              v34 = dword_985D0 + v63;
              v45 = dword_9860C-- == 1;
              if ( dword_9860C < 0 )
              {
                return result;
              }
              if ( !v45 )
              {
                break;
              }
              v35 = dword_98634 + v65;
            }
            if ( !--dword_98604 )
            {
              goto LABEL_61;
            }
            v35 = dword_98634 + v65;
          }
LABEL_65:
          v60 = (_DWORD *)dword_98600;
          dword_985F8 = dword_98600;
          v61 = (_DWORD *)(dword_98600 + 0x18);
          if ( dword_98600 + 0x18 >= dword_985EC )
          {
            v61 = (_DWORD *)dword_985E8;
          }
          dword_98600 = (int)v61;
          dword_98608 = (v61[1] == v60[1]) + v61[1] - v60[1];
          LODWORD(v62) = 0;
          HIDWORD(v62) = (*v61 - *v60) << 0x10;
          dword_98638 = (v62 >> 0x10) / (dword_98608 << 0x10);
          v36 = (*v60 << 0x10) + 0x8000;
          if ( dword_985E4 )
          {
            goto LABEL_45;
          }
          goto LABEL_35;
        }
      }
    }
  }
  return result;
}
// 985C4: using guessed type int dword_985C4;
// 985C8: using guessed type int dword_985C8;
// 985CC: using guessed type int dword_985CC;
// 985D0: using guessed type int dword_985D0;
// 985E4: using guessed type int dword_985E4;
// 985E8: using guessed type int dword_985E8;
// 985EC: using guessed type int dword_985EC;
// 985F0: using guessed type int dword_985F0;
// 985F4: using guessed type int dword_985F4;
// 985F8: using guessed type int dword_985F8;
// 985FC: using guessed type int dword_985FC;
// 98600: using guessed type int dword_98600;
// 98604: using guessed type int dword_98604;
// 98608: using guessed type int dword_98608;
// 9860C: using guessed type int dword_9860C;
// 98610: using guessed type int dword_98610;
// 98614: using guessed type int dword_98614;
// 98618: using guessed type int dword_98618;
// 98634: using guessed type int dword_98634;
// 98638: using guessed type int dword_98638;
// 9866C: using guessed type int dword_9866C;

//----- (00062DA5) --------------------------------------------------------
int __cdecl sub_62DA5(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  int v5; // ecx
  int result; // eax
  int v7; // edi
  bool v8; // cc
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  _DWORD *v12; // ebx
  int v13; // esi
  signed int v14; // edi
  int v15; // ecx
  unsigned __int64 v16; // rt0
  int v17; // edx
  _DWORD *v18; // ebx
  _DWORD *v19; // esi
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  __int64 v23; // rt0
  _DWORD *v24; // ebx
  _DWORD *v25; // esi
  int v26; // ecx
  int v27; // edx
  int v28; // ecx
  __int64 v29; // rt0
  int v30; // eax
  int v31; // edi
  int v32; // ecx
  int v33; // ecx
  int v34; // eax
  int v35; // ebx
  int v36; // et0
  int v37; // eax
  int v38; // ebx
  int v39; // edi
  int v40; // eax
  unsigned int v41; // ebx
  int v42; // ebx
  __int16 v43; // dx
  __int16 v44; // dx
  int v45; // ebx
  __int16 v46; // dx
  int v47; // ebx
  __int16 v48; // dx
  int v49; // ebx
  __int16 v50; // dx
  __int16 v51; // dx
  int v52; // ebx
  bool v53; // zf
  _DWORD *v54; // ebx
  _DWORD *v55; // esi
  __int64 v56; // rt0
  _DWORD *v57; // ebx
  _DWORD *v58; // edi
  __int64 v59; // rt0
  char v60; // [esp-10h] [ebp-1Ch]
  int v61; // [esp-Ch] [ebp-18h]
  int v62; // [esp-8h] [ebp-14h]

  v4 = (_DWORD *)*a1;
  dword_985D0 = *(_DWORD *)(*a1 + 4) + 1;
  v5 = v4[1];
  if ( v5 >= a1[3] )
  {
    v5 = a1[3];
  }
  result = a1[1];
  v7 = 0;
  if ( result >= 0 )
  {
    v7 = a1[1];
  }
  v8 = v5 < v7;
  v9 = v5 - v7;
  if ( !v8 )
  {
    dword_985C4 = v9;
    v10 = v4[2];
    if ( v10 >= a1[4] )
    {
      v10 = a1[4];
    }
    result = 0;
    if ( (int)a1[2] >= 0 )
    {
      result = a1[2];
    }
    v8 = v10 < result;
    v11 = v10 - result;
    if ( !v8 )
    {
      dword_985C8 = v11;
      dword_985CC = *v4 + v7 + dword_985D0 * result;
      v12 = (_DWORD *)a3;
      dword_985E8 = a3;
      dword_985EC = a3 + 0x18 * a2;
      v13 = 0x7FFF;
      v14 = 0xFFFF8000;
      v15 = 0xF;
      do
      {
        HIDWORD(v16) = *v12 >> 0x1F;
        LODWORD(v16) = dword_985C4 - *v12;
        HIDWORD(v16) = v16 >> 0x1F;
        LODWORD(v16) = v12[1];
        HIDWORD(v16) = v16 >> 0x1F;
        LODWORD(v16) = dword_985C8 - v16;
        v17 = v16 >> 0x1F;
        result = v12[1];
        if ( result <= v13 )
        {
          v13 = v12[1];
          dword_985F0 = (int)v12;
        }
        if ( result >= v14 )
        {
          v14 = result;
        }
        v15 &= v17;
        v12 += 6;
      }
      while ( v12 != (_DWORD *)dword_985EC );
      if ( !v15 )
      {
        result = dword_985F0;
        dword_985FC = dword_985F0;
        dword_98600 = dword_985F0;
        dword_98610 = v13;
        if ( v14 != v13 )
        {
          while ( 1 )
          {
            v18 = (_DWORD *)dword_985FC;
            dword_985F4 = dword_985FC;
            v19 = (_DWORD *)(dword_985FC - 0x18);
            if ( dword_985FC - 0x18 < dword_985E8 )
            {
              v19 = (_DWORD *)(dword_985EC - 0x18);
            }
            dword_985FC = (int)v19;
            v20 = v19[1];
            v21 = v18[1];
            if ( v21 >= 0 || v20 > 0 )
            {
              v22 = v20 - v21;
              if ( v22 )
              {
                break;
              }
            }
          }
          dword_98604 = v22;
          LODWORD(v23) = 0;
          HIDWORD(v23) = (*v19 - *v18) << 0x10;
          dword_98634 = (v23 >> 0x10) / (v22 << 0x10);
          dword_98614 = (*v18 << 0x10) + 0x8000;
          while ( 1 )
          {
            v24 = (_DWORD *)dword_98600;
            dword_985F8 = dword_98600;
            v25 = (_DWORD *)(dword_98600 + 0x18);
            if ( dword_98600 + 0x18 >= dword_985EC )
            {
              v25 = (_DWORD *)dword_985E8;
            }
            dword_98600 = (int)v25;
            v26 = v25[1];
            v27 = v24[1];
            if ( v27 >= 0 || v26 > 0 )
            {
              v28 = v26 - v27;
              if ( v28 )
              {
                break;
              }
            }
          }
          dword_98608 = v28;
          LODWORD(v29) = 0;
          HIDWORD(v29) = (*v25 - *v24) << 0x10;
          dword_98638 = (v29 >> 0x10) / (v28 << 0x10);
          dword_98618 = (*v24 << 0x10) + 0x8000;
          v30 = dword_985C8 - dword_98610;
          v8 = v14 <= dword_985C8;
          v31 = v14 - dword_985C8;
          if ( v8 )
          {
            v30 += v31;
          }
          dword_9860C = v30;
          if ( dword_98610 < 0 )
          {
            dword_9860C += dword_98610;
            dword_98610 = 0;
            v32 = -*(_DWORD *)(dword_985F4 + 4);
            dword_98604 += *(_DWORD *)(dword_985F4 + 4);
            dword_98614 += (unsigned __int64)((v32 << 0x10) * (__int64)dword_98634) >> 0x10;
            v33 = -*(_DWORD *)(dword_985F8 + 4);
            dword_98608 += *(_DWORD *)(dword_985F8 + 4);
            dword_98618 += (unsigned __int64)((v33 << 0x10) * (__int64)dword_98638) >> 0x10;
          }
          dword_985DC = dword_985CC + dword_985D0 * dword_98610;
          v34 = dword_98614;
          v35 = dword_98618;
          while ( 1 )
          {
            v62 = v34;
            v61 = v35;
            if ( v35 <= v34 )
            {
              v36 = v34;
              v34 = v35;
              v35 = v36;
            }
            v37 = v34 >> 0x10;
            if ( v37 <= dword_985C4 )
            {
              v38 = v35 >> 0x10;
              if ( v38 >= 0 )
              {
                dword_98654 = v37;
                dword_98658 = v38;
                if ( v38 != v37 )
                {
                  if ( dword_98654 < 0 )
                  {
                    dword_98654 = 0;
                  }
                  if ( dword_98658 > dword_985C4 )
                  {
                    dword_98658 -= dword_98658 - dword_985C4;
                  }
                }
                v39 = dword_98654 + dword_985DC;
                dword_985E0 = dword_98658 - dword_98654 + dword_98654 + dword_985DC;
                v40 = 0;
                v41 = dword_98658 - dword_98654 + 1;
                if ( ((dword_98654 + dword_985DC) & 1) != 0 )
                {
                  LOBYTE(v40) = *(_BYTE *)v39;
                  *(_BYTE *)v39 = *(_BYTE *)(v40 + a4);
                  if ( !--v41 )
                  {
                    goto LABEL_58;
                  }
                  ++v39;
                }
                if ( v41 == 1 )
                {
                  goto LABEL_57;
                }
                v60 = v41;
                v42 = (v41 >> 1) - 1;
                if ( v42 < 5 )
                {
LABEL_51:
                  LOBYTE(v40) = *(_WORD *)v39;
                  LOBYTE(v44) = *(_BYTE *)(v40 + a4);
                  LOBYTE(v40) = HIBYTE(*(_WORD *)v39);
                  HIBYTE(v44) = *(_BYTE *)(v40 + a4);
                  *(_WORD *)v39 = v44;
                  v45 = v42 - 1;
                  if ( v45 >= 0 )
                  {
                    LOBYTE(v40) = *(_WORD *)(v39 + 2);
                    LOBYTE(v46) = *(_BYTE *)(v40 + a4);
                    LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 2));
                    HIBYTE(v46) = *(_BYTE *)(v40 + a4);
                    *(_WORD *)(v39 + 2) = v46;
                    v47 = v45 - 1;
                    if ( v47 >= 0 )
                    {
                      LOBYTE(v40) = *(_WORD *)(v39 + 4);
                      LOBYTE(v48) = *(_BYTE *)(v40 + a4);
                      LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 4));
                      HIBYTE(v48) = *(_BYTE *)(v40 + a4);
                      *(_WORD *)(v39 + 4) = v48;
                      v49 = v47 - 1;
                      if ( v49 >= 0 )
                      {
                        LOBYTE(v40) = *(_WORD *)(v39 + 6);
                        LOBYTE(v50) = *(_BYTE *)(v40 + a4);
                        LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 6));
                        HIBYTE(v50) = *(_BYTE *)(v40 + a4);
                        *(_WORD *)(v39 + 6) = v50;
                        if ( v49 - 1 >= 0 )
                        {
                          LOBYTE(v40) = *(_WORD *)(v39 + 8);
                          LOBYTE(v51) = *(_BYTE *)(v40 + a4);
                          LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 8));
                          HIBYTE(v51) = *(_BYTE *)(v40 + a4);
                          *(_WORD *)(v39 + 8) = v51;
                        }
                      }
                    }
                  }
                }
                else
                {
                  while ( 1 )
                  {
                    LOBYTE(v40) = *(_WORD *)v39;
                    LOBYTE(v43) = *(_BYTE *)(v40 + a4);
                    LOBYTE(v40) = HIBYTE(*(_WORD *)v39);
                    HIBYTE(v43) = *(_BYTE *)(v40 + a4);
                    *(_WORD *)v39 = v43;
                    LOBYTE(v40) = *(_WORD *)(v39 + 2);
                    LOBYTE(v43) = *(_BYTE *)(v40 + a4);
                    LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 2));
                    HIBYTE(v43) = *(_BYTE *)(v40 + a4);
                    *(_WORD *)(v39 + 2) = v43;
                    LOBYTE(v40) = *(_WORD *)(v39 + 4);
                    LOBYTE(v43) = *(_BYTE *)(v40 + a4);
                    LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 4));
                    HIBYTE(v43) = *(_BYTE *)(v40 + a4);
                    *(_WORD *)(v39 + 4) = v43;
                    LOBYTE(v40) = *(_WORD *)(v39 + 6);
                    LOBYTE(v43) = *(_BYTE *)(v40 + a4);
                    LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 6));
                    HIBYTE(v43) = *(_BYTE *)(v40 + a4);
                    *(_WORD *)(v39 + 6) = v43;
                    LOBYTE(v40) = *(_WORD *)(v39 + 8);
                    LOBYTE(v43) = *(_BYTE *)(v40 + a4);
                    LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 8));
                    HIBYTE(v43) = *(_BYTE *)(v40 + a4);
                    *(_WORD *)(v39 + 8) = v43;
                    LOBYTE(v40) = *(_WORD *)(v39 + 0xA);
                    LOBYTE(v43) = *(_BYTE *)(v40 + a4);
                    LOBYTE(v40) = HIBYTE(*(_WORD *)(v39 + 0xA));
                    HIBYTE(v43) = *(_BYTE *)(v40 + a4);
                    *(_WORD *)(v39 + 0xA) = v43;
                    v39 += 0xC;
                    v42 -= 6;
                    if ( v42 < 0 )
                    {
                      break;
                    }
                    if ( v42 < 5 )
                    {
                      goto LABEL_51;
                    }
                  }
                }
                if ( (v60 & 1) != 0 )
                {
LABEL_57:
                  LOBYTE(v40) = *(_BYTE *)dword_985E0;
                  *(_BYTE *)dword_985E0 = *(_BYTE *)(v40 + a4);
                }
              }
            }
LABEL_58:
            dword_985DC += dword_985D0;
            v52 = v61;
            result = v62;
            v53 = dword_9860C-- == 1;
            if ( dword_9860C < 0 )
            {
              return result;
            }
            if ( v53 )
            {
              v34 = dword_98634 + v62;
              v35 = dword_98638 + v61;
            }
            else
            {
              if ( --dword_98604 )
              {
                v34 = dword_98634 + v62;
              }
              else
              {
                v54 = (_DWORD *)dword_985FC;
                dword_985F4 = dword_985FC;
                v55 = (_DWORD *)(dword_985FC - 0x18);
                if ( dword_985FC - 0x18 < dword_985E8 )
                {
                  v55 = (_DWORD *)(dword_985EC - 0x18);
                }
                dword_985FC = (int)v55;
                dword_98604 = (v55[1] == v54[1]) + v55[1] - v54[1];
                LODWORD(v56) = 0;
                HIDWORD(v56) = (*v55 - *v54) << 0x10;
                dword_98634 = (v56 >> 0x10) / (dword_98604 << 0x10);
                v34 = (*v54 << 0x10) + 0x8000;
                v52 = v61;
              }
              if ( --dword_98608 )
              {
                v35 = dword_98638 + v52;
              }
              else
              {
                v57 = (_DWORD *)dword_98600;
                dword_985F8 = dword_98600;
                v58 = (_DWORD *)(dword_98600 + 0x18);
                if ( dword_98600 + 0x18 >= dword_985EC )
                {
                  v58 = (_DWORD *)dword_985E8;
                }
                dword_98600 = (int)v58;
                dword_98608 = (v58[1] == v57[1]) + v58[1] - v57[1];
                LODWORD(v59) = 0;
                HIDWORD(v59) = (*v58 - *v57) << 0x10;
                dword_98638 = (v59 >> 0x10) / (dword_98608 << 0x10);
                v35 = (*v57 << 0x10) + 0x8000;
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 985C4: using guessed type int dword_985C4;
// 985C8: using guessed type int dword_985C8;
// 985CC: using guessed type int dword_985CC;
// 985D0: using guessed type int dword_985D0;
// 985DC: using guessed type int dword_985DC;
// 985E0: using guessed type int dword_985E0;
// 985E8: using guessed type int dword_985E8;
// 985EC: using guessed type int dword_985EC;
// 985F0: using guessed type int dword_985F0;
// 985F4: using guessed type int dword_985F4;
// 985F8: using guessed type int dword_985F8;
// 985FC: using guessed type int dword_985FC;
// 98600: using guessed type int dword_98600;
// 98604: using guessed type int dword_98604;
// 98608: using guessed type int dword_98608;
// 9860C: using guessed type int dword_9860C;
// 98610: using guessed type int dword_98610;
// 98614: using guessed type int dword_98614;
// 98618: using guessed type int dword_98618;
// 98634: using guessed type int dword_98634;
// 98638: using guessed type int dword_98638;
// 98654: using guessed type int dword_98654;
// 98658: using guessed type int dword_98658;

//----- (000648EC) --------------------------------------------------------
void sub_648EC()
{
  int v0; // [esp+0h] [ebp-10h]
  int v1; // [esp+4h] [ebp-Ch]

  sub_64D91();
  x0 = dword_132BC4 + dword_132C14;
  y0 = dword_132BC8 + dword_132C18;
  x1 = dword_132BA4 + dword_132BC4 + dword_132C14 - 1;
  y1 = dword_132BE0 + dword_132BC8 + dword_132C18 - 1;
  if ( dword_132BC4 + dword_132C14 > dword_132BB8 || y0 > dword_132BBC || x1 < 0 || y1 < 0 )
  {
    goto LABEL_19;
  }
  if ( x0 < 0 )
  {
    x0 = 0;
  }
  if ( y0 < 0 )
  {
    y0 = 0;
  }
  if ( x1 > dword_132BB8 )
  {
    x1 = dword_132BB8;
  }
  if ( y1 > dword_132BBC )
  {
    y1 = dword_132BBC;
  }
  if ( (dword_132B68 == 0xFFFFFFFF || !sub_64E59(&dword_132B68)) && (!dword_132BB0 || dword_132BB0(&x0)) )
  {
    dword_132BF8 = 0;
    V_Window2.x_max = x1 - x0;
    V_Window3.x_max = x1 - x0;
    V_Type5_stru_132B8C.rect.x2 = x1 - x0;
    V_Window2.y_max = y1 - y0;
    V_Window3.y_max = y1 - y0;
    V_Type5_stru_132B8C.rect.y2 = y1 - y0;
    VFX_window_read(&V_Window2, x0, y0, x1, y1);
    memmove(V_Window3.buffer, V_Window2.buffer, n);
    if ( dword_132BC4 + dword_132C14 >= 0 )
    {
      v0 = -dword_132BC4;
    }
    else
    {
      v0 = dword_132C14;
    }
    if ( dword_132BC8 + dword_132C18 >= 0 )
    {
      v1 = -dword_132BC8;
    }
    else
    {
      v1 = dword_132C18;
    }
    sub_5CB3C(&V_Type5_stru_132B8C, dword_132BA0, dword_132B88, v0, v1);
    VFX_window_refresh(&V_Window3, x0, y0, x1, y1);
    sub_64DAC();
  }
  else
  {
LABEL_19:
    dword_132BF8 = 1;
    sub_64DAC();
  }
}
// 132B68: using guessed type int dword_132B68;
// 132B88: using guessed type int dword_132B88;
// 132BA0: using guessed type int dword_132BA0;
// 132BA4: using guessed type int dword_132BA4;
// 132BB0: using guessed type int (__cdecl *dword_132BB0)(_DWORD);
// 132BB8: using guessed type int dword_132BB8;
// 132BBC: using guessed type int dword_132BBC;
// 132BC4: using guessed type int dword_132BC4;
// 132BC8: using guessed type int dword_132BC8;
// 132BE0: using guessed type int dword_132BE0;
// 132BF8: using guessed type int dword_132BF8;
// 132C14: using guessed type int dword_132C14;
// 132C18: using guessed type int dword_132C18;

//----- (00064B6E) --------------------------------------------------------
void sub_64B6E()
{
  sub_64D91();
  if ( !dword_132BF8 )
  {
    VFX_window_refresh(&V_Window2, x0, y0, x1, y1);
  }
  sub_64DAC();
}
// 132BF8: using guessed type int dword_132BF8;

//----- (00064BC4) --------------------------------------------------------
int __fastcall sub_64BC4(int a1, int a2, int a3, int a4)
{
  int result; // eax

  dword_132B68 = a1;
  dword_132B6C = a2;
  dword_132B70 = a3;
  result = a4;
  dword_132B74 = a4;
  return result;
}
// 132B68: using guessed type int dword_132B68;
// 132B6C: using guessed type int dword_132B6C;
// 132B70: using guessed type int dword_132B70;
// 132B74: using guessed type int dword_132B74;

//----- (00064C01) --------------------------------------------------------
int sub_64C01()
{
  struct SREGS v1; // [esp+0h] [ebp-48h] BYREF
  union REGS v2; // [esp+Ch] [ebp-3Ch] BYREF
  union REGS v3; // [esp+28h] [ebp-20h] BYREF

  *(_QWORD *)&v3.x.eax = 0x200000100i64;
  int386(0x31, &v3, &v2);
  if ( v2.x.cflag )
  {
    return 0;
  }
  dword_132C28 = v2.w.ax;
  dword_132C2C = v2.w.dx;
  memmove((void *)(0x10 * v2.w.ax), &unk_98794, 0x12u);
  memset(&unk_132C38, 0, 0x32u);
  dword_132C54 = 0xC;
  dword_132C50 = 0x7F;
  word_132C5A = dword_132C28;
  *(_QWORD *)&v3.x.eax = 0x3300000300i64;
  v3.x.ecx = 0;
  v3.x.edi = (unsigned int)&unk_132C38;
  v1.ds = __DS__;
  v1.es = __DS__;
  int386x(0x31, &v3, &v2, &v1);
  return 1;
}
// 132C28: using guessed type int dword_132C28;
// 132C2C: using guessed type int dword_132C2C;
// 132C50: using guessed type int dword_132C50;
// 132C54: using guessed type int dword_132C54;
// 132C5A: using guessed type __int16 word_132C5A;

//----- (00064D00) --------------------------------------------------------
int sub_64D00()
{
  union REGS v1; // [esp+0h] [ebp-44h] BYREF
  union REGS v2; // [esp+1Ch] [ebp-28h] BYREF
  struct SREGS v3; // [esp+38h] [ebp-Ch] BYREF

  memset(&unk_132C6A, 0, 0x32u);
  dword_132C86 = 0xC;
  dword_132C82 = 0;
  word_132C8C = 0;
  *(_QWORD *)&v2.x.eax = 0x3300000300i64;
  v2.x.ecx = 0;
  v2.x.edi = (unsigned int)&unk_132C6A;
  v3.ds = __DS__;
  v3.es = __DS__;
  return int386x(0x31, &v2, &v1, &v3);
}
// 132C82: using guessed type int dword_132C82;
// 132C86: using guessed type int dword_132C86;
// 132C8C: using guessed type __int16 word_132C8C;

//----- (00064D91) --------------------------------------------------------
void sub_64D91()
{
  ++dword_132C04;
}
// 132C04: using guessed type int dword_132C04;

//----- (00064DAC) --------------------------------------------------------
void sub_64DAC()
{
  --dword_132C04;
}
// 132C04: using guessed type int dword_132C04;

//----- (00064DC8) --------------------------------------------------------
void sub_64DC8()
{
  ++dword_132C24;
}
// 132C24: using guessed type int dword_132C24;

//----- (00064DE3) --------------------------------------------------------
void sub_64DE3()
{
  --dword_132C24;
}
// 132C24: using guessed type int dword_132C24;

//----- (00064DFF) --------------------------------------------------------
int __fastcall sub_64DFF(_DWORD *a1)
{
  sub_64D91();
  if ( dword_132BF8 || dword_132BC0 < 0 )
  {
    sub_64DAC();
    return 0;
  }
  else
  {
    *a1 = x0;
    a1[1] = *(&x0 + 1);
    a1[2] = *(&x0 + 2);
    a1[3] = *(&x0 + 3);
    sub_64DAC();
    return 1;
  }
}
// 132BC0: using guessed type int dword_132BC0;
// 132BF8: using guessed type int dword_132BF8;

//----- (00064E59) --------------------------------------------------------
BOOL __fastcall sub_64E59(_DWORD *a1)
{
  int v2[4]; // [esp+0h] [ebp-18h] BYREF
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = a1;
  return sub_64DFF(v2) && v2[0] <= v3[2] && v2[2] >= *v3 && v2[3] >= v3[1] && v2[1] <= v3[3];
}

//----- (00064ECA) --------------------------------------------------------
void sub_64ECA()
{
  sub_64D91();
  if ( dword_132BC0 )
  {
    if ( !++dword_132BC0 )
    {
      sub_648EC();
    }
  }
  sub_64DAC();
}
// 132BC0: using guessed type int dword_132BC0;

//----- (00064F06) --------------------------------------------------------
void sub_64F06()
{
  sub_64D91();
  if ( !dword_132BC0 )
  {
    sub_64B6E();
  }
  --dword_132BC0;
  sub_64DAC();
}
// 132BC0: using guessed type int dword_132BC0;

//----- (00064F39) --------------------------------------------------------
void __fastcall sub_64F39(int a1, int a2)
{
  __int16 v2; // ax
  unsigned __int16 v4; // [esp+10h] [ebp-8h]
  __int16 savedregs_2; // [esp+1Ah] [ebp+2h]
  __int16 savedregs_6; // [esp+1Eh] [ebp+6h]

  if ( dword_132BA0 != a1 || dword_132B88 != a2 )
  {
    sub_64D91();
    sub_64F06();
    dword_132BA0 = a1;
    dword_132B88 = a2;
    v4 = sub_610E8(a1, a2);
    v2 = sub_6111C(a1, a2);
    dword_132BA4 = savedregs_6;
    dword_132BE0 = v4;
    dword_132BC4 = savedregs_2;
    dword_132BC8 = v2;
    n = v4 * savedregs_6;
    sub_64ECA();
    sub_64DAC();
  }
}
// 64FB3: variable 'savedregs_6' is possibly undefined
// 64FD2: variable 'savedregs_2' is possibly undefined
// 132B88: using guessed type int dword_132B88;
// 132BA0: using guessed type int dword_132BA0;
// 132BA4: using guessed type int dword_132BA4;
// 132BC4: using guessed type int dword_132BC4;
// 132BC8: using guessed type int dword_132BC8;
// 132BE0: using guessed type int dword_132BE0;

//----- (00064FFE) --------------------------------------------------------
void __fastcall sub_64FFE(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  sub_64D91();
  if ( a1 )
  {
    *a1 = dword_132C14;
  }
  if ( a2 )
  {
    *a2 = dword_132C18;
  }
  if ( a3 )
  {
    *a3 = dword_132C0C;
  }
  if ( a4 )
  {
    *a4 = dword_132C34;
  }
  if ( a5 )
  {
    *a5 = dword_132C00;
  }
  sub_64DAC();
}
// 132C00: using guessed type int dword_132C00;
// 132C0C: using guessed type int dword_132C0C;
// 132C14: using guessed type int dword_132C14;
// 132C18: using guessed type int dword_132C18;
// 132C34: using guessed type int dword_132C34;

//----- (0006507C) --------------------------------------------------------
void __fastcall sub_6507C(int a1, int a2)
{
  union REGS v2; // [esp+0h] [ebp-4Ch] BYREF
  union REGS v3; // [esp+1Ch] [ebp-30h] BYREF
  int v4; // [esp+38h] [ebp-14h]
  int v5; // [esp+3Ch] [ebp-10h]
  int v6; // [esp+40h] [ebp-Ch]
  int v7; // [esp+44h] [ebp-8h]
  int v8; // [esp+48h] [ebp-4h]

  v5 = a1;
  v4 = a2;
  sub_64D91();
  v2.x.eax = 4;
  v2.x.ecx = 8 * v5;
  v2.x.edx = 8 * a2;
  int386(0x33, &v2, &v3);
  v2.x.eax = 3;
  int386(0x33, &v2, &v3);
  v6 = 0x4F0;
  MEMORY[0x4F0] = v3.w.bx;
  v8 = 0x4F2;
  MEMORY[0x4F2] = v3.w.cx;
  v7 = 0x4F4;
  MEMORY[0x4F4] = v3.w.dx;
  sub_64DAC();
  callback_fn();
}

//----- (0006515A) --------------------------------------------------------
int (__cdecl *__fastcall sub_6515A(int (__cdecl *result)(_DWORD)))(_DWORD)
{
  dword_132BB0 = result;
  return result;
}
// 132BB0: using guessed type int (__cdecl *dword_132BB0)(_DWORD);

//----- (0006517C) --------------------------------------------------------
void callback_fn()
{
  if ( dword_132C04 <= 0 )
  {
    ++dword_132C04;
    dword_132C08 = dword_132C0C;
    dword_132C30 = dword_132C34;
    dword_132BFC = dword_132C00;
    dword_132C0C = (MEMORY[0x4F0] & 1) != 0;
    dword_132C34 = (MEMORY[0x4F0] & 2) != 0;
    dword_132C00 = (MEMORY[0x4F0] & 4) != 0;
    if ( (dword_132C0C != dword_132C08 || dword_132C34 != dword_132C30 || dword_132C00 != dword_132BFC) && dword_132BA8 )
    {
      dword_132BA8(dword_132C0C, dword_132C34, dword_132C00);
    }
    if ( dword_132C24 <= 0 )
    {
      dword_132C1C = dword_132C14;
      dword_132C20 = dword_132C18;
      dword_132C14 = MEMORY[0x4F2] >> 3;
      dword_132C18 = MEMORY[0x4F4] >> 3;
      if ( MEMORY[0x4F2] >> 3 != dword_132C1C || dword_132C18 != dword_132C20 )
      {
        if ( dword_132BAC )
        {
          dword_132BAC(dword_132C14, dword_132C18);
        }
        if ( dword_132BC0 >= 0 )
        {
          sub_64B6E();
          sub_648EC();
        }
      }
      --dword_132C04;
    }
    else
    {
      --dword_132C04;
    }
  }
}
// 132BA8: using guessed type int (__cdecl *dword_132BA8)(_DWORD, _DWORD, _DWORD);
// 132BAC: using guessed type int (__cdecl *dword_132BAC)(_DWORD, _DWORD);
// 132BC0: using guessed type int dword_132BC0;
// 132BFC: using guessed type int dword_132BFC;
// 132C00: using guessed type int dword_132C00;
// 132C04: using guessed type int dword_132C04;
// 132C08: using guessed type int dword_132C08;
// 132C0C: using guessed type int dword_132C0C;
// 132C14: using guessed type int dword_132C14;
// 132C18: using guessed type int dword_132C18;
// 132C1C: using guessed type int dword_132C1C;
// 132C20: using guessed type int dword_132C20;
// 132C24: using guessed type int dword_132C24;
// 132C30: using guessed type int dword_132C30;
// 132C34: using guessed type int dword_132C34;

//----- (00065832) --------------------------------------------------------
void __fastcall sub_65832(P_Type6 *a1, LONG a2, LONG a3, LONG a4, int y1)
{
  int v5; // [esp+0h] [ebp-B0h]
  int v6; // [esp+4h] [ebp-ACh]
  int *v7; // [esp+8h] [ebp-A8h]
  int *v8; // [esp+Ch] [ebp-A4h]
  int *v9; // [esp+10h] [ebp-A0h]
  int *v10; // [esp+14h] [ebp-9Ch]
  int v11; // [esp+18h] [ebp-98h]
  LONG v12; // [esp+1Ch] [ebp-94h]
  LONG v13; // [esp+20h] [ebp-90h]
  LONG v14; // [esp+24h] [ebp-8Ch]
  LONG v15; // [esp+28h] [ebp-88h]
  LONG v16; // [esp+2Ch] [ebp-84h]
  LONG v17; // [esp+30h] [ebp-80h]
  int v18; // [esp+34h] [ebp-7Ch]
  LONG x_max; // [esp+38h] [ebp-78h]
  LONG v20; // [esp+3Ch] [ebp-74h]
  LONG y_max; // [esp+40h] [ebp-70h]
  LONG v22; // [esp+44h] [ebp-6Ch]
  int *v23[5]; // [esp+48h] [ebp-68h] BYREF
  T_Type5 v24; // [esp+5Ch] [ebp-54h] BYREF
  PANE *target; // [esp+70h] [ebp-40h]
  LONG x1; // [esp+74h] [ebp-3Ch]
  LONG x0; // [esp+78h] [ebp-38h]
  LONG y0; // [esp+7Ch] [ebp-34h]
  STENCIL *v29; // [esp+80h] [ebp-30h]
  int v30; // [esp+84h] [ebp-2Ch]
  int v31; // [esp+88h] [ebp-28h]
  int v32; // [esp+8Ch] [ebp-24h]
  int v33; // [esp+90h] [ebp-20h]
  int v34; // [esp+94h] [ebp-1Ch]
  int i; // [esp+98h] [ebp-18h]
  int v36; // [esp+9Ch] [ebp-14h]
  int *v37; // [esp+A0h] [ebp-10h]
  int *v38; // [esp+A4h] [ebp-Ch]
  int v39; // [esp+A8h] [ebp-8h]
  int v40; // [esp+ACh] [ebp-4h]

  target = (PANE *)a1;
  x0 = a2;
  y0 = a3;
  x1 = a4;
  if ( dword_132BC0 >= 0 )
  {
    sub_64DC8();
    if ( ::x0 <= x1 && ::x1 >= x0 && ::y1 >= y0 && ::y0 <= y1 )
    {
      if ( target->x1 >= target->window->x_max )
      {
        x_max = target->window->x_max;
      }
      else
      {
        x_max = target->x1;
      }
      if ( target->x0 <= 0 )
      {
        v20 = 0;
      }
      else
      {
        v20 = target->x0;
      }
      if ( x1 - x0 == x_max - v20
        && (target->y1 >= target->window->y_max ? (y_max = target->window->y_max) : (y_max = target->y1),
            target->y0 <= 0 ? (v22 = 0) : (v22 = target->y0),
            y1 - y0 == y_max - v22) )
      {
        if ( target->window->stencil )
        {
          if ( x0 <= ::x0 )
          {
            v15 = ::x0;
          }
          else
          {
            v15 = x0;
          }
          v34 = v15 - x0 + target->x0;
          if ( x1 >= ::x1 )
          {
            v16 = ::x1;
          }
          else
          {
            v16 = x1;
          }
          v33 = v16 - x0 + target->x0;
          if ( y0 <= ::y0 )
          {
            v17 = ::y0;
          }
          else
          {
            v17 = y0;
          }
          v32 = v17 - y0 + target->y0;
          if ( y1 >= ::y1 )
          {
            v18 = ::y1;
          }
          else
          {
            v18 = y1;
          }
          v31 = v18 - y0 + target->y0;
          for ( i = v32; i <= v31; ++i )
          {
            v36 = 0;
            v29 = &target->window->stencil[*(_DWORD *)&target->window->stencil[4 * i]];
            while ( v36 <= v33 )
            {
              v30 = v36 + (*v29 & 0x7F) - 1;
              if ( *v29 < 0x80u && v36 <= v33 && v30 >= v34 )
              {
                goto LABEL_23;
              }
              ++v29;
              v36 = v30 + 1;
            }
          }
        }
        v24.a = (P_Type6)target->window;
        if ( x0 <= ::x0 )
        {
          v14 = ::x0;
        }
        else
        {
          v14 = x0;
        }
        v24.rect.x1 = v14 - x0 + target->x0;
        if ( x1 >= ::x1 )
        {
          v13 = ::x1;
        }
        else
        {
          v13 = x1;
        }
        v24.rect.x2 = v13 - x0 + target->x0;
        if ( y0 <= ::y0 )
        {
          v12 = ::y0;
        }
        else
        {
          v12 = y0;
        }
        v24.rect.y1 = v12 - y0 + target->y0;
        if ( y1 >= ::y1 )
        {
          v11 = ::y1;
        }
        else
        {
          v11 = y1;
        }
        v24.rect.y2 = v11 - y0 + target->y0;
        v38 = (int *)(::x1 - ::x0);
        v37 = (int *)(::y1 - ::y0);
        v23[0] = (int *)&V_Window2;
        if ( ::x0 >= x0 )
        {
          v10 = 0;
        }
        else
        {
          v10 = (int *)(x0 - ::x0);
        }
        v23[1] = v10;
        if ( ::x1 <= x1 )
        {
          v9 = v38;
        }
        else
        {
          v9 = (int *)((char *)v38 - (::x1 - x1));
        }
        v23[3] = v9;
        if ( ::y0 >= y0 )
        {
          v8 = 0;
        }
        else
        {
          v8 = (int *)(y0 - ::y0);
        }
        v23[2] = v8;
        if ( ::y1 <= y1 )
        {
          v7 = v37;
        }
        else
        {
          v7 = (int *)((char *)v37 - (::y1 - y1));
        }
        v23[4] = v7;
        sub_5EAAF((int **)&v24, 0, 0, v23, 0, 0, 0xFFFFFFFF);
        if ( dword_132BC4 + dword_132C14 >= x0 )
        {
          v6 = -dword_132BC4;
        }
        else
        {
          v6 = dword_132C14 - x0;
        }
        v40 = v6;
        if ( dword_132BC8 + dword_132C18 >= y0 )
        {
          v5 = -dword_132BC8;
        }
        else
        {
          v5 = dword_132C18 - y0;
        }
        v39 = v5;
        sub_5CB3C(&v24, dword_132BA0, dword_132B88, v40, v5);
        VFX_pane_refresh(target, x0, y0, x1, y1);
        sub_5EAAF(v23, 0, 0, &v24, 0, 0, 0xFFFFFFFF);
        sub_64DE3();
        callback_fn();
      }
      else
      {
LABEL_23:
        VFX_wait_vblank_leading();
        sub_64F06();
        VFX_pane_refresh(target, x0, y0, x1, y1);
        sub_64ECA();
        sub_64DE3();
        callback_fn();
      }
    }
    else
    {
      sub_64BC4(x0, y0, x1, y1);
      sub_64DE3();
      VFX_pane_refresh(target, x0, y0, x1, y1);
      sub_64BC4(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);
      callback_fn();
    }
  }
  else
  {
    VFX_pane_refresh(target, x0, y0, x1, y1);
  }
}
// 132B88: using guessed type int dword_132B88;
// 132BA0: using guessed type int dword_132BA0;
// 132BC0: using guessed type int dword_132BC0;
// 132BC4: using guessed type int dword_132BC4;
// 132BC8: using guessed type int dword_132BC8;
// 132C14: using guessed type int dword_132C14;
// 132C18: using guessed type int dword_132C18;

//----- (00065E2B) --------------------------------------------------------
unsigned int __fastcall sub_65E2B(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1[2] )
    {
      break;
    }
    if ( *(_DWORD *)(4 * i + a1[1]) == 1 )
    {
      sub_65832(
        (P_Type6 *)(0x14 * i + *a1),
        *(_DWORD *)(0x14 * i + *a1 + 4),
        *(_DWORD *)(0x14 * i + *a1 + 8),
        *(_DWORD *)(0x14 * i + *a1 + 0xC),
        *(_DWORD *)(0x14 * i + *a1 + 0x10));
    }
  }
  return result;
}

//----- (00065EA4) --------------------------------------------------------
int __fastcall sub_65EA4(int a1, int a2)
{
  union REGS v3; // [esp+0h] [ebp-44h] BYREF
  union REGS v4; // [esp+1Ch] [ebp-28h] BYREF
  int v5; // [esp+38h] [ebp-Ch]
  int v6; // [esp+3Ch] [ebp-8h]

  v5 = a1;
  v6 = a2;
  dword_132C04 = 0;
  dword_132C24 = 0;
  dword_132BC0 = 0xFFFFFFFF;
  dword_132BA0 = 0;
  dword_132BF8 = 0;
  sub_64BC4(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);
  dword_132BAC = 0;
  dword_132BA8 = 0;
  dword_132BB0 = 0;
  dword_132C00 = 0xFFFFFFFF;
  dword_132C34 = 0xFFFFFFFF;
  dword_132C0C = 0xFFFFFFFF;
  dword_132C18 = 0xFFFFFFFF;
  dword_132C14 = 0xFFFFFFFF;
  dword_132BB8 = v5 - 1;
  dword_132BBC = a2 - 1;
  v3.x.eax = 0;
  int386(0x33, &v3, &v4);
  if ( v4.w.ax != 0xFFFF )
  {
    return 0;
  }
  v3.x.eax = 7;
  v3.x.ecx = 0;
  v3.x.edx = 8 * dword_132BB8;
  int386(0x33, &v3, &v4);
  v3.x.eax = 8;
  v3.x.ecx = 0;
  v3.x.edx = 8 * dword_132BBC;
  int386(0x33, &v3, &v4);
  v3.x.eax = 0xF;
  *(_QWORD *)&v3.h.cl = 0x100000001i64;
  int386(0x33, &v3, &v4);
  if ( !sub_64C01() )
  {
    return 0;
  }
  V_Window3.buffer = (UBYTE *)malloc(0x4000u);
  V_Window2.buffer = (UBYTE *)malloc(0x4000u);
  V_Window3.shadow = 0;
  V_Window3.stencil = 0;
  V_Window2.shadow = 0;
  V_Window2.stencil = 0;
  V_Type5_stru_132B8C.rect.x1 = 0;
  V_Type5_stru_132B8C.rect.y1 = 0;
  V_Type5_stru_132B8C.a = (P_Type6)&V_Window3;
  sub_6507C(v5 / 2, v6 / 2);
  timer = AIL_register_timer(callback_fn);
  if ( v6 < 400 )
  {
    AIL_set_timer_frequency(timer, 70u);
  }
  else
  {
    AIL_set_timer_frequency(timer, 60u);
  }
  AIL_start_timer(timer);
  return 1;
}
// 132BA0: using guessed type int dword_132BA0;
// 132BA8: using guessed type int (__cdecl *dword_132BA8)(_DWORD, _DWORD, _DWORD);
// 132BAC: using guessed type int (__cdecl *dword_132BAC)(_DWORD, _DWORD);
// 132BB0: using guessed type int (__cdecl *dword_132BB0)(_DWORD);
// 132BB8: using guessed type int dword_132BB8;
// 132BBC: using guessed type int dword_132BBC;
// 132BC0: using guessed type int dword_132BC0;
// 132BF8: using guessed type int dword_132BF8;
// 132C00: using guessed type int dword_132C00;
// 132C04: using guessed type int dword_132C04;
// 132C0C: using guessed type int dword_132C0C;
// 132C14: using guessed type int dword_132C14;
// 132C18: using guessed type int dword_132C18;
// 132C24: using guessed type int dword_132C24;
// 132C34: using guessed type int dword_132C34;

//----- (000660FF) --------------------------------------------------------
int sub_660FF()
{
  union REGS v2; // [esp+0h] [ebp-38h] BYREF
  union REGS v3; // [esp+1Ch] [ebp-1Ch] BYREF

  sub_64F06();
  AIL_stop_timer(timer);
  AIL_release_timer_handle(timer);
  sub_64D00();
  free(V_Window2.buffer);
  free(V_Window3.buffer);
  v3.x.eax = 0x101;
  v3.x.edx = dword_132C2C;
  return int386(0x31, &v3, &v2);
}
// 132C2C: using guessed type int dword_132C2C;

//----- (00066177) --------------------------------------------------------
void *__cdecl DLL_read(ULONG src, ULONG srcoff, ULONG flags, void *dest, ULONG length)
{
  if ( (flags & DLLSRC_MEM) != 0 )
  {
    memcpy(dest, (const void *)(src + srcoff), length);
  }
  else
  {
    lseek(src, srcoff, 0);
    read(src, dest, length);
  }
  return (void *)(srcoff + length);
}

//----- (000661DE) --------------------------------------------------------
void *__cdecl sub_661DE(size_t size)
{
  void *v1; // eax
  void *v2; // esi

  v1 = malloc(size);
  v2 = v1;
  if ( v1 )
  {
    sub_6635F((unsigned int)v1, size);
  }
  return v2;
}

//----- (000661FF) --------------------------------------------------------
int __cdecl sub_661FF(void *ptr)
{
  int result; // eax

  if ( ptr )
  {
    sub_66376();
    return off_987B0(ptr);
  }
  return result;
}
// 987B0: using guessed type int (__fastcall *off_987B0)(_DWORD);

//----- (00066220) --------------------------------------------------------
int __cdecl sub_66220(unsigned int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // esi
  union REGS v6; // [esp+0h] [ebp-3Ch] BYREF
  union REGS v7; // [esp+1Ch] [ebp-20h] BYREF

  v6.x.eax = 0x100;
  v6.x.ebx = a1;
  int386(0x31, &v6, &v7);
  if ( v7.x.cflag )
  {
    v4 = 0;
  }
  else
  {
    *a3 = v7.x.eax << 0x10;
    *a2 = 0x10 * v7.w.ax;
    *a4 = v7.w.dx;
    v4 = 1;
  }
  if ( v4 )
  {
    sub_662D1(*a3 >> 0xC, (*a3 >> 0xC) + 0x10 * a1 - 1);
  }
  return v4;
}

//----- (000662A5) --------------------------------------------------------
int __cdecl sub_662A5(int a1, int a2, unsigned __int16 a3)
{
  union REGS v4; // [esp+0h] [ebp-38h] BYREF
  union REGS v5; // [esp+1Ch] [ebp-1Ch] BYREF

  v4.x.eax = 0x101;
  v4.x.edx = a3;
  return int386(0x31, &v4, &v5);
}

//----- (000662D1) --------------------------------------------------------
BOOL __cdecl sub_662D1(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  unsigned int v4; // edx
  union REGS v6; // [esp+0h] [ebp-38h] BYREF
  union REGS v7; // [esp+1Ch] [ebp-1Ch] BYREF

  v2 = a1;
  if ( a1 >= a2 )
  {
    v3 = a2;
  }
  else
  {
    v3 = a1;
  }
  if ( a1 < a2 )
  {
    v2 = a2;
  }
  v4 = v2 - v3 + 1;
  v6.x.eax = 0x600;
  v6.x.ebx = HIWORD(v3);
  v6.x.ecx = (unsigned __int16)v3;
  v6.x.esi = HIWORD(v4);
  v6.x.edi = (unsigned __int16)v4;
  int386(0x31, &v6, &v7);
  return v7.x.cflag == 0;
}

//----- (0006633A) --------------------------------------------------------
void sub_6633A()
{
  JUMPOUT(0x662F4);
}
// 6635D: control flows out of bounds to 662F4

//----- (0006635F) --------------------------------------------------------
BOOL __cdecl sub_6635F(unsigned int a1, int a2)
{
  return sub_662D1(a1, a2 + a1);
}

//----- (00066376) --------------------------------------------------------
void sub_66376()
{
  sub_6633A();
}

//----- (0006638D) --------------------------------------------------------
ULONG __cdecl DLL_size(void *source, ULONG flags)
{
  int module_size; // edi
  ULONG lx; // ebp
  void *src_ptr; // eax
  ULONG i; // esi
  LX_header_struct LX_hdr; // [esp+0h] [ebp-D8h] BYREF
  object_table_struct object_table; // [esp+ACh] [ebp-2Ch] BYREF
  ULONG LX_offset; // [esp+C4h] [ebp-14h] BYREF
  char cword[4]; // [esp+C8h] [ebp-10h] BYREF

  *(_DWORD *)cword = '  ';
  module_size = 0;
  if ( (flags & DLLSRC_MEM) != 0 )
  {
    lx = (ULONG)source;
  }
  else
  {
    lx = open((const char *)source, O_BINARY);
    if ( lx == 0xFFFFFFFF )                            // error opening file?
    {
      return 0;
    }
  }
  // Get LX header offset
  DLL_read(lx, 0x3Cu, flags, &LX_offset, 4u);
  // Check for valid LX marker
  DLL_read(lx, LX_offset, flags, cword, 2u);
  if ( strcmp(cword, "LX") )
  {
    close(lx);
    return 0;
  }
  // Read LX header (Tables not included)
  DLL_read(lx, LX_offset, flags, &LX_hdr, sizeof(LX_header_struct));
  // Read object table; calculate memory needed
  src_ptr = (void *)(LX_hdr.object_table_off + LX_offset);
  for ( i = 0; i < LX_hdr.num_objects_in_module; ++i )
  {
    src_ptr = DLL_read(lx, (ULONG)src_ptr, flags, &object_table, sizeof(object_table_struct));
    module_size += object_table.virtual_size;
  }
  if ( (flags & DLLSRC_MEM) == 0 )
  {
    close(lx);
  }
  // Add slack for paragraph alignment of each DATA Object
  return module_size + 15 * LX_hdr.num_objects_in_module;
}

//----- (000664BC) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void *__cdecl DLL_load(void *source, ULONG flags, void *dll)
{
  ULONG lx; // esi
  size_t v4; // eax
  size_t dll_size; // ebx
  bool v6; // zf
  void *src_ptr; // ecx
  ULONG i; // edi
  void *src_ptr_1; // ecx
  ULONG j; // ebp
  void *src_ptr_2; // ecx
  int v13; // eax
  UBYTE *v14; // edx
  unsigned int v15; // edx
  void *src_ptr_3; // ecx
  ULONG k; // edi
  void *v18; // edx
  void *src_ptr_8; // ecx
  void *src_ptr_4; // eax
  void *src_ptr_5; // ecx
  void *src_ptr_6; // eax
  void *src_ptr_7; // eax
  UBYTE *page_ptr[100]; // [esp+0h] [ebp-2CCh]
  LX_header_struct LX_hdr; // [esp+190h] [ebp-13Ch] BYREF
  UBYTE *object_ptr[10]; // [esp+23Ch] [ebp-90h]
  object_table_struct object_table; // [esp+264h] [ebp-68h] BYREF
  object_page_table_struct object_page_table; // [esp+27Ch] [ebp-50h] BYREF
  ULONG LX_offset; // [esp+284h] [ebp-48h] BYREF
  ULONG next_page_offset; // [esp+288h] [ebp-44h] BYREF
  ULONG page_offset; // [esp+28Ch] [ebp-40h] BYREF
  char cword[4]; // [esp+290h] [ebp-3Ch] BYREF
  void *object_page_table_pos; // [esp+294h] [ebp-38h]
  UBYTE *dll_ptr; // [esp+298h] [ebp-34h]
  void *object_table_pos; // [esp+29Ch] [ebp-30h]
  void *v36; // [esp+2A0h] [ebp-2Ch]
  int page_count; // [esp+2A4h] [ebp-28h]
  unsigned int read_size; // [esp+2A8h] [ebp-24h]
  UWORD srcoff; // [esp+2ACh] [ebp-20h] BYREF
  UWORD trgoff; // [esp+2B0h] [ebp-1Ch] BYREF
  UBYTE src; // [esp+2B4h] [ebp-18h] OVERLAPPED BYREF
  UBYTE f_object; // [esp+2B8h] [ebp-14h] OVERLAPPED BYREF
  UBYTE fix_flags; // [esp+2BCh] [ebp-10h] OVERLAPPED BYREF

  *(_DWORD *)cword = '  ';
  page_count = 0;
  if ( (flags & DLLSRC_MEM) != 0 )
  {
    lx = (ULONG)source;
  }
  else
  {
    lx = open((const char *)source, O_BINARY);
    if ( lx == 0xFFFFFFFF )                            // error opening file?
    {
      return 0;
    }
  }
  // Allocate memory if not done by caller
  v4 = DLL_size(source, flags);
  dll_size = v4;
  if ( (flags & DLLMEM_ALLOC) == 0 || (dll = malloc(v4)) != 0 )
  {
    memset(dll, 0, dll_size);
    dll_ptr = (UBYTE *)dll;
    // Get LX header offset
    DLL_read(lx, 0x3Cu, flags, &LX_offset, 4u);
    // Check for valid LX marker
    DLL_read(lx, LX_offset, flags, cword, 2u);
    if ( !strcmp(cword, "LX") )
    {
      // Read LX header (Tables not included)
      DLL_read(lx, LX_offset, flags, &LX_hdr, sizeof(LX_header_struct));
      // Read object table
      src_ptr = (void *)(LX_hdr.object_table_off + LX_offset);
      for ( i = 0; i < LX_hdr.num_objects_in_module; ++i )
      {
        // Read in object page entries
        object_table_pos = DLL_read(lx, (ULONG)src_ptr, flags, &object_table, sizeof(object_table_struct));
        src_ptr_1 = (void *)(LX_hdr.object_page_table_off + LX_offset);
        for ( j = 0; j < object_table.num_page_table_entries; ++j )
        {
          src_ptr_2 = DLL_read(lx, (ULONG)src_ptr_1, flags, &object_page_table, sizeof(object_page_table_struct));
          // Read page data into DLL buffer
          if ( !j )                                    // Do if this is a new object
          {
            // If this is the data object, paragraph-align it,
            // unless this is the first object in the file; then
            // the user is responsible for allocating a paragraph-aligned
            // memory block
            if ( (object_table.object_flags & 2) != 0
              && (object_table.object_flags & 1) != 0
              && ((unsigned __int8)dll_ptr & 0xF) != 0
              && i )
            {
              dll_ptr += 0x10 - ((unsigned __int8)dll & 0xF);
            }
            object_ptr[i + 1] = dll_ptr;               // Save object start position
          }
          v13 = page_count;
          v14 = dll_ptr;
          page_ptr[page_count] = dll_ptr;              // Save the page start position
          object_page_table_pos = src_ptr_2;           // Save place in table
          page_count = v13 + 1;
          v15 = object_table.virtual_size - (v14 - object_ptr[i + 1]);
          if ( v15 >= object_page_table.data_size )
          {
            read_size = object_page_table.data_size;
          }
          else
          {
            read_size = v15;
          }
          DLL_read(
            lx,
            LX_hdr.data_pages_off + (object_page_table.page_data_offset << SLOBYTE(LX_hdr.page_offset_shift)),
            flags,
            dll_ptr,
            read_size);
          dll_ptr += read_size;
          src_ptr_1 = object_page_table_pos;           // Restore place in table
        }
        src_ptr = object_table_pos;                    // Restore place in table
      }
      // Read fixup page table and perform fixups
      src_ptr_3 = DLL_read(lx, LX_hdr.fixup_page_table_off + LX_offset, flags, &page_offset, 4u);
      for ( k = 0; ; ++k )
      {
        if ( k >= LX_hdr.module_num_of_pages )
        {
          if ( (flags & 1) == 0 )
          {
            close(lx);
          }
          return dll;
        }
        v18 = DLL_read(lx, (ULONG)src_ptr_3, flags, &next_page_offset, 4u);
        src_ptr_3 = v18;
        if ( page_offset != next_page_offset )
        {
          break;
        }
LABEL_39:
        page_offset = next_page_offset;
      }
      // Read object page entries
      v36 = v18;
      src_ptr_8 = (void *)(LX_hdr.fixup_record_table_off + page_offset + LX_offset);
      while ( 1 )
      {
        src_ptr_4 = DLL_read(lx, (ULONG)src_ptr_8, flags, &src, 1u);
        src_ptr_5 = DLL_read(lx, (ULONG)src_ptr_4, flags, &fix_flags, 1u);
        if ( (src & 7) == 0 || (fix_flags & 4) != 0 && (fix_flags & 0x20) == 0 )
        {
          break;
        }
        if ( (src & 0x20) != 0 )
        {
          break;
        }
        src_ptr_6 = DLL_read(lx, (ULONG)src_ptr_5, flags, &srcoff, 2u);
        src_ptr_7 = DLL_read(lx, (ULONG)src_ptr_6, flags, &f_object, 1u);
        src_ptr_8 = DLL_read(lx, (ULONG)src_ptr_7, flags, &trgoff, 2u);
        // Perform fixup (if positive offset)
        if ( srcoff <= LX_hdr.page_size )
        {
          *(_DWORD *)&page_ptr[k][srcoff] = &object_ptr[f_object][trgoff];
        }
        if ( (unsigned int)src_ptr_8 >= LX_hdr.fixup_record_table_off + LX_offset + next_page_offset )
        {
          src_ptr_3 = v36;
          goto LABEL_39;
        }
      }
    }
    v6 = (flags & DLLSRC_MEM) == 0;
  }
  else
  {
    v6 = (flags & DLLSRC_MEM) == 0;
  }
  if ( v6 )
  {
    close(lx);
  }
  return 0;
}
// 664BC: variables would overlap: lvar "src" ^2C8.1(user-defined) and stkvar "src" ^2C8.4(has user info)
// 664BC: variables would overlap: lvar "f_object" ^2CC.1(user-defined) and stkvar "f_object" ^2CC.4(has user info)
// 664BC: variables would overlap: lvar "fix_flags" ^2D0.1(user-defined) and stkvar "fix_flags" ^2D0.16(has user info)

//----- (0006694A) --------------------------------------------------------
int __cdecl sub_6694A(char *path)
{
  int result; // eax
  int v2; // edx
  int v3; // ebx

  dword_987A8 = 0;
  result = open(path, 0x200);
  v2 = result;
  if ( result == 0xFFFFFFFF )
  {
    dword_987A8 = 3;
  }
  else
  {
    v3 = filelength(result);
    if ( v3 == 0xFFFFFFFF )
    {
      dword_987A8 = 5;
    }
    close(v2);
    return v3;
  }
  return result;
}
// 987A8: using guessed type int dword_987A8;

//----- (00066996) --------------------------------------------------------
void *__cdecl sub_66996(char *path, int a2)
{
  size_t v2; // eax
  unsigned int v3; // edi
  void *v5; // ecx
  int v6; // eax
  int v7; // esi

  dword_987A8 = 0;
  v2 = sub_6694A(path);
  v3 = v2;
  if ( v2 == 0xFFFFFFFF )
  {
    goto LABEL_2;
  }
  v5 = (void *)a2;
  if ( !a2 )
  {
    v5 = malloc(v2);
  }
  if ( !v5 )
  {
    dword_987A8 = 2;
    return 0;
  }
  v6 = open(path, O_BINARY);
  v7 = v6;
  if ( v6 == 0xFFFFFFFF )
  {
    off_987B0(v5);
LABEL_2:
    dword_987A8 = 3;
    return 0;
  }
  if ( read(v6, v5, v3) != v3 )
  {
    off_987B0(v5);
    dword_987A8 = 5;
    return 0;
  }
  close(v7);
  return v5;
}
// 987A8: using guessed type int dword_987A8;
// 987B0: using guessed type int (__fastcall *off_987B0)(_DWORD);

//----- (00066B05) --------------------------------------------------------
BOOL sub_66B05()
{
  BOOL result; // eax

  if ( !dword_987B4 )
  {
    sub_662D1((unsigned int)sub_66B05, (unsigned int)sub_6B984);
    sub_6635F((unsigned int)&dword_132CB8, 4);
    sub_6635F((unsigned int)&dword_132CBC, 4);
    sub_6635F((unsigned int)&fp, 4);
    sub_6635F((unsigned int)&dword_132C9C, 4);
    sub_6635F((unsigned int)&dword_132CAC, 4);
    sub_6635F((unsigned int)&dword_132CA8, 4);
    sub_6635F((unsigned int)&dword_132CB0, 4);
    result = sub_6635F((unsigned int)&dword_132CA0, 4);
    dword_987B4 = 1;
  }
  return result;
}
// 987B4: using guessed type int dword_987B4;
// 132C9C: using guessed type int dword_132C9C;
// 132CA0: using guessed type int dword_132CA0;
// 132CA8: using guessed type int dword_132CA8;
// 132CAC: using guessed type int dword_132CAC;
// 132CB0: using guessed type int dword_132CB0;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00066BAD) --------------------------------------------------------
int sub_66BAD()
{
  int result; // eax
  int v1; // ebx

  if ( (dword_132C9C != 0x63 || dword_132CAC != 0x3B || dword_132CAC != dword_132CA8 || dword_132C9C != dword_132CB0)
    && ++dword_132CB0 == 0x64 )
  {
    result = 0;
    dword_132CB0 = 0;
    v1 = ++dword_132CA8;
    if ( dword_132CA8 == 0x3C )
    {
      dword_132CA8 = 0;
      if ( v1 == ++dword_132CAC )
      {
        dword_132CAC = 0;
        ++dword_132C9C;
      }
    }
  }
  return result;
}
// 132C9C: using guessed type int dword_132C9C;
// 132CA8: using guessed type int dword_132CA8;
// 132CAC: using guessed type int dword_132CAC;
// 132CB0: using guessed type int dword_132CB0;

//----- (00066C19) --------------------------------------------------------
int sub_66C19()
{
  int v0; // ebp
  int v1; // edi
  int v2; // esi
  unsigned int i; // edx
  unsigned int j; // edx
  int v6; // [esp+0h] [ebp-1Ch]

  sub_741F4();
  v6 = dword_132C9C;
  v0 = dword_132CAC;
  v1 = dword_132CA8;
  v2 = dword_132CB0;
  sub_74201();
  if ( dword_132CA4 == 1 )
  {
    fprintf(fp, "[%.02u:%.02u:%.02u.%.02u] ", v6, v0, v1, v2);
  }
  else
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
  }
  for ( j = 1; j < dword_132CA4; ++j )
  {
    fprintf(fp, &byte_93C9D);
  }
  return 1;
}
// 132C9C: using guessed type int dword_132C9C;
// 132CA4: using guessed type int dword_132CA4;
// 132CA8: using guessed type int dword_132CA8;
// 132CAC: using guessed type int dword_132CAC;
// 132CB0: using guessed type int dword_132CB0;

//----- (00066CBF) --------------------------------------------------------
void __cdecl AIL_startup()
{
  const char *v0; // edx
  FILE *v1; // eax
  const char *v2; // ebx
  struct tm *v3; // eax
  char *v4; // eax
  unsigned __int16 v5; // dx
  int v6; // eax
  time_t v7; // [esp+0h] [ebp-10h] BYREF

  sub_66B05();
  LOWORD(v0) = 0;
  dword_132CB8 = 0;
  dword_132CBC = 0;
  v1 = (FILE *)getenv("AIL_DEBUG");
  v2 = (const char *)v1;
  if ( !v1 )
  {
    goto LABEL_2;
  }
  if ( getenv("AIL_SYS_DEBUG") )
  {
    dword_132CBC = 1;
  }
  v0 = "w+t";
  v1 = fopen(v2, "w+t");
  fp = v1;
  if ( v1 )
  {
    if ( isatty(v1->_handle) )
    {
      setbuf(fp, 0);
    }
    time(&v7);
    v3 = localtime(&v7);
    v4 = asctime(v3);
    v5 = (unsigned __int16)v4;
    strcpy(byte_132CC0, v4);
    byte_132CD8 = 0;
    fprintf(fp, "-------------------------------------------------------------------------------\n");
    fprintf(fp, "Audio Interface Library application usage script generated by AIL V%s\n", "3.02");
    fprintf(fp, "Start time: %s\n", byte_132CC0);
    v6 = fprintf(fp, "-------------------------------------------------------------------------------\n\n");
    sub_72042(v6, v5);
    dword_132C9C = 0;
    dword_132CAC = 0;
    dword_132CA8 = 0;
    dword_132CB0 = 0;
    dword_132CA0 = sub_749B6((int)sub_66BAD);
    sub_74B48(dword_132CA0, 0x64u);
    sub_74A70(dword_132CA0);
    dword_132CB8 = 1;
    dword_132CA4 = 1;
    sub_66C19();
    dword_132CA4 = 0;
    fprintf(fp, "AIL_startup()\n");
  }
  else
  {
LABEL_2:
    sub_72042((int)v1, (unsigned __int16)v0);
  }
}
// 132C9C: using guessed type int dword_132C9C;
// 132CA0: using guessed type int dword_132CA0;
// 132CA4: using guessed type int dword_132CA4;
// 132CA8: using guessed type int dword_132CA8;
// 132CAC: using guessed type int dword_132CAC;
// 132CB0: using guessed type int dword_132CB0;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;
// 132CD8: using guessed type char byte_132CD8;

//----- (00066E3B) --------------------------------------------------------
void __cdecl AIL_shutdown()
{
  int v0; // edx

  v0 = ++dword_132CA4;
  if ( dword_132CB8 && (v0 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_shutdown()\n");
  }
  sub_72148();
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    fclose(fp);
  }
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00066ECE) --------------------------------------------------------
LONG __cdecl AIL_set_preference(ULONG number, LONG value)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_preference(%d,%d)\n", number, value);
  }
  sub_71CE5(number, value);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67349);
  }
  JUMPOUT(0x67351);
}
// 66FC3: control flows out of bounds to 67349
// 66F4C: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00066FD2) --------------------------------------------------------
REALFAR __cdecl AIL_get_real_vect(ULONG vectnum)
{
  int v1; // ecx
  int v2; // ebx
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_get_real_vect(0x%X)\n", vectnum);
  }
  sub_74525(vectnum, v3, v2, v1);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67349);
  }
  JUMPOUT(0x67351);
}
// 68C4F: control flows out of bounds to 67349
// 67047: control flows out of bounds to 67351
// 67036: variable 'v2' is possibly undefined
// 67036: variable 'v1' is possibly undefined
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000670BD) --------------------------------------------------------
void __cdecl AIL_set_real_vect(ULONG vectnum, REALFAR real_ptr)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_real_vect(0x%X,0x%X)\n", vectnum, real_ptr);
  }
  sub_74551();
  JUMPOUT(0x6722B);
}
// 67131: control flows out of bounds to 6722B
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067136) --------------------------------------------------------
void __cdecl AIL_set_USE16_ISR(LONG IRQ, REALFAR real_base, ULONG ISR_offset)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_USE16_ISR(%d,0x%X,%u)\n", IRQ, real_base, ISR_offset);
  }
  sub_745CD(IRQ, real_base, ISR_offset);
  JUMPOUT(0x671B3);
}
// 671AE: control flows out of bounds to 671B3
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000671C0) --------------------------------------------------------
void __cdecl AIL_restore_USE16_ISR(LONG IRQ)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_restore_USE16_ISR(%d)\n", IRQ);
  }
  sub_747E3(IRQ);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067234) --------------------------------------------------------
// attributes: thunk
unsigned int sub_67234()
{
  unsigned int v0; // kr00_4
  unsigned int result; // eax

  v0 = __readeflags();
  result = v0;
  _disable();
  return result;
}

//----- (00067239) --------------------------------------------------------
void __cdecl sub_67239(unsigned int a1)
{
  sub_7482C(a1);
}

//----- (00067247) --------------------------------------------------------
LONG __cdecl AIL_call_driver(AIL_DRIVER *drvr, LONG fn, VDI_CALL *in, VDI_CALL *out)
{
  int v4; // edx
  int v6; // esi
  unsigned int i; // edx
  unsigned int j; // edx

  v4 = ++dword_132CA4;
  if ( dword_132CB8 && (v4 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_call_driver(0x%X,0x%X,0x%X,0x%X)\n", drvr, fn, in, out);
  }
  v6 = sub_74893((int)drvr, fn, in, out);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    fprintf(fp, "Result = %d\n", v6);
  }
  --dword_132CA4;
  return v6;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006735D) --------------------------------------------------------
void __cdecl AIL_delay(LONG intervals)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_delay(%d)\n", intervals);
  }
  sub_7496D(intervals);
  JUMPOUT(0x67228);
}
// 673C5: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000673CF) --------------------------------------------------------
LONG __cdecl AIL_read_INI(AIL_INI *INI, BYTE *filename)
{
  int v2; // edx
  LONG v4; // edi
  unsigned int i; // edx
  unsigned int j; // edx
  unsigned int k; // edx
  unsigned int m; // edx
  unsigned int n; // edx
  unsigned int ii; // edx
  unsigned int jj; // edx
  unsigned int kk; // edx
  unsigned int mm; // edx
  unsigned int nn; // edx
  unsigned int i1; // edx
  unsigned int i2; // edx
  unsigned int i3; // edx
  unsigned int i4; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_API_read_INI(0x%X,%s)\n", INI, filename);
  }
  v4 = sub_71A1D((int)INI, filename);
  if ( v4 )
  {
    if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
    {
      for ( i = 0; i < 0xE; ++i )
      {
        fprintf(fp, " ");
      }
      for ( j = 1; j < dword_132CA4; ++j )
      {
        fprintf(fp, &byte_93C9D);
      }
      fprintf(fp, "Driver = %s\n", INI->driver_name);
      for ( k = 0; k < 0xE; ++k )
      {
        fprintf(fp, " ");
      }
      for ( m = 1; m < dword_132CA4; ++m )
      {
        fprintf(fp, &byte_93C9D);
      }
      fprintf(fp, "Device = %s\n", INI->device_name);
      for ( n = 0; n < 0xE; ++n )
      {
        fprintf(fp, " ");
      }
      for ( ii = 1; ii < dword_132CA4; ++ii )
      {
        fprintf(fp, &byte_93C9D);
      }
      fprintf(fp, "IO     = %X\n", INI->IO.IO);
      for ( jj = 0; jj < 0xE; ++jj )
      {
        fprintf(fp, " ");
      }
      for ( kk = 1; kk < dword_132CA4; ++kk )
      {
        fprintf(fp, &byte_93C9D);
      }
      fprintf(fp, "IRQ    = %d\n", INI->IO.IRQ);
      for ( mm = 0; mm < 0xE; ++mm )
      {
        fprintf(fp, " ");
      }
      for ( nn = 1; nn < dword_132CA4; ++nn )
      {
        fprintf(fp, &byte_93C9D);
      }
      fprintf(fp, "DMA_8  = %d\n", INI->IO.DMA_8_bit);
      for ( i1 = 0; i1 < 0xE; ++i1 )
      {
        fprintf(fp, " ");
      }
      for ( i2 = 1; i2 < dword_132CA4; ++i2 )
      {
        fprintf(fp, &byte_93C9D);
      }
      fprintf(fp, "DMA_16 = %d\n", INI->IO.DMA_16_bit);
    }
  }
  else if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i3 = 0; i3 < 0xE; ++i3 )
    {
      fprintf(fp, " ");
    }
    for ( i4 = 1; i4 < dword_132CA4; ++i4 )
    {
      fprintf(fp, &byte_93C9D);
    }
    fprintf(fp, "Result = %u\n", 0);
  }
  --dword_132CA4;
  return v4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067728) --------------------------------------------------------
HTIMER __cdecl AIL_register_timer(CALLBACK callback_fn)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_timer(0x%X)\n", callback_fn);
  }
  sub_749B6((int)callback_fn);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67349);
  }
  JUMPOUT(0x67351);
}
// 68C4F: control flows out of bounds to 67349
// 6779D: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067813) --------------------------------------------------------
ULONG __cdecl AIL_set_timer_user(HTIMER timer, ULONG user)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_timer_user(%u,%u)\n", timer, user);
  }
  sub_749FD(timer, user);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x66FBC);
  }
  JUMPOUT(0x67351);
}
// 67901: control flows out of bounds to 66FBC
// 67891: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067906) --------------------------------------------------------
void __cdecl AIL_set_timer_period(HTIMER timer, ULONG microseconds)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_timer_period(%u,%u)\n", timer, microseconds);
  }
  sub_74B18(timer, microseconds);
  JUMPOUT(0x6712E);
}
// 67977: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006797C) --------------------------------------------------------
void __cdecl AIL_set_timer_frequency(HTIMER timer, ULONG hertz)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_timer_frequency(%u,%u)\n", timer, hertz);
  }
  sub_74B48(timer, hertz);
  JUMPOUT(0x6712E);
}
// 679ED: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000679F2) --------------------------------------------------------
void __cdecl AIL_set_timer_divisor(HTIMER timer, ULONG PIT_divisor)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_timer_divisor(%u,%u)\n", timer, PIT_divisor);
  }
  sub_74B78(timer, PIT_divisor);
  JUMPOUT(0x6712E);
}
// 67A63: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067A68) --------------------------------------------------------
ULONG __cdecl AIL_interrupt_divisor()
{
  int v0; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v0 = ++dword_132CA4;
  if ( dword_132CB8 && (v0 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_interrupt_divisor()\n");
  }
  sub_74BBA();
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67349);
  }
  JUMPOUT(0x67351);
}
// 685E9: control flows out of bounds to 67349
// 67AD0: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067B46) --------------------------------------------------------
void __cdecl AIL_start_timer(HTIMER timer)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_start_timer(%u)\n", timer);
  }
  sub_74A70(timer);
  JUMPOUT(0x67228);
}
// 67BAE: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067BB3) --------------------------------------------------------
void __cdecl AIL_start_all_timers()
{
  int v0; // edx

  v0 = ++dword_132CA4;
  if ( dword_132CB8 && (v0 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_start_all_timers()\n");
  }
  sub_74AA0();
  JUMPOUT(0x66EC6);
}
// 67C10: control flows out of bounds to 66EC6
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067C15) --------------------------------------------------------
void __cdecl AIL_stop_timer(HTIMER timer)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_stop_timer(%u)\n", timer);
  }
  sub_74AC4(timer);
  JUMPOUT(0x67228);
}
// 67C7D: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067C82) --------------------------------------------------------
void __cdecl AIL_stop_all_timers()
{
  int v0; // edx

  v0 = ++dword_132CA4;
  if ( dword_132CB8 && (v0 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_stop_all_timers()\n");
  }
  sub_74AF4();
  JUMPOUT(0x66EC6);
}
// 67CDF: control flows out of bounds to 66EC6
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067CE4) --------------------------------------------------------
void __cdecl AIL_release_timer_handle(HTIMER timer)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_release_timer_handle(%u)\n", timer);
  }
  sub_74A25(timer);
  JUMPOUT(0x67228);
}
// 67D4C: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067D51) --------------------------------------------------------
void __cdecl AIL_release_all_timers()
{
  int v0; // edx

  v0 = ++dword_132CA4;
  if ( dword_132CB8 && (v0 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_release_all_timers()\n");
  }
  sub_74A4C();
  JUMPOUT(0x66EC6);
}
// 67DAE: control flows out of bounds to 66EC6
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067DB3) --------------------------------------------------------
IO_PARMS *__cdecl AIL_get_IO_environment(AIL_DRIVER *drvr)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_get_IO_environment(0x%X)\n", drvr);
  }
  sub_71FD1((int)drvr);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x670B2);
  }
  JUMPOUT(0x67351);
}
// 67E93: control flows out of bounds to 670B2
// 67E28: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067E98) --------------------------------------------------------
AIL_DRIVER *__cdecl AIL_install_driver(UBYTE *driver_image, ULONG n_bytes)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_driver(0x%X,%u)\n", driver_image, n_bytes);
  }
  sub_71CFE(driver_image, n_bytes);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x66FBC);
  }
  JUMPOUT(0x67351);
}
// 67F86: control flows out of bounds to 66FBC
// 67F16: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067F8B) --------------------------------------------------------
void __cdecl AIL_uninstall_driver(AIL_DRIVER *drvr)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_uninstall_driver(0x%X)\n", drvr);
  }
  sub_71F2E(drvr);
  JUMPOUT(0x67228);
}
// 67FF3: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00067FF8) --------------------------------------------------------
LONG __cdecl AIL_install_DIG_INI()
{
  int v0; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v0 = ++dword_132CA4;
  if ( dword_132CB8 && (v0 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_DIG_INI()\n");
  }
  sub_6DE40();
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67349);
  }
  JUMPOUT(0x67351);
}
// 685E9: control flows out of bounds to 67349
// 68060: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000680D6) --------------------------------------------------------
HDIGDRIVER __cdecl AIL_install_DIG_driver_file(BYTE *filename, IO_PARMS *IO)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_DIG_driver_file(%s,0x%X)\n", filename, IO);
  }
  sub_6DD80(filename, (int)IO);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 681BE: control flows out of bounds to 67F80
// 68154: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000681C3) --------------------------------------------------------
void __cdecl AIL_uninstall_DIG_driver(HDIGDRIVER dig)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_uninstall_DIG_driver(0x%X)\n", dig);
  }
  sub_6DEA0(&dig->drvr);
  JUMPOUT(0x67228);
}
// 6822B: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068230) --------------------------------------------------------
HSAMPLE __cdecl AIL_allocate_sample_handle(HDIGDRIVER dig)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_allocate_sample_handle(0x%X)\n", dig);
  }
  sub_6DEE0((int)dig);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x670B2);
  }
  JUMPOUT(0x67351);
}
// 68310: control flows out of bounds to 670B2
// 682A5: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068315) --------------------------------------------------------
HSAMPLE __cdecl AIL_allocate_file_sample(HDIGDRIVER dig, void *file_image, LONG block)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_allocate_file_sample(0x%X,0x%X,%d)\n", dig, file_image, block);
  }
  sub_6C938((int)dig, (char *)file_image, block);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x680CB);
  }
  JUMPOUT(0x67351);
}
// 68409: control flows out of bounds to 680CB
// 6839E: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006840E) --------------------------------------------------------
void __cdecl AIL_release_sample_handle(HSAMPLE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_release_sample_handle(0x%X)\n", S);
  }
  sub_6DF50((int)S);
  JUMPOUT(0x67228);
}
// 68476: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006847B) --------------------------------------------------------
void __cdecl AIL_init_sample(HSAMPLE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_init_sample(0x%X)\n", S);
  }
  sub_6DF60((int *)S);
  JUMPOUT(0x67228);
}
// 684E3: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000684E8) --------------------------------------------------------
LONG __cdecl AIL_set_sample_file(HSAMPLE S, void *file_image, LONG block)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_file(0x%X,0x%X,%d)\n", S, file_image, block);
  }
  sub_6CA63((int)S, (char *)file_image, block);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x685DC);
  }
  JUMPOUT(0x67351);
}
// 685DA: control flows out of bounds to 685DC
// 68571: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000685EE) --------------------------------------------------------
void __cdecl AIL_set_sample_address(HSAMPLE S, void *start, ULONG len)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_address(0x%X,0x%X,%u)\n", S, start, len);
  }
  sub_6E020(S, (int)start, len);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068670) --------------------------------------------------------
void __cdecl AIL_set_sample_type(HSAMPLE S, LONG format, ULONG flags)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_type(0x%X,%d,%u)\n", S, format, flags);
  }
  sub_6E050((int)S, format, flags);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000686F2) --------------------------------------------------------
void __cdecl AIL_start_sample(HSAMPLE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_start_sample(0x%X)\n", S);
  }
  sub_6E170(S);
  JUMPOUT(0x67228);
}
// 6875A: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006875F) --------------------------------------------------------
void __cdecl AIL_stop_sample(HSAMPLE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_stop_sample(0x%X)\n", S);
  }
  sub_6E1F0((int)S);
  JUMPOUT(0x67228);
}
// 687C7: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000687CC) --------------------------------------------------------
void __cdecl AIL_resume_sample(HSAMPLE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_resume_sample(0x%X)\n", S);
  }
  sub_6E210((int)S);
  JUMPOUT(0x67228);
}
// 68834: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068839) --------------------------------------------------------
void __cdecl AIL_end_sample(HSAMPLE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_end_sample(0x%X)\n", S);
  }
  sub_6E230((int)S);
  JUMPOUT(0x67228);
}
// 688A1: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000688A6) --------------------------------------------------------
void __cdecl AIL_set_sample_playback_rate(HSAMPLE S, LONG playback_rate)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_playback_rate(0x%X,%d)\n", S, playback_rate);
  }
  sub_6E090((int)S, playback_rate);
  JUMPOUT(0x6712E);
}
// 68917: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006891C) --------------------------------------------------------
void __cdecl AIL_set_sample_volume(HSAMPLE S, LONG volume)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_volume(0x%X,%d)\n", S, volume);
  }
  sub_6E0B0((int)S, volume);
  JUMPOUT(0x6712E);
}
// 6898D: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068992) --------------------------------------------------------
void __cdecl AIL_set_sample_pan(HSAMPLE S, LONG pan)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_pan(0x%X,%d)\n", S, pan);
  }
  sub_6E0E0((int)S, pan);
  JUMPOUT(0x6712E);
}
// 68A03: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068A08) --------------------------------------------------------
void __cdecl AIL_set_sample_loop_count(HSAMPLE S, LONG loop_count)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_loop_count(0x%X,%d)\n", S, loop_count);
  }
  sub_6E160((int)S, loop_count);
  JUMPOUT(0x6712E);
}
// 68A79: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068A7E) --------------------------------------------------------
ULONG __cdecl AIL_sample_status(HSAMPLE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_status(0x%X)\n", S);
  }
  sub_6E010((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67808);
  }
  JUMPOUT(0x67351);
}
// 68B5E: control flows out of bounds to 67808
// 68AF3: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068B63) --------------------------------------------------------
LONG __cdecl AIL_sample_playback_rate(HSAMPLE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_playback_rate(0x%X)\n", S);
  }
  sub_6E080((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C43);
  }
  JUMPOUT(0x67351);
}
// 68C41: control flows out of bounds to 68C43
// 68BD8: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068C54) --------------------------------------------------------
LONG __cdecl AIL_sample_volume(HSAMPLE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_volume(0x%X)\n", S);
  }
  sub_6E0A0((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 68CC9: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068D39) --------------------------------------------------------
LONG __cdecl AIL_sample_pan(HSAMPLE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_pan(0x%X)\n", S);
  }
  sub_6E0D0((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 68DAE: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068E1E) --------------------------------------------------------
LONG __cdecl AIL_sample_loop_count(HSAMPLE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_loop_count(0x%X)\n", S);
  }
  sub_6E140((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 68E93: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068F03) --------------------------------------------------------
HDIGDRIVER __cdecl AIL_install_DIG_driver_image(void *driver_image, ULONG size, IO_PARMS *IO)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_DIG_driver_image(0x%X,%u,0x%X)\n", driver_image, size, IO);
  }
  sub_6DE00(driver_image, size, (int)IO);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x680CB);
  }
  JUMPOUT(0x67351);
}
// 68FF7: control flows out of bounds to 680CB
// 68F8C: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00068FFC) --------------------------------------------------------
LONG __cdecl AIL_minimum_sample_buffer_size(HDIGDRIVER dig, LONG playback_rate, LONG format)
{
  FILE *v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = (FILE *)++dword_132CA4;
  if ( dword_132CB8 && (v3 == (FILE *)1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    v3 = fp;
    fprintf(fp, "AIL_minimum_sample_buffer_size(0x%X,%d,%d)\n", dig, playback_rate, format);
  }
  sub_6E330((int)v3, dig, playback_rate, format);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x685E2);
  }
  JUMPOUT(0x67351);
}
// 685DD: control flows out of bounds to 685E2
// 69085: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000690F5) --------------------------------------------------------
LONG __cdecl AIL_sample_buffer_ready(HSAMPLE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_buffer_ready(0x%X)\n", S);
  }
  sub_6E460(S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 6916A: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000691DA) --------------------------------------------------------
void __cdecl AIL_load_sample_buffer(HSAMPLE S, ULONG buff_num, void *buffer, ULONG len)
{
  int v4; // edx

  v4 = ++dword_132CA4;
  if ( dword_132CB8 && (v4 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_load_sample_buffer(0x%X,%u,0x%X,%u)\n", S, buff_num, buffer, len);
  }
  sub_6E3D0(S, buff_num, (int)buffer, len);
  JUMPOUT(0x671B6);
}
// 69264: control flows out of bounds to 671B6
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069269) --------------------------------------------------------
void __cdecl AIL_set_sample_position(HSAMPLE S, ULONG pos)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_position(0x%X,%u)\n", S, pos);
  }
  sub_6E120((int)S, pos);
  JUMPOUT(0x6712E);
}
// 692DA: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000692DF) --------------------------------------------------------
ULONG __cdecl AIL_sample_position(HSAMPLE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_position(0x%X)\n", S);
  }
  sub_6E100((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67808);
  }
  JUMPOUT(0x67351);
}
// 693BF: control flows out of bounds to 67808
// 69354: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000693C4) --------------------------------------------------------
CALLBACK __cdecl AIL_register_SOB_callback(HSAMPLE S, CALLBACK SOB)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_SOB_callback(0x%X,0x%X)\n", S, SOB);
  }
  sub_6E280((int)S, (int)SOB);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 694AC: control flows out of bounds to 67F80
// 69442: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000694B1) --------------------------------------------------------
CALLBACK __cdecl AIL_register_EOB_callback(HSAMPLE S, CALLBACK EOB)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_EOB_callback(0x%X,0x%X)\n", S, EOB);
  }
  sub_6E2A0((int)S, (int)EOB);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 69599: control flows out of bounds to 67F80
// 6952F: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006959E) --------------------------------------------------------
CALLBACK __cdecl AIL_register_EOS_callback(HSAMPLE S, CALLBACK EOS)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_EOS_callback(0x%X,0x%X)\n", S, EOS);
  }
  sub_6E2C0((int)S, (int)EOS);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 69686: control flows out of bounds to 67F80
// 6961C: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006968B) --------------------------------------------------------
CALLBACK __cdecl AIL_register_EOF_callback(HSAMPLE S, CALLBACK EOFILE)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_EOF_callback(0x%X,0x%X)\n", S, EOFILE);
  }
  sub_6CB3B((int)S, (int)EOFILE);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 69773: control flows out of bounds to 67F80
// 69709: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069778) --------------------------------------------------------
void __cdecl AIL_set_sample_user_data(HSAMPLE S, ULONG index, LONG value)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sample_user_data(0x%X,%u,%d)\n", S, index, value);
  }
  sub_6E2E0((int)S, index, value);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000697FA) --------------------------------------------------------
LONG __cdecl AIL_sample_user_data(HSAMPLE S, ULONG index)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sample_user_data(0x%X,%u)\n", S, index);
  }
  sub_6E300((int)S, index);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x66FB6);
  }
  JUMPOUT(0x67351);
}
// 698E2: control flows out of bounds to 66FB6
// 69878: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000698E7) --------------------------------------------------------
LONG __cdecl AIL_active_sample_count(HDIGDRIVER dig)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_active_sample_count(0x%X)\n", dig);
  }
  sub_6DEB0((int)dig);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 6995C: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (000699CC) --------------------------------------------------------
LONG __cdecl AIL_install_MDI_INI()
{
  int v0; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v0 = ++dword_132CA4;
  if ( dword_132CB8 && (v0 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_MDI_INI()\n");
  }
  sub_70690();
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x680CB);
  }
  JUMPOUT(0x67351);
}
// 69A9F: control flows out of bounds to 680CB
// 69A34: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069AA4) --------------------------------------------------------
HMDIDRIVER __cdecl AIL_install_MDI_driver_file(BYTE *filename, IO_PARMS *IO)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_MDI_driver_file(%s,0x%X)\n", filename, IO);
  }
  sub_705D0(filename, (int)IO);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 69B8C: control flows out of bounds to 67F80
// 69B22: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069B91) --------------------------------------------------------
void __cdecl AIL_uninstall_MDI_driver(HMDIDRIVER mdi)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_uninstall_MDI_driver(0x%X)\n", mdi);
  }
  sub_706F0(&mdi->drvr);
  JUMPOUT(0x67228);
}
// 69BF9: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069BFE) --------------------------------------------------------
HSEQUENCE __cdecl AIL_allocate_sequence_handle(HMDIDRIVER mdi)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_allocate_sequence_handle(0x%X)\n", mdi);
  }
  sub_70780((int)mdi);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x670B2);
  }
  JUMPOUT(0x67351);
}
// 69CDE: control flows out of bounds to 670B2
// 69C73: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069CE3) --------------------------------------------------------
void __cdecl AIL_release_sequence_handle(HSEQUENCE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_release_sequence_handle(0x%X)\n", S);
  }
  sub_70800(S);
  JUMPOUT(0x67228);
}
// 69D4B: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069D50) --------------------------------------------------------
LONG __cdecl AIL_init_sequence(HSEQUENCE S, void *start, LONG sequence_num)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_init_sequence(0x%X,0x%X,%d)\n", S, start, sequence_num);
  }
  sub_70820((AIL_DRIVER ***)S, (int)start, sequence_num);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x685E2);
  }
  JUMPOUT(0x67351);
}
// 685DD: control flows out of bounds to 685E2
// 69DD9: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069E49) --------------------------------------------------------
void __cdecl AIL_start_sequence(HSEQUENCE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_start_sequence(0x%X)\n", S);
  }
  sub_70BD0(S);
  JUMPOUT(0x67228);
}
// 69EB1: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069EB6) --------------------------------------------------------
void __cdecl AIL_stop_sequence(HSEQUENCE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_stop_sequence(0x%X)\n", S);
  }
  sub_70C10(S);
  JUMPOUT(0x67228);
}
// 69F1E: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069F23) --------------------------------------------------------
void __cdecl AIL_resume_sequence(HSEQUENCE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_resume_sequence(0x%X)\n", S);
  }
  sub_70CE0(S);
  JUMPOUT(0x67228);
}
// 69F8B: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069F90) --------------------------------------------------------
void __cdecl AIL_end_sequence(HSEQUENCE S)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_end_sequence(0x%X)\n", S);
  }
  sub_70D70(S);
  JUMPOUT(0x67228);
}
// 69FF8: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (00069FFD) --------------------------------------------------------
void __cdecl AIL_set_sequence_tempo(HSEQUENCE S, LONG tempo, LONG milliseconds)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sequence_tempo(0x%X,%d,%d)\n", S, tempo, milliseconds);
  }
  sub_70DB0(S, tempo, milliseconds);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A07F) --------------------------------------------------------
void __cdecl AIL_set_sequence_volume(HSEQUENCE S, LONG volume, LONG milliseconds)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sequence_volume(0x%X,%d,%d)\n", S, volume, milliseconds);
  }
  sub_70E20(S, volume, milliseconds);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A101) --------------------------------------------------------
void __cdecl AIL_set_sequence_loop_count(HSEQUENCE S, LONG loop_count)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sequence_loop_count(0x%X,%d)\n", S, loop_count);
  }
  sub_70DA0((int)S, loop_count);
  JUMPOUT(0x6712E);
}
// 6A172: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A177) --------------------------------------------------------
ULONG __cdecl AIL_sequence_status(HSEQUENCE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sequence_status(0x%X)\n", S);
  }
  sub_70EA0((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67808);
  }
  JUMPOUT(0x67351);
}
// 6A257: control flows out of bounds to 67808
// 6A1EC: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A25C) --------------------------------------------------------
LONG __cdecl AIL_sequence_tempo(HSEQUENCE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sequence_tempo(0x%X)\n", S);
  }
  sub_70ED0((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 6A2D1: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A341) --------------------------------------------------------
LONG __cdecl AIL_sequence_volume(HSEQUENCE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sequence_volume(0x%X)\n", S);
  }
  sub_70EE0((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 6A3B6: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A426) --------------------------------------------------------
LONG __cdecl AIL_sequence_loop_count(HSEQUENCE S)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sequence_loop_count(0x%X)\n", S);
  }
  sub_70EB0((int)S);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 6A49B: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A50B) --------------------------------------------------------
HMDIDRIVER __cdecl AIL_install_MDI_driver_image(void *driver_image, ULONG size, IO_PARMS *IO)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_MDI_driver_image(0x%X,%u,0x%X)\n", driver_image, size, IO);
  }
  sub_70650(driver_image, size, (int)IO);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x680CB);
  }
  JUMPOUT(0x67351);
}
// 6A5FF: control flows out of bounds to 680CB
// 6A594: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A604) --------------------------------------------------------
void __cdecl AIL_set_GTL_filename_prefix(BYTE *prefix)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_GTL_filename_prefix(%s)\n", prefix);
  }
  sub_70700(prefix);
  JUMPOUT(0x67228);
}
// 6A66C: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A671) --------------------------------------------------------
LONG __cdecl AIL_timbre_status(HMDIDRIVER mdi, LONG bank, LONG patch)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_timbre_status(0x%X,%d,%d)\n", mdi, bank, patch);
  }
  sub_70EF0(&mdi->drvr, bank, patch);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x685E2);
  }
  JUMPOUT(0x67351);
}
// 685DD: control flows out of bounds to 685E2
// 6A6FA: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A76A) --------------------------------------------------------
LONG __cdecl AIL_install_timbre(HMDIDRIVER mdi, LONG bank, LONG patch)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_install_timbre(0x%X,%d,%d)\n", mdi, bank, patch);
  }
  sub_70F30((int)mdi, bank, patch);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x685E2);
  }
  JUMPOUT(0x67351);
}
// 685DD: control flows out of bounds to 685E2
// 6A7F3: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A863) --------------------------------------------------------
void __cdecl AIL_protect_timbre(HMDIDRIVER mdi, LONG bank, LONG patch)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_protect_timbre(0x%X,%d,%d)\n", mdi, bank, patch);
  }
  sub_71030(&mdi->drvr, bank, patch);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A8E5) --------------------------------------------------------
void __cdecl AIL_unprotect_timbre(HMDIDRIVER mdi, LONG bank, LONG patch)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_unprotect_timbre(0x%X,%d,%d)\n", mdi, bank, patch);
  }
  sub_71070(&mdi->drvr, bank, patch);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006A967) --------------------------------------------------------
LONG __cdecl AIL_active_sequence_count(HMDIDRIVER mdi)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_active_sequence_count(0x%X)\n", mdi);
  }
  sub_710B0((int)mdi);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 6A9DC: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006AA4C) --------------------------------------------------------
LONG __cdecl AIL_controller_value(HSEQUENCE S, LONG channel, LONG controller_num)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_controller_value(0x%X,%d,%d)\n", S, channel, controller_num);
  }
  sub_710E0((int)S, channel, controller_num);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x685E2);
  }
  JUMPOUT(0x67351);
}
// 685DD: control flows out of bounds to 685E2
// 6AAD5: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006AB45) --------------------------------------------------------
LONG __cdecl AIL_channel_notes(HSEQUENCE S, LONG channel)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_channel_notes(0x%X,%d)\n", S, channel);
  }
  sub_71110((int)S, channel);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x66FB6);
  }
  JUMPOUT(0x67351);
}
// 6AC2D: control flows out of bounds to 66FB6
// 6ABC3: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006AC32) --------------------------------------------------------
void __cdecl AIL_sequence_position(HSEQUENCE S, LONG *beat, LONG *measure)
{
  int v3; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sequence_position(0x%X,0x%X,0x%X)\n", S, beat, measure);
  }
  sub_71150(S, beat, measure);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    fprintf(fp, "Result = %d:%d\n", *measure + 1, *beat + 1);
    JUMPOUT(0x69261);
  }
  JUMPOUT(0x671B6);
}
// 6AD35: control flows out of bounds to 69261
// 6ACB1: control flows out of bounds to 671B6
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006AD3A) --------------------------------------------------------
void __cdecl AIL_branch_index(HSEQUENCE S, ULONG marker)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_branch_index(0x%X,%u)\n", S, marker);
  }
  sub_711C0(S, marker);
  JUMPOUT(0x6712E);
}
// 6ADAB: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006ADB0) --------------------------------------------------------
CALLBACK __cdecl AIL_register_prefix_callback(HSEQUENCE S, CALLBACK callback)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_prefix_callback(0x%X,0x%X)\n", S, callback);
  }
  sub_71250((int)S, (int)callback);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 6AE98: control flows out of bounds to 67F80
// 6AE2E: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006AE9D) --------------------------------------------------------
CALLBACK __cdecl AIL_register_trigger_callback(HSEQUENCE S, CALLBACK callback)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_trigger_callback(0x%X,0x%X)\n", S, callback);
  }
  sub_71270((int)S, (int)callback);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 6AF85: control flows out of bounds to 67F80
// 6AF1B: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006AF8A) --------------------------------------------------------
CALLBACK __cdecl AIL_register_sequence_callback(HSEQUENCE S, CALLBACK callback)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_sequence_callback(0x%X,0x%X)\n", S, callback);
  }
  sub_71290((int)S, (int)callback);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 6B072: control flows out of bounds to 67F80
// 6B008: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B077) --------------------------------------------------------
CALLBACK __cdecl AIL_register_event_callback(HMDIDRIVER mdi, CALLBACK callback)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_event_callback(0x%X,0x%X)\n", mdi, callback);
  }
  sub_712B0((int)mdi, (int)callback);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 6B15F: control flows out of bounds to 67F80
// 6B0F5: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B164) --------------------------------------------------------
CALLBACK __cdecl AIL_register_timbre_callback(HMDIDRIVER mdi, CALLBACK callback)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_timbre_callback(0x%X,0x%X)\n", mdi, callback);
  }
  sub_712D0((int)mdi, (int)callback);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67F80);
  }
  JUMPOUT(0x67351);
}
// 6B24C: control flows out of bounds to 67F80
// 6B1E2: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B251) --------------------------------------------------------
void __cdecl AIL_set_sequence_user_data(HSEQUENCE S, ULONG index, LONG value)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_set_sequence_user_data(0x%X,%u,%d)\n", S, index, value);
  }
  sub_712F0((int)S, index, value);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B2D3) --------------------------------------------------------
LONG __cdecl AIL_sequence_user_data(HSEQUENCE S, ULONG index)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_sequence_user_data(0x%X,%u)\n", S, index);
  }
  sub_71310((int)S, index);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x66FB6);
  }
  JUMPOUT(0x67351);
}
// 6B3BB: control flows out of bounds to 66FB6
// 6B351: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B3C0) --------------------------------------------------------
void __cdecl AIL_register_ICA_array(HSEQUENCE S, BYTE *array)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_register_ICA_array(0x%X,0x%X)\n", S, array);
  }
  sub_71330((int)S, (int)array);
  JUMPOUT(0x6712E);
}
// 6B431: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B436) --------------------------------------------------------
LONG __cdecl AIL_lock_channel(HMDIDRIVER mdi)
{
  int v1; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_lock_channel(0x%X)\n", mdi);
  }
  sub_71340(mdi);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x68C49);
  }
  JUMPOUT(0x67351);
}
// 68C44: control flows out of bounds to 68C49
// 6B4AB: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B51B) --------------------------------------------------------
void __cdecl AIL_release_channel(HMDIDRIVER mdi, LONG channel)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_release_channel(0x%X,%d)\n", mdi, channel);
  }
  sub_714E0(mdi, channel);
  JUMPOUT(0x6712E);
}
// 6B58C: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B591) --------------------------------------------------------
void __cdecl AIL_map_sequence_channel(HSEQUENCE S, LONG seq_channel, LONG new_channel)
{
  int v3; // edx

  v3 = ++dword_132CA4;
  if ( dword_132CB8 && (v3 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_map_sequence_channel(0x%X,%d,%d)\n", S, seq_channel, new_channel);
  }
  sub_71610(S, seq_channel, new_channel);
  --dword_132CA4;
}
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B613) --------------------------------------------------------
LONG __cdecl AIL_true_sequence_channel(HSEQUENCE S, LONG seq_channel)
{
  int v2; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_true_sequence_channel(0x%X,%d)\n", S, seq_channel);
  }
  sub_71650((int)S, seq_channel);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x66FB6);
  }
  JUMPOUT(0x67351);
}
// 6B6FB: control flows out of bounds to 66FB6
// 6B691: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B700) --------------------------------------------------------
void __cdecl AIL_send_channel_voice_message(HMDIDRIVER mdi, HSEQUENCE S, LONG status, LONG data_1, LONG data_2)
{
  int v5; // edx

  v5 = ++dword_132CA4;
  if ( dword_132CB8 && (v5 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_send_channel_voice_message(0x%X,0x%X,0x%X,0x%X,0x%X)\n", mdi, S, status, data_1, data_2);
  }
  sub_71670((int)mdi, S, status, data_1, data_2);
  JUMPOUT(0x671B6);
}
// 6B794: control flows out of bounds to 671B6
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B799) --------------------------------------------------------
void __cdecl AIL_send_sysex_message(HMDIDRIVER mdi, void *buffer)
{
  int v2; // edx

  v2 = ++dword_132CA4;
  if ( dword_132CB8 && (v2 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_send_sysex_message(0x%X,0x%X)\n", mdi, buffer);
  }
  sub_71720(mdi, buffer);
  JUMPOUT(0x6712E);
}
// 6B80A: control flows out of bounds to 6712E
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B80F) --------------------------------------------------------
HWAVE __cdecl AIL_create_wave_synthesizer(HDIGDRIVER dig, HMDIDRIVER mdi, void *wave_lib, LONG polyphony)
{
  int v4; // edx
  unsigned int i; // edx
  unsigned int j; // edx

  v4 = ++dword_132CA4;
  if ( dword_132CB8 && (v4 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_create_wave_synthesizer(0x%X,0x%X,0x%X,%d)\n", dig, mdi, wave_lib, polyphony);
  }
  sub_6C347((int)dig, mdi, (int)wave_lib, polyphony);
  if ( dword_132CB8 && (dword_132CA4 == 1 || dword_132CBC) && !sub_749AA() )
  {
    for ( i = 0; i < 0xE; ++i )
    {
      fprintf(fp, " ");
    }
    for ( j = 1; j < dword_132CA4; ++j )
    {
      fprintf(fp, &byte_93C9D);
    }
    JUMPOUT(0x67342);
  }
  JUMPOUT(0x67351);
}
// 6B912: control flows out of bounds to 67342
// 6B8A2: control flows out of bounds to 67351
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B917) --------------------------------------------------------
void __cdecl AIL_destroy_wave_synthesizer(HWAVE W)
{
  int v1; // edx

  v1 = ++dword_132CA4;
  if ( dword_132CB8 && (v1 == 1 || dword_132CBC) && !sub_749AA() && sub_66C19() )
  {
    fprintf(fp, "AIL_destroy_wave_synthesizer(0x%X)\n", W);
  }
  sub_6C4BF(W);
  JUMPOUT(0x67228);
}
// 6B97F: control flows out of bounds to 67228
// 132CA4: using guessed type int dword_132CA4;
// 132CB8: using guessed type int dword_132CB8;
// 132CBC: using guessed type int dword_132CBC;

//----- (0006B984) --------------------------------------------------------
void sub_6B984()
{
  if ( dword_987B4 )
  {
    sub_6633A();
    dword_987B4 = 0;
  }
}
// 987B4: using guessed type int dword_987B4;

//----- (0006BBAE) --------------------------------------------------------
BOOL sub_6BBAE()
{
  BOOL result; // eax

  if ( !dword_987B8 )
  {
    result = sub_662D1((unsigned int)sub_6BBAE, (unsigned int)sub_6C513);
    dword_987B8 = 1;
  }
  return result;
}
// 987B8: using guessed type int dword_987B8;

//----- (0006BBDA) --------------------------------------------------------
_DWORD *__cdecl sub_6BBDA(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
  unsigned int v4; // esi
  int v5; // ecx
  _DWORD *result; // eax

  v4 = a2 & 0xF0;
  v5 = a2 & 0xF;
  result = (_DWORD *)(a1 + 4 * v5);
  if ( v4 < 0xC0 )
  {
    if ( v4 == 0xB0 )
    {
      if ( a3 < 0x5B )
      {
        if ( a3 < 7 )
        {
          if ( a3 )
          {
            if ( a3 <= 1 )
            {
              result = (_DWORD *)a4;
              *(_DWORD *)(a1 + 4 * v5 + 0x240) = a4;
            }
            else if ( a3 == 6 )
            {
              result = (_DWORD *)a4;
              *(_DWORD *)(a1 + 4 * v5 + 0x400) = a4;
            }
          }
        }
        else if ( a3 <= 7 )
        {
          result = (_DWORD *)a4;
          *(_DWORD *)(a1 + 4 * v5 + 0x280) = a4;
        }
        else if ( a3 < 0xB )
        {
          if ( a3 == 0xA )
          {
            result = (_DWORD *)a4;
            *(_DWORD *)(a1 + 4 * v5 + 0x2C0) = a4;
          }
        }
        else if ( a3 <= 0xB )
        {
          result = (_DWORD *)a4;
          *(_DWORD *)(a1 + 4 * v5 + 0x300) = a4;
        }
        else if ( a3 == 0x40 )
        {
          result[0xD0] = a4;
        }
      }
      else if ( a3 <= 0x5B )
      {
        result[0xE0] = a4;
      }
      else if ( a3 < 0x70 )
      {
        if ( a3 < 0x6E )
        {
          if ( a3 == 0x5D )
          {
            result[0xF0] = a4;
          }
        }
        else if ( a3 <= 0x6E )
        {
          result[0x30] = a4;
        }
        else
        {
          result[0x40] = a4;
        }
      }
      else if ( a3 <= 0x70 )
      {
        result[0x50] = a4;
      }
      else if ( a3 < 0x73 )
      {
        if ( a3 == 0x72 )
        {
          result[0x60] = a4;
        }
      }
      else if ( a3 <= 0x73 )
      {
        result[0x70] = a4;
      }
      else if ( a3 == 0x77 )
      {
        result[0x80] = a4;
      }
    }
  }
  else if ( v4 <= 0xC0 )
  {
    *result = (unsigned __int8)a3;
  }
  else if ( v4 == 0xE0 )
  {
    result[0x10] = (unsigned __int8)a3;
    result[0x20] = a4;
  }
  return result;
}

//----- (0006BD8F) --------------------------------------------------------
_DWORD *__fastcall sub_6BD8F(_DWORD *result, int a2, int a3)
{
  int i; // edx

  for ( i = 0; i < 0x200 && *result != 0xFFFFFFFF; ++i )
  {
    if ( a2 == *result && a3 == result[1] )
    {
      return result;
    }
    result += 8;
  }
  return 0;
}

//----- (0006BDB8) --------------------------------------------------------
void __fastcall sub_6BDB8(int a1, int a2)
{
  int v2; // esi
  _DWORD *v3; // edi

  v2 = a1 + 4 * a2;
  v3 = (_DWORD *)(a1 + 4 * *(_DWORD *)(v2 + 0x4D8));
  AIL_set_sample_volume(*(HSAMPLE *)(v2 + 0x494), v3[0xC5] * v3[0xA5] / 0x7F * *(_DWORD *)(v2 + 0x5D8) / 0x7F);
  AIL_set_sample_pan(*(HSAMPLE *)(v2 + 0x494), v3[0xB5]);
}

//----- (0006BE24) --------------------------------------------------------
void __fastcall sub_6BE24(int a1, int a2)
{
  int v4; // ebx
  int v5; // eax
  unsigned int v6; // edx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // ebp
  int v12; // eax
  int v13; // edx
  __int64 v14; // rtt
  int v15; // [esp+0h] [ebp-24h]
  int v16; // [esp+8h] [ebp-1Ch]
  int v17; // [esp+Ch] [ebp-18h]

  v17 = *(_DWORD *)(a1 + 4 * a2 + 0x4D8);
  v15 = *(_DWORD *)(a1 + 4 * a2 + 0x558);
  v4 = *(_DWORD *)(a1 + 4 * a2 + 0x598);
  v16 = *(_DWORD *)(a1 + 4 * a2 + 0x518);
  v5 = (*(_DWORD *)(a1 + 4 * v17 + 0x94) << 7) | *(_DWORD *)(a1 + 4 * v17 + 0x54);
  if ( v5 <= 0x2000 )
  {
    if ( v5 >= 0x2000 )
    {
      v7 = 0;
      v6 = 0;
    }
    else
    {
      v7 = 0x2000 - v5;
      v6 = 0xFFFFFFFF;
    }
  }
  else
  {
    v6 = 1;
    v7 = v5 - 0x1FFF;
  }
  v8 = v16 + *(_DWORD *)(a1 + 4 * v17 + 0x414) * v6;
  if ( v8 < 0 )
  {
    v8 = 0;
  }
  if ( v8 > 0x7F )
  {
    v8 = 0x7F;
  }
  v9 = dword_6B9AE[v16];
  v10 = v7 * (dword_6B9AE[v8] - v9);
  v11 = v9 + ((v10 - (__CFSHL__(v10 >> 0x1F, 0xD) + (v10 >> 0x1F << 0xD))) >> 0xD);
  if ( v17 == 9 )
  {
    v13 = v11 * v4;
    v12 = v11 * v4;
  }
  else
  {
    v12 = v11 * (v9 * v4 / dword_6B9AE[v15]);
    v13 = v12;
  }
  LODWORD(v14) = v12;
  HIDWORD(v14) = v13 >> 0x1F;
  AIL_set_sample_playback_rate(*(HSAMPLE *)(a1 + 4 * a2 + 0x494), v14 / v9);
  JUMPOUT(0x6BE1E);
}
// 6BF29: control flows out of bounds to 6BE1E
// 6B9AE: using guessed type int dword_6B9AE[];

//----- (0006C347) --------------------------------------------------------
_DWORD *__cdecl sub_6C347(int a1, HMDIDRIVER mdi, int a3, int a4)
{
  _DWORD *result; // eax
  LONG v5; // ebp
  _DWORD *v6; // esi
  int i; // ecx
  int v8; // eax
  int v9; // eax
  int j; // ecx
  int k; // ecx

  sub_6BBAE();
  result = sub_661DE(0x65Cu);
  v5 = (LONG)result;
  v6 = result;
  if ( result )
  {
    result[1] = a1;
    *result = mdi;
    result[2] = a3;
    result[3] = AIL_register_event_callback(mdi, sub_6BF53);
    *(_DWORD *)(v5 + 0x10) = AIL_register_timbre_callback(mdi, sub_6BF2E);
    mdi->master_volume = v5;
    for ( i = 0; i < 0x10; ++i )
    {
      v6[i + 5] = 0;
      v6[i + 0x15] = 0;
      v6[i + 0x25] = 0x40;
      v6[i + 0x65] = 0;
      v6[i + 0xA5] = 0x7F;
      v6[i + 0xB5] = 0x40;
      v6[i + 0xC5] = 0x7F;
      v6[i + 0x105] = dword_1330AC;
    }
    for ( v6[0x135] = 0; ; v6[0x135] = v8 + 1 )
    {
      v9 = a4 <= 0x10 ? a4 : 0x10;
      if ( v9 <= v6[0x135] )
      {
        break;
      }
      v6[v6[0x135] + 0x125] = AIL_allocate_sample_handle((HDIGDRIVER)v6[1]);
      v8 = v6[0x135];
      if ( !v6[v8 + 0x125] )
      {
        break;
      }
    }
    for ( j = 0; j < 0x10; ++j )
    {
      v6[j + 0x115] = 0;
    }
    for ( k = 0; k < v6[0x135]; ++k )
    {
      v6[k + 0x136] = 0xFFFFFFFF;
    }
    v6[0x196] = 0;
    return v6;
  }
  else
  {
    strcpy(&byte_132F70, "Insufficient memory for HWAVE descriptor\n");
  }
  return result;
}
// 6BF2E: using guessed type int sub_6BF2E();
// 6BF53: using guessed type int sub_6BF53();
// 1330AC: using guessed type int dword_1330AC;

//----- (0006C4BF) --------------------------------------------------------
int __cdecl sub_6C4BF(void *ptr)
{
  int i; // esi

  for ( i = 0; i < *((_DWORD *)ptr + 0x135); ++i )
  {
    AIL_release_sample_handle(*((HSAMPLE *)ptr + i + 0x125));
  }
  AIL_register_event_callback(*(HMDIDRIVER *)ptr, *((CALLBACK *)ptr + 3));
  AIL_register_timbre_callback(*(HMDIDRIVER *)ptr, *((CALLBACK *)ptr + 4));
  return sub_661FF(ptr);
}

//----- (0006C513) --------------------------------------------------------
void sub_6C513()
{
  if ( dword_987B8 )
  {
    sub_6633A();
    dword_987B8 = 0;
  }
}
// 987B8: using guessed type int dword_987B8;

//----- (0006C53D) --------------------------------------------------------
BOOL sub_6C53D()
{
  BOOL result; // eax

  if ( !dword_987BC )
  {
    result = sub_662D1((unsigned int)sub_6C53D, (unsigned int)sub_6CB57);
    dword_987BC = 1;
  }
  return result;
}
// 987BC: using guessed type int dword_987BC;

//----- (0006C569) --------------------------------------------------------
int __cdecl sub_6C569(_DWORD *a1)
{
  return *a1 >> 8;
}

//----- (0006C573) --------------------------------------------------------
void __cdecl sub_6C573(HSAMPLE S)
{
  if ( S->system_data[0] )
  {
    ((void (__cdecl *)(HSAMPLE))S->system_data[0])(S);
  }
  if ( S->system_data[6] > 0 )
  {
    AIL_release_sample_handle(S);
  }
  S->system_data[6] = 0xFFFFFFFF;
}

//----- (0006C5D1) --------------------------------------------------------
void __cdecl sub_6C5D1(HSAMPLE S, int a2)
{
  int v2; // ebp
  LONG v3; // edi
  int v4; // eax
  LONG v5; // ecx
  LONG v6; // ebx
  unsigned int v7; // ebp
  unsigned __int64 v8; // rax
  int v9; // eax
  int v10; // eax

  v2 = 0;
  while ( !v2 )
  {
    v3 = S->system_data[1];
    switch ( *(_BYTE *)v3 )
    {
      case 0:
        sub_6C573(S);
        return;
      case 1:
        if ( !S->system_data[5] )
        {
          goto LABEL_39;
        }
        v4 = sub_6C569((_DWORD *)S->system_data[1]);
        AIL_set_sample_address(S, (void *)(v3 + 6), v4 - 2);
        AIL_set_sample_playback_rate(S, (unsigned int)&unk_F4240 / (0x100 - (unsigned int)*(unsigned __int8 *)(v3 + 4)));
        AIL_set_sample_type(S, 0, 0);
        goto LABEL_8;
      case 4:
        v5 = S->system_data[4];
        if ( v5 != 0xFFFFFFFF )
        {
          S->system_data[5] = *(__int16 *)(v3 + 4) == v5;
        }
        goto LABEL_39;
      case 6:
        S->system_data[2] = v3;
        S->system_data[3] = *(unsigned __int16 *)(v3 + 4);
        goto LABEL_39;
      case 7:
        v6 = S->system_data[3];
        if ( v6 == 0xFFFF || (S->system_data[3] = v6 - 1, v6) )
        {
          v3 = S->system_data[2];
        }
        goto LABEL_39;
      case 8:
        if ( !S->system_data[5] )
        {
          goto LABEL_39;
        }
        if ( *(_BYTE *)(v3 + 7) )
        {
          AIL_set_sample_type(S, 2, 0);
          v7 = (unsigned int)sub_10000 - *(unsigned __int16 *)(v3 + 4);
          v8 = 0x7A12000i64;
        }
        else
        {
          AIL_set_sample_type(S, 0, 0);
          v7 = (unsigned int)sub_10000 - *(unsigned __int16 *)(v3 + 4);
          v8 = 0xF424000i64;
        }
        AIL_set_sample_playback_rate(S, v8 / v7);
        v3 += sub_6C569((_DWORD *)v3) + 4;
        v9 = sub_6C569((_DWORD *)v3);
        AIL_set_sample_address(S, (void *)(v3 + 6), v9 - 2);
LABEL_8:
        if ( a2 )
        {
          goto LABEL_37;
        }
        goto LABEL_38;
      case 9:
        if ( !S->system_data[5] )
        {
          goto LABEL_39;
        }
        v10 = sub_6C569((_DWORD *)S->system_data[1]);
        AIL_set_sample_address(S, (void *)(v3 + 0x10), v10 - 0xC);
        AIL_set_sample_playback_rate(S, *(_DWORD *)(v3 + 4));
        if ( *(_BYTE *)(v3 + 9) != 1 || *(_WORD *)(v3 + 0xA) )
        {
          if ( *(_BYTE *)(v3 + 9) != 2 || *(_WORD *)(v3 + 0xA) )
          {
            if ( *(_BYTE *)(v3 + 9) == 1 && *(_WORD *)(v3 + 0xA) == 4 )
            {
              AIL_set_sample_type(S, 1, 1u);
            }
            else if ( *(_BYTE *)(v3 + 9) == 2 && *(_WORD *)(v3 + 0xA) == 4 )
            {
              AIL_set_sample_type(S, 3, 1u);
            }
          }
          else
          {
            AIL_set_sample_type(S, 2, 0);
          }
        }
        else
        {
          AIL_set_sample_type(S, 0, 0);
        }
        if ( a2 )
        {
LABEL_37:
          AIL_start_sample(S);
        }
LABEL_38:
        v2 = 1;
LABEL_39:
        S->system_data[1] = v3 + sub_6C569((_DWORD *)v3) + 4;
        break;
      default:
        goto LABEL_39;
    }
  }
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (0006C83E) --------------------------------------------------------
void __cdecl sub_6C83E(SAMPLE *a1)
{
  sub_6C5D1(a1, 1);
}

//----- (0006C84E) --------------------------------------------------------
void __cdecl sub_6C84E(int a1, HSAMPLE S)
{
  int i; // esi
  int j; // esi

  for ( i = a1 + 0xC; strnicmp((const char *)i, "fmt ", 4u); i += *(_DWORD *)(i + 4) + 8 + (*(_DWORD *)(i + 4) & 1) )
  {
    ;
  }
  if ( *(_WORD *)(i + 0xA) == 1 && *(_WORD *)(i + 0x16) == 8 )
  {
    AIL_set_sample_type(S, 0, 0);
  }
  else if ( *(_WORD *)(i + 0xA) == 2 && *(_WORD *)(i + 0x16) == 8 )
  {
    AIL_set_sample_type(S, 2, 0);
  }
  else if ( *(_WORD *)(i + 0xA) == 1 && *(_WORD *)(i + 0x16) == 0x10 )
  {
    AIL_set_sample_type(S, 1, 1u);
  }
  else if ( *(_WORD *)(i + 0xA) == 2 && *(_WORD *)(i + 0x16) == 0x10 )
  {
    AIL_set_sample_type(S, 3, 1u);
  }
  AIL_set_sample_playback_rate(S, *(_DWORD *)(i + 0xC));
  for ( j = a1 + 0xC; strnicmp((const char *)j, "data", 4u); j += *(_DWORD *)(j + 4) + 8 + (*(_DWORD *)(j + 4) & 1) )
  {
    ;
  }
  AIL_set_sample_address(S, (void *)(j + 8), *(_DWORD *)(j + 4));
}

//----- (0006C938) --------------------------------------------------------
SAMPLE *__cdecl sub_6C938(int dig, char *s1, int a3)
{
  int v3; // ebp
  SAMPLE *result; // eax
  SAMPLE *v5; // esi
  SAMPLE *v6; // edi

  sub_6C53D();
  if ( !strnicmp(s1, "Creative", 8u) )
  {
    v3 = 0;
  }
  else
  {
    if ( strnicmp(s1 + 8, "WAVE", 4u) )
    {
      strcpy(&byte_132F70, "Unrecognized digital audio file type\n");
      return 0;
    }
    v3 = 1;
  }
  result = AIL_allocate_sample_handle((HDIGDRIVER)dig);
  v5 = result;
  v6 = result;
  if ( result )
  {
    AIL_init_sample(result);
    v5->system_data[0] = 0;
    if ( v3 )
    {
      v5->system_data[6] = 1;
      AIL_register_EOS_callback(v5, sub_6C573);
      sub_6C84E((int)s1, v5);
    }
    else
    {
      v5->system_data[1] = (LONG)&s1[*((unsigned __int16 *)s1 + 0xA)];
      v5->system_data[4] = a3;
      v5->system_data[5] = a3 == 0xFFFFFFFF;
      v5->system_data[6] = 1;
      AIL_register_EOS_callback(v5, sub_6C83E);
      sub_6C5D1(v5, 0);
    }
    if ( v6->system_data[6] == 0xFFFFFFFF )
    {
      strcpy(&byte_132F70, "Invalid or missing data block\n");
      return 0;
    }
    return v6;
  }
  return result;
}
// 6C9C6: conditional instruction was optimized away because ebp.4==1

//----- (0006CA63) --------------------------------------------------------
int __cdecl sub_6CA63(int a1, char *s1, int a3)
{
  int v3; // eax

  v3 = strnicmp(s1, "Creative", 8u);
  if ( v3 )
  {
    if ( strnicmp(s1 + 8, "WAVE", 4u) )
    {
      strcpy(&byte_132F70, "Unrecognized digital audio file type\n");
      return 0;
    }
    v3 = 1;
  }
  if ( v3 )
  {
    *(_DWORD *)(a1 + 0x88C) = 0;
    sub_6C84E((int)s1, (HSAMPLE)a1);
  }
  else
  {
    *(_DWORD *)(a1 + 0x878) = &s1[*((unsigned __int16 *)s1 + 0xA)];
    *(_DWORD *)(a1 + 0x884) = a3;
    *(_DWORD *)(a1 + 0x888) = a3 == 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x88C) = 0;
    sub_6C5D1((HSAMPLE)a1, 0);
  }
  if ( *(_DWORD *)(a1 + 0x88C) == 0xFFFFFFFF )
  {
    strcpy(&byte_132F70, "Invalid or missing data block\n");
    return 0;
  }
  return 1;
}
// 6CABC: conditional instruction was optimized away because eax.4==1

//----- (0006CB3B) --------------------------------------------------------
int __cdecl sub_6CB3B(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 0x874);
    *(_DWORD *)(a1 + 0x874) = a2;
    return v3;
  }
  return result;
}

//----- (0006CB57) --------------------------------------------------------
void sub_6CB57()
{
  if ( dword_987BC )
  {
    sub_6633A();
    dword_987BC = 0;
  }
}
// 987BC: using guessed type int dword_987BC;

//----- (0006CB90) --------------------------------------------------------
BOOL sub_6CB90()
{
  BOOL result; // eax

  if ( !dword_98844 )
  {
    sub_662D1((unsigned int)sub_6CB90, (unsigned int)sub_6E4C0);
    sub_6635F((unsigned int)byte_987C0, 0x80);
    sub_6635F((unsigned int)&dword_98840, 4);
    sub_6635F((unsigned int)&dword_132CF4, 4);
    sub_6635F((unsigned int)&in, 0xC);
    sub_6635F((unsigned int)&dword_132CFC, 4);
    sub_6635F((unsigned int)&dword_132D00, 4);
    sub_6635F((unsigned int)&dword_132CF0, 4);
    sub_6635F((unsigned int)&dword_132CF8, 4);
    sub_6635F((unsigned int)&dword_132CEC, 4);
    result = sub_741C3();
    dword_98844 = 1;
  }
  return result;
}
// 98840: using guessed type int dword_98840;
// 98844: using guessed type int dword_98844;
// 132CEC: using guessed type int dword_132CEC;
// 132CF0: using guessed type int dword_132CF0;
// 132CF4: using guessed type int dword_132CF4;
// 132CF8: using guessed type int dword_132CF8;
// 132CFC: using guessed type int dword_132CFC;
// 132D00: using guessed type int dword_132D00;

//----- (0006CCD0) --------------------------------------------------------
int *__cdecl sub_6CCD0(int a1)
{
  int v1; // edx
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int *result; // eax
  int v7; // edx
  int v8; // esi
  int v9; // ecx
  int v10; // edi
  int v11; // ebx
  int v12; // edi
  signed int v13; // ebx
  int v14; // edi
  signed int v15; // ebx
  int v16; // edi
  int v17; // ebx
  int v18; // edx
  int v19; // ebx
  signed int v20; // edx
  int v21; // ecx
  int v22; // edi
  signed int v23; // ebx
  int v24; // edx
  int v25; // [esp+8h] [ebp-20h]
  int v26; // [esp+Ch] [ebp-1Ch]

  v1 = *(_DWORD *)(a1 + 0x40);
  if ( v1 <= 0x7F )
  {
    if ( v1 < 0 )
    {
      *(_DWORD *)(a1 + 0x40) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 0x40) = 0x7F;
  }
  v2 = *(_DWORD *)(a1 + 0x44);
  if ( v2 <= 0x7F )
  {
    if ( v2 < 0 )
    {
      *(_DWORD *)(a1 + 0x44) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 0x44) = 0x7F;
  }
  v3 = *(_DWORD *)(a1 + 0x40);
  v4 = *(_DWORD *)(a1 + 0x44);
  v26 = v3;
  if ( v3 )
  {
    v26 = v3 + 1;
  }
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 0x18);
  if ( v5 == 2 || v5 == 3 )
  {
    result = (int *)(a1 + 0x48);
    v7 = a1 + 0x448;
    v8 = (unsigned __int8)byte_987C0[0x7F - v4];
    v9 = (unsigned __int8)byte_987C0[v4];
    v25 = v26 << 8;
    if ( (*(_BYTE *)(a1 + 0x38) & 1) != 0 )
    {
      v10 = 0;
      v11 = 0;
      do
      {
        *result = (v8 * (v11 >> 7)) >> 7;
        v7 += 4;
        ++result;
        *(_DWORD *)(v7 - 4) = (v9 * (v11 >> 7)) >> 7;
        v10 += 0x100;
        v11 += v25;
      }
      while ( v10 < 0x8000 );
      v12 = 0xFFFF8000;
      v13 = 0xFFFF8000 * v26;
      do
      {
        *result = (v8 * (v13 >> 7)) >> 7;
        v7 += 4;
        ++result;
        *(_DWORD *)(v7 - 4) = (v9 * (v13 >> 7)) >> 7;
        v12 += 0x100;
        v13 += v26 << 8;
      }
      while ( v12 < 0 );
    }
    else
    {
      v14 = 0xFFFF8000;
      v15 = 0xFFFF8000 * v26;
      do
      {
        *result = (v8 * (v15 >> 7)) >> 7;
        v7 += 4;
        ++result;
        *(_DWORD *)(v7 - 4) = (v9 * (v15 >> 7)) >> 7;
        v14 += 0x100;
        v15 += v25;
      }
      while ( v14 < 0x8000 );
    }
  }
  else
  {
    result = (int *)(a1 + 0x48);
    if ( (*(_BYTE *)(a1 + 0x38) & 1) != 0 )
    {
      v16 = 0;
      v17 = 0;
      do
      {
        ++result;
        v16 += 0x100;
        v18 = v17 >> 7;
        v17 += v26 << 8;
        result[0xFFFFFFFF] = v18;
      }
      while ( v16 < 0x8000 );
      v19 = 0xFFFF8000;
      v20 = 0xFFFF8000 * v26;
      do
      {
        ++result;
        v19 += 0x100;
        v21 = v20 >> 7;
        v20 += v26 << 8;
        result[0xFFFFFFFF] = v21;
      }
      while ( v19 < 0 );
    }
    else
    {
      v22 = 0xFFFF8000;
      v23 = 0xFFFF8000 * v26;
      do
      {
        ++result;
        v22 += 0x100;
        v24 = v23 >> 7;
        v23 += v26 << 8;
        result[0xFFFFFFFF] = v24;
      }
      while ( v22 < 0x8000 );
    }
  }
  return result;
}

//----- (0006CF50) --------------------------------------------------------
void __cdecl sub_6CF50(int a1)
{
  int v1; // edi
  int v2; // edi
  int v3; // eax
  _DWORD *v4; // eax
  int v5; // edi
  int v6; // eax
  AIL_DRIVER *v7; // [esp-10h] [ebp-1Ch]
  int v8; // [esp-4h] [ebp-10h]

  if ( !dword_98840 )
  {
    dword_98840 = 1;
    dword_132CF4 = a1;
    v1 = sub_67234();
    dword_132CFC = v1;
    if ( *(_DWORD *)(dword_132CF4 + 0x54) )
    {
      v2 = **(__int16 **)(dword_132CF4 + 0x34);
      dword_132CF8 = v2;
      if ( v2 != 0xFFFFFFFF && v2 != *(_DWORD *)(dword_132CF4 + 0x38) )
      {
        v8 = dword_132CF4;
        *(_DWORD *)(dword_132CF4 + 0x38) = v2;
        sub_74197(v8);
        dword_132D00 = 0;
        v3 = *(_DWORD *)(dword_132CF4 + 0x5C);
        dword_132CF0 = *(_DWORD *)(dword_132CF4 + 0x60);
        for ( dword_132CEC = v3; dword_132CF0; dword_132CEC += 0x894 )
        {
          if ( *(_DWORD *)(dword_132CEC + 4) == 4 )
          {
            ++dword_132D00;
            sub_73F04(dword_132CEC);
          }
          --dword_132CF0;
        }
        v4 = (_DWORD *)dword_132CF4;
        *(_DWORD *)(dword_132CF4 + 0x64) = dword_132D00;
        sub_74105(v4, dword_132CF8 ^ 1);
        if ( (*(_BYTE *)(dword_132CF4 + 0x1C) & 0x10) != 0 )
        {
          v7 = *(AIL_DRIVER **)dword_132CF4;
          in.CX = 0;
          in.DX = dword_132CF8 ^ 1;
          AIL_call_driver(v7, 0x405, &in, 0);
        }
        v5 = dword_132CF4;
        if ( *(_DWORD *)(dword_132CF4 + 0x64) )
        {
          *(_DWORD *)(dword_132CF4 + 0x58) = 0;
        }
        else
        {
          v6 = *(_DWORD *)(dword_132CF4 + 0x58);
          *(_DWORD *)(dword_132CF4 + 0x58) = v6 + 1;
          if ( v6 == 2 )
          {
            if ( *(_DWORD *)(v5 + 0x54) )
            {
              AIL_call_driver(*(AIL_DRIVER **)v5, 0x402, 0, 0);
              *(_DWORD *)(v5 + 0x54) = 0;
            }
          }
        }
      }
      sub_67239(dword_132CFC);
      dword_98840 = 0;
    }
    else
    {
      sub_67239(v1);
      dword_98840 = 0;
    }
  }
}
// 98840: using guessed type int dword_98840;
// 132CEC: using guessed type int dword_132CEC;
// 132CF0: using guessed type int dword_132CF0;
// 132CF4: using guessed type int dword_132CF4;
// 132CF8: using guessed type int dword_132CF8;
// 132CFC: using guessed type int dword_132CFC;
// 132D00: using guessed type int dword_132D00;

//----- (0006D140) --------------------------------------------------------
int __usercall sub_6D140@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebx
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // ecx
  unsigned __int16 v9; // ax
  int v10; // ebx
  int v11; // ebp
  int v12; // ebp
  int result; // eax
  signed int v14; // ebx
  int i; // ecx
  int v16; // ebx
  unsigned int v17; // eax
  _DWORD *v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // [esp+0h] [ebp-34h]
  int v24; // [esp+4h] [ebp-30h]
  int v25; // [esp+8h] [ebp-2Ch]
  int v26; // [esp+Ch] [ebp-28h]
  VDI_CALL in; // [esp+10h] [ebp-24h] BYREF
  int v28; // [esp+1Ch] [ebp-18h]
  int v29; // [esp+20h] [ebp-14h]
  int v30; // [esp+24h] [ebp-10h]

  v28 = *(_DWORD *)(a2 + 0x54);
  if ( v28 )
  {
    v2 = 0;
    if ( *(int *)(a2 + 0x60) > 0 )
    {
      v3 = 0;
      do
      {
        *(_DWORD *)(*(_DWORD *)(a2 + 0x5C) + v3 + 0x890) = *(_DWORD *)(*(_DWORD *)(a2 + 0x5C) + v3 + 4);
        v4 = v3 + *(_DWORD *)(a2 + 0x5C);
        if ( *(_DWORD *)(v4 + 4) == 4 )
        {
          *(_DWORD *)(v4 + 4) = 8;
        }
        ++v2;
        v3 += 0x894;
      }
      while ( v2 < *(_DWORD *)(a2 + 0x60) );
    }
    if ( *(_DWORD *)(a2 + 0x54) )
    {
      AIL_call_driver(*(AIL_DRIVER **)a2, 0x402, 0, 0);
      *(_DWORD *)(a2 + 0x54) = 0;
    }
    sub_74197(a2);
    sub_74105((_DWORD *)a2, 0);
    sub_74105((_DWORD *)a2, 1);
  }
  switch ( dword_133090 | (2 * dword_13308C) )
  {
    case 0:
      v23 = 0;
      v24 = 1;
      v25 = 2;
      v26 = 3;
      break;
    case 1:
      v23 = 1;
      v24 = 0;
      v25 = 3;
      v26 = 2;
      break;
    case 2:
      v23 = 2;
      v24 = 3;
      v25 = 0;
      v26 = 1;
      break;
    case 3:
      v23 = 3;
      v24 = 2;
      v25 = 1;
      v26 = 0;
      break;
    default:
      break;
  }
  v5 = 0;
  while ( 1 )
  {
    v6 = *(int *)((char *)&v23 + v5);
    if ( *(_BYTE *)(*(_DWORD *)(a2 + 4) + v6) )
    {
      break;
    }
    v5 += 4;
    if ( v5 >= 0x10 )
    {
      goto LABEL_19;
    }
  }
  *(_DWORD *)(a2 + 0x18) = v6;
LABEL_19:
  *(_DWORD *)(a2 + 0x1C) = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 0xE * *(_DWORD *)(a2 + 0x18) + 0x1A);
  if ( dword_133074 )
  {
    if ( (unsigned int)dword_133074 <= 1 )
    {
      v7 = *(unsigned __int16 *)(*(_DWORD *)(a2 + 4) + 0xE * *(_DWORD *)(a2 + 0x18) + 0x12);
    }
    else if ( dword_133074 == 2 )
    {
      v7 = *(unsigned __int16 *)(*(_DWORD *)(a2 + 4) + 0xE * *(_DWORD *)(a2 + 0x18) + 0x14);
    }
    else
    {
      v23 = *(unsigned __int16 *)(0xE * *(_DWORD *)(a2 + 0x18) + *(_DWORD *)(a2 + 4) + 0x10);
      v24 = *(unsigned __int16 *)(0xE * *(_DWORD *)(a2 + 0x18) + *(_DWORD *)(a2 + 4) + 0x12);
      v8 = 0;
      v9 = *(_WORD *)(0xE * *(_DWORD *)(a2 + 0x18) + *(_DWORD *)(a2 + 4) + 0x14);
      v30 = 0x7FFFFFFF;
      v25 = v9;
      v10 = 0;
      do
      {
        if ( (int)abs32(dword_133074 - *(int *)((char *)&v23 + v10)) <= v30 )
        {
          v30 = abs32(dword_133074 - *(int *)((char *)&v23 + v10));
          a1 = v8;
        }
        ++v8;
        v10 += 4;
      }
      while ( v8 < 3 );
      v7 = *(&v23 + a1);
    }
  }
  else
  {
    v7 = *(unsigned __int16 *)(*(_DWORD *)(a2 + 4) + 0xE * *(_DWORD *)(a2 + 0x18) + 0x10);
  }
  *(_DWORD *)(a2 + 0x14) = v7;
  switch ( *(_DWORD *)(a2 + 0x18) )
  {
    case 0:
      *(_DWORD *)(a2 + 0x3C) = 1;
      *(_DWORD *)(a2 + 0x40) = 1;
      break;
    case 1:
      *(_DWORD *)(a2 + 0x3C) = 1;
      goto LABEL_35;
    case 2:
      *(_DWORD *)(a2 + 0x3C) = 2;
      *(_DWORD *)(a2 + 0x40) = 1;
      break;
    case 3:
      *(_DWORD *)(a2 + 0x3C) = 2;
LABEL_35:
      *(_DWORD *)(a2 + 0x40) = 2;
      break;
    default:
      break;
  }
  *(_DWORD *)(a2 + 0x10) = *(_DWORD *)(a2 + 0x3C)
                         * dword_13307C
                         * *(_DWORD *)(a2 + 0x14)
                         / 0x3E8
                         * *(_DWORD *)(a2 + 0x40);
  v11 = 0xE * *(_DWORD *)(a2 + 0x18) + *(_DWORD *)(a2 + 4);
  v29 = *(unsigned __int16 *)(v11 + 0x16);
  v12 = *(unsigned __int16 *)(v11 + 0x18);
  if ( !dword_1330B4 )
  {
    goto LABEL_41;
  }
  if ( v12 > 0x800 )
  {
    v12 = 0x800;
  }
  if ( v29 > 0x800 )
  {
    result = 0;
    strcpy(&byte_132F70, "Minimum DMA buffer size too large for VDM\n");
  }
  else
  {
LABEL_41:
    v14 = 0x7FFFFFFF;
    for ( i = 8; i <= dword_133078 / 2; i *= 2 )
    {
      if ( (int)abs32(i - *(_DWORD *)(a2 + 0x10)) <= v14 )
      {
        a1 = i;
        v14 = abs32(i - *(_DWORD *)(a2 + 0x10));
      }
    }
    v16 = v29;
    *(_DWORD *)(a2 + 0x10) = a1;
    if ( a1 < v16 )
    {
      *(_DWORD *)(a2 + 0x10) = v16;
    }
    if ( v12 < *(_DWORD *)(a2 + 0x10) )
    {
      *(_DWORD *)(a2 + 0x10) = v12;
    }
    v17 = *(_DWORD *)(a2 + 0x20);
    if ( dword_1330B4 )
    {
      v17 = ((unsigned int)&unk_FF000 & ((v17 >> 0xC) + 0xFFF)) << 0xC;
    }
    **(_DWORD **)(a2 + 8) = v17;
    *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) = *(_DWORD *)(a2 + 0x10) + v17;
    v18 = *(_DWORD **)(a2 + 8);
    *(_DWORD *)(a2 + 0x2C) = (unsigned __int16)*v18 + 0x10 * HIWORD(*v18);
    v19 = (unsigned __int16)v18[1] + 0x10 * HIWORD(v18[1]);
    v20 = v28;
    *(_DWORD *)(a2 + 0x30) = v19;
    if ( v20 )
    {
      v21 = 0;
      if ( *(int *)(a2 + 0x60) > 0 )
      {
        v22 = 0;
        do
        {
          *(_DWORD *)(*(_DWORD *)(a2 + 0x5C) + v22 + 4) = *(_DWORD *)(*(_DWORD *)(a2 + 0x5C) + v22 + 0x890);
          ++v21;
          v22 += 0x894;
        }
        while ( v21 < *(_DWORD *)(a2 + 0x60) );
      }
      sub_74197(a2);
      sub_74105((_DWORD *)a2, 0);
      sub_74105((_DWORD *)a2, 1);
      if ( !*(_DWORD *)(a2 + 0x54) )
      {
        in.DX = *(_WORD *)(a2 + 0x18);
        in.CX = *(_WORD *)(a2 + 0x14);
        AIL_call_driver(*(AIL_DRIVER **)a2, 0x401, &in, 0);
        *(_DWORD *)(a2 + 0x54) = 1;
      }
    }
    return 1;
  }
  return result;
}
// 133074: using guessed type int dword_133074;
// 133078: using guessed type int dword_133078;
// 13307C: using guessed type int dword_13307C;
// 13308C: using guessed type int dword_13308C;
// 133090: using guessed type int dword_133090;
// 1330B4: using guessed type int dword_1330B4;

//----- (0006D5C0) --------------------------------------------------------
LONG __cdecl sub_6D5C0(AIL_DRIVER **a1, const void *a2)
{
  ULONG size; // eax
  _WORD *v3; // ebx
  unsigned int i; // eax
  int v5; // ebx
  int v7[6]; // [esp+0h] [ebp-30h] BYREF
  VDI_CALL in; // [esp+18h] [ebp-18h] BYREF

  qmemcpy(v7, a2, sizeof(v7));
  size = (*a1)->size;
  if ( *(_WORD *)(size + 0x10) )
  {
    v3 = (_WORD *)((unsigned __int16)*(_DWORD *)(size + 0xC) + 0x10 * HIWORD(*(_DWORD *)(size + 0xC)));
    if ( SLOWORD(v7[0]) < 0 )
    {
      LOWORD(v7[0]) = *v3;
    }
    if ( v7[0] < 0 )
    {
      HIWORD(v7[0]) = v3[1];
    }
    if ( SLOWORD(v7[1]) < 0 )
    {
      LOWORD(v7[1]) = v3[2];
    }
    if ( v7[1] < 0 )
    {
      HIWORD(v7[1]) = v3[3];
    }
    for ( i = 0; i != 0x10; i += 4 )
    {
      if ( v7[i / 4 + 2] < 0 )
      {
        v7[i / 4 + 2] = *(_DWORD *)&v3[i / 2 + 4];
      }
    }
  }
  v5 = dword_133094;
  qmemcpy((void *)((*a1)->size + 0x16), v7, 0x18u);
  if ( v5 )
  {
    in.DX = 3;
  }
  else
  {
    in.DX = 1;
  }
  return AIL_call_driver(*a1, 0x304, &in, 0);
}
// 133094: using guessed type int dword_133094;

//----- (0006D6C0) --------------------------------------------------------
int __cdecl sub_6D6C0(AIL_DRIVER **ptr)
{
  if ( ptr[0x15] )
  {
    AIL_call_driver(*ptr, 0x402, 0, 0);
    ptr[0x15] = 0;
    sub_74197((int)ptr);
    sub_74105(ptr, 0);
    sub_74105(ptr, 1);
    AIL_delay(0xA);
  }
  AIL_release_timer_handle((HTIMER)ptr[3]);
  sub_662A5((int)ptr[0xA], (int)ptr[8], (unsigned __int16)ptr[9]);
  sub_661FF(ptr[0x17]);
  sub_661FF(ptr[0x14]);
  return sub_661FF(ptr);
}
// 6D6CE: conditional instruction was optimized away because edx.4!=0

//----- (0006D770) --------------------------------------------------------
AIL_DRIVER **__cdecl sub_6D770(AIL_DRIVER *drvr, const void *a2)
{
  AIL_DRIVER **result; // eax
  AIL_DRIVER **v3; // ebp
  int v4; // edx
  IO_PARMS *IO_environment; // eax
  const void *v6; // edx
  ULONG size; // eax
  int v8; // esi
  int v9; // edi
  int v10; // ecx
  int v11; // edi
  int v12; // edx
  AIL_DRIVER *v13; // eax
  int v14; // eax
  AIL_DRIVER *v15; // eax
  int v16; // ecx
  int v17; // eax
  HTIMER v18; // eax
  _BYTE v19[24]; // [esp+0h] [ebp-50h] BYREF
  VDI_CALL out; // [esp+18h] [ebp-38h] BYREF
  AIL_DRIVER *v21; // [esp+24h] [ebp-2Ch] BYREF
  unsigned int v22; // [esp+28h] [ebp-28h] BYREF
  AIL_DRIVER *v23; // [esp+2Ch] [ebp-24h] BYREF
  int v24; // [esp+30h] [ebp-20h]
  const void *v25; // [esp+34h] [ebp-1Ch]
  IO_PARMS *v26; // [esp+38h] [ebp-18h]
  int v27; // [esp+3Ch] [ebp-14h]
  int v28; // [esp+40h] [ebp-10h]

  sub_6CB90();
  result = (AIL_DRIVER **)sub_661DE(0x88u);
  v3 = result;
  if ( result )
  {
    *result = drvr;
    if ( drvr->VHDR )
    {
      strcpy(&byte_132F70, ".DIG driver required\n");
      sub_661FF(result);
      return 0;
    }
    else
    {
      AIL_call_driver(drvr, 0x301, 0, &out);
      v3[1] = (AIL_DRIVER *)((unsigned __int16)out.AX + 0x10 * (unsigned __int16)out.DX);
      v4 = (unsigned __int16)out.BX + 0x10 * (unsigned __int16)out.CX;
      v3[2] = (AIL_DRIVER *)v4;
      v3[0xE] = (AIL_DRIVER *)0xFFFFFFFF;
      v3[0x15] = 0;
      v3[0x16] = 0;
      v3[0x19] = 0;
      v3[0xD] = (AIL_DRIVER *)(v4 + 8);
      v27 = 0;
      memset(&unk_1330B8, 0xFFFFFFFF, 0x18u);
      if ( a2 )
      {
        qmemcpy(&unk_1330B8, a2, 0x18u);
        if ( sub_6D5C0(v3, a2) )
        {
          v27 = 1;
          qmemcpy(v19, a2, sizeof(v19));
        }
      }
      if ( !v27 )
      {
        IO_environment = AIL_get_IO_environment(*v3);
        v26 = IO_environment;
        if ( IO_environment )
        {
          qmemcpy(&unk_1330B8, IO_environment, 0x18u);
          if ( sub_6D5C0(v3, IO_environment) )
          {
            v27 = 1;
            qmemcpy(v19, v26, sizeof(v19));
          }
        }
      }
      if ( !v27 && dword_1330B0 == 1 )
      {
        v28 = v27;
        v24 = v27;
        while ( 1 )
        {
          size = (*v3)->size;
          if ( *(unsigned __int16 *)(size + 0x10) <= v28 )
          {
            break;
          }
          v6 = (const void *)(0x10 * HIWORD(*(_DWORD *)(size + 0xC)) + (unsigned __int16)*(_DWORD *)(size + 0xC) + v24);
          v25 = v6;
          if ( !v28 )
          {
            qmemcpy(&unk_1330B8, v6, 0x18u);
          }
          if ( sub_6D5C0(v3, v25) )
          {
            v27 = 1;
            qmemcpy(v19, v25, sizeof(v19));
            break;
          }
          v24 += 0x18;
          ++v28;
        }
      }
      if ( v27 )
      {
        qmemcpy(&unk_1330B8, v19, 0x18u);
        if ( dword_1330B4 )
        {
          v8 = 0x2000;
        }
        else
        {
          v8 = dword_133078;
        }
        v3[0xA] = 0;
        v9 = (v8 + 0xF - (__CFSHL__((v8 + 0xF) >> 0x1F, 4) + 0x10 * ((v8 + 0xF) >> 0x1F))) >> 4;
        do
        {
          if ( !sub_66220(v9, &v23, &v22, &v21) )
          {
            strcpy(&byte_132F70, "Could not allocate DMA buffers\n");
            sub_661FF(v3);
            return 0;
          }
          v10 = (int)v3[0xA];
          if ( v10 )
          {
            sub_662A5(v10, (int)v3[8], (unsigned __int16)v3[9]);
          }
          v3[0xA] = v23;
          v3[8] = (AIL_DRIVER *)v22;
          v3[9] = v21;
        }
        while ( ((unsigned int)&unk_F0000 & (v22 >> 0xC)) != ((unsigned int)&unk_F0000 & (v8 + (v22 >> 0xC) - 1)) );
        if ( sub_6D140(v9, (int)v3) )
        {
          AIL_call_driver(*v3, 0x305, 0, 0);
          (*v3)->type = 1;
          v11 = (int)v3[0x10];
          v12 = (int)v3[4];
          v3[0x12] = (AIL_DRIVER *)(v12 / (v11 * (int)v3[0xF]));
          v3[0x11] = (AIL_DRIVER *)(v12 / v11);
          v3[0x13] = (AIL_DRIVER *)(4 * (v12 / v11));
          v13 = (AIL_DRIVER *)sub_661DE(4 * (v12 / v11));
          v3[0x14] = v13;
          if ( v13 )
          {
            v14 = dword_133080;
            v3[0x18] = (AIL_DRIVER *)dword_133080;
            v15 = (AIL_DRIVER *)sub_661DE(0x894 * v14);
            v3[0x17] = v15;
            if ( v15 )
            {
              v16 = 0;
              if ( (int)v3[0x18] > 0 )
              {
                v17 = 0;
                do
                {
                  *(ULONG *)((char *)&v3[0x17]->sel + v17) = 1;
                  *(REALFAR *)((char *)&v3[0x17]->seg + v17) = (REALFAR)v3;
                  ++v16;
                  v17 += 0x894;
                }
                while ( v16 < (int)v3[0x18] );
              }
              v18 = AIL_register_timer(sub_6CF50);
              v3[3] = (AIL_DRIVER *)v18;
              if ( v18 == 0xFFFFFFFF )
              {
                strcpy(&byte_132F70, "Out of timer handles\n");
                if ( drvr->initialized != 0xFFFFFFFF )
                {
                  AIL_restore_USE16_ISR(drvr->initialized);
                }
                AIL_call_driver(*v3, 0x306, 0, 0);
                (*v3)->type = 0;
                sub_662A5((int)v3[0xA], (int)v3[8], (unsigned __int16)v3[9]);
                sub_661FF(v3[0x17]);
                sub_661FF(v3[0x14]);
                sub_661FF(v3);
                return 0;
              }
              else
              {
                AIL_set_timer_user(v18, (ULONG)v3);
                AIL_set_timer_frequency((HTIMER)v3[3], hertz);
                AIL_start_timer((HTIMER)v3[3]);
                (*v3)->server = (HTIMER)sub_6D6C0;
                (*v3)->destructor = (void (__cdecl *)(void *))v3;
                sub_74197((int)v3);
                sub_74105(v3, 0);
                sub_74105(v3, 1);
                return v3;
              }
            }
            else
            {
              strcpy(&byte_132F70, "Could not allocate SAMPLE structures\n");
              if ( drvr->initialized != 0xFFFFFFFF )
              {
                AIL_restore_USE16_ISR(drvr->initialized);
              }
              AIL_call_driver(*v3, 0x306, 0, 0);
              (*v3)->type = 0;
              sub_662A5((int)v3[0xA], (int)v3[8], (unsigned __int16)v3[9]);
              sub_661FF(v3[0x14]);
              sub_661FF(v3);
              return 0;
            }
          }
          else
          {
            strcpy(&byte_132F70, "Could not allocate build buffer\n");
            if ( drvr->initialized != 0xFFFFFFFF )
            {
              AIL_restore_USE16_ISR(drvr->initialized);
            }
            AIL_call_driver(*v3, 0x306, 0, 0);
            (*v3)->type = 0;
            sub_662A5((int)v3[0xA], (int)v3[8], (unsigned __int16)v3[9]);
            sub_661FF(v3);
            return 0;
          }
        }
        else
        {
          sub_662A5((int)v3[0xA], (int)v3[8], (unsigned __int16)v3[9]);
          sub_661FF(v3);
          return 0;
        }
      }
      else
      {
        strcpy(&byte_132F70, "Digital sound hardware not found\n");
        sub_661FF(v3);
        return 0;
      }
    }
  }
  else
  {
    strcpy(&byte_132F70, "Could not allocate memory for driver\n");
  }
  return result;
}
// 133078: using guessed type int dword_133078;
// 133080: using guessed type int dword_133080;
// 1330B0: using guessed type int dword_1330B0;
// 1330B4: using guessed type int dword_1330B4;

//----- (0006DD80) --------------------------------------------------------
UBYTE *__cdecl sub_6DD80(char *path, int a2)
{
  UBYTE *result; // eax
  UBYTE *v3; // esi
  ULONG v4; // eax
  AIL_DRIVER *v5; // edi
  AIL_DRIVER **v6; // esi

  result = (UBYTE *)sub_66996(path, 0);
  v3 = result;
  if ( result )
  {
    v4 = sub_6694A(path);
    v5 = AIL_install_driver(v3, v4);
    off_987B0(v3);
    if ( v5 )
    {
      v6 = sub_6D770(v5, (const void *)a2);
      if ( !v6 )
      {
        AIL_uninstall_driver(v5);
      }
      return (UBYTE *)v6;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    strcpy(&byte_132F70, "Driver file not found\n");
  }
  return result;
}
// 987B0: using guessed type int (__fastcall *off_987B0)(_DWORD);

//----- (0006DE00) --------------------------------------------------------
AIL_DRIVER *__cdecl sub_6DE00(void *s2, size_t n, int a3)
{
  AIL_DRIVER *result; // eax
  AIL_DRIVER *v4; // esi
  AIL_DRIVER **v5; // edi

  result = AIL_install_driver((UBYTE *)s2, n);
  v4 = result;
  if ( result )
  {
    v5 = sub_6D770(result, (const void *)a3);
    if ( !v5 )
    {
      AIL_uninstall_driver(v4);
    }
    return (AIL_DRIVER *)v5;
  }
  return result;
}

//----- (0006DE40) --------------------------------------------------------
HDIGDRIVER sub_6DE40()
{
  HDIGDRIVER result; // eax
  AIL_INI INI; // [esp+0h] [ebp-120h] BYREF

  result = (HDIGDRIVER)AIL_read_INI(&INI, "DIG.INI");
  if ( result )
  {
    return AIL_install_DIG_driver_file(INI.driver_name, &INI.IO);
  }
  strcpy(&byte_132F70, "Unable to open file DIG.INI\n");
  return result;
}

//----- (0006DEA0) --------------------------------------------------------
void __cdecl sub_6DEA0(AIL_DRIVER **a1)
{
  AIL_uninstall_driver(*a1);
}

//----- (0006DEB0) --------------------------------------------------------
int __cdecl sub_6DEB0(int a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edx

  v1 = 0;
  v2 = 0;
  if ( *(int *)(a1 + 0x60) > 0 )
  {
    v3 = *(_DWORD *)(a1 + 0x5C);
    do
    {
      if ( *(_DWORD *)(v3 + 4) == 4 )
      {
        ++v1;
      }
      ++v2;
      v3 += 0x894;
    }
    while ( v2 < *(_DWORD *)(a1 + 0x60) );
  }
  return v1;
}

//----- (0006DEE0) --------------------------------------------------------
SAMPLE *__cdecl sub_6DEE0(int a1)
{
  int v1; // eax
  int v2; // edx
  SAMPLE *v4; // esi
  int v5; // eax

  sub_66FC8();
  v1 = 0;
  if ( *(int *)(a1 + 0x60) > 0 )
  {
    v2 = *(_DWORD *)(a1 + 0x5C);
    do
    {
      if ( *(_DWORD *)(v2 + 4) == 1 )
      {
        break;
      }
      ++v1;
      v2 += 0x894;
    }
    while ( v1 < *(_DWORD *)(a1 + 0x60) );
  }
  if ( v1 == *(_DWORD *)(a1 + 0x60) )
  {
    strcpy(&byte_132F70, "Out of sample handles\n");
    sub_66FCD(v1);
    return 0;
  }
  else
  {
    v4 = (SAMPLE *)(0x894 * v1 + *(_DWORD *)(a1 + 0x5C));
    AIL_init_sample(v4);
    sub_66FCD(v5);
    return v4;
  }
}
// 6DF42: variable 'v5' is possibly undefined

//----- (0006DF50) --------------------------------------------------------
int __cdecl sub_6DF50(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 4) = 1;
  }
  return result;
}

//----- (0006DF60) --------------------------------------------------------
int *__cdecl sub_6DF60(int *a1)
{
  int *result; // eax
  int v2; // edx

  result = a1;
  if ( a1 )
  {
    a1[1] = 2;
    a1[2] = 0;
    a1[4] = 0;
    a1[6] = 0;
    a1[8] = 0;
    a1[3] = 0;
    a1[5] = 0;
    a1[7] = 0;
    a1[9] = 1;
    a1[0xA] = 0;
    a1[0xB] = 0xFFFFFFFE;
    a1[0xC] = 1;
    a1[0xD] = 0;
    a1[0xE] = 0;
    a1[0xF] = 0x2B11;
    a1[0x11] = 0x40;
    a1[0x212] = 0;
    a1[0x213] = 0;
    v2 = dword_133084;
    a1[0x214] = 0;
    a1[0x10] = v2;
    return sub_6CCD0((int)a1);
  }
  return result;
}
// 133084: using guessed type int dword_133084;

//----- (0006E010) --------------------------------------------------------
int __cdecl sub_6E010(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 4);
  }
  return result;
}

//----- (0006E020) --------------------------------------------------------
_DWORD *__cdecl sub_6E020(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    a1[3] = 0;
    a1[5] = 0;
    a1[2] = a2;
    a1[4] = a3;
  }
  return result;
}

//----- (0006E050) --------------------------------------------------------
int *__cdecl sub_6E050(int a1, int a2, int a3)
{
  int *result; // eax

  result = (int *)a1;
  if ( a1 && (a2 != *(_DWORD *)(a1 + 0x34) || a3 != *(_DWORD *)(a1 + 0x38)) )
  {
    *(_DWORD *)(a1 + 0x34) = a2;
    *(_DWORD *)(a1 + 0x38) = a3;
    return sub_6CCD0(a1);
  }
  return result;
}

//----- (0006E080) --------------------------------------------------------
int __cdecl sub_6E080(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 0x3C);
  }
  return result;
}

//----- (0006E090) --------------------------------------------------------
int __cdecl sub_6E090(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 0x3C) = a2;
  }
  return result;
}

//----- (0006E0A0) --------------------------------------------------------
int __cdecl sub_6E0A0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 0x40);
  }
  return result;
}

//----- (0006E0B0) --------------------------------------------------------
int *__cdecl sub_6E0B0(int a1, int a2)
{
  int *result; // eax

  result = (int *)a1;
  if ( a1 )
  {
    if ( a2 != *(_DWORD *)(a1 + 0x40) )
    {
      *(_DWORD *)(a1 + 0x40) = a2;
      return sub_6CCD0(a1);
    }
  }
  return result;
}

//----- (0006E0D0) --------------------------------------------------------
int __cdecl sub_6E0D0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 0x44);
  }
  return result;
}

//----- (0006E0E0) --------------------------------------------------------
int *__cdecl sub_6E0E0(int a1, int a2)
{
  int *result; // eax

  result = (int *)a1;
  if ( a1 )
  {
    if ( a2 != *(_DWORD *)(a1 + 0x44) )
    {
      *(_DWORD *)(a1 + 0x44) = a2;
      return sub_6CCD0(a1);
    }
  }
  return result;
}

//----- (0006E100) --------------------------------------------------------
int __cdecl sub_6E100(int a1)
{
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 0x28) + 0x18);
  }
  else
  {
    return 0;
  }
}

//----- (0006E120) --------------------------------------------------------
int __cdecl sub_6E120(int a1, int a2)
{
  int result; // eax

  if ( a1 )
  {
    result = a1 + 4 * *(_DWORD *)(a1 + 0x28);
    *(_DWORD *)(result + 0x18) = a2;
  }
  return result;
}

//----- (0006E140) --------------------------------------------------------
unsigned int __cdecl sub_6E140(int a1)
{
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 0x30);
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (0006E160) --------------------------------------------------------
int __cdecl sub_6E160(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 0x30) = a2;
  }
  return result;
}

//----- (0006E170) --------------------------------------------------------
void __cdecl sub_6E170(_DWORD *a1)
{
  _DWORD *v1; // eax
  int v2; // esi
  VDI_CALL in; // [esp+0h] [ebp-18h] BYREF

  if ( a1 )
  {
    if ( a1[1] != 1 )
    {
      v1 = &a1[a1[0xA]];
      if ( v1[4] )
      {
        if ( v1[2] )
        {
          v1[6] = 0;
          a1[1] = 4;
          v2 = *a1;
          if ( !*(_DWORD *)(*a1 + 0x54) )
          {
            in.DX = *(_WORD *)(v2 + 0x18);
            in.CX = *(_WORD *)(v2 + 0x14);
            AIL_call_driver(*(AIL_DRIVER **)v2, 0x401, &in, 0);
            *(_DWORD *)(v2 + 0x54) = 1;
          }
        }
      }
    }
  }
}

//----- (0006E1F0) --------------------------------------------------------
int __cdecl sub_6E1F0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 4) == 4 )
    {
      *(_DWORD *)(a1 + 4) = 8;
    }
  }
  return result;
}

//----- (0006E210) --------------------------------------------------------
int __cdecl sub_6E210(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 4) == 8 )
    {
      *(_DWORD *)(a1 + 4) = 4;
    }
  }
  return result;
}

//----- (0006E230) --------------------------------------------------------
int __cdecl sub_6E230(int a1)
{
  int v1; // edx
  int v2; // ecx
  int result; // eax

  if ( a1 )
  {
    v1 = *(_DWORD *)(a1 + 4);
    if ( v1 != 1 && v1 != 2 )
    {
      v2 = *(_DWORD *)(a1 + 0x84C);
      *(_DWORD *)(a1 + 4) = 2;
      if ( v2 )
      {
        result = (*(int (__cdecl **)(int))(a1 + 0x84C))(a1);
      }
      if ( *(_DWORD *)(a1 + 0x850) )
      {
        return (*(int (__cdecl **)(int))(a1 + 0x850))(a1);
      }
    }
  }
  return result;
}

//----- (0006E280) --------------------------------------------------------
int __cdecl sub_6E280(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 0x848);
    *(_DWORD *)(a1 + 0x848) = a2;
    return v3;
  }
  return result;
}

//----- (0006E2A0) --------------------------------------------------------
int __cdecl sub_6E2A0(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 0x84C);
    *(_DWORD *)(a1 + 0x84C) = a2;
    return v3;
  }
  return result;
}

//----- (0006E2C0) --------------------------------------------------------
int __cdecl sub_6E2C0(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 0x850);
    *(_DWORD *)(a1 + 0x850) = a2;
    return v3;
  }
  return result;
}

//----- (0006E2E0) --------------------------------------------------------
int __cdecl sub_6E2E0(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    result = a1 + 4 * a2;
    *(_DWORD *)(result + 0x854) = a3;
  }
  return result;
}

//----- (0006E300) --------------------------------------------------------
int __cdecl sub_6E300(int a1, int a2)
{
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 4 * a2 + 0x854);
  }
  else
  {
    return 0;
  }
}

//----- (0006E330) --------------------------------------------------------
int __usercall sub_6E330@<eax>(int a1@<edx>, _DWORD *a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // edi
  int v6; // ebx
  int v7; // ebx

  switch ( a4 )
  {
    case 0:
      a1 = 1;
      break;
    case 1:
    case 2:
      a1 = 2;
      break;
    case 3:
      a1 = 4;
      break;
    default:
      break;
  }
  v4 = a3 * (a2[4] * a1 / (a2[0x10] * a2[0xF])) / a2[5];
  v5 = a2[5];
  v6 = ((v4 * dword_133088 - (__CFSHL__((v4 * dword_133088) >> 0x1F, 0xF) + ((v4 * dword_133088) >> 0x1F << 0xF))) >> 0xF)
     + v4;
  if ( a3 != v5 && 2 * a3 != v5 && 4 * a3 != v5 )
  {
    v6 += 4;
  }
  v7 = v6 + 0xFF;
  LOBYTE(v7) = 0;
  return v7;
}
// 133088: using guessed type int dword_133088;

//----- (0006E3D0) --------------------------------------------------------
_DWORD *__cdecl sub_6E3D0(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax
  int v5; // esi
  VDI_CALL in; // [esp+0h] [ebp-10h] BYREF

  result = a1;
  if ( a1 )
  {
    a1[a2 + 6] = 0;
    a1[a2 + 8] = a4 == 0;
    a1[a2 + 4] = a4;
    a1[a2 + 2] = a3;
    if ( a4 )
    {
      if ( a1[1] != 4 )
      {
        v5 = *a1;
        a1[1] = 4;
        if ( !*(_DWORD *)(v5 + 0x54) )
        {
          in.DX = *(_WORD *)(v5 + 0x18);
          in.CX = *(_WORD *)(v5 + 0x14);
          result = (_DWORD *)AIL_call_driver(*(AIL_DRIVER **)v5, 0x401, &in, 0);
          *(_DWORD *)(v5 + 0x54) = 1;
        }
      }
    }
  }
  return result;
}

//----- (0006E460) --------------------------------------------------------
char __cdecl sub_6E460(_DWORD *a1)
{
  unsigned int v2; // edx
  int v3; // ebx

  if ( !a1 )
  {
    return 0xFF;
  }
  v2 = a1[0xB];
  if ( v2 < 0xFFFFFFFE )
  {
    v3 = a1[0xA];
    if ( a1[0xB] == v3 )
    {
      return 0xFF;
    }
    else
    {
      a1[0xB] = v3;
      return v3 ^ 1;
    }
  }
  else if ( v2 == 0xFFFFFFFF )
  {
    a1[0xB] = a1[0xA];
    return 1;
  }
  else
  {
    a1[9] = 0;
    a1[0xB] = 0xFFFFFFFF;
    return 0;
  }
}

//----- (0006E4C0) --------------------------------------------------------
void sub_6E4C0()
{
  if ( dword_98844 )
  {
    sub_6633A();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    dword_98844 = 0;
  }
}
// 98844: using guessed type int dword_98844;

//----- (0006E580) --------------------------------------------------------
BOOL sub_6E580()
{
  BOOL result; // eax

  if ( !dword_988CC )
  {
    sub_662D1((unsigned int)sub_6E580, (unsigned int)sub_717B0);
    sub_6635F((unsigned int)"SAMPLE", 0x80);
    sub_6635F((unsigned int)&dword_988C8, 4);
    sub_6635F((unsigned int)&S, 4);
    sub_6635F((unsigned int)&dword_132D10, 4);
    sub_6635F((unsigned int)&dword_132D14, 4);
    sub_6635F((unsigned int)&dword_132D24, 4);
    sub_6635F((unsigned int)&dword_132D18, 4);
    sub_6635F((unsigned int)&dword_132D1C, 4);
    sub_6635F((unsigned int)&dword_132D08, 4);
    sub_6635F((unsigned int)&dword_132D20, 4);
    sub_6635F((unsigned int)&dword_132D2C, 4);
    sub_6635F((unsigned int)&dword_132D28, 4);
    result = sub_6635F((unsigned int)&dword_132D04, 4);
    dword_988CC = 1;
  }
  return result;
}
// 988C8: using guessed type int dword_988C8;
// 988CC: using guessed type int dword_988CC;
// 132D04: using guessed type int dword_132D04;
// 132D08: using guessed type int dword_132D08;
// 132D10: using guessed type int dword_132D10;
// 132D14: using guessed type int dword_132D14;
// 132D18: using guessed type int dword_132D18;
// 132D1C: using guessed type int dword_132D1C;
// 132D20: using guessed type int dword_132D20;
// 132D24: using guessed type int dword_132D24;
// 132D28: using guessed type int dword_132D28;
// 132D2C: using guessed type int dword_132D2C;

//----- (0006E6E0) --------------------------------------------------------
LONG __cdecl sub_6E6E0(int a1)
{
  LONG result; // eax
  VDI_CALL in; // [esp+0h] [ebp-10h] BYREF

  if ( *(int *)(a1 + 0x1A8) > 0 )
  {
    in.CX = *(_WORD *)(a1 + 0x1A8);
    result = AIL_call_driver(*(AIL_DRIVER **)a1, 0x502, &in, 0);
    *(_DWORD *)(a1 + 0x1A8) = 0;
    *(_DWORD *)(a1 + 0x1AC) = 0;
  }
  return result;
}

//----- (0006E730) --------------------------------------------------------
int __cdecl sub_6E730(int a1, char a2, char a3, char a4)
{
  unsigned int v4; // eax
  int v5; // eax
  int v6; // edi
  int v7; // eax
  int v8; // edx
  int result; // eax
  int v10; // edx
  int v11; // edx
  VDI_CALL in; // [esp+0h] [ebp-14h] BYREF

  v4 = a2 & 0xF0;
  if ( v4 < 0xB0 )
  {
    if ( v4 < 0x90 )
    {
      if ( v4 != 0x80 )
      {
LABEL_16:
        v5 = 0;
        goto LABEL_17;
      }
    }
    else if ( v4 > 0x90 && v4 != 0xA0 )
    {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  if ( v4 > 0xB0 )
  {
    if ( v4 < 0xD0 )
    {
      if ( v4 != 0xC0 )
      {
        goto LABEL_16;
      }
    }
    else if ( v4 > 0xD0 )
    {
      if ( v4 != 0xE0 )
      {
        goto LABEL_16;
      }
      goto LABEL_14;
    }
    v5 = 2;
    goto LABEL_17;
  }
LABEL_14:
  v5 = 3;
LABEL_17:
  v6 = v5;
  if ( (unsigned int)(*(_DWORD *)(a1 + 0x1AC) + v5) > 0x200 && *(int *)(a1 + 0x1A8) > 0 )
  {
    in.CX = *(_WORD *)(a1 + 0x1A8);
    AIL_call_driver(*(AIL_DRIVER **)a1, 0x502, &in, 0);
    *(_DWORD *)(a1 + 0x1A8) = 0;
    *(_DWORD *)(a1 + 0x1AC) = 0;
  }
  v7 = *(_DWORD *)(a1 + 0x1AC);
  v8 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 0x1AC) = v7 + 1;
  *(_BYTE *)(v8 + v7 + 0x100) = a2;
  result = *(_DWORD *)(a1 + 0x1AC);
  v10 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 0x1AC) = result + 1;
  *(_BYTE *)(v10 + result + 0x100) = a3;
  if ( v6 == 3 )
  {
    result = *(_DWORD *)(a1 + 0x1AC);
    v11 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 0x1AC) = result + 1;
    *(_BYTE *)(v11 + result + 0x100) = a4;
  }
  ++*(_DWORD *)(a1 + 0x1A8);
  return result;
}

//----- (0006E910) --------------------------------------------------------
int __cdecl sub_6E910(_DWORD *a1)
{
  int v1; // eax
  int v2; // ecx
  char v3; // bl

  v1 = 4;
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(*a1)++;
    v2 = v3 & 0x7F | (v2 << 7);
    if ( v3 >= 0 )
    {
      break;
    }
    --v1;
  }
  while ( v1 );
  return v2;
}

//----- (0006E980) --------------------------------------------------------
int __cdecl sub_6E980(int a1, int a2)
{
  int v3; // esi
  unsigned int v4; // edi
  int result; // eax
  unsigned int v6; // ebp
  unsigned int v7; // ecx

  v3 = a2;
  v4 = 0;
  do
  {
    a1 += v4;
    if ( strncmp((const char *)a1, "FORM", 4u) && strncmp((const char *)a1, "CAT ", 4u) )
    {
      return 0;
    }
    v4 = ((*(_DWORD *)(a1 + 4) & 0xFF00) << 8)
       + ((unsigned __int8)*(_DWORD *)(a1 + 4) << 0x18)
       + ((*(_DWORD *)(a1 + 4) & 0xFF0000u) >> 8)
       + ((*(_DWORD *)(a1 + 4) & 0xFF000000) >> 0x18)
       + 8;
  }
  while ( strncmp((const char *)(a1 + 8), "XMID", 4u) );
  result = strncmp((const char *)a1, "FORM", 4u);
  if ( result )
  {
    v6 = a1 + v4;
    v7 = a1 + 0xC;
    if ( v7 >= v6 )
    {
      return 0;
    }
    while ( strncmp((const char *)(v7 + 8), "XMID", 4u) || --v3 != 0xFFFFFFFF )
    {
      v7 += ((unsigned __int8)*(_DWORD *)(v7 + 4) << 0x18)
          + ((*(_DWORD *)(v7 + 4) & 0xFF00) << 8)
          + ((*(_DWORD *)(v7 + 4) & 0xFF0000u) >> 8)
          + ((*(_DWORD *)(v7 + 4) & 0xFF000000) >> 0x18)
          + 8;
      if ( v7 >= v6 )
      {
        return 0;
      }
    }
    return v7;
  }
  else if ( !a2 )
  {
    return a1;
  }
  return result;
}

//----- (0006EAA0) --------------------------------------------------------
int __cdecl sub_6EAA0(int a1, char a2, unsigned int a3)
{
  int v3; // ebx
  unsigned int v4; // ecx
  _DWORD *v5; // edx

  v3 = a2 & 0xF;
  v4 = a2 & 0xF0;
  v5 = (_DWORD *)(a1 + 4 * v3);
  if ( v4 >= 0xC0 )
  {
    if ( v4 <= 0xC0 )
    {
      return *v5;
    }
    if ( v4 == 0xE0 )
    {
      return v5[0x10] | (v5[0x20] << 7);
    }
    return 0xFFFFFFFF;
  }
  if ( v4 != 0xB0 )
  {
    return 0xFFFFFFFF;
  }
  if ( a3 < 0x5B )
  {
    if ( a3 < 7 )
    {
      if ( !a3 )
      {
        return 0xFFFFFFFF;
      }
      if ( a3 <= 1 )
      {
        return *(_DWORD *)(a1 + 4 * v3 + 0x240);
      }
      else if ( a3 == 6 )
      {
        return *(_DWORD *)(a1 + 4 * v3 + 0x400);
      }
      else
      {
        return 0xFFFFFFFF;
      }
    }
    else if ( a3 <= 7 )
    {
      return *(_DWORD *)(a1 + 4 * v3 + 0x280);
    }
    else if ( a3 < 0xB )
    {
      if ( a3 == 0xA )
      {
        return *(_DWORD *)(a1 + 4 * v3 + 0x2C0);
      }
      else
      {
        return 0xFFFFFFFF;
      }
    }
    else if ( a3 <= 0xB )
    {
      return *(_DWORD *)(a1 + 4 * v3 + 0x300);
    }
    else if ( a3 == 0x40 )
    {
      return v5[0xD0];
    }
    else
    {
      return 0xFFFFFFFF;
    }
  }
  else if ( a3 <= 0x5B )
  {
    return v5[0xE0];
  }
  else if ( a3 < 0x70 )
  {
    if ( a3 < 0x6E )
    {
      if ( a3 == 0x5D )
      {
        return v5[0xF0];
      }
      else
      {
        return 0xFFFFFFFF;
      }
    }
    else if ( a3 <= 0x6E )
    {
      return v5[0x30];
    }
    else
    {
      return v5[0x40];
    }
  }
  else if ( a3 <= 0x70 )
  {
    return v5[0x50];
  }
  else if ( a3 < 0x73 )
  {
    if ( a3 == 0x72 )
    {
      return v5[0x60];
    }
    else
    {
      return 0xFFFFFFFF;
    }
  }
  else if ( a3 <= 0x73 )
  {
    return v5[0x70];
  }
  else if ( a3 == 0x77 )
  {
    return v5[0x80];
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (0006EC20) --------------------------------------------------------
unsigned int __cdecl sub_6EC20(int a1, char a2, unsigned int a3, unsigned __int8 a4)
{
  unsigned int result; // eax
  int v5; // ecx
  unsigned int v6; // edi
  _DWORD *v7; // ebx

  result = a3;
  v5 = a2 & 0xF;
  v6 = a2 & 0xF0;
  v7 = (_DWORD *)(a1 + 4 * v5);
  if ( v6 < 0xC0 )
  {
    if ( v6 == 0xB0 )
    {
      if ( a3 < 0x5B )
      {
        if ( a3 < 7 )
        {
          if ( a3 )
          {
            if ( a3 <= 1 )
            {
              result = a4;
              *(_DWORD *)(a1 + 4 * v5 + 0x240) = a4;
            }
            else if ( a3 == 6 )
            {
              result = a4;
              *(_DWORD *)(a1 + 4 * v5 + 0x400) = a4;
            }
          }
        }
        else if ( a3 <= 7 )
        {
          result = a4;
          *(_DWORD *)(a1 + 4 * v5 + 0x280) = a4;
        }
        else if ( a3 < 0xB )
        {
          if ( a3 == 0xA )
          {
            result = a4;
            *(_DWORD *)(a1 + 4 * v5 + 0x2C0) = a4;
          }
        }
        else if ( a3 <= 0xB )
        {
          result = a4;
          *(_DWORD *)(a1 + 4 * v5 + 0x300) = a4;
        }
        else if ( a3 == 0x40 )
        {
          result = a4;
          v7[0xD0] = a4;
        }
      }
      else if ( a3 <= 0x5B )
      {
        result = a4;
        v7[0xE0] = a4;
      }
      else if ( a3 < 0x70 )
      {
        if ( a3 < 0x6E )
        {
          if ( a3 == 0x5D )
          {
            result = a4;
            v7[0xF0] = a4;
          }
        }
        else
        {
          result = a4;
          if ( a3 <= 0x6E )
          {
            v7[0x30] = a4;
          }
          else
          {
            v7[0x40] = a4;
          }
        }
      }
      else if ( a3 <= 0x70 )
      {
        result = a4;
        v7[0x50] = a4;
      }
      else if ( a3 < 0x73 )
      {
        if ( a3 == 0x72 )
        {
          result = a4;
          v7[0x60] = a4;
        }
      }
      else if ( a3 <= 0x73 )
      {
        result = a4;
        v7[0x70] = a4;
      }
      else if ( a3 == 0x77 )
      {
        result = a4;
        v7[0x80] = a4;
      }
    }
  }
  else if ( v6 <= 0xC0 )
  {
    result = (unsigned __int8)a3;
    *v7 = (unsigned __int8)a3;
  }
  else if ( v6 == 0xE0 )
  {
    v7[0x10] = (unsigned __int8)a3;
    result = a4;
    v7[0x20] = a4;
  }
  return result;
}

//----- (0006EDE0) --------------------------------------------------------
void __cdecl sub_6EDE0(HSEQUENCE S, char a2, unsigned int a3, ULONG marker, int a5)
{
  int v5; // edi
  int v6; // edx
  struct _MDI_DRIVER **v7; // eax
  AIL_DRIVER **v8; // eax
  AIL_DRIVER **v9; // eax
  AIL_DRIVER **v10; // eax
  int v11; // ett
  LONG time_numerator; // eax
  LONG time_fraction; // ebp
  HSEQUENCE v14; // edx
  int i; // eax
  int v16; // eax
  void **p_RBRN; // edx
  struct _MDI_DRIVER **v18; // eax
  struct _MDI_DRIVER *v19; // ecx
  LONG v20; // ebp
  LONG v21; // eax
  LONG v22; // edi
  struct _MDI_DRIVER **v23; // [esp+0h] [ebp-20h]
  LONG v24; // [esp+4h] [ebp-1Ch]
  struct _MDI_DRIVER *mdi; // [esp+Ch] [ebp-14h]
  int v26; // [esp+10h] [ebp-10h]

  v5 = marker;
  mdi = S->driver;
  v6 = a2 & 0xF0;
  v26 = a2 & 0xF;
  v24 = S->FOR_loop_count[v26 + 3];
  if ( v6 == 0xB0 || v6 == 0xC0 || v6 == 0xE0 )
  {
    sub_6EC20((int)&S->chan_map[0xF], v26 | v6, a3, marker);
  }
  if ( v6 != 0xB0 )
  {
    goto LABEL_31;
  }
  if ( a5 )
  {
    v7 = &S->driver + v26;
    if ( v7[0xA4] != (struct _MDI_DRIVER *)0xFFFFFFFF )
    {
      v5 = (int)v7[0xA4];
      v7[0xA4] = (struct _MDI_DRIVER *)0xFFFFFFFF;
    }
  }
  v23 = &S->driver + v26;
  v8 = &mdi->drvr + v24;
  if ( a3 < 0x6F )
  {
    if ( a3 < 0x6C )
    {
      if ( a3 >= 6 )
      {
        if ( a3 <= 6 )
        {
          sub_6EDE0(S, a2 & 0xF | 0xB0, 0x64, 0, 0);
          sub_6EDE0(S, a2 & 0xF | 0xB0, 0x65, 0, 0);
          sub_6EDE0(S, a2 & 0xF | 0xB0, 0x26, 0, 0);
        }
        else if ( a3 == 7 )
        {
          v11 = v5 * S->interval_num;
          v5 = v11 / 0x7F;
          if ( v11 / 0x7F > 0x7F )
          {
            v5 = 0x7F;
          }
          if ( v5 < 0 )
          {
            v5 = 0;
          }
        }
      }
    }
    else
    {
      if ( a3 > 0x6C )
      {
        if ( a3 <= 0x6D )
        {
          AIL_branch_index(S, v5);
        }
        else
        {
          v20 = v26 + 1;
          if ( v5 < 0x40 )
          {
            if ( v8[8] == (AIL_DRIVER *)1 )
            {
              sub_6F300(S, v26);
              AIL_release_channel(mdi, v24 + 1);
              AIL_map_sequence_channel(S, v20, v20);
            }
          }
          else if ( v8[8] != (AIL_DRIVER *)1 )
          {
            v21 = AIL_lock_channel(mdi);
            v22 = v21;
            if ( v21 )
            {
              AIL_map_sequence_channel(S, v20, v21);
              mdi->lock[v22 + 0xF] = (LONG)S;
            }
          }
        }
        return;
      }
      if ( S->prefix_callback )
      {
        v23[0xA4] = (struct _MDI_DRIVER *)((int (__cdecl *)(HSEQUENCE, int, int))S->prefix_callback)(S, v26, v5);
      }
    }
LABEL_31:
    v9 = &mdi->drvr + v24;
    if ( v9[8] != (AIL_DRIVER *)1 || S == (HSEQUENCE)v9[0x18] )
    {
      v10 = &mdi->drvr + v24;
      if ( v6 == 0x90 )
      {
        v10[0x58] = (AIL_DRIVER *)((char *)v10[0x58] + 1);
      }
      else if ( v6 == 0x80 )
      {
        v10[0x58] = (AIL_DRIVER *)((char *)v10[0x58] + 0xFFFFFFFF);
      }
      mdi->user[v24] = S;
      if ( !mdi->event_trap
        || !((int (__cdecl *)(struct _MDI_DRIVER *, HSEQUENCE, int, unsigned int, int))mdi->event_trap)(
              mdi,
              S,
              v24 | v6,
              a3,
              v5) )
      {
        sub_6E730((int)mdi, v24 | v6, a3, v5);
      }
    }
    return;
  }
  if ( a3 <= 0x6F )
  {
    if ( v8[8] != (AIL_DRIVER *)1 )
    {
      if ( v5 >= 0x40 )
      {
        v8[8] = (AIL_DRIVER *)2;
      }
      else
      {
        v8[8] = 0;
      }
    }
    return;
  }
  if ( a3 < 0x75 )
  {
    if ( a3 >= 0x73 )
    {
      if ( a3 > 0x73 )
      {
        v14 = S;
        for ( i = 0; i < 4; ++i )
        {
          if ( v14->FOR_ptrs[3] == (void *)0xFFFFFFFF )
          {
            break;
          }
          v14 = (HSEQUENCE)((char *)v14 + 4);
        }
        if ( i != 4 )
        {
          S->FOR_ptrs[i + 3] = (void *)v5;
          *(&S->time_per_beat + i) = (LONG)S->EVNT_ptr;
        }
        return;
      }
      v23[0xA4] = (struct _MDI_DRIVER *)S->ICA[v5];
    }
    goto LABEL_31;
  }
  if ( a3 <= 0x75 )
  {
    if ( v5 >= 0x40 )
    {
      v16 = 3;
      p_RBRN = &S->RBRN;
      do
      {
        if ( p_RBRN[0x20] != (void *)0xFFFFFFFF )
        {
          break;
        }
        --v16;
        p_RBRN += 0xFFFFFFFF;
      }
      while ( v16 >= 0 );
      if ( v16 != 0xFFFFFFFF )
      {
        v18 = &S->driver + v16;
        v19 = v18[0x20];
        if ( v19 )
        {
          v18[0x20] = (struct _MDI_DRIVER *)((char *)v19 + 0xFFFFFFFF);
          if ( v19 == (struct _MDI_DRIVER *)1 )
          {
            v18[0x20] = (struct _MDI_DRIVER *)0xFFFFFFFF;
          }
          else
          {
            S->EVNT_ptr = (UBYTE *)v18[0x1C];
          }
        }
        else
        {
          S->EVNT_ptr = (UBYTE *)v18[0x1C];
        }
      }
    }
  }
  else
  {
    if ( a3 <= 0x76 )
    {
      S->tempo_error = 0;
      S->time_fraction = 0;
      time_numerator = S->time_numerator;
      time_fraction = S->time_fraction;
      S->beat_count = 0;
      S->time_fraction = time_fraction - time_numerator;
      return;
    }
    if ( a3 != 0x77 )
    {
      goto LABEL_31;
    }
    if ( S->trigger_callback )
    {
      ((void (__cdecl *)(HSEQUENCE, int, int))S->trigger_callback)(S, v26, v5);
    }
  }
}
// 6EDE0: could not find valid save-restore pair for ebx

//----- (0006F230) --------------------------------------------------------
void __cdecl sub_6F230(SEQUENCE *a1)
{
  SEQUENCE *v1; // esi
  int v2; // edi
  LONG v3; // eax
  struct _MDI_DRIVER *driver; // esi
  VDI_CALL in; // [esp+0h] [ebp-1Ch] BYREF
  void **v6; // [esp+Ch] [ebp-10h]

  v1 = a1;
  v2 = 0;
  v6 = &a1->FOR_ptrs[3];
  do
  {
    v3 = v1->shadow.bend_range[0];
    if ( v3 != 0xFFFFFFFF )
    {
      ++v2;
      sub_6EDE0(a1, v3 | 0x80, v1->note_chan[0xF], 0, 0);
      v1->shadow.bend_range[0] = 0xFFFFFFFF;
    }
    v1 = (SEQUENCE *)((char *)v1 + 4);
  }
  while ( v1 != (SEQUENCE *)v6 );
  driver = a1->driver;
  a1->shadow.chorus[0xF] = 0;
  if ( driver->message_count > 0 )
  {
    in.CX = driver->message_count;
    AIL_call_driver(driver->drvr, 0x502, &in, 0);
    driver->message_count = 0;
    driver->offset = 0;
  }
  if ( v2 )
  {
    if ( !sub_673CA() )
    {
      AIL_delay(3);
    }
  }
}
// 673CA: using guessed type int sub_673CA(void);

//----- (0006F300) --------------------------------------------------------
LONG __cdecl sub_6F300(SEQUENCE *a1, int a2)
{
  SEQUENCE *v2; // esi
  LONG v3; // eax
  LONG result; // eax
  struct _MDI_DRIVER *driver; // esi
  VDI_CALL in; // [esp+0h] [ebp-18h] BYREF

  v2 = a1;
  do
  {
    if ( a2 == v2->shadow.bend_range[0] )
    {
      v3 = v2->shadow.bend_range[0];
      LOBYTE(v3) = v3 | 0x80;
      result = sub_6EDE0(a1, v3, v2->note_chan[0xF], 0, 0);
      v2->shadow.bend_range[0] = 0xFFFFFFFF;
    }
    v2 = (SEQUENCE *)((char *)v2 + 4);
  }
  while ( v2 != (SEQUENCE *)&a1->FOR_ptrs[3] );
  driver = a1->driver;
  if ( a1->driver->message_count > 0 )
  {
    in.CX = driver->message_count;
    result = AIL_call_driver(driver->drvr, 0x502, &in, 0);
    driver->message_count = 0;
    driver->offset = 0;
  }
  return result;
}
// 6EDE0: using guessed type _DWORD __cdecl sub_6EDE0(HSEQUENCE S, _DWORD, _DWORD, ULONG marker, _DWORD);

//----- (0006F3B0) --------------------------------------------------------
void __cdecl sub_6F3B0(SEQUENCE *a1, int a2)
{
  ULONG v2; // edx
  unsigned int v3; // ecx
  struct _MDI_DRIVER **v4; // eax
  ULONG v5; // edx
  ULONG v6; // ebp
  ULONG v7; // ebx
  ULONG v8; // ebp
  ULONG v9; // ebx
  ULONG v10; // ebp
  ULONG v11; // ebx
  ULONG v12; // ebp
  ULONG v13; // ebx
  ULONG v14; // ebp
  ULONG v15; // ebx

  v2 = a1->shadow.c_mute[a2 + 0xF];
  if ( v2 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0x72u, v2, 0);
  }
  v3 = a1->chan_map[a2 + 0xF];
  if ( v3 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xC0, v3, 0, 0);
  }
  v4 = &a1->driver + a2;
  v5 = (ULONG)v4[0x54];
  if ( v5 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xE0, (unsigned int)v4[0x44], v5, 0);
  }
  v6 = a1->shadow.c_lock[a2 + 0xF];
  if ( v6 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0x6Fu, v6, 0);
  }
  v7 = a1->shadow.c_prot[a2 + 0xF];
  if ( v7 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0x70u, v7, 0);
  }
  v8 = a1->shadow.indirect[a2 + 0xF];
  if ( v8 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 1u, v8, 0);
  }
  v9 = a1->shadow.callback[a2 + 0xF];
  if ( v9 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 7u, v9, 0);
  }
  v10 = a1->shadow.mod[a2 + 0xF];
  if ( v10 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0xAu, v10, 0);
  }
  v11 = a1->shadow.vol[a2 + 0xF];
  if ( v11 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0xBu, v11, 0);
  }
  v12 = a1->shadow.pan[a2 + 0xF];
  if ( v12 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0x40u, v12, 0);
  }
  v13 = a1->shadow.exp[a2 + 0xF];
  if ( v13 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0x5Bu, v13, 0);
  }
  v14 = a1->shadow.sus[a2 + 0xF];
  if ( v14 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 0x5Du, v14, 0);
  }
  v15 = a1->shadow.reverb[a2 + 0xF];
  if ( v15 != 0xFFFFFFFF )
  {
    sub_6EDE0(a1, a2 | 0xB0, 6u, v15, 0);
  }
}

//----- (0006F5C0) --------------------------------------------------------
_DWORD *__cdecl sub_6F5C0(_DWORD *a1)
{
  _DWORD *v1; // edx
  int i; // eax
  _DWORD *v3; // eax
  _DWORD *result; // eax

  v1 = a1;
  for ( i = 0; i < 0x10; ++i )
  {
    v1[0x24] = i;
    ++v1;
  }
  memset(a1 + 0x34, 0xFFFFFFFF, 0x440u);
  v3 = a1;
  do
  {
    ++v3;
    v3[0x1F] = 0xFFFFFFFF;
  }
  while ( v3 != a1 + 4 );
  result = a1;
  do
  {
    ++result;
    result[0x144] = 0xFFFFFFFF;
  }
  while ( result != a1 + 0x20 );
  a1[0x144] = 0;
  a1[0xB] = 0;
  a1[0x16] = 0;
  a1[0x17] = 0xFFFFFFFF;
  a1[0x1A] = 0;
  a1[0x19] = 0;
  a1[0x18] = 4;
  a1[0x1B] = 0x7A1200;
  a1[0xC] = 0;
  a1[0xA] = 1;
  return result;
}

//----- (0006F690) --------------------------------------------------------
void __cdecl sub_6F690(SEQUENCE *a1)
{
  SEQUENCE *v1; // esi
  int i; // edi
  ULONG v3; // edx

  v1 = a1;
  for ( i = 0; i < 0x10; ++i )
  {
    v3 = v1->shadow.callback[0xF];
    if ( v3 != 0xFFFFFFFF )
    {
      sub_6EDE0(a1, i | 0xB0, 7u, v3, 0);
    }
    v1 = (SEQUENCE *)((char *)v1 + 4);
  }
}

//----- (0006F6D0) --------------------------------------------------------
HSEQUENCE __cdecl sub_6F6D0(int a1)
{
  HSEQUENCE result; // eax
  HSEQUENCE v2; // eax
  LONG volume_period; // ebx
  LONG tempo_period; // ecx
  LONG v5; // esi
  int v6; // ecx
  SEQUENCE *v7; // ebx
  struct _MDI_DRIVER **v8; // eax
  int v9; // ebp
  HSEQUENCE v10; // eax
  int v11; // ebp
  LONG v12; // esi
  UBYTE *EVNT_ptr; // ebx
  UBYTE *v14; // ebx
  SEQUENCE *v15; // eax
  char *EOS; // edx
  HSEQUENCE v17; // eax
  char *EVNT; // ebx
  HSEQUENCE v19; // eax
  CALLBACK beat_callback; // esi
  HSEQUENCE v21; // ebx
  int v22; // eax
  char v23; // cl
  int v24; // eax
  HSEQUENCE v25; // eax
  int v26; // edi
  int v27; // eax
  UBYTE *v28; // ebp
  size_t v29; // ebx
  UBYTE *v30; // eax
  unsigned int v31; // esi
  unsigned int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // ebp
  HSEQUENCE v36; // eax
  int v37; // esi
  HSEQUENCE v38; // eax
  UBYTE *v39; // ebx
  HSEQUENCE v40; // eax
  LONG v41; // ebp
  LONG beat_fraction; // edx
  LONG tempo_error; // esi
  LONG measure_count; // edi
  LONG beat_count; // ebp
  HSEQUENCE v46; // eax
  LONG volume_target; // ebx
  LONG volume_accum; // edi
  LONG interval_num; // edx
  LONG v50; // ebp
  LONG volume; // ebx
  HSEQUENCE v52; // eax
  LONG tempo_target; // ebx
  LONG tempo_accum; // edx
  LONG v55; // esi
  LONG v56; // ecx
  LONG tempo_percent; // ebx
  ULONG v58; // [esp-8h] [ebp-20h]
  UBYTE **p_EVNT_ptr; // [esp-4h] [ebp-1Ch]
  VDI_CALL in; // [esp+0h] [ebp-18h] BYREF

  result = (HSEQUENCE)a1;
  if ( !*(_DWORD *)(a1 + 0x14) && !dword_988C8 )
  {
    dword_132D14 = *(_DWORD *)(a1 + 0x1C);
    dword_988C8 = 1;
    S = *(HSEQUENCE *)(a1 + 0x18);
    while ( dword_132D14 )
    {
      v2 = S;
      if ( S->status == 4 )
      {
        volume_period = S->volume_period;
        tempo_period = S->tempo_period;
        ++S->interval_count;
        dword_132D24 = 0;
        v2->tempo_period = volume_period + tempo_period;
        while ( 1 )
        {
          v5 = S->tempo_period;
          if ( v5 < 0x64 )
          {
            break;
          }
          v6 = S->shadow.chorus[0xF];
          S->tempo_period = v5 - 0x64;
          if ( v6 > 0 )
          {
            dword_132D10 = 0;
            do
            {
              v7 = S;
              v8 = &S->driver + dword_132D10;
              if ( v8[0x145] != (struct _MDI_DRIVER *)0xFFFFFFFF )
              {
                v9 = (int)&v8[0x185][0xFFFFFFFF].system_data[7] + 3;
                v8[0x185] = (struct _MDI_DRIVER *)v9;
                if ( v9 <= 0 )
                {
                  sub_6EDE0(v7, (unsigned __int8)v8[0x145] | 0x80, (unsigned int)v8[0x165], 0, 0);
                  v10 = S;
                  S->shadow.bend_range[dword_132D10] = 0xFFFFFFFF;
                  v11 = v10->shadow.chorus[0xF] - 1;
                  v10->shadow.chorus[0xF] = v11;
                  if ( !v11 )
                  {
                    break;
                  }
                }
              }
              ++dword_132D10;
            }
            while ( dword_132D10 < 0x20 );
          }
          v12 = S->loop_count - 1;
          S->loop_count = v12;
          if ( v12 <= 0 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                EVNT_ptr = S->EVNT_ptr;
                dword_132D20 = *EVNT_ptr;
                if ( (unsigned int)dword_132D20 < 0x80 || dword_132D24 )
                {
                  if ( !dword_132D24 )
                  {
                    v38 = S;
                    v39 = S->EVNT_ptr;
                    S->EVNT_ptr = v39 + 1;
                    v38->loop_count = *v39;
                  }
                  goto LABEL_67;
                }
                if ( (unsigned int)dword_132D20 >= 0xF7 )
                {
                  break;
                }
                if ( dword_132D20 != 0xF0 )
                {
                  goto LABEL_41;
                }
LABEL_38:
                dword_132D04 = (int)(S->EVNT_ptr + 1);
                v27 = sub_6E910(&dword_132D04);
                v28 = S->EVNT_ptr;
                dword_132D28 = dword_132D04 - (_DWORD)v28 + v27;
                v29 = dword_132D04 - (_DWORD)v28 + v27;
                sub_6E6E0(a1);
                if ( v29 > 0x200 )
                {
                  v29 = 0x200;
                }
                memmove((void *)(*(_DWORD *)(a1 + 8) + 0x100), v28, v29);
                ++*(_DWORD *)(a1 + 0x1A8);
                sub_6E6E0(a1);
                S->EVNT_ptr += dword_132D28;
              }
              if ( (unsigned int)dword_132D20 <= 0xF7 )
              {
                goto LABEL_38;
              }
              if ( dword_132D20 == 0xFF )
              {
                v14 = EVNT_ptr + 2;
                p_EVNT_ptr = &S->EVNT_ptr;
                dword_132D2C = v14[0xFFFFFFFF];
                S->EVNT_ptr = v14;
                dword_132D28 = sub_6E910(p_EVNT_ptr);
                if ( (unsigned int)dword_132D2C < 0x51 )
                {
                  if ( dword_132D2C != 0x2F )
                  {
                    goto LABEL_37;
                  }
                  dword_132D24 = 1;
                  v15 = S;
                  EOS = (char *)S->EOS;
                  if ( EOS && (S->EOS = EOS + 0xFFFFFFFF, EOS == (char *)1) )
                  {
                    AIL_stop_sequence(v15);
                    v19 = S;
                    beat_callback = S->beat_callback;
                    S->status = 2;
                    if ( !beat_callback )
                    {
                      goto LABEL_37;
                    }
                    ((void (__cdecl *)(HSEQUENCE))v19->beat_callback)(v19);
                    S->EVNT_ptr += dword_132D28;
                  }
                  else
                  {
                    v17 = S;
                    S->tempo_error = 0;
                    v17->beat_count = 0xFFFFFFFF;
                    EVNT = (char *)v17->EVNT;
                    v17->time_fraction = 0;
                    v17->EVNT_ptr = (UBYTE *)(EVNT + 8);
                    S->EVNT_ptr += dword_132D28;
                  }
                }
                else if ( (unsigned int)dword_132D2C <= 0x51 )
                {
                  dword_132D1C = S->EVNT_ptr[2] + (S->EVNT_ptr[1] << 8) + (*S->EVNT_ptr << 0x10);
                  S->beat_fraction = 0x10 * dword_132D1C;
                  S->EVNT_ptr += dword_132D28;
                }
                else
                {
                  if ( dword_132D2C == 0x58 )
                  {
                    v21 = S;
                    S->measure_count = *S->EVNT_ptr;
                    dword_132D1C = v21->EVNT_ptr[1] - 2;
                    v22 = 0xF42400 / (int)dword_133098;
                    v23 = dword_132D1C;
                    dword_132D18 = 0xF42400 / (int)dword_133098;
                    if ( dword_132D1C >= 0 )
                    {
                      v24 = v22 << dword_132D1C;
                    }
                    else
                    {
                      dword_132D1C = -dword_132D1C;
                      v24 = v22 >> -v23;
                    }
                    v21->time_numerator = v24;
                    v25 = S;
                    S->time_fraction = 0;
                    v25->tempo_error = 0;
                    v26 = v25->time_fraction - v25->time_numerator;
                    ++v25->beat_count;
                    v25->time_fraction = v26;
                  }
LABEL_37:
                  S->EVNT_ptr += dword_132D28;
                }
              }
              else
              {
LABEL_41:
                dword_132D08 = dword_132D20 & 0xF;
                v30 = S->EVNT_ptr;
                v58 = v30[2];
                v31 = v30[1];
                dword_132D20 &= 0xF0u;
                sub_6EDE0(S, *v30, v31, v58, 1);
                if ( dword_132D20 == 0x90 )
                {
                  v34 = 0;
                  dword_132D10 = 0;
                  do
                  {
                    if ( S->shadow.bend_range[v34] == 0xFFFFFFFF )
                    {
                      break;
                    }
                    ++v34;
                    ++dword_132D10;
                  }
                  while ( v34 < 0x20 );
                  v35 = dword_132D10;
                  if ( dword_132D10 == 0x20 )
                  {
                    strcpy(&byte_132F70, "Internal note queue overflow\n");
                    AIL_stop_sequence(S);
                    result = S;
                    dword_988C8 = 0;
                    S->status = 2;
                    return result;
                  }
                  v36 = S;
                  v37 = dword_132D08;
                  ++S->shadow.chorus[0xF];
                  v36->shadow.bend_range[v35] = v37;
                  v36->note_chan[v35 + 0xF] = v36->EVNT_ptr[1];
                  v36->EVNT_ptr += 3;
                  S->note_num[dword_132D10 + 0xF] = sub_6E910(&v36->EVNT_ptr);
                }
                else
                {
                  v32 = *S->EVNT_ptr & 0xF0;
                  if ( v32 < 0xB0 )
                  {
                    if ( v32 < 0x90 )
                    {
                      if ( v32 == 0x80 )
                      {
                        goto LABEL_55;
                      }
                    }
                    else if ( v32 <= 0x90 || v32 == 0xA0 )
                    {
LABEL_55:
                      v33 = 3;
                      goto LABEL_58;
                    }
                  }
                  else
                  {
                    if ( v32 <= 0xB0 )
                    {
                      goto LABEL_55;
                    }
                    if ( v32 < 0xD0 )
                    {
                      if ( v32 == 0xC0 )
                      {
LABEL_56:
                        v33 = 2;
                        goto LABEL_58;
                      }
                    }
                    else
                    {
                      if ( v32 <= 0xD0 )
                      {
                        goto LABEL_56;
                      }
                      if ( v32 == 0xE0 )
                      {
                        goto LABEL_55;
                      }
                    }
                  }
                  v33 = 0;
LABEL_58:
                  S->EVNT_ptr += v33;
                }
              }
            }
          }
LABEL_67:
          if ( !dword_132D24 )
          {
            v40 = S;
            v41 = S->time_numerator + S->time_fraction;
            beat_fraction = S->beat_fraction;
            S->time_fraction = v41;
            if ( v41 >= beat_fraction )
            {
              tempo_error = v40->tempo_error;
              v40->time_fraction = v41 - beat_fraction;
              ++tempo_error;
              measure_count = v40->measure_count;
              v40->tempo_error = tempo_error;
              if ( tempo_error >= measure_count )
              {
                beat_count = v40->beat_count;
                v40->tempo_error = 0;
                v40->beat_count = beat_count + 1;
              }
            }
          }
        }
        if ( !dword_132D24 )
        {
          if ( S->interval_num != S->volume )
          {
            S->volume_target += S->driver->interval_time;
            do
            {
              v46 = S;
              volume_target = S->volume_target;
              volume_accum = S->volume_accum;
              if ( volume_target < volume_accum )
              {
                break;
              }
              interval_num = S->interval_num;
              v50 = volume_target - volume_accum;
              volume = S->volume;
              S->volume_target = v50;
              v46->interval_num = volume <= interval_num ? interval_num - 1 : interval_num + 1;
            }
            while ( S->interval_num != S->volume );
            if ( (S->interval_count & 7) == 0 )
            {
              sub_6F690(S);
            }
          }
          if ( S->volume_period != S->tempo_percent )
          {
            S->tempo_target += S->driver->interval_time;
            do
            {
              v52 = S;
              tempo_target = S->tempo_target;
              tempo_accum = S->tempo_accum;
              if ( tempo_target < tempo_accum )
              {
                break;
              }
              v55 = S->volume_period;
              v56 = tempo_target - tempo_accum;
              tempo_percent = S->tempo_percent;
              S->tempo_target = v56;
              v52->volume_period = tempo_percent <= v55 ? v55 - 1 : v55 + 1;
            }
            while ( S->volume_period != S->tempo_percent );
          }
        }
      }
      --dword_132D14;
      S = (HSEQUENCE)((char *)S + 0x6D4);
    }
    result = (HSEQUENCE)a1;
    if ( *(int *)(a1 + 0x1A8) > 0 )
    {
      in.CX = *(_WORD *)(a1 + 0x1A8);
      AIL_call_driver(*(AIL_DRIVER **)a1, 0x502, &in, 0);
      result = (HSEQUENCE)a1;
      *(_DWORD *)(a1 + 0x1A8) = 0;
      *(_DWORD *)(a1 + 0x1AC) = 0;
    }
    dword_988C8 = 0;
  }
  return result;
}
// 988C8: using guessed type int dword_988C8;
// 132D04: using guessed type int dword_132D04;
// 132D08: using guessed type int dword_132D08;
// 132D10: using guessed type int dword_132D10;
// 132D14: using guessed type int dword_132D14;
// 132D18: using guessed type int dword_132D18;
// 132D1C: using guessed type int dword_132D1C;
// 132D20: using guessed type int dword_132D20;
// 132D24: using guessed type int dword_132D24;
// 132D28: using guessed type int dword_132D28;
// 132D2C: using guessed type int dword_132D2C;

//----- (0006FE00) --------------------------------------------------------
LONG __cdecl sub_6FE00(AIL_DRIVER **a1, const void *a2)
{
  ULONG size; // eax
  _WORD *v3; // ebx
  unsigned int i; // eax
  int v6[9]; // [esp+0h] [ebp-24h] BYREF

  qmemcpy(v6, a2, 0x18u);
  size = (*a1)->size;
  if ( *(_WORD *)(size + 0x10) )
  {
    v3 = (_WORD *)(0x10 * HIWORD(*(_DWORD *)(size + 0xC)) + (unsigned __int16)*(_DWORD *)(size + 0xC));
    if ( SLOWORD(v6[0]) < 1 )
    {
      LOWORD(v6[0]) = *v3;
    }
    if ( SHIWORD(v6[0]) < 1 )
    {
      HIWORD(v6[0]) = v3[1];
    }
    if ( SLOWORD(v6[1]) < 1 )
    {
      LOWORD(v6[1]) = v3[2];
    }
    if ( SHIWORD(v6[1]) < 1 )
    {
      HIWORD(v6[1]) = v3[3];
    }
    for ( i = 0; i != 0x10; i += 4 )
    {
      if ( v6[i / 4 + 2] < 1 )
      {
        v6[i / 4 + 2] = *(_DWORD *)&v3[i / 2 + 4];
      }
    }
  }
  qmemcpy((void *)((*a1)->size + 0x16), v6, 0x18u);
  return AIL_call_driver(*a1, 0x304, 0, 0);
}

//----- (0006FED0) --------------------------------------------------------
int __cdecl sub_6FED0(void *ptr)
{
  int v1; // edi
  int v2; // esi

  v1 = 0;
  if ( *((int *)ptr + 7) > 0 )
  {
    v2 = 0;
    do
    {
      ++v1;
      AIL_end_sequence((HSEQUENCE)(v2 + *((_DWORD *)ptr + 6)));
      v2 += 0x6D4;
    }
    while ( v1 < *((_DWORD *)ptr + 7) );
  }
  AIL_release_timer_handle(*((_DWORD *)ptr + 3));
  sub_661FF(*((void **)ptr + 6));
  return sub_661FF(ptr);
}

//----- (0006FF30) --------------------------------------------------------
_DWORD *__cdecl sub_6FF30(int drvr, const void *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // ebp
  const char *v4; // eax
  char *v5; // eax
  char *v6; // edx
  const char *v7; // esi
  char *v8; // edi
  char v9; // al
  char v10; // al
  char *v11; // esi
  char *v12; // edi
  char v13; // al
  char v14; // al
  IO_PARMS *IO_environment; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  void *v19; // eax
  int v20; // esi
  int v21; // eax
  int v22; // eax
  __int64 v23; // rtt
  _DWORD *v24; // esi
  HTIMER v25; // eax
  int v26; // edi
  char v27[24]; // [esp+0h] [ebp-50h] BYREF
  VDI_CALL out; // [esp+18h] [ebp-38h] BYREF
  VDI_CALL in; // [esp+24h] [ebp-2Ch] BYREF
  const void *v30; // [esp+30h] [ebp-20h]
  IO_PARMS *v31; // [esp+34h] [ebp-1Ch]
  int v32; // [esp+38h] [ebp-18h]
  int v33; // [esp+3Ch] [ebp-14h]
  int v34; // [esp+40h] [ebp-10h]

  sub_6E580();
  result = sub_661DE(0x1D0u);
  v3 = result;
  if ( result )
  {
    *result = drvr;
    if ( *(_DWORD *)(drvr + 0x10) == 1 )
    {
      AIL_call_driver((AIL_DRIVER *)drvr, 0x301, 0, &out);
      v3[1] = (unsigned __int16)out.AX + 0x10 * (unsigned __int16)out.DX;
      v3[2] = (unsigned __int16)out.BX + 0x10 * (unsigned __int16)out.CX;
      v4 = (const char *)(0x10 * HIWORD(*(_DWORD *)v3[1]) + (unsigned __int16)*(_DWORD *)v3[1]);
      if ( v4 )
      {
        if ( *v4 )
        {
          v5 = getenv(v4);
          if ( v5 )
          {
            if ( *v5 )
            {
              strncpy((char *)v3[2], v5, 0x80u);
            }
          }
        }
      }
      v6 = (char *)(0x10 * HIWORD(*(_DWORD *)(v3[1] + 4)) + (unsigned __int16)*(_DWORD *)(v3[1] + 4));
      if ( v6 && *v6 )
      {
        v7 = "SAMPLE";
        v8 = (char *)(v3[2] + 0x80);
        do
        {
          v9 = *v7;
          *v8 = *v7;
          if ( !v9 )
          {
            break;
          }
          v10 = v7[1];
          v7 += 2;
          v8[1] = v10;
          v8 += 2;
        }
        while ( v10 );
        v11 = v6;
        v12 = (char *)(v3[2] + 0x80 + strlen((const char *)(v3[2] + 0x80)));
        do
        {
          v13 = *v11;
          *v12 = *v11;
          if ( !v13 )
          {
            break;
          }
          v14 = v11[1];
          v11 += 2;
          v12[1] = v14;
          v12 += 2;
        }
        while ( v14 );
      }
      else
      {
        *(_BYTE *)(v3[2] + 0x80) = 0;
      }
      memset(&unk_1330B8, 0xFFFFFFFF, 0x18u);
      v32 = 0;
      if ( a2 )
      {
        qmemcpy(&unk_1330B8, a2, 0x18u);
        if ( sub_6FE00((AIL_DRIVER **)v3, a2) )
        {
          v32 = 1;
          qmemcpy(v27, a2, sizeof(v27));
        }
      }
      if ( !v32 )
      {
        IO_environment = AIL_get_IO_environment((AIL_DRIVER *)*v3);
        v31 = IO_environment;
        if ( IO_environment )
        {
          qmemcpy(&unk_1330B8, IO_environment, 0x18u);
          if ( sub_6FE00((AIL_DRIVER **)v3, IO_environment) )
          {
            v32 = 1;
            qmemcpy(v27, v31, sizeof(v27));
          }
        }
      }
      if ( !v32 && dword_1330B0 == 1 )
      {
        v34 = v32;
        v33 = v32;
        while ( 1 )
        {
          v17 = *(_DWORD *)(*v3 + 0xC);
          if ( *(unsigned __int16 *)(v17 + 0x10) <= v34 )
          {
            break;
          }
          v16 = 0x10 * HIWORD(*(_DWORD *)(v17 + 0xC)) + (unsigned __int16)*(_DWORD *)(v17 + 0xC);
          v30 = (const void *)(v16 + v33);
          if ( !v34 )
          {
            qmemcpy(&unk_1330B8, (const void *)(v16 + v33), 0x18u);
          }
          if ( sub_6FE00((AIL_DRIVER **)v3, v30) )
          {
            v32 = 1;
            qmemcpy(v27, v30, sizeof(v27));
            break;
          }
          v33 += 0x18;
          ++v34;
        }
      }
      if ( v32 )
      {
        qmemcpy(&unk_1330B8, v27, 0x18u);
        AIL_call_driver((AIL_DRIVER *)*v3, 0x305, 0, 0);
        *(_DWORD *)(*v3 + 0x14) = 1;
        AIL_call_driver((AIL_DRIVER *)*v3, 0x501, 0, &out);
        if ( out.AX )
        {
          v18 = dword_13309C;
          v3[7] = dword_13309C;
          v19 = sub_661DE(0x6D4 * v18);
          v3[6] = v19;
          if ( v19 )
          {
            v20 = 0;
            if ( (int)v3[7] > 0 )
            {
              v21 = 0;
              do
              {
                *(_DWORD *)(v3[6] + v21 + 4) = 1;
                *(_DWORD *)(v3[6] + v21) = v3;
                ++v20;
                v21 += 0x6D4;
              }
              while ( v20 < v3[7] );
            }
            LODWORD(v23) = &unk_F4240;
            HIDWORD(v23) = (int)&unk_F4240 >> 0x1F;
            v22 = v23 / (int)dword_133098;
            v3[0x68] = 0;
            v3[0x69] = 0;
            v3[0x6A] = 0;
            v3[0x6B] = 0;
            v3[5] = 0;
            v24 = v3;
            v3[4] = v22;
            do
            {
              ++v24;
              v24[7] = 0;
              v24[0x17] = 0;
              v24[0x27] = 0;
              v24[0x37] = 0;
              v24[0x47] = 0;
              v24[0x57] = 0;
            }
            while ( v24 != v3 + 0x10 );
            v25 = AIL_register_timer(sub_6F6D0);
            v3[3] = v25;
            if ( v25 == 0xFFFFFFFF )
            {
              strcpy(&byte_132F70, "Out of timer handles\n");
              AIL_call_driver((AIL_DRIVER *)*v3, 0x306, 0, 0);
              *(_DWORD *)(*v3 + 0x14) = 0;
              sub_661FF((void *)v3[6]);
              sub_661FF(v3);
              return 0;
            }
            else
            {
              AIL_set_timer_user(v25, (ULONG)v3);
              *(_DWORD *)(*v3 + 0x20) = sub_6FED0;
              v26 = 0;
              *(_DWORD *)(*v3 + 0x24) = v3;
              do
              {
                sub_6E730((int)v3, v26 | 0xB0, 0x72, 0);
                sub_6E730((int)v3, v26 | 0xC0, 0, 0);
                sub_6E730((int)v3, v26 | 0xE0, 0, 0x40);
                sub_6E730((int)v3, v26 | 0xB0, 0x70, 0);
                sub_6E730((int)v3, v26 | 0xB0, 1, 0);
                sub_6E730((int)v3, v26 | 0xB0, 7, dword_1330A0);
                sub_6E730((int)v3, v26 | 0xB0, 0xA, 0x40);
                sub_6E730((int)v3, v26 | 0xB0, 0xB, 0x7F);
                sub_6E730((int)v3, v26 | 0xB0, 0x40, 0);
                sub_6E730((int)v3, v26 | 0xB0, 0x5B, 0x28);
                sub_6E730((int)v3, v26 | 0xB0, 0x5D, 0);
                sub_6E730((int)v3, v26 | 0xB0, 0x64, 0);
                sub_6E730((int)v3, v26 | 0xB0, 0x65, 0);
                sub_6E730((int)v3, v26 | 0xB0, 0x26, 0);
                sub_6E730((int)v3, v26 | 0xB0, 6, dword_1330AC);
                if ( (int)v3[0x6A] > 0 )
                {
                  in.CX = *((_WORD *)v3 + 0xD4);
                  AIL_call_driver((AIL_DRIVER *)*v3, 0x502, &in, 0);
                  v3[0x6A] = 0;
                  v3[0x6B] = 0;
                }
                if ( (v26 & 3) == 0 )
                {
                  AIL_delay(3);
                }
                ++v26;
              }
              while ( v26 < 0x10 );
              AIL_set_timer_frequency(v3[3], dword_133098);
              AIL_start_timer(v3[3]);
              return v3;
            }
          }
          else
          {
            strcpy(&byte_132F70, "Could not allocate SEQUENCE structures\n");
            AIL_call_driver((AIL_DRIVER *)*v3, 0x306, 0, 0);
            *(_DWORD *)(*v3 + 0x14) = 0;
            sub_661FF(v3);
            return 0;
          }
        }
        else
        {
          strcpy(&byte_132F70, "Could not initialize instrument manager\n");
          AIL_call_driver((AIL_DRIVER *)*v3, 0x306, 0, 0);
          *(_DWORD *)(*v3 + 0x14) = 0;
          sub_661FF(v3);
          return 0;
        }
      }
      else
      {
        strcpy(&byte_132F70, "XMIDI sound hardware not found\n");
        sub_661FF(v3);
        return 0;
      }
    }
    else
    {
      strcpy(&byte_132F70, ".MDI driver required\n");
      sub_661FF(result);
      return 0;
    }
  }
  else
  {
    strcpy(&byte_132F70, "Could not allocate memory for driver\n");
  }
  return result;
}
// 13309C: using guessed type int dword_13309C;
// 1330A0: using guessed type int dword_1330A0;
// 1330AC: using guessed type int dword_1330AC;
// 1330B0: using guessed type int dword_1330B0;

//----- (000705D0) --------------------------------------------------------
UBYTE *__cdecl sub_705D0(char *path, int a2)
{
  UBYTE *result; // eax
  UBYTE *v3; // esi
  ULONG v4; // eax
  AIL_DRIVER *v5; // edi
  _DWORD *v6; // esi

  result = (UBYTE *)sub_66996(path, 0);
  v3 = result;
  if ( result )
  {
    v4 = sub_6694A(path);
    v5 = AIL_install_driver(v3, v4);
    off_987B0(v3);
    if ( v5 )
    {
      v6 = sub_6FF30((int)v5, (const void *)a2);
      if ( !v6 )
      {
        AIL_uninstall_driver(v5);
      }
      return (UBYTE *)v6;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    strcpy(&byte_132F70, "Driver file not found\n");
  }
  return result;
}
// 987B0: using guessed type int (__fastcall *off_987B0)(_DWORD);

//----- (00070650) --------------------------------------------------------
AIL_DRIVER *__cdecl sub_70650(void *s2, size_t n, int a3)
{
  AIL_DRIVER *result; // eax
  AIL_DRIVER *v4; // esi
  _DWORD *v5; // edi

  result = AIL_install_driver((UBYTE *)s2, n);
  v4 = result;
  if ( result )
  {
    v5 = sub_6FF30((int)result, (const void *)a3);
    if ( !v5 )
    {
      AIL_uninstall_driver(v4);
    }
    return (AIL_DRIVER *)v5;
  }
  return result;
}

//----- (00070690) --------------------------------------------------------
HMDIDRIVER sub_70690()
{
  HMDIDRIVER result; // eax
  AIL_INI INI; // [esp+0h] [ebp-120h] BYREF

  result = (HMDIDRIVER)AIL_read_INI(&INI, "MDI.INI");
  if ( result )
  {
    return AIL_install_MDI_driver_file(INI.driver_name, &INI.IO);
  }
  strcpy(&byte_132F70, "Unable to open file MDI.INI\n");
  return result;
}

//----- (000706F0) --------------------------------------------------------
void __cdecl sub_706F0(AIL_DRIVER **a1)
{
  AIL_uninstall_driver(*a1);
}

//----- (00070700) --------------------------------------------------------
int __cdecl sub_70700(char *a1)
{
  char *v2; // edi
  char v3; // al
  char v4; // al
  int result; // eax
  unsigned int v6; // kr04_4
  unsigned int v7; // edx
  unsigned int v8; // kr08_4

  v2 = "SAMPLE";
  do
  {
    v3 = *a1;
    *v2 = *a1;
    if ( !v3 )
    {
      break;
    }
    v4 = a1[1];
    a1 += 2;
    v2[1] = v4;
    v2 += 2;
  }
  while ( v4 );
  result = 0;
  v6 = strlen("SAMPLE") + 1;
  v7 = v6 - 2;
  if ( v6 != 2 )
  {
    while ( 1 )
    {
      result = (unsigned __int8)aSample[v7];
      if ( result == 0x5C )
      {
        break;
      }
      if ( result == 0x2E )
      {
        BYTE1(result) = 0;
        aSample[v7] = 0;
        return result;
      }
      if ( !--v7 )
      {
        return result;
      }
    }
    result = 0;
    v8 = strlen("SAMPLE") + 1;
    if ( v7 == v8 - 2 )
    {
      aSample[v8 - 2] = 0;
    }
  }
  return result;
}

//----- (00070780) --------------------------------------------------------
_DWORD *__cdecl sub_70780(int a1)
{
  int v1; // eax
  int v2; // edx
  _DWORD *v4; // esi
  _DWORD *v5; // eax

  sub_66FC8();
  v1 = 0;
  if ( *(int *)(a1 + 0x1C) > 0 )
  {
    v2 = *(_DWORD *)(a1 + 0x18);
    do
    {
      if ( *(_DWORD *)(v2 + 4) == 1 )
      {
        break;
      }
      ++v1;
      v2 += 0x6D4;
    }
    while ( v1 < *(_DWORD *)(a1 + 0x1C) );
  }
  if ( v1 == *(_DWORD *)(a1 + 0x1C) )
  {
    strcpy(&byte_132F70, "Out of sequence handles\n");
    sub_66FCD(v1);
    return 0;
  }
  else
  {
    v4 = (_DWORD *)(0x6D4 * v1 + *(_DWORD *)(a1 + 0x18));
    v4[1] = 2;
    v5 = sub_6F5C0(v4);
    sub_66FCD((int)v5);
    return v4;
  }
}

//----- (00070800) --------------------------------------------------------
void __cdecl sub_70800(HSEQUENCE S)
{
  if ( S )
  {
    AIL_stop_sequence(S);
    S->status = 1;
  }
}

//----- (00070820) --------------------------------------------------------
int __cdecl sub_70820(AIL_DRIVER ***a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // edi
  unsigned int v5; // esi
  AIL_DRIVER **v6; // eax
  int v7; // eax
  AIL_DRIVER **v8; // ebp
  _WORD *v9; // edi
  unsigned int v10; // esi
  unsigned int v11; // edx
  char *i; // eax
  unsigned __int16 v13; // bx
  int v14; // eax
  AIL_DRIVER **v15; // esi
  VDI_CALL v16; // [esp+0h] [ebp-24h] BYREF
  VDI_CALL in; // [esp+Ch] [ebp-18h] BYREF

  if ( !a1 )
  {
    return 0;
  }
  a1[1] = (AIL_DRIVER **)2;
  result = sub_6E980(a2, a3);
  if ( !result )
  {
    strcpy(&byte_132F70, "Invalid XMIDI sequence\n");
    return result;
  }
  v4 = result
     + ((*(_DWORD *)(result + 4) & 0xFF00) << 8)
     + ((unsigned __int8)*(_DWORD *)(result + 4) << 0x18)
     + ((*(_DWORD *)(result + 4) & 0xFF0000u) >> 8)
     + ((*(_DWORD *)(result + 4) & 0xFF000000) >> 0x18)
     + 8;
  a1[2] = 0;
  a1[3] = 0;
  v5 = result + 0xC;
  for ( a1[4] = 0;
        v5 < v4;
        v5 += ((*(_DWORD *)(v5 + 4) & 0xFF00) << 8)
            + ((unsigned __int8)*(_DWORD *)(v5 + 4) << 0x18)
            + ((*(_DWORD *)(v5 + 4) & 0xFF0000u) >> 8)
            + ((*(_DWORD *)(v5 + 4) & 0xFF000000) >> 0x18)
            + 8 )
  {
    if ( !strncmp((const char *)v5, "TIMB", 4u) )
    {
      a1[2] = (AIL_DRIVER **)v5;
    }
    if ( !strncmp((const char *)v5, "RBRN", 4u) )
    {
      a1[3] = (AIL_DRIVER **)v5;
    }
    if ( !strncmp((const char *)v5, "EVNT", 4u) )
    {
      a1[4] = (AIL_DRIVER **)v5;
    }
  }
  if ( !a1[4] )
  {
    result = 0;
    strcpy(&byte_132F70, "Invalid XMIDI sequence\n");
    return result;
  }
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[0xA] = (AIL_DRIVER **)1;
  sub_6F5C0(a1);
  v6 = a1[4];
  a1[0x10] = 0;
  a1[0xF] = 0;
  a1[0x11] = (AIL_DRIVER **)0x64;
  a1[0x12] = (AIL_DRIVER **)0x64;
  a1[0x14] = 0;
  a1[0x13] = 0;
  a1[0x15] = 0;
  a1[5] = v6 + 2;
  v7 = dword_1330A0;
  a1[0xD] = (AIL_DRIVER **)dword_1330A0;
  v8 = a1[2];
  a1[0xE] = (AIL_DRIVER **)v7;
  if ( !v8 )
  {
    return 1;
  }
  memmove(&unk_132D30, v8, 0x200u);
  if ( (*a1)[0x69] )
  {
    v9 = &unk_132D30;
    v10 = 0;
    while ( v10 < *((unsigned __int16 *)&unk_132D30 + 4) )
    {
      if ( ((int (__cdecl *)(AIL_DRIVER **, int, _DWORD))(*a1)[0x69])(
             *a1,
             (unsigned __int16)(v9[5] & 0xFF00) >> 8,
             (unsigned __int8)v9[5]) )
      {
        v11 = v10 + 1;
        for ( i = (char *)&unk_132D30 + 2 * v10 + 2; ; *((_WORD *)i + 3) = *((_WORD *)i + 4) )
        {
          v13 = *((_WORD *)&unk_132D30 + 4);
          if ( v11 >= v13 )
          {
            break;
          }
          i += 2;
          ++v11;
        }
        v14 = *((unsigned __int8 *)&unk_132D30 + 5);
        *((_WORD *)&unk_132D30 + 4) = v13 - 1;
        *((_BYTE *)&unk_132D30 + 5) = v14 - 2;
        if ( v14 < 2 )
        {
          --*((_BYTE *)&unk_132D30 + 4);
        }
      }
      else
      {
        ++v9;
        ++v10;
      }
    }
  }
  if ( !*((_WORD *)&unk_132D30 + 4) )
  {
    return 1;
  }
  if ( sub_673CA() )
  {
    result = 0xFFFFFFFF;
    strcpy(&byte_132F70, "No timbres loaded\n");
    return result;
  }
  (*a1)[5] = (AIL_DRIVER *)((char *)(*a1)[5] + 1);
  v15 = *a1;
  if ( (int)(*a1)[0x6A] > 0 )
  {
    in.CX = *((_WORD *)v15 + 0xD4);
    AIL_call_driver(*v15, 0x502, &in, 0);
    v15[0x6A] = 0;
    v15[0x6B] = 0;
  }
  memmove(&(*a1)[2][5].destructor, &unk_132D30, 0x200u);
  AIL_call_driver(**a1, 0x503, 0, &v16);
  (*a1)[5] = (AIL_DRIVER *)((char *)(*a1)[5] + 0xFFFFFFFF);
  if ( v16.AX )
  {
    return 1;
  }
  sprintf(&byte_132F70, "Driver could not install timbre bank %u, patch %u\n", v16.BX >> 8, LOBYTE(v16.BX));
  return 0xFFFFFFFF;
}
// 673CA: using guessed type int sub_673CA(void);
// 1330A0: using guessed type int dword_1330A0;

//----- (00070BD0) --------------------------------------------------------
UBYTE *__cdecl sub_70BD0(HSEQUENCE S)
{
  char *EVNT; // eax
  UBYTE *result; // eax

  if ( S )
  {
    if ( S->status != 1 )
    {
      AIL_stop_sequence(S);
      sub_6F5C0(S);
      EVNT = (char *)S->EVNT;
      S->status = 4;
      result = (UBYTE *)(EVNT + 8);
      S->EVNT_ptr = result;
    }
  }
  return result;
}

//----- (00070C10) --------------------------------------------------------
void __cdecl sub_70C10(SEQUENCE *a1)
{
  SEQUENCE *v1; // esi
  MDI_DRIVER *driver; // ebp
  LONG v3; // edi

  if ( a1 && a1->status == 4 )
  {
    v1 = a1;
    a1->status = 8;
    sub_6F230(a1);
    driver = a1->driver;
    do
    {
      v3 = v1->FOR_loop_count[3];
      if ( v1->shadow.pan[0xF] >= 0x40 )
      {
        sub_6E730((int)driver, v3 | 0xB0, 0x40, 0);
      }
      if ( v1->shadow.c_lock[0xF] >= 0x40 )
      {
        driver->lock[v3] = 0;
      }
      if ( v1->shadow.c_prot[0xF] >= 0x40 )
      {
        sub_6E730((int)driver, v3 | 0xB0, 0x70, 0);
      }
      if ( v1->shadow.pitch_h[0xF] >= 0x40 )
      {
        AIL_release_channel(driver, v3 + 1);
      }
      v1 = (SEQUENCE *)((char *)v1 + 4);
    }
    while ( v1 != (SEQUENCE *)&a1->volume_accum );
  }
}
// 70C10: could not find valid save-restore pair for ebx

//----- (00070CE0) --------------------------------------------------------
void __cdecl sub_70CE0(SEQUENCE *a1)
{
  SEQUENCE *v1; // edi
  int v2; // esi
  int v3; // eax
  int i; // esi
  MDI_DRIVER *mdi; // [esp+0h] [ebp-10h]

  if ( a1 && a1->status == 8 )
  {
    v1 = a1;
    v2 = 0;
    mdi = a1->driver;
    do
    {
      if ( v1->shadow.pitch_h[0xF] >= 0x40 )
      {
        v3 = AIL_lock_channel(mdi) - 1;
        if ( v3 == 0xFFFFFFFF )
        {
          v3 = v2;
        }
        v1->FOR_loop_count[3] = v3;
      }
      ++v2;
      v1 = (SEQUENCE *)((char *)v1 + 4);
    }
    while ( v2 < 0x10 );
    for ( i = 0; i < 0x10; ++i )
    {
      sub_6F3B0(a1, i);
    }
    a1->status = 4;
  }
}

//----- (00070D70) --------------------------------------------------------
void __cdecl sub_70D70(HSEQUENCE S)
{
  if ( S )
  {
    if ( S->status != 1 )
    {
      AIL_stop_sequence(S);
      S->status = 2;
    }
  }
}

//----- (00070DA0) --------------------------------------------------------
int __cdecl sub_70DA0(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 0x28) = a2;
  }
  return result;
}

//----- (00070DB0) --------------------------------------------------------
int __cdecl sub_70DB0(_DWORD *a1, int a2, int a3)
{
  int v3; // esi
  signed int v4; // esi
  int result; // eax

  if ( a1 )
  {
    ++*(_DWORD *)(*a1 + 0x14);
    a1[0x12] = a2;
    v3 = a1[0x12];
    if ( a1[0x11] != v3 )
    {
      if ( a3 )
      {
        v4 = abs32(a1[0x11] - v3);
        a1[0x13] = 0;
        a1[0x14] = 0x3E8 * a3 / v4;
      }
      else
      {
        a1[0x11] = v3;
      }
    }
    result = *a1;
    --*(_DWORD *)(*a1 + 0x14);
  }
  return result;
}

//----- (00070E20) --------------------------------------------------------
struct _MDI_DRIVER *__cdecl sub_70E20(SEQUENCE *a1, LONG a2, int a3)
{
  LONG volume; // ecx
  struct _MDI_DRIVER *result; // eax
  signed int v5; // ecx

  if ( a1 )
  {
    ++a1->driver->disable;
    a1->volume = a2;
    volume = a1->volume;
    if ( a1->interval_num == volume )
    {
      result = a1->driver;
      --a1->driver->disable;
    }
    else
    {
      if ( a3 )
      {
        v5 = abs32(a1->interval_num - volume);
        a1->volume_target = 0;
        a1->volume_accum = 0x3E8 * a3 / v5;
      }
      else
      {
        a1->interval_num = volume;
      }
      sub_6F690(a1);
      result = a1->driver;
      --a1->driver->disable;
    }
  }
  return result;
}

//----- (00070EA0) --------------------------------------------------------
int __cdecl sub_70EA0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 4);
  }
  return result;
}

//----- (00070EB0) --------------------------------------------------------
unsigned int __cdecl sub_70EB0(int a1)
{
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 0x28);
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (00070ED0) --------------------------------------------------------
int __cdecl sub_70ED0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 0x44);
  }
  return result;
}

//----- (00070EE0) --------------------------------------------------------
int __cdecl sub_70EE0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 0x34);
  }
  return result;
}

//----- (00070EF0) --------------------------------------------------------
LONG __cdecl sub_70EF0(AIL_DRIVER **a1, __int16 a2, __int16 a3)
{
  VDI_CALL in; // [esp+0h] [ebp-Ch] BYREF

  in.CX = (a2 << 8) | a3;
  return AIL_call_driver(*a1, 0x504, &in, 0);
}

//----- (00070F30) --------------------------------------------------------
int __cdecl sub_70F30(int a1, int a2, int a3)
{
  int v4; // edi
  int v5; // ebp
  VDI_CALL in; // [esp+0h] [ebp-24h] BYREF
  VDI_CALL out; // [esp+Ch] [ebp-18h] BYREF

  if ( *(_DWORD *)(a1 + 0x1A4) && (*(int (__cdecl **)(int, int, int))(a1 + 0x1A4))(a1, a2, a3) )
  {
    return 1;
  }
  v4 = *(_DWORD *)(a1 + 0x14);
  v5 = *(_DWORD *)(a1 + 0x1A8);
  byte_988DA = a3;
  byte_988DB = a2;
  *(_DWORD *)(a1 + 0x14) = v4 + 1;
  if ( v5 > 0 )
  {
    in.CX = *(_WORD *)(a1 + 0x1A8);
    AIL_call_driver(*(AIL_DRIVER **)a1, 0x502, &in, 0);
    *(_DWORD *)(a1 + 0x1A8) = 0;
    *(_DWORD *)(a1 + 0x1AC) = 0;
  }
  memmove((void *)(*(_DWORD *)(a1 + 8) + 0x100), "TIMB", 0xCu);
  AIL_call_driver(*(AIL_DRIVER **)a1, 0x503, 0, &out);
  --*(_DWORD *)(a1 + 0x14);
  if ( !out.AX )
  {
    sprintf(&byte_132F70, "Driver could not install timbre bank %u, patch %u\n", out.BX >> 8, LOBYTE(out.BX));
  }
  return out.AX;
}
// 988DA: using guessed type char byte_988DA;
// 988DB: using guessed type char byte_988DB;

//----- (00071030) --------------------------------------------------------
LONG __cdecl sub_71030(AIL_DRIVER **a1, __int16 a2, __int16 a3)
{
  VDI_CALL in; // [esp+0h] [ebp-Ch] BYREF

  in.CX = (a2 << 8) | a3;
  in.DX = 1;
  return AIL_call_driver(*a1, 0x505, &in, 0);
}

//----- (00071070) --------------------------------------------------------
LONG __cdecl sub_71070(AIL_DRIVER **a1, __int16 a2, __int16 a3)
{
  VDI_CALL in; // [esp+0h] [ebp-Ch] BYREF

  in.CX = (a2 << 8) | a3;
  in.DX = 0;
  return AIL_call_driver(*a1, 0x505, &in, 0);
}

//----- (000710B0) --------------------------------------------------------
int __cdecl sub_710B0(int a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edx

  v1 = 0;
  v2 = 0;
  if ( *(int *)(a1 + 0x1C) > 0 )
  {
    v3 = *(_DWORD *)(a1 + 0x18);
    do
    {
      if ( *(_DWORD *)(v3 + 4) == 4 )
      {
        ++v1;
      }
      ++v2;
      v3 += 0x6D4;
    }
    while ( v2 < *(_DWORD *)(a1 + 0x1C) );
  }
  return v1;
}

//----- (000710E0) --------------------------------------------------------
int __cdecl sub_710E0(int a1, char a2, unsigned int a3)
{
  if ( a1 )
  {
    return sub_6EAA0(a1 + 0xD0, (a2 - 1) | 0xB0, a3);
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (00071110) --------------------------------------------------------
int __cdecl sub_71110(int a1, int a2)
{
  int v3; // eax
  int v4; // edx

  if ( !a1 )
  {
    return 0;
  }
  v3 = a1;
  v4 = 0;
  do
  {
    if ( a2 - 1 == *(_DWORD *)(v3 + 0x514) )
    {
      ++v4;
    }
    v3 += 4;
  }
  while ( v3 != a1 + 0x40 );
  return v4;
}

//----- (00071150) --------------------------------------------------------
void __cdecl sub_71150(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // edi
  int v4; // ecx
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // ebp

  if ( a1 )
  {
    v3 = dword_1330A4;
    ++*(_DWORD *)(*a1 + 0x14);
    v4 = 0;
    v5 = a1[0x16];
    v6 = a1[0x17];
    v7 = a1[0x1A];
    if ( v3 > 0 )
    {
      do
      {
        v8 = a1[0x1B];
        v7 += a1[0x19];
        if ( v7 >= v8 )
        {
          ++v5;
          v7 -= v8;
          if ( v5 >= a1[0x18] )
          {
            ++v6;
            v5 = 0;
          }
        }
        ++v4;
      }
      while ( v4 < dword_1330A4 );
    }
    if ( v6 < 0 )
    {
      v6 = 0;
    }
    if ( a3 )
    {
      *a3 = v6;
    }
    if ( a2 )
    {
      *a2 = v5;
    }
    --*(_DWORD *)(*a1 + 0x14);
  }
}
// 1330A4: using guessed type int dword_1330A4;

//----- (000711C0) --------------------------------------------------------
void __cdecl sub_711C0(_DWORD *a1, int a2)
{
  int v2; // edx
  int v3; // ebp
  int v4; // ecx
  int v5; // eax
  unsigned __int16 *v6; // edx
  int v7; // edx
  int v8; // eax
  int v9; // ebx
  _DWORD *v10; // eax

  if ( a1 )
  {
    v2 = a1[3];
    if ( v2 )
    {
      v3 = v2 + 0xA;
      v4 = *(__int16 *)(v2 + 8);
      v5 = 0;
      if ( v4 > 0 )
      {
        v6 = (unsigned __int16 *)(v2 + 0xA);
        do
        {
          if ( *v6 == a2 )
          {
            break;
          }
          ++v5;
          v6 += 3;
        }
        while ( v5 < v4 );
      }
      if ( v5 != v4 )
      {
        v7 = *(_DWORD *)(6 * v5 + v3 + 2);
        v8 = a1[4] + 8;
        a1[0xB] = 0;
        v9 = dword_1330A8;
        a1[5] = v7 + v8;
        if ( !v9 )
        {
          v10 = a1;
          do
          {
            ++v10;
            v10[0x1F] = 0xFFFFFFFF;
          }
          while ( v10 != a1 + 4 );
        }
      }
    }
  }
}
// 1330A8: using guessed type int dword_1330A8;

//----- (00071250) --------------------------------------------------------
int __cdecl sub_71250(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 0x1C);
    *(_DWORD *)(a1 + 0x1C) = a2;
    return v3;
  }
  return result;
}

//----- (00071270) --------------------------------------------------------
int __cdecl sub_71270(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 0x20);
    *(_DWORD *)(a1 + 0x20) = a2;
    return v3;
  }
  return result;
}

//----- (00071290) --------------------------------------------------------
int __cdecl sub_71290(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 0x24);
    *(_DWORD *)(a1 + 0x24) = a2;
    return v3;
  }
  return result;
}

//----- (000712B0) --------------------------------------------------------
int __cdecl sub_712B0(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 0x1A0);
  *(_DWORD *)(a1 + 0x1A0) = a2;
  return result;
}

//----- (000712D0) --------------------------------------------------------
int __cdecl sub_712D0(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 0x1A4);
  *(_DWORD *)(a1 + 0x1A4) = a2;
  return result;
}

//----- (000712F0) --------------------------------------------------------
int __cdecl sub_712F0(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    result = a1 + 4 * a2;
    *(_DWORD *)(result + 0x694) = a3;
  }
  return result;
}

//----- (00071310) --------------------------------------------------------
int __cdecl sub_71310(int a1, int a2)
{
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 4 * a2 + 0x694);
  }
  else
  {
    return 0;
  }
}

//----- (00071330) --------------------------------------------------------
int __cdecl sub_71330(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 0x18) = a2;
  }
  return result;
}

//----- (00071340) --------------------------------------------------------
unsigned int __cdecl sub_71340(_DWORD *a1)
{
  unsigned int v1; // ebp
  int v2; // edi
  _DWORD *v3; // eax
  int v4; // esi
  int v5; // ebx
  int v6; // esi
  _DWORD *v7; // eax
  unsigned int result; // eax
  SEQUENCE *v9; // edi
  SEQUENCE *v10; // esi
  LONG v11; // ebx
  LONG v12; // eax
  _DWORD *v13; // eax
  int v14; // esi
  void **v15; // [esp+0h] [ebp-18h]
  int v16; // [esp+4h] [ebp-14h]

  v1 = 0xFFFFFFFF;
  v2 = 0x7FFFFFFF;
  v3 = a1 + 8;
  v4 = 8;
  ++a1[5];
  do
  {
    if ( v4 != 9 )
    {
      v5 = v3[8];
      if ( v5 != 1 && v5 != 2 && v2 > v3[0x58] )
      {
        v2 = v3[0x58];
        v1 = v4;
      }
    }
    --v4;
    v3 += 0xFFFFFFFF;
  }
  while ( v4 >= 1 );
  if ( v1 == 0xFFFFFFFF )
  {
    v6 = 8;
    v7 = a1 + 8;
    do
    {
      if ( v6 != 9 && v7[8] != 1 && v2 > v7[0x58] )
      {
        v2 = v7[0x58];
        v1 = v6;
      }
      --v6;
      v7 += 0xFFFFFFFF;
    }
    while ( v6 >= 1 );
  }
  if ( v1 == 0xFFFFFFFF )
  {
    result = 0;
    --a1[5];
  }
  else
  {
    sub_6E730((int)a1, v1 | 0xB0, 0x40, 0);
    v9 = (SEQUENCE *)a1[6];
    v16 = a1[7];
    if ( v16 )
    {
      v15 = &v9->FOR_ptrs[3];
      do
      {
        if ( v9->status != 1 )
        {
          v10 = v9;
          do
          {
            v11 = v10->shadow.bend_range[0];
            if ( v11 != 0xFFFFFFFF && v1 == v9->FOR_loop_count[v11 + 3] )
            {
              v12 = v10->shadow.bend_range[0];
              LOBYTE(v12) = v11 | 0x80;
              sub_6EDE0(v9, v12, v10->note_chan[0xF], 0, 0);
              v10->shadow.bend_range[0] = 0xFFFFFFFF;
            }
            v10 = (SEQUENCE *)((char *)v10 + 4);
          }
          while ( v10 != (SEQUENCE *)v15 );
        }
        v9 = (SEQUENCE *)((char *)v9 + 0x6D4);
        --v16;
        v15 += 0x1B5;
      }
      while ( v16 );
    }
    v13 = &a1[v1];
    v13[0x18] = 0;
    v14 = v13[8];
    v13[8] = 1;
    v13[0x48] = v14;
    v13[0x28] = v13[0x38];
    result = v1 + 1;
    --a1[5];
  }
  return result;
}
// 6EDE0: using guessed type _DWORD __cdecl sub_6EDE0(HSEQUENCE S, _DWORD, _DWORD, ULONG marker, _DWORD);

//----- (000714E0) --------------------------------------------------------
_DWORD *__cdecl sub_714E0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  SEQUENCE *v3; // edi
  SEQUENCE *v4; // esi
  LONG v5; // ecx
  SEQUENCE *v6; // esi
  void **v7; // [esp+0h] [ebp-18h]
  int v8; // [esp+4h] [ebp-14h]
  int v9; // [esp+8h] [ebp-10h]

  v9 = a2 - 1;
  result = &a1[a2 - 1];
  if ( result[8] == 1 )
  {
    ++a1[5];
    result[8] = result[0x48];
    result[0x38] = result[0x28];
    sub_6E730((int)a1, v9 | 0xB0, 0x40, 0);
    v3 = (SEQUENCE *)a1[6];
    v8 = a1[7];
    if ( v8 )
    {
      v7 = &v3->FOR_ptrs[3];
      do
      {
        if ( v3->status != 1 )
        {
          v4 = v3;
          do
          {
            v5 = v4->shadow.bend_range[0];
            if ( v5 != 0xFFFFFFFF && v9 == v3->FOR_loop_count[v5 + 3] )
            {
              sub_6EDE0(v3, v5 | 0x80, v4->note_chan[0xF], 0, 0);
              v4->shadow.bend_range[0] = 0xFFFFFFFF;
            }
            v4 = (SEQUENCE *)((char *)v4 + 4);
          }
          while ( v4 != (SEQUENCE *)v7 );
        }
        v3 = (SEQUENCE *)((char *)v3 + 0x6D4);
        --v8;
        v7 += 0x1B5;
      }
      while ( v8 );
    }
    v6 = (SEQUENCE *)a1[v9 + 0x28];
    if ( v6 )
    {
      if ( v6->status != 1 )
      {
        sub_6F3B0(v6, v9);
      }
    }
    result = a1;
    --a1[5];
  }
  return result;
}

//----- (00071610) --------------------------------------------------------
_DWORD *__cdecl sub_71610(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax
  int v4; // edx

  result = a1;
  if ( a1 )
  {
    a1[a2 + 0x23] = a3 - 1;
    v4 = *a1 + 4 * a3;
    if ( *(_DWORD *)(v4 + 0x1C) == 1 && a1 != *(_DWORD **)(v4 + 0x5C) )
    {
      *(_DWORD *)(v4 + 0x5C) = a1;
    }
  }
  return result;
}

//----- (00071650) --------------------------------------------------------
int __cdecl sub_71650(int a1, int a2)
{
  if ( a1 )
  {
    return *(_DWORD *)(a1 + 4 * a2 + 0x8C) + 1;
  }
  else
  {
    return 0;
  }
}

//----- (00071670) --------------------------------------------------------
void __cdecl sub_71670(int a1, SEQUENCE *a2, int a3, unsigned int a4, ULONG a5)
{
  VDI_CALL in; // [esp+0h] [ebp-18h] BYREF

  ++*(_DWORD *)(a1 + 0x14);
  if ( a2 )
  {
    sub_6EDE0(a2, a3, a4, a5, 0);
  }
  else if ( !*(_DWORD *)(a1 + 0x1A0)
         || !(*(int (__cdecl **)(int, _DWORD, int, unsigned int, ULONG))(a1 + 0x1A0))(a1, 0, a3, a4, a5) )
  {
    sub_6E730(a1, a3, a4, a5);
  }
  if ( *(int *)(a1 + 0x1A8) > 0 )
  {
    in.CX = *(_WORD *)(a1 + 0x1A8);
    AIL_call_driver(*(AIL_DRIVER **)a1, 0x502, &in, 0);
    *(_DWORD *)(a1 + 0x1A8) = 0;
    *(_DWORD *)(a1 + 0x1AC) = 0;
  }
  --*(_DWORD *)(a1 + 0x14);
}

//----- (00071720) --------------------------------------------------------
LONG __cdecl sub_71720(_DWORD *a1, void *a2)
{
  int v2; // eax
  unsigned int v3; // ebp
  size_t v4; // ebx
  LONG result; // eax
  int v6; // [esp+0h] [ebp-14h] BYREF
  void *s2; // [esp+4h] [ebp-10h]

  ++a1[5];
  v6 = (int)a2 + 1;
  v2 = sub_6E910(&v6);
  s2 = a2;
  v3 = v2 + v6 - (_DWORD)a2;
  sub_6E6E0((int)a1);
  if ( v3 <= 0x200 )
  {
    v4 = v3;
  }
  else
  {
    v4 = 0x200;
  }
  memmove((void *)(a1[2] + 0x100), s2, v4);
  ++a1[0x6A];
  result = sub_6E6E0((int)a1);
  --a1[5];
  return result;
}

//----- (000717B0) --------------------------------------------------------
void sub_717B0()
{
  if ( dword_988CC )
  {
    sub_6633A();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    dword_988CC = 0;
  }
}
// 988CC: using guessed type int dword_988CC;

//----- (000718A4) --------------------------------------------------------
BOOL sub_718A4()
{
  BOOL result; // eax

  if ( !dword_988E0 )
  {
    sub_662D1((unsigned int)sub_718A4, (unsigned int)sub_72175);
    sub_6635F((unsigned int)&drvr, 0x40);
    sub_6635F((unsigned int)&hertz, 0x48);
    sub_6635F((unsigned int)&byte_132F70, 0x100);
    sub_6635F((unsigned int)&unk_1330B8, 0x18);
    sub_6635F((unsigned int)&dword_988DC, 4);
    result = sub_6635F((unsigned int)&dword_1330D0, 4);
    dword_988E0 = 1;
  }
  return result;
}
// 988DC: using guessed type int dword_988DC;
// 988E0: using guessed type int dword_988E0;
// 1330D0: using guessed type int dword_1330D0;

//----- (0007192D) --------------------------------------------------------
void __cdecl sub_7192D(AIL_DRIVER *drvr)
{
  if ( !dword_988DC )
  {
    dword_988DC = 1;
    dword_1330D0 = sub_67234();
    AIL_call_driver(drvr, 0x302, 0, 0);
    sub_67239(dword_1330D0);
    dword_988DC = 0;
  }
}
// 988DC: using guessed type int dword_988DC;
// 1330D0: using guessed type int dword_1330D0;

//----- (0007197C) --------------------------------------------------------
int __cdecl sub_7197C(char *s, int a2, int a3)
{
  size_t i; // ecx
  int v4; // edx
  int j; // edx
  int v6; // ebx
  int v8; // [esp+0h] [ebp-10h]
  int v9; // [esp+4h] [ebp-Ch]

  v8 = 0;
  v9 = 1;
  for ( i = 0; i < strlen(s); ++i )
  {
    v4 = (unsigned __int8)s[i];
    if ( v4 == 0x2D )
    {
      v9 = -v9;
    }
    else if ( (byte_96230[(unsigned __int8)(v4 + 1)] & 2) == 0 )
    {
      for ( j = 0; j < a2; ++j )
      {
        v6 = (unsigned __int8)byte_94F88[j];
        if ( toupper((unsigned __int8)s[i], j, v6) == v6 )
        {
          v8 = j + a2 * v8;
          break;
        }
      }
      if ( j == a2 )
      {
        break;
      }
    }
  }
  if ( a3 )
  {
    *(_DWORD *)a3 = &s[i];
  }
  return v9 * v8;
}
// 7903F: using guessed type int __fastcall toupper(_DWORD, _DWORD, _DWORD);

//----- (00071A1D) --------------------------------------------------------
int __cdecl sub_71A1D(int a1, char *filename)
{
  int result; // eax
  int v3; // ebp
  signed int i; // ecx
  size_t j; // ecx
  const char *v6; // esi
  char *v7; // edx
  const char *v8; // edx
  __int16 *v9; // eax
  __int16 v10[140]; // [esp+0h] [ebp-174h] BYREF
  char v11[92]; // [esp+118h] [ebp-5Ch] BYREF

  memset(v10, 0, sizeof(v10));
  memset(&v10[0x80], 0xFFFFFFFF, 0x18u);
  result = (int)fopen(filename, "rt");
  v3 = result;
  if ( !result )
  {
    return result;
  }
  while ( fgets(v11, 0x50, (FILE *)v3) && (*(_BYTE *)(v3 + 0xC) & 0x10) == 0 )
  {
    for ( i = strlen(v11) - 1; i >= 0 && (byte_96230[(unsigned __int8)(v11[i] + 1)] & 2) != 0; --i )
    {
      v11[i] = 0;
    }
    for ( j = 0; j < strlen(v11) && (byte_96230[(unsigned __int8)(v11[j] + 1)] & 2) != 0; ++j )
    {
      ;
    }
    v6 = &v11[j];
    while ( j < strlen(v11) && (byte_96230[(unsigned __int8)(v11[j] + 1)] & 2) == 0 )
    {
      ++j;
    }
    v7 = &v11[j];
    while ( j < strlen(v11) && (byte_96230[(unsigned __int8)(v11[j] + 1)] & 2) != 0 )
    {
      ++j;
    }
    if ( j < strlen(v11) )
    {
      *v7 = 0;
      if ( *v6 != 0x3B )
      {
        if ( !strnicmp(v6, "DRIVER", 7u) )
        {
          v8 = &v11[j];
          v9 = &v10[0x40];
          goto LABEL_22;
        }
        if ( !strnicmp(v6, "DEVICE", 7u) )
        {
          v8 = &v11[j];
          v9 = v10;
LABEL_22:
          strcpy((char *)v9, v8);
        }
        else if ( !strnicmp(v6, "IO_ADDR", 8u) )
        {
          v10[0x80] = sub_7197C(&v11[j], 0x10, 0);
        }
        else if ( !strnicmp(v6, "IRQ", 4u) )
        {
          v10[0x81] = sub_7197C(&v11[j], 0xA, 0);
        }
        else if ( !strnicmp(v6, "DMA_8_bit", 0xAu) )
        {
          v10[0x82] = sub_7197C(&v11[j], 0xA, 0);
        }
        else if ( !strnicmp(v6, "DMA_16_bit", 0xBu) )
        {
          v10[0x83] = sub_7197C(&v11[j], 0xA, 0);
        }
      }
    }
  }
  fclose((FILE *)v3);
  if ( strlen((const char *)&v10[0x40]) && strlen((const char *)v10) )
  {
    qmemcpy((void *)a1, v10, 0x118u);
    return 1;
  }
  else
  {
    strcpy(&byte_132F70, "Corrupted .INI file\n");
    return 0;
  }
}
// 71A1D: using guessed type char var_5C[92];

//----- (00071CE5) --------------------------------------------------------
int __cdecl sub_71CE5(int a1, ULONG a2)
{
  int v2; // edx

  v2 = *(&hertz + a1);
  *(&hertz + a1) = a2;
  return v2;
}

//----- (00071CFE) --------------------------------------------------------
AIL_DRIVER *__cdecl sub_71CFE(void *s2, size_t n)
{
  AIL_DRIVER *result; // eax
  AIL_DRIVER *v3; // ebp
  const char *buf; // eax
  unsigned int i; // ecx
  HTIMER v6; // eax

  result = (AIL_DRIVER *)sub_661DE(0x28u);
  v3 = result;
  if ( !result )
  {
    strcpy(&byte_132F70, "Insufficient memory for driver descriptor\n");
    return result;
  }
  if ( !sub_66220((n + 0xF) >> 4, &result->buf, result, &result->sel) )
  {
    strcpy(&byte_132F70, "Insufficient low memory\n");
    sub_661FF(v3);
    return 0;
  }
  memmove(v3->buf, s2, n);
  buf = (const char *)v3->buf;
  v3->size = (ULONG)buf;
  if ( !strnicmp(buf, "AIL3DIG", 7u) )
  {
    v3->VHDR = 0;
  }
  else
  {
    if ( strnicmp((const char *)v3->size, "AIL3MDI", 7u) )
    {
      strcpy(&byte_132F70, "Invalid driver type\n");
      sub_662A5((int)v3->buf, v3->seg, v3->sel);
LABEL_9:
      sub_661FF(v3);
      return 0;
    }
    v3->VHDR = (VDI_HDR *)1;
  }
  for ( i = 0; i < 0x10; ++i )
  {
    if ( !*(&drvr + i) )
    {
      *(&drvr + i) = v3;
      *(_WORD *)(v3->size + 0x32) = i;
      break;
    }
  }
  if ( i == 0x10 )
  {
    strcpy(&byte_132F70, "Out of driver handles\n");
    sub_662A5((int)v3->buf, v3->seg, v3->sel);
    goto LABEL_9;
  }
  *(_WORD *)(v3->size + 0x30) = 0;
  v3->type = 0;
  v3->initialized = 0xFFFFFFFF;
  *(_DWORD *)(v3->size + 0x36) = AIL_get_real_vect(0x66u);
  AIL_set_real_vect(0x66u, v3->seg + *(unsigned __int16 *)(v3->size + 0x34));
  v3->server = 0;
  v3->destructor = 0;
  AIL_call_driver(v3, 0x300, 0, 0);
  if ( *(__int16 *)(v3->size + 0x2E) > 0 )
  {
    v6 = AIL_register_timer(sub_7192D);
    v3->PM_ISR = v6;
    if ( v6 == 0xFFFFFFFF )
    {
      strcpy(&byte_132F70, "Out of timer handles\n");
      AIL_set_real_vect(0x66u, *(_DWORD *)(v3->size + 0x36));
      sub_662A5((int)v3->buf, v3->seg, v3->sel);
      goto LABEL_9;
    }
    AIL_set_timer_user(v6, (ULONG)v3);
    AIL_set_timer_frequency(v3->PM_ISR, *(__int16 *)(v3->size + 0x2E));
    AIL_start_timer(v3->PM_ISR);
  }
  else
  {
    v3->PM_ISR = 0xFFFFFFFF;
  }
  return v3;
}

//----- (00071F2E) --------------------------------------------------------
int __cdecl sub_71F2E(void *ptr)
{
  int result; // eax
  int i; // edx

  if ( *((_DWORD *)ptr + 8) )
  {
    (*((void (__cdecl **)(_DWORD))ptr + 8))(*((_DWORD *)ptr + 9));
  }
  if ( *((_DWORD *)ptr + 7) != 0xFFFFFFFF )
  {
    AIL_release_timer_handle(*((_DWORD *)ptr + 7));
  }
  if ( *((_DWORD *)ptr + 5) )
  {
    if ( *((_DWORD *)ptr + 6) != 0xFFFFFFFF )
    {
      AIL_restore_USE16_ISR(*((_DWORD *)ptr + 6));
    }
    AIL_call_driver((AIL_DRIVER *)ptr, 0x306, 0, 0);
  }
  AIL_set_real_vect(0x66u, *(_DWORD *)(*((_DWORD *)ptr + 3) + 0x36));
  sub_662A5(*((_DWORD *)ptr + 2), *(_DWORD *)ptr, *((_DWORD *)ptr + 1));
  result = sub_661FF(ptr);
  for ( i = 0; i < 0x10; ++i )
  {
    result = 4 * i;
    if ( ptr == *(&drvr + i) )
    {
      *(&drvr + i) = 0;
    }
  }
  return result;
}

//----- (00071FD1) --------------------------------------------------------
char *__cdecl sub_71FD1(int drvr)
{
  char *result; // eax

  result = (char *)(0x10 * HIWORD(*(_DWORD *)(*(_DWORD *)(drvr + 0xC) + 0x12))
                  + (unsigned __int16)*(_DWORD *)(*(_DWORD *)(drvr + 0xC) + 0x12));
  if ( result )
  {
    result = getenv(result);
    if ( result )
    {
      strncpy((char *)(*(_DWORD *)(drvr + 0xC) + 0x3A), result, 0x80u);
      if ( AIL_call_driver((AIL_DRIVER *)drvr, 0x303, 0, 0) == 0xFFFFFFFF )
      {
        return 0;
      }
      else
      {
        qmemcpy(&unk_1330D4, (const void *)(*(_DWORD *)(drvr + 0xC) + 0x16), 0x18u);
        return (char *)&unk_1330D4;
      }
    }
  }
  return result;
}

//----- (00072042) --------------------------------------------------------
void __fastcall sub_72042(int a1, unsigned __int16 a2)
{
  int i; // eax

  sub_718A4();
  AIL_set_preference(0, 0xC8);
  AIL_set_preference(1u, 1);
  AIL_set_preference(2u, 0x8000);
  AIL_set_preference(3u, 0x64);
  AIL_set_preference(4u, 0x10);
  AIL_set_preference(5u, 0x64);
  AIL_set_preference(6u, 0x28F);
  AIL_set_preference(7u, 0);
  AIL_set_preference(8u, 0);
  AIL_set_preference(9u, 1);
  AIL_set_preference(0xAu, 0x78);
  AIL_set_preference(0xBu, 8);
  AIL_set_preference(0xCu, 0x7F);
  AIL_set_preference(0xDu, 1);
  AIL_set_preference(0xEu, 0);
  AIL_set_preference(0xFu, 2);
  AIL_set_preference(0x10u, 1);
  AIL_set_preference(0x11u, 1);
  for ( i = 0; i < 0x10; ++i )
  {
    *(&drvr + i) = 0;
  }
  BYTE1(i) = 0;
  byte_132F70 = 0;
  sub_743FC(i, a2);
}

//----- (00072148) --------------------------------------------------------
int sub_72148()
{
  int i; // esi

  for ( i = 0xF; i >= 0; --i )
  {
    if ( *(&drvr + i) )
    {
      AIL_uninstall_driver(*(&drvr + i));
    }
  }
  AIL_release_all_timers();
  return sub_744EA();
}

//----- (00072175) --------------------------------------------------------
void sub_72175()
{
  if ( dword_988E0 )
  {
    sub_6633A();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    sub_66376();
    dword_988E0 = 0;
  }
}
// 988E0: using guessed type int dword_988E0;

//----- (000725FC) --------------------------------------------------------
int __usercall sub_725FC@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    result = v3 ^ 0x8000;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007260D) --------------------------------------------------------
int __usercall sub_7260D@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072619) --------------------------------------------------------
int __usercall sub_72619@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    BYTE1(v4) ^= 0x80u;
    LOBYTE(v4) = BYTE1(result);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072638) --------------------------------------------------------
int __usercall sub_72638@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    LOBYTE(v4) = BYTE1(result);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007264C) --------------------------------------------------------
char __usercall sub_7264C@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // ax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    HIBYTE(v5) = BYTE1(v3) ^ 0x80;
    LOBYTE(v5) = (unsigned __int16)(v4 ^ 0x8000) >> 8;
    *a2++ = v5;
    --a1;
  }
  while ( a1 );
  return v5;
}

//----- (0007266B) --------------------------------------------------------
char __usercall sub_7266B@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int v4; // eax

  do
  {
    v4 = *a3;
    v3 = a3[1];
    a3 += 2;
    LOBYTE(v4) = BYTE1(v3);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return v4;
}

//----- (0007267F) --------------------------------------------------------
int __usercall sub_7267F@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = BYTE1(result);
    *a2 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007269C) --------------------------------------------------------
int __usercall sub_7269C@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000726AE) --------------------------------------------------------
int __usercall sub_726AE@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000726CB) --------------------------------------------------------
int __usercall sub_726CB@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = BYTE1(v5);
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000726DD) --------------------------------------------------------
int __usercall sub_726DD@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    result = v3 ^ 0x8000;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000726F1) --------------------------------------------------------
int __usercall sub_726F1@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072700) --------------------------------------------------------
__int16 __usercall sub_72700@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3++;
    LOWORD(v3) = v3 ^ 0x8000;
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072716) --------------------------------------------------------
__int16 __usercall sub_72716@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3++;
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072727) --------------------------------------------------------
int __usercall sub_72727@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    *a2 = result;
    a2[1] = v4 ^ 0x8000;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072748) --------------------------------------------------------
int __usercall sub_72748@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007275E) --------------------------------------------------------
int __usercall sub_7275E@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    *a2 = v4 ^ 0x8000;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007277F) --------------------------------------------------------
int __usercall sub_7277F@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072795) --------------------------------------------------------
int __usercall sub_72795@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    LOWORD(v4) = v4 ^ 0x8000;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000727BA) --------------------------------------------------------
int __usercall sub_727BA@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int result; // eax
  char v5; // t0
  char v6; // t1

  do
  {
    result = *a3;
    v3 = a3[1];
    a3 += 2;
    v5 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v5;
    v6 = v3;
    LOBYTE(v3) = BYTE1(v3);
    BYTE1(v3) = v6;
    *a2 = result;
    a2[1] = v3;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000727D4) --------------------------------------------------------
int __usercall sub_727D4@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    result = v3 ^ 0x8000;
    LOWORD(v4) = v4 ^ 0x8000;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000727F9) --------------------------------------------------------
int __usercall sub_727F9@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // edx
  int result; // eax
  char v5; // t0
  char v6; // t1

  do
  {
    result = *a3;
    v3 = a3[1];
    a3 += 2;
    v5 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v5;
    v6 = v3;
    LOBYTE(v3) = BYTE1(v3);
    BYTE1(v3) = v6;
    *a2 = v3;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072813) --------------------------------------------------------
int __usercall sub_72813@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = result;
    *a2 = v5 ^ 0x8000;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072836) --------------------------------------------------------
int __usercall sub_72836@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007284E) --------------------------------------------------------
int __usercall sub_7284E@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    *a3 = v5 ^ 0x8000;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072871) --------------------------------------------------------
int __usercall sub_72871@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072889) --------------------------------------------------------
int __usercall sub_72889@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    LOWORD(v5) = v5 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = BYTE1(v5);
    BYTE1(v5) = v8;
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000728B0) --------------------------------------------------------
int __usercall sub_728B0@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    result = *a4;
    v4 = a4[1];
    a4 += 2;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a3 = result;
    *a2 = v4;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000728CC) --------------------------------------------------------
int __usercall sub_728CC@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    result = v4 ^ 0x8000;
    LOWORD(v5) = v5 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = BYTE1(v5);
    BYTE1(v5) = v8;
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000728F3) --------------------------------------------------------
int __usercall sub_728F3@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // edx
  int result; // eax
  char v6; // t0
  char v7; // t1

  do
  {
    result = *a4;
    v4 = a4[1];
    a4 += 2;
    v6 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v6;
    v7 = v4;
    LOBYTE(v4) = BYTE1(v4);
    BYTE1(v4) = v7;
    *a3 = v4;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007290F) --------------------------------------------------------
int __usercall sub_7290F@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      v3 = 0xFFFF8000;
    }
    result = v3 ^ 0x8000;
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007293C) --------------------------------------------------------
int __usercall sub_7293C@<eax>(int a1@<ecx>, _BYTE *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    *a2++ = BYTE1(result);
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072964) --------------------------------------------------------
int __usercall sub_72964@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  __int16 v6; // dx

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      v3 = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 0x7F;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      BYTE1(v4) = 0x80;
    }
    result = v3 ^ 0x8000;
    HIBYTE(v6) = BYTE1(v4) ^ 0x80;
    LOBYTE(v6) = BYTE1(result);
    *a2++ = v6;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000729BD) --------------------------------------------------------
int __usercall sub_729BD@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 0x7F;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      BYTE1(v4) = 0x80;
    }
    LOBYTE(v4) = BYTE1(result);
    *a2++ = v4;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072A0B) --------------------------------------------------------
char __usercall sub_72A0B@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // ax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      BYTE1(v3) = 0x7F;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      BYTE1(v3) = 0x80;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    HIBYTE(v5) = BYTE1(v3) ^ 0x80;
    LOBYTE(v5) = (unsigned __int16)(v4 ^ 0x8000) >> 8;
    *a2++ = v5;
    --a1;
  }
  while ( a1 );
  return v5;
}

//----- (00072A64) --------------------------------------------------------
char __usercall sub_72A64@<al>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      BYTE1(v3) = 0x7F;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      BYTE1(v3) = 0x80;
    }
    if ( v4 > 0x7FFF )
    {
      BYTE1(v4) = 0x7F;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      BYTE1(v4) = 0x80;
    }
    LOBYTE(v3) = BYTE1(v4);
    *a2++ = v3;
    --a1;
  }
  while ( a1 );
  return v3;
}

//----- (00072AB2) --------------------------------------------------------
int __usercall sub_72AB2@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      v4 = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = BYTE1(result);
    *a2 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072B09) --------------------------------------------------------
int __usercall sub_72B09@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 0x7F;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      BYTE1(v5) = 0x80;
    }
    *a3 = BYTE1(result);
    *a2 = BYTE1(v5);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072B55) --------------------------------------------------------
int __usercall sub_72B55@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      v4 = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = (unsigned __int16)(v5 ^ 0x8000) >> 8;
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072BAC) --------------------------------------------------------
int __usercall sub_72BAC@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>, _BYTE *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      BYTE1(v5) = 0x7F;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      BYTE1(v5) = 0x80;
    }
    *a3 = BYTE1(v5);
    *a2 = BYTE1(result);
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072BF8) --------------------------------------------------------
int __usercall sub_72BF8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int result; // eax

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      v3 = 0xFFFF8000;
    }
    result = v3 ^ 0x8000;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072C28) --------------------------------------------------------
int __usercall sub_72C28@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  do
  {
    result = *a3++;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072C53) --------------------------------------------------------
__int16 __usercall sub_72C53@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 v4; // ax
  __int16 result; // ax
  char v6; // t0

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      LOWORD(v3) = 0x8000;
    }
    v4 = v3 ^ 0x8000;
    v6 = v4;
    LOBYTE(result) = HIBYTE(v4);
    HIBYTE(result) = v6;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072C85) --------------------------------------------------------
__int16 __usercall sub_72C85@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  __int16 result; // ax
  char v5; // t0

  do
  {
    v3 = *a3++;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      LOWORD(v3) = 0x8000;
    }
    v5 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v5;
    *a2++ = result;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072CB2) --------------------------------------------------------
int __usercall sub_72CB2@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      v3 = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    *a2 = result;
    a2[1] = v4 ^ 0x8000;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072D0D) --------------------------------------------------------
int __usercall sub_72D0D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    *a2 = result;
    a2[1] = v4;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072D5D) --------------------------------------------------------
int __usercall sub_72D5D@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      v3 = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    *a2 = v4 ^ 0x8000;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072DB8) --------------------------------------------------------
int __usercall sub_72DB8@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax
  int v4; // edx

  do
  {
    result = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    *a2 = v4;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072E08) --------------------------------------------------------
int __usercall sub_72E08@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // dx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      v3 = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    v5 = v4 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = HIBYTE(v5);
    HIBYTE(v5) = v8;
    *a2 = result;
    a2[1] = v5;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072E67) --------------------------------------------------------
__int16 __usercall sub_72E67@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 result; // ax
  char v6; // t0
  __int16 v7; // dx
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      LOWORD(v3) = 0x8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    v6 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v6;
    v8 = v4;
    LOBYTE(v7) = BYTE1(v4);
    HIBYTE(v7) = v8;
    *a2 = result;
    a2[1] = v7;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072EBB) --------------------------------------------------------
int __usercall sub_72EBB@<eax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 v5; // dx
  int result; // eax
  char v7; // t0
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      v3 = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      v3 = 0xFFFF8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    result = v3 ^ 0x8000;
    v5 = v4 ^ 0x8000;
    v7 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v7;
    v8 = v5;
    LOBYTE(v5) = HIBYTE(v5);
    HIBYTE(v5) = v8;
    *a2 = v5;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072F1A) --------------------------------------------------------
__int16 __usercall sub_72F1A@<ax>(int a1@<ecx>, _WORD *a2@<edi>, int *a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  __int16 result; // ax
  char v6; // t0
  __int16 v7; // dx
  char v8; // t1

  do
  {
    v3 = *a3;
    v4 = a3[1];
    a3 += 2;
    if ( v3 > 0x7FFF )
    {
      LOWORD(v3) = 0x7FFF;
    }
    else if ( v3 < (int)0xFFFF8000 )
    {
      LOWORD(v3) = 0x8000;
    }
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    v6 = v3;
    LOBYTE(result) = BYTE1(v3);
    HIBYTE(result) = v6;
    v8 = v4;
    LOBYTE(v7) = BYTE1(v4);
    HIBYTE(v7) = v8;
    *a2 = v7;
    a2[1] = result;
    a2 += 2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072F6E) --------------------------------------------------------
int __usercall sub_72F6E@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      v4 = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = result;
    *a2 = v5 ^ 0x8000;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00072FCB) --------------------------------------------------------
int __usercall sub_72FCB@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    *a3 = result;
    *a2 = v5;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007301D) --------------------------------------------------------
int __usercall sub_7301D@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      v4 = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    *a3 = v5 ^ 0x8000;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007307A) --------------------------------------------------------
int __usercall sub_7307A@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int result; // eax
  int v5; // edx

  do
  {
    result = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( result > 0x7FFF )
    {
      result = 0x7FFF;
    }
    else if ( result < (int)0xFFFF8000 )
    {
      result = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    *a3 = v5;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000730CC) --------------------------------------------------------
int __usercall sub_730CC@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 v6; // dx
  int result; // eax
  char v8; // t0
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      v4 = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    v6 = v5 ^ 0x8000;
    v8 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v8;
    v9 = v6;
    LOBYTE(v6) = HIBYTE(v6);
    HIBYTE(v6) = v9;
    *a3 = result;
    *a2 = v6;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007312D) --------------------------------------------------------
__int16 __usercall sub_7312D@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 result; // ax
  char v7; // t0
  __int16 v8; // dx
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    v7 = v4;
    LOBYTE(result) = BYTE1(v4);
    HIBYTE(result) = v7;
    v9 = v5;
    LOBYTE(v8) = BYTE1(v5);
    HIBYTE(v8) = v9;
    *a3 = result;
    *a2 = v8;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (00073183) --------------------------------------------------------
int __usercall sub_73183@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 v6; // dx
  int result; // eax
  char v8; // t0
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      v4 = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      v4 = 0xFFFF8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    result = v4 ^ 0x8000;
    v6 = v5 ^ 0x8000;
    v8 = result;
    LOBYTE(result) = BYTE1(result);
    BYTE1(result) = v8;
    v9 = v6;
    LOBYTE(v6) = HIBYTE(v6);
    HIBYTE(v6) = v9;
    *a3 = v6;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (000731E4) --------------------------------------------------------
__int16 __usercall sub_731E4@<ax>(int a1@<ecx>, _WORD *a2@<ebx>, _WORD *a3@<edi>, int *a4@<esi>)
{
  int v4; // eax
  int v5; // edx
  __int16 result; // ax
  char v7; // t0
  __int16 v8; // dx
  char v9; // t1

  do
  {
    v4 = *a4;
    v5 = a4[1];
    a4 += 2;
    if ( v4 > 0x7FFF )
    {
      LOWORD(v4) = 0x7FFF;
    }
    else if ( v4 < (int)0xFFFF8000 )
    {
      LOWORD(v4) = 0x8000;
    }
    if ( v5 > 0x7FFF )
    {
      LOWORD(v5) = 0x7FFF;
    }
    else if ( v5 < (int)0xFFFF8000 )
    {
      LOWORD(v5) = 0x8000;
    }
    v7 = v4;
    LOBYTE(result) = BYTE1(v4);
    HIBYTE(result) = v7;
    v9 = v5;
    LOBYTE(v8) = BYTE1(v5);
    HIBYTE(v8) = v9;
    *a3 = v8;
    *a2 = result;
    ++a3;
    ++a2;
    --a1;
  }
  while ( a1 );
  return result;
}

//----- (0007323A) --------------------------------------------------------
int __usercall sub_7323A@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a3;
    result ^= 0x8000u;
    ++a3;
    *a2++ += (__int16)result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (0007325B) --------------------------------------------------------
int __usercall sub_7325B@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a3;
    result ^= 0x8000u;
    ++a3;
    *a2 += (__int16)result;
    a2[1] += (__int16)result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (0007327F) --------------------------------------------------------
int __usercall sub_7327F@<eax>(int result@<eax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a3;
    result ^= 0x8000u;
    a3 += 2;
    *a2++ += (__int16)result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000732AB) --------------------------------------------------------
int __usercall sub_732AB@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a4;
    HIBYTE(a2) = a4[1];
    result ^= 0x8000u;
    a2 ^= 0x8000u;
    a4 += 2;
    *a3 += (__int16)result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000732DD) --------------------------------------------------------
int __usercall sub_732DD@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>)
{
  do
  {
    if ( a3 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *(_BYTE *)(a3 + 1);
    result ^= 0x8000u;
    a3 += 2;
    *a2++ += (__int16)result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073309) --------------------------------------------------------
int __usercall sub_73309@<eax>(int result@<eax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    HIBYTE(a2) = *a4;
    BYTE1(result) = a4[1];
    result ^= 0x8000u;
    a2 ^= 0x8000u;
    a4 += 2;
    *a3 += (__int16)result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (0007333B) --------------------------------------------------------
__int16 __usercall sub_7333B@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2++ ^ 0x8000;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (0007335F) --------------------------------------------------------
__int16 __usercall sub_7335F@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2++ ^ 0x8000;
    *a1 += result;
    a1[1] += result;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073386) --------------------------------------------------------
__int16 __usercall sub_73386@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2 ^ 0x8000;
    a2 += 2;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000733B4) --------------------------------------------------------
__int16 __usercall sub_733B4@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2 ^ 0x8000;
    v3 = a2[1] ^ 0x8000;
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000733E8) --------------------------------------------------------
__int16 __usercall sub_733E8@<ax>(_DWORD *a1@<edi>, unsigned int a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( a2 >= dword_988EC )
    {
      break;
    }
    result = *(_WORD *)(a2 + 2) ^ 0x8000;
    a2 += 4;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073416) --------------------------------------------------------
__int16 __usercall sub_73416@<ax>(_DWORD *a1@<edi>, _WORD *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = a2[1] ^ 0x8000;
    v3 = *a2 ^ 0x8000;
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (0007344A) --------------------------------------------------------
__int16 __usercall sub_7344A@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a3++;
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073466) --------------------------------------------------------
__int16 __usercall sub_73466@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a3++;
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073485) --------------------------------------------------------
__int16 __usercall sub_73485@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, _BYTE *a3@<esi>)
{
  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a3;
    a3 += 2;
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000734A6) --------------------------------------------------------
__int16 __usercall sub_734A6@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a4;
    HIBYTE(a2) = a4[1];
    a4 += 2;
    *a3 += result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000734CD) --------------------------------------------------------
__int16 __usercall sub_734CD@<ax>(__int16 result@<ax>, _DWORD *a2@<edi>, unsigned int a3@<esi>)
{
  do
  {
    if ( a3 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *(_BYTE *)(a3 + 1);
    a3 += 2;
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000734EE) --------------------------------------------------------
__int16 __usercall sub_734EE@<ax>(__int16 result@<ax>, __int16 a2@<bx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    HIBYTE(a2) = *a4;
    HIBYTE(result) = a4[1];
    a4 += 2;
    *a3 += result;
    a3[1] += a2;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073515) --------------------------------------------------------
__int16 __usercall sub_73515@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2++;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073534) --------------------------------------------------------
__int16 __usercall sub_73534@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2++;
    *a1 += result;
    a1[1] += result;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073556) --------------------------------------------------------
__int16 __usercall sub_73556@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2;
    a2 += 2;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073579) --------------------------------------------------------
__int16 __usercall sub_73579@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 result; // ax
  __int16 v3; // bx

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    result = *a2;
    v3 = a2[1];
    a2 += 2;
    *a1 += result;
    a1[1] += v3;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000735A2) --------------------------------------------------------
__int16 __usercall sub_735A2@<ax>(_DWORD *a1@<edi>, unsigned int a2@<esi>)
{
  __int16 result; // ax

  do
  {
    if ( a2 >= dword_988EC )
    {
      break;
    }
    result = *(_WORD *)(a2 + 2);
    a2 += 4;
    *a1++ += result;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000735C5) --------------------------------------------------------
__int16 __usercall sub_735C5@<ax>(_DWORD *a1@<edi>, __int16 *a2@<esi>)
{
  __int16 v2; // bx
  __int16 result; // ax

  do
  {
    if ( (unsigned int)a2 >= dword_988EC )
    {
      break;
    }
    v2 = *a2;
    result = a2[1];
    a2 += 2;
    *a1 += result;
    a1[1] += v2;
    a1 += 2;
  }
  while ( (unsigned int)a1 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (000735EE) --------------------------------------------------------
int __usercall sub_735EE@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a4;
    result ^= 0x8000u;
    a4 = (_BYTE *)((qword_988F8 + __PAIR64__((unsigned int)a4, a2)) >> 0x20);
    a2 += qword_988F8;
    *a3++ += (__int16)result;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (0007361A) --------------------------------------------------------
int __usercall sub_7361A@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a4;
    result ^= 0x8000u;
    a4 = (_BYTE *)((qword_988F8 + __PAIR64__((unsigned int)a4, a2)) >> 0x20);
    a2 += qword_988F8;
    *a3 += (__int16)result;
    a3[1] += (__int16)result;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073649) --------------------------------------------------------
int __usercall sub_73649@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  int v4; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a4;
    result ^= 0x8000u;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a4 += *((_DWORD *)&qword_988F8 + v4 + 1);
    *a3++ += (__int16)result;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073683) --------------------------------------------------------
int __usercall sub_73683@<eax>(
        int result@<eax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *a5;
    HIBYTE(a3) = a5[1];
    result ^= 0x8000u;
    a3 ^= 0x8000u;
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4 += (__int16)result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000736C3) --------------------------------------------------------
int __usercall sub_736C3@<eax>(int result@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, unsigned int a4@<esi>)
{
  int v4; // ebp

  do
  {
    if ( a4 >= dword_988EC )
    {
      break;
    }
    BYTE1(result) = *(_BYTE *)(a4 + 1);
    result ^= 0x8000u;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a4 += *((_DWORD *)&qword_988F8 + v4 + 1);
    *a3++ += (__int16)result;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000736FD) --------------------------------------------------------
int __usercall sub_736FD@<eax>(
        int result@<eax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    HIBYTE(a3) = *a5;
    BYTE1(result) = a5[1];
    result ^= 0x8000u;
    a3 ^= 0x8000u;
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4 += (__int16)result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (0007373D) --------------------------------------------------------
__int16 __usercall sub_7373D@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3 ^ 0x8000;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_988F8 + v4 + 1));
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (0007376F) --------------------------------------------------------
__int16 __usercall sub_7376F@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3 ^ 0x8000;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_988F8 + v4 + 1));
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000737A4) --------------------------------------------------------
__int16 __usercall sub_737A4@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3 ^ 0x8000;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_988F8 + v4 + 1));
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000737E0) --------------------------------------------------------
__int16 __usercall sub_737E0@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3 ^ 0x8000;
    v4 = a3[1] ^ 0x8000;
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_988F8 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073822) --------------------------------------------------------
__int16 __usercall sub_73822@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, unsigned int a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( a3 >= dword_988EC )
    {
      break;
    }
    result = *(_WORD *)(a3 + 2) ^ 0x8000;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 += *((_DWORD *)&qword_988F8 + v4 + 1);
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (0007385E) --------------------------------------------------------
__int16 __usercall sub_7385E@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, _WORD *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = a3[1] ^ 0x8000;
    v4 = *a3 ^ 0x8000;
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (_WORD *)((char *)a3 + *((_DWORD *)&qword_988F8 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000738A0) --------------------------------------------------------
__int16 __usercall sub_738A0@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a4;
    a4 = (_BYTE *)((qword_988F8 + __PAIR64__((unsigned int)a4, a2)) >> 0x20);
    a2 += qword_988F8;
    *a3++ += result;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000738C7) --------------------------------------------------------
__int16 __usercall sub_738C7@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a4;
    a4 = (_BYTE *)((qword_988F8 + __PAIR64__((unsigned int)a4, a2)) >> 0x20);
    a2 += qword_988F8;
    *a3 += result;
    a3[1] += result;
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000738F1) --------------------------------------------------------
__int16 __usercall sub_738F1@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  int v4; // ebp

  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a4;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a4 += *((_DWORD *)&qword_988F8 + v4 + 1);
    *a3++ += result;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073920) --------------------------------------------------------
__int16 __usercall sub_73920@<ax>(
        __int16 result@<ax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *a5;
    HIBYTE(a3) = a5[1];
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4 += result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073955) --------------------------------------------------------
__int16 __usercall sub_73955@<ax>(__int16 result@<ax>, unsigned int a2@<ecx>, _DWORD *a3@<edi>, unsigned int a4@<esi>)
{
  int v4; // ebp

  do
  {
    if ( a4 >= dword_988EC )
    {
      break;
    }
    HIBYTE(result) = *(_BYTE *)(a4 + 1);
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a4 += *((_DWORD *)&qword_988F8 + v4 + 1);
    *a3++ += result;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073984) --------------------------------------------------------
__int16 __usercall sub_73984@<ax>(
        __int16 result@<ax>,
        unsigned int a2@<ecx>,
        __int16 a3@<bx>,
        _DWORD *a4@<edi>,
        _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    HIBYTE(a3) = *a5;
    HIBYTE(result) = a5[1];
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a2) >> 0x20;
    a2 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4 += result;
    a4[1] += a3;
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000739B9) --------------------------------------------------------
__int16 __usercall sub_739B9@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_988F8 + v4 + 1));
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (000739E6) --------------------------------------------------------
__int16 __usercall sub_739E6@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_988F8 + v4 + 1));
    *a2 += result;
    a2[1] += result;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073A16) --------------------------------------------------------
__int16 __usercall sub_73A16@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3;
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_988F8 + v4 + 1));
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073A47) --------------------------------------------------------
__int16 __usercall sub_73A47@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 result; // ax
  __int16 v4; // bx
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    result = *a3;
    v4 = a3[1];
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_988F8 + v5 + 1));
    *a2 += result;
    a2[1] += v4;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073A7E) --------------------------------------------------------
__int16 __usercall sub_73A7E@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, unsigned int a3@<esi>)
{
  __int16 result; // ax
  int v4; // ebp

  do
  {
    if ( a3 >= dword_988EC )
    {
      break;
    }
    result = *(_WORD *)(a3 + 2);
    v4 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 += *((_DWORD *)&qword_988F8 + v4 + 1);
    *a2++ += result;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073AAF) --------------------------------------------------------
__int16 __usercall sub_73AAF@<ax>(unsigned int a1@<ecx>, _DWORD *a2@<edi>, __int16 *a3@<esi>)
{
  __int16 v3; // bx
  __int16 result; // ax
  int v5; // ebp

  do
  {
    if ( (unsigned int)a3 >= dword_988EC )
    {
      break;
    }
    v3 = *a3;
    result = a3[1];
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a1) >> 0x20;
    a1 += qword_988F8;
    a3 = (__int16 *)((char *)a3 + *((_DWORD *)&qword_988F8 + v5 + 1));
    *a2 += result;
    a2[1] += v3;
    a2 += 2;
  }
  while ( (unsigned int)a2 < dword_988F4 );
  return result;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073AE6) --------------------------------------------------------
char __usercall sub_73AE6@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a4++;
    *a3++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073B02) --------------------------------------------------------
char __usercall sub_73B02@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a4++;
    *a3 += *(_DWORD *)(a2 + 4 * a1);
    a3[1] += *(_DWORD *)(a2 + 4 * a1 + 0x400);
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073B28) --------------------------------------------------------
char __usercall sub_73B28@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, _BYTE *a4@<esi>)
{
  do
  {
    if ( (unsigned int)a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a4;
    a4 += 2;
    *a3++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073B49) --------------------------------------------------------
char __usercall sub_73B49@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a5;
    LOBYTE(a3) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 0x400);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073B74) --------------------------------------------------------
char __usercall sub_73B74@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>)
{
  do
  {
    if ( a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a4 + 1);
    a4 += 2;
    *a3++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073B95) --------------------------------------------------------
char __usercall sub_73B95@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a3) = *a5;
    LOBYTE(a1) = a5[1];
    a5 += 2;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 0x400);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073BC0) --------------------------------------------------------
char __usercall sub_73BC0@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>)
{
  do
  {
    if ( a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a4 + 1);
    a4 += 2;
    *a3++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073BDF) --------------------------------------------------------
char __usercall sub_73BDF@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>)
{
  do
  {
    if ( a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a4 + 1);
    a4 += 2;
    *a3 += *(_DWORD *)(a2 + 4 * a1);
    a3[1] += *(_DWORD *)(a2 + 4 * a1 + 0x400);
    a3 += 2;
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073C08) --------------------------------------------------------
char __usercall sub_73C08@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>)
{
  do
  {
    if ( a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a4 + 1);
    a4 += 4;
    *a3++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073C2A) --------------------------------------------------------
char __usercall sub_73C2A@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, unsigned int a5@<esi>)
{
  do
  {
    if ( a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a5 + 1);
    LOBYTE(a3) = *(_BYTE *)(a5 + 3);
    a5 += 4;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 0x400);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073C56) --------------------------------------------------------
char __usercall sub_73C56@<al>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<edi>, unsigned int a4@<esi>)
{
  do
  {
    if ( a4 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a4 + 3);
    a4 += 4;
    *a3++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a3 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073C78) --------------------------------------------------------
char __usercall sub_73C78@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _DWORD *a4@<edi>, unsigned int a5@<esi>)
{
  do
  {
    if ( a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a3) = *(_BYTE *)(a5 + 1);
    LOBYTE(a1) = *(_BYTE *)(a5 + 3);
    a5 += 4;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a3 + 0x400);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;

//----- (00073CA4) --------------------------------------------------------
char __usercall sub_73CA4@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a5;
    a5 = (_BYTE *)((qword_988F8 + __PAIR64__((unsigned int)a5, a3)) >> 0x20);
    a3 += qword_988F8;
    *a4++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073CCB) --------------------------------------------------------
char __usercall sub_73CCB@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a5;
    a5 = (_BYTE *)((qword_988F8 + __PAIR64__((unsigned int)a5, a3)) >> 0x20);
    a3 += qword_988F8;
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a1 + 0x400);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073CFC) --------------------------------------------------------
char __usercall sub_73CFC@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4@<edi>, _BYTE *a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( (unsigned int)a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a5;
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073D2B) --------------------------------------------------------
char __usercall sub_73D2B@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *a6;
    LOBYTE(a4) = a6[1];
    v6 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a6 += *((_DWORD *)&qword_988F8 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 0x400);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073D64) --------------------------------------------------------
char __usercall sub_73D64@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        unsigned int a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a5 + 1);
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073D93) --------------------------------------------------------
char __usercall sub_73D93@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        _BYTE *a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( (unsigned int)a6 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a4) = *a6;
    LOBYTE(a1) = a6[1];
    v6 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a6 += *((_DWORD *)&qword_988F8 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 0x400);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073DCC) --------------------------------------------------------
char __usercall sub_73DCC@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        unsigned int a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a5 + 1);
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073DF9) --------------------------------------------------------
char __usercall sub_73DF9@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        unsigned int a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a5 + 1);
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4 += *(_DWORD *)(a2 + 4 * a1);
    a4[1] += *(_DWORD *)(a2 + 4 * a1 + 0x400);
    a4 += 2;
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073E30) --------------------------------------------------------
char __usercall sub_73E30@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        unsigned int a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a5 + 1);
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073E60) --------------------------------------------------------
char __usercall sub_73E60@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        unsigned int a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( a6 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a6 + 1);
    LOBYTE(a4) = *(_BYTE *)(a6 + 3);
    v6 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a6 += *((_DWORD *)&qword_988F8 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 0x400);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073E9A) --------------------------------------------------------
char __usercall sub_73E9A@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4@<edi>,
        unsigned int a5@<esi>)
{
  int v5; // ebp

  do
  {
    if ( a5 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a1) = *(_BYTE *)(a5 + 3);
    v5 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a5 += *((_DWORD *)&qword_988F8 + v5 + 1);
    *a4++ += *(_DWORD *)(a2 + 4 * a1);
  }
  while ( (unsigned int)a4 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073ECA) --------------------------------------------------------
char __usercall sub_73ECA@<al>(
        int a1@<eax>,
        int a2@<edx>,
        unsigned int a3@<ecx>,
        int a4@<ebx>,
        _DWORD *a5@<edi>,
        unsigned int a6@<esi>)
{
  int v6; // ebp

  do
  {
    if ( a6 >= dword_988EC )
    {
      break;
    }
    LOBYTE(a4) = *(_BYTE *)(a6 + 1);
    LOBYTE(a1) = *(_BYTE *)(a6 + 3);
    v6 = ((unsigned int)qword_988F8 + (unsigned __int64)a3) >> 0x20;
    a3 += qword_988F8;
    a6 += *((_DWORD *)&qword_988F8 + v6 + 1);
    *a5 += *(_DWORD *)(a2 + 4 * a1);
    a5[1] += *(_DWORD *)(a2 + 4 * a4 + 0x400);
    a5 += 2;
  }
  while ( (unsigned int)a5 < dword_988F4 );
  return a1;
}
// 988EC: using guessed type int dword_988EC;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;

//----- (00073F04) --------------------------------------------------------
int __cdecl sub_73F04(int a1)
{
  int v1; // ecx
  _DWORD *v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rax
  int v5; // eax
  char *v6; // edx
  unsigned int v7; // eax
  int v8; // ebx
  _DWORD *v9; // edi
  int v10; // ebx
  unsigned int v11; // esi
  int v12; // edx
  int v13; // ebx
  int result; // eax
  int v15; // ebx

  v1 = a1;
  v2 = *(_DWORD **)a1;
  v3 = 0;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 0x18) == 2 || v2[6] == 3 )
  {
    v3 = 1;
  }
  if ( *(_DWORD *)(a1 + 0x34) == 2 || *(_DWORD *)(a1 + 0x34) == 3 )
  {
    v3 |= 2u;
    if ( (*(_DWORD *)(a1 + 0x38) & 2) != 0 )
    {
      v3 |= 4u;
    }
  }
  if ( *(_DWORD *)(a1 + 0x34) == 1 || *(_DWORD *)(a1 + 0x34) == 3 )
  {
    v3 |= 8u;
  }
  if ( *(_DWORD *)(a1 + 0x40) == 0x7F && *(_DWORD *)(a1 + 0x44) == 0x40 )
  {
    if ( (*(_DWORD *)(a1 + 0x38) & 1) != 0 )
    {
      v3 |= 0x10u;
    }
  }
  else
  {
    v3 |= 0x40u;
  }
  dword_988E4 = v3;
  LODWORD(v4) = 0;
  HIDWORD(v4) = *(_DWORD *)(a1 + 0x3C);
  if ( SHIDWORD(v4) <= 0 )
  {
    HIDWORD(v4) = 1;
  }
  v5 = v4 / (unsigned int)(v2[5] << 0x10);
  v6 = (char *)(v5 - (_DWORD)sub_10000);
  if ( v5 <= (int)sub_10000 )
  {
    v6 = (char *)sub_10000 - v5;
  }
  if ( (unsigned int)v6 > dword_133088 )
  {
    LODWORD(qword_988F8) = v5 << 0x10;
    v7 = HIWORD(v5);
    v8 = v7 + 1;
    if ( (dword_988E4 & 2) != 0 )
    {
      v7 *= 2;
      v8 *= 2;
    }
    if ( (dword_988E4 & 8) != 0 )
    {
      v7 *= 2;
      v8 *= 2;
    }
    HIDWORD(qword_988F8) = v7;
    dword_98900 = v8;
    dword_988E4 |= 0x20u;
  }
  dword_988F0 = v2[0x14];
  dword_988F4 = v2[0x13] + dword_988F0;
  v9 = (_DWORD *)dword_988F0;
  do
  {
    v10 = *(_DWORD *)(v1 + 0x28);
    dword_988E8 = *(_DWORD *)(v1 + 4 * v10 + 0x18) + *(_DWORD *)(v1 + 4 * v10 + 8);
    dword_988EC = *(_DWORD *)(v1 + 4 * v10 + 0x10) + *(_DWORD *)(v1 + 4 * v10 + 8);
    if ( *(_DWORD *)(v1 + 0x848) )
    {
      (*(void (__stdcall **)(int))(v1 + 0x848))(v1);
    }
    v11 = dword_988E8;
    v12 = v1 + 0x48;
    ((void (__usercall *)(int@<eax>, _DWORD *@<edi>, _BYTE *@<esi>))funcs_74040[dword_988E4])(
      0,
      v9,
      (_BYTE *)dword_988E8);
    v1 = a1;
    v13 = *(_DWORD *)(a1 + 0x28);
    result = v11 - *(_DWORD *)(a1 + 4 * v13 + 8);
    *(_DWORD *)(a1 + 4 * v13 + 0x18) = result;
    if ( v11 < dword_988EC )
    {
      break;
    }
    if ( *(_DWORD *)(a1 + 0x84C) )
    {
      result = (*(int (__fastcall **)(int, int, int))(a1 + 0x84C))(a1, v12, v13);
    }
    if ( *(_DWORD *)(a1 + 0x30) )
    {
      if ( *(_DWORD *)(a1 + 0x30) == 1 )
      {
        v15 = *(_DWORD *)(a1 + 0x28) ^ 1;
        if ( *(_DWORD *)(a1 + 4 * v15 + 0x20) )
        {
          *(_DWORD *)(a1 + 4) = 2;
          if ( *(_DWORD *)(a1 + 0x850) )
          {
            return (*(int (__fastcall **)(int, int, int))(a1 + 0x850))(a1, v12, v15);
          }
          return result;
        }
        if ( !*(_DWORD *)(a1 + 4 * v15 + 0x10) || *(_DWORD *)(a1 + 4 * v15 + 0x18) )
        {
          return result;
        }
        *(_DWORD *)(a1 + 0x28) = v15;
      }
      else
      {
        --*(_DWORD *)(a1 + 0x30);
      }
    }
    *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 0x28) + 0x18) = 0;
  }
  while ( (unsigned int)v9 < dword_988F4 );
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 723FC: using guessed type int (*funcs_74040[4])();
// 988E4: using guessed type int dword_988E4;
// 988E8: using guessed type int dword_988E8;
// 988EC: using guessed type int dword_988EC;
// 988F0: using guessed type int dword_988F0;
// 988F4: using guessed type int dword_988F4;
// 988F8: using guessed type __int64 qword_988F8;
// 98900: using guessed type int dword_98900;
// 133088: using guessed type int dword_133088;

//----- (00074105) --------------------------------------------------------
int __cdecl sub_74105(_DWORD *a1, int a2)
{
  int v2; // eax
  int *v3; // esi
  int v4; // ecx
  _BYTE *v5; // edi

  v2 = a1[7] & 0xF;
  if ( a1[6] == 2 || a1[6] == 3 )
  {
    v2 |= 0x10u;
  }
  if ( a1[6] == 1 || a1[6] == 3 )
  {
    v2 |= 0x20u;
  }
  if ( a1[0x19] )
  {
    v2 |= 0x40u;
  }
  dword_988E4 = v2;
  v3 = (int *)a1[0x14];
  v4 = a1[0x12];
  if ( (a1[7] & 0x20) != 0 )
  {
    dword_988E4 |= 8u;
    v5 = (_BYTE *)(a2 * (a1[4] >> 1) + a1[0xB]);
  }
  else
  {
    v5 = (_BYTE *)a1[a2 + 0xB];
  }
  return ((int (__usercall *)@<eax>(int@<ecx>, _BYTE *@<edi>, int *@<esi>))funcs_74189[dword_988E4])(v4, v5, v3);
}
// 721FC: using guessed type int (*funcs_74189[2])();
// 988E4: using guessed type int dword_988E4;

//----- (00074197) --------------------------------------------------------
int __cdecl sub_74197(int a1)
{
  char *v1; // edi
  int result; // eax
  unsigned int v3; // [esp-Ch] [ebp-18h]

  v1 = *(char **)(a1 + 0x50);
  result = 0;
  v3 = *(_DWORD *)(a1 + 0x4C);
  memset(v1, 0, v3 & 3);
  memset(&v1[v3 & 3], 0, 4 * (v3 >> 2));
  return result;
}

//----- (000741C3) --------------------------------------------------------
BOOL sub_741C3()
{
  sub_662D1((unsigned int)&dword_988E4, (unsigned int)dword_98904);
  return sub_662D1((unsigned int)funcs_74189, (unsigned int)sub_741C3);
}
// 721FC: using guessed type int (*funcs_74189[2])();
// 988E4: using guessed type int dword_988E4;
// 98904: using guessed type int dword_98904[];

//----- (000741F4) --------------------------------------------------------
void sub_741F4()
{
  ++dword_98A9A;
}
// 98A9A: using guessed type int dword_98A9A;

//----- (00074201) --------------------------------------------------------
void sub_74201()
{
  --dword_98A9A;
}
// 98A9A: using guessed type int dword_98A9A;

//----- (0007420E) --------------------------------------------------------
int __usercall sub_7420E@<eax>(
        __int32 a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        __int32 a6@<edi>,
        __int32 a7@<esi>)
{
  int v7; // edx
  unsigned int i; // edi
  unsigned int v9; // eax
  unsigned int j; // edi
  __int32 v11; // eax
  __int32 v12; // ecx
  __int32 v13; // eax
  _DWORD v15[10]; // [esp-30h] [ebp-30h] BYREF
  __int32 v16; // [esp-8h] [ebp-8h] BYREF
  __int32 v17; // [esp-4h] [ebp-4h] BYREF
  void *retaddr[2]; // [esp+0h] [ebp+0h] BYREF

  if ( dword_98A96 )
  {
    v17 = a1;
    __outbyte(0x20u, 0x20u);
    __asm { iret }
  }
  v17 = a7;
  v16 = a6;
  v15[9] = a5;
  v15[8] = retaddr;
  v15[7] = a4;
  v15[6] = a3;
  v15[5] = a2;
  v15[4] = a1;
  v15[3] = (unsigned __int16)__DS__;
  v15[2] = (unsigned __int16)__ES__;
  v15[1] = (unsigned __int16)__FS__;
  v15[0] = (unsigned __int16)__GS__;
  __DS__ = word_98A9E;
  ++dword_98A96;
  word_994AC = __SS__;
  dword_994B0 = (int)v15;
  v7 = dword_98A92;
  for ( i = 0; i < 0x10; ++i )
  {
    if ( dword_98944[i] == 2 )
    {
      v9 = v7 + dword_98984[i];
      if ( v9 >= dword_989C4[i] )
      {
        v9 -= dword_989C4[i];
        ++dword_98A04[i];
      }
      dword_98984[i] = v9;
    }
  }
  __outbyte(0x20u, 0x20u);
  _enable();
  if ( dword_98A9A <= 0 )
  {
    for ( j = 0; j < 0xF; ++j )
    {
      while ( dword_98A04[j] )
      {
        --dword_98A04[j];
        ((void (__stdcall *)(int))dword_98904[j])(dword_98A44[j]);
      }
    }
  }
  if ( !dword_98A40 )
  {
    --dword_98A96;
    __asm { iret }
  }
  --dword_98A40;
  --dword_98A96;
  v11 = (unsigned __int16)word_98A88;
  v12 = _InterlockedExchange(&v16, dword_98A84);
  v13 = _InterlockedExchange(&v17, v11);
  return MK_FP(retaddr[0], retaddr[0])(v13, v17, v16, v12);
}
// 7420E: could not find valid save-restore pair for ebx
// 7420E: could not find valid save-restore pair for ebp
// 7420E: could not find valid save-restore pair for edi
// 7420E: could not find valid save-restore pair for esi
// 98904: using guessed type int dword_98904[];
// 98944: using guessed type int dword_98944[];
// 98984: using guessed type int dword_98984[];
// 989C4: using guessed type int dword_989C4[];
// 98A04: using guessed type int dword_98A04[];
// 98A40: using guessed type int dword_98A40;
// 98A44: using guessed type int dword_98A44[];
// 98A84: using guessed type int dword_98A84;
// 98A88: using guessed type __int16 word_98A88;
// 98A92: using guessed type int dword_98A92;
// 98A96: using guessed type int dword_98A96;
// 98A9A: using guessed type int dword_98A9A;
// 98A9E: using guessed type __int16 word_98A9E;
// 994AC: using guessed type __int16 word_994AC;
// 994B0: using guessed type int dword_994B0;

//----- (00074334) --------------------------------------------------------
char __cdecl sub_74334(int a1)
{
  unsigned int v1; // kr00_4
  unsigned __int8 v2; // ah
  char result; // al
  bool v4; // zf
  void *retaddr; // [esp+10h] [ebp+4h]

  v1 = __readeflags();
  _disable();
  __outbyte(0x43u, 0x36u);
  v2 = BYTE1(a1);
  dword_98A8E = a1;
  __outbyte(0x40u, a1);
  result = BYTE1(a1);
  __outbyte(0x40u, v2);
  v4 = (BYTE1(retaddr) & 2) == 0;
  _disable();
  if ( !v4 )
  {
    _enable();
  }
  __writeeflags(v1);
  return result;
}
// 98A8E: using guessed type int dword_98A8E;

//----- (00074364) --------------------------------------------------------
char __cdecl sub_74364(unsigned int a1)
{
  int v1; // eax

  v1 = 0;
  if ( a1 < 0xD68D )
  {
    v1 = 0x2710 * (unsigned __int64)a1 / 0x20BC;
  }
  return sub_74334(v1);
}

//----- (00074397) --------------------------------------------------------
int sub_74397()
{
  unsigned int v0; // eax
  unsigned int v1; // ecx
  unsigned int i; // edi

  v0 = sub_66FC8((unsigned __int16)__ES__);
  v1 = 0xFFFFFFFF;
  for ( i = 0; i < 0x10; ++i )
  {
    if ( dword_98944[i] )
    {
      v0 = dword_989C4[i];
      if ( v0 < v1 )
      {
        v1 = dword_989C4[i];
      }
    }
  }
  if ( v1 != dword_98A92 )
  {
    dword_98A92 = v1;
    sub_74364(v1);
    v0 = 0;
    memset(dword_98984, 0, 0x40u);
  }
  return sub_66FCD(v0);
}
// 66FC8: using guessed type int __cdecl sub_66FC8(_DWORD);
// 98944: using guessed type int dword_98944[];
// 98984: using guessed type int dword_98984[];
// 989C4: using guessed type int dword_989C4[];
// 98A92: using guessed type int dword_98A92;

//----- (000743FC) --------------------------------------------------------
void __fastcall sub_743FC(int a1, unsigned __int16 a2)
{
  unsigned int v2; // kr00_4
  bool v3; // zf
  char v4; // [esp-7h] [ebp-13h]

  v2 = __readeflags();
  v4 = BYTE1(v2);
  _disable();
  word_98A9E = __DS__;
  sub_74BC6();
  dword_98A96 = 0;
  dword_98A9A = 0;
  dword_98A92 = 0xFFFFFFFF;
  dword_98AA0 = 0xFFFFFFFF;
  memset(dword_98944, 0, 0x40u);
  memset(dword_98984, 0, 0x40u);
  memset(dword_989C4, 0, 0x40u);
  memset(dword_98A04, 0, 0x40u);
  __asm
  {
    int     31h; DPMI Services   ax=func xxxxh
    int     21h; DOS - 2+ - GET INTERRUPT VECTOR
  }
  dword_98A84 = 8;
  word_98A88 = __DS__;
  dword_98A8A = a2;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  dword_98980 = 2;
  AIL_set_timer_period(0x3C, 0xD68Du);
  v3 = (v4 & 2) == 0;
  _disable();
  if ( !v3 )
  {
    _enable();
  }
  __writeeflags(v2);
}
// 98944: using guessed type int dword_98944[];
// 98980: using guessed type int dword_98980;
// 98984: using guessed type int dword_98984[];
// 989C4: using guessed type int dword_989C4[];
// 98A04: using guessed type int dword_98A04[];
// 98A84: using guessed type int dword_98A84;
// 98A88: using guessed type __int16 word_98A88;
// 98A8A: using guessed type int dword_98A8A;
// 98A92: using guessed type int dword_98A92;
// 98A96: using guessed type int dword_98A96;
// 98A9A: using guessed type int dword_98A9A;
// 98A9E: using guessed type __int16 word_98A9E;
// 98AA0: using guessed type int dword_98AA0;

//----- (000744EA) --------------------------------------------------------
int sub_744EA()
{
  unsigned int v0; // kr00_4
  int result; // eax
  bool v2; // zf
  char v3; // [esp-3h] [ebp-Fh]

  v0 = __readeflags();
  v3 = BYTE1(v0);
  _disable();
  sub_74334(0);
  result = 0x2508;
  __asm { int     21h; DOS - SET INTERRUPT VECTOR }
  v2 = (v3 & 2) == 0;
  _disable();
  if ( !v2 )
  {
    _enable();
  }
  __writeeflags(v0);
  return result;
}
// 98A84: using guessed type int dword_98A84;
// 98A88: using guessed type __int16 word_98A88;

//----- (00074525) --------------------------------------------------------
int __fastcall sub_74525(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ecx

  __asm { int     31h; DPMI Services   ax=func xxxxh }
  v4 = a4 << 0x10;
  LOWORD(v4) = a2;
  __asm { int     21h; DOS - 2+ - GET INTERRUPT VECTOR }
  return v4;
}

//----- (00074551) --------------------------------------------------------
int sub_74551()
{
  int result; // eax

  result = 0x201;
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  return result;
}

//----- (000745CD) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __cdecl sub_745CD(int a1, int a2, __int16 a3)
{
  int result; // eax

  if ( dword_98AA0 == 0xFFFFFFFF )
  {
    __asm
    {
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      int     31h; DPMI Services   ax=func xxxxh
      lar     ecx, edx
      int     31h; DPMI Services   ax=func xxxxh
    }
    dword_74594 = (int)&unk_98AAC - ((unsigned int)&unk_98AAC & 0xFFFFFFF0) + 0x200;
    word_7458E = 0;
    word_7457F = 0;
    word_745B4 = 0;
    word_745BB = a3;
    word_745AA = (unsigned __int16)&dword_74578 - ((unsigned int)&dword_74578 & 0xFFFFFFF0) + 0x4A;
    dword_98AA0 = a1;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
    dword_98AA4 = 0xC0FF;
    dword_98AA8 = __DS__;
    result = 0x205;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
  }
  return result;
}
// 7476A: write access to const memory at 74594 has been detected
// 74772: write access to const memory at 7458E has been detected
// 7477B: write access to const memory at 7457F has been detected
// 74784: write access to const memory at 745B4 has been detected
// 7478D: write access to const memory at 745BB has been detected
// 7479B: write access to const memory at 745AA has been detected
// 74578: using guessed type int dword_74578;
// 7457F: using guessed type __int16 word_7457F;
// 7458E: using guessed type __int16 word_7458E;
// 74594: using guessed type int dword_74594;
// 745AA: using guessed type __int16 word_745AA;
// 745B4: using guessed type __int16 word_745B4;
// 745BB: using guessed type __int16 word_745BB;
// 98AA0: using guessed type int dword_98AA0;
// 98AA4: using guessed type int dword_98AA4;
// 98AA8: using guessed type int dword_98AA8;

//----- (000747E3) --------------------------------------------------------
int __cdecl sub_747E3(int a1)
{
  int result; // eax

  if ( a1 != 0xFFFFFFFF && a1 == dword_98AA0 )
  {
    result = 0x205;
    __asm { int     31h; DPMI Services   ax=func xxxxh }
    dword_98AA0 = 0xFFFFFFFF;
  }
  return result;
}
// 98AA0: using guessed type int dword_98AA0;
// 98AA4: using guessed type int dword_98AA4;
// 98AA8: using guessed type int dword_98AA8;

//----- (0007482C) --------------------------------------------------------
void __cdecl sub_7482C(unsigned int a1)
{
  bool v1; // zf
  void *retaddr; // [esp+4h] [ebp+4h]

  v1 = (BYTE1(retaddr) & 2) == 0;
  _disable();
  if ( !v1 )
  {
    _enable();
  }
  __writeeflags(a1);
}

//----- (00074893) --------------------------------------------------------
int __cdecl sub_74893(int a1, __int16 a2, _WORD *a3, _WORD *a4)
{
  __int16 v8; // dx
  __int16 v9; // si
  __int16 v10; // di
  __int16 v11; // cx
  __int16 v12; // dx
  __int16 v13; // si
  __int16 v14; // di
  int v16; // [esp-Ch] [ebp-54h]
  __int16 v17[25]; // [esp+Eh] [ebp-3Ah] BYREF

  sub_66FC8();
  memset(v17, 0, sizeof(v17));
  _CF = __CFSHR__(0x32, 2);
  _ZF = 0;
  _SF = 0;
  v17[0x12] = 0;
  v17[0x11] = 0;
  __asm { pushfw }
  v17[0x10] = 0;
  v17[0xE] = a2;
  if ( a3 )
  {
    v8 = a3[3];
    v9 = a3[4];
    v10 = a3[5];
    v17[0xC] = a3[2];
    v17[0xA] = v8;
    v17[2] = v9;
    v17[0] = v10;
  }
  v17[8] = *(_WORD *)(*(_DWORD *)(a1 + 8) + 0x32);
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  if ( a4 )
  {
    v11 = v17[0xC];
    v12 = v17[0xA];
    v13 = v17[2];
    v14 = v17[0];
    *a4 = v17[0xE];
    a4[2] = v11;
    a4[3] = v12;
    a4[4] = v13;
    a4[5] = v14;
    a4[1] = v17[8];
  }
  v16 = v17[0xE];
  sub_66FCD(v17[0xE]);
  return v16;
}
// 66FC8: using guessed type int sub_66FC8(void);

//----- (0007496D) --------------------------------------------------------
unsigned __int8 __cdecl sub_7496D(int a1)
{
  unsigned __int8 result; // al
  unsigned __int16 v2; // dx
  int i; // ecx
  unsigned __int8 v4; // al

  result = MEMORY[0x463];
  v2 = MEMORY[0x463] + 6;
  for ( i = a1; i; --i )
  {
    do
    {
      v4 = __inbyte(v2);
    }
    while ( (v4 & 8) == 0 );
    do
    {
      result = __inbyte(v2);
    }
    while ( (result & 8) != 0 );
  }
  return result;
}

//----- (000749AA) --------------------------------------------------------
int __fastcall sub_749AA()
{
  return dword_98A96;
}
// 98A96: using guessed type int dword_98A96;

//----- (000749B6) --------------------------------------------------------
unsigned int __cdecl sub_749B6(int a1)
{
  unsigned int v1; // eax
  unsigned int v3; // [esp-4h] [ebp-10h]

  sub_66FC8();
  v1 = 0;
  while ( *(int *)((char *)dword_98944 + v1) )
  {
    v1 += 4;
    if ( v1 >= 0x3C )
    {
      v1 = 0xFFFFFFFF;
      goto LABEL_6;
    }
  }
  *(int *)((char *)dword_98944 + v1) = 1;
  *(int *)((char *)dword_98904 + v1) = a1;
LABEL_6:
  v3 = v1;
  sub_66FCD(v1);
  return v3;
}
// 66FC8: using guessed type int sub_66FC8(void);
// 98904: using guessed type int dword_98904[];
// 98944: using guessed type int dword_98944[];

//----- (000749FD) --------------------------------------------------------
int __cdecl sub_749FD(int a1, __int32 a2)
{
  int v2; // eax
  int v4; // [esp-4h] [ebp-10h]

  v2 = sub_66FC8();
  if ( a1 != 0xFFFFFFFF )
  {
    v2 = _InterlockedExchange((int *)((char *)dword_98A44 + a1), a2);
  }
  v4 = v2;
  sub_66FCD(v2);
  return v4;
}
// 66FC8: using guessed type int sub_66FC8(void);
// 98A44: using guessed type int dword_98A44[];

//----- (00074A25) --------------------------------------------------------
int __cdecl sub_74A25(int a1)
{
  sub_66FC8();
  if ( a1 != 0xFFFFFFFF )
  {
    *(int *)((char *)dword_98944 + a1) = 0;
  }
  return sub_66FCD(a1);
}
// 66FC8: using guessed type int sub_66FC8(void);
// 98944: using guessed type int dword_98944[];

//----- (00074A4C) --------------------------------------------------------
int sub_74A4C()
{
  HTIMER v0; // esi
  int v1; // eax
  bool v2; // cc

  sub_66FC8();
  v0 = 0x38;
  do
  {
    AIL_release_timer_handle(v0);
    v2 = v0 < 4;
    v0 -= 4;
  }
  while ( !v2 );
  return sub_66FCD(v1);
}
// 74A67: variable 'v1' is possibly undefined
// 66FC8: using guessed type int sub_66FC8(void);

//----- (00074A70) --------------------------------------------------------
int __cdecl sub_74A70(int a1)
{
  int v1; // eax

  v1 = sub_66FC8();
  if ( a1 != 0xFFFFFFFF && *(int *)((char *)dword_98944 + a1) == 1 )
  {
    *(int *)((char *)dword_98944 + a1) = 2;
  }
  return sub_66FCD(v1);
}
// 66FC8: using guessed type int sub_66FC8(void);
// 98944: using guessed type int dword_98944[];

//----- (00074AA0) --------------------------------------------------------
int sub_74AA0()
{
  HTIMER v0; // esi
  int v1; // eax
  bool v2; // sf
  bool v3; // of

  sub_66FC8();
  v0 = 0x38;
  do
  {
    AIL_start_timer(v0);
    v3 = __OFSUB__(v0, 4);
    v2 = v0 - 4 < 0;
    v0 -= 4;
  }
  while ( v2 == v3 );
  return sub_66FCD(v1);
}
// 74ABB: variable 'v1' is possibly undefined

//----- (00074AC4) --------------------------------------------------------
int __cdecl sub_74AC4(int a1)
{
  int v1; // eax

  v1 = sub_66FC8();
  if ( a1 != 0xFFFFFFFF && *(int *)((char *)dword_98944 + a1) == 2 )
  {
    *(int *)((char *)dword_98944 + a1) = 1;
  }
  return sub_66FCD(v1);
}
// 66FC8: using guessed type int sub_66FC8(void);
// 98944: using guessed type int dword_98944[];

//----- (00074AF4) --------------------------------------------------------
int sub_74AF4()
{
  HTIMER v0; // esi
  int v1; // eax
  bool v2; // sf
  bool v3; // of

  sub_66FC8();
  v0 = 0x38;
  do
  {
    AIL_stop_timer(v0);
    v3 = __OFSUB__(v0, 4);
    v2 = v0 - 4 < 0;
    v0 -= 4;
  }
  while ( v2 == v3 );
  return sub_66FCD(v1);
}
// 74B0F: variable 'v1' is possibly undefined

//----- (00074B18) --------------------------------------------------------
int __cdecl sub_74B18(int a1, int a2)
{
  int v2; // eax

  sub_66FC8();
  *(int *)((char *)dword_989C4 + a1) = a2;
  *(int *)((char *)dword_98984 + a1) = 0;
  v2 = sub_74397();
  return sub_66FCD(v2);
}
// 98984: using guessed type int dword_98984[];
// 989C4: using guessed type int dword_989C4[];

//----- (00074B48) --------------------------------------------------------
int __cdecl sub_74B48(HTIMER timer, unsigned int a2)
{
  int v2; // eax

  sub_66FC8();
  AIL_set_timer_period(timer, (unsigned int)&unk_F4240 / a2);
  return sub_66FCD(v2);
}
// 74B6E: variable 'v2' is possibly undefined

//----- (00074B78) --------------------------------------------------------
int __cdecl sub_74B78(HTIMER timer, unsigned int a2)
{
  ULONG v2; // eax
  int v3; // eax

  sub_66FC8();
  if ( a2 )
  {
    v2 = 0x2710 * (unsigned __int64)a2 / 0x2E9C;
  }
  else
  {
    v2 = 0xD68D;
  }
  AIL_set_timer_period(timer, v2);
  return sub_66FCD(v3);
}
// 74BB0: variable 'v3' is possibly undefined

//----- (00074BBA) --------------------------------------------------------
int sub_74BBA()
{
  return dword_98A8E;
}
// 98A8E: using guessed type int dword_98A8E;

//----- (00074BC6) --------------------------------------------------------
BOOL sub_74BC6()
{
  sub_662D1((unsigned int)dword_98904, (unsigned int)&dword_994B4);
  return sub_662D1((unsigned int)sub_741F4, (unsigned int)sub_74BC6);
}
// 98904: using guessed type int dword_98904[];
// 994B4: using guessed type int dword_994B4;

//----- (00074BF0) --------------------------------------------------------
int __fastcall sub_74BF0(FILE *a1)
{
  int v2; // esi
  int v3; // edi

  v2 = ftell(a1);
  fseek(a1, 0, 2);
  v3 = ftell(a1);
  fseek(a1, v2, 0);
  return v3;
}

//----- (00074C28) --------------------------------------------------------
__int16 __fastcall sub_74C28(unsigned __int16 *a1, _WORD *a2, unsigned int a3)
{
  __int16 v5[12]; // [esp+0h] [ebp-18h] BYREF

  if ( !dword_994C4 )
  {
    sub_76A40(0x200, &dword_1330F8, &dword_1330F4, &dword_994C4, &word_1330FC);
  }
  v5[0] = dword_994C4;
  a1[5] = word_1330FC;
  sub_75FBE(dword_1330F8, (char *)dword_1330F4, a2, a3);
  sub_76BB0(0x10, a1, a1, v5);
  return sub_75F98(a2, dword_1330F8, (char *)dword_1330F4, a3);
}
// 994C4: using guessed type int dword_994C4;
// 1330F4: using guessed type int dword_1330F4;
// 1330F8: using guessed type int dword_1330F8;
// 1330FC: using guessed type __int16 word_1330FC;
// 74C28: using guessed type __int16 var_18[12];

//----- (00074CBC) --------------------------------------------------------
_WORD *__fastcall sub_74CBC(int a1, int a2, int a3, int a4)
{
  _WORD v5[3]; // [esp-6h] [ebp-278h] BYREF
  unsigned int v6; // [esp+0h] [ebp-272h]
  char s1[80]; // [esp+1FAh] [ebp-78h] BYREF
  unsigned __int16 v8; // [esp+24Ah] [ebp-28h] BYREF
  unsigned __int16 v9; // [esp+24Ch] [ebp-26h]
  unsigned __int16 v10; // [esp+250h] [ebp-22h]
  char *v11; // [esp+25Ah] [ebp-18h] BYREF
  int v12[5]; // [esp+25Eh] [ebp-14h] BYREF

  v12[3] = a4;
  v8 = 0x4F00;
  strncpy((char *)v5, "VBE2", 4u);
  sub_74C28(&v8, v5, 0x200u);
  if ( v8 != 0x4F )
  {
    return 0;
  }
  if ( strncmp((const char *)v5, "VESA", 4u) )
  {
    return 0;
  }
  sub_76A04(v12, &v11, HIWORD(v6), (unsigned __int16)v6);
  sub_75F98(s1, v12[0], v11, 0x50u);
  if ( strncmp(s1, "Universal VESA VBE", 0x12u) )
  {
    return 0;
  }
  v8 = 0x4F0F;
  v9 = 0x1234;
  sub_76AD8(0x10, &v8, &v8);
  if ( v8 != 0x4F )
  {
    return 0;
  }
  sub_76A04(v12, &v11, v10, v9);
  sub_75F98(word_133100, v12[0], v11, 0xF2u);
  return word_133100;
}
// 133100: using guessed type _WORD word_133100[122];

//----- (00074E4C) --------------------------------------------------------
int __fastcall sub_74E4C(int a1, int a2, int a3, int a4)
{
  __int16 v5; // [esp-2h] [ebp-224h] BYREF
  int v6; // [esp+0h] [ebp-222h]
  unsigned int v7; // [esp+4h] [ebp-21Eh]
  __int16 v8[8]; // [esp+1FEh] [ebp-24h] BYREF
  int v9; // [esp+20Eh] [ebp-14h] BYREF
  int v10[4]; // [esp+212h] [ebp-10h] BYREF

  v10[2] = a4;
  v8[0] = 0x4F00;
  strncpy((char *)&v5, "VBE2", 4u);
  sub_74C28((unsigned __int16 *)v8, &v5, 0x200u);
  if ( v8[0] != 0x4F )
  {
    return 0;
  }
  if ( strncmp((const char *)&v5, "VESA", 4u) )
  {
    return 0;
  }
  if ( SHIWORD(v6) > 0x200 )
  {
    sub_76A04(v10, &v9, HIWORD(v7), (unsigned __int16)v7);
    if ( sub_75F45(v10[0], v9) == 0x54524F56 )
    {
      HIWORD(v6) = 0x102;
    }
  }
  return SHIWORD(v6);
}
// 74E4C: using guessed type __int16 var_24[8];

//----- (00074F2C) --------------------------------------------------------
void __noreturn sub_74F2C()
{
  printf("In order for this program to be able to function correctly with your video\n");
  printf("card, it requires a VESA VBE SuperVGA BIOS implemenation to be installed.\n");
  printf("Please install the VESA VBE driver that came with your video card *BEFORE*\n");
  printf("attempting to run this program again.\n\n");
  printf("Your VESA driver will be a program called VESA.EXE, VVESA.EXE or something\n");
  printf("similar and will be located in your video cards driver utilities directories.\n");
  printf("If you dont have a proper VESA VBE driver, please contact SciTech Software\n");
  printf("as we may have a suitable TSR for your video card (this TSR is required in\n");
  printf("*ADDITION* to UniVBE, so that UniVBE can correctly set the video modes).\n");
  exit(1);
}
// 74F2C: using guessed type void __noreturn sub_74F2C();

//----- (00074FAC) --------------------------------------------------------
BOOL __fastcall sub_74FAC(char a1, int a2, int a3, int a4)
{
  unsigned __int16 v5[10]; // [esp+0h] [ebp-1Ch] BYREF
  int v6; // [esp+14h] [ebp-8h]

  v6 = a4;
  HIBYTE(v5[1]) = a1;
  strcpy((char *)v5, "\bO");
  sub_76AD8(0x10, v5, v5);
  return v5[0] == 0x4F;
}

//----- (0007501C) --------------------------------------------------------
__int16 sub_7501C()
{
  __int16 result; // ax

  if ( dword_994BC )
  {
    return sub_76618(0x10, dword_994BC);
  }
  return result;
}
// 994BC: using guessed type int dword_994BC;

//----- (00075034) --------------------------------------------------------
void __fastcall sub_75034(int a1)
{
  unsigned __int16 *v1; // edx
  unsigned __int16 v2; // ax
  bool v3; // cc
  _WORD *i; // eax
  unsigned __int16 v5; // bx

  v1 = (unsigned __int16 *)(a1 + 0x194);
  while ( 1 )
  {
    while ( 1 )
    {
      v2 = *v1;
      if ( *v1 == 0xFFFF )
      {
        JUMPOUT(0x74FE8);
      }
      if ( v2 >= 0x12Du )
      {
        break;
      }
      if ( v2 < 0x10Du )
      {
        goto LABEL_10;
      }
      v3 = v2 <= 0x10Fu;
LABEL_9:
      if ( v3 )
      {
        goto LABEL_11;
      }
LABEL_10:
      ++v1;
    }
    if ( v2 > 0x141u )
    {
      if ( v2 < 0x153u )
      {
        goto LABEL_10;
      }
      v3 = v2 <= 0x158u;
      goto LABEL_9;
    }
LABEL_11:
    for ( i = v1; ; i[0xFFFFFFFF] = v5 )
    {
      v5 = i[1];
      if ( v5 == 0xFFFF )
      {
        break;
      }
      ++i;
    }
    *i = 0xFFFF;
  }
}
// 7504C: control flows out of bounds to 74FE8

//----- (00075098) --------------------------------------------------------
FILE *__usercall sub_75098@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, char *a5, int a6)
{
  char *v7; // edi
  char v8; // al
  char v9; // al
  const char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  FILE *result; // eax
  FILE *v15; // edi
  void *v16; // eax
  int v17; // ebp
  const char *v18; // eax
  char *v19; // edx
  int v20; // eax
  _WORD *v21; // eax
  int v22; // ebx
  unsigned __int16 v23; // dx
  __int16 v24; // ax
  size_t v25; // ecx
  int v26; // edi
  const char *v27; // eax
  char *v28; // eax
  int v29; // edx
  __int16 v30; // ax
  const char *v31; // [esp-8h] [ebp-ACh]
  const char *v32; // [esp-4h] [ebp-A8h]
  char *v33; // [esp-4h] [ebp-A8h]
  char s[144]; // [esp+0h] [ebp-A4h] BYREF
  size_t n; // [esp+90h] [ebp-14h]
  int v36; // [esp+94h] [ebp-10h]

  if ( !a6 && sub_74E4C(a1, a2, a4, a3) >= 0x200 )
  {
    return 0;
  }
  v7 = s;
  do
  {
    v8 = *a5;
    *v7 = *a5;
    if ( !v8 )
    {
      break;
    }
    v9 = a5[1];
    a5 += 2;
    v7[1] = v9;
    v7 += 2;
  }
  while ( v9 );
  v10 = "univbe.drv";
  v11 = &s[strlen(s)];
  do
  {
    v12 = *v10;
    *v11 = *v10;
    if ( !v12 )
    {
      break;
    }
    v13 = v10[1];
    v10 += 2;
    v11[1] = v13;
    v11 += 2;
  }
  while ( v13 );
  result = fopen(s, "rb");
  v15 = result;
  if ( !result )
  {
    return result;
  }
  n = sub_74BF0(result);
  v16 = malloc(n + 0x10);
  v17 = (int)v16;
  if ( !v16 )
  {
    printf("UVBLib: Not enough memory to update configuration!\n");
    exit(1);
  }
  fread(v16, 1u, n, v15);
  fclose(v15);
  if ( strncmp((const char *)v17, "Universal VESA VBE", 0x12u) )
  {
    printf("UVBLib: %s is not a valid UniVBE driver file!\n", s);
    exit(1);
  }
  v32 = (const char *)sub_75510();
  v18 = (const char *)sub_75508();
  sprintf(s, "%s.%s", v18, v32);
  v19 = s;
  if ( strncmp((const char *)(v17 + 0x3F), s, 9u) )
  {
    printf("UVBLib: Driver file version is different!\n");
    exit(1);
  }
  if ( *(unsigned __int16 *)(v17 + 0x172) == 0xFFFF )
  {
    printf("Please run UVCONFIG.EXE to configure the UNIVBE.DRV driver.\n");
    exit(1);
  }
  v20 = *(unsigned __int16 *)(v17 + 0x172);
  if ( (unsigned __int16)v20 == 0x1C
    || (v21 = sub_74CBC(v20, (int)s, 9, (int)v15)) != 0
    && ((LOBYTE(v19) = *((_BYTE *)v21 + 0xE1), BYTE1(v19) = *(_BYTE *)(v17 + 0x129), (unsigned __int8)v19 > BYTE1(v19))
     || (_BYTE)v19 == BYTE1(v19)
     && (LOBYTE(v21) = *((_BYTE *)v21 + 0xE2), (unsigned __int8)v21 >= *(_BYTE *)(v17 + 0x12A))) )
  {
    free((void *)v17);
    return 0;
  }
  if ( *(_WORD *)(v17 + 0x17E) && !sub_74E4C((int)v21, (int)v19, 9, (int)v15) )
  {
    sub_74F2C();
  }
  v22 = n;
  if ( !sub_76A40(n, &dword_994B4, &dword_994B8, &dword_1330F0, &dword_1330EC) )
  {
    printf("UVBLib: Unable to allocate real mode memory!\n");
    exit(1);
  }
  sub_765D4(0x10, &dword_994BC);
  v23 = *(_WORD *)(v17 + 0x176);
  *(_DWORD *)(v17 + 0x190) = dword_994BC;
  *(_WORD *)(v17 + 0x162) = (int)v23 >> 6;
  v24 = dword_1330F0;
  *(_WORD *)(v17 + 0x18C) = dword_1330F0;
  *(_WORD *)(v17 + 0x158) = v24;
  *(_WORD *)(v17 + 0x160) = v24;
  *(_WORD *)(v17 + 0x864) = v24;
  *(_WORD *)(v17 + 0x868) = v24;
  *(_WORD *)(v17 + 0x86C) = v24;
  *(_WORD *)(v17 + 0x870) = v24;
  *(_WORD *)(v17 + 0x874) = v24;
  *(_WORD *)(v17 + 0x878) = v24;
  *(_WORD *)(v17 + 0x87C) = v24;
  *(_WORD *)(v17 + 0x880) = v24;
  *(_WORD *)(v17 + 0x884) = v24;
  *(_WORD *)(v17 + 0x888) = v24;
  *(_WORD *)(v17 + 0x88C) = v24;
  *(_WORD *)(v17 + 0x890) = v24;
  *(_WORD *)(v17 + 0x894) = v24;
  *(_WORD *)(v17 + 0x8B4) = v24;
  *(_WORD *)(v17 + 0x8B8) = v24;
  *(_WORD *)(v17 + 0x8BC) = v24;
  *(_WORD *)(v17 + 0x8C0) = v24;
  v25 = n;
  *(_WORD *)(v17 + 0x8C4) = v24;
  *(_WORD *)(v17 + 0x8C8) = v24;
  sub_75FBE(dword_994B4, (char *)dword_994B8, (_WORD *)v17, v25);
  if ( dword_994C0 != 0x4321 )
  {
    v36 = sub_764C0();
    v26 = sub_75F45(v36, 0x6C);
    printf("UVBELib(tm)/Lite  - Universal VESA BIOS Extension Linkable Library\n");
    v33 = sub_75518();
    v31 = (const char *)sub_75510();
    v27 = (const char *)sub_75508();
    printf("                    Release %s.%s (%s)\n\n", v27, v31, v33);
    v28 = sub_75500();
    printf(off_95504, v28);
    printf("\n");
    printf("Video Card: %s\n", (const char *)(v17 + 0x48));
    printf("RAM DAC:    %s\n\n", (const char *)(v17 + 0x98));
    while ( (unsigned int)(sub_75F45(v36, 0x6C) - v26) < 0x23 )
    {
      ;
    }
  }
  *(_WORD *)(v17 + 0x123) = 1;
  *(_WORD *)(v17 + 0x125) = 1;
  *(_WORD *)(v17 + 0x127) = 1;
  sub_75034(v17);
  v29 = dword_1330F0 << 0x10;
  sub_76618(0x10, (dword_1330F0 << 0x10) | *(unsigned __int16 *)(v17 + 0x18E));
  if ( sub_74FAC(6, v29, v22, v25) )
  {
    v30 = *(_WORD *)(v17 + 0x15A);
    LOBYTE(v30) = v30 | 1;
    sub_75F6C(dword_994B4, dword_994B8 + 0x15A, v30);
  }
  free((void *)v17);
  return (FILE *)1;
}
// 74F2C: using guessed type void __noreturn sub_74F2C(void);
// 994B4: using guessed type int dword_994B4;
// 994B8: using guessed type int dword_994B8;
// 994BC: using guessed type int dword_994BC;
// 994C0: using guessed type int dword_994C0;
// 1330EC: using guessed type _DWORD dword_1330EC;
// 1330F0: using guessed type int dword_1330F0;
// 75098: using guessed type char s[144];

//----- (00075500) --------------------------------------------------------
char *sub_75500()
{
  return off_994C8;
}
// 994C8: using guessed type char *off_994C8;

//----- (00075508) --------------------------------------------------------
void *sub_75508()
{
  return off_994CC;
}
// 994CC: using guessed type void *off_994CC;

//----- (00075510) --------------------------------------------------------
void *sub_75510()
{
  return off_994D0;
}
// 994D0: using guessed type void *off_994D0;

//----- (00075518) --------------------------------------------------------
char *sub_75518()
{
  return off_994D4;
}
// 994D4: using guessed type char *off_994D4;

//----- (00075520) --------------------------------------------------------
int __usercall sub_75520@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v8; // [esp-28h] [ebp-28h] BYREF
  int v9; // [esp-24h] [ebp-24h]
  int v10; // [esp-20h] [ebp-20h]
  _DWORD v11[5]; // [esp-1Ch] [ebp-1Ch]
  _DWORD v12[2]; // [esp-8h] [ebp-8h] BYREF
  void *retaddr[2]; // [esp+0h] [ebp+0h]

  v12[1] = (unsigned __int16)__DS__;
  v12[0] = (unsigned __int16)__ES__;
  v11[4] = a7;
  v11[3] = a6;
  v11[2] = a5;
  v11[1] = v12;
  v11[0] = a4;
  v10 = a3;
  v9 = a2;
  v8 = a1;
  word_995D8 = __SS__;
  dword_995DA = (int)&v8;
  dword_997F8((unsigned __int16)a1, (unsigned __int16)a4, (unsigned __int16)a3, (unsigned __int16)a2);
  return MK_FP(retaddr[0], retaddr[0])(
           *MK_FP(word_995D8, &v8),
           *MK_FP(word_995D8, &v9),
           *MK_FP(word_995D8, v11),
           *MK_FP(word_995D8, &v10));
}
// 995D8: using guessed type __int16 word_995D8;
// 995DA: using guessed type int dword_995DA;
// 997F8: using guessed type int (__cdecl *dword_997F8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000756E9) --------------------------------------------------------
void sub_756E9()
{
  _enable();
  *MK_FP(dword_133218, dword_13320C) = 1;
  __asm { iret }
}
// 75714: control flows out of bounds to 75715
// 13320C: using guessed type int dword_13320C;
// 133218: using guessed type int dword_133218;

//----- (00075748) --------------------------------------------------------
void __usercall sub_75748(__int16 a1@<ax>, __int16 a2@<di>)
{
  int v2; // ebx

  _enable();
  __ES__ = dword_133204;
  v2 = dword_133220;
  *MK_FP(dword_133204, dword_133220) = a1;
  *(_WORD *)(v2 + 2) = a2;
  __asm { iret }
}
// 7577A: control flows out of bounds to 7577B
// 133204: using guessed type int dword_133204;
// 133220: using guessed type int dword_133220;

//----- (000757C1) --------------------------------------------------------
int sub_757C1()
{
  int result; // eax

  LOWORD(result) = 0xC;
  __asm { int     33h; - MS MOUSE - DEFINE INTERRUPT SUBROUTINE PARAMETERS }
  return result;
}

//----- (000758F4) --------------------------------------------------------
void sub_758F4()
{
  BOOL v0; // esi
  int v1; // esi
  int v2; // esi

  if ( !dword_9982C )
  {
    sub_764AD();
    v0 = !sub_75E48((int)&dword_997F0, 0xFFF);
    v1 = !sub_75E48((int)&unk_994D8, 0xFFF) || v0;
    v2 = !sub_75EF0((int)sub_75860, 0xFFF) | v1;
    if ( !sub_75EF0((int)sub_75520, 0xFFF) | v2 )
    {
      printf("Page locking services failed - interrupt handling not safe!\n");
      exit(1);
    }
    dword_9982C = 1;
  }
}
// 75860: using guessed type int sub_75860();
// 997F0: using guessed type int dword_997F0;
// 9982C: using guessed type int dword_9982C;

//----- (000759A8) --------------------------------------------------------
int __cdecl sub_759A8(int a1, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD))
{
  sub_758F4();
  dword_133210 = a1;
  dword_997F8 = a2;
  sub_757C1();
  return 1;
}
// 997F8: using guessed type int (__cdecl *dword_997F8)(_DWORD, _DWORD, _DWORD, _DWORD);
// 133210: using guessed type int dword_133210;

//----- (000759D4) --------------------------------------------------------
__int32 sub_759D4()
{
  __int32 result; // eax
  __int32 v1[7]; // [esp+0h] [ebp-1Ch] BYREF

  if ( dword_997F8 )
  {
    LOWORD(v1[0]) = 0x21;
    result = sub_765A4(0x33, v1, v1);
    dword_997F8 = 0;
  }
  return result;
}
// 997F8: using guessed type int (__cdecl *dword_997F8)(_DWORD, _DWORD, _DWORD, _DWORD);
// 759D4: using guessed type __int32 var_1C[7];

//----- (00075A08) --------------------------------------------------------
int __cdecl sub_75A08(char a1, int a2)
{
  int result; // eax
  __int32 v3; // [esp+0h] [ebp-1Ch] BYREF
  char v4; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-10h]

  v4 = a1;
  LOWORD(v3) = 0x204;
  sub_765A4(0x31, &v3, &v3);
  *(_WORD *)(a2 + 4) = v5;
  result = v6;
  *(_DWORD *)a2 = v6;
  return result;
}

//----- (00075A44) --------------------------------------------------------
__int32 __cdecl sub_75A44(char a1, int a2)
{
  __int32 v3; // [esp+0h] [ebp-28h] BYREF
  char v4; // [esp+4h] [ebp-24h]
  __int16 v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+Ch] [ebp-1Ch]
  _WORD v7[6]; // [esp+1Ch] [ebp-Ch] BYREF

  sub_764AD();
  v4 = a1;
  LOWORD(v3) = 0x205;
  sub_75FE4(v7);
  v5 = v7[1];
  v6 = a2;
  return sub_765A4(0x31, &v3, &v3);
}

//----- (00075A8C) --------------------------------------------------------
__int32 __cdecl sub_75A8C(char a1, int a2, __int16 a3)
{
  __int32 v4; // [esp+0h] [ebp-1Ch] BYREF
  char v5; // [esp+4h] [ebp-18h]
  __int16 v6; // [esp+8h] [ebp-14h]
  int v7; // [esp+Ch] [ebp-10h]

  v5 = a1;
  v6 = a3;
  v7 = a2;
  LOWORD(v4) = 0x205;
  return sub_765A4(0x31, &v4, &v4);
}

//----- (00075AC4) --------------------------------------------------------
int *__fastcall sub_75AC4(char a1, int a2, int *a3)
{
  sub_75A08(a1, a2);
  return sub_765D4(a1, a3);
}

//----- (00075AE8) --------------------------------------------------------
__int32 __fastcall sub_75AE8(char a1, int a2, int a3, int a4, int a5, __int16 a6, int a7)
{
  sub_76618(a1, a7);
  return sub_75A8C(a1, a5, a6);
}

//----- (00075B18) --------------------------------------------------------
__int32 __fastcall sub_75B18(char a1, int a2)
{
  sub_758F4();
  return sub_75A44(a1, a2);
}

//----- (00075E48) --------------------------------------------------------
BOOL __cdecl sub_75E48(int a1, int a2)
{
  __int32 v3; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v4; // [esp+4h] [ebp-18h]
  __int16 v5; // [esp+8h] [ebp-14h]
  __int16 v6; // [esp+10h] [ebp-Ch]
  __int16 v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  v4 = HIWORD(a1);
  v6 = HIWORD(a2);
  v7 = a2;
  LOWORD(v3) = 0x600;
  v5 = a1;
  sub_765A4(0x31, &v3, &v3);
  return (_WORD)v8 == 0;
}

//----- (00075E9C) --------------------------------------------------------
BOOL __cdecl sub_75E9C(int a1, int a2)
{
  __int32 v3; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v4; // [esp+4h] [ebp-18h]
  __int16 v5; // [esp+8h] [ebp-14h]
  __int16 v6; // [esp+10h] [ebp-Ch]
  __int16 v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  v4 = HIWORD(a1);
  v6 = HIWORD(a2);
  v7 = a2;
  LOWORD(v3) = 0x601;
  v5 = a1;
  sub_765A4(0x31, &v3, &v3);
  return (_WORD)v8 == 0;
}

//----- (00075EF0) --------------------------------------------------------
BOOL __cdecl sub_75EF0(int a1, int a2)
{
  return sub_75E48(a1, a2);
}

//----- (00075F20) --------------------------------------------------------
char __cdecl sub_75F20(__int16 a1, int a2)
{
  return *MK_FP(a1, a2);
}

//----- (00075F32) --------------------------------------------------------
__int16 __cdecl sub_75F32(__int16 a1, int a2)
{
  return *MK_FP(a1, a2);
}

//----- (00075F45) --------------------------------------------------------
int __cdecl sub_75F45(__int16 a1, int a2)
{
  return *MK_FP(a1, a2);
}

//----- (00075F6C) --------------------------------------------------------
__int16 __cdecl sub_75F6C(__int16 a1, int a2, __int16 a3)
{
  __int16 result; // ax

  result = a3;
  *MK_FP(a1, a2) = a3;
  return result;
}

//----- (00075F98) --------------------------------------------------------
__int16 __cdecl sub_75F98(_WORD *a1, __int16 a2, char *a3, unsigned int a4)
{
  __int16 result; // ax
  unsigned int i; // ecx

  result = a2;
  for ( i = a4 >> 1; i; --i )
  {
    *a1 = *MK_FP(a2, a3);
    a3 += 2;
    ++a1;
  }
  qmemcpy(a1, a3, a4 & 1);
  return result;
}

//----- (00075FBE) --------------------------------------------------------
__int16 __cdecl sub_75FBE(__int16 a1, char *a2, _WORD *a3, unsigned int a4)
{
  __int16 result; // ax
  unsigned int i; // ecx

  result = a1;
  for ( i = a4 >> 1; i; --i )
  {
    *MK_FP(a1, a2) = *a3++;
    a2 += 2;
  }
  qmemcpy(a2, a3, a4 & 1);
  return result;
}

//----- (00075FE4) --------------------------------------------------------
_WORD *__cdecl sub_75FE4(_WORD *a1)
{
  _WORD *result; // eax

  result = a1;
  *a1 = __ES__;
  a1[1] = __CS__;
  a1[2] = __SS__;
  a1[3] = __DS__;
  a1[4] = __FS__;
  a1[5] = __GS__;
  return result;
}

//----- (00076404) --------------------------------------------------------
__int32 __cdecl sub_76404(int a1)
{
  __int32 v2; // [esp+4h] [ebp-4h] BYREF

  return _InterlockedExchange(&v2, (__int32)&dword_76004[a1]);
}
// 76004: using guessed type int dword_76004[256];

//----- (0007641A) --------------------------------------------------------
__int32 __cdecl sub_7641A(int a1, _DWORD *a2, __int32 *a3, _WORD *a4)
{
  __int32 v4; // ebx
  __int32 v5; // ecx
  __int32 v6; // edx
  __int32 v7; // edi
  __int32 v8; // esi
  __int32 result; // eax
  char v10; // kr00_1

  __ES__ = *a4;
  __FS__ = a4[4];
  __GS__ = a4[5];
  v4 = a2[1];
  v5 = a2[2];
  v6 = a2[3];
  v7 = a2[5];
  v8 = a2[4];
  result = sub_76404(a1);
  v10 = __readeflags();
  *a3 = result;
  a3[1] = v4;
  a3[2] = v5;
  a3[3] = v6;
  a3[4] = v8;
  a3[5] = v7;
  a3[6] = v10 & 1;
  *a4 = __ES__;
  a4[3] = __DS__;
  a4[4] = __FS__;
  a4[5] = __GS__;
  return result;
}

//----- (000764AD) --------------------------------------------------------
void sub_764AD()
{
  word_99850 = __DS__;
}
// 99850: using guessed type __int16 word_99850;

//----- (000764C0) --------------------------------------------------------
int sub_764C0()
{
  if ( !dword_99858 )
  {
    dword_99858 = sub_76CB4(0x400u, 0xFFFF);
  }
  return dword_99858;
}
// 99858: using guessed type int dword_99858;

//----- (00076520) --------------------------------------------------------
int sub_76520()
{
  if ( !dword_9985C )
  {
    dword_9985C = sub_76CB4((unsigned int)&unk_B8000, 0xFFFF);
  }
  return dword_9985C;
}
// 9985C: using guessed type int dword_9985C;

//----- (0007654C) --------------------------------------------------------
int sub_7654C()
{
  if ( !dword_99860 )
  {
    dword_99860 = sub_76CB4((unsigned int)&unk_B0000, 0xFFFF);
  }
  return dword_99860;
}
// 99860: using guessed type int dword_99860;

//----- (00076578) --------------------------------------------------------
int sub_76578()
{
  if ( !dword_99864 )
  {
    dword_99864 = sub_76CB4((unsigned int)&V_CobFilesIndex_stru_9A254.fnames[0x1DF][0x1E], 0xFFFF);
  }
  return dword_99864;
}
// 99864: using guessed type int dword_99864;

//----- (000765A4) --------------------------------------------------------
__int32 __cdecl sub_765A4(int a1, _DWORD *a2, __int32 *a3)
{
  _WORD v4[6]; // [esp+0h] [ebp-Ch] BYREF

  sub_75FE4(v4);
  return sub_7641A(a1, a2, a3, v4);
}
// 765A4: using guessed type _WORD var_C[6];

//----- (000765D4) --------------------------------------------------------
int *__cdecl sub_765D4(char a1, int *a2)
{
  int *result; // eax
  unsigned __int16 v3[8]; // [esp+0h] [ebp-18h] BYREF
  unsigned __int16 v4[4]; // [esp+10h] [ebp-8h] BYREF

  sub_764AD();
  HIBYTE(v3[0]) = 0x35;
  LOBYTE(v3[0]) = a1;
  sub_76BB0(0x21, v3, v3, (__int16 *)v4);
  result = a2;
  *a2 = v3[1] | (v4[0] << 0x10);
  return result;
}
// 765D4: using guessed type unsigned __int16 var_8[4];

//----- (00076618) --------------------------------------------------------
__int16 __cdecl sub_76618(char a1, int a2)
{
  unsigned __int16 v3[8]; // [esp+0h] [ebp-18h] BYREF
  __int16 v4[4]; // [esp+10h] [ebp-8h] BYREF

  sub_764AD();
  HIBYTE(v3[0]) = 0x25;
  LOBYTE(v3[0]) = a1;
  v4[3] = HIWORD(a2);
  v3[3] = a2;
  return sub_76BB0(0x21, v3, v3, v4);
}

//----- (00076658) --------------------------------------------------------
int __fastcall sub_76658(int a1, int a2)
{
  __int32 v3; // [esp+0h] [ebp-1Ch] BYREF
  unsigned __int16 v4; // [esp+4h] [ebp-18h]
  unsigned __int16 v5; // [esp+8h] [ebp-14h]
  __int16 v6; // [esp+10h] [ebp-Ch]
  __int16 v7; // [esp+14h] [ebp-8h]
  int v8; // [esp+18h] [ebp-4h]

  v5 = a1;
  LOWORD(v3) = 0x800;
  v6 = HIWORD(a2);
  v7 = a2;
  v4 = HIWORD(a1);
  sub_765A4(0x31, &v3, &v3);
  if ( (_WORD)v8 )
  {
    return 0;
  }
  else
  {
    return (v4 << 0x10) + v5;
  }
}

//----- (000766B8) --------------------------------------------------------
BOOL __fastcall sub_766B8(__int16 a1, int a2)
{
  __int32 v3; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v4; // [esp+4h] [ebp-18h]
  __int16 v5; // [esp+8h] [ebp-14h]
  __int16 v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  v4 = a1;
  v5 = HIWORD(a2);
  v6 = a2;
  LOWORD(v3) = 7;
  sub_765A4(0x31, &v3, &v3);
  return (_WORD)v7 == 0;
}

//----- (00076700) --------------------------------------------------------
int __fastcall sub_76700(__int16 a1)
{
  __int32 v2; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v3; // [esp+4h] [ebp-18h]
  unsigned __int16 v4; // [esp+8h] [ebp-14h]
  unsigned __int16 v5; // [esp+Ch] [ebp-10h]

  v3 = a1;
  LOWORD(v2) = 6;
  sub_765A4(0x31, &v2, &v2);
  return v5 + (v4 << 0x10);
}

//----- (00076740) --------------------------------------------------------
BOOL __fastcall sub_76740(__int16 a1, int a2)
{
  __int32 v3; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v4; // [esp+4h] [ebp-18h]
  __int16 v5; // [esp+8h] [ebp-14h]
  __int16 v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  v4 = a1;
  v5 = HIWORD(a2);
  v6 = a2;
  LOWORD(v3) = 8;
  sub_765A4(0x31, &v3, &v3);
  return (_WORD)v7 == 0;
}

//----- (00076788) --------------------------------------------------------
int __fastcall sub_76788(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  __int16 v4[3]; // [esp+0h] [ebp-Ch] BYREF
  __int16 v5; // [esp+6h] [ebp-6h]

  result = sub_76658(a1, a2);
  v3 = result;
  if ( result )
  {
    sub_75FE4(v4);
    result = sub_76740(v5, 0xFFFFFFFF);
    if ( result )
    {
      return v3 - sub_76700(v5);
    }
  }
  return result;
}
// 76788: using guessed type __int16 var_C[3];

//----- (000767D4) --------------------------------------------------------
unsigned int __fastcall sub_767D4(unsigned int a1, int a2)
{
  unsigned int result; // eax
  int v4; // edi
  __int32 v5; // [esp+0h] [ebp-20h] BYREF
  __int16 v6; // [esp+4h] [ebp-1Ch]
  __int16 v7; // [esp+8h] [ebp-18h]
  int v8; // [esp+18h] [ebp-8h]
  int v9; // [esp+1Ch] [ebp-4h]

  v9 = a2;
  LOWORD(v5) = 0;
  v7 = 1;
  sub_765A4(0x31, &v5, &v5);
  if ( (_WORD)v8 )
  {
    return 0;
  }
  v4 = (unsigned __int16)v5;
  if ( a1 <= (unsigned int)&unk_100000
    || (LOWORD(v5) = 9, v6 = v4, v7 = 0x8092, sub_765A4(0x31, &v5, &v5), result = sub_76658(a1, v9), (a1 = result) != 0) )
  {
    result = sub_766B8(v4, a1);
    if ( result )
    {
      result = sub_76740(v4, v9);
      if ( result )
      {
        return v4;
      }
    }
  }
  return result;
}

//----- (00076874) --------------------------------------------------------
__int32 __fastcall sub_76874(__int16 a1)
{
  __int32 v2; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v3; // [esp+4h] [ebp-18h]

  v3 = a1;
  LOWORD(v2) = 1;
  return sub_765A4(0x31, &v2, &v2);
}

//----- (00076A04) --------------------------------------------------------
_DWORD *__cdecl sub_76A04(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *result; // eax

  if ( !dword_99878 )
  {
    dword_99878 = sub_76CB4(dword_99878, (int)&unk_FFFFF);
  }
  *a1 = dword_99878;
  result = a2;
  *a2 = 0x10 * a3 + a4;
  return result;
}
// 99878: using guessed type int dword_99878;

//----- (00076A40) --------------------------------------------------------
int __cdecl sub_76A40(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  __int32 v6; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v7; // [esp+4h] [ebp-18h]
  unsigned __int16 v8; // [esp+Ch] [ebp-10h]
  int v9; // [esp+18h] [ebp-4h]

  v7 = (unsigned int)(a1 + 0xF) >> 4;
  LOWORD(v6) = 0x100;
  sub_765A4(0x31, &v6, &v6);
  if ( (_WORD)v9 )
  {
    return 0;
  }
  *a2 = v8;
  *a3 = 0;
  *a4 = (unsigned __int16)v6;
  *a5 = 0;
  return 1;
}
// 76A40: could not find valid save-restore pair for ebx

//----- (00076AAC) --------------------------------------------------------
__int32 __cdecl sub_76AAC(__int16 a1)
{
  __int32 v2[3]; // [esp+0h] [ebp-1Ch] BYREF
  __int16 v3; // [esp+Ch] [ebp-10h]

  v3 = a1;
  LOWORD(v2[0]) = 0x101;
  return sub_765A4(0x31, v2, v2);
}
// 76AAC: using guessed type __int32 var_1C[3];

//----- (00076AD8) --------------------------------------------------------
__int16 __cdecl sub_76AD8(char a1, unsigned __int16 *a2, _WORD *a3)
{
  int s; // [esp+0h] [ebp-5Ch] BYREF
  int v5; // [esp+4h] [ebp-58h]
  int v6; // [esp+10h] [ebp-4Ch]
  int v7; // [esp+14h] [ebp-48h]
  int v8; // [esp+18h] [ebp-44h]
  int v9; // [esp+1Ch] [ebp-40h]
  int v10; // [esp+20h] [ebp-3Ch]
  __int32 v11; // [esp+34h] [ebp-28h] BYREF
  char v12; // [esp+38h] [ebp-24h]
  char v13; // [esp+39h] [ebp-23h]
  __int16 v14; // [esp+3Ch] [ebp-20h]
  int *p_s; // [esp+48h] [ebp-14h]
  __int16 v16[6]; // [esp+50h] [ebp-Ch] BYREF

  memset(&s, 0, 0x32u);
  v9 = *a2;
  v6 = a2[1];
  v8 = a2[2];
  v7 = a2[3];
  v5 = a2[4];
  s = a2[5];
  sub_75FE4(v16);
  v12 = a1;
  v13 = 0;
  v16[0] = v16[3];
  p_s = &s;
  LOWORD(v11) = 0x300;
  v14 = 0;
  sub_7641A(0x31, &v11, &v11, v16);
  *a3 = v9;
  a3[1] = v6;
  a3[2] = v8;
  a3[3] = v7;
  a3[4] = v5;
  a3[5] = s;
  a3[6] = v10 & 1;
  return *a3;
}

//----- (00076BB0) --------------------------------------------------------
__int16 __cdecl sub_76BB0(char a1, unsigned __int16 *a2, _WORD *a3, __int16 *a4)
{
  int s; // [esp+0h] [ebp-5Ch] BYREF
  int v6; // [esp+4h] [ebp-58h]
  int v7; // [esp+10h] [ebp-4Ch]
  int v8; // [esp+14h] [ebp-48h]
  int v9; // [esp+18h] [ebp-44h]
  int v10; // [esp+1Ch] [ebp-40h]
  char v11; // [esp+20h] [ebp-3Ch]
  __int16 v12; // [esp+22h] [ebp-3Ah]
  __int16 v13; // [esp+24h] [ebp-38h]
  int v14; // [esp+2Ch] [ebp-30h]
  int v15; // [esp+30h] [ebp-2Ch]
  __int32 v16; // [esp+34h] [ebp-28h] BYREF
  char v17; // [esp+38h] [ebp-24h]
  char v18; // [esp+39h] [ebp-23h]
  __int16 v19; // [esp+3Ch] [ebp-20h]
  int *p_s; // [esp+48h] [ebp-14h]
  __int16 v21[6]; // [esp+50h] [ebp-Ch] BYREF

  memset(&s, 0, 0x32u);
  v10 = *a2;
  v7 = a2[1];
  v9 = a2[2];
  v8 = a2[3];
  v6 = a2[4];
  s = a2[5];
  v12 = *a4;
  v13 = a4[3];
  sub_75FE4(v21);
  v17 = a1;
  v18 = 0;
  v21[0] = v21[3];
  p_s = &s;
  LOWORD(v16) = 0x300;
  v19 = 0;
  sub_7641A(0x31, &v16, &v16, v21);
  *a3 = v10;
  a3[1] = v7;
  a3[2] = v9;
  a3[3] = v8;
  a3[4] = v6;
  a3[5] = s;
  *a4 = v12;
  a4[1] = v14;
  a4[2] = v15;
  a4[3] = v13;
  a3[6] = v11 & 1;
  return *a3;
}

//----- (00076CB4) --------------------------------------------------------
unsigned int __cdecl sub_76CB4(unsigned int a1, int a2)
{
  return sub_767D4(a1, a2);
}

//----- (0007D9E4) --------------------------------------------------------
int __usercall sub_7D9E4@<eax>(int result@<eax>, int a2@<ecx>, _BYTE *a3@<ebp>)
{
  _BYTE v3[108]; // [esp-80h] [ebp-80h] BYREF
  int v4; // [esp-14h] [ebp-14h]
  int v5; // [esp-10h] [ebp-10h]
  int v6; // [esp-Ch] [ebp-Ch]

  a3[4] |= result;
  if ( ((unsigned __int8)result & *a3) == 0 )
  {
    v6 = a2;
    v5 = (unsigned __int16)__ES__;
    v4 = (unsigned __int16)__DS__;
    qmemcpy(v3, a3, sizeof(v3));
    result = __FPE_handler(BYTE1(result));
    qmemcpy(a3, v3, 0x6Cu);
  }
  return result;
}
// 9995D: using guessed type int (__fastcall *__FPE_handler)(_DWORD);

//----- (0007DA32) --------------------------------------------------------
void sub_7DA32()
{
  ;
}

//----- (0007DA38) --------------------------------------------------------
void sub_7DA38()
{
  ;
}

//----- (0007DA3E) --------------------------------------------------------
void sub_7DA3E()
{
  ;
}

//----- (0007DA44) --------------------------------------------------------
void sub_7DA44()
{
  ;
}

//----- (0007DA4A) --------------------------------------------------------
void sub_7DA4A()
{
  ;
}

//----- (0007DA52) --------------------------------------------------------
void sub_7DA52()
{
  ;
}

//----- (0007DA58) --------------------------------------------------------
void sub_7DA58()
{
  ;
}

//----- (0007DA5E) --------------------------------------------------------
void sub_7DA5E()
{
  ;
}

//----- (0007DA64) --------------------------------------------------------
void sub_7DA64()
{
  ;
}

//----- (0007DA6C) --------------------------------------------------------
void sub_7DA6C()
{
  ;
}

//----- (0007DA74) --------------------------------------------------------
void sub_7DA74()
{
  ;
}

//----- (0007DA7C) --------------------------------------------------------
void sub_7DA7C()
{
  ;
}

//----- (0007DA84) --------------------------------------------------------
void sub_7DA84()
{
  ;
}

//----- (0007DA8E) --------------------------------------------------------
void sub_7DA8E()
{
  ;
}

//----- (0007DA98) --------------------------------------------------------
void sub_7DA98()
{
  ;
}

//----- (0007DAA0) --------------------------------------------------------
void sub_7DAA0()
{
  ;
}

//----- (0007DAA8) --------------------------------------------------------
void sub_7DAA8()
{
  ;
}

//----- (0007DAB1) --------------------------------------------------------
void sub_7DAB1()
{
  ;
}

//----- (0007DABA) --------------------------------------------------------
void sub_7DABA()
{
  ;
}

//----- (0007DAC3) --------------------------------------------------------
void sub_7DAC3()
{
  ;
}

//----- (0007DACC) --------------------------------------------------------
void sub_7DACC()
{
  ;
}

//----- (0007DAD7) --------------------------------------------------------
void sub_7DAD7()
{
  ;
}

//----- (0007DAE2) --------------------------------------------------------
void sub_7DAE2()
{
  ;
}

//----- (0007DAEB) --------------------------------------------------------
void sub_7DAEB()
{
  ;
}

//----- (0007DAF4) --------------------------------------------------------
char __usercall sub_7DAF4@<al>(unsigned __int8 a1@<ah>, int a2@<ebx>, _BYTE *a3@<esi>)
{
  char result; // al

  LOWORD(a2) = (a1 >> 3) & 0x18 | *a3 & 7;
  funcs_7DB07[a2]();
  return result;
}
// 7D4E0: using guessed type int (*funcs_7DB07[24])();

//----- (0007DB31) --------------------------------------------------------
int __usercall sub_7DB31@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_7F722(*a3, a1 + 0x6C);
  v3 = sub_7EEF8(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DB50) --------------------------------------------------------
int __usercall sub_7DB50@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_7F722(*a3, a1 + 0x6C);
  v3 = sub_7F32C(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DB6F) --------------------------------------------------------
int __usercall sub_7DB6F@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        signed int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  int v20; // eax

  sub_7F722(*a3, a1 + 0x6C);
  v20 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DB8B) --------------------------------------------------------
int __usercall sub_7DB8B@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        signed int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  __int16 v19; // bx
  int v21; // eax

  sub_7F722(*a3, a1 + 0x6C);
  v21 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v21 + 3);
  *(_WORD *)(a1 + 4) = v18;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DBA7) --------------------------------------------------------
int __usercall sub_7DBA7@<eax>(int a1@<ebp>, signed int *a2@<esi>)
{
  sub_7F722(*a2, a1 + 0x6C);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007DBC6) --------------------------------------------------------
int __usercall sub_7DBC6@<eax>(int a1@<ebp>, signed int *a2@<esi>)
{
  sub_7F722(*a2, a1 + 0x6C);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007DBE5) --------------------------------------------------------
int __usercall sub_7DBE5@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_7F722(*a3, a1 + 0x6C);
  v3 = sub_7F157(a2 + a1 + 0x1C, a1 + 0x6C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DC04) --------------------------------------------------------
int __usercall sub_7DC04@<eax>(int a1@<ebp>, int a2@<edi>, signed int *a3@<esi>)
{
  int v3; // eax

  sub_7F722(*a3, a1 + 0x6C);
  v3 = sub_7F157(a1 + 0x6C, a2 + a1 + 0x1C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DC23) --------------------------------------------------------
int __usercall sub_7DC23@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        signed int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx

  v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
  sub_7F722(*a3, v18 + a1 + 0x1C);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DC5D) --------------------------------------------------------
int __usercall sub_7DC5D@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  *a3 = sub_7F5DC(a2 + a1 + 0x1C);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DC6E) --------------------------------------------------------
void __usercall sub_7DC6E(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  *a3 = sub_7F5DC(a2 + a1 + 0x1C);
  JUMPOUT(0x7D98D);
}
// 7DC7A: control flows out of bounds to 7D98D

//----- (0007DC7F) --------------------------------------------------------
int __usercall sub_7DC7F@<eax>(
        void *a1@<ebp>,
        const void *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  qmemcpy(a1, a2, 0x1Cu);
  return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DC9D) --------------------------------------------------------
int __usercall sub_7DC9D@<eax>(
        int a1@<ebp>,
        __int16 *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  __int16 v17; // ax
  __int16 v18; // ax

  v17 = *a2;
  *(_WORD *)a1 = *a2;
  v18 = v17 & 0x300;
  if ( v18 == 0x300 )
  {
    *(_DWORD *)(a1 + 0x76) = sub_7D7D4;
  }
  else if ( v18 == 0x200 )
  {
    *(_DWORD *)(a1 + 0x76) = sub_7D944;
  }
  else
  {
    *(_DWORD *)(a1 + 0x76) = sub_7D908;
  }
  return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);
// 7D908: using guessed type int sub_7D908();
// 7D944: using guessed type int sub_7D944();

//----- (0007DCDD) --------------------------------------------------------
int __usercall sub_7DCDD@<eax>(
        const void *a1@<ebp>,
        void *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  qmemcpy(a2, a1, 0x1Cu);
  return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DCF1) --------------------------------------------------------
int __usercall sub_7DCF1@<eax>(
        _WORD *a1@<ebp>,
        _WORD *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  *a2 = *a1;
  return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DCFF) --------------------------------------------------------
int __usercall sub_7DCFF@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7EEF8(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DD1E) --------------------------------------------------------
int __usercall sub_7DD1E@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7F32C(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DD3D) --------------------------------------------------------
int __usercall sub_7DD3D@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  int v20; // eax

  sub_7F516(*a3);
  v20 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DD59) --------------------------------------------------------
int __usercall sub_7DD59@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  __int16 v19; // bx
  int v21; // eax

  sub_7F516(*a3);
  v21 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v21 + 3);
  *(_WORD *)(a1 + 4) = v18;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DD75) --------------------------------------------------------
int __usercall sub_7DD75@<eax>(int a1@<ebp>, int *a2@<esi>)
{
  sub_7F516(*a2);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007DD94) --------------------------------------------------------
int __usercall sub_7DD94@<eax>(int a1@<ebp>, int *a2@<esi>)
{
  sub_7F516(*a2);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007DDB3) --------------------------------------------------------
int __usercall sub_7DDB3@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7F157(a2 + a1 + 0x1C, a1 + 0x6C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DDD2) --------------------------------------------------------
int __usercall sub_7DDD2@<eax>(int a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7F157(a1 + 0x6C, a2 + a1 + 0x1C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DDF1) --------------------------------------------------------
int __usercall sub_7DDF1@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx

  v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
  sub_7F516(*a3);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DE2B) --------------------------------------------------------
int __usercall sub_7DE2B@<eax>(
        _WORD *a1@<ebp>,
        int a2@<edi>,
        _DWORD *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // eax
  _DWORD *v19; // ebx
  int v21; // [esp-Ch] [ebp-Ch]
  int v22; // [esp-8h] [ebp-8h]
  int v23; // [esp-4h] [ebp-4h]

  v23 = *(_DWORD *)((char *)a1 + a2 + 0x1C);
  v22 = *(_DWORD *)((char *)a1 + a2 + 0x20);
  v21 = *(_DWORD *)((char *)a1 + a2 + 0x22);
  sub_7F7E7((unsigned int)a1 + a2 + 0x1C, *a1 & 0xC00);
  sub_7F4A7();
  *a3 = v18;
  v19 = (_DWORD *)((char *)a1 + a2 + 0x1C);
  *(_DWORD *)((char *)v19 + 6) = v21;
  v19[1] = v22;
  *v19 = v23;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7DE53: variable 'v18' is possibly undefined
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DE67) --------------------------------------------------------
void __usercall sub_7DE67(_WORD *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>)
{
  int v3; // eax

  sub_7F7E7((unsigned int)a1 + a2 + 0x1C, *a1 & 0xC00);
  sub_7F4A7();
  *a3 = v3;
  JUMPOUT(0x7D98D);
}
// 7DE86: control flows out of bounds to 7D98D
// 7DE83: variable 'v3' is possibly undefined

//----- (0007DE8B) --------------------------------------------------------
int __usercall sub_7DE8B@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_7F55C(*a3, a1 + 0x6C, (_BYTE *)a1);
  v3 = sub_7EEF8(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DEAE) --------------------------------------------------------
int __usercall sub_7DEAE@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_7F55C(*a3, a1 + 0x6C, (_BYTE *)a1);
  v3 = sub_7F32C(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DED1) --------------------------------------------------------
int __usercall sub_7DED1@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int64 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  int v20; // eax

  sub_7F55C(*a3, a1 + 0x6C, (_BYTE *)a1);
  v20 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DEF1) --------------------------------------------------------
int __usercall sub_7DEF1@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int64 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  __int16 v19; // bx
  int v21; // eax

  sub_7F55C(*a3, a1 + 0x6C, (_BYTE *)a1);
  v21 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v21 + 3);
  *(_WORD *)(a1 + 4) = v18;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DF11) --------------------------------------------------------
int __usercall sub_7DF11@<eax>(int a1@<ebp>, __int64 *a2@<esi>)
{
  sub_7F55C(*a2, a1 + 0x6C, (_BYTE *)a1);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007DF34) --------------------------------------------------------
int __usercall sub_7DF34@<eax>(int a1@<ebp>, __int64 *a2@<esi>)
{
  sub_7F55C(*a2, a1 + 0x6C, (_BYTE *)a1);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007DF57) --------------------------------------------------------
int __usercall sub_7DF57@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_7F55C(*a3, a1 + 0x6C, (_BYTE *)a1);
  v3 = sub_7F157(a2 + a1 + 0x1C, a1 + 0x6C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DF7A) --------------------------------------------------------
int __usercall sub_7DF7A@<eax>(int a1@<ebp>, int a2@<edi>, __int64 *a3@<esi>)
{
  int v3; // eax

  sub_7F55C(*a3, a1 + 0x6C, (_BYTE *)a1);
  v3 = sub_7F157(a1 + 0x6C, a2 + a1 + 0x1C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007DF9D) --------------------------------------------------------
int __usercall sub_7DF9D@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx

  v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
  *(_DWORD *)(v18 + a1 + 0x1C) = *(_DWORD *)a3;
  *(_DWORD *)(v18 + a1 + 0x20) = *(_DWORD *)(a3 + 4);
  *(_WORD *)(v18 + a1 + 0x24) = *(_WORD *)(a3 + 8);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007DFE4) --------------------------------------------------------
int __usercall sub_7DFE4@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int64 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx

  v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
  sub_7F55C(*a3, v18 + a1 + 0x1C, (_BYTE *)a1);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E022) --------------------------------------------------------
int __usercall sub_7E022@<eax>(
        int a1@<edx>,
        _BYTE *a2@<ebp>,
        int a3@<edi>,
        int *a4@<esi>,
        int a5,
        __int16 a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        __int16 a19)
{
  *a4 = sub_7F65B((__int64 *)&a2[a3 + 0x1C], a2);
  a4[1] = a1;
  return sub_7D7D4(a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E037) --------------------------------------------------------
void __usercall sub_7E037(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)a3 = *(_DWORD *)(a2 + a1 + 0x1C);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + a1 + 0x20);
  *(_WORD *)(a3 + 8) = *(_WORD *)(a2 + a1 + 0x24);
  JUMPOUT(0x7D98D);
}
// 7E050: control flows out of bounds to 7D98D

//----- (0007E055) --------------------------------------------------------
void __usercall sub_7E055(int a1@<edx>, _BYTE *a2@<ebp>, int a3@<edi>, int *a4@<esi>)
{
  *a4 = sub_7F65B((__int64 *)&a2[a3 + 0x1C], a2);
  a4[1] = a1;
  JUMPOUT(0x7D98D);
}
// 7E065: control flows out of bounds to 7D98D

//----- (0007E06A) --------------------------------------------------------
int __usercall sub_7E06A@<eax>(
        _DWORD *a1@<ebp>,
        _DWORD *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  _DWORD *v17; // esi
  unsigned int v18; // ebx
  int v19; // ecx
  _DWORD *v20; // esi

  qmemcpy(a1, a2, 0x1Cu);
  v17 = a2 + 7;
  v18 = 0xA * ((a1[1] & 0x3800u) >> 0xB);
  v19 = 8;
  do
  {
    *(_DWORD *)((char *)a1 + v18 + 0x1C) = *v17;
    v20 = v17 + 1;
    *(_DWORD *)((char *)a1 + v18 + 0x20) = *v20++;
    *(_WORD *)((char *)a1 + v18 + 0x24) = *(_WORD *)v20;
    v17 = (_DWORD *)((char *)v20 + 2);
    v18 = *(unsigned __int16 *)((char *)&off_7D3D0 + v18 + 2);
    --v19;
  }
  while ( v19 );
  return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E0B1) --------------------------------------------------------
void __usercall sub_7E0B1(char *a1@<ebp>, int a2@<edi>, _DWORD *a3@<esi>)
{
  _DWORD *v4; // edi
  int v5; // ecx
  _DWORD *v6; // edi

  qmemcpy(a3, a1, 0x1Cu);
  v4 = a3 + 7;
  v5 = 8;
  do
  {
    *v4 = *(_DWORD *)&a1[a2 + 0x1C];
    v6 = v4 + 1;
    *v6++ = *(_DWORD *)&a1[a2 + 0x20];
    *(_WORD *)v6 = *(_WORD *)&a1[a2 + 0x24];
    v4 = (_DWORD *)((char *)v6 + 2);
    a2 = *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2);
    --v5;
  }
  while ( v5 );
  JUMPOUT(0x7E9C7);
}
// 7E0D7: control flows out of bounds to 7E9C7
// 7D3D0: using guessed type void *off_7D3D0;

//----- (0007E0DC) --------------------------------------------------------
int __usercall sub_7E0DC@<eax>(
        int a1@<ebp>,
        _WORD *a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  *a2 = *(_WORD *)(a1 + 4);
  return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E0EA) --------------------------------------------------------
int __usercall sub_7E0EA@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7EEF8(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E10B) --------------------------------------------------------
int __usercall sub_7E10B@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7F32C(a2 + a1 + 0x1C, a1 + 0x6C, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E12C) --------------------------------------------------------
int __usercall sub_7E12C@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int16 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  int v20; // eax

  sub_7F516(*a3);
  v20 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E14A) --------------------------------------------------------
int __usercall sub_7E14A@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int16 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  __int16 v19; // bx
  int v21; // eax

  sub_7F516(*a3);
  v21 = sub_7F0BE(a2 + a1 + 0x1C, a1 + 0x6C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v21 + 3);
  *(_WORD *)(a1 + 4) = v18;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E168) --------------------------------------------------------
int __usercall sub_7E168@<eax>(int a1@<ebp>, __int16 *a2@<esi>)
{
  sub_7F516(*a2);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007E189) --------------------------------------------------------
int __usercall sub_7E189@<eax>(int a1@<ebp>, __int16 *a2@<esi>)
{
  sub_7F516(*a2);
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007E1AA) --------------------------------------------------------
int __usercall sub_7E1AA@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7F157(a2 + a1 + 0x1C, a1 + 0x6C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E1CB) --------------------------------------------------------
int __usercall sub_7E1CB@<eax>(int a1@<ebp>, int a2@<edi>, __int16 *a3@<esi>)
{
  int v3; // eax

  sub_7F516(*a3);
  v3 = sub_7F157(a1 + 0x6C, a2 + a1 + 0x1C, (_BYTE *)a1, (int)a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E1EC) --------------------------------------------------------
int __usercall sub_7E1EC@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        __int16 *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx

  v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
  sub_7F516(*a3);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E228) --------------------------------------------------------
int __usercall sub_7E228@<eax>(
        _WORD *a1@<ebp>,
        int a2@<edi>,
        _WORD *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // eax
  _DWORD *v19; // ebx
  int v21; // [esp-Ch] [ebp-Ch]
  int v22; // [esp-8h] [ebp-8h]
  int v23; // [esp-4h] [ebp-4h]

  v23 = *(_DWORD *)((char *)a1 + a2 + 0x1C);
  v22 = *(_DWORD *)((char *)a1 + a2 + 0x20);
  v21 = *(_DWORD *)((char *)a1 + a2 + 0x22);
  sub_7F7E7((unsigned int)a1 + a2 + 0x1C, *a1 & 0xC00);
  sub_7F4A7();
  if ( (__int16)v18 != v18 )
  {
    LOWORD(v18) = 0x8000;
  }
  *a3 = v18;
  v19 = (_DWORD *)((char *)a1 + a2 + 0x1C);
  *(_DWORD *)((char *)v19 + 6) = v21;
  v19[1] = v22;
  *v19 = v23;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7E252: variable 'v18' is possibly undefined
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E270) --------------------------------------------------------
void __usercall sub_7E270(_WORD *a1@<ebp>, int a2@<edi>, _WORD *a3@<esi>)
{
  int v3; // eax

  sub_7F7E7((unsigned int)a1 + a2 + 0x1C, *a1 & 0xC00);
  sub_7F4A7();
  if ( (__int16)v3 != v3 )
  {
    LOWORD(v3) = 0x8000;
  }
  *a3 = v3;
  JUMPOUT(0x7D98D);
}
// 7E29B: control flows out of bounds to 7D98D
// 7E28E: variable 'v3' is possibly undefined

//----- (0007E2A5) --------------------------------------------------------
int __usercall sub_7E2A5@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        unsigned int *a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx

  v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
  sub_7F527(*a3, v18 + a1 + 0x1C);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E2E4) --------------------------------------------------------
void __usercall sub_7E2E4(_WORD *a1@<ebp>, int a2@<edi>, int *a3@<esi>)
{
  sub_7F7E7((unsigned int)a1 + a2 + 0x1C, *a1 & 0xC00);
  *a3 = sub_7F4AC((int *)((char *)a1 + a2 + 0x1C));
  JUMPOUT(0x7D98D);
}
// 7E303: control flows out of bounds to 7D98D

//----- (0007E30D) --------------------------------------------------------
int __usercall sub_7E30D@<eax>(
        int a1@<ebx>,
        int a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        __int16 a16)
{
  switch ( a1 )
  {
    case 0:
      return sub_7D7D4(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  }
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E33A) --------------------------------------------------------
int __usercall sub_7E33A@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7EEF8(a2 + a1 + 0x1C, a3 + a1 + 0x1C, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E34F) --------------------------------------------------------
int __usercall sub_7E34F@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7F32C(a2 + a1 + 0x1C, a3 + a1 + 0x1C, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E364) --------------------------------------------------------
int __usercall sub_7E364@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  int v20; // eax

  v20 = sub_7F0BE(a2 + a1 + 0x1C, a3 + a1 + 0x1C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E376) --------------------------------------------------------
int __usercall sub_7E376@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  __int16 v19; // bx
  int v21; // eax

  v21 = sub_7F0BE(a2 + a1 + 0x1C, a3 + a1 + 0x1C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v21 + 3);
  *(_WORD *)(a1 + 4) = v18;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E388) --------------------------------------------------------
int __usercall sub_7E388@<eax>(int a1@<ebp>)
{
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007E39D) --------------------------------------------------------
int __usercall sub_7E39D@<eax>(int a1@<ebp>)
{
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007E3B2) --------------------------------------------------------
int __usercall sub_7E3B2@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7F157(a2 + a1 + 0x1C, a3 + a1 + 0x1C, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E3C7) --------------------------------------------------------
int __usercall sub_7E3C7@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7F157(a3 + a1 + 0x1C, a2 + a1 + 0x1C, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007E3DC) --------------------------------------------------------
int __usercall sub_7E3DC@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx

  v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
  *(_DWORD *)(v18 + a1 + 0x1C) = *(_DWORD *)(a3 + a1 + 0x1C);
  *(_DWORD *)(v18 + a1 + 0x20) = *(_DWORD *)(a3 + a1 + 0x20);
  *(_WORD *)(v18 + a1 + 0x24) = *(_WORD *)(a3 + a1 + 0x24);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E424) --------------------------------------------------------
int __usercall sub_7E424@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // ebx
  int v19; // esi
  __int16 v20; // ax

  v18 = a2 + a1 + 0x1C;
  v19 = a3 + a1 + 0x1C;
  *(_DWORD *)v19 = _InterlockedExchange((volatile __int32 *)v18, *(_DWORD *)v19);
  *(_DWORD *)(v19 + 4) = _InterlockedExchange((volatile __int32 *)(a2 + a1 + 0x20), *(_DWORD *)(v19 + 4));
  v20 = *(_WORD *)(a2 + a1 + 0x24);
  *(_WORD *)(v18 + 8) = *(_WORD *)(v19 + 8);
  *(_WORD *)(v19 + 8) = v20;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E44C) --------------------------------------------------------
int __usercall sub_7E44C@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  int result; // eax
  int v20; // eax

  switch ( a1 )
  {
    case 0:
      *(_BYTE *)(a3 + a2 + 0x25) ^= 0x80u;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 1:
      *(_BYTE *)(a3 + a2 + 0x25) &= ~0x80u;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 2:
    case 3:
    case 6:
    case 7:
      JUMPOUT(0x7E308);
    case 4:
      *(_DWORD *)(a2 + 0x6C) = 0;
      *(_DWORD *)(a2 + 0x70) = 0;
      *(_WORD *)(a2 + 0x74) = 0;
      v20 = sub_7F0BE(a3 + a2 + 0x1C, a2 + 0x6C);
      v18 = *(_WORD *)(a2 + 4) & 0xB8FF;
      HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v20 + 3);
      *(_WORD *)(a2 + 4) = v18;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 5:
      sub_7FC6E(a3 + a2 + 0x1C, a2, a3);
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
  }
  return result;
}
// 7E44C: control flows out of bounds to 7E308
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E4CD) --------------------------------------------------------
int __usercall sub_7E4CD@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  int v18; // edi
  __int16 v19; // bx
  int v20; // esi
  int result; // eax
  int v22; // edi
  __int16 v23; // bx
  int v24; // esi
  int v25; // edi
  __int16 v26; // bx
  int v27; // esi
  int v28; // edi
  __int16 v29; // bx
  int v30; // esi
  int v31; // edi
  __int16 v32; // bx
  int v33; // esi
  int v34; // edi
  __int16 v35; // bx
  int v36; // esi
  int v37; // edi
  __int16 v38; // bx
  int v39; // esi

  switch ( a1 )
  {
    case 0:
      v18 = *(unsigned __int16 *)((char *)dword_7D3D4 + a3);
      v19 = *(_WORD *)((char *)dword_7D3D4 + v18 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v19;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v18 + 2);
      v20 = v18 + a2 + 0x1C;
      *(_DWORD *)v20 = 0;
      *(_DWORD *)(v20 + 4) = 0x80000000;
      *(_WORD *)(v20 + 8) = 0x3FFF;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 1:
      v22 = *(unsigned __int16 *)((char *)dword_7D3D4 + a3);
      v23 = *(_WORD *)((char *)dword_7D3D4 + v22 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v23;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v22 + 2);
      v24 = v22 + a2 + 0x1C;
      *(_DWORD *)v24 = 0xCD1B8AFE;
      *(_DWORD *)(v24 + 4) = 0xD49A784B;
      *(_WORD *)(v24 + 8) = 0x4000;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 2:
      v25 = *(unsigned __int16 *)((char *)dword_7D3D4 + a3);
      v26 = *(_WORD *)((char *)dword_7D3D4 + v25 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v26;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v25 + 2);
      v27 = v25 + a2 + 0x1C;
      *(_DWORD *)v27 = 0x5C17F0BC;
      *(_DWORD *)(v27 + 4) = 0xB8AA3B29;
      *(_WORD *)(v27 + 8) = 0x3FFF;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 3:
      v28 = *(unsigned __int16 *)((char *)dword_7D3D4 + a3);
      v29 = *(_WORD *)((char *)dword_7D3D4 + v28 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v29;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v28 + 2);
      v30 = v28 + a2 + 0x1C;
      *(_DWORD *)v30 = 0x2168C235;
      *(_DWORD *)(v30 + 4) = 0xC900DAA2;
      *(_WORD *)(v30 + 8) = 0x4000;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 4:
      v31 = *(unsigned __int16 *)((char *)dword_7D3D4 + a3);
      v32 = *(_WORD *)((char *)dword_7D3D4 + v31 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v32;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v31 + 2);
      v33 = v31 + a2 + 0x1C;
      *(_DWORD *)v33 = 0xFBCFF799;
      *(_DWORD *)(v33 + 4) = 0x9A209A84;
      *(_WORD *)(v33 + 8) = 0x3FFD;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 5:
      v34 = *(unsigned __int16 *)((char *)dword_7D3D4 + a3);
      v35 = *(_WORD *)((char *)dword_7D3D4 + v34 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v35;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v34 + 2);
      v36 = v34 + a2 + 0x1C;
      *(_DWORD *)v36 = 0xD1CF79AC;
      *(_DWORD *)(v36 + 4) = 0xB17217F7;
      *(_WORD *)(v36 + 8) = 0x3FFE;
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 6:
      v37 = *(unsigned __int16 *)((char *)dword_7D3D4 + a3);
      v38 = *(_WORD *)((char *)dword_7D3D4 + v37 + 2);
      *(_WORD *)(a2 + 4) &= 0xC7FFu;
      *(_WORD *)(a2 + 4) |= v38;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v37 + 2);
      v39 = v37 + a2 + 0x1C;
      *(_DWORD *)v39 = 0;
      *(_DWORD *)(v39 + 4) = 0;
      *(_WORD *)(v39 + 8) = 0;
      *(_WORD *)(a2 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v37 + 2);
      *(_WORD *)(a2 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x12] + v37);
      result = sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
      break;
    case 7:
      JUMPOUT(0x7E308);
  }
  return result;
}
// 7E4CD: control flows out of bounds to 7E308
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E6E8) --------------------------------------------------------
int __usercall sub_7E6E8@<eax>(
        int a1@<edx>,
        int a2@<ecx>,
        int a3@<ebx>,
        int a4@<ebp>,
        int a5@<edi>,
        int a6@<esi>,
        int a7,
        __int16 a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        __int16 a21)
{
  int v21; // eax
  int result; // eax
  int v23; // eax
  int v24; // edi
  __int16 v25; // bx
  int v26; // eax
  int v27; // edi
  __int16 v28; // bx
  int v29; // esi
  __int16 v30; // bx
  __int16 v31; // bx

  switch ( a3 )
  {
    case 0:
      v21 = sub_80294(a5 + a4 + 0x1C, a1, a3, a2);
      result = (*(int (__fastcall **)(int))(a4 + 0x76))(v21);
      break;
    case 1:
      v23 = a5 + a4 + 0x1C;
      *(_WORD *)(a4 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a5 + 2);
      *(_WORD *)(a4 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a5 + 2);
      v24 = *(unsigned __int16 *)((char *)&off_7D3D0 + a5 + 2);
      v25 = *(_WORD *)((char *)dword_7D3D4 + v24 + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v25;
      v26 = sub_7FD75(v23, v24 + a4 + 0x1C, (_BYTE *)a4, a6);
      result = (*(int (__fastcall **)(int))(a4 + 0x76))(v26);
      break;
    case 2:
      sub_8025E(a5 + a4 + 0x1C);
      v27 = *(unsigned __int16 *)((char *)dword_7D3D4 + a5);
      v28 = *(_WORD *)((char *)dword_7D3D4 + v27 + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v28;
      *(_WORD *)(a4 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + v27 + 2);
      v29 = v27 + a4 + 0x1C;
      *(_DWORD *)v29 = 0;
      *(_DWORD *)(v29 + 4) = 0x80000000;
      *(_WORD *)(v29 + 8) = 0x3FFF;
      result = sub_7D7D4(a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
      break;
    case 3:
      JUMPOUT(0x7ED79);
    case 4:
      JUMPOUT(0x7EDC2);
    case 5:
      JUMPOUT(0x7EE27);
    case 6:
      v30 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)dword_7D3D4 + a5) + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v30;
      result = sub_7D7D4(a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
      break;
    case 7:
      v31 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a5 + 2) + 2);
      *(_WORD *)(a4 + 4) &= 0xC7FFu;
      *(_WORD *)(a4 + 4) |= v31;
      result = sub_7D7D4(a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
      break;
  }
  return result;
}
// 7E6E8: control flows out of bounds to 7ED79
// 7E6E8: control flows out of bounds to 7EDC2
// 7E6E8: control flows out of bounds to 7EE27
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E7F2) --------------------------------------------------------
#error "7E88F: call analysis failed (funcsize=50)"

//----- (0007E90A) --------------------------------------------------------
int __fastcall sub_7E90A(int a1, int a2, int a3)
{
  return funcs_7E90A[a3]();
}
// 7E308: using guessed type int sub_7E308(void);
// 7E912: using guessed type int (*funcs_7E90A[8])();

//----- (0007E993) --------------------------------------------------------
int __usercall sub_7E993@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
    case 1:
    case 4:
    case 5:
    case 6:
    case 7:
      JUMPOUT(0x7E308);
    case 2:
      *(_WORD *)(a2 + 4) &= 0x7F00u;
      result = sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
      break;
    case 3:
      *(_WORD *)a2 = 0x33F;
      *(_WORD *)(a2 + 4) = 0;
      *(_WORD *)(a2 + 8) = 0xFFFF;
      *(_DWORD *)(a2 + 0x76) = sub_7D7D4;
      result = sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
      break;
  }
  return result;
}
// 7E993: control flows out of bounds to 7E308
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007E9ED) --------------------------------------------------------
int __usercall sub_7E9ED@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7EEF8(a3 + a1 + 0x1C, a2 + a1 + 0x1C, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007EA02) --------------------------------------------------------
int __usercall sub_7EA02@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7F32C(a3 + a1 + 0x1C, a2 + a1 + 0x1C, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007EA17) --------------------------------------------------------
int __usercall sub_7EA17@<eax>(int a1@<ebp>)
{
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007EA2C) --------------------------------------------------------
int __usercall sub_7EA2C@<eax>(int a1@<ebp>)
{
  sub_7EEEA();
  return (*(int (**)(void))(a1 + 0x76))();
}

//----- (0007EA41) --------------------------------------------------------
int __usercall sub_7EA41@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7F157(a2 + a1 + 0x1C, a3 + a1 + 0x1C, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007EA56) --------------------------------------------------------
int __usercall sub_7EA56@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax

  v3 = sub_7F157(a3 + a1 + 0x1C, a2 + a1 + 0x1C, (_BYTE *)a1, a3);
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}

//----- (0007EA6B) --------------------------------------------------------
int __usercall sub_7EA6B@<eax>(
        int a1@<ebp>,
        int a2@<esi>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007EA8A) --------------------------------------------------------
int __usercall sub_7EA8A@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  *(_DWORD *)(a3 + a1 + 0x1C) = *(_DWORD *)(a2 + a1 + 0x1C);
  *(_DWORD *)(a3 + a1 + 0x20) = *(_DWORD *)(a2 + a1 + 0x20);
  *(_WORD *)(a3 + a1 + 0x24) = *(_WORD *)(a2 + a1 + 0x24);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a3 + 2);
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007EAB6) --------------------------------------------------------
int __usercall sub_7EAB6@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  int v20; // eax

  v20 = sub_7F0BE(a2 + a1 + 0x1C, a3 + a1 + 0x1C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v20 + 3);
  *(_WORD *)(a1 + 4) = v18;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007EAC8) --------------------------------------------------------
int __usercall sub_7EAC8@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        int a4,
        __int16 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        __int16 a18)
{
  __int16 v18; // dx
  __int16 v19; // bx
  int v21; // eax

  v21 = sub_7F0BE(a2 + a1 + 0x1C, a3 + a1 + 0x1C);
  v18 = *(_WORD *)(a1 + 4) & 0xB8FF;
  HIBYTE(v18) |= *((_BYTE *)&dword_7D3DC[0x25] + v21 + 3);
  *(_WORD *)(a1 + 4) = v18;
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v19 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v19;
  return sub_7D7D4(a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007EADA) --------------------------------------------------------
void __usercall sub_7EADA(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)(a3 + a1 + 0x1C) = *(_DWORD *)(a2 + a1 + 0x1C);
  *(_DWORD *)(a3 + a1 + 0x20) = *(_DWORD *)(a2 + a1 + 0x20);
  *(_WORD *)(a3 + a1 + 0x24) = *(_WORD *)(a2 + a1 + 0x24);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a3 + 2);
  JUMPOUT(0x7D98D);
}
// 7EB01: control flows out of bounds to 7D98D
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007EB06) --------------------------------------------------------
int __usercall sub_7EB06@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_7EEF8(a3 + a1 + 0x1C, a2 + a1 + 0x1C, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007EB51) --------------------------------------------------------
int __usercall sub_7EB51@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_7F32C(a3 + a1 + 0x1C, a2 + a1 + 0x1C, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007EB9C) --------------------------------------------------------
int __fastcall sub_7EB9C(int a1, int a2, int a3)
{
  return funcs_7EB9C[a3]();
}
// 7E308: using guessed type int sub_7E308(void);
// 7EBA4: using guessed type int (*funcs_7EB9C[8])();

//----- (0007EC25) --------------------------------------------------------
int __usercall sub_7EC25@<eax>(int a1@<ebp>, int a2@<edi>)
{
  __int16 v2; // bx

  sub_7EEEA();
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v2 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v2;
  return (*(int (**)(void))(a1 + 0x76))();
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007EC70) --------------------------------------------------------
int __usercall sub_7EC70@<eax>(int a1@<ebp>, int a2@<edi>)
{
  __int16 v2; // bx

  sub_7EEEA();
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v2 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v2;
  return (*(int (**)(void))(a1 + 0x76))();
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007ECBB) --------------------------------------------------------
int __usercall sub_7ECBB@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_7F157(a2 + a1 + 0x1C, a3 + a1 + 0x1C, (_BYTE *)a1, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007ED06) --------------------------------------------------------
int __usercall sub_7ED06@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>)
{
  int v3; // eax
  __int16 v4; // bx

  v3 = sub_7F157(a3 + a1 + 0x1C, a2 + a1 + 0x1C, (_BYTE *)a1, a3);
  *(_WORD *)(a1 + 8) &= *(_WORD *)((char *)&dword_7D3DC[0x11] + a2 + 2);
  *(_WORD *)(a1 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a2 + 2);
  v4 = *(_WORD *)((char *)dword_7D3D4 + *(unsigned __int16 *)((char *)&off_7D3D0 + a2 + 2) + 2);
  *(_WORD *)(a1 + 4) &= 0xC7FFu;
  *(_WORD *)(a1 + 4) |= v4;
  return (*(int (__fastcall **)(int))(a1 + 0x76))(v3);
}
// 7D3D0: using guessed type void *off_7D3D0;
// 7D3D4: using guessed type int dword_7D3D4[2];
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007ED51) --------------------------------------------------------
int __usercall sub_7ED51@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3,
        __int16 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17)
{
  switch ( a1 )
  {
    case 0:
      LOWORD(a12) = *(_WORD *)(a2 + 4);
      return sub_7D7D4(a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
  }
}
// 7D7D4: using guessed type _DWORD __cdecl sub_7D7D4(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int16);

//----- (0007EEEA) --------------------------------------------------------
void sub_7EEEA()
{
  JUMPOUT(0x7EEFF);
}
// 7EEF6: control flows out of bounds to 7EEFF

//----- (0007EEF8) --------------------------------------------------------
int __usercall sub_7EEF8@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v3; // ecx
  int v4; // ebx
  int v5; // esi
  __int64 v6; // rax

  LOWORD(a3) = *(_WORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)a2;
  v5 = a3 << 0x10;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = *(_QWORD *)a1;
  LODWORD(v6) = sub_7EF52(v6, v3, v4, v5);
  *(_QWORD *)v4 = v6;
  *(_WORD *)(v4 + 8) = v5;
  return v6;
}

//----- (0007EF22) --------------------------------------------------------
int __userpurge sub_7EF22@<eax>(int a1@<eax>, int a2@<esi>, int a3, int a4, __int16 a5)
{
  int v5; // esi
  __int64 v6; // rax

  LOWORD(a2) = a5;
  v5 = a2 << 0x10;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = *(_QWORD *)a1;
  LODWORD(v6) = sub_7EF52(v6, a4, a3, v5);
  *(_QWORD *)a3 = v6;
  *(_WORD *)(a3 + 8) = v5;
  return v6;
}

//----- (0007EF52) --------------------------------------------------------
int __usercall sub_7EF52@<eax>(__int64 a1@<edx:eax>, int a2@<ecx>, int a3@<ebx>, int a4@<esi>)
{
  bool v4; // cf
  unsigned __int16 v5; // si
  int v6; // ecx
  int v7; // esi
  unsigned int v9; // ebp
  int v10; // edi
  int v11; // ecx
  unsigned __int16 v12; // di
  bool v13; // cf
  int v14; // ecx
  int v15; // et1
  int v16; // et2
  int v17; // edi
  int v18; // ebx
  char v19; // ch
  int v20; // ebx
  int v21; // edi
  char v22; // cf
  char v23; // tt
  int v24; // ett
  int v25; // ett
  __int16 v26; // bp
  int v27; // et2
  bool v28; // cf
  int v29; // eax
  bool v30; // tt
  BOOL v31; // ett
  int v32; // ett
  int v34; // [esp-Ch] [ebp-Ch]

  if ( !a1 )
  {
    v4 = __CFADD__((_WORD)a4, (_WORD)a4);
    v5 = 2 * a4;
    if ( !v5 )
    {
      LODWORD(a1) = a3;
      return a1;
    }
    LOWORD(a4) = (v5 >> 1) | (v4 << 0xF);
  }
  if ( a2 || a3 || (a4 & 0x7FFF0000) != 0 )
  {
    v6 = a4;
    v7 = a2;
    v9 = (v6 >> 0x10) & 0x80007FFF;
    v10 = __ROL4__(((int)__ROL4__(v6, 0x10) >> 0x10) & 0x80007FFF, 0x10);
    v11 = __ROL4__(v9, 0x10);
    LOWORD(v11) = v10 + v11;
    v12 = __ROL4__(v10, 0x10);
    v14 = __ROL4__(v11, 0x10);
    v13 = (unsigned __int16)v14 < v12;
    LOWORD(v14) = v14 - v12;
    if ( !(_WORD)v14 )
    {
      goto LABEL_13;
    }
    if ( v13 )
    {
      LOWORD(v9) = v12;
      LOWORD(v14) = -(__int16)v14;
      v15 = a1;
      LODWORD(a1) = a3;
      a3 = v15;
      v16 = HIDWORD(a1);
      HIDWORD(a1) = v7;
      v7 = v16;
    }
    if ( (unsigned __int16)v14 > 0x40u )
    {
      LODWORD(a1) = a3;
    }
    else
    {
LABEL_13:
      BYTE1(v14) = 0;
      if ( v14 < 0 )
      {
        BYTE1(v14) = 0xFF;
        a3 = -a3;
        v7 = -v7 - (a3 != 0);
      }
      v17 = 0;
      if ( (_BYTE)v14 )
      {
        v34 = a3;
        v18 = 0;
        if ( (unsigned __int8)v14 >= 0x20u )
        {
          LOBYTE(v18) = (_DWORD)a1 != 0;
          v17 = v18;
          if ( (_BYTE)v14 == 0x40 )
          {
            v17 = HIDWORD(a1) | v18;
            HIDWORD(a1) = 0;
          }
          a1 = HIDWORD(a1);
        }
        v17 |= __PAIR64__(a1, 0) >> v14;
        LODWORD(a1) = (unsigned __int64)a1 >> v14;
        HIDWORD(a1) = (unsigned __int64)HIDWORD(a1) >> v14;
        a3 = v34;
      }
      v4 = __CFADD__(__PAIR64__(v7, a3), a1);
      a1 += __PAIR64__(v7, a3);
      v19 = v4 + BYTE1(v14);
      if ( v19 < 0 )
      {
        if ( (_BYTE)v14 == 0x40 )
        {
          a1 += (v17 & 0x7FFFFFFF) != 0;
        }
        a1 = -a1;
        v19 = 0;
      }
      v20 = a1;
      LOBYTE(v20) = v19 | a1;
      if ( HIDWORD(a1) | v20 && (_WORD)v9 )
      {
        if ( v19 )
        {
LABEL_31:
          v26 = v9 + 1;
          if ( v26 == 0x7FFF )
          {
            goto LABEL_39;
          }
          v4 = BYTE4(a1) & 1;
          HIDWORD(a1) = (HIDWORD(a1) >> 1) | 0x80000000;
          v27 = v4 << 0x1F;
          v4 = a1 & 1;
          LODWORD(a1) = ((unsigned int)a1 >> 1) | v27;
          if ( v4 )
          {
            v28 = __CFADD__(v17, v17);
            if ( !(2 * v17) )
            {
              v29 = __ROR4__(a1, 1);
              v30 = __CFSHL__(v29, 1);
              LODWORD(a1) = __ROL4__(v29, 1);
              v28 = v30;
            }
            v31 = v28;
            v4 = __CFADD__(v28, (_DWORD)a1);
            LODWORD(a1) = v31 + a1;
            v32 = v4;
            v4 = __CFADD__(v4, HIDWORD(a1));
            HIDWORD(a1) += v32;
            if ( v4 )
            {
              LODWORD(a1) = a1 >> 1;
              if ( v26 == 0x7FFE )
              {
LABEL_39:
                LODWORD(a1) = 0;
              }
            }
          }
        }
        else
        {
          v21 = __ROL4__(v17, 1);
          v23 = v21 & 1;
          v17 = __ROR4__(v21, 1);
          v22 = v23;
          while ( 1 )
          {
            LOWORD(v9) = v9 - 1;
            if ( !(_WORD)v9 )
            {
              break;
            }
            v24 = v22 + (_DWORD)a1;
            v4 = __CFADD__(v22, (_DWORD)a1) | __CFADD__((_DWORD)a1, v24);
            LODWORD(a1) = a1 + v24;
            v25 = v4 + HIDWORD(a1);
            v22 = __CFADD__(v4, HIDWORD(a1)) | __CFADD__(HIDWORD(a1), v25);
            HIDWORD(a1) += v25;
            if ( v22 )
            {
              goto LABEL_31;
            }
          }
        }
      }
    }
  }
  return a1;
}

//----- (0007F0BE) --------------------------------------------------------
int __fastcall sub_7F0BE(unsigned int a1, int a2)
{
  int v2; // esi
  bool v3; // cf
  bool v4; // zf
  int v5; // edi
  int result; // eax
  int v7; // edi
  int v8; // eax

  if ( (*(_WORD *)(a1 + 8) | 0x8000) == 0xFFFF && *(_DWORD *)a1 | (2 * *(_DWORD *)(a1 + 4))
    || (*(_WORD *)(a2 + 8) | 0x8000) == 0xFFFF && *(_DWORD *)a2 | (2 * *(_DWORD *)(a2 + 4)) )
  {
    return 2;
  }
  v2 = *(_DWORD *)(a1 + 6);
  if ( (v2 ^ *(_DWORD *)(a2 + 6)) >= 0 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 8);
    v3 = (unsigned __int16)v2 < *(_WORD *)(a2 + 8);
    v4 = (_WORD)v2 == *(_WORD *)(a2 + 8);
    if ( (_WORD)v2 == *(_WORD *)(a2 + 8) )
    {
      v3 = *(_QWORD *)a1 < *(_QWORD *)a2;
      v4 = *(_QWORD *)a1 == *(_QWORD *)a2;
    }
    v5 = 0;
    if ( v4 )
    {
      return v5;
    }
    v2 ^= (a1 >> 1) | (v3 << 0x1F);
    return 0xFFFFFFFE * __CFADD__(v2, v2) + 1;
  }
  v7 = *(_DWORD *)(a2 + 4) | *(_DWORD *)(a1 + 4) | *(_DWORD *)a2 | *(_DWORD *)a1;
  LOWORD(a1) = *(_WORD *)(a1 + 8);
  v8 = a1 << 0x10;
  LOWORD(v8) = *(_WORD *)(a2 + 8);
  result = v7 | v8 & 0x7FFF7FFF;
  if ( result )
  {
    return 0xFFFFFFFE * __CFADD__(v2, v2) + 1;
  }
  return result;
}

//----- (0007F157) --------------------------------------------------------
int __usercall sub_7F157@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>)
{
  int v4; // ecx
  unsigned int v5; // ebx
  int v6; // esi
  unsigned __int64 v7; // rax

  LOWORD(a4) = *(_WORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)a2;
  v6 = a4 << 0x10;
  LOWORD(v6) = *(_WORD *)(a1 + 8);
  v7 = *(_QWORD *)a1;
  LODWORD(v7) = sub_7F181(v7, v4, v5, a3, v6);
  *(_QWORD *)v5 = v7;
  *(_WORD *)(v5 + 8) = v6;
  return v7;
}

//----- (0007F181) --------------------------------------------------------
int __usercall sub_7F181@<eax>(
        unsigned __int64 a1@<edx:eax>,
        int a2@<ecx>,
        unsigned int a3@<ebx>,
        _BYTE *a4@<ebp>,
        int a5@<esi>)
{
  bool v5; // cf
  unsigned __int16 v6; // si
  int v7; // ecx
  int v8; // esi
  int v10; // edi
  int v11; // ecx
  __int16 v12; // di
  __int16 v13; // cx
  __int16 v14; // di
  unsigned int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // esi
  unsigned __int64 v18; // rax
  int v19; // ecx
  int v20; // edi
  unsigned int i; // esi
  unsigned int v22; // edi
  int v23; // esi
  unsigned int v24; // eax
  unsigned __int64 v25; // kr18_8
  unsigned __int64 v26; // rax
  int v27; // ecx
  int v28; // edi
  int j; // esi
  __int16 v30; // di
  char v31; // cl
  _BYTE v33[12]; // [esp-20h] [ebp-20h]
  unsigned __int64 v34; // [esp-14h] [ebp-14h]
  __int16 v35; // [esp-Ch] [ebp-Ch]

  if ( a2 || a3 || (a5 & 0x7FFF0000) != 0 )
  {
    if ( !a1 )
    {
      v5 = __CFADD__((_WORD)a5, (_WORD)a5);
      v6 = 2 * a5;
      if ( !v6 )
      {
        return a1;
      }
      LOWORD(a5) = (v6 >> 1) | (v5 << 0xF);
    }
    v7 = a5;
    v8 = a2;
    v10 = __ROL4__(((int)__ROL4__(v7, 0x10) >> 0x10) & 0x80007FFF, 0x10);
    v11 = __ROL4__((v7 >> 0x10) & 0x80007FFF, 0x10);
    LOWORD(v10) = v11 + v10;
    v12 = __ROL4__(v10, 0x10);
    v13 = __ROL4__(v11, 0x10);
    if ( !v12 )
    {
      do
      {
        a1 *= 2i64;
        --v12;
      }
      while ( (a1 & 0x8000000000000000i64) == 0i64 );
    }
    if ( !v13 )
    {
      do
      {
        v8 = __PAIR64__(v8, a3) >> 0x1F;
        a3 *= 2;
        --v13;
      }
      while ( v8 >= 0 );
    }
    v14 = v12 - v13 + 0x3FFF;
    if ( v14 < 0 || (unsigned __int16)v14 < 0x7FFFu )
    {
      if ( v14 >= (__int16)0xFFFFFFC0 )
      {
        v35 = v14;
        v34 = __PAIR64__(v8, a3);
        v15 = v8;
        v16 = HIDWORD(a1);
        v17 = a1;
        LODWORD(a1) = 0;
        if ( v15 <= HIDWORD(a1) )
        {
          HIDWORD(a1) -= v15;
          LODWORD(a1) = 1;
        }
        *(_DWORD *)&v33[8] = a1;
        *(_DWORD *)&v33[4] = __PAIR64__(HIDWORD(a1), v17) / v15;
        v18 = ((*(unsigned int *)&v33[4] * (unsigned __int64)a3) >> 0x20)
            + *(unsigned int *)&v33[4] * (unsigned __int64)v15;
        if ( (v33[8] & 1) != 0 )
        {
          v18 += v34;
        }
        v19 = -(*(_DWORD *)&v33[4] * a3);
        v20 = (__PAIR64__(v16, v17) - __PAIR64__(HIDWORD(v18), (*(_DWORD *)&v33[4] * a3 != 0) + (unsigned int)v18)) >> 0x20;
        for ( i = v17 - ((*(_DWORD *)&v33[4] * a3 != 0) + (_DWORD)v18); v20; v20 += v5 )
        {
          --*(_QWORD *)&v33[4];
          v5 = __CFADD__(v34, __PAIR64__(i, v19));
          i = (v34 + __PAIR64__(i, v19)) >> 0x20;
          v19 += v34;
        }
        v22 = i;
        v23 = v19;
        if ( HIDWORD(v34) <= v22 )
        {
          v22 -= HIDWORD(v34);
          ++*(_QWORD *)&v33[4];
        }
        v24 = __PAIR64__(v22, v19) / HIDWORD(v34);
        *(_DWORD *)v33 = v24;
        if ( v24 )
        {
          v25 = v24 * (unsigned __int64)a3;
          v26 = HIDWORD(v25) + v24 * (unsigned __int64)HIDWORD(v34);
          v27 = -(int)v25;
          v28 = (__PAIR64__(v22, v23) - __PAIR64__(HIDWORD(v26), ((_DWORD)v25 != 0) + (unsigned int)v26)) >> 0x20;
          for ( j = v23 - (((_DWORD)v25 != 0) + (_DWORD)v26); v28; v28 += v5 )
          {
            v5 = (*(_QWORD *)v33)-- == 0i64;
            *(_DWORD *)&v33[8] -= v5;
            v5 = __CFADD__(v34, __PAIR64__(j, v27));
            j = (v34 + __PAIR64__(j, v27)) >> 0x20;
            v27 += v34;
          }
        }
        a1 = *(_QWORD *)v33;
        v30 = v35 - 1;
        if ( v33[8] & 1 )
        {
          HIDWORD(a1) = *(__int64 *)&v33[4] >> 1;
          LODWORD(a1) = *(__int64 *)v33 >> 1;
          v30 = v35;
        }
        if ( v30 <= 0 )
        {
          if ( v30 )
          {
            v31 = -(char)v30;
          }
          else
          {
            v31 = 1;
          }
          LODWORD(a1) = a1 >> v31;
        }
      }
      else
      {
        LODWORD(a1) = 0;
      }
    }
    else
    {
      LODWORD(a1) = 0;
    }
  }
  else if ( a1 || (WORD1(a1) = HIWORD(a5), 2 * (_WORD)a5) )
  {
    LOWORD(a1) = 0x8304;
    sub_7D9E4(a1, 0, a4);
    LODWORD(a1) = 0;
  }
  else
  {
    LOWORD(a1) = 0x8101;
    sub_7D9E4(a1, 0, a4);
    LODWORD(a1) = 0;
  }
  return a1;
}

//----- (0007F32C) --------------------------------------------------------
int __usercall sub_7F32C@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  unsigned int v3; // ecx
  unsigned int v4; // ebx
  int v5; // esi
  unsigned __int64 v6; // rax

  LOWORD(a3) = *(_WORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)a2;
  v5 = a3 << 0x10;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = *(_QWORD *)a1;
  LODWORD(v6) = sub_7F356(v6, v3, v4, v5);
  *(_QWORD *)v4 = v6;
  *(_WORD *)(v4 + 8) = v5;
  return v6;
}

//----- (0007F356) --------------------------------------------------------
int __usercall sub_7F356@<eax>(
        unsigned __int64 a1@<edx:eax>,
        unsigned int a2@<ecx>,
        unsigned int a3@<ebx>,
        int a4@<esi>)
{
  bool v4; // cf
  unsigned __int16 v5; // si
  int v6; // ecx
  unsigned int v7; // esi
  unsigned int v9; // ecx
  __int16 v10; // cx
  unsigned __int64 v11; // rax
  int v12; // esi
  int v13; // et1
  unsigned int v14; // ecx
  unsigned __int64 v15; // rax
  unsigned int v16; // ecx
  unsigned int v17; // edi
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // kr08_8
  int v20; // ebx
  __int16 v21; // cx
  bool v22; // cf
  BOOL v23; // ett
  bool v24; // cf
  int v25; // ett
  int v26; // et2
  __int16 v27; // cx
  unsigned __int64 v29; // [esp-18h] [ebp-18h]
  unsigned int v30; // [esp-10h] [ebp-10h]
  __int16 v31; // [esp-Ch] [ebp-Ch]

  if ( !a1 )
  {
    v4 = __CFADD__((_WORD)a4, (_WORD)a4);
    v5 = 2 * a4;
    if ( !v5 )
    {
      return a1;
    }
    LOWORD(a4) = (v5 >> 1) | (v4 << 0xF);
  }
  if ( a2 || a3 || (a4 & 0x7FFF0000) != 0 )
  {
    v6 = a4;
    v7 = a2;
    v9 = (((int)__ROL4__(v6, 0x10) >> 0x10) & 0x80007FFF) + ((v6 >> 0x10) & 0x80007FFF);
    v4 = (unsigned __int16)v9 < 0x3FFEu;
    v10 = v9 - 0x3FFE;
    if ( !v4 && (unsigned __int16)v10 >= 0x7FFFu )
    {
      goto LABEL_26;
    }
    if ( v10 < (__int16)0xFFFFFFC0 )
    {
      LODWORD(a1) = 0;
      return a1;
    }
    v31 = v10;
    v30 = v7;
    v29 = a1;
    v11 = a3 * (unsigned __int64)(unsigned int)a1;
    v13 = v11;
    LODWORD(v11) = v7;
    v12 = v13;
    v14 = HIDWORD(v11);
    v15 = (unsigned int)v29 * (unsigned __int64)(unsigned int)v11;
    v4 = __CFADD__((unsigned int)v15, __PAIR64__(HIDWORD(v15), v14));
    v17 = (v15 + v14) >> 0x20;
    v16 = v15 + v14;
    v18 = HIDWORD(v29) * (unsigned __int64)a3;
    v19 = v18 + __PAIR64__(v17, v16);
    a1 = __PAIR64__(__CFADD__(v18, __PAIR64__(v17, v16)) + (unsigned int)v4, (v18 + __PAIR64__(v17, v16)) >> 0x20)
       + v30 * (unsigned __int64)HIDWORD(v29);
    v20 = v19;
    v21 = v31;
    if ( (a1 & 0x8000000000000000i64) == 0i64 )
    {
      v4 = __CFADD__(__PAIR64__(a1, v19), __PAIR64__(a1, v19));
      LODWORD(a1) = __PAIR64__(a1, v19) >> 0x1F;
      v20 = 2 * v19;
      HIDWORD(a1) += v4 + HIDWORD(a1);
      v21 = v31 - 1;
    }
    v22 = __CFADD__(v20, v20);
    if ( __CFADD__(v20, v20) )
    {
      if ( !(2 * v20) )
      {
        v22 = v12 != 0;
        if ( !v12 )
        {
          v22 = a1 & 1;
        }
      }
      v23 = v22;
      v4 = __CFADD__(v22, (_DWORD)a1);
      LODWORD(a1) = v23 + a1;
      v25 = v4;
      v24 = __CFADD__(v4, HIDWORD(a1));
      HIDWORD(a1) += v25;
      if ( v24 )
      {
        v26 = v24 << 0x1F;
        v4 = BYTE4(a1) & 1;
        HIDWORD(a1) = (HIDWORD(a1) >> 1) | v26;
        LODWORD(a1) = ((unsigned int)a1 >> 1) | (v4 << 0x1F);
        if ( ++v21 == 0x7FFF )
        {
LABEL_26:
          LODWORD(a1) = 0;
          return a1;
        }
      }
    }
    if ( v21 <= 0 )
    {
      if ( v21 )
      {
        v27 = -v21;
      }
      else
      {
        LOBYTE(v27) = 1;
      }
      LODWORD(a1) = a1 >> v27;
    }
  }
  else
  {
    LODWORD(a1) = 0;
  }
  return a1;
}

//----- (0007F4A7) --------------------------------------------------------
void sub_7F4A7()
{
  JUMPOUT(0x7F4AF);
}
// 7F4AA: control flows out of bounds to 7F4AF

//----- (0007F4AC) --------------------------------------------------------
int __fastcall sub_7F4AC(int *a1)
{
  __int16 v1; // cx
  int v2; // ebx
  unsigned int v3; // eax
  bool v4; // cf
  char v5; // ch
  char v6; // ch
  int result; // eax

  v1 = (a1[2] & 0x7FFF) - 0x3FFE;
  if ( (a1[2] & 0x7FFFu) < 0x3FFE )
  {
    return 0;
  }
  if ( v1 > 0x20 || (char)(*((_BYTE *)a1 + 8) + 2) > 0x20 )
  {
    return 0x80000000;
  }
  HIBYTE(v1) = (*((_BYTE *)a1 + 9) >> 1) | 0x20;
  v2 = *a1;
  v3 = a1[1];
  HIBYTE(v1) = (HIBYTE(v1) >> 1) | (__CFADD__(v2, v2) << 7);
  if ( (_BYTE)v1 == 0x20 )
  {
    v4 = __CFADD__(HIBYTE(v1), HIBYTE(v1));
    v5 = 2 * HIBYTE(v1);
  }
  else
  {
    v5 = 2 * HIBYTE(v1);
    v4 = __CFADD__(v3 << v1, v3 << v1);
    v3 = (unsigned __int64)v3 << v1 >> 0x20;
  }
  v6 = ((v4 << 7) | 0x7F) & v5;
  result = __CFADD__(v6, v6) + v3;
  if ( __CFADD__(2 * v6, 2 * v6) )
  {
    return -result;
  }
  return result;
}

//----- (0007F516) --------------------------------------------------------
int __fastcall sub_7F516(int a1)
{
  if ( a1 < 0 )
  {
    JUMPOUT(0x7F52F);
  }
  return sub_7F527();
}
// 7F524: control flows out of bounds to 7F52F
// 7F527: using guessed type int sub_7F527(void);

//----- (0007F527) --------------------------------------------------------
int __fastcall sub_7F527(unsigned int a1, int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  __int16 v5; // cx
  unsigned int v6; // edx
  int result; // eax

  if ( a1 )
  {
    _BitScanReverse(&v3, a1);
    v4 = a1 << (0x1F - v3);
    v5 = (unsigned __int8)v3 + 0x3FFF;
    v6 = v4;
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }
  result = 0;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = v6;
  *(_WORD *)(a2 + 8) = v5;
  return result;
}

//----- (0007F55C) --------------------------------------------------------
int __usercall sub_7F55C@<eax>(__int64 a1@<edx:eax>, int a2@<ebx>, _BYTE *a3@<ebp>)
{
  int v3; // ecx
  signed __int64 v4; // rax
  int v5; // ecx
  bool v6; // zf
  int v7; // et0
  unsigned int v9; // [esp-8h] [ebp-8h]

  v3 = HIDWORD(a1);
  v4 = a1 << 0xB;
  v5 = v3 >> 0x14;
  LOWORD(v5) = v5 & 0x7FF;
  if ( (_WORD)v5 )
  {
    if ( (_WORD)v5 == 0x7FF )
    {
      LOWORD(v5) = 0x7FFF;
      v6 = (v4 & 0x7FFFFFFF00000000i64) == 0;
      if ( (v4 & 0x7FFFFFFF00000000i64) == 0 )
      {
        v6 = (_DWORD)v4 == 0;
      }
      if ( !v6 )
      {
        v9 = v4;
        LOWORD(v4) = 0x8101;
        sub_7D9E4(v4, v5, a3);
        v4 = __PAIR64__(HIDWORD(v4), v9) | 0x4000000000000000i64;
      }
    }
    else
    {
      LOWORD(v5) = v5 + 0x3C00;
    }
    HIDWORD(v4) |= 0x80000000;
  }
  else if ( v4 )
  {
    LOWORD(v5) = 0x3C01;
    if ( !HIDWORD(v4) )
    {
      v7 = v4;
      LODWORD(v4) = 0;
      HIDWORD(v4) = v7;
      LOWORD(v5) = 0x3BE1;
    }
    while ( v4 >= 0 )
    {
      v4 *= 2i64;
      LOWORD(v5) = v5 - 1;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)a2 = v4;
  *(_WORD *)(a2 + 8) = ((unsigned __int16)(2 * v5) >> 1) | (__CFADD__(v5, v5) << 0xF);
  return v4;
}

//----- (0007F5DC) --------------------------------------------------------
int __fastcall sub_7F5DC(int a1)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  unsigned int v4; // ecx
  bool v5; // cf
  int result; // eax
  __int16 v7; // bx
  __int16 v8; // cx
  unsigned __int64 v9; // rt0

  v2 = 0xFFFFFF00;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = v3 << 0x19;
  LOWORD(v4) = *(_WORD *)(a1 + 8);
  if ( __CFSHL__(v3, 0x19) )
  {
    if ( !(v3 << 0x19) && !*(_DWORD *)a1 )
    {
      v2 = 0xFFFFFE00;
    }
    v5 = __CFADD__(v3, 0x100);
    v3 += 0x100;
    if ( v5 )
    {
      v3 = 0x80000000;
      LOWORD(v4) = v4 + 1;
    }
  }
  result = v2 & v3;
  v7 = v4;
  v8 = v4 & 0x7FFF;
  if ( v8 )
  {
    if ( v8 == 0x7FFF )
    {
      return ((((unsigned int)(2 * result) >> 8) | 0xFF000000) >> 1) | (__CFADD__(v7, v7) << 0x1F);
    }
    else
    {
      LOWORD(v4) = v8 - 0x3F80;
      if ( (v4 & 0x8000u) == 0 )
      {
        if ( (__int16)v4 < 0xFF )
        {
          LODWORD(v9) = 2 * result;
          HIDWORD(v9) = v4;
          return ((unsigned int)(v9 >> 8) >> 1) | (__CFADD__(v7, v7) << 0x1F);
        }
        else
        {
          return (__CFADD__(v7, v7) << 0x1F) | 0x7F800000;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

//----- (0007F65B) --------------------------------------------------------
int __usercall sub_7F65B@<eax>(__int64 *a1@<eax>, _BYTE *a2@<ebp>)
{
  __int16 v2; // cx
  unsigned __int64 v3; // rax
  unsigned int v4; // esi
  bool v5; // cf
  __int16 v6; // cx
  int result; // eax
  unsigned __int8 v8; // cl
  int v9; // [esp-4h] [ebp-10h]

  v2 = *((_WORD *)a1 + 4);
  v3 = *a1;
  v4 = 0xFFFFF800;
  if ( __CFSHL__(v3, 0x16) )
  {
    if ( !((_DWORD)v3 << 0x16) )
    {
      v4 = 0xFFFFF000;
    }
    v5 = __CFADD__(v3, 0x800i64);
    v3 += 0x800i64;
    if ( v5 )
    {
      HIDWORD(v3) = 0x80000000;
      ++v2;
    }
  }
  LODWORD(v3) = v4 & v3;
  v6 = (v2 & 0x7FFF) - 0x3C00;
  if ( (unsigned __int16)v6 >= 0x7FFu )
  {
    if ( (unsigned __int16)v6 < 0xC400u )
    {
      result = v3 >> 0xB;
      if ( v6 != 0x43FF )
      {
        v9 = result;
        LOWORD(result) = 0x8408;
        sub_7D9E4(result, v6, a2);
        return v9;
      }
    }
    else if ( v6 < (__int16)0xFFFFFFCC )
    {
      return 0;
    }
    else
    {
      v8 = 0xC - v6;
      if ( v8 >= 0x20u )
      {
        v8 -= 0x20;
        v4 = v3;
        v3 = HIDWORD(v3);
      }
      return ((unsigned int)(__PAIR64__(v3, v4) >> v8) + __PAIR64__(v3 >> (v8 & 0x1F), __PAIR64__(v3, v4) >> v8)) >> 0x20;
    }
  }
  else if ( v6 )
  {
    return v3 >> 0xB;
  }
  else
  {
    return v3 >> 0xC;
  }
  return result;
}

//----- (0007F722) --------------------------------------------------------
signed int __fastcall sub_7F722(signed int result, int a2)
{
  int v2; // ecx
  signed int v3; // eax

  v2 = result >> 0x17;
  LOWORD(v2) = (unsigned __int8)(result >> 0x17);
  if ( (unsigned __int8)(result >> 0x17) )
  {
    v3 = result << 8;
    if ( (_BYTE)v2 == 0xFF )
    {
      LOWORD(v2) = 0xFFFF;
      v3 &= ~0x80000000;
      if ( v3 )
      {
        v3 |= 0x40000000u;
      }
    }
    else
    {
      LOWORD(v2) = v2 + 0x3F80;
    }
    LOWORD(v2) = ((unsigned __int16)(2 * v2) >> 1) | (__CFADD__(v2, v2) << 0xF);
    result = v3 | 0x80000000;
  }
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = result;
  *(_WORD *)(a2 + 8) = v2;
  return result;
}

//----- (0007F7E7) --------------------------------------------------------
unsigned int __fastcall sub_7F7E7(unsigned int result, __int16 a2)
{
  int v3; // ebx
  bool v4; // zf
  __int16 v5; // bx
  char v6; // cc
  __int16 v7; // bx
  int v8; // ecx
  int v9; // eax
  unsigned int v10; // ecx
  bool v11; // tt
  bool v12; // zf
  bool v13; // cf
  int v14; // esi
  int v15; // eax
  unsigned int v16; // esi
  bool v17; // tt
  bool v18; // zf

  _EDI = result;
  v3 = *(unsigned __int16 *)(result + 8);
  v4 = a2 == 0x400;
  if ( a2 != 0x400 )
  {
    v4 = a2 == 0x800;
  }
  if ( v4 && (v3 & 0x8000) != 0 )
  {
    a2 ^= 0xC00u;
  }
  if ( a2 == 0xC00 )
  {
    a2 = 0x400;
  }
  v5 = v3 & 0x7FFF;
  v6 = v5 < 0x403F;
  v7 = v5 - 0x403F;
  if ( v6 )
  {
    v8 = *(_DWORD *)result;
    v6 = ((__int16)(v7 + 0x20) < 0) ^ __OFADD__(0x20, v7);
    LOWORD(v3) = v7 + 0x20;
    if ( !v6 )
    {
      v9 = dword_7F767[v3];
      v10 = v9 & v8;
      *(_DWORD *)_EDI ^= v10;
      result = v9 + 1;
      if ( a2 == 0x400 )
      {
        return result;
      }
      if ( !a2 )
      {
        v10 *= 2;
        if ( result > v10 )
        {
          return result;
        }
        if ( result == v10 )
        {
          v11 = __CFSHL__(result, 1);
          result = __ROL4__(result, 1);
          if ( v11 )
          {
            v12 = (result & *(_DWORD *)(_EDI + 4)) == 0;
          }
          else
          {
            v12 = (result & *(_DWORD *)_EDI) == 0;
          }
          if ( v12 )
          {
            return result;
          }
          result = __ROR4__(result, 1);
        }
      }
      if ( v10 )
      {
        v13 = __CFADD__(result, *(_QWORD *)_EDI);
        *(_QWORD *)_EDI += result;
        if ( v13 )
        {
          __asm { rcr     dword ptr [edi+4], 1 }
          ++*(_WORD *)(_EDI + 8);
        }
      }
      return result;
    }
    *(_DWORD *)result = 0;
    v14 = *(_DWORD *)(result + 4);
    v6 = ((__int16)(v3 + 0x20) < 0) ^ __OFADD__(0x20, (_WORD)v3);
    LOWORD(v3) = v3 + 0x20;
    if ( v6 )
    {
      if ( a2 != 0x400 && (a2 || (_WORD)v3 == 0xFFFF && (v14 != 0x80000000 || v8)) )
      {
        *(_DWORD *)(result + 4) = 0x80000000;
        *(_WORD *)(result + 8) |= 0x3FFFu;
      }
      else
      {
        result = 0;
        *(_DWORD *)(_EDI + 4) = 0;
        *(_WORD *)(_EDI + 8) = 0;
      }
      return result;
    }
    v15 = dword_7F767[v3];
    v16 = v15 & v14;
    *(_DWORD *)(_EDI + 4) ^= v16;
    result = v15 + 1;
    if ( a2 == 0x400 )
    {
      return result;
    }
    if ( !a2 )
    {
      v17 = __CFSHL__(v8, 1);
      v8 = __ROL4__(v8, 1);
      v16 += v17 + v16;
      if ( result > v16 )
      {
        return result;
      }
      if ( result == v16 )
      {
        if ( v8 )
        {
LABEL_35:
          v13 = __CFADD__(result, *(_DWORD *)(_EDI + 4));
          *(_DWORD *)(_EDI + 4) += result;
          if ( v13 )
          {
            __asm { rcr     dword ptr [edi+4], 1 }
            ++*(_WORD *)(_EDI + 8);
          }
          return result;
        }
        v13 = __CFADD__(result, result);
        v18 = 2 * result == 0;
        result *= 2;
        if ( !v13 )
        {
          v18 = (result & *(_DWORD *)(_EDI + 4)) == 0;
        }
        if ( v18 )
        {
          return result;
        }
        result >>= 1;
      }
    }
    if ( !(v16 | v8) )
    {
      return result;
    }
    goto LABEL_35;
  }
  return result;
}
// 7F767: using guessed type int dword_7F767[];

//----- (0007F974) --------------------------------------------------------
__int16 __usercall sub_7F974@<ax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>, _BYTE *a4@<ebp>, int a5@<esi>)
{
  char v5; // ch
  char v6; // dl

  if ( 2 * *(_WORD *)(a1 + 8) )
  {
    if ( 2 * *(_WORD *)(a2 + 8) )
    {
      v5 = *(_BYTE *)(a1 + 9);
      sub_7F157(a1, a2, a4, a5);
      LOWORD(a1) = sub_7FA2A(a3, a4, a5);
      v6 = *(_BYTE *)(a3 + 9);
      if ( v5 < 0 )
      {
        if ( v6 > 0 )
        {
          LOWORD(a1) = sub_7EF22(a3, a5, 0x2168C235, 0xC90FDAA2, 0xC000);
        }
      }
      else if ( v6 < 0 )
      {
        LOWORD(a1) = sub_7EF22(a3, a5, 0x2168C235, 0xC90FDAA2, 0x4000);
      }
    }
    else
    {
      LOWORD(a1) = *(_WORD *)(a1 + 8) & 0x8000 | 0x3FFF;
      *(_WORD *)(a3 + 8) = a1;
      *(_DWORD *)(a3 + 4) = 0xC90FDAA2;
      *(_DWORD *)a3 = 0x2168C235;
    }
  }
  else if ( *(char *)(a2 + 9) >= 0 )
  {
    *(_WORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)a3 = 0;
  }
  else
  {
    *(_WORD *)(a3 + 8) = 0x4000;
    *(_DWORD *)(a3 + 4) = 0xC90FDAA2;
    *(_DWORD *)a3 = 0x2168C235;
  }
  return a1;
}

//----- (0007FA2A) --------------------------------------------------------
__int16 __usercall __spoils<> sub_7FA2A@<ax>(int a1@<eax>, _BYTE *a2@<ebp>, int a3@<esi>)
{
  unsigned __int8 v4; // ch
  char v5; // cl
  __int16 result; // ax
  unsigned __int16 v7; // ax
  bool v8; // cc
  int v9; // esi
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  int v12; // esi
  int v13; // esi
  int v14; // ebx
  char v15; // cf
  char v16; // ch
  int v17; // [esp-1Ch] [ebp-24h]
  int v18; // [esp-18h] [ebp-20h]
  int v19; // [esp-14h] [ebp-1Ch]

  v4 = 0;
  v5 = *(_BYTE *)(a1 + 9);
  *(_BYTE *)(a1 + 9) = v5 & 0x7F;
  if ( *(_WORD *)(a1 + 8) == 0x3FFF && *(_DWORD *)(a1 + 4) == 0x80000000 && !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = 0x2168C235;
    *(_DWORD *)(a1 + 4) = 0xC90FDAA2;
    LOBYTE(result) = 0xFE;
    HIBYTE(result) = v5 & 0x80 | 0x3F;
    *(_WORD *)(a1 + 8) = result;
  }
  else
  {
    if ( *(__int16 *)(a1 + 8) >= 0x3FFF )
    {
      LOWORD(a3) = *(_WORD *)(a1 + 8);
      a3 <<= 0x10;
      LOWORD(a3) = 0x3FFF;
      *(_DWORD *)a1 = sub_7F181(0x8000000000000000i64, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, a2, a3);
      *(_DWORD *)(a1 + 4) = 0x80000000;
      *(_WORD *)(a1 + 8) = 0x3FFF;
      v4 = 2;
    }
    v7 = *(_WORD *)(a1 + 8);
    v8 = v7 <= 0x3FFDu;
    if ( v7 == 0x3FFD )
    {
      v8 = *(_QWORD *)a1 <= 0x8930A2F4F66AB09Bi64;
    }
    if ( !v8 )
    {
      HIWORD(v9) = 0x3FFF;
      v10 = *(_QWORD *)a1;
      LOWORD(v9) = *(_WORD *)(a1 + 8);
      v19 = sub_7EF52(*(_QWORD *)a1, 0xDDB3D742, 0xC265539E, v9);
      v18 = HIDWORD(v10);
      v17 = v9;
      HIWORD(v9) = 0x3FFF;
      v11 = *(_QWORD *)a1;
      LOWORD(v9) = *(_WORD *)(a1 + 8);
      LODWORD(v11) = sub_7F356(*(_QWORD *)a1, 0xDDB3D742, 0xC265539E, v9);
      v12 = __ROL4__(v9, 0x10);
      LOWORD(v12) = 0xBFFF;
      v13 = __ROL4__(v12, 0x10);
      LODWORD(v11) = sub_7EF52(v11, 0x80000000, 0, v13);
      v14 = v17 << 0x10;
      LOWORD(v14) = v13;
      a3 = v14;
      *(_DWORD *)a1 = sub_7F181(v11, v18, v19, a2, v14);
      *(_DWORD *)(a1 + 4) = HIDWORD(v11);
      *(_WORD *)(a1 + 8) = v14;
      v4 |= 1u;
    }
    result = sub_805A6(a1, (int)&word_7F91A, a3);
    v15 = v4 & 1;
    v16 = v4 >> 1;
    if ( v15 )
    {
      result = sub_7EF22(a1, a3, 0x6B9B2C23, 0x860A91C1, 0x3FFE);
    }
    if ( v16 & 1 )
    {
      result = sub_7EF22(a1, a3, 0x2168C235, 0xC90FDAA2, 0xBFFF);
      *(_BYTE *)(a1 + 9) ^= 0x80u;
    }
    if ( v5 < 0 )
    {
      *(_BYTE *)(a1 + 9) ^= 0x80u;
    }
  }
  return result;
}
// 7F91A: using guessed type __int16 word_7F91A;

//----- (0007FB8D) --------------------------------------------------------
int __usercall sub_7FB8D@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  __int16 v4; // si
  unsigned int v5; // ecx
  unsigned int v6; // ebx
  __int64 v7; // rax

  if ( !*(_WORD *)(a1 + 8) && !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
  {
    return 0;
  }
  if ( *(_WORD *)(a2 + 8) || *(_DWORD *)(a2 + 4) || *(_DWORD *)a2 )
  {
    v4 = *(_WORD *)(a1 + 8);
    LOWORD(a3) = *(_WORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 4);
    v6 = *(_DWORD *)a2;
    v7 = *(_QWORD *)a1;
    *(_DWORD *)a1 = sub_7FBF3(v7, v5, v6, a3, v4);
    *(_DWORD *)(a1 + 4) = HIDWORD(v7);
    *(_WORD *)(a1 + 8) = v4;
    return a3;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_WORD *)(a1 + 8) = 0;
    return 0;
  }
}

//----- (0007FBF3) --------------------------------------------------------
int __usercall sub_7FBF3@<eax>(
        __int64 a1@<edx:eax>,
        unsigned int a2@<ecx>,
        unsigned int a3@<ebx>,
        __int16 a4@<di>,
        __int16 a5@<si>)
{
  int v5; // esi
  int v6; // edi
  bool v7; // cc
  int v8; // esi
  int v9; // edi
  bool v10; // cf
  int v11; // esi
  int v12; // ett

  v5 = a5 & 0x7FFF;
  v6 = a4 & 0x7FFF;
  v7 = v5 < v6;
  v8 = v5 - v6;
  if ( !v7 )
  {
    v9 = 0;
LABEL_3:
    v10 = a2 < HIDWORD(a1);
    if ( a2 == HIDWORD(a1) && (v10 = a3 < (unsigned int)a1, a3 == (_DWORD)a1) || v10 )
    {
LABEL_6:
      a1 -= __PAIR64__(a2, a3);
      v10 = 1;
    }
    while ( 1 )
    {
      v9 += v10 + v9;
      v7 = v8-- < 1;
      if ( v7 )
      {
        break;
      }
      v10 = __CFADD__(a1, a1);
      a1 *= 2i64;
      if ( v10 )
      {
        goto LABEL_6;
      }
      v10 = 0;
      if ( a1 < 0 )
      {
        goto LABEL_3;
      }
    }
    v11 = 0;
    if ( a1 )
    {
      while ( a1 >= 0 )
      {
        v12 = (a1 + (unsigned __int64)(unsigned int)a1) >> 0x20;
        LODWORD(a1) = 2 * a1;
        HIDWORD(a1) += v12;
        --v11;
      }
    }
  }
  return a1;
}

//----- (0007FC6E) --------------------------------------------------------
char __usercall sub_7FC6E@<al>(int a1@<eax>, int a2@<ebp>, int a3@<edi>)
{
  unsigned __int16 v4; // dx
  char v5; // al
  char v6; // dh
  __int16 v7; // ax
  __int16 v8; // ax
  bool v9; // zf
  char result; // al
  __int16 v11; // dx

  v4 = *(_WORD *)((char *)&dword_7D3DC[0x13] + a3 + 2);
  if ( (*(_WORD *)(a2 + 8) & v4) == v4 )
  {
    v5 = 0x41;
    v6 = 0;
  }
  else
  {
    *(_WORD *)(a2 + 8) &= ~v4;
    v7 = *(_WORD *)(a1 + 8);
    v6 = 2 * __ROL1__(HIBYTE(v7) & 0x80, 1);
    v8 = v7 & 0x7FFF;
    if ( v8 )
    {
      if ( v8 == 0x7FFF )
      {
        *(_WORD *)(a2 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a3);
        v9 = *(_DWORD *)a1 == 0;
        if ( !*(_DWORD *)a1 )
        {
          v9 = *(_DWORD *)(a1 + 4) == 0x80000000;
        }
        v5 = 1;
        if ( v9 )
        {
          v5 = 5;
        }
      }
      else
      {
        v5 = 4;
        if ( *(char *)(a1 + 7) >= 0 )
        {
          *(_WORD *)(a2 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x13] + a3);
          v5 = 0x44;
        }
      }
    }
    else
    {
      v5 = 0x44;
      if ( !*(_QWORD *)a1 )
      {
        *(_WORD *)(a2 + 8) |= *(_WORD *)((char *)&dword_7D3DC[0x12] + a3);
        v5 = 0x40;
      }
    }
  }
  result = v6 | v5;
  v11 = *(_WORD *)(a2 + 4) & 0xB8FF;
  HIBYTE(v11) |= result;
  *(_WORD *)(a2 + 4) = v11;
  return result;
}
// 7D3DC: using guessed type int dword_7D3DC[41];

//----- (0007FD5C) --------------------------------------------------------
int __usercall sub_7FD5C@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>)
{
  sub_7EF22(a1, a4, 0, 0x80000000, 0x3FFF);
  return sub_7FD75(a1, a2, a3, a4);
}

//----- (0007FD75) --------------------------------------------------------
int __usercall sub_7FD75@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ebp>, int a4@<esi>)
{
  int v4; // esi
  int result; // eax

  sub_7FDB8(a1, a3);
  sub_7F32C(a1, a2, a4);
  LOWORD(a4) = *(_WORD *)(a2 + 8);
  v4 = a4 << 0x10;
  LOWORD(v4) = 0x3FFF;
  result = sub_7F356(0xB8AA3B295C17F0BDi64, *(_DWORD *)(a2 + 4), *(_DWORD *)a2, v4);
  *(_DWORD *)a2 = result;
  *(_DWORD *)(a2 + 4) = 0xB8AA3B29;
  *(_WORD *)(a2 + 8) = 0x3FFF;
  return result;
}

//----- (0007FDB8) --------------------------------------------------------
int __usercall sub_7FDB8@<eax>(int a1@<eax>, _BYTE *a2@<ebp>)
{
  __int64 v3; // rax
  bool v4; // cc
  __int64 v5; // rax
  int v6; // esi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // kr00_8
  int v9; // esi
  int v10; // esi
  int v11; // esi
  int v12; // esi
  int v13; // esi
  int v14; // esi
  int v15; // esi
  int v16; // esi
  __int64 v17; // rax
  __int64 v18; // kr08_8
  __int64 v19; // rax
  int v20; // esi
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // esi
  unsigned int v26; // [esp+4h] [ebp-20h]
  __int16 v27; // [esp+4h] [ebp-20h]
  __int16 v28; // [esp+4h] [ebp-20h]
  unsigned int v29; // [esp+8h] [ebp-1Ch]
  unsigned int v30; // [esp+8h] [ebp-1Ch]
  int v31; // [esp+8h] [ebp-1Ch]
  int v32; // [esp+Ch] [ebp-18h]
  int v33; // [esp+Ch] [ebp-18h]

  v32 = *(unsigned __int16 *)(a1 + 8) - 0x3FFE;
  *(_WORD *)(a1 + 8) = 0x3FFE;
  v3 = *(_QWORD *)a1;
  LODWORD(v3) = sub_7EF52(v3, 0x80000000, 0, 0xBFFE3FFE);
  v4 = *(_WORD *)(a1 + 8) <= 0x3FFEu;
  if ( *(_WORD *)(a1 + 8) == 0x3FFE )
  {
    v4 = *(_QWORD *)a1 <= 0xB504F333F9DE6484i64;
  }
  if ( v4 )
  {
    *(_QWORD *)a1 = v3;
    *(_WORD *)(a1 + 8) = 0x3FFE;
    --v32;
  }
  else
  {
    LODWORD(v3) = sub_7EF52(v3, 0x80000000, 0, 0xBFFE3FFE);
  }
  v26 = HIDWORD(v3);
  v29 = v3;
  v5 = *(_QWORD *)a1;
  v6 = (unsigned __int16)(*(_WORD *)(a1 + 8) - 1) | 0x3FFE0000;
  LODWORD(v5) = sub_7EF52(*(_QWORD *)a1, 0x80000000, 0, v6);
  v6 <<= 0x10;
  LOWORD(v6) = 0x3FFE;
  v7 = __PAIR64__(v26, sub_7F181(__PAIR64__(v26, v29), SHIDWORD(v5), v5, a2, v6));
  v30 = v7;
  v6 <<= 0x10;
  LOWORD(v6) = 0x3FFE;
  *(_DWORD *)a1 = sub_7F356(v7, HIDWORD(v7), v7, v6);
  *(_DWORD *)(a1 + 4) = HIDWORD(v7);
  *(_WORD *)(a1 + 8) = 0x3FFE;
  sub_80554((int)&dword_7FD34, v6);
  v8 = v7;
  HIDWORD(v17) = *(_DWORD *)(a1 + 4);
  LOWORD(v6) = *(_WORD *)(a1 + 8);
  sub_80554((int)&word_7FD16, v6);
  v9 = __ROL4__(v6, 0x10);
  LOWORD(v9) = 0x3FFE;
  v10 = __ROL4__(v9, 0x10);
  LODWORD(v17) = sub_7F181(v17, SHIDWORD(v8), v8, a2, v10);
  v11 = __ROL4__(v10, 0x10);
  LOWORD(v11) = *(_WORD *)(a1 + 8);
  v12 = __ROL4__(v11, 0x10);
  LODWORD(v17) = sub_7F356(v17, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v12);
  v13 = __ROL4__(v12, 0x10);
  LOWORD(v13) = 0x3FFE;
  v14 = __ROL4__(v13, 0x10);
  LODWORD(v17) = sub_7F356(v17, v26, v30, v14);
  v15 = __ROL4__(v14, 0x10);
  LOWORD(v15) = 0x3FFE;
  v16 = __ROL4__(v15, 0x10);
  LODWORD(v17) = sub_7EF52(v17, v26, v30, v16);
  if ( v32 )
  {
    v18 = v17;
    v27 = v16;
    sub_7F516(v32);
    v19 = *(_QWORD *)a1;
    v20 = *(unsigned __int16 *)(a1 + 8) | 0xBFF20000;
    LODWORD(v19) = sub_7F356(*(_QWORD *)a1, 0xDE8082E3, 0x865435Cu, v20);
    v21 = __ROL4__(v20, 0x10);
    LOWORD(v21) = v27;
    v22 = __ROL4__(v21, 0x10);
    v33 = sub_7EF52(v19, SHIDWORD(v18), v18, v22);
    v31 = HIDWORD(v19);
    v28 = v22;
    v17 = *(_QWORD *)a1;
    v23 = *(unsigned __int16 *)(a1 + 8) | 0x3FFE0000;
    LODWORD(v17) = sub_7F356(*(_QWORD *)a1, 0xB1800000, 0, v23);
    v24 = __ROL4__(v23, 0x10);
    LOWORD(v24) = v28;
    v16 = __ROL4__(v24, 0x10);
    LODWORD(v17) = sub_7EF52(v17, v31, v33, v16);
  }
  *(_QWORD *)a1 = v17;
  *(_WORD *)(a1 + 8) = v16;
  return v17;
}
// 7FE97: variable 'v7' is possibly undefined
// 7FEBE: variable 'v17' is possibly undefined
// 7FD16: using guessed type __int16 word_7FD16;
// 7FD34: using guessed type int dword_7FD34;

//----- (00080050) --------------------------------------------------------
int __usercall sub_80050@<eax>(int a1@<eax>, int a2@<esi>)
{
  __int16 v2; // si
  __int64 v3; // rax
  char v4; // al
  int v5; // edi
  int v6; // esi
  __int16 v7; // ax
  int v8; // ecx
  __int16 v9; // ax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  int v12; // esi
  int v13; // ecx
  unsigned int v14; // ebx
  __int16 v16; // [esp-4h] [ebp-1Ch]
  __int16 v19; // [esp+4h] [ebp-14h]
  unsigned __int64 v20; // [esp+Ch] [ebp-Ch]
  __int16 v21; // [esp+14h] [ebp-4h]
  _BYTE savedregs[20]; // [esp+18h] [ebp+0h] BYREF

  v2 = *(_WORD *)(a1 + 8);
  v3 = *(_QWORD *)a1;
  *(_DWORD *)a1 = sub_7FBF3(v3, 0xC90FDAA2, 0x2168C235u, 0x3FFE, v2);
  *(_DWORD *)(a1 + 4) = HIDWORD(v3);
  *(_WORD *)(a1 + 8) = v2;
  v4 = 0xFE;
  v5 = a1;
  v6 = a2;
  if ( *(char *)(a1 + 9) < 0 )
  {
    sub_7EF22(a1, a2, 0x2168C235, 0xC90FDAA2, 0x3FFE);
    v4 = 0xFD;
  }
  HIBYTE(v7) = a2;
  LOBYTE(v7) = ((a2 & 2) + v4) & 7;
  v19 = v7;
  if ( (v7 & 1) != 0 )
  {
    sub_7EF22(v5, v6, 0x2168C235, 0xC90FDAA2, 0xBFFE);
    *(_BYTE *)(v5 + 9) ^= 0x80u;
  }
  v8 = (unsigned __int16)(*(_WORD *)(v5 + 8) - 0x3FFE);
  if ( (__int16)v8 >= (__int16)0xFFFFFFE0 )
  {
    if ( (v8 & 0x8000u) == 0 )
    {
      LOWORD(v8) = 0;
    }
    LOWORD(v8) = -(__int16)v8;
    if ( (__int16)v8 > 8 )
    {
      LOWORD(v8) = 8;
    }
    LOWORD(v8) = word_8003E[v8];
    HIBYTE(v9) = HIBYTE(v19);
    LOBYTE(v9) = (v19 + 1) & 2;
    if ( (_BYTE)v9 || HIBYTE(v19) == 1 )
    {
      v16 = v9;
      v10 = *(_QWORD *)v5;
      LOWORD(v6) = *(_WORD *)(v5 + 8);
      v6 <<= 0x10;
      LOWORD(v6) = *(_WORD *)(v5 + 8);
      sub_7F356(*(_QWORD *)v5, *(_DWORD *)(v5 + 4), *(_DWORD *)v5, v6);
      sub_80554((int)dword_7FFE4 + 0xA * v8, v6);
      v20 = v10;
      v21 = v6;
      v9 = v16;
    }
    if ( !(_BYTE)v9 || HIBYTE(v9) == 1 )
    {
      sub_805A6(v5, (int)&word_7FF8A[5 * v8], v6);
    }
  }
  else
  {
    v20 = 0x8000000000000000i64;
    v21 = 0x3FFF;
  }
  if ( (((_BYTE)v19 + 1) & 2) != 0 )
  {
    v11 = v20;
    LOWORD(v6) = v21;
  }
  else
  {
    v11 = *(_QWORD *)v5;
    LOWORD(v6) = *(_WORD *)(v5 + 8);
  }
  if ( (v19 & 4) != 0 )
  {
    LOWORD(v6) = v6 ^ 0x8000;
  }
  if ( HIBYTE(v19) == 1 )
  {
    v12 = __ROL4__(v6, 0x10);
    if ( (((_BYTE)v19 + 3) & 2) != 0 )
    {
      v13 = HIDWORD(v20);
      v14 = v20;
      LOWORD(v12) = v21;
    }
    else
    {
      v14 = *(_DWORD *)v5;
      v13 = *(_DWORD *)(v5 + 4);
      LOWORD(v12) = *(_WORD *)(v5 + 8);
    }
    if ( (((_BYTE)v19 + 2) & 4) != 0 )
    {
      v12 ^= 0x8000u;
    }
    v6 = __ROL4__(v12, 0x10);
    if ( v14 || v13 || (v6 & 0x7FFF0000) != 0 )
    {
      LODWORD(v11) = sub_7F181(v11, v13, v14, savedregs, v6);
    }
    else
    {
      v11 = 0x8000000000000000i64;
      LOWORD(v6) = v6 | 0x7FFF;
    }
  }
  *(_QWORD *)v5 = v11;
  *(_WORD *)(v5 + 8) = v6;
  return v11;
}
// 8017A: variable 'v10' is possibly undefined
// 801B7: variable 'v20' is possibly undefined
// 801BD: variable 'v21' is possibly undefined
// 7FF8A: using guessed type __int16 word_7FF8A[];
// 7FFE4: using guessed type int dword_7FFE4[19];
// 8003E: using guessed type __int16 word_8003E[];

//----- (00080247) --------------------------------------------------------
int __fastcall sub_80247(int a1)
{
  return sub_80050(a1, 0);
}

//----- (00080251) --------------------------------------------------------
int __fastcall sub_80251(int a1)
{
  return sub_80050(a1, 2);
}

//----- (0008025E) --------------------------------------------------------
int __fastcall sub_8025E(int a1)
{
  return sub_80050(a1, 1);
}

//----- (00080294) --------------------------------------------------------
int __fastcall sub_80294(int a1, int a2, int a3, int a4)
{
  unsigned int v5; // esi
  __int16 v6; // cx
  bool v7; // zf
  unsigned __int16 v8; // bx
  int v9; // ecx
  signed __int64 v10; // rax
  bool v11; // cf
  __int16 v12; // bx
  unsigned __int64 v13; // rax
  int v14; // esi
  int v15; // esi
  int v16; // esi
  int v17; // esi
  int v18; // esi
  int v19; // esi
  int v20; // esi
  int v21; // esi
  int v22; // esi
  int v23; // esi
  int v24; // esi
  int v25; // esi
  unsigned __int64 v26; // rax
  unsigned int v27; // ecx
  int (*v28)(); // esi
  int v29; // eax
  int v30; // et0
  int v31; // esi
  __int32 v33; // [esp-2Ch] [ebp-38h] BYREF
  __int32 v34; // [esp-28h] [ebp-34h] BYREF
  unsigned int v35; // [esp-24h] [ebp-30h] BYREF
  __int32 v36; // [esp-20h] [ebp-2Ch] BYREF
  __int32 v37; // [esp-1Ch] [ebp-28h] BYREF
  int (*v38)(); // [esp-18h] [ebp-24h] BYREF
  int v39; // [esp-14h] [ebp-20h]
  int v40; // [esp-10h] [ebp-1Ch]
  int v41; // [esp-8h] [ebp-14h]

  v41 = a4;
  v5 = 0;
  v6 = *(_WORD *)(a1 + 8);
  *(_BYTE *)(a1 + 9) &= ~0x80u;
  v7 = *(_WORD *)(a1 + 8) == 0;
  if ( !*(_WORD *)(a1 + 8) )
  {
    v7 = *(_QWORD *)a1 == 0i64;
  }
  if ( v7 )
  {
    v9 = 0;
  }
  else
  {
    if ( v6 < 0 )
    {
      v5 = 0xFFFFFFFF;
      sub_7EF22(a1, 0xFFFFFFFF, 0, 0x80000000, 0xBFFF);
      *(_BYTE *)(a1 + 9) ^= 0x80u;
    }
    v8 = *(_WORD *)(a1 + 8) + 4;
    v9 = 0;
    v10 = *(_QWORD *)a1;
    while ( v8 >= 0x3FFFu )
    {
      v11 = __CFADD__(v10, v10);
      v10 *= 2i64;
      v9 += v11 + v9;
      --v8;
    }
    if ( v10 )
    {
      while ( v10 >= 0 )
      {
        v10 *= 2i64;
        --v8;
      }
      v12 = v8 - 4;
    }
    else
    {
      v12 = 0;
    }
    *(_QWORD *)a1 = v10;
    *(_WORD *)(a1 + 8) = v12;
  }
  v40 = v5;
  v39 = v9;
  v13 = *(_QWORD *)a1;
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v14 = v5 << 0x10;
  LOWORD(v14) = *(_WORD *)(a1 + 8);
  LODWORD(v13) = sub_7F356(*(_QWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v14);
  v37 = HIDWORD(v13);
  v38 = (int (*)())v13;
  v36 = v14;
  v15 = (unsigned __int16)v14 | 0x40030000;
  LODWORD(v13) = _InterlockedExchange((volatile __int32 *)&v38, sub_7EF52(v13, 0xA6829A79, 0x1BF21F8C, v15));
  HIDWORD(v13) = _InterlockedExchange(&v37, SHIDWORD(v13));
  v16 = (unsigned __int16)_InterlockedExchange(&v36, v15) | 0x3FFA0000;
  LODWORD(v13) = sub_7F356(v13, 0xEC96F0D6, 0x9D7BFDBu, v16);
  v17 = (unsigned __int16)v16 | 0x40010000;
  LODWORD(v13) = sub_7EF52(v13, 0xE6D5051A, 0xE536E187, v17);
  v18 = __ROL4__(v17, 0x10);
  LOWORD(v18) = *(_WORD *)(a1 + 8);
  v19 = __ROL4__(v18, 0x10);
  LODWORD(v13) = sub_7F356(v13, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v19);
  v34 = HIDWORD(v13);
  v35 = v13;
  v33 = v19;
  v20 = __ROL4__(v19 ^ 0x8000, 0x10);
  LOWORD(v20) = v36;
  v21 = __ROL4__(v20, 0x10);
  LODWORD(v13) = _InterlockedExchange((volatile __int32 *)&v35, sub_7EF52(v13, v37, (int)v38, v21));
  HIDWORD(v26) = _InterlockedExchange(&v34, SHIDWORD(v13));
  v22 = __ROL4__(_InterlockedExchange(&v33, v21), 0x10);
  LOWORD(v22) = v36;
  v23 = __ROL4__(v22, 0x10);
  LODWORD(v26) = sub_7EF52(v26, v37, (int)v38, v23);
  v24 = __ROL4__(v23, 0x10);
  LOWORD(v24) = v33;
  v25 = __ROL4__(v24, 0x10);
  LODWORD(v26) = sub_7F181(v26, v34, v35, &v36, v25);
  *(_QWORD *)a1 = v26;
  *(_WORD *)(a1 + 8) = v25;
  v27 = v39;
  v28 = sub_8026C;
  while ( v27 )
  {
    v11 = v27 & 1;
    v27 >>= 1;
    if ( v11 )
    {
      v39 = v27;
      v38 = v28;
      LOWORD(v26) = *(_WORD *)(a1 + 8);
      v29 = (_DWORD)v26 << 0x10;
      LOWORD(v29) = *((_WORD *)v28 + 4);
      v30 = v29;
      v26 = *(_QWORD *)v28;
      LODWORD(v26) = sub_7F356(*(_QWORD *)v28, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v30);
      *(_QWORD *)a1 = v26;
      *(_WORD *)(a1 + 8) = v30;
      v28 = v38;
      v27 = v39;
    }
    v28 = (int (*)())((char *)v28 + 0xA);
  }
  v31 = v40;
  *(_WORD *)(a1 + 8) += v40;
  return sub_7EF22(a1, v31, 0, 0x80000000, 0xBFFF);
}
// 8026C: using guessed type int sub_8026C();

//----- (00080468) --------------------------------------------------------
int __fastcall sub_80468(unsigned __int64 a1)
{
  __int16 v1; // cx
  unsigned int v2; // ebx
  unsigned __int16 v3; // cx
  __int16 v4; // cx
  int v5; // edi
  __int16 v6; // cx
  __int16 v7; // cx
  int v8; // et2
  unsigned int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned __int64 v13; // rt2
  unsigned int v14; // esi
  unsigned int v15; // esi
  unsigned int v16; // ecx
  unsigned int v17; // eax
  bool v18; // cf
  int v19; // eax
  int v20; // et2
  BOOL v21; // ett
  _DWORD *v23; // [esp-10h] [ebp-18h]

  v1 = *(_WORD *)(a1 + 8);
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    goto LABEL_7;
  }
  if ( *(_DWORD *)(a1 + 4) )
  {
    if ( v1 == 0x7FFF )
    {
      return a1;
    }
LABEL_7:
    if ( (v1 & 0x7FFF) == 0x7FFF )
    {
      goto LABEL_5;
    }
    v18 = __CFADD__(v1, v1);
    v3 = 2 * v1;
    if ( v18 )
    {
      goto LABEL_5;
    }
    v4 = v3 >> 1;
    if ( v4 && !__CFADD__(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 4)) )
    {
LABEL_4:
      *(_WORD *)(a1 + 8) = 0xFFFF;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
LABEL_5:
      *(_BYTE *)(a1 + 7) |= 0xC0u;
      return a1;
    }
    HIDWORD(a1) = *(_DWORD *)(a1 + 4);
    v5 = 0;
    v23 = (_DWORD *)a1;
    v6 = v4 - 0x3FFF;
    v18 = v6 & 1;
    v7 = v6 >> 1;
    if ( !v18 )
    {
      v18 = BYTE4(a1) & 1;
      HIDWORD(a1) >>= 1;
      v8 = v18 << 0x1F;
      v18 = v2 & 1;
      v2 = (v2 >> 1) | v8;
      v5 = v18 << 0x1F;
    }
    *(_WORD *)(a1 + 8) = v7 + 0x3FFF;
    v9 = HIDWORD(a1);
    LODWORD(a1) = v2;
    v10 = (HIDWORD(a1)++ >> 1) | 0x80000000;
    if ( HIDWORD(a1) )
    {
      --HIDWORD(a1);
      while ( 1 )
      {
        v13 = a1 % v10;
        v11 = a1 / v10;
        v12 = v13;
        v14 = v10 - 1;
        if ( v14 <= v11 )
        {
          break;
        }
        v10 = ((v11 + v14 + 1) >> 1) | (__CFADD__(v11, v14 + 1) << 0x1F);
        a1 = __PAIR64__(v9, v2);
      }
      v15 = v14 + 1;
      v16 = v11;
      v17 = __PAIR64__(v12, v5) / v15;
      v10 = v16 + v15;
    }
    else
    {
      v18 = v2 < v10;
      if ( v2 == v10 )
      {
LABEL_21:
        *v23 = a1;
        v23[1] = v10 + v18;
        return a1;
      }
      v17 = __PAIR64__(v2, v5) / v10;
    }
    v18 = v10 & 1;
    v10 = (v10 >> 1) | 0x80000000;
    v20 = v18 << 0x1F;
    v18 = v17 & 1;
    v19 = (v17 >> 1) | v20;
    v21 = v18;
    v18 = __CFADD__(v18, v19);
    LODWORD(a1) = v21 + v19;
    goto LABEL_21;
  }
  if ( 2 * v1 )
  {
    goto LABEL_4;
  }
  return a1;
}

//----- (00080554) --------------------------------------------------------
void __usercall sub_80554(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edi
  unsigned __int64 v3; // rax
  int v4; // esi
  int v5; // esi
  int v6; // esi
  unsigned int vars0; // [esp+0h] [ebp+0h]
  unsigned int vars4; // [esp+4h] [ebp+4h]
  __int16 vars8; // [esp+8h] [ebp+8h]
  int varsC; // [esp+Ch] [ebp+Ch]

  v2 = a1;
  v3 = *(_QWORD *)a1;
  LOWORD(a2) = *(_WORD *)(a1 + 8);
  do
  {
    v4 = __ROL4__(a2, 0x10);
    LOWORD(v4) = vars8;
    v5 = __ROL4__(v4, 0x10);
    LODWORD(v3) = sub_7F356(v3, vars4, vars0, v5);
    v2 += 0xA;
    v6 = __ROL4__(v5, 0x10);
    LOWORD(v6) = *(_WORD *)(v2 + 8);
    a2 = __ROL4__(v6, 0x10);
    LODWORD(v3) = sub_7EF52(v3, *(_DWORD *)(v2 + 4), *(_DWORD *)v2, a2);
    --varsC;
  }
  while ( varsC );
}
// 8056E: variable 'vars8' is possibly undefined
// 8057B: variable 'vars4' is possibly undefined
// 8057B: variable 'vars0' is possibly undefined
// 8059A: variable 'varsC' is possibly undefined

//----- (000805A6) --------------------------------------------------------
int __usercall sub_805A6@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v4; // esi
  int v5; // esi
  int v6; // esi
  unsigned __int64 v7; // rax

  v7 = *(_QWORD *)a1;
  LOWORD(a3) = *(_WORD *)(a1 + 8);
  v4 = a3 << 0x10;
  LOWORD(v4) = *(_WORD *)(a1 + 8);
  sub_7F356(v7, *(_DWORD *)(a1 + 4), v7, v4);
  sub_80554(a2, v4);
  v5 = __ROL4__(v4, 0x10);
  LOWORD(v5) = *(_WORD *)(a1 + 8);
  v6 = __ROL4__(v5, 0x10);
  LODWORD(v7) = sub_7F356(v7, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, v6);
  *(_QWORD *)a1 = v7;
  *(_WORD *)(a1 + 8) = v6;
  return v7;
}
// 805DC: variable 'v7' is possibly undefined

// nfuncs=1902 queued=1496 decompiled=1496 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 1496 function(s)"
