<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Documentation | M.A.X. Port</title>
<meta name="generator" content="Jekyll v3.10.0">
<meta property="og:title" content="Documentation">
<meta name="author" content="M.A.X. Port Team">
<meta property="og:locale" content="en_US">
<meta name="description" content="M.A.X. Port is a runtime executable for the 1996 DOS game M.A.X.: Mechanized Assault &amp; Exploration developed and published by Interplay Productions.">
<meta property="og:description" content="M.A.X. Port is a runtime executable for the 1996 DOS game M.A.X.: Mechanized Assault &amp; Exploration developed and published by Interplay Productions.">
<link rel="canonical" href="https://klei1984.github.io/max/documentation/">
<meta property="og:url" content="https://klei1984.github.io/max/documentation/">
<meta property="og:site_name" content="M.A.X. Port">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Documentation">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"M.A.X. Port Team"},"description":"M.A.X. Port is a runtime executable for the 1996 DOS game M.A.X.: Mechanized Assault &amp; Exploration developed and published by Interplay Productions.","headline":"Documentation","url":"https://klei1984.github.io/max/documentation/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="Documentation%20_%20M.A.X.%20Port_files/main.css"><link type="application/atom+xml" rel="alternate" href="https://klei1984.github.io/max/feed.xml" title="M.A.X. Port"><link rel="apple-touch-icon" sizes="180x180" href="https://klei1984.github.io/max/assets/images/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://klei1984.github.io/max/assets/images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://klei1984.github.io/max/assets/images/favicon-16x16.png">
<link rel="manifest" href="https://klei1984.github.io/max/assets/images/site.webmanifest">
<link rel="mask-icon" href="https://klei1984.github.io/max/assets/images/safari-pinned-tab.svg" color="#5b5dd5">
<link rel="shortcut icon" href="https://klei1984.github.io/max/assets/images/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/max/assets/images/browserconfig.xml">
<meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="Documentation%20_%20M.A.X.%20Port_files/documentation.css"></head>

    
    
    
  

  <body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="https://klei1984.github.io/max/">M.A.X. Port</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
          <ul class="nav-list">
                <li class="nav-item page-link"><a class="nav-link" href="https://klei1984.github.io/max/about/">About</a>
                </li>
                <li class="nav-item page-link"><a class="nav-link" href="https://klei1984.github.io/max/evolution/">Evolution</a>
                </li>
                <li class="nav-item page-link"><a class="nav-link" href="https://klei1984.github.io/max/roadmap/">Roadmap</a>
                </li><li class="nav-item page-link">
                  <input type="checkbox" id="nav-item-trigger" class="nav-item-trigger">
                  <label class="nav-item nav-label" for="nav-item-trigger">Articles</label>
                  <div class="dropdown-trigger"><a class="dropdown-item nav-link" href="https://klei1984.github.io/max/install/">Installation Guideline</a><a class="dropdown-item nav-link" href="https://klei1984.github.io/max/build/">Build Instructions</a><a class="dropdown-item nav-link" href="https://klei1984.github.io/max/fixdos/">Patching Up MS-DOS Versions</a><a class="dropdown-item nav-link" href="https://klei1984.github.io/max/devenv/">Development Environments</a><a class="dropdown-item nav-link" href="https://klei1984.github.io/max/documentation/">Documentation</a><a class="dropdown-item nav-link" href="https://klei1984.github.io/max/save/">Save File Format</a><a class="dropdown-item nav-link" href="https://klei1984.github.io/max/network/">Networking</a></div>
                </li>
              
                <li class="nav-item page-link"><a class="nav-link" href="https://klei1984.github.io/max/license/">License</a>
                </li>
                <li class="nav-item page-link"><a class="nav-link" href="https://klei1984.github.io/max/defects/">Defects</a>
                </li>
                <li class="nav-item page-link"><a class="nav-link" href="https://klei1984.github.io/max/download/">Download</a>
                </li></ul>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Documentation</h1>
  </header>

  <div class="post-content">
    <h2 id="preface">Preface</h2>

<p>The article tries to document the technical aspects of M.A.X. that could either
be interesting for an enthusiast or could be relevant for an engineer.<br>
The information found herein is not guaranteed to be complete or technically accurate.</p>

<h2 id="compiler-toolchain">Compiler Toolchain</h2>

<p>M.A.X. v1.04 was built using the Watcom C/C++ 10.5 compiler. The original M.A.X.
runtime is a 16/32 bit mixed linear executable (LE) that is bound to a 32-bit DOS
extender stub.<br>
The Watcom compiler was shipped with the DOS/4GW 32-bit DOS extender.
The game was shipped with DOS/4GW 1.97.</p>

<p>The compiler supports various memory models from which M.A.X. used a Mixed
16/32-bit flat/small model.</p>

<table>
  <thead>
    <tr>
      <th>C/C++ Runtime Libraries</th>
      <th>Floating-Point Libraries (80x87)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>clib3r.lib , plib3r.lib</td>
      <td>math387r.lib , emu387.lib</td>
    </tr>
  </tbody>
</table>

<p>The <strong>3r</strong> suffix in the library names means that the compiler generates 386
instructions based on the 386 instruction timings and that the compiler uses
the Watcom register calling convention <a href="#ref1">[1]</a><a href="#ref2">[2]</a>.</p>

<p>In general the compiled code inherits the following characteristics:</p>
<ul>
  <li>function arguments are passed in registers EAX, EDX, EBX and ECX as long as they fit and then on the stack.</li>
  <li>48 bit __far pointers are passed 64 bit aligned in two registers or stack variables.</li>
  <li>all registers except EAX are preserved across function calls.</li>
  <li>functions with external linkage are suffixed with an underscore on machine-code level. E.g. <strong>main_</strong>.</li>
  <li>variables with external linkage are prefixed with an underscore on machine-code level. E.g. <strong>__STACKLOW</strong>.</li>
</ul>

<h2 id="libraries-used">Libraries Used</h2>

<p>M.A.X. is built upon several static link libraries. Out of the 5706 subroutines
1644 (28.81%) are coming from these libraries. Of course its also true that many
of the library functions are not even used by the game.</p>

<table>
  <thead>
    <tr>
      <th>Library Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Watcom C 32-bit runtime (clib3r.lib)</td>
      <td>Implements standard C library functions like fopen, memcpy, 
etc. At the time the Watcom C/C++ compiler supported several platforms 
like DOS, Linux, Netware, Windows and in many cases the compiler 
supported various flavors of the C standard like POSIX, ANSI and ISO. 
Many of the related functions are not portable.</td>
    </tr>
    <tr>
      <td>Watcom C++ 32-bit runtime (plib3r.lib)</td>
      <td>Implements <em>standard</em> C++ support. The library contains
 services that facilitate handling of C++ classes, global constructor 
and destructor lists, vtables, class inheritance and similar C++ 
“stuff”.<br>M.A.X. calls 32 global constructors from which 12 are 
compiler or system related. E.g. there is a global constructor called 
__verify_pentium_fdiv_bug(). Interesting… or not.</td>
    </tr>
    <tr>
      <td>Watcom floating-point libraries (math387r.lib &amp; emu387r.lib)</td>
      <td>M.A.X. is built with hardware floating point support, but if no x87 <a href="#ref3">[3]</a> hardware is detected on the PC at runtime it is able to fall back to software emulation.</td>
    </tr>
    <tr>
      <td>GNW</td>
      <td>GNW is a user interface and OS-abstraction library designed and programmed by Timothy Cain <a href="#ref4">[4]</a>.
 Alternative versions of the library were used within Fallout 1, Fallout
 2, Mapper 2 (Official Fallout 2 editor), Star Trek: Starfleet Academy, 
Atomic Bomberman and more.<br>GNW implements not only a windowing 
system, but memory and file system abstraction layers and more. It also 
provides a streamlined interface for debugging and a human input device 
recorder and playback service for arcade like attract mode. This is not 
the way M.A.X. realizes the demo gameplay in the main menu after a 60 
seconds idle timeout though.</td>
    </tr>
    <tr>
      <td>HMI S.O.S. v3.x</td>
      <td>HMI Sound Operating System <a href="#ref5">[5]</a> is a sound 
card detection and sound card abstraction layer for DOS and many other 
platforms. It supports digital and MIDI playback, mixing more than 20 
sound channels, streaming a music sample directly from HDD to conserve 
RAM space and many-many more. M.A.X., Descent 1 and 2, Blood &amp; Magic
 and the MVE library rely on the v3.x branch of the library. M.A.X. does
 not support MIDI music. The music in M.A.X. is too awesome to be in 
mere MIDI format. Thanks Mr. Luzietti <a href="#ref6">[6]</a>! M.A.X. wraps the SOS API layer into a game specific C++ Sound Manager component called <strong>soundmgr</strong>.</td>
    </tr>
    <tr>
      <td>MVE</td>
      <td>Interplay’s own video player library <a href="#ref7">[7]</a>. 
Alternative versions of the library were used within many Interplay 
legends like Redneck Rampage Rides Again, Descent II, Descent II setup 
tool, Fallout, etc. The library integrates the HMI SOS library for sound
 playback and the VBE library for video display.</td>
    </tr>
    <tr>
      <td>LZSS</td>
      <td>LZSS is used within the database manager component of GNW, but M.A.X does not rely on it.</td>
    </tr>
    <tr>
      <td>VBE</td>
      <td>VBE is a VESA BIOS Extension interface wrapper layer to the 
video display. The VBE library is not used by the game itself. Only the 
MVE library relies on the VBE library functions for video playback. The 
game itself uses GNW for video display.</td>
    </tr>
  </tbody>
</table>

<h2 id="watcom-v105-c-32-bit-constructs">Watcom v10.5 C++ 32 bit Constructs</h2>
<h3 id="a-bit-of-history">A bit of history</h3>
<p>The first ISO C++ standard was published in September, 1998. ANSI 
standardization was proposed in 1989 and the first organizational 
meeting of the ANSI C++ committee took place already in December, 1989. 
The language specification continuously evolved during the time frame.</p>

<p>A very good publication about the early history of C++ can be found in <a href="#ref8">[8]</a>.</p>

<p>Watcom implemented the full AT&amp;T C++ 3.0 specification with 
support for templates and exceptions in 1993 within Watcom C/C++32 v9.5.
 Watcom C/C++32 v10.5 was released two years later in 1995. At the time 
namespaces, or runtime type information (RTTI) were just concepts or 
even less.</p>

<p>The following sections attempt to document how the Watcom C/C++ 
compiler organizes data related to C++ constructs in 16/32 bit mixed 
linear executables (LE) targeting MS-DOS hosts.<br>
Most available publications about reversing C++ applications focus on 
state of the art compilers and related methods or data organization 
models. Most of those techniques or models simply do not apply to 
executables generated by the original Watcom C/C++ compilers and even 
the programming language was different.</p>

<p>The C++ user population doubled every 7.5 months or so between 1979 
and 1991. The estimated number of C++ users was 400.000 in 1991. Why was
 C++ so popular?</p>

<p>One pretty obvious reason even for simple applications is semi 
automated resource deallocation or file handling via destructors. E.g. 
to load a character font using C, GNW opens a file, dynamically 
allocates a buffer for meta data, dynamically allocates further buffers 
for each individual character’s data, reads the file and fills all the 
buffers, and if any step fails the function enters dedicated else paths 
to deallocate all the resources necessary in a reverse order and finally
 it closes the file handle if necessary. All this is implemented by hand
 and every error condition has its own list of buffer deallocation and 
file handle operations depending on the already allocated and opened 
resources. This leads to bloated code with lots of conditional branches 
and repeated code snippets with minor differences only. Hard to read, 
error prone, difficult to maintain. On the other hand the generated code
 is efficient thanks to optimizing compilers that eliminate most of the 
duplicated code and many of the branches via various tricks and there 
are state of the art processes to eliminate or mitigate the risks of 
inroducing coding errors.<br>
The same can be achieved in C++ in a much cleaner way. But do not be 
fooled, this does not mean that C++ is memory or file system safe by 
design, quite the opposite.</p>

<h3 id="used-resources">Used resources</h3>
<ul>
  <li>The binary and source code releases of the Open Watcom compiler, 
and the last professional version with its source code, could be 
downloaded from <a href="#ref9">[9]</a>.</li>
  <li>The older professional versions are required as well to be able to perform comparisons, analysis on libraries and such.</li>
  <li>The latest Open Watcom release for the favoured host OS is required for tools like wdis, wlib, wdump.</li>
</ul>

<p>Analyzed code generator:<br>
  WATCOM C/C++32 Compile and Link Utility Version 10.5<br>
  wcl386.exe (1995-07-11)<br>
  MD5 hash: 2af860b0f1e431852f4989f4226f3938 *WCL386.EXE)</p>

<h3 id="identifying-the-compiler-revision-used">Identifying the compiler revision used</h3>
<p>The simplest way to narrow down the list of potential compiler 
versions is the copyright notice which is embedded into the startup 
code: <code class="language-plaintext highlighter-rouge">WATCOM C/C++32 Run-Time system. (c) Copyright by WATCOM International Corp. 1988-1995. All rights reserved.</code>. The string is very talkative. <code class="language-plaintext highlighter-rouge">C++</code> support was introduced in 1993 within v9.5. <code class="language-plaintext highlighter-rouge">32</code> indicates that the 32 bit runtime library is in use. The copyright date code <code class="language-plaintext highlighter-rouge">1988-1995</code>
 clearly indicates that the compiler is not older than 1995 which means 
at least v10.5. A brief version history is available on Wikipedia at <a href="#ref10">[10]</a>.</p>

<p>A more precise way to identify the exact tool version is to take the C
 and C++ runtime libraries from the various compiler revisions, the 
library files that are linked into the executable like clib3r.lib or 
plib3s.lib, explode them using wlib tool, disassemble the resulting 
object files, like undefed.obj, using the wdis tool and compare the 
signatures of the resulting assembler routines and related variables or 
lookup tables with the disassembled executable’s routines whether there 
are exact matches.</p>

<p><img src="Documentation%20_%20M.A.X.%20Port_files/watcom_signature.svg" alt="workflow for matching library signatures"></p>

<p>For the signature checks a set of regex patterns based scripts were 
developed in Python. The output of the scripts cannot be 100% accurate, 
manual cross-verification is always required, but this is not a 
drawback. Having full control over the identification process guarantees
 that accuracy and completeness are kept high priority. The reversing 
tool used was IDA Freeware 7.0 which does not have built in signature 
checkers. The identified routines as well as variables were entered into
 the IDA database manually, but 100% accurate and as complete as 
possible with proper type definitions taken from the compiler’s header 
files.</p>

<h3 id="detecting-the-presence-of-c-constructs-in-executables">Detecting the presence of C++ constructs in executables</h3>
<p>The Watcom C++32 Runtime library provides services to manage global 
objects and their life cycles, exceptions and more. The easiest way to 
detect the presence of C++ constructs in an executable is to search for 
error messages related to the C++ runtime. A good example is the error 
message that is emitted when a non existent copy constructor is 
attempted to be invoked: <code class="language-plaintext highlighter-rouge">undefined constructor or destructor called!</code>. There are many more such diagnostic messages.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
C++ Runtime Library Error Messages
pure virtual function called!
undefined constructor or destructor called!
compiler error: eliminated virtual function call!
stack data has been corrupted!
violation of function exception specification!
throw while "terminate" function active!
throw during construction of exception!
throw during destructor for handled exception!
re-throw when no exception handler active!
no handler active to catch thrown object!
system exception! code = 0x00000000
no memory left to handle thrown exception!
return from "terminate" function!
return from "unexpected" function!
... 
*/</span>
</code></pre></div></div>

<p>After basic identification, the previously described signature checks
 and setup of a reversing database allows identification of the C++ 
runtime library functions and their calling contexts can be analyzed 
further.</p>

<table>
  <thead>
    <tr>
      <th>C++ Runtime Library Function</th>
      <th>Symbol Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>void CPPLIB(fatal_runtime_error)( char *msg, int code )</td>
      <td>__wcpp_2_fatal_runtime_error__</td>
      <td>Called on fatal runtime errors. Exit the application with diagnostic error message.</td>
    </tr>
    <tr>
      <td>void CPPLIB( undefed_cdtor )( void )</td>
      <td>__wcpp_2_undefed_cdtor__</td>
      <td>The function is emitted by the compiler for undefined 
constructors and destructors as a placeholder in type signature tables. 
When a default constructor, copy constructor or destructor is not 
required by an application they are not generated instead this 
placeholder function is used.</td>
    </tr>
    <tr>
      <td>void CPPLIB(mod_register)( RW_DTREG* rw )</td>
      <td>__wcpp_2_mod_register__</td>
      <td>Register constructed global, namspace, or class static objects
 into a linked list to be able to destruct them at termination of the 
program. These objects are constructed at the start of the program.</td>
    </tr>
    <tr>
      <td>void CPPLIB(lcl_register)( RW_DTREG RT_FAR *rw )</td>
      <td>__wcpp_2_lcl_register__</td>
      <td>Register constructed local static objects into a linked list 
to be able to destruct them at termination of the program. The main 
difference compared to CPPLIB(mod_register) is that local static objects
 are only registered and constructed if their declaration is encountered
 at least once during program execution.</td>
    </tr>
    <tr>
      <td>void CPPLIB(module_dtor)( void )</td>
      <td>__wcpp_2_module_dtor__</td>
      <td>Iterate the list of previously constructed global, namspace, 
class static or local static objects in reverse order and call their 
appropriate destructor.</td>
    </tr>
    <tr>
      <td>void * CPPLIB(ctor_array)( void *array, unsigned count, RT_TYPE_SIG sig )</td>
      <td>__wcpp_2_ctor_array__</td>
      <td>Emitted by the compiler to construct named automatic or temporary object arrays.</td>
    </tr>
    <tr>
      <td>void * CPPLIB(dtor_array)( void *array, unsigned count, RT_TYPE_SIG sig )</td>
      <td>__wcpp_2_dtor_array__</td>
      <td>Destruct a previously constructed object array. The function 
is not directly emitted into user defined code. For named automic and 
temporary objects a unique object instance specific function is emitted 
by the compiler called __arrdtorblk. This instance specific function 
defines the parameters to be used by the runtime library function.</td>
    </tr>
    <tr>
      <td>void* CPPLIB( ctor_array_storage_g )( void* array, unsigned count, RT_TYPE_SIG sig )</td>
      <td>__wcpp_2_ctor_array_storage_g__</td>
      <td>Emitted by the compiler to register and contruct free-store objects created with the new[] operator.</td>
    </tr>
    <tr>
      <td>ARRAY_STORAGE* CPPLIB(dtor_array_store)( void *array, RT_TYPE_SIG sig )</td>
      <td>__wcpp_2_dtor_array_store__</td>
      <td>Emitted by the compiler before a free-store object array is destroyed with the delete[] operator.</td>
    </tr>
    <tr>
      <td>void CPPLIB(pure_error)( void )</td>
      <td>__wcpp_2_pure_error__</td>
      <td>Trap function for non-overridden pure virtual method calls emitted by the compiler into class virtual function tables.</td>
    </tr>
    <tr>
      <td>void CPPLIB(undef_vfun)( void )</td>
      <td>__wcpp_2_undef_vfun__</td>
      <td>Trap function for stripped virtual function calls. Unless the compiler is broken this function is never called.</td>
    </tr>
    <tr>
      <td>…</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>

<h4 id="finding-class-members-via-the-this-pointer">Finding class members via the <em>this pointer</em></h4>

<p>Named automatic and temporary objects are allocated into <em>automatic memory</em>.
 In practice this means the stack frame of the function in which the 
object declaration is found. As constructors, destructors and most class
 member functions expect the <em>this pointer</em> as the first argument
 and Watcom typically uses their own register calling convention in 
these scenarios this creates a promising method to identify class member
 functions simply by just looking at the assembly listing:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; The %ebp register holds the start address of the stack frame.</span>
<span class="c1">; The -0x14 offset from %ebp points to the start address of the object.</span>
<span class="c1">; The lea instruction takes the address to the location and moves the value to the %eax register.</span>
<span class="c1">; The %eax register holds the first function argument, in this case the 'this pointer'.</span>

<span class="nf">lea</span>    <span class="o">-</span><span class="mh">0x000014</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="nf">call</span>   <span class="nb">cl</span><span class="nv">ass_default_ctor_</span>
<span class="nf">...</span>
<span class="nf">lea</span>    <span class="o">-</span><span class="mh">0x000014</span><span class="p">(</span><span class="o">%</span><span class="nb">ebp</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="nf">call</span>   <span class="nb">cl</span><span class="nv">ass_method_</span> <span class="c1">; this is clearly a method of the previously identified class.</span>
</code></pre></div></div>

<h4 id="finding-class-default-constructors-copy-constructors-and-destructors">Finding class default constructors, copy constructors and destructors</h4>

<p>Typically the compiler emits class and class instance related data 
for the C++ runtime into the CONST2 segment. Original C++ module 
boundaries could be guessed by looking at the layout of this data. For 
each compiled module the compiler first emits const variable 
initializers and than the metadata for classes.</p>

<p style="color:gray; font-size: 100%; text-align: right;"><br style="clear:both">
By default, the data group “DGROUP” consists of the “CONST”, “CONST2”, “_DATA”, and “_BSS” segments.<br>
The compiler places certain types of data in each segment.<br>
The “CONST” segment contains constant literals that appear in your source code.<br>
The “CONST2” segment contains initialized read-only data.<br>
The “_BSS” segment contains uninitialized data such as scalars, structures, or arrays. <a href="#ref11">[11]</a>”</p>
<p><br></p>

<p>Identification of the default constructor, copy constructor and 
destructor of global, namspace, class static and local static objects is
 rather easy in most scenarios.</p>

<p>The compiler emits a type signature for each unstripped class and the
 data is not stripped even in cases when the C++ runtime does not 
reference them.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Comdat: char unsigned const near __typesig[]  SEGMENT ANY 'DGROUP:CONST2'  00000011 bytes  </span>
 <span class="err">0000</span>  <span class="err">00</span>                                      <span class="err">-</span> <span class="nf">.</span>
 <span class="err">0001</span>  <span class="err">00</span> <span class="err">00</span> <span class="err">00</span> <span class="err">00</span>                             <span class="kd">DD</span>      <span class="nv">near</span> <span class="nv">A</span><span class="p">::</span><span class="nv">A</span><span class="p">()</span>
 <span class="err">0005</span>  <span class="err">00</span> <span class="err">00</span> <span class="err">00</span> <span class="err">00</span>                             <span class="kd">DD</span>      <span class="nv">near</span> <span class="nv">A</span><span class="p">::</span><span class="nv">A</span><span class="p">(</span> <span class="nv">A</span> <span class="nv">const</span> <span class="nv">near</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="c1">; replaced by __wcpp_2_undefed_cdtor__ if function is not referenced</span>
 <span class="err">0009</span>  <span class="err">00</span> <span class="err">00</span> <span class="err">00</span> <span class="err">00</span>                             <span class="kd">DD</span>      <span class="nv">near</span> <span class="nv">A</span><span class="p">::</span><span class="o">~</span><span class="nv">A</span><span class="p">()</span>
 <span class="err">000</span><span class="nf">d</span>  <span class="mi">11</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>                             <span class="o">-</span> <span class="nv">....</span>
</code></pre></div></div>

<p>The first byte is a header, which seems to be always zero in the 
analyzed executables. In later versions of the compiler the header 
contains four bytes. The next three 32 bit words are function pointers 
to the default constructor, copy constructor and destructor in this 
order. These functions are not necessarily defined for a class. If the 
class does not have a copy constructor or if it is not referenced, 
__wcpp_2_undefed_cdtor__ is emitted instead. If the class does not 
define a default constructor it is replaced with a NULL pointer, but in 
certain scenarios __wcpp_2_undefed_cdtor__ is emitted instead of NULL. 
The type signature is not emitted into the executable if the class does 
not have a default constructor, a copy constructor and the destructor. 
The last 32 bit word is the object data size in bytes. The given class 
in the example above has 17 bytes of data. It is very important that 
alignment rules for basic types do not apply here. In other words object
 data are always packed.</p>

<h4 id="global-namspace-and-class-static-objects">Global, namspace, and class static objects</h4>

<p>For objects constructed, or classes instantiated, at program startup 
the compiler emits a special function unique for each instance called <code class="language-plaintext highlighter-rouge">.fn_init()</code>.
 This function is responsible to call the appropriate constructors 
required for the object and track the state of the instantiation.</p>

<p>…</p>

<h2 id="debug-options-in-max-v104">Debug Options in M.A.X. v1.04</h2>

<h2 id="references">References</h2>
<p><a name="ref1"></a>[1] <a href="https://users.pja.edu.pl/~jms/qnx/help/watcom/compiler-tools/cpopts.html#SW3RS">Watcom C/C++ compiler options</a><br>
<a name="ref2"></a>[2] <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">x86 calling conventions</a><br>
<a name="ref3"></a>[3] <a href="https://en.wikipedia.org/wiki/X87">x87</a><br>
<a name="ref4"></a>[4] <a href="https://www.mobygames.com/developer/sheet/view/developerId,2720/">Timothy Cain biography at MobyGames</a><br>
<a name="ref5"></a>[5] <a href="http://web.archive.org/web/19970225190838/http://www.humanmachine.com/dev.htm">HMI SOS home page</a><br>
<a name="ref6"></a>[6] <a href="https://www.mobygames.com/developer/sheet/view/developerId,5423/">Brian Luzietti biography at MobyGames</a><br>
<a name="ref7"></a>[7] <a href="https://wiki.multimedia.cx/index.php/Interplay_MVE">MVE format</a><br>
<a name="ref8"></a>[8] A History of C++: 1979 - 1991, Bjarne Stroustrup - March, 1993<br>
<a name="ref9"></a>[9] <a href="ftp://ftp.openwatcom.org/source">Open Watcom FTP</a><br>
<a name="ref10"></a>[10] <a href="https://en.wikipedia.org/wiki/Watcom_C/C%2B%2B">Watcom C/C++ release history</a><br>
<a name="ref11"></a>[11] Open Watcom C/C++ User’s Guide<br></p>

  </div>

</article>

      </div>
    </main><footer class="footer-min">
  <div class="text-muted">
    M.A.X. Port Team
    &nbsp;&nbsp;•&nbsp;&nbsp;
    
      2025
    

    
  </div>
</footer>


</body></html>