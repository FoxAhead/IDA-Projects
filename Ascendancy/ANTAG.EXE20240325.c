/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Watcom C++
*/

#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn sub_10000(); // weak
void *__fastcall sub_10010(T_Type5 *, int, int, int);
int __fastcall sub_10668(_DWORD *, char *, int, int);
int __fastcall sub_10878(_DWORD *, int, int, int);
int __fastcall sub_10A14(int, int);
void __fastcall __spoils<> sub_10A3C(P_TypeA8 a1);
void *__fastcall sub_10A80(int a1, char a2);
void __fastcall __spoils<> sub_10AC4(P_TypeA8 result);
int __fastcall sub_10B24(int, unsigned __int16, int, int *);
void __fastcall sub_11870(int, int edx0);
int __fastcall sub_11BA4(int);
int __fastcall sub_12140(int);
void __fastcall sub_12238(int a1, int a2);
void __fastcall sub_1229C(int, int);
unsigned int __fastcall sub_12368(int, int);
void __fastcall sub_1240C(int a1, int a2);
char *__fastcall sub_12440(int);
int __fastcall sub_12480(float *, float *, int, int, float);
unsigned int __fastcall sub_12618(int);
void __fastcall sub_12674(int);
int __fastcall sub_126F8(int, int);
int __fastcall sub_12AE4(int, int);
void __fastcall sub_12B4C(int, int);
unsigned int __fastcall sub_12C98(int, int, int);
unsigned int __fastcall sub_12E88(int);
int __fastcall sub_12F7C(int);
unsigned int __fastcall sub_13370(int, int, int);
unsigned int __fastcall sub_136C4(int);
unsigned int __fastcall sub_1380C(int);
void __fastcall sub_139E0(int a1, int a2);
void __fastcall sub_13A28(int a1, int a2);
void __fastcall sub_13AD8(int a1, int a2);
_DWORD *__fastcall sub_13BC0(_DWORD *result, _DWORD *);
_DWORD *__fastcall sub_13BF0(_DWORD *result);
unsigned int __fastcall sub_13C10(int);
unsigned int __fastcall sub_14224(int);
int __fastcall sub_142D8(int);
int __fastcall sub_14490(int);
unsigned int __fastcall sub_145C0(int);
unsigned int __fastcall sub_147CC(int);
unsigned int __fastcall sub_14B18(int, int, int);
unsigned int __fastcall sub_15078(int);
unsigned int __fastcall sub_15164(int);
unsigned int __fastcall sub_152E4(int, int, int, int);
void __fastcall sub_15630(int a1, int a2);
int __fastcall sub_156C0(int, int, unsigned __int16);
int __fastcall sub_1577C(int);
int __fastcall sub_15788(int result);
int __fastcall sub_15794(int result, int);
int __fastcall sub_157B4(const void *, const void *); // idb
void __fastcall sub_157EC(size_t *);
char *__fastcall sub_15808(int, int, int);
int __fastcall sub_15948(int, int);
int __fastcall sub_15D20(int);
int __fastcall sub_15D2C(int result);
int __fastcall sub_15D38(int result, const void *);
int __fastcall sub_15D74(int result, int);
int __fastcall sub_15DA4(int result, int, unsigned __int16);
void __fastcall sub_15E1C(int *, int);
int __fastcall sub_15ED4(T_TypeA2 *);
int __fastcall sub_1604C(int a1, char a2);
int __fastcall sub_16120(int);
int __fastcall sub_16348(int, unsigned __int16, int, signed int);
void __fastcall sub_16D6C(int, int, int, int);
int __fastcall sub_16FC0(int, int, int, int);
int __fastcall sub_171D0(int, int, int);
char *__fastcall sub_17204(int, int, int);
void __fastcall sub_17260(int result);
void __fastcall sub_172B0(int);
int __fastcall sub_173F4(int, int, int, int);
int __fastcall sub_17430(int);
void __fastcall sub_17E50(int, int, int, int);
float *__fastcall sub_17E88(int, int);
void __fastcall sub_17F54(int);
void __fastcall sub_17FF0(int, int, int, int);
void __fastcall sub_181F0(int);
int __fastcall sub_1826C(int, int, unsigned __int16, unsigned __int16);
void __fastcall sub_182B8(int, int);
unsigned int __fastcall sub_18370(int);
int __fastcall sub_185CC(int);
void __fastcall sub_186B8(int, int, int);
int __fastcall sub_187EC(int);
void __fastcall sub_18C2C(int, int);
void __fastcall sub_18CA8(int, int);
void __fastcall sub_1936C(int);
int __fastcall sub_19AE8(int);
__int64 __fastcall sub_19E2C(int, unsigned int, int);
int __fastcall sub_1A9C0(int);
int __fastcall sub_1A9E0(int);
int __fastcall sub_1AA00(int);
_DWORD *__fastcall sub_1AA40(float *, float *);
__int64 __fastcall sub_1AA90(int);
_DWORD *__fastcall sub_1AAC0(int);
_DWORD *__fastcall sub_1ABE0(_DWORD *);
float *__fastcall sub_1AC70(float *result, int, int, int);
_DWORD *__fastcall sub_1ACA0(_DWORD *result);
int __fastcall sub_1ACC0(int, int, int);
int __fastcall sub_1ACE8(int result);
int __fastcall sub_1ACF4(int);
_DWORD *__fastcall sub_1AD1C(int, int);
int __fastcall sub_1ADAC(int, const char *);
int __fastcall sub_1AEB0(unsigned int, unsigned __int16, const char *);
int __fastcall sub_1B000(unsigned int, unsigned __int16);
int __fastcall sub_1B084(unsigned int, int);
int __fastcall sub_1B270(int, const char *, int);
int __fastcall sub_1B2DC(unsigned int, int);
int __fastcall sub_1B354(unsigned int, unsigned __int16);
_DWORD *__fastcall sub_1B498(_DWORD *result);
_DWORD *__fastcall sub_1B4D0(_DWORD *);
_DWORD *__fastcall sub_1B4F0(_DWORD *);
void __fastcall sub_1B808(_DWORD *, int, int, int, int, int, int, int);
void __fastcall sub_1B834(int, int);
float *__fastcall sub_1B864(int, int, int, int);
float *__fastcall sub_1B958(int, float *, int, int);
void __fastcall sub_1BAF0(float *, int, int, int, int);
FILE *__fastcall sub_1BB10(const char *aFName, fpos_t *pos);
void __fastcall Q_InitFileInfo_sub_1BB78(P_Type1 a1);
void __fastcall Q_CloseFileAndDelete_sub_1BBC8(P_Type1 a1);
BOOL __fastcall Q_CfilePreload_sub_1BBFC(P_Type1 a1, const char *aFName, int aOFlags, int a4);
BOOL __fastcall sub_1BCA8(T_Type1 *, const char *);
BOOL __fastcall Q_CFILE_CPP_sub_1BCBC(T_Type1 *a1, int aOFlags);
int __fastcall Q_CloseFile_sub_1BE00(P_Type1 a1);
int __fastcall sub_1BE28(P_Type1 a1);
int __fastcall sub_1BEA0(int *);
int __fastcall sub_1BECC(int *, int offset, int);
int __fastcall sub_1BF0C(int *, int);
void *__fastcall Q_CfileLoad_sub_1BF1C(T_Type1 *, void *);
int __fastcall sub_1BF94(P_Type1 a1, void *aBuf, unsigned int aLen);
unsigned int __fastcall sub_1BFD4(int *, void *buf, unsigned int, unsigned int, int);
unsigned int __fastcall sub_1C098(unsigned int count, int, unsigned int);
void __fastcall Q_CFILE_CPP_IndexOneCob_sub_1C278(P_CobFilesIndex a1, char *CobFileName);
void __fastcall Q_CobCfgLoad_sub_1C3C4(P_CobFilesIndex a1);
void sub_1CC94();
int Q_CORN_CPP_StaticTxtLoad_sub_1CD3C();
char *__fastcall Q_CORN_CPP_StaticTxtRead_sub_1CEA8(int aTextIndex);
int sub_1CEF0();
unsigned __int8 __fastcall sub_1CF14(unsigned __int8 result);
_DWORD *__fastcall sub_1CF40(_DWORD *result);
int __fastcall sub_1CF68(int, int);
__int16 __fastcall sub_1D234(int, int, __int16);
unsigned int __fastcall sub_1D3E8(int, int, int);
unsigned int __fastcall sub_1D538(int, int);
int __fastcall sub_1D654(__int16 *, int, int);
void __fastcall sub_1D734(int, int);
int __fastcall sub_1D794(__int16 *, _DWORD *);
unsigned int __fastcall sub_1D834(int, __int16);
int *__fastcall sub_1D920(int, unsigned int count, int);
int __fastcall sub_1DA04(int, int);
int __fastcall sub_1DA4C(int, __int16, int, int);
int __fastcall sub_1DB70(int a1, __int16 a2, int *a3, int a4);
int __fastcall sub_1DE64(int);
int __fastcall sub_1E03C(int);
char __fastcall sub_1E094(int);
void __fastcall sub_1E10C(int, __int16, __int16, __int16);
int __fastcall sub_1E150(int, __int16);
int __fastcall sub_1E2A0(int, __int16);
void __fastcall sub_1E70C(int, __int16, unsigned __int8);
char __fastcall sub_1EE08(int, char);
__int16 __fastcall sub_1EEA4(int);
void __fastcall sub_1EFC0(int);
unsigned int __fastcall sub_1F038(int);
int __fastcall sub_1F404(int);
int sub_1F91C();
int __fastcall sub_1FB34(int);
void __fastcall sub_1FD18(int, int);
int __fastcall sub_1FD90(int, int, int);
int __fastcall sub_1FDF0(int, int, int, int);
int __fastcall sub_1FFE0(int, int);
int __fastcall sub_2016C(int, int, __int16);
int __fastcall sub_201D8(int);
int __fastcall sub_205A0(int, int, int);
char *__fastcall sub_20684(int, __int16);
__int16 __fastcall sub_20720(int, int);
char __fastcall sub_207A0(int);
int __fastcall sub_20B3C(int);
char __fastcall sub_20C94(int, int, int, int);
int __fastcall sub_2106C(int result);
unsigned __int8 __fastcall sub_21170(int);
int __fastcall sub_211EC(int, int, int);
void __fastcall sub_21314(int);
int __fastcall sub_21374(int, unsigned int count); // idb
__int16 __fastcall sub_21AA0(int, unsigned int count);
__int16 __fastcall sub_220CC(int);
int __fastcall sub_22260(int);
int __fastcall sub_22280(int);
int __fastcall sub_222A0(int);
int __fastcall sub_222C0(int);
int __fastcall sub_222E0(int);
int __fastcall sub_22300(int);
int __fastcall sub_22320(int);
_DWORD *__fastcall sub_22360(int);
char *__fastcall sub_223B0(int);
char *__fastcall sub_223E0(int);
int __fastcall sub_22400(int result);
int __fastcall sub_22430(const void *, const void *); // idb
int sub_22468();
char *__fastcall sub_224A4(int);
char *__fastcall sub_22588(char *, char);
unsigned int __fastcall Q_COSWND_CPP_sub_22644(int, const char *, const char *);
_DWORD *__fastcall sub_2280C(int, int, int, int);
void __fastcall sub_23BF0(int, int);
int __fastcall sub_23FD4(int);
void __fastcall sub_24154(int, int, int, int, float);
void __fastcall sub_24198(int, int, int, int);
void __fastcall sub_2422C(int, int, int, int);
int __fastcall sub_24948(int result, int, int);
int __fastcall sub_24BE0(int);
int __fastcall __spoils<> sub_24D30(int, int, int, int);
__int64 __fastcall sub_24FCC(int, T_Type1 *, int);
int __fastcall sub_254A4(int);
int __fastcall sub_254B0(int result);
int __fastcall sub_254BC(int result, int);
void __fastcall sub_254DC(size_t *);
void __fastcall sub_254F8(int *a1, int a2);
void __fastcall __spoils<> sub_25BF8(P_TypeA2 a1);
void *__fastcall sub_25C08(int a1, char a2);
void __fastcall sub_25C4C(unsigned int, int);
int __fastcall sub_25CB8(int result);
void *__fastcall sub_25CD4(int a1, char a2);
void __fastcall sub_25D18(int result, LONG a2);
int __fastcall sub_25FB4(int result);
unsigned int __fastcall sub_26000(int, __int16, __int16, int);
int __fastcall sub_26140(int);
char *__fastcall sub_26150(int);
void Q_debugbreak_sub_26194();
void __fastcall __noreturn Q_AssertLogBreakExit_sub_26198(int ignore, const char *sourcefile, int line);
void __fastcall __noreturn Q_AssertLogBreakExit_sub_261A8(int ignore, const char *sourcefile, int line);
int __fastcall sub_261B8(int result, const char *, int);
int __cdecl sub_2620C(char *format, char); // idb
void __noreturn Q_debugbreak_exit_sub_2624C();
void __fastcall __spoils<edx,ebx> sub_2625C(void *aData, int a2, char *a3);
void __fastcall sub_2627C(void *);
void *__fastcall sub_2628C(size_t, int, char *s2);
void *__fastcall sub_262B0(size_t, size_t, int, char *);
void __fastcall sub_262CC(void *ptr);
void sub_262F0();
void sub_26314();
void sub_2631C();
void sub_26328();
void sub_2632C();
int __fastcall sub_2633C(int a1, int a2, LONG a3);
__int16 __fastcall __spoils<> sub_26360(__int16);
LONG sub_264B4();
int __fastcall sub_2656C(__int16);
void __fastcall sub_265A8(int);
void __fastcall __spoils<> sub_267A0(P_TypeA5 a1);
void *__fastcall sub_267BC(int a1, char a2);
void __fastcall __spoils<> sub_26800(P_TypeA5 result);
char __fastcall sub_26874(int, __int16 *);
unsigned int __fastcall sub_270F4(int, __int16, int, int);
void __fastcall __spoils<> sub_2712C(T_TypeA2 *a1);
void *__fastcall sub_2713C(int a1, char a2);
unsigned int __fastcall sub_27184(int, __int16, int, int);
__int64 __fastcall sub_271FC(int);
void __fastcall __spoils<> sub_27BF8(P_TypeA2 a1);
void *__fastcall sub_27C08(int a1, char a2);
unsigned int __fastcall sub_27C50(int, __int16, int, int);
void __fastcall sub_27D18(int, int, int, int);
void __cdecl callback_fn();
int __fastcall sub_28C4C(__int16 *, __int16 *);
void __fastcall __spoils<> sub_28C74(P_Type2 a1);
void __fastcall sub_28DA4(int a1);
UBYTE *__fastcall sub_28EB4(int a1, const char *a2, int a3, int a4, int a5);
int __fastcall sub_29038(int, size_t, unsigned int, int, int, int);
unsigned int __fastcall sub_296B4(int, int, int, int);
void __fastcall sub_29B24(_DWORD *, int, int, int);
unsigned __int16 __fastcall sub_29C6C(int, _WORD *);
int __fastcall sub_29D54(int, unsigned __int8 *);
void __fastcall sub_29F58(int, const void *);
FILE *__fastcall sub_2A1DC(int, const char *);
void __fastcall sub_2AA88(int);
int __fastcall sub_2AC84(int, ULONG hertz);
void __fastcall sub_2AD08(int);
__int16 __cdecl sub_2AD40(unsigned __int16 *, int, LONG y);
void __fastcall __spoils<> sub_2AE80(P_TypeA9 a1);
int __fastcall sub_2AEB0(int a1, char a2);
UBYTE *__fastcall sub_2AF04(int a1, const char *a2);
int __fastcall sub_2AF3C(int);
unsigned int __fastcall sub_2AFF0(int, __int16, int, int);
void __fastcall __spoils<> sub_2B2C0(_DWORD *);
void **__fastcall sub_2B2E0(void **);
unsigned int __fastcall sub_2B2FC(int a1, const char *aFName);
unsigned int __fastcall sub_2B360(void **a1, const char *aFName);
_DWORD *__fastcall sub_2B3E0(_DWORD *result, int, int, int, int);
int __fastcall sub_2B3F4(int, char *s2, char *s1, int);
int __fastcall sub_2B4F4(_DWORD *, char *string);
LONG __fastcall sub_2B594(int *a1);
int __fastcall sub_2B5BC(int *, char *);
void __fastcall sub_2B610(_DWORD *a1, LONG a2, LONG a3, char *a4, int a5, int a6, __int16 a7);
int __fastcall sub_2B8A8(int, int, int, const char *, __int16, __int16, __int16, int);
int sub_2BB50();
LONG __fastcall sub_2BB74(int **a1, int *a2, int *a3, int *a4, int *y0, unsigned __int8 a6, int a7);
int __fastcall sub_2BC40(_DWORD *a1, void *a2, LONG a3, int *a4, int *a5);
__int64 __fastcall sub_2BCF4(int a1, unsigned __int8 a2);
__int64 __fastcall sub_2BD04(int, char, char *);
int __fastcall sub_2BD4C(int result);
T_Type6 *__fastcall sub_2BD7C(T_Type6 *);
unsigned int __fastcall sub_2BD88(P_Type6 a1, const char *a2, const char *a3);
unsigned int __fastcall Q_GSYSTEM_CPP_sub_2BFDC(P_Type6 a1, int a2, int a3, int a4);
void *__fastcall sub_2C08C(int, unsigned __int16);
int __fastcall sub_2C0C0(int, const char *, unsigned __int16);
unsigned int __fastcall Q_LoadPal_sub_2C158(P_Type6 a1, const char *aFName, int a3, unsigned __int16 a4);
int __fastcall sub_2C1E0(int, unsigned __int16, unsigned __int16, unsigned int);
int __fastcall sub_2C224(P_Type6 a1, unsigned __int16 a2, __int16 a3, RGB *a4);
int __fastcall sub_2C2B0(int, unsigned __int16, __int16, int);
void __fastcall sub_2C2F8(int, char *);
void __fastcall sub_2C418(int, int, __int16);
void __fastcall sub_2C4C0(int, int, int);
__int64 __fastcall sub_2C5E4(int, char);
void __fastcall sub_2C670(int, int, int, char *);
void __fastcall sub_2C6CC(P_Type6 a1);
void __fastcall Q_GSYSTEM_CPP_PreloadMouseShp_sub_2C744(P_Type6 a1, char *a2, int a3, int a4);
void __fastcall Q_GSYSTEM_CPP_sub_2C7D0(T_Type6 *a1, int a2, int a3);
void __fastcall __spoils<> sub_2C830(P_TypeA2 a1);
int __fastcall sub_2C848(int, char);
void __fastcall __spoils<> sub_2C8E4(P_TypeA1 result);
int __fastcall sub_2C978(P_TypeA1 a1);
unsigned int __fastcall sub_2C990(int, int);
unsigned int __fastcall sub_2CA0C(int, int, _DWORD *);
_DWORD *__fastcall sub_2CA78(_DWORD *result, __int16, __int16);
void __fastcall sub_2CD24(unsigned int, int);
void __fastcall sub_2CF28(unsigned int);
unsigned int __fastcall sub_2D0F4(unsigned int, int);
void __fastcall sub_2D218(_DWORD *);
int __fastcall sub_2D258(int result, __int16);
int __fastcall sub_2D2CC(int, int, int, int);
int __fastcall sub_2D334(const char *);
char *__fastcall sub_2D3D0(int);
unsigned int __fastcall sub_2D400(int, int);
void __fastcall __spoils<> sub_2D464(P_TypeA4 a1);
void *__fastcall sub_2D480(int a1, char a2);
void __fastcall __spoils<> sub_2D4C4(P_TypeA4 result);
unsigned int __fastcall sub_2D4D0(_DWORD *, __int16, int, int);
void __fastcall sub_2D528(int, int);
void __fastcall sub_2D79C(int);
int __fastcall sub_2D99C(int, unsigned int count, int);
int __fastcall sub_2D9C4(int);
void *__fastcall sub_2D9FC(int a1, char a2);
int __fastcall sub_2DA60(int result);
int __fastcall sub_2DA68(T_TypeA1 *);
void *__fastcall sub_2DA80(int, __int16);
unsigned int __fastcall sub_2DAC8(int, __int16, __int16, int);
int __fastcall sub_2DB54(int result, __int16, __int16);
int __fastcall sub_2DBE4(int a1, int a2, int a3);
int __fastcall sub_2DCA0(int result, __int16);
int __fastcall sub_2DD70(int);
unsigned int __fastcall sub_2DDB8(int, __int16);
unsigned int __fastcall sub_2DE68(int, __int16, int, int);
void __fastcall sub_2E084(int);
int __fastcall sub_2E1B4(int, unsigned int count, int);
int __fastcall sub_2E208(_DWORD *a1, const char *a2, int a3, int a4);
T_TypeA2 *__fastcall sub_2E248(T_TypeA2 *);
void *__fastcall sub_2E264(int a1, char a2);
int __fastcall sub_2E2B8(int);
int __fastcall sub_2E3BC(T_TypeA1 *);
unsigned int __fastcall sub_2E3D4(int, __int16, signed int, signed int);
void __fastcall sub_2E6C0(int);
void __fastcall sub_2E868(int, int);
int __fastcall sub_2E9CC(int, char);
int __fastcall sub_2EA8C(int, const char *, __int16, int);
unsigned int __fastcall sub_2EC50(int, unsigned __int16, int);
int __fastcall sub_2ECA4(int, unsigned __int16);
int __fastcall sub_2ECDC(int result, unsigned __int16);
int __fastcall sub_2ED14(int, unsigned __int16);
int __fastcall sub_2ED4C(int);
void __fastcall sub_2EDC8(int, unsigned int, unsigned int);
void __fastcall sub_2F090(int, unsigned int, unsigned int, __int16);
int __fastcall sub_2F1C8(int result, int);
int __fastcall sub_2F1D8(int result, int);
void __fastcall sub_2F1E0(int);
int __fastcall sub_2F228(int, size_t, int);
void __fastcall sub_2F2B4(int);
T_TypeA2 *__fastcall sub_2F2F4(T_TypeA2 *result);
void *__fastcall sub_2F30C(int a1, char a2);
void __fastcall sub_2F354(int);
int __fastcall sub_2F414(int);
unsigned int __fastcall sub_2F420(int a1, __int16 a2, int a3, int a4);
unsigned int __fastcall sub_2F424(int, __int16, int, int);
unsigned int __fastcall sub_2F478(int a1, __int16 a2, int a3, int a4);
T_TypeA2 *__fastcall sub_2F48C(T_TypeA2 *);
void *__fastcall sub_2F4A8(int a1, char a2);
int __fastcall sub_2F4EC(int result);
void __fastcall sub_2F540(int);
unsigned int __fastcall sub_2F6B0(int, __int16, char, unsigned int);
int __fastcall sub_2F8A4(int, int);
// char __usercall sub_2F8F8@<al>(int@<eax>, __int16@<dx>, char@<bl>, int@<edi>);
int __fastcall sub_2F9A4(int, const char *, __int16);
void __fastcall __spoils<> sub_2FA18(P_TypeA3 a1);
void *__fastcall sub_2FA34(int a1, char a2);
void __fastcall __spoils<> sub_2FA78(P_TypeA3 result);
void __fastcall sub_2FA98(int);
void __fastcall sub_2FBA4(int, int);
int __fastcall sub_2FC3C(int);
void __fastcall __spoils<> sub_2FC50(P_TypeA2 a1);
void *__fastcall sub_2FC68(int a1, char a2);
int __fastcall sub_2FCB0(_DWORD *, char *, char *);
unsigned int __fastcall sub_2FD68(int, __int16, int, int);
void __fastcall Q_HELPWIN_CPP_FgetsLine_sub_2FE58(FILE *fp, char *line);
int sub_2FEB8(); // weak
// void __usercall sub_3067B(const char *a1@<edx>, int a2@<ebp>);
// void __usercall sub_306F0(int a1@<ecx>, const char *a2@<ebx>, int a3@<ebp>, int a4@<esi>);
void __fastcall sub_30774(int);
int __fastcall sub_30A90(T_Type5 *, int edx0, int, int);
int __fastcall sub_31158(_DWORD *, int, int, int);
T_TypeA2 *__fastcall sub_31200(T_TypeA2 *result);
void *__fastcall sub_3121C(int a1, char a2);
unsigned int __fastcall sub_31268(int, unsigned __int16, int, int);
void __fastcall sub_3160C(int);
void __fastcall sub_316A8(int a1, int a2);
int __fastcall sub_317D0(int);
int __fastcall sub_318A0(unsigned __int16, unsigned __int8);
char __fastcall sub_31934(int a1);
int __fastcall sub_31A34(unsigned __int16, char);
int __spoils<> sub_31B08();
int __fastcall sub_31C18(int result, int);
char __fastcall sub_31E60(const char *, int);
int __fastcall sub_31FB0(_DWORD *, const char *, int, int);
void __fastcall __spoils<> sub_3201C(P_TypeA7 a1);
void *__fastcall sub_32038(int a1, char a2);
void __fastcall __spoils<> sub_3207C(P_TypeA7 result);
unsigned int __fastcall sub_320B8(int, __int16, int, int);
void __fastcall sub_32414(int);
void *__fastcall sub_32658(int);
int __fastcall sub_32714(int, int, __int16);
int __fastcall sub_32800(int, int);
int __fastcall sub_32A1C(int);
__int64 __fastcall sub_32A48(int, int, __int16, int, int);
__int64 __fastcall sub_32B44(int, int, __int16);
__int64 __fastcall sub_32BDC(int, char);
__int64 __fastcall sub_32C14(int, char);
int __fastcall __spoils<> sub_32E84(int, int, int, int);
int __fastcall sub_32FD8(int, FILE *, int);
void __fastcall sub_330DC(T_Type5 *a1, unsigned __int8 *a2);
void __fastcall __spoils<> sub_33598(P_TypeA4 a1);
void *__fastcall sub_335B4(int a1, char a2);
void __fastcall __spoils<> sub_335F8(P_TypeA4 result);
unsigned int __fastcall sub_33604(int, __int16, int, int);
void __fastcall sub_33674(int);
void __fastcall __spoils<> sub_33830(P_TypeA6 a1);
void *__fastcall sub_33840(int a1, char a2);
int __fastcall sub_33884(_DWORD *, int, int, int);
unsigned int __fastcall sub_338DC(int, __int16, int, int);
void __fastcall sub_33A68(int a1);
__int16 __fastcall sub_33AF0(int, unsigned __int16, unsigned __int16, int);
FILE *sub_33D30();
int __fastcall sub_3407C(int);
void __fastcall sub_3420C(int);
unsigned int __fastcall sub_34368(int, unsigned __int8, unsigned __int16);
int __fastcall sub_34774(int result, unsigned __int8, int, int);
int __fastcall sub_347CC(int, unsigned __int8);
unsigned __int16 __fastcall sub_34A44(int, _DWORD *, _DWORD *, _DWORD *);
int __fastcall sub_34AE4(int, unsigned __int8, int);
unsigned int __fastcall sub_34B0C(__int64 a1, unsigned __int8 a2, unsigned __int8 a3);
unsigned __int16 __fastcall sub_34E70(int);
int __fastcall sub_352E0(int);
__int16 __fastcall sub_3583C(int, unsigned __int16, unsigned __int8);
int __fastcall sub_358BC(int);
int __fastcall sub_358F0(int);
int __fastcall sub_35930(int, char);
int __fastcall sub_35968(int, int, int);
unsigned int __fastcall sub_35A00(int, unsigned __int16);
char *__fastcall sub_35A70(int, unsigned __int16);
unsigned __int16 __fastcall sub_35B04(int, unsigned __int16, int);
unsigned int __fastcall sub_35BB4(int, int);
unsigned int __fastcall sub_35C38(int, int);
char __fastcall sub_35DA4(int);
char __fastcall __spoils<ah> sub_35E24(int);
int __fastcall sub_35ED8(int);
int __fastcall sub_35FE0(int);
void __fastcall sub_36050(int);
void __fastcall sub_360D8(int);
void __fastcall sub_36158(int);
int __fastcall sub_361B8(int a1);
unsigned int __fastcall sub_3623C(int);
int __fastcall sub_362C8(int, _DWORD *);
unsigned int __fastcall sub_362E0(int);
void __fastcall sub_3636C(int, int);
int __fastcall sub_363B0(int);
int __fastcall sub_364B4(int, __int16);
// __int64 __userpurge sub_366C8@<edx:eax>(__int64 a1@<edx:eax>, _DWORD *a2@<ecx>, _DWORD *a3@<ebx>, __int64 result, _DWORD *a5, _DWORD *a6, _DWORD *a7);
int __fastcall sub_3676C(int, int);
__int16 __fastcall sub_36A5C(int, int, __int16);
unsigned int __fastcall sub_36CD4(int, unsigned __int16, int *);
unsigned __int16 __fastcall sub_37040(int);
unsigned int __fastcall sub_370B8(int, unsigned int count, int);
T_TypeA2 *__fastcall sub_372B0(T_TypeA2 *, int, int, int);
void *__fastcall sub_372CC(int a1, char a2);
int __fastcall sub_37310(int, int, int, int);
int __fastcall sub_37380(int, int);
int __fastcall sub_373E0(int, int);
int __fastcall sub_3745C(T_Type5 *, unsigned __int8 *, int, int);
int __fastcall sub_37568(int a1, unsigned __int16 a2, int a3, unsigned int a4);
void __fastcall sub_384B0(int);
char __fastcall sub_39390(int, unsigned __int8, __int16 *, _WORD *);
__int16 __fastcall sub_393F4(int, unsigned __int16, _WORD *, _WORD *);
char *__fastcall sub_394BC(int);
int __fastcall sub_395C4(int, unsigned int count, int);
void __fastcall __spoils<> sub_395EC(P_TypeA2 result);
void *__fastcall sub_395FC(int a1, char a2);
unsigned int __fastcall sub_39644(int, __int16, int, int);
void __fastcall sub_396F0(int, int);
T_TypeA2 *__fastcall sub_39D80(T_TypeA2 *);
void *__fastcall sub_39D9C(int a1, char a2);
char *sub_39DE0();
unsigned int __fastcall sub_39E3C(int, __int16 dx0, int, int);
void __fastcall sub_3A6BC(int);
int __fastcall sub_3B120(int);
int __fastcall sub_3B188(int result);
int __fastcall sub_3B1FC(_BYTE *, char, __int16);
char __fastcall sub_3B220(int, int, int, int);
int __fastcall sub_3B56C(unsigned __int8 *, __int16 *);
void __fastcall sub_3B5B8(unsigned __int8 *);
unsigned int __fastcall sub_3C12C(unsigned __int8 *, _DWORD *);
char __fastcall sub_3C1C0(unsigned __int8 *, int *, int);
int __fastcall sub_3C2E8(unsigned __int8 *a1, int *a2, int a3);
char __fastcall sub_3C670(_BYTE *);
int __fastcall sub_3C968(int);
int __fastcall sub_3CB60(unsigned __int8 *, int, unsigned __int8);
unsigned int __fastcall sub_3CCE4(_BYTE *, int);
char __fastcall sub_3D8F0(_BYTE *a1, int a2);
unsigned int __fastcall sub_3E020(int, int, unsigned __int8);
int __fastcall sub_3E1CC(int, int);
unsigned int __fastcall sub_3E520(int, int);
int __fastcall sub_3E800(_BYTE *, unsigned __int16 *);
__int16 __fastcall sub_3EA7C(_BYTE *);
char __fastcall sub_3EBDC(unsigned __int8 *a1, int a2);
size_t __fastcall sub_3EFE0(int);
__int16 __fastcall sub_3F060(unsigned __int8 *, _DWORD *, int, unsigned __int8);
unsigned int __fastcall sub_3F324(int, char, char, char, int, char, _DWORD *, unsigned __int8);
unsigned int __fastcall sub_3F3F8(unsigned __int8 *, char, char, char, char, char, _DWORD *, unsigned __int8);
unsigned int __fastcall sub_3F784(int, char, char, char, char, char, _DWORD *, unsigned __int8);
unsigned int __fastcall sub_3FBAC(int, char, char, char, char, char, _DWORD *, unsigned __int8);
int __fastcall sub_40084(int, _DWORD *, int, char);
char *__fastcall sub_40144(unsigned __int8 *, int);
int __fastcall compar(const void *, const void *); // idb
size_t __fastcall sub_40224(unsigned __int8 *, _DWORD *, _DWORD *);
int __fastcall sub_402E0(_BYTE *);
int __fastcall sub_403C0(unsigned __int8 *, int);
int __fastcall sub_40590(_BYTE *);
unsigned int __fastcall sub_405F4(_BYTE *);
int __fastcall sub_40664(_BYTE *);
int __fastcall sub_406C4(unsigned __int8 *, __int16 *, int);
// int __userpurge sub_41268@<eax>(unsigned __int8 *@<eax>, __int16@<dx>, int@<ecx>, int@<ebx>, int@<ebp>, int, __int16, int, int, int, int, int);
unsigned int __fastcall sub_43184(int, int, int);
char __fastcall sub_43374(unsigned __int8 *, int);
unsigned int __fastcall sub_433E0(int, __int16, int);
int __fastcall sub_434E4(char *, int);
int __fastcall sub_43B7C(int, __int16);
__int64 __fastcall sub_43BDC(int, unsigned int, int);
int __fastcall sub_43C80(int, int, int, int);
unsigned int __fastcall sub_44024(_BYTE *, char);
char *__fastcall sub_44080(unsigned __int8 *);
int __fastcall sub_44238(int, __int16, _BYTE *, __int16);
char __fastcall sub_44434(unsigned __int8 *, __int16, _DWORD *);
int __fastcall sub_44A2C(_BYTE *, int, char, _BYTE *);
char __fastcall sub_44BCC(int, __int16 *, char, int, int *);
char __fastcall sub_450B0(unsigned __int8 *, __int16, char, char, int, int);
// int __usercall sub_45848@<eax>(unsigned __int8 *@<eax>, int@<edx>, int@<ebx>, __int16 *@<edi>);
int __fastcall sub_45958(unsigned __int8 *, char, __int16 *, _DWORD *);
int __fastcall sub_45A0C(_BYTE *, int, int, __int16);
unsigned int __fastcall sub_45A54(unsigned __int8 *, int, int);
unsigned int __fastcall sub_45D50(unsigned __int8 *, int, int);
unsigned int __fastcall sub_45E64(_BYTE *, __int16);
void __fastcall sub_45F60(_BYTE *, __int16, int);
unsigned int __fastcall sub_46034(_BYTE *, __int16);
void __fastcall sub_46130(_BYTE *, __int16, int);
unsigned int __fastcall sub_46208(_BYTE *, __int16);
int __fastcall sub_46304(_BYTE *, __int16, int);
unsigned __int16 *sub_46470();
unsigned __int16 *__fastcall sub_46480(unsigned __int16 *a1, const char *a2);
int __fastcall sub_466FC(unsigned int);
unsigned int __fastcall sub_468BC(unsigned int result);
unsigned int __fastcall sub_46900(char *, char);
unsigned int __fastcall sub_4694C(int, unsigned __int16, __int16);
int __fastcall sub_469F0(int, unsigned __int16);
__int16 __fastcall sub_46A94(unsigned __int16 *, unsigned __int16, int);
int __fastcall sub_46BB0(_WORD *, unsigned int count, int);
unsigned __int16 *__fastcall sub_46C10(unsigned __int16 *a1);
int __fastcall sub_46C20(int, int, int);
int __fastcall sub_46C48(int a1, char a2);
int __fastcall sub_46CAC(int, int, int, int);
int __fastcall sub_47088(int);
unsigned int __fastcall sub_47224(int, unsigned __int16, int, unsigned int);
int __fastcall sub_47A64(const void *, const void *); // idb
void __fastcall sub_47ABC(int a1);
int __fastcall sub_48B14(int, unsigned int count, int);
int __fastcall sub_48B40(T_TypeA2 *, int, int, int);
_DWORD *__fastcall sub_48B90(_DWORD *);
int __cdecl sub_48C58(_DWORD); // weak
int __fastcall sub_48C5C(int, char);
int sub_48C84();
int __fastcall sub_48EAC(int result);
int __fastcall sub_49148(int, char);
unsigned int __fastcall sub_492AC(_DWORD *, char, int);
unsigned int __fastcall sub_492F8(_DWORD *, int);
int __fastcall sub_49328(int a1, char a2);
int __fastcall sub_4937C(int a1, char a2);
void __fastcall sub_493BC(int, char);
int __fastcall sub_49494(int, float *);
unsigned int __fastcall sub_4960C(int, int);
unsigned int __fastcall sub_49648(int, __int16 **);
int __fastcall sub_496BC(int, _DWORD *);
void __fastcall sub_496E0(_DWORD *);
int __fastcall sub_49828(int);
__int16 __fastcall sub_49940(int);
int __fastcall sub_49A40(int, int);
char *__fastcall sub_49A8C(int, char *);
int __fastcall sub_49B3C(int, int);
int __fastcall sub_49B68(int, int);
int __fastcall sub_49CC4(int, int);
int __fastcall sub_4A0D0(int, int);
int __fastcall sub_4A144(int);
int __fastcall sub_4A18C(int);
int __fastcall sub_4A1CC(int, __int16);
char __fastcall sub_4A36C(int, char, __int16);
int __fastcall sub_4A404(int, char);
_BYTE *__fastcall sub_4A480(int, unsigned __int16, int);
unsigned int __fastcall sub_4A534(int, char);
unsigned int __fastcall sub_4A564(int);
int __fastcall sub_4A5B8(int result);
int __fastcall sub_4A6AC(int, int, int, int);
int __fastcall __spoils<> sub_4A8CC(int);
int __fastcall sub_4A8FC(int);
int __fastcall sub_4A988(int);
int __fastcall sub_4AA78(int, int);
int __fastcall sub_4AAEC(int, int);
__int64 __fastcall sub_4AE8C(int, unsigned int, int);
int __fastcall sub_4B5C0(int result, int);
int __fastcall sub_4B5E0(_DWORD *, int);
int __fastcall sub_4B780(int result, int);
int __fastcall sub_4B7A0(int, int, int, __int16);
int __fastcall sub_4B944(int, int);
int __fastcall sub_4C7FC(int, int);
int __fastcall sub_4CAB8(int, int);
int __fastcall sub_4CDF8(int, int);
_DWORD *sub_4D700();
int __fastcall sub_4D724(T_Type5 *a1, int a2, LONG a3, int a4);
unsigned int __fastcall sub_4D7A8(int, int, int);
char *__fastcall sub_4D92C(int);
int __fastcall sub_4DA08(int a1, char a2, int a3, int a4);
int __fastcall sub_4DA5C(int result);
int __fastcall sub_4DA7C(int, int, int, int);
char __fastcall sub_4DD14(int);
unsigned int __fastcall sub_4DDB0(int, __int16, int, int);
int __fastcall sub_4E644(int result, char, int, int);
unsigned int __fastcall sub_4E69C(int);
void __fastcall sub_4E758(_DWORD *);
int __fastcall sub_4EE00(int);
char *sub_4EE50();
char *__fastcall sub_4EE74(int);
int __fastcall sub_4EF94(int);
LONG __fastcall Q_StartSoundSystem_sub_4EFB0(int a1, int aDIG, int aMID);
HMDIDRIVER __fastcall sub_4F088(char *path, char *, char *, char *);
int __fastcall sub_4F184(int, int);
void __fastcall sub_4F32C(int, __int16, int);
void __fastcall sub_4F45C(int, __int16);
void __fastcall sub_4F4D4(int, __int16);
HDIGDRIVER __fastcall sub_4F534(_DWORD *, char *, char *);
int __fastcall sub_4F5E8(int, int);
int __fastcall sub_4F65C(int, const char *);
unsigned int __fastcall sub_4F8CC(int, __int16, int);
int __fastcall sub_4FA1C(int result);
void __fastcall sub_4FAB4(int);
int __fastcall sub_4FB90(int result, __int16);
void __fastcall sub_4FE8C(int result);
void __fastcall __spoils<> sub_4FF08(int a1);
void __fastcall __spoils<> sub_4FF1C(int result);
void __fastcall __spoils<> sub_4FF28(int result);
void __fastcall sub_4FF4C(int, char);
int __fastcall sub_4FF94(_DWORD *);
int __fastcall sub_50140(int, __int16);
unsigned __int16 __fastcall sub_50530(T_Type5 *, int, int, int);
LONG __fastcall sub_50D70(_DWORD *a1, int a2, int a3, int a4);
void __fastcall sub_51610(T_Type5 *a1, LONG a2, int a3, int a4);
T_TypeA2 *__fastcall sub_51674(T_TypeA2 *);
void *__fastcall sub_51690(int a1, char a2);
int __fastcall sub_516D4(int result);
void __fastcall sub_516E0(_DWORD *);
unsigned int __fastcall sub_51894(int, __int16, __int16, int);
T_TypeA2 *__fastcall sub_51B64(T_TypeA2 *);
void *__fastcall sub_51B80(int a1, char a2);
void __fastcall sub_51BC4(_DWORD *);
unsigned int __fastcall sub_51D24(int, __int16, int, int);
T_TypeA2 *__fastcall sub_520EC(T_TypeA2 *);
void *__fastcall sub_52108(int a1, char a2);
int __fastcall sub_5214C(int result);
int __fastcall sub_52174(int);
void __fastcall sub_521C0(int, int edx0);
unsigned int sub_526D8();
int __fastcall sub_52714(int);
unsigned int __fastcall sub_5294C(int, __int16 dx0, int, int);
void __fastcall sub_53000(float *);
void __fastcall sub_53054(float *, float);
unsigned int __fastcall sub_53078(_DWORD *);
double __fastcall sub_5309C(float *, float *);
float *__fastcall sub_53114(float *result, float *);
int __fastcall sub_5323C(int result, float);
float *__fastcall sub_532AC(float *result, float);
float *__fastcall sub_53318(float *result, float);
float *__fastcall sub_53384(float *result, float *, float *);
int __fastcall sub_533D4(float *, float, int, int, int, int);
int __fastcall sub_53440(float *);
void __fastcall sub_5353C(float *, int, int, int, int);
void __fastcall sub_53564(float *, int, int, int, int);
void __fastcall sub_5358C(float *, int, int, int, int);
void __fastcall sub_535B4(float *, int, int, int, int);
void __fastcall sub_535E4(float *, int, int, int, int);
void __fastcall sub_53644(float *, int, int, int);
void __fastcall sub_53754(float *, int, int, int);
void __fastcall sub_53864(float *, int, int, int);
float *__fastcall sub_53B08(float *result, float *, float *, float *);
int __fastcall sub_53DC0(int, int, int);
void __cdecl Q_Timer_sub_53DE4();
int Q_CheckFreeMemory_sub_53DEC();
void __fastcall sub_53E38(P_Type5 a1, int a2, int a3, __int16 a4);
void __fastcall sub_53EB8(P_Type5 a1, int a2, int a3, int a4, int a5, __int16 a6);
void __fastcall sub_53F40(T_Type5 *a1, void *a2, LONG a3, LONG a4, int a5, char a6);
void __fastcall sub_53FB0(const char *a1, int a2, int a3, int a4);
void __fastcall sub_54048(const char *, int, int, int);
LONG __fastcall __spoils<> sub_54208(PANE *a1, int a2, int a3, int a4);
LONG __fastcall sub_542B0(_DWORD *a1, int a2, int a3, int *a4);
int __fastcall sub_54344(int, int, int);
char *__fastcall sub_54374(T_Type3 *a1);
void *__fastcall sub_54448(int);
unsigned int __fastcall sub_545EC(P_Type3 a1);
void __fastcall sub_54664(int);
int __fastcall sub_5469C(P_Type3 a1, int a2, int a3, int a4);
unsigned int __fastcall sub_54D64(unsigned int a1, int a2, int a3);
unsigned int __fastcall sub_5508C(P_Type3 a1);
void __fastcall sub_55214(int eax0, LONG a2, LONG a3, LONG a4, int a5);
void __fastcall sub_55274(P_Type3 a1, int x1, int y1, int x2, int y2);
void __fastcall sub_552CC(P_Type3 a1, P_Type5 a2);
int __fastcall sub_552F8(unsigned int a1, int a2, int *a3);
unsigned int __fastcall sub_55618(unsigned int result, int);
int __fastcall sub_556CC(unsigned int a1, int a2);
const char *__fastcall sub_557D4(T_Type3 *eax0, char *s2, const char *, __int16);
unsigned int __fastcall sub_55AEC(int, __int16, int, int);
char __fastcall sub_55B74(int);
__int16 __fastcall sub_55E80(int);
void __fastcall sub_56400(T_Type3 *, int, __int16, int, int, int);
void __fastcall sub_564C0(T_Type3 *, int, __int16);
int __fastcall sub_56528(int, int, __int16);
unsigned int __fastcall sub_56564(int, int, __int16, int);
int __fastcall sub_56694(int);
void __fastcall sub_56728(int, int, int, __int16, int, int);
void __fastcall sub_567BC(int, int, __int16);
void __fastcall sub_56824(int);
int __fastcall sub_5691C(int result);
int __fastcall sub_56B60(int, __int16, int, int);
int __fastcall sub_56BE8(int result, __int16, int, int, int);
int __fastcall sub_56D30(int, int, int, int, int);
int __fastcall sub_56D70(int, char *, __int16, int, int);
int __fastcall sub_56DA8(int, char *s1, _WORD *);
int __fastcall sub_56E18(int, char *s1, __int16, _WORD *);
P_Type3 __fastcall sub_56E9C(P_Type3 a1, __int16 a2, int a3);
int __fastcall sub_570AC(int, int);
int __fastcall sub_571B8(P_Type3 a1, P_TypeA1 a2);
unsigned int __fastcall sub_57220(int, int, __int16);
unsigned int __fastcall sub_57310(int, int, __int16, int);
unsigned int __fastcall sub_5748C(int, __int16, __int16);
int __fastcall sub_574F0(P_Type3 a1, __int16 a2, int a3);
int __fastcall sub_57510(int, __int16, int);
int __fastcall sub_57530(int result, int, int);
FILE *__fastcall sub_575BC(P_Type3);
FILE *__fastcall Q_WINMGR_CPP_sub_57670(P_Type3 a1, const char *a2);
void __fastcall sub_59828(int a1, int a2, int a3, int a4);
void __fastcall sub_5989C(P_Type3 a1, int a2, int a3, int a4);
int __fastcall sub_59908(int result);
void __fastcall sub_59934(T_Type3 *a1, int a2, int a3);
unsigned int __fastcall sub_59988(P_Type3, char *, int);
int __fastcall sub_59A54(int result);
void __fastcall sub_59B80(int);
void __fastcall sub_59C80(T_Type3 *, int, __int16, __int16, int, int, int);
unsigned int __fastcall sub_59CFC(int, const char *);
void __fastcall sub_59DE0(int, int, int, int);
char *__fastcall sub_59E88(T_Type3 *a1, char *a2, char *filename);
void __fastcall Q_WINMGR_CPP_sub_5A094(P_Type3 a1, void *aData, int a3, char *a4);
void __fastcall Q_WINMGR_CPP_sub_5A144(P_Type3 a1, void *a2);
char *__fastcall sub_5A194(int, int, _DWORD *, _DWORD *);
void __fastcall sub_5A270(T_Type3 *a1, int a2, int a3, int a4);
void __fastcall sub_5A294(_DWORD *);
void __fastcall sub_5A320(__int16 a1);
int __fastcall sub_5A47C(T_Type5 *, const char *, int, int);
LONG __fastcall sub_5A4E4(_DWORD *a1, LONG a2, int a3, int a4);
T_TypeA2 *__fastcall sub_5A594(T_TypeA2 *result);
void *__fastcall sub_5A5AC(int a1, char a2);
int __fastcall sub_5A5F4(T_TypeA1 *);
unsigned int __fastcall sub_5A60C(int, __int16, __int16, int);
void __fastcall sub_5AA08(int);
int __fastcall sub_5AB04(const char **, const char **);
void __fastcall sub_5AB2C(int, int);
int __fastcall sub_5AE68(int, int);
unsigned int __fastcall sub_5AF30(int, int);
int __fastcall sub_5B200(int, int);
int __fastcall sub_5B244(int result, int);
void *__fastcall sub_5B2B0(int a1, char a2);
T_TypeA2 *__fastcall sub_5B2F0(T_TypeA2 *result);
void *__fastcall sub_5B300(int a1, char a2);
T_TypeA2 *__fastcall sub_5B340(T_TypeA2 *result);
BOOL __fastcall sub_5B50C(_DWORD *, _DWORD *);
_DWORD *__fastcall sub_5B617(size_t);
unsigned int __fastcall sub_5B71C(int);
unsigned int __fastcall sub_5B7C2(_DWORD *a1, int a2, int x1, int y1, int x2, int y2);
unsigned int __fastcall sub_5BA38(_DWORD *);
int __fastcall sub_5BAC0(_DWORD *, int);
char *__fastcall sub_5BBE4(void **, char *, int);
void __fastcall sub_5BDDC(void *);
// BYTE *__cdecl VFX_driver_name(void *VFXScanDLL);
// LONG __cdecl VFX_register_driver(void *DLLbase);
// LONG __cdecl VFX_pixel_write(PANE *pane, LONG x, LONG y, ULONG color);
// LONG __cdecl VFX_pixel_read(PANE *pane, LONG x, LONG y);
// LONG __cdecl VFX_line_draw(PANE *pane, LONG x0, LONG y0, LONG x1, LONG y1, LONG mode, LONG parm);
// void __cdecl VFX_shape_draw(PANE *pane, void *shape_table, LONG shape_number, LONG hotX, LONG hotY);
// void __cdecl VFX_shape_lookaside(UBYTE *table);
// void __cdecl VFX_shape_translate_draw(PANE *pane, void *shape_table, LONG shape_number, LONG hotX, LONG hotY);
// void __cdecl VFX_shape_transform(PANE *pane, void *shape_table, LONG shape_number, LONG hotX, LONG hotY, void *buffer, LONG rot, LONG x_scale, LONG y_scale, LONG flags);
// void __cdecl VFX_shape_visible_rectangle(void *shape_table, LONG shape_number, LONG hotX, LONG hotY, LONG mirror, LONG *rectangle);
// LONG __cdecl VFX_pane_wipe(PANE *pane, LONG color);
// LONG __cdecl VFX_pane_copy(PANE *source, LONG sx, LONG sy, PANE *target, LONG tx, LONG ty, LONG fill);
// void __cdecl VFX_ellipse_draw(PANE *pane, LONG xc, LONG yc, LONG width, LONG height, LONG color);
// void __cdecl VFX_ellipse_fill(PANE *pane, LONG xc, LONG yc, LONG width, LONG height, LONG color);
// LONG __cdecl VFX_font_height(void *font);
// LONG __cdecl VFX_character_width(void *font, LONG character);
// void __cdecl VFX_string_draw(PANE *pane, LONG x, LONG y, void *font, char *string, UBYTE *color_translate);
// LONG __cdecl VFX_GIF_draw(PANE *pane, UBYTE *GIF_buffer, void *GIF_scratch);
// LONG __cdecl VFX_shape_resolution(void *shape_table, LONG shape_num);
// LONG __cdecl VFX_shape_count(void *shape_table);
// int __cdecl sub_61800(_DWORD *, int, int);
// int __cdecl sub_62DA5(_DWORD *, int, int, int);
// void MOUSE_show(void);
// void MOUSE_hide(void);
// void __fastcall MOUSE_set_pointer(void *table, LONG shape);
// void __fastcall MOUSE_status(LONG *mx, LONG *my, LONG *ml, LONG *mr, LONG *mc);
// void __fastcall MOUSE_force_move(LONG new_x, LONG new_y);
// void __fastcall MOUSE_pane_list_refresh(PANE_LIST *list);
// LONG __fastcall MOUSE_init(LONG xsize, LONG ysize, LONG background);
// void MOUSE_shutdown(void);
// void *__cdecl DLL_load(void *source, ULONG flags, void *dll);
// void __cdecl AIL_startup();
// void __cdecl AIL_shutdown();
// HTIMER __cdecl AIL_register_timer(AILTIMERCB callback_fn);
// void __cdecl AIL_set_timer_frequency(HTIMER timer, ULONG hertz);
// void __cdecl AIL_start_timer(HTIMER timer);
// void __cdecl AIL_stop_timer(HTIMER timer);
// void __cdecl AIL_release_timer_handle(HTIMER timer);
// LONG __cdecl AIL_install_DIG_INI();
// HDIGDRIVER __cdecl AIL_install_DIG_driver_file(BYTE *filename, IO_PARMS *IO);
// HSAMPLE __cdecl AIL_allocate_sample_handle(HDIGDRIVER dig);
// void __cdecl AIL_init_sample(HSAMPLE S);
// void __cdecl AIL_set_sample_address(HSAMPLE S, void *start, ULONG len);
// void __cdecl AIL_set_sample_type(HSAMPLE S, LONG format, ULONG flags);
// void __cdecl AIL_start_sample(HSAMPLE S);
// void __cdecl AIL_stop_sample(HSAMPLE S);
// void __cdecl AIL_set_sample_playback_rate(HSAMPLE S, LONG playback_rate);
// void __cdecl AIL_set_sample_volume(HSAMPLE S, LONG volume);
// void __cdecl AIL_set_sample_loop_count(HSAMPLE S, LONG loop_count);
// ULONG __cdecl AIL_sample_status(HSAMPLE S);
// LONG __cdecl AIL_minimum_sample_buffer_size(HDIGDRIVER dig, LONG playback_rate, LONG format);
// LONG __cdecl AIL_sample_buffer_ready(HSAMPLE S);
// void __cdecl AIL_load_sample_buffer(HSAMPLE S, ULONG buff_num, void *buffer, ULONG len);
// LONG __cdecl AIL_install_MDI_INI();
// HMDIDRIVER __cdecl AIL_install_MDI_driver_file(BYTE *filename, IO_PARMS *IO);
// HSEQUENCE __cdecl AIL_allocate_sequence_handle(HMDIDRIVER mdi);
// void __cdecl AIL_start_sequence(HSEQUENCE S);
// void __cdecl AIL_stop_sequence(HSEQUENCE S);
// void __cdecl AIL_end_sequence(HSEQUENCE S);
// ULONG __cdecl AIL_sequence_status(HSEQUENCE S);
// void __cdecl AIL_set_GTL_filename_prefix(BYTE *prefix);
// __int16 __cdecl UVB_sub_75F32(__int16, int);
// __int16 __cdecl UVB_sub_75F6C(__int16, int, __int16);
// __int16 __cdecl UVB_sub_75FBE(__int16, char *, _WORD *, unsigned int);
// __int16 __cdecl UVB_sub_768A0(__int16, __int16, unsigned __int16 *, __int16 *);
// _DWORD *__cdecl UVB_sub_76A04(_DWORD *, _DWORD *, int, int);
// int __cdecl UVB_sub_76A40(int, _DWORD *, _DWORD *, _DWORD *, _DWORD *);
// __int16 __cdecl UVB_sub_76BB0(char, unsigned __int16 *, _WORD *, __int16 *);
// int sprintf(char *s, const char *format, ...);
// int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD); weak
// void __fastcall operator delete[](void *); weak
// void __fastcall operator delete(void *); weak
// int __fastcall strcmp(const char *s1, const char *s2);
// double __fastcall sqrt(double x);
// void _CHP();
// void *__fastcall memset(void *s, int c, size_t n);
// void __fastcall qsort(void *base, size_t nmemb, size_t size, int (__fastcall *compar)(const void *, const void *));
// int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD); weak
// int sscanf(const char *s, const char *format, ...);
// int __fastcall fclose(FILE *fp);
// double __fastcall cos(double x);
// double __fastcall sin(double x);
// double __fastcall tan(double x);
// void *__fastcall operator new[](size_t size);
// int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD); weak
// int __fastcall stricmp(const char *s1, const char *s2);
// FILE *__fastcall fdopen(int handle, const char *mode);
// int __fastcall fgetpos(FILE *fp, fpos_t *pos);
// char *__fastcall strncpy(char *s1, const char *s2, size_t n);
// int __fastcall filelength(int handle);
// int open(const char *path, int oflag, ...);
// int __fastcall lseek(int handle, int offset, int origin);
// int __fastcall close(int handle);
// int __fastcall tell(int handle);
// volatile int *__fastcall _get_errno_ptr();
// int __fastcall read(int handle, void *buf, unsigned int len);
// unsigned int __fastcall dos_write(int handle, const void far *buf, unsigned int count, unsigned int *bytes);
// void __fastcall _assert(int, char *, char *, int);
// int __fastcall write(int handle, const void *buf, unsigned int len);
// FILE *__fastcall fopen(const char *filename, const char *mode);
// int fscanf(FILE *fp, const char *format, ...);
// int getch(void);
// void __fastcall exit(int status);
// int heapchk(void);
// time_t __fastcall time(time_t *timer);
// int rand(void);
// void __fastcall srand(unsigned int seed);
// int __fastcall access(const char *path, int mode);
// char *__fastcall fgets(char *s, int n, FILE *fp);
// int __fastcall _wcpp_2_mod_register_(_DWORD); weak
// int fprintf(FILE *fp, const char *format, ...);
// int __fastcall vsprintf(char *s, const char *format, __va_list arg);
// void *__fastcall malloc(size_t size);
// void *__fastcall calloc(size_t n, size_t size);
// void __fastcall free(void *ptr);
// int __fastcall strnicmp(const char *s1, const char *s2, size_t n);
// int __fastcall atoi(const char *nptr);
// char *__fastcall strdup(const char *string);
// void __fastcall delay(unsigned int milliseconds);
// unsigned int __fastcall dos_getftime(int handle, unsigned __int16 *date, unsigned __int16 *time);
// int __fastcall strncmp(const char *s1, const char *s2, size_t n);
// double __fastcall pow(double x, double y);
// _DWORD __stdcall _wcpp_2_assign_array_(_DWORD); weak
// int __fastcall _wcpp_2_copy_array_(_DWORD, _DWORD, _DWORD, _DWORD); weak
// double __fastcall acos(double x);
// void *__fastcall operator new(size_t size);
// char *__fastcall strupr(char *string);
// int __fastcall heapwalk(struct _heapinfo *entry);
// void *__fastcall memmove(void *s1, const void *s2, size_t n);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_18241; // weak
_UNKNOWN loc_18247; // weak
_UNKNOWN loc_18253; // weak
_UNKNOWN loc_1825F; // weak
_UNKNOWN loc_1829D; // weak
_UNKNOWN loc_18696; // weak
_UNKNOWN locret_1B66C; // weak
_UNKNOWN loc_21D46; // weak
_UNKNOWN loc_21D90; // weak
_UNKNOWN loc_21D96; // weak
_UNKNOWN loc_21DB2; // weak
_UNKNOWN loc_24D98; // weak
_UNKNOWN loc_24D9B; // weak
_UNKNOWN loc_24D9E; // weak
_UNKNOWN loc_24DA4; // weak
_UNKNOWN loc_24DAA; // weak
_UNKNOWN loc_24DAD; // weak
_UNKNOWN loc_27100; // weak
_UNKNOWN loc_27281; // weak
_UNKNOWN loc_272D8; // weak
_UNKNOWN loc_27C93; // weak
_UNKNOWN loc_3067E; // weak
_UNKNOWN loc_306F3; // weak
_UNKNOWN loc_306F7; // weak
_UNKNOWN loc_306F9; // weak
char byte_30700[] = { '\xE8' }; // weak
void *off_30701 = &loc_46F35; // weak
_UNKNOWN loc_32C48; // weak
_UNKNOWN loc_32DCD; // weak
_UNKNOWN loc_32DD2; // weak
_UNKNOWN loc_32DD4; // weak
char byte_32DDA[] = { '\x8B' }; // weak
char byte_32DDB[] = { '5' }; // weak
_UNKNOWN loc_493DC; // weak
double dbl_9017F = 0.0000152587890625; // weak
double dbl_901BB = 0.3333333333333333; // weak
float flt_901C3 = 0.015625; // weak
float flt_901C7 = 20.0; // weak
float flt_901E5 = 1280.0; // weak
double dbl_9022A = -20.0; // weak
double dbl_90232 = 0.05; // weak
double dbl_9023A = 20.0; // weak
double dbl_90242 = 0.0000152587890625; // weak
float flt_9024A = 0.050000001; // weak
float flt_9026C = -0.039999999; // weak
double dbl_90270 = 0.2; // weak
float flt_90278 = 0.039999999; // weak
float flt_9027C = 2.0; // weak
float flt_90280 = 32.0; // weak
float flt_902A0 = 96.0; // weak
double dbl_902A4 = 3.2; // weak
double dbl_902C8 = 3.2; // weak
float flt_90308 = 0.050000001; // weak
double dbl_9030C = 3.2; // weak
float flt_90314 = 50.0; // weak
float flt_90334 = 0.2; // weak
float flt_90338 = 0.03125; // weak
float flt_9033C = 32.0; // weak
float flt_9034E = -0.039999999; // weak
double dbl_90352 = 0.04; // weak
float flt_903A5 = 0.000015258789; // weak
float flt_903A9 = 0.000015258789; // weak
float flt_903AD = 2.5; // weak
double dbl_903B1 = 0.5; // weak
float flt_903B9 = 2.0; // weak
float flt_90432 = 10.0; // weak
double dbl_90436 = 1.25; // weak
double dbl_9043E = 0.1; // weak
double dbl_90446 = 0.8; // weak
float flt_9045D = 0.00125; // weak
float flt_90461 = 0.0020000001; // weak
float flt_90465 = 0.00125; // weak
float flt_9049E = 0.5; // weak
float flt_904A2 = 16384.0; // weak
float flt_904A6 = 0.125; // weak
float flt_904AA = -1.0; // weak
float flt_904AE = 131072.0; // weak
float flt_904C1 = 0.5; // weak
float flt_904C5 = 0.33333334; // weak
float flt_904C9 = 0.5; // weak
float flt_904CD = 2.0; // weak
float flt_904E0 = 50.0; // weak
float flt_904E4 = -50.0; // weak
float flt_904E8 = 0.0099999998; // weak
float flt_905FA = 32.0; // weak
float flt_90646 = 0.5; // weak
float flt_9064A = 0.03125; // weak
float flt_9064E = 0.0062500001; // weak
float flt_90652 = 960.0; // weak
float flt_90656 = 0.125; // weak
float flt_9065A = -32.0; // weak
float flt_9066D = -440.0; // weak
float flt_907F4 = 0.5; // weak
float flt_90A84 = 0.0011363636; // weak
float flt_90A88 = 1000.0; // weak
float flt_90A8C = 2000.0; // weak
float flt_90AF2 = -200.0; // weak
float flt_90B90 = 4.0; // weak
float flt_90B94 = 0.0099999998; // weak
float flt_90BC8 = -75.0; // weak
float flt_90BCC = 50.0; // weak
float flt_90C86 = 2000.0; // weak
float flt_90C8A = 0.011111111; // weak
double dbl_90D6E = 1.5; // weak
double dbl_90D76 = 1.25; // weak
float flt_9103C = 20.0; // weak
float flt_91040 = 60.0; // weak
float flt_91060 = 0.5; // weak
float flt_910EA = -1500.0; // weak
double dbl_91DB5 = 1.3; // weak
double dbl_91DD9 = 4000000.0; // weak
double dbl_91E43 = 0.95; // weak
float flt_91E91 = -3200.0; // weak
float flt_91E95 = 1280.0; // weak
_UNKNOWN unk_920AA; // weak
float flt_920F0 = 0.050000001; // weak
double dbl_920F4 = 0.6666666666666666; // weak
double dbl_92150 = 6.28318530716; // weak
float flt_92158 = 0.5; // weak
float flt_9215C = 2.0; // weak
float flt_92160 = -0.5; // weak
float flt_92164 = -2.0; // weak
float flt_92168 = -4.0; // weak
float flt_9216C = -6.0; // weak
double dbl_9232C = 1.2; // weak
float flt_92334 = 1440.0; // weak
float flt_92338 = 10000.0; // weak
float flt_9233C = 600.0; // weak
double dbl_9259A = 0.9; // weak
double dbl_925A2 = 2.0; // weak
double dbl_925AA = 0.9; // weak
double dbl_925B2 = 1.6; // weak
double dbl_925BA = 0.85; // weak
double dbl_925C2 = 1.7; // weak
float flt_92658 = 10.0; // weak
double dbl_9265C = 1.25; // weak
double dbl_92664 = 0.1; // weak
double dbl_9266C = 0.8; // weak
_UNKNOWN unk_92696; // weak
float flt_92697 = 0.25; // weak
float flt_9269B = 0.5; // weak
float flt_926DB = -1.0; // weak
double dbl_926EB = 10.0; // weak
double dbl_926F3 = 20.0; // weak
double dbl_9275B = 0.95; // weak
double dbl_92763 = 0.825; // weak
float flt_92777 = 0.0062500001; // weak
float flt_9277B = 32.0; // weak
float flt_9277F = 5.0; // weak
float flt_927BF = 0.33333334; // weak
float flt_927C3 = 2.0; // weak
float flt_927C7 = 0.1; // weak
float flt_927CB = 2.0; // weak
float flt_927E7 = 1600.0; // weak
float flt_928C7 = 2.0; // weak
double dbl_928CB = 0.75; // weak
float flt_928D3 = 64.0; // weak
float flt_928E6 = 2.0; // weak
double dbl_928EA = 0.75; // weak
float flt_92C3A = 0.33333334; // weak
float flt_92C3E = 2.0; // weak
_UNKNOWN unk_92C97; // weak
float flt_92D77 = -1500.0; // weak
double dbl_92DD4 = 0.5; // weak
_UNKNOWN unk_959A4; // weak
int (*off_959B8[5])() = { &sub_10A80, &sub_2CA78, &sub_10B24, &sub_11870, &sub_2CF28 }; // weak
_UNKNOWN unk_959D8; // weak
float flt_959F4 = 0.017453292; // weak
_UNKNOWN unk_95A28; // weak
_UNKNOWN unk_95A3C; // weak
int (*off_95A50[6])() = { &sub_1604C, &sub_2CA78, &sub_16348, &sub_18CA8, &sub_2CF28, &sub_19E2C }; // weak
float flt_95A68 = 0.017453292; // weak
_UNKNOWN unk_95A8C; // weak
_UNKNOWN unk_95AA0; // weak
_UNKNOWN unk_95AB4; // weak
_UNKNOWN unk_95AC8; // weak
_UNKNOWN unk_95ADC; // weak
_UNKNOWN unk_95AF0; // weak
_UNKNOWN unk_95B04; // weak
_UNKNOWN unk_95B34; // weak
_UNKNOWN unk_95B48; // weak
_UNKNOWN unk_95B70; // weak
int (*off_95B84[5])() = { &sub_25CD4, &sub_2CA78, &sub_26000, &sub_25D18, &sub_25FB4 }; // weak
int (*off_95B9C[5])() = { &sub_25C08, &sub_2CA78, &sub_2F424, &sub_25C4C, &sub_2CF28 }; // weak
int (*off_95BB4[2])() = { &sub_22588, &sub_2CA78 }; // weak
_UNKNOWN unk_95C04; // weak
_UNKNOWN unk_95C18; // weak
_UNKNOWN unk_95C2C; // weak
int (*off_95C40[5])() = { &sub_27C08, &sub_2CA78, &sub_27C50, &sub_27D18, &sub_2CF28 }; // weak
int (*off_95C58[5])() = { &sub_2713C, &sub_2CA78, &sub_27184, &sub_271FC, &sub_2CF28 }; // weak
int (*off_95C70[5])() = { &sub_267BC, &sub_2CA78, &sub_270F4, &sub_27124, &sub_2CF28 }; // weak
_UNKNOWN unk_95CA0; // weak
int (*off_95CB4[3])() = { &sub_2AEB0, &sub_2CA78, &sub_2AFF0 }; // weak
_UNKNOWN unk_95D04; // weak
_UNKNOWN unk_95D18; // weak
_UNKNOWN unk_95D2C; // weak
_UNKNOWN unk_95D40; // weak
_UNKNOWN unk_95D54; // weak
_UNKNOWN unk_95D68; // weak
_UNKNOWN unk_95D7C; // weak
int (*off_95D90[5])() = { &sub_2FA34, &sub_2CA78, &sub_2F420, &sub_2FA98, &sub_2CF28 }; // weak
int (*off_95DA8[4])() = { &sub_2F4A8, &sub_2CA78, &sub_2F6B0, &sub_2F540 }; // weak
int (*off_95DC0[5])() = { &sub_2F30C, &sub_2CA78, &sub_2F478, &sub_2F354, &sub_2F414 }; // weak
int (*off_95DD8[5])() = { &sub_2E264, &sub_2CA78, &sub_2E3D4, &sub_2E6C0, &sub_2CF28 }; // weak
int (*off_95DF0[5])() = { &sub_2D9FC, &sub_2DB54, &sub_2DE68, &sub_2E084, &sub_2CF28 }; // weak
int (*off_95E08[5])() = { &sub_2D480, &sub_2CA78, &sub_2D4D0, &sub_2D528, &sub_2D79C }; // weak
int (*off_95E20[5])() = { &sub_2C848, &sub_2CA78, &sub_2F424, &sub_2CD24, &sub_2CF28 }; // weak
_UNKNOWN unk_95E40; // weak
int (*off_95E54[5])() = { &sub_2FC68, &sub_2CA78, &sub_2FD68, &sub_30774, &sub_2CF28 }; // weak
_UNKNOWN unk_95E74; // weak
int (*off_95E88[5])() = { &sub_3121C, &sub_2CA78, &sub_31268, &sub_3160C, &sub_2CF28 }; // weak
_UNKNOWN unk_95EB0; // weak
_UNKNOWN unk_95EC4; // weak
_UNKNOWN unk_95ED8; // weak
int (*off_95EEC[5])() = { &sub_33840, &sub_2CA78, &sub_338DC, &sub_33A68, &sub_2CF28 }; // weak
int (*off_95F04[5])() = { &sub_335B4, &sub_2CA78, &sub_33604, &sub_33674, &sub_2CF28 }; // weak
int (*off_95F1C[5])() = { &sub_32038, &sub_2CA78, &sub_320B8, &sub_32414, &sub_2CF28 }; // weak
_UNKNOWN unk_95F44; // weak
_UNKNOWN unk_95F58; // weak
int (*off_95F6C[5])() = { &sub_395FC, &sub_2CA78, &sub_39644, &sub_396F0, &sub_2CF28 }; // weak
int (*off_95F84[5])() = { &sub_372CC, &sub_2CA78, &sub_37568, &sub_384B0, &sub_2CF28 }; // weak
_UNKNOWN unk_95FA4; // weak
int (*off_95FB8[5])() = { &sub_39D9C, &sub_2CA78, &sub_39E3C, &sub_3A6BC, &sub_2CF28 }; // weak
_UNKNOWN unk_96004; // weak
int (*off_96018[5])() = { &sub_46C48, &sub_2CA78, &sub_47224, &sub_47ABC, &sub_2CF28 }; // weak
_UNKNOWN unk_96038; // weak
_UNKNOWN unk_96068; // weak
int (*off_9607C[5])() = { &sub_4DA08, &sub_2CA78, &sub_4DDB0, &sub_4E758, &sub_2CF28 }; // weak
_UNKNOWN unk_960BC; // weak
_UNKNOWN unk_960D0; // weak
_UNKNOWN unk_960E4; // weak
int (*off_960F8[5])() = { &sub_52108, &sub_2CA78, &sub_5294C, &sub_521C0, &sub_2CF28 }; // weak
int (*off_96110[5])() = { &sub_51B80, &sub_2CA78, &sub_51D24, &sub_51BC4, &sub_2CF28 }; // weak
int (*off_96128[5])() = { &sub_51690, &sub_2CA78, &sub_51894, &sub_516E0, &sub_2CF28 }; // weak
float flt_96140 = 0.017453292; // weak
float flt_96144 = 57.29578; // weak
_UNKNOWN unk_9615C; // weak
_UNKNOWN unk_96184; // weak
_UNKNOWN unk_96198; // weak
int (*off_961AC[5])() = { &sub_5A5AC, &sub_2CA78, &sub_5A60C, &sub_5AA08, &sub_2CF28 }; // weak
int (*off_961C4[5])() = { &sub_5B2B0, &sub_2CA78, &sub_2F424, &sub_1240C, &sub_2FC3C }; // weak
int (*off_961DC[5])() = { &sub_5B300, &sub_2CA78, &sub_2F424, &sub_2FBA4, &sub_2FC3C }; // weak
char aDataRacea03Haz[17] = "DATA\\RACEA03.HAZ"; // weak
_UNKNOWN unk_964E4; // weak
int dword_964EC = 0; // weak
__int16 word_964F0[] = { 10 }; // weak
__int16 word_964FA[12] = { 30, 30, 30, 30, 20, 20, 20, 20, 20, 20, 15, 15 }; // weak
void *off_96512 = &unk_10000F; // weak
_UNKNOWN unk_9652C; // weak
__int16 word_9652E[] = { 6 }; // weak
_UNKNOWN unk_96548; // weak
_UNKNOWN unk_9659C; // weak
char aCosdip[7] = "cosdip"; // weak
_UNKNOWN unk_965F8; // weak
int dword_965FD = -33549042; // weak
_DWORD dword_96654[5] = { 0, 0, 0, 0, 0 }; // weak
char s[] = "Thank you for playing Ascendancy."; // idb
_UNKNOWN unk_96768; // weak
int dword_96770 = 0; // weak
int dword_96774 = -1; // weak
char byte_96778 = '\xF3'; // weak
char byte_96779[7] = { '\x13', '\x17', '\x1B', '\x1F', '#', '\'', '+' }; // weak
_UNKNOWN unk_96780; // weak
int dword_96788 = 0; // weak
_UNKNOWN unk_9678C; // weak
_UNKNOWN unk_967BE; // weak
_UNKNOWN unk_967F0; // weak
__int16 word_9682E[5] = { 207, 297, 252, 207, 297 }; // weak
__int16 word_96838[4] = { 358, 358, 403, 442 }; // weak
int dword_96840 = -65094; // weak
int dword_9684C = 100; // weak
char *off_96850[5] = { "PLRES", "PLIND", "PLPRO", "PLPOP", "PLBUILD" }; // weak
_DWORD dword_96864[2] = { 50397184, 33686273 }; // weak
_UNKNOWN unk_9686C; // weak
_UNKNOWN unk_968A8; // weak
char byte_968DC = '\x01'; // weak
char byte_968DD = '\xFF'; // weak
__int16 word_968E8[21] =
{
  0,
  0,
  0,
  0,
  0,
  60,
  100,
  62,
  77,
  90,
  150,
  140,
  63,
  66,
  72,
  0,
  92,
  100,
  0,
  89,
  68
}; // weak
_UNKNOWN unk_96912; // weak
_UNKNOWN unk_96918; // weak
_UNKNOWN unk_9691E; // weak
_UNKNOWN unk_9696C; // weak
_UNKNOWN unk_96994; // weak
void *off_9699E = (void *)0x50000; // weak
char byte_969A8[] = { '\0' }; // weak
char byte_969B8[16] =
{
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x03',
  '\x01',
  '\0',
  '\0'
}; // weak
char byte_969C8[16] =
{
  '\x03',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\x0F',
  '\x1F',
  '\x1F',
  '\x1F',
  '\x1F',
  '\a',
  '\x01',
  '\0',
  '\0'
}; // weak
_DWORD dword_969D8[4] = { 70, 170, 240, 410 }; // weak
_UNKNOWN unk_96AC0; // weak
int dword_96AC8 = 0; // weak
int dword_96ACC = -1; // weak
int dword_96AD0 = -1; // weak
_UNKNOWN unk_96AD4; // weak
_UNKNOWN unk_96B08; // weak
int dword_96B10 = 0; // weak
__int16 word_96B2A = -1; // weak
__int16 word_96B2C = -1; // weak
_UNKNOWN unk_96B30; // weak
__int16 word_96B6C = 6166; // weak
__int16 word_96B6E = -1; // weak
__int16 word_96B70 = -1; // weak
__int16 word_96B72 = -1; // weak
_DWORD dword_96B74[5] = { 15, 25, 50, 75, 100 }; // weak
int dword_96B88 = 5; // weak
_UNKNOWN unk_96B8C; // weak
int dword_96B94 = 0; // weak
int dword_96BAC = -1; // weak
__int16 word_96BB0 = -1; // weak
int dword_96BB4 = -1; // weak
int dword_96BB8 = -1; // weak
int dword_96BBC = 1065353216; // weak
int dword_96BC0 = -1; // weak
__int16 word_96BC4[8] = { 243, 19, 27, 31, 23, 39, 35, 15 }; // weak
VFX_DESC *(__cdecl *VFX_describe_driver)() = NULL;
void (__cdecl *VFX_init_driver)() = NULL;
void (__cdecl *VFX_shutdown_driver)() = NULL;
void (__cdecl *VFX_area_wipe)(LONG x0, LONG y0, LONG x1, LONG y1, LONG color) = NULL;
void (__cdecl *VFX_wait_vblank_leading)() = NULL;
void (__cdecl *VFX_window_read)(WINDOW *destination, LONG x0, LONG y0, LONG x1, LONG y1) = NULL;
void (__cdecl *VFX_DAC_read)(LONG color_number, RGB *triplet) = NULL;
void (__cdecl *VFX_DAC_write)(LONG color_number, RGB *triplet) = NULL;
void (__cdecl *VFX_pane_refresh)(PANE *target, LONG x0, LONG y0, LONG x1, LONG y1) = NULL;
void (__cdecl *VFX_line_address)(LONG x, LONG y, UBYTE **addr, ULONG *nbytes) = NULL;
void (__fastcall *MEM_free)(void *ptr) = &free;
int dword_9A234 = 0; // weak
int dword_9A238 = 0; // weak
_UNKNOWN unk_9A23C; // weak
int dword_9A240 = 0; // weak
int dword_9A244 = 0; // weak
int dword_9A248 = 0; // weak
int dword_9A24C = 0; // weak
int V_CobCfgLoaded_dword_9A250 = 0; // weak
T_CobFilesIndex V_CobFilesIndex_stru_9A254 =
{
  {
    {
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0'
    },
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    {  }
  }
};
int dword_A0CF8; // weak
int dword_A0CFC; // weak
int dword_A0D00; // weak
T_StaticStrings V_StaticStrings_dword_A0D04;
int dword_A2F6C[]; // weak
char byte_A2F72[]; // weak
int byte_A2F73; // idb
char byte_A2F74[]; // weak
int dword_A2F75; // weak
int dword_A2F79; // weak
char byte_A310F[]; // weak
_UNKNOWN unk_A3122; // weak
__int16 word_A3124[5]; // weak
_UNKNOWN unk_A312F; // weak
char byte_A3132[9]; // weak
int dword_A313B; // weak
_UNKNOWN unk_A3141; // weak
__int16 word_A3143[]; // weak
__int16 word_A3147[]; // weak
char byte_A315B[]; // weak
int dword_A315C; // weak
int dword_A3CF2; // weak
__int16 word_A3CF6[]; // weak
int dword_A3CF8; // weak
char byte_A3D20; // weak
__int16 word_A3D21[]; // weak
int dword_A3D67[]; // weak
__int16 word_A3D7B[]; // weak
__int16 word_A62A1; // weak
_UNKNOWN unk_A62A3; // weak
__int16 word_A792F; // weak
_UNKNOWN unk_BB1B3; // weak
char byte_BB20A[61411]; // weak
int dword_CA1ED; // weak
_UNKNOWN unk_CA1F1; // weak
int dword_CA245; // weak
int dword_CA24A; // weak
int dword_D35E5; // weak
char byte_D35E9[117]; // weak
__int16 word_D365E; // weak
int dword_D3660; // weak
int dword_D3664; // idb
int dword_D3668; // weak
char byte_D366C; // weak
char byte_D5D47[10000]; // weak
int dword_D8457; // weak
__int16 word_D845C; // weak
char byte_D8460[100]; // weak
char byte_D84C4[258]; // weak
int dword_D85C6[]; // weak
_UNKNOWN unk_D85E4; // weak
int dword_D85E8; // weak
int dword_D85EC; // weak
_UNKNOWN unk_D85F8; // weak
int dword_D85FC; // weak
int dword_D8600; // weak
int dword_D8604; // weak
int a3; // idb
int dword_D860C; // weak
int dword_D8610; // weak
int dword_D8614; // weak
int dword_D8618; // weak
__int16 word_D8620; // weak
int dword_D8622; // weak
int dword_D8628; // weak
int dword_D862C; // weak
int dword_D8630; // weak
int dword_D8638; // weak
int dword_D863C; // weak
int dword_D8644; // weak
LONG new_x; // idb
LONG dword_D864C; // idb
int dword_D8650; // weak
T_Type6 V_Type6_stru_D8654;
int dword_D8D8F; // weak
UBYTE buffer[94816]; // weak
_UNKNOWN unk_F4240; // weak
__int16 word_FFE9E[]; // weak
__int16 word_FFEA0[7]; // weak
__int16 word_FFEAE[7]; // weak
__int16 word_FFEBC[7]; // weak
__int16 word_FFECA[7]; // weak
__int16 word_FFED8; // weak
__int16 word_FFEDA; // weak
__int16 word_FFEDC; // weak
__int16 word_FFEDE; // weak
__int16 word_FFEE0; // weak
__int16 word_FFEE2; // weak
__int16 word_FFEE6; // weak
__int16 word_FFEE8; // weak
__int16 word_FFEEA; // weak
__int16 word_FFEEC; // weak
__int16 word_FFEEE; // weak
__int16 word_FFEF0; // weak
__int16 word_FFEF2; // weak
__int16 word_FFEF4; // weak
__int16 word_FFEF6; // weak
__int16 word_FFEF8; // weak
_UNKNOWN unk_FFF04; // weak
int dword_100302; // weak
int dword_100308; // weak
WINDOW V_Window1; // idb
void *buf; // idb
int dword_100324; // weak
int dword_100328; // weak
void *dword_10032C; // idb
__int16 word_100330; // weak
__int16 word_100332; // weak
char byte_100334; // weak
char byte_100335; // weak
int dword_100338; // weak
int dword_10033C; // weak
_UNKNOWN unk_100340; // weak
__int16 word_100350; // weak
_UNKNOWN unk_100744; // weak
_UNKNOWN unk_100EC4; // weak
char byte_101DC4[16]; // weak
_UNKNOWN unk_101DD4; // weak
_UNKNOWN unk_102554; // weak
__int16 word_103F94; // weak
__int16 word_103F98[]; // weak
int dword_103F9A[]; // weak
char byte_103F9E[]; // weak
char byte_103F9F[]; // weak
char byte_103FA0[]; // weak
char byte_103FA1[]; // weak
__int16 word_103FA2[]; // weak
__int16 word_103FA4[]; // weak
char byte_103FA6[755]; // weak
char byte_104299; // weak
char byte_104311; // weak
char byte_104338; // weak
char byte_1043B1; // weak
char byte_1043D9; // weak
char byte_104401; // weak
char byte_104429; // weak
char byte_104451; // weak
int dword_104515; // weak
char byte_104541; // weak
int dword_1045B4; // weak
char byte_1045B8[68]; // weak
int dword_1045FC[]; // weak
char byte_104603[]; // weak
char byte_104604[75]; // weak
char byte_10464F[]; // weak
_UNKNOWN unk_104650; // weak
int dword_10467C; // weak
char *dword_104680; // idb
int dword_104684[]; // weak
int dword_104688[4]; // weak
int dword_104698[]; // weak
int dword_10469C[10]; // weak
int dword_1046C4[]; // weak
int dword_1046E8[100]; // weak
int dword_104878[100]; // weak
int dword_104A08[100]; // weak
int dword_104B98[]; // weak
int dword_104BC0[9]; // weak
__int16 word_104BE8; // weak
int byte_104BEA; // idb
int dword_104BEC[100]; // weak
int dword_104D7C[99]; // weak
int dword_104F09; // weak
int dword_104F6D; // weak
int dword_104FD1; // weak
int dword_105035; // weak
int dword_10509C; // weak
int dword_1050A0; // weak
char byte_1050A4[420]; // weak
int dword_105248; // weak
int dword_10524C; // weak
int dword_105250; // weak
int dword_105254; // weak
size_t word_105258; // idb
char byte_10525A[60]; // weak
__int16 word_105296; // weak
char byte_105298[7]; // weak
int dword_10529F; // weak
char byte_1052A3[71]; // weak
int dword_1052EA; // weak
int dword_105416; // weak
int dword_105830; // weak
int dword_105BB4; // weak
__int16 word_106FA6[7]; // weak
__int16 word_106FB4[7]; // weak
int dword_106FC2; // weak
int dword_106FCC; // weak
int dword_106FD0; // weak
int dword_106FD4; // weak
int dword_106FD8; // weak
int dword_106FDC; // weak
char byte_106FE0[56]; // weak
__int16 word_107018; // weak
int dword_10701C; // weak
_UNKNOWN unk_107020; // weak
char byte_107052[]; // weak
__int16 word_107053[]; // weak
char byte_107055[5]; // weak
int dword_10705A; // weak
int dword_10705E; // weak
int dword_107062; // weak
int dword_107066; // weak
int dword_10706A; // weak
int dword_10706E; // weak
int dword_107072; // weak
int dword_107082; // weak
char byte_107F3D; // weak
int dword_1085F2; // weak
int dword_108A80; // weak
int dword_108C28; // weak
_UNKNOWN unk_108F98; // weak
int dword_108FE8; // weak
int dword_108FEC; // weak
int dword_108FF0; // weak
int dword_108FF4; // weak
int dword_108FF8; // weak
int dword_108FFC; // weak
int dword_109000; // weak
int dword_109004; // weak
int dword_109008; // weak
int dword_10900C; // weak
int dword_109010; // weak
int dword_109014; // weak
int dword_109018; // weak
_UNKNOWN unk_10901C; // weak
int dword_10903A; // weak
__int16 word_10903E; // weak
char byte_109040; // weak
int dword_109041; // weak
char byte_109045; // weak
int dword_109046; // weak
char byte_10904A; // weak
int dword_10904B; // weak
char byte_10904F; // weak
int dword_109050; // weak
float flt_109054; // weak
int dword_109058; // weak
float flt_10905C; // weak
float flt_109060; // weak
int dword_109064; // weak
float flt_109068; // weak
int dword_10906C; // weak
int dword_109070; // weak
int dword_109074; // weak
int dword_109078; // weak
int dword_10907C; // weak
int dword_109080; // weak
__int16 word_109084; // weak
float flt_109086; // weak
int dword_10908A; // weak
float flt_10908E; // weak
char byte_109092; // weak
int dword_109142; // weak
int dword_109146; // weak
_UNKNOWN unk_10914C; // weak
int dword_109357; // weak
int dword_10935F; // weak
int dword_10936F; // weak
int dword_109373; // weak
int dword_109377; // weak
_UNKNOWN unk_1094C6; // weak
int dword_1094DE[218]; // weak
__int16 word_109846; // weak
_UNKNOWN unk_109DF8; // weak
int dword_10AE60; // weak
int dword_10AE64; // weak
int dword_10AE68; // weak
int dword_10AE6C; // weak
T_Type3 V_Type3_stru_10AE70;
int dword_12FC10; // weak
int dword_12FC14; // weak
float flt_12FC1C; // weak
_DWORD dword_12FC20[248]; // weak
int dword_132B04; // idb
int dword_132B08; // idb
int dword_132B10; // weak
int dword_132B14; // weak
int dword_132B18; // weak
int dword_132B1C; // weak
char byte_132B20[20]; // weak
int dword_132B34; // weak
char byte_132B38[32]; // weak
int V_Timer_dword_132B58; // weak
int dword_132B5C; // weak
int dword_132B60; // weak
int dword_132B64; // weak


//----- (00010000) --------------------------------------------------------
void __noreturn sub_10000()
{
  while ( 1 )
  {
    __debugbreak();
  }
}
// 10000: using guessed type void __noreturn sub_10000();

//----- (00010010) --------------------------------------------------------
void *__fastcall sub_10010(T_Type5 *a1, int a2, int a3, int a4)
{
  void *v5; // eax
  void *v6; // ebp
  LONG v7; // edi
  int v8; // ecx
  const char *v9; // ecx
  LONG *p_x0; // esi
  void *result; // eax
  unsigned __int16 v12; // dx
  void *v13; // esi
  int v14; // eax
  PANE *v15; // esi
  const char *v16; // ecx
  void *v17; // ebp
  int v18; // ecx
  int v19; // esi
  int v20; // edi
  int v21; // eax
  int v22; // esi
  int v23; // edi
  int v24; // esi
  LONG v25; // edi
  __int16 v26; // si
  int v27; // edx
  int v28; // ebx
  __int16 v29; // [esp-Ch] [ebp-98h]
  LONG v30; // [esp-8h] [ebp-94h]
  LONG v31; // [esp-4h] [ebp-90h]
  PANE v32; // [esp+0h] [ebp-8Ch] BYREF
  int v33[5]; // [esp+14h] [ebp-78h]
  int v34[2]; // [esp+28h] [ebp-64h]
  LONG v35[2]; // [esp+30h] [ebp-5Ch]
  int v36[2]; // [esp+38h] [ebp-54h]
  LONG hotX; // [esp+40h] [ebp-4Ch] BYREF
  LONG hotY; // [esp+44h] [ebp-48h] BYREF
  int v39; // [esp+48h] [ebp-44h]
  int v40; // [esp+4Ch] [ebp-40h]
  int v41; // [esp+50h] [ebp-3Ch]
  int v42; // [esp+54h] [ebp-38h]
  int v43; // [esp+58h] [ebp-34h]
  int v44; // [esp+5Ch] [ebp-30h]
  int v45; // [esp+60h] [ebp-2Ch]
  unsigned int v46; // [esp+64h] [ebp-28h]
  int v47; // [esp+68h] [ebp-24h]
  unsigned int v48; // [esp+6Ch] [ebp-20h]
  LONG shape_number; // [esp+70h] [ebp-1Ch]
  LONG v50; // [esp+74h] [ebp-18h]
  PANE *pane; // [esp+78h] [ebp-14h]
  unsigned int v52; // [esp+7Ch] [ebp-10h]

  pane = (PANE *)a1;
  v43 = 0;
  if ( a4 )
  {
    VFX_pane_wipe((PANE *)a1, 0x96);
    v43 = 0x96;
  }
  if ( a3 < 0 )
  {
    v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDA);
    v6 = v5;
    if ( !v5 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x46);
    }
    v7 = 5 * *(unsigned __int16 *)(a2 + 0x16) + *(unsigned __int16 *)(a2 + 0x14);
    sub_2BC40(pane, v5, v7, &hotX, &hotY);
    v39 = a2;
    VFX_shape_draw(pane, v6, v7, hotX, hotY);
    v8 = *(unsigned __int8 *)(a2 + 0x57);
    v40 = 0xF3;
    if ( v8 != 0xFF )
    {
      sub_53E38((P_Type5)pane, 2, 4, v8);
      v40 = 4 * (unsigned __int8)byte_A2F74[0x1EE * *(unsigned __int8 *)(a2 + 0x57)] + 0x13;
    }
    v29 = v40;
    v9 = (const char *)(v39 + 0x24);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = pane->window;
    p_x0 = &pane->x0;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = pane->x0;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = *++p_x0;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = *++p_x0;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = p_x0[1];
    return (void *)sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x12, 7, v9, 0, v29, 0xFF, 0);
  }
  v12 = word_FFEBC[*(__int16 *)(a2 + 0x56)];
  v44 = a2;
  v13 = (void *)sub_1B084((unsigned int)dword_12FC20, v12);
  if ( !v13 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x5C);
  }
  v14 = *(__int16 *)(v44 + 0x56);
  v41 = 0;
  if ( v14 == (unsigned __int8)byte_104BEA || sub_4AAEC(v44, (unsigned __int8)byte_104BEA) > 0 )
  {
    v41 = 0xFFFFFFFF;
  }
  sub_2BC40(pane, v13, *(char *)(v44 + 0xAA), &hotX, &hotY);
  if ( v41 != 0xFFFFFFFF )
  {
    goto LABEL_25;
  }
  if ( *(int *)(v44 + 0x88) > 0 )
  {
    if ( 4 * *(_DWORD *)(v44 + 0x8C) < *(_DWORD *)(v44 + 0x98) || *(int *)(v44 + 0x8C) < 5 )
    {
      VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x800));
      VFX_shape_translate_draw(pane, v13, *(char *)(v44 + 0xAA), hotX, hotY);
      goto LABEL_26;
    }
    if ( !*((_BYTE *)&byte_A2F73 + 0x1EE * *(__int16 *)(v44 + 0x56)) )
    {
      VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x300));
      VFX_shape_translate_draw(pane, v13, *(char *)(v44 + 0xAA), hotX, hotY);
      goto LABEL_26;
    }
    if ( *((_BYTE *)&byte_A2F73 + 0x1EE * *(__int16 *)(v44 + 0x56)) != 0xD )
    {
      VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x600));
      VFX_shape_translate_draw(pane, v13, *(char *)(v44 + 0xAA), hotX, hotY);
      goto LABEL_26;
    }
LABEL_25:
    VFX_shape_draw(pane, v13, *(char *)(v44 + 0xAA), hotX, hotY);
    goto LABEL_26;
  }
  VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x1600));
  VFX_shape_translate_draw(pane, v13, *(char *)(v44 + 0xAA), hotX, hotY);
LABEL_26:
  v15 = pane;
  sub_53E38((P_Type5)pane, 2, 4, *(_WORD *)(v44 + 0x56));
  v16 = (const char *)(v44 + 0x34);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v15->window;
  v15 = (PANE *)((char *)v15 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v15->window;
  v15 = (PANE *)((char *)v15 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = v15->window;
  v15 = (PANE *)((char *)v15 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = v15->window;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v15->x0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x12, 7, v16, 0, 0xF, 0xFF, 0);
  result = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE6);
  v17 = result;
  if ( !result )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0xA4);
  }
  if ( v41 == 0xFFFFFFFF )
  {
    v20 = 0x12;
    v19 = 0;
    v42 = sub_4A8CC(v44);
    do
    {
      if ( v19 >= v42 )
      {
        break;
      }
      v18 = v20;
      ++v19;
      v20 += 5;
      sub_53EB8((P_Type5)pane, (int)v17, 0, v18, 0x11, *(_WORD *)(v44 + 0x56));
    }
    while ( v19 < 0xA );
    v33[0] = *(_DWORD *)v44;
    v33[1] = *(_DWORD *)(v44 + 4);
    v33[2] = *(_DWORD *)(v44 + 0x10);
    v33[3] = *(_DWORD *)(v44 + 0x20);
    v50 = 0x1F;
    v21 = *(_DWORD *)(v44 + 0x18);
    v47 = 0;
    v33[4] = v21;
    v46 = 0;
    v32 = *pane;
    do
    {
      v32.x1 = v32.x0 + 1;
      v22 = v33[v46 / 4];
      v23 = 2;
      if ( v22 > 0 )
      {
        v32.x1 += (8 * v22 - (__CFSHL__((8 * v22) >> 0x1F, 2) + 4 * ((8 * v22) >> 0x1F))) >> 2;
      }
      v24 = 0;
      shape_number = v47 + 1;
      do
      {
        v30 = v23;
        ++v24;
        v23 += 8;
        VFX_shape_draw(&v32, v17, shape_number, v30, v50);
      }
      while ( v24 < 0xF );
      v50 += 9;
      v46 += 4;
      ++v47;
    }
    while ( v47 < 5 );
    v34[0] = *(_DWORD *)(v44 + 0x8C);
    v34[1] = *(_DWORD *)(v44 + 0x88);
    v25 = 0x7C;
    v36[0] = *(_DWORD *)(v44 + 0x98);
    v48 = 0;
    v36[1] = sub_4A8FC(v44);
    v35[0] = 2;
    v35[1] = 5;
    v45 = 0x82;
    do
    {
      result = (void *)v48;
      v27 = v36[v48 / 4];
      if ( v27 > 0 )
      {
        v28 = v34[v48 / 4];
        if ( v28 >= 0 )
        {
          if ( v28 > v27 )
          {
            v34[v48 / 4] = v36[v48 / 4];
          }
          v26 = 0;
          v52 = v48;
        }
        else
        {
          v34[v48 / 4] = 0;
          v26 = 0;
          v52 = v48;
        }
        while ( v26 < 9 )
        {
          v31 = 8 * v26++ + 9;
          VFX_shape_draw(pane, v17, *(LONG *)((char *)v35 + v52), v25, v31);
        }
        result = (void *)sub_2BB74(
                           (int **)pane,
                           (int *)v25,
                           (int *)8,
                           (int *)v45,
                           (int *)(0x50 - 0x48 * *(int *)((char *)v34 + v52) / *(int *)((char *)v36 + v52)),
                           v43,
                           0xFFFFFFFF);
      }
      v25 += 8;
      v45 += 8;
      v48 += 4;
    }
    while ( v48 != 8 );
  }
  return result;
}
// D8D8F: using guessed type int dword_D8D8F;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDA: using guessed type __int16 word_FFEDA;
// FFEE6: using guessed type __int16 word_FFEE6;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00010668) --------------------------------------------------------
int __fastcall sub_10668(_DWORD *a1, char *a2, int a3, int a4)
{
  void *v5; // edi
  char *v6; // esi
  unsigned __int8 v7; // al
  int result; // eax
  int v9; // eax
  char *sub_1CEA8; // eax
  char s[80]; // [esp+0h] [ebp-6Ch] BYREF
  LONG hotY; // [esp+50h] [ebp-1Ch] BYREF
  LONG hotX; // [esp+54h] [ebp-18h] BYREF
  int v14; // [esp+58h] [ebp-14h]
  char *v15; // [esp+5Ch] [ebp-10h]

  v15 = a2;
  v14 = a3;
  v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFED8);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0xEA);
  }
  v6 = v15;
  if ( a4 && !v14 && (word_107053[0x35 * *v15] & 0x80) == 0 )
  {
    VFX_pane_wipe((PANE *)a1, 0x96);
  }
  if ( *v15 == (char)0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0xFB);
  }
  sub_2BC40(a1, v5, *v15, &hotX, &hotY);
  if ( v14 == 2 || v14 == 3 )
  {
    VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x700));
    VFX_shape_translate_draw((PANE *)a1, v5, *v6, hotX, hotY);
  }
  else
  {
    VFX_shape_draw((PANE *)a1, v5, *v6, hotX, hotY);
  }
  if ( *(_DWORD *)(v6 + 3) )
  {
    if ( (word_107053[0x35 * *v6] & 0x20) != 0 )
    {
      sub_2BB74(
        (int **)a1,
        (int *)1,
        (int *)1,
        (int *)(a1[3] - a1[1] - 1),
        (int *)(a1[4] - a1[2] - 1),
        4 * byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13,
        0);
    }
  }
  sprintf(s, "%s", (const char *)&unk_107020 + 0x6A * *v6);
  v7 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  result = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 2, s, 0, 4 * v7 + 0x13, 0xFF, 0);
  if ( v14 == 2 )
  {
    v9 = 0;
  }
  else
  {
    if ( v14 != 3 )
    {
      return result;
    }
    v9 = 1;
  }
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v9);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 0xC, sub_1CEA8, 0, 0xF, 0xFF, 0);
}
// D8D8F: using guessed type int dword_D8D8F;
// FFED8: using guessed type __int16 word_FFED8;
// 107053: using guessed type __int16 word_107053[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00010878) --------------------------------------------------------
int __fastcall sub_10878(_DWORD *a1, int a2, int a3, int a4)
{
  void *v5; // edi
  unsigned __int8 v6; // al
  int result; // eax
  __int16 v8; // dx
  char *sub_1CEA8; // eax
  char s[80]; // [esp+0h] [ebp-68h] BYREF
  LONG hotX; // [esp+50h] [ebp-18h] BYREF
  LONG hotY; // [esp+54h] [ebp-14h] BYREF
  int v13; // [esp+58h] [ebp-10h]

  v13 = a3;
  v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDC);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x122);
  }
  if ( a4 && !v13 )
  {
    VFX_pane_wipe((PANE *)a1, 0x96);
  }
  sub_2BC40(a1, v5, *(unsigned __int8 *)(a2 + 1), &hotX, &hotY);
  if ( v13 == 1 )
  {
    VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x700));
    VFX_shape_translate_draw((PANE *)a1, v5, *(unsigned __int8 *)(a2 + 1), hotX, hotY);
  }
  else
  {
    VFX_shape_draw((PANE *)a1, v5, *(unsigned __int8 *)(a2 + 1), hotX, hotY);
  }
  sprintf(s, "%s", (const char *)&dword_103F9A[0xA * *(unsigned __int8 *)(a2 + 1) + 3]);
  v6 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  result = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 2, s, 0, 4 * v6 + 0x13, 0xFF, 0);
  if ( v13 == 1 )
  {
    v8 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
    return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 5, 0xC, sub_1CEA8, 0, v8 + 0x13, 0xFF, 0);
  }
  return result;
}
// D8D8F: using guessed type int dword_D8D8F;
// FFEDC: using guessed type __int16 word_FFEDC;
// 103F9A: using guessed type int dword_103F9A[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00010A14) --------------------------------------------------------
int __fastcall sub_10A14(int a1, int a2)
{
  int v2; // ecx
  int v3; // esi
  int result; // eax

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  result = 0xFFFFFFFF;
  if ( v2 > v3 )
  {
    return 1;
  }
  if ( v2 == v3 )
  {
    return 0;
  }
  return result;
}

//----- (00010A3C) --------------------------------------------------------
void __fastcall __spoils<> sub_10A3C(P_TypeA8 a1)
{
  sub_2C830(&a1->a);
  a1->j2 = 0;
  a1->j3 = 0;
  a1->j4 = 0;
  a1->a.b = (int)off_959B8;
  sub_10AC4(a1);
}
// 959B8: using guessed type int (*off_959B8[5])();

//----- (00010A80) --------------------------------------------------------
void *__fastcall sub_10A80(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_959A4);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_959B8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 959B8: using guessed type int (*off_959B8[5])();

//----- (00010AC4) --------------------------------------------------------
void __fastcall __spoils<> sub_10AC4(P_TypeA8 result)
{
  result->b = 0;
  result->c = 0;
  result->d = 0;
  result->e = 0;
  result->f = 0;
  result->g = 0;
  result->i = 0;
}

//----- (00010B24) --------------------------------------------------------
int __fastcall sub_10B24(int a1, unsigned __int16 a2, int a3, int *a4)
{
  int result; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  __int16 i; // ax
  int v13; // edx
  int v14; // edx
  int v15; // eax
  char v16; // al
  unsigned __int8 v17; // al
  int v18; // ecx
  char v19; // bh
  int v20; // edx
  int **v21; // edi
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // ebx
  char v26; // al
  int v27; // eax
  int v28; // edx
  int v29; // eax
  int v30; // eax
  char *v31; // eax
  char *v32; // esi
  char *v33; // eax
  int v34; // edx
  int v35; // edx
  int v36; // eax
  int v37; // edx
  char *v38; // eax
  int v39; // ebx
  char v40; // cl
  int *v41; // ecx
  int v42; // [esp-4h] [ebp-9Ch]
  char v43; // [esp+0h] [ebp-98h] BYREF
  int v44; // [esp+1h] [ebp-97h]
  char v45; // [esp+5h] [ebp-93h]
  int *v46; // [esp+6h] [ebp-92h]
  int v47; // [esp+Ah] [ebp-8Eh]
  int v48; // [esp+Eh] [ebp-8Ah]
  int v49; // [esp+12h] [ebp-86h]
  int v50; // [esp+16h] [ebp-82h]
  int v51; // [esp+1Ah] [ebp-7Eh]
  int v52; // [esp+1Eh] [ebp-7Ah]
  int v53; // [esp+22h] [ebp-76h]
  char v54; // [esp+28h] [ebp-70h]
  int v55; // [esp+29h] [ebp-6Fh]
  char v56; // [esp+2Dh] [ebp-6Bh]
  int v57; // [esp+2Eh] [ebp-6Ah]
  int v58; // [esp+32h] [ebp-66h]
  int v59; // [esp+36h] [ebp-62h]
  int v60; // [esp+3Ah] [ebp-5Eh]
  int v61; // [esp+3Eh] [ebp-5Ah]
  int v62; // [esp+42h] [ebp-56h]
  int v63; // [esp+46h] [ebp-52h]
  int v64; // [esp+4Ah] [ebp-4Eh]
  char v65; // [esp+50h] [ebp-48h]
  int v66; // [esp+51h] [ebp-47h]
  char v67; // [esp+55h] [ebp-43h]
  int *v68; // [esp+56h] [ebp-42h]
  int v69; // [esp+5Ah] [ebp-3Eh]
  int v70; // [esp+5Eh] [ebp-3Ah]
  int v71; // [esp+62h] [ebp-36h]
  int v72; // [esp+66h] [ebp-32h]
  int v73; // [esp+6Ah] [ebp-2Eh]
  int v74; // [esp+6Eh] [ebp-2Ah]
  int v75; // [esp+72h] [ebp-26h]
  int *v76; // [esp+78h] [ebp-20h]
  int *v77; // [esp+7Ch] [ebp-1Ch]
  int *v78; // [esp+80h] [ebp-18h]
  int v79; // [esp+84h] [ebp-14h]
  char v80; // [esp+88h] [ebp-10h]

  v79 = a3;
  if ( a2 < 0x327u )
  {
    if ( a2 >= 0x322u )
    {
      if ( a2 > 0x322u )
      {
        if ( a2 < 0x325u )
        {
          if ( a2 != 0x324 )
          {
            return sub_2F424(a1, a2, v79, (int)a4);
          }
          if ( *(_BYTE *)(a1 + 0xB9) != 1 )
          {
            *(_BYTE *)(a1 + 0xB9) = 1;
            sub_12140(a1);
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
          }
          return 0xFFFFFFFF;
        }
        else if ( a2 <= 0x325u )
        {
          if ( *(_BYTE *)(a1 + 0xB9) != 4 )
          {
            *(_BYTE *)(a1 + 0xB9) = 4;
            sub_12140(a1);
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
          }
          return 0xFFFFFFFF;
        }
        else
        {
          *(_DWORD *)(a1 + 0xBF) = 0;
          if ( !a3 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x2E1);
          }
          if ( !a4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x2E2);
          }
          if ( *(_WORD *)(a1 + 0xD4) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x2E4);
          }
          v40 = *(_BYTE *)(a1 + 0xAB);
          if ( v40 == 3 )
          {
            v47 = 0;
            v48 = 0;
            v49 = 0;
            v51 = 0;
            v52 = 0;
            v50 = 0;
            v43 = 2;
            *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 0;
            v41 = a4;
            if ( *(_BYTE *)(a1 + 0xB0) )
            {
              v43 = 1;
              v44 = *(_DWORD *)(a1 + 0xB1);
              v45 = 0;
              v46 = *(int **)(a1 + 0xAC);
            }
            else
            {
              v43 = 0;
              v80 = v79;
              switch ( (_BYTE)v79 )
              {
                case 5:
                  v45 = 3;
                  v47 = *a4;
                  v48 = a4[1];
                  v49 = a4[2];
                  *(_DWORD *)(a1 + 0xC8) = *a4;
                  v41 = (int *)(a1 + 0xC8);
                  *(_DWORD *)(a1 + 0xCC) = a4[1];
                  *(_DWORD *)(a1 + 0xD0) = a4[2];
                  *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 7;
                  *(_DWORD *)(*(_DWORD *)(a1 + 0xAC) + 0x5E) = 0;
                  break;
                case 2:
                  v46 = a4;
                  v45 = 1;
                  *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 3;
                  *(_DWORD *)(*(_DWORD *)(a1 + 0xAC) + 0x5E) = a4;
                  break;
                case 4:
                  v45 = 2;
                  v46 = a4;
                  *(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x5D) = 1;
                  v22 = *a4;
                  if ( *a4 == dword_D3660 )
                  {
                    v22 = a4[1];
                  }
                  *(_DWORD *)(*(_DWORD *)(a1 + 0xAC) + 0x5E) = v22;
                  break;
              }
              v23 = *(_DWORD *)(a1 + 0xAC);
              *(_BYTE *)(v23 + 0x62) = v43;
              *(_DWORD *)(v23 + 0x63) = v44;
              *(_BYTE *)(v23 + 0x67) = v45;
              v23 += 0x62;
              *(_DWORD *)(v23 + 6) = v46;
              *(_DWORD *)(v23 + 0xA) = v47;
              *(_DWORD *)(v23 + 0xE) = v48;
              *(_DWORD *)(v23 + 0x12) = v49;
              *(_DWORD *)(v23 + 0x16) = v50;
              *(_DWORD *)(v23 + 0x1A) = v51;
              *(_DWORD *)(v23 + 0x1E) = v52;
              *(_DWORD *)(v23 + 0x22) = v53;
              sub_49B3C(*(_DWORD *)(a1 + 0xAC), 0);
              v24 = *(_DWORD *)(a1 + 0xAC);
              if ( (*(_BYTE *)(v24 + 0x84) & 8) == 0 )
              {
                *(_DWORD *)(a1 + 0xBF) = v24;
                *(_DWORD *)(a1 + 0xC4) = v41;
                *(_BYTE *)(a1 + 0xC3) = v80;
              }
            }
          }
          else if ( v40 == 2 )
          {
            if ( *(_BYTE *)(a1 + 0xB0) != 2 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x33B);
            }
            if ( (_BYTE)v79 != 3 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x33C);
            }
          }
          *(_BYTE *)(a1 + 0xB9) = 1;
          sub_12140(a1);
          *(_BYTE *)(a1 + 0xB0) = 0;
          v25 = *(_DWORD *)(a1 + 0xA7);
          *(_DWORD *)(a1 + 0xB1) = 0;
          (*(void (__fastcall **)(int, _DWORD))(v25 + 0xC))(a1, 0);
          sub_12674(*(_DWORD *)(a1 + 0xBB));
          return 0;
        }
      }
      v18 = 0;
      v19 = *(_BYTE *)(a1 + 0xAB);
      *(_DWORD *)(a1 + 0xBF) = 0;
      if ( v19 == 3 && (_BYTE)v79 )
      {
        v69 = 0;
        v70 = 0;
        v71 = 0;
        *(_DWORD *)(&v43 + 0xFFFFFFF6 + 0x70) = 0;
        *(_DWORD *)(&v43 + 0xFFFFFFF6 + 0x74) = 0;
        *(_DWORD *)(&v43 + 0xFFFFFFF6 + 0x78) = 0;
        v65 = 1;
        v66 = *(_DWORD *)(a1 + 0xB1);
        v67 = 5;
        if ( (unsigned __int8)v79 < 3u )
        {
          if ( (_BYTE)v79 == 2 )
          {
            v67 = 1;
            v68 = a4;
          }
        }
        else if ( (unsigned __int8)v79 <= 3u )
        {
          v68 = a4;
          v67 = 0;
        }
        else if ( (_BYTE)v79 == 4 && *(_BYTE *)(a1 + 0xB0) == 1 )
        {
          v68 = a4;
          v67 = 2;
        }
        v20 = *(_DWORD *)(a1 + 0xAC);
        *(_BYTE *)(v20 + 0x62) = v65;
        *(_DWORD *)(v20 + 0x63) = v66;
        *(_BYTE *)(v20 + 0x67) = v67;
        v20 += 0x62;
        *(_DWORD *)(v20 + 6) = v68;
        *(_DWORD *)(v20 + 0xA) = v69;
        *(_DWORD *)(v20 + 0xE) = v70;
        *(_DWORD *)(v20 + 0x12) = v71;
        *(_DWORD *)(v20 + 0x16) = v72;
        *(_DWORD *)(v20 + 0x1A) = v73;
        *(_DWORD *)(v20 + 0x1E) = v74;
        *(_DWORD *)(v20 + 0x22) = v75;
        sub_49B3C(*(_DWORD *)(a1 + 0xAC), 0);
        if ( (*(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x84) & 1) == 0 )
        {
          return v18;
        }
      }
      else
      {
        if ( *(_BYTE *)(a1 + 0xAB) != 2 )
        {
          return v18;
        }
        if ( (_BYTE)v79 != 3 )
        {
          return v18;
        }
        v77 = a4;
        v21 = (int **)(*(_DWORD *)(a1 + 0xAC) + 0x6B);
        v76 = *(int **)(a1 + 0xB1);
        *v21++ = v76;
        *v21 = v77;
        v21[1] = v78;
        sub_3676C(*(_DWORD *)(a1 + 0xAC), 0);
        if ( (*(_BYTE *)(*(_DWORD *)(a1 + 0xAC) + 0x73) & 1) == 0 )
        {
          return v18;
        }
      }
      return 0xFFFFFFFF;
    }
    if ( a2 < 0xDu )
    {
      if ( a2 != 1 )
      {
        return sub_2F424(a1, a2, v79, (int)a4);
      }
      v8 = sub_56DA8((int)&V_Type3_stru_10AE70, "BatModeWnd", 0);
      *(_DWORD *)(a1 + 0xBB) = v8;
      if ( !v8 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x184);
      }
      v9 = sub_56DA8((int)&V_Type3_stru_10AE70, "BatListWnd", 0);
      *(_DWORD *)(a1 + 0xB5) = v9;
      if ( !v9 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x187);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xB5) + 0xAB) = 0;
      sub_2E9CC(*(_DWORD *)(a1 + 0xB5), 0);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xB5) + 0xC5) = 0;
      sub_2ED4C(*(_DWORD *)(a1 + 0xB5));
      *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
      v10 = dword_D3660;
      *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
      *(_DWORD *)(a1 + 0xBF) = 0;
      sub_1D734(v10, a1 + 0xDA);
      *(_WORD *)(a1 + 0xD4) = 0;
      *(_DWORD *)(a1 + 0x104) = 0;
      *(_DWORD *)(a1 + 0xD6) = v11;
      if ( ((1 << byte_104BEA) & (*(unsigned __int8 *)(v10 + 0x15) | *(unsigned __int8 *)(v10 + 0x14))) != 0 )
      {
        *(_BYTE *)(a1 + 0xB9) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 0xB9) = 4;
      }
      *(_BYTE *)(a1 + 0xBA) = 0;
      for ( i = 0; ; ++i )
      {
        v13 = i;
        if ( i >= *(_DWORD *)(a1 + 0xD6) )
        {
          break;
        }
        *(_DWORD *)(a1 + 4 * v13 + 0xE8) = 0xFFFFFFFF;
      }
      sub_2D258(a1, a2);
      sub_12140(a1);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      return 0;
    }
    if ( a2 <= 0xDu )
    {
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      return 0;
    }
    if ( a2 != 0x320 )
    {
      return sub_2F424(a1, a2, v79, (int)a4);
    }
    *(_BYTE *)(a1 + 0xB0) = 0;
    v16 = v79;
    *(_DWORD *)(a1 + 0xB1) = 0;
    *(_BYTE *)(a1 + 0xAB) = v16;
    v17 = *(_BYTE *)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xAC) = a4;
    if ( v17 < 2u )
    {
      if ( v17 )
      {
        goto LABEL_64;
      }
      *(_BYTE *)(a1 + 0xB9) = 1;
    }
    else if ( v17 <= 2u )
    {
      *(_BYTE *)(a1 + 0xB9) = 3;
    }
    else
    {
      if ( v17 != 3 )
      {
LABEL_64:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\batcon.cpp", 0x263);
      }
      *(_BYTE *)(a1 + 0xB9) = 2;
    }
    sub_12140(a1);
    (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
    return 0xFFFFFFFF;
  }
  if ( a2 <= 0x327u )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4
      && ((1 << byte_104BEA) & (*(unsigned __int8 *)(dword_D3660 + 0x14) | *(unsigned __int8 *)(dword_D3660 + 0x15))) != 0
      && !*(_DWORD *)(a1 + 0x104)
      && !*(_WORD *)(a1 + 0xD4) )
    {
      sub_1229C(a1, 0xFFFFFFFF);
      return 0;
    }
    return 0;
  }
  if ( a2 < 0x32Bu )
  {
    if ( a2 < 0x329u )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4
        && ((1 << byte_104BEA) & (*(unsigned __int8 *)(dword_D3660 + 0x15) | *(unsigned __int8 *)(dword_D3660 + 0x14))) != 0
        && !*(_DWORD *)(a1 + 0x104)
        && !*(_WORD *)(a1 + 0xD4) )
      {
        *(_WORD *)(a1 + 0xD4) = 0xFFFF;
        *(_DWORD *)(a1 + 0x104) = 0xFFFFFFFF;
        sub_1229C(a1, 0xFFFFFFFF);
        return 0;
      }
    }
    else
    {
      if ( a2 > 0x329u )
      {
        if ( *(_BYTE *)(a1 + 0xBA) )
        {
          *(_BYTE *)(a1 + 0xBA) = 0;
          sub_11BA4(a1);
        }
        return 0xFFFFFFFF;
      }
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4 )
      {
        v14 = *(_DWORD *)(a1 + 0xBF);
        if ( v14 )
        {
          if ( *(_BYTE *)(v14 + 0x58) == 4 && dword_D3660 == *(_DWORD *)(*(_DWORD *)(a1 + 0xBF) + 0x59) )
          {
            *(_BYTE *)(a1 + 0xAB) = 3;
            *(_BYTE *)(a1 + 0xB0) = 0;
            v15 = *(_DWORD *)(a1 + 0xBF);
            *(_DWORD *)(a1 + 0xB1) = 0;
            *(_DWORD *)(a1 + 0xAC) = v15;
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 8))();
            return 0;
          }
        }
      }
    }
    return 0;
  }
  if ( a2 <= 0x32Bu )
  {
    if ( *(_BYTE *)(a1 + 0xBA) != 1 )
    {
      *(_BYTE *)(a1 + 0xBA) = 1;
      sub_11BA4(a1);
    }
    return 0xFFFFFFFF;
  }
  if ( a2 < 0x32Du )
  {
    if ( *(_BYTE *)(a1 + 0xBA) != 4 )
    {
      *(_BYTE *)(a1 + 0xBA) = 4;
      sub_11BA4(a1);
    }
    return 0xFFFFFFFF;
  }
  if ( a2 <= 0x32Du )
  {
    if ( *(_BYTE *)(a1 + 0xBA) != 5 )
    {
      *(_BYTE *)(a1 + 0xBA) = 5;
      sub_11BA4(a1);
    }
    return 0xFFFFFFFF;
  }
  if ( a2 < 0x1C01u )
  {
    return sub_2F424(a1, a2, v79, (int)a4);
  }
  if ( a2 <= 0x1C01u )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 0xBB) + 0xB7) != 4 )
    {
      v26 = *(_BYTE *)(a1 + 0xB9) - 1;
      *(_DWORD *)(a1 + 0xBF) = 0;
      switch ( v26 )
      {
        case 0:
        case 3:
          if ( a4 == (int *)4 )
          {
            if ( sub_2ECA4(*(_DWORD *)(a1 + 0xB5), v79) >= 0 )
            {
              *(_BYTE *)(a1 + 0xAB) = 3;
              *(_BYTE *)(a1 + 0xB9) = 2;
            }
            else
            {
              *(_BYTE *)(a1 + 0xAB) = 2;
              *(_BYTE *)(a1 + 0xB9) = 3;
            }
            sub_12140(a1);
            v27 = sub_2ED14(*(_DWORD *)(a1 + 0xB5), v79);
            v42 = 0;
            v28 = *(_DWORD *)(a1 + 0xBB);
            *(_DWORD *)(a1 + 0xAC) = v27;
            sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v28 + 0x41), 0x53, 0, v42);
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
            result = 0xFFFFFFFF;
          }
          else
          {
            v29 = sub_2ED14(*(_DWORD *)(a1 + 0xB5), v79);
            v30 = sub_12AE4(*(_DWORD *)(a1 + 0xBB), v29);
            if ( !v30 )
            {
              return 0xFFFFFFFF;
            }
            sub_17E88(*(_DWORD *)(a1 + 0xBB), v30);
            sub_18C2C(*(_DWORD *)(a1 + 0xBB), 0);
            result = 0xFFFFFFFF;
          }
          break;
        case 1:
          if ( sub_2ECA4(*(_DWORD *)(a1 + 0xB5), v79) )
          {
            return 0xFFFFFFFF;
          }
          v31 = (char *)sub_2ED14(*(_DWORD *)(a1 + 0xB5), v79);
          v32 = v31;
          if ( *v31 == (char)0xFF )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x39C);
          }
          v33 = (char *)&unk_107020 + 0x6A * *v31;
          if ( (*(_WORD *)(v33 + 0x33) & 0x80) != 0 )
          {
            return 0xFFFFFFFF;
          }
          v34 = *(_WORD *)(v33 + 0x33) & 0x20;
          if ( (_BYTE)v34 )
          {
            sub_49A8C(*(_DWORD *)(a1 + 0xAC), v32);
          }
          else
          {
            *(_BYTE *)(a1 + 0xB0) = 1;
            *(_DWORD *)(a1 + 0xB1) = v32;
            if ( (*(_WORD *)(v33 + 0x33) & 0x40) != 0 )
            {
              v58 = v34;
              v59 = v34;
              v60 = v34;
              v61 = v34;
              v62 = v34;
              v63 = v34;
              v54 = 1;
              v55 = *(_DWORD *)(a1 + 0xB1);
              v56 = 5;
              v35 = *(_DWORD *)(a1 + 0xAC) + 0x62;
              *(_BYTE *)v35 = 1;
              *(_DWORD *)(v35 + 1) = v55;
              *(_BYTE *)(v35 + 5) = v56;
              *(_DWORD *)(v35 + 6) = v57;
              *(_DWORD *)(v35 + 0xA) = v58;
              *(_DWORD *)(v35 + 0xE) = v59;
              *(_DWORD *)(v35 + 0x12) = v60;
              *(_DWORD *)(v35 + 0x16) = v61;
              *(_DWORD *)(v35 + 0x1A) = v62;
              *(_DWORD *)(v35 + 0x1E) = v63;
              *(_DWORD *)(v35 + 0x22) = v64;
              *(_BYTE *)(a1 + 0xB0) = 0;
              *(_DWORD *)(a1 + 0xB1) = 0;
              *(_BYTE *)(a1 + 0xB9) = 1;
              sub_12140(a1);
              sub_12674(*(_DWORD *)(a1 + 0xBB));
            }
            else
            {
              sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(*(_DWORD *)(a1 + 0xBB) + 0x41), 0x51, 0, v34);
            }
          }
          (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
          return 0xFFFFFFFF;
        case 2:
          if ( sub_2ECA4(*(_DWORD *)(a1 + 0xB5), v79) )
          {
            return 0xFFFFFFFF;
          }
          v36 = sub_2ED14(*(_DWORD *)(a1 + 0xB5), v79);
          v42 = 0;
          *(_BYTE *)(a1 + 0xB0) = 2;
          v37 = *(_DWORD *)(a1 + 0xBB);
          *(_DWORD *)(a1 + 0xB1) = v36;
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v37 + 0x41), 0x51, 0, v42);
          return 0xFFFFFFFF;
        default:
          return 0xFFFFFFFF;
      }
      return result;
    }
    return 0;
  }
  if ( a2 != 0x1C02 )
  {
    return sub_2F424(a1, a2, v79, (int)a4);
  }
  switch ( *(_BYTE *)(a1 + 0xB9) )
  {
    case 2:
      v38 = (char *)sub_2ED14(*(_DWORD *)(a1 + 0xB5), v79);
      sub_56B60((int)&V_Type3_stru_10AE70, 5, *v38, 4);
      result = 0xFFFFFFFF;
      break;
    case 3:
      v39 = *(unsigned __int8 *)(sub_2ED14(*(_DWORD *)(a1 + 0xB5), v79) + 1);
      sub_56B60((int)&V_Type3_stru_10AE70, 5, v39, 5);
      goto LABEL_122;
    default:
LABEL_122:
      result = 0xFFFFFFFF;
      break;
  }
  return result;
}
// 10C71: variable 'v11' is possibly undefined
// D3660: using guessed type int dword_D3660;

//----- (00011870) --------------------------------------------------------
void __fastcall sub_11870(int a1, int edx0)
{
  LONG v3; // esi
  char v4; // ah
  int v5; // esi
  int v6; // edx
  int v7; // ebx
  void *v8; // eax
  char v9; // bl
  void *v10; // eax
  __int16 v11; // ax
  unsigned __int8 v12; // cl
  LONG v13; // [esp-20h] [ebp-A0h]
  char s[40]; // [esp+0h] [ebp-80h] BYREF
  T_Type5 v15; // [esp+28h] [ebp-58h] BYREF
  PANE pane; // [esp+3Ch] [ebp-44h] BYREF
  T_Type5 a2; // [esp+50h] [ebp-30h] BYREF
  __int16 v18; // [esp+64h] [ebp-1Ch]
  __int16 v19; // [esp+68h] [ebp-18h]

  if ( edx0 != 0x1C01 )
  {
    sub_11BA4(a1);
  }
  a2.a = *(P_Type6 *)(a1 + 4);
  a2.rect.x1 = 0x1D2;
  a2.rect.y1 = 0;
  a2.rect.x2 = 0x27F;
  a2.rect.y2 = 0x8D;
  VFX_pane_wipe((PANE *)&a2, 0);
  v3 = 0xA;
  v4 = *(_BYTE *)(a1 + 0xB9);
  if ( v4 == 2 || v4 == 3 )
  {
    v5 = *(_DWORD *)(a1 + 0xB5) + 4;
    v15.a = *(P_Type6 *)v5;
    v5 += 4;
    v15.rect.x1 = *(_DWORD *)v5;
    v5 += 4;
    v15.rect.y1 = *(_DWORD *)v5;
    v5 += 4;
    v15.rect.x2 = *(_DWORD *)v5;
    v15.rect.y2 = *(_DWORD *)(v5 + 4);
    v15.rect.y1 = 7;
    v15.rect.y2 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) + 8;
    if ( *(_BYTE *)(a1 + 0xB9) == 2 )
    {
      v6 = *(_DWORD *)(a1 + 0xAC);
      v7 = 0;
      v3 = 0xB;
    }
    else
    {
      v7 = 0xFFFFFFFF;
      v6 = *(_DWORD *)(a1 + 0xAC);
      v3 = 0x13;
    }
    sub_10010(&v15, v6, v7, 0);
  }
  v8 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  VFX_shape_draw((PANE *)&a2, v8, v3, 0, 0);
  sub_2D218((_DWORD *)a1);
  sub_552CC(&V_Type3_stru_10AE70, &a2);
  v9 = *(_BYTE *)(a1 + 0xB9);
  if ( v9 == 1 || v9 == 4 )
  {
    pane.window = *(WINDOW **)(a1 + 4);
    pane.x0 = 0x1DA;
    pane.y0 = 7;
    pane.x1 = 0x278;
    pane.y1 = 0x25;
    v13 = *(_DWORD *)dword_D3660;
    v10 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(*(_DWORD *)(a1 + 0xBB) + 0x19C8));
    VFX_shape_transform(&pane, v10, v13, 0xF, 0xF, buffer, 0, 0x3333, 0x3333, 0);
    v11 = 0;
    v19 = 0xF3;
    v18 = 0xFFFF;
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      while ( 1 )
      {
        if ( *(int *)((char *)&dword_A2F75 + 0x1EE * v11) != 0xFFFFFFFF )
        {
          v12 = *(_BYTE *)(dword_D3660 + 0x14);
          if ( v12 )
          {
            if ( ((1 << v11) | v12) == 1 << v11
              || dword_D3660 == *(int *)((char *)&dword_A2F79 + 0x1EE * v11) && ((1 << v11) & v12) != 0 )
            {
              break;
            }
          }
        }
        if ( ++v11 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_20;
        }
      }
      v18 = v11;
    }
LABEL_20:
    if ( v18 != 0xFFFFFFFF )
    {
      v19 = 4 * (unsigned __int8)byte_A2F74[0x1EE * v11] + 0x13;
      sub_53E38((P_Type5)&pane, 0x8D, 3, v11);
    }
    sprintf(s, "%s", (const char *)(dword_D3660 + 0x1C));
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x28, 5, s, 0, v19, 0xFF, 0x6C);
    sprintf(s, "%s", &byte_D84C4[0x14 * *(_DWORD *)dword_D3660]);
    *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x28, 0x12, s, 0, 0xF3, 0xFF, 0x6C);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&pane);
  }
}
// A2F75: using guessed type int dword_A2F75;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// D3660: using guessed type int dword_D3660;
// D8DA0: using guessed type UBYTE buffer[94816];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 11870: using guessed type _DWORD var_58[2];

//----- (00011BA4) --------------------------------------------------------
int __fastcall sub_11BA4(int a1)
{
  int v2; // ebp
  int v3; // edi
  unsigned __int16 v4; // ax
  __int16 i; // di
  int v6; // edx
  unsigned __int16 v7; // ax
  char *v9; // edi
  int v10; // ebx
  char v11; // ah
  int v12; // ebp
  char v13; // al
  char *v14; // ebp
  unsigned __int16 v15; // dx
  int v16; // edi
  int v17; // edx
  int v18; // ebp
  __int64 v19; // rax
  __int16 v20; // di
  int v21; // ebp
  int v22; // edx
  unsigned __int16 v23; // ax
  __int16 k; // di
  int v25; // edx
  unsigned __int16 v26; // ax
  __int64 v27; // [esp-4h] [ebp-3A0h] BYREF
  _DWORD *v28; // [esp+4h] [ebp-398h]
  _DWORD *v29; // [esp+8h] [ebp-394h]
  _DWORD *v30; // [esp+Ch] [ebp-390h]
  int v31[107]; // [esp+1ACh] [ebp-1F0h] BYREF
  int v32; // [esp+358h] [ebp-44h]
  int v33; // [esp+35Ch] [ebp-40h]
  int v34; // [esp+360h] [ebp-3Ch] BYREF
  int v35; // [esp+364h] [ebp-38h] BYREF
  int v36; // [esp+368h] [ebp-34h] BYREF
  int v37; // [esp+36Ch] [ebp-30h]
  int v38; // [esp+370h] [ebp-2Ch]
  int v39; // [esp+374h] [ebp-28h]
  int v40; // [esp+378h] [ebp-24h]
  __int16 v41; // [esp+37Ch] [ebp-20h]
  __int16 j; // [esp+380h] [ebp-1Ch]

  sub_2ED4C(*(_DWORD *)(a1 + 0xB5));
  switch ( *(_BYTE *)(a1 + 0xB9) )
  {
    case 1:
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10010);
      v41 = 0;
      v2 = sub_1D794((__int16 *)dword_D3660, (_DWORD *)&v27 + 1);
      while ( v41 < v2 )
      {
        v3 = *((_DWORD *)&v27 + v41 + 1);
        if ( *(_BYTE *)(v3 + 0x58) == 4 )
        {
          if ( *(__int16 *)(v3 + 0x56) >= 7 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x4AC);
          }
          if ( *(_WORD *)(v3 + 0x56) == (unsigned __int8)byte_104BEA )
          {
            v4 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), *((const char **)&v27 + v41 + 1), 0xFFFFFFFF, 0);
            sub_2EC50(*(_DWORD *)(a1 + 0xB5), v4, v41);
          }
        }
        ++v41;
      }
      for ( i = 0; i < *(__int16 *)(dword_D3660 + 0x5A); ++i )
      {
        v6 = *(_DWORD *)(dword_D3660 + 4 * i + 0x46);
        if ( *(_BYTE *)(v6 + 0x57) == (_BYTE)byte_104BEA )
        {
          v7 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v6, 0xFFFFFFFF, 0);
          sub_2EC50(*(_DWORD *)(a1 + 0xB5), v7, i | 0x80000000);
        }
      }
      goto LABEL_15;
    case 2:
      if ( *(_BYTE *)(a1 + 0xAB) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x4D8);
      }
      if ( !*(_DWORD *)(a1 + 0xAC) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x4D9);
      }
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10668);
      v37 = *(_DWORD *)(a1 + 0xAC);
      v33 = *(_DWORD *)(v37 + 0x88);
      if ( *(_WORD *)(v37 + 0x56) == (unsigned __int8)byte_104BEA || sub_4AAEC(v37, (unsigned __int8)byte_104BEA) == 2 )
      {
        v9 = (char *)(v37 + 0xAB);
        LOWORD(v40) = 0;
        while ( (__int16)v40 < *(_DWORD *)(v37 + 0x15A) )
        {
          if ( *v9 != (char)0xFF )
          {
            if ( (v12 = 0x6A * *v9, v13 = byte_107052[v12],
                                    v14 = (char *)&unk_107020 + v12,
                                    v13 == *(_BYTE *)(a1 + 0xBA))
              && (*(_WORD *)(v14 + 0x33) & 0x80) == 0
              || *(_BYTE *)(a1 + 0xBA) == 4 && (*(_WORD *)(v14 + 0x33) & 0x80) != 0 )
            {
              v15 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), v9, 0xFFFFFFFF, 0);
              v32 = *(__int16 *)(v37 + 0x56);
              v10 = 0;
              if ( (unsigned __int8)byte_104BEA == v32 )
              {
                if ( (*(_WORD *)(v14 + 0x33) & 0x20) == 0 )
                {
                  if ( !*(_DWORD *)(v14 + 0x42) || *(_WORD *)(v9 + 1) )
                  {
                    if ( v33 < *(_DWORD *)(v14 + 0x36) )
                    {
                      v10 = 3;
                    }
                  }
                  else
                  {
                    v10 = 2;
                  }
                }
              }
              else
              {
                v10 = 1;
              }
              if ( (*(_WORD *)(v14 + 0x33) & 0x80) != 0 )
              {
                v10 = *v9 + 0x1F4;
              }
              v11 = v14[0x32];
              if ( v11 == 2 )
              {
                v10 = *v9 + 0x258;
              }
              else if ( v11 == 4 )
              {
                v10 = *v9 + 0x2BC;
              }
              sub_2EC50(*(_DWORD *)(a1 + 0xB5), v15, v10);
            }
          }
          v9 += 7;
          LOWORD(v40) = v40 + 1;
        }
      }
      goto LABEL_15;
    case 3:
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10878);
      v16 = *(_DWORD *)(a1 + 0xAC);
      if ( *(_BYTE *)(a1 + 0xAB) != 2 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x51F);
      }
      if ( !v16 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x520);
      }
      if ( (_BYTE)byte_104BEA == *(_BYTE *)(v16 + 0x57) )
      {
        for ( j = 0; j < (int)*(unsigned __int16 *)(v16 + 0x1A); ++j )
        {
          v17 = 4 * j + *(_DWORD *)(v16 + 0x10);
          v38 = 4 * j;
          v18 = 0;
          if ( (*(_WORD *)(v17 + 2) & 1) != 0 && (word_103FA2[0x14 * *(unsigned __int8 *)(v17 + 1)] & 4) != 0 )
          {
            v39 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v17, 0xFFFFFFFF, 0);
            LODWORD(v27) = &v36;
            HIDWORD(v19) = *(unsigned __int8 *)(v38 + *(_DWORD *)(v16 + 0x10) + 1);
            LODWORD(v19) = v16;
            sub_366C8(v19, &v35, &v34, v27, v28, v29, v30);
            if ( v36 && !((int)*(unsigned __int16 *)(v38 + *(_DWORD *)(v16 + 0x10) + 2) >> 8) )
            {
              v18 = 1;
            }
            sub_2EC50(*(_DWORD *)(a1 + 0xB5), v39, v18);
          }
        }
      }
      goto LABEL_15;
    case 4:
      *(_WORD *)(*(_DWORD *)(a1 + 0xB5) + 0x8C9) = 0x54;
      sub_2F1C8(*(_DWORD *)(a1 + 0xB5), (int)sub_10010);
      v20 = 0;
      v21 = sub_1D794((__int16 *)dword_D3660, v31);
      while ( v20 < v21 )
      {
        v22 = v31[v20];
        if ( *(_BYTE *)(v22 + 0x58) == 4 && *(_WORD *)(v22 + 0x56) != (unsigned __int8)byte_104BEA )
        {
          v23 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v22, 0xFFFFFFFF, 0);
          sub_2EC50(*(_DWORD *)(a1 + 0xB5), v23, v20);
        }
        ++v20;
      }
      for ( k = 0; k < *(__int16 *)(dword_D3660 + 0x5A); ++k )
      {
        v25 = *(_DWORD *)(dword_D3660 + 4 * k + 0x46);
        if ( (_BYTE)byte_104BEA != *(_BYTE *)(v25 + 0x57) )
        {
          v26 = sub_2EA8C(*(_DWORD *)(a1 + 0xB5), (const char *)v25, 0xFFFFFFFF, 0);
          sub_2EC50(*(_DWORD *)(a1 + 0xB5), v26, k | 0x80000000);
        }
      }
LABEL_15:
      sub_2F1D8(*(_DWORD *)(a1 + 0xB5), (int)sub_10A14);
      sub_2F1E0(*(_DWORD *)(a1 + 0xB5));
      break;
    default:
      return (*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xB5) + 0xA7) + 0xC))();
  }
  return (*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xB5) + 0xA7) + 0xC))();
}
// D3660: using guessed type int dword_D3660;
// 103FA2: using guessed type __int16 word_103FA2[];
// 11BA4: using guessed type int var_1F0[107];

//----- (00012140) --------------------------------------------------------
int __fastcall sub_12140(int a1)
{
  __int16 i; // si
  unsigned int v3; // edx
  char v4; // ah
  __int16 j; // bx
  int v6; // eax
  int result; // eax
  int v8; // eax
  unsigned int v9; // [esp+4h] [ebp-1Ch]

  for ( i = 0; i < *(__int16 *)(a1 + 0x6B); ++i )
  {
    if ( !strcmp((const char *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * i) + 0x20), "My^Items") )
    {
      break;
    }
  }
  if ( i >= *(__int16 *)(a1 + 0x6B) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batcon.cpp", 0x58C);
  }
  v3 = 0xFFFFFFFF;
  v4 = *(_BYTE *)(a1 + 0xB9);
  v9 = 0;
  if ( v4 == 2 )
  {
    v3 = 0;
  }
  else if ( v4 == 3 )
  {
    v9 = 0xFFFFFFFF;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= 9 )
    {
      break;
    }
    if ( v9 )
    {
      v6 = i + j;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v6) + 0x35) = 0;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v6) + 0x39) = 0;
    }
    else
    {
      v8 = i + j;
      if ( j >= 5 )
      {
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x35) = ~v3;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x39) = ~v3;
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x35) = v3;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v8) + 0x39) = v3;
      }
    }
  }
  return result;
}

//----- (00012238) --------------------------------------------------------
void __fastcall sub_12238(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 0xAB) == 3 )
  {
    sub_49B3C(*(_DWORD *)(a1 + 0xAC), 1);
  }
  else if ( *(_BYTE *)(a1 + 0xAB) == 2 )
  {
    sub_3676C(*(_DWORD *)(a1 + 0xAC), 1);
  }
  *(_BYTE *)(a1 + 0xAB) = 0;
  *(_DWORD *)(a1 + 0xAC) = 0;
  if ( a2 == 0xFFFFFFFF )
  {
    sub_11BA4(a1);
  }
  sub_1229C(a1, a2);
}

//----- (0001229C) --------------------------------------------------------
void __fastcall sub_1229C(int a1, int a2)
{
  __int16 *v3; // esi
  _BYTE v4[5]; // [esp+0h] [ebp-1Ch] BYREF

  v3 = (__int16 *)dword_D3660;
  while ( (__int16)++*(_WORD *)(a1 + 0xD4) < *(_DWORD *)(a1 + 0xD6) || sub_12368(a1, a2) )
  {
    v4[0] = 0;
    *(_DWORD *)(a1 + 4 * *(__int16 *)(a1 + 0xD4) + 0xE8) = sub_406C4(
                                                             (unsigned __int8 *)&byte_A2F72[0x1EE
                                                                                          * *(__int16 *)(a1 + 2 * *(__int16 *)(a1 + 0xD4) + 0xDA)],
                                                             v3,
                                                             (int)v4);
    if ( v4[0] )
    {
      *(_DWORD *)(a1 + 0xAB) = *(_DWORD *)v4;
      *(_BYTE *)(a1 + 0xAF) = v4[4];
      if ( v4[0] == 3 )
      {
        sub_49B3C(*(int *)&v4[1], 0);
      }
      else
      {
        sub_3676C(*(int *)&v4[1], 0);
      }
      if ( a2 == 0xFFFFFFFF )
      {
        sub_12674(*(_DWORD *)(a1 + 0xBB));
      }
      else
      {
        sub_12238(a1, a2);
      }
      return;
    }
  }
}
// D3660: using guessed type int dword_D3660;

//----- (00012368) --------------------------------------------------------
unsigned int __fastcall sub_12368(int a1, int a2)
{
  __int16 *v3; // esi
  unsigned int v4; // edi
  __int16 i; // ax
  int v6; // eax
  __int16 v7; // cx
  int v8; // eax
  unsigned __int8 *v9; // eax

  v3 = (__int16 *)dword_D3660;
  v4 = 0;
  if ( *(_DWORD *)(a1 + 0x104) == 0xFFFFFFFF )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 0xD6); ++i )
    {
      if ( *(_DWORD *)(a1 + 4 * i + 0xE8) == 0xFFFFFFFF )
      {
        v4 = 0xFFFFFFFF;
        break;
      }
    }
  }
  v6 = dword_D3660;
  *(_DWORD *)(a1 + 0x104) = v4;
  sub_1D734(v6, a1 + 0xDA);
  *(_WORD *)(a1 + 0xD4) = 0;
  v7 = 0;
  *(_DWORD *)(a1 + 0xD6) = v8;
  while ( v7 < *(_DWORD *)(a1 + 0xD6) )
  {
    v9 = (unsigned __int8 *)&byte_A2F72[0x1EE * *(__int16 *)(a1 + 2 * v7++ + 0xDA)];
    sub_3B56C(v9, v3);
  }
  if ( a2 == 0xFFFFFFFF )
  {
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
  }
  return v4;
}
// 123C0: variable 'v8' is possibly undefined
// D3660: using guessed type int dword_D3660;

//----- (0001240C) --------------------------------------------------------
void __fastcall sub_1240C(int a1, int a2)
{
  sub_2FBA4(a1, a2);
  sub_53E38((P_Type5)(a1 + 4), 3, 3, (unsigned __int8)byte_104BEA);
}

//----- (00012440) --------------------------------------------------------
char *__fastcall sub_12440(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 0xA);
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return (char *)v1 + 0xFFFFFFEA;
}

//----- (00012480) --------------------------------------------------------
int __fastcall sub_12480(float *a1, float *a2, int a3, int a4, float a5)
{
  double v6; // st7
  double v7; // st7
  float v9; // [esp+8h] [ebp-80h] BYREF
  float v10; // [esp+Ch] [ebp-7Ch]
  float v11; // [esp+10h] [ebp-78h]
  float v12; // [esp+14h] [ebp-74h] BYREF
  float v13; // [esp+18h] [ebp-70h]
  float v14; // [esp+1Ch] [ebp-6Ch]
  int v15[3]; // [esp+20h] [ebp-68h] BYREF
  float v16; // [esp+2Ch] [ebp-5Ch]
  int v17; // [esp+30h] [ebp-58h]
  int v18; // [esp+34h] [ebp-54h]
  float v19; // [esp+38h] [ebp-50h]
  float v20; // [esp+3Ch] [ebp-4Ch]
  float v21; // [esp+40h] [ebp-48h]
  int v22[3]; // [esp+44h] [ebp-44h] BYREF
  float v23; // [esp+50h] [ebp-38h]
  float v24; // [esp+54h] [ebp-34h]
  float v25; // [esp+58h] [ebp-30h]
  float v26; // [esp+5Ch] [ebp-2Ch]
  int v27; // [esp+60h] [ebp-28h]
  int v28; // [esp+64h] [ebp-24h]
  int *v29; // [esp+68h] [ebp-20h]
  float *v30; // [esp+6Ch] [ebp-1Ch]
  int *v31; // [esp+70h] [ebp-18h]
  float *v32; // [esp+74h] [ebp-14h]
  float v33; // [esp+7Ch] [ebp-Ch]
  int v34; // [esp+80h] [ebp-8h]

  v34 = a4;
  v30 = &v12;
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v23 = *a2 - *a1;
  v24 = a2[1] - a1[1];
  v25 = a2[2] - a1[2];
  v12 = v23;
  v13 = v24;
  v14 = v25;
  v33 = sqrt(v24 * v24 + v23 * v23 + v25 * v25);
  if ( a5 >= (double)v33 )
  {
    *a1 = *a2;
    a1[1] = a2[1];
    a1[2] = a2[2];
    return 0xFFFFFFFF;
  }
  else
  {
    v26 = v12 * a5;
    *(float *)&v27 = v13 * a5;
    *(float *)&v28 = a5 * v14;
    v6 = 1.0 / v33;
    v29 = v22;
    *(float *)v22 = v26;
    v22[1] = v27;
    v22[2] = v28;
    v16 = v26 * v6;
    v31 = v15;
    *(float *)&v17 = *(float *)&v27 * v6;
    *(float *)v15 = v16;
    v19 = 0.0;
    v15[1] = v17;
    *(float *)&v18 = v6 * *(float *)&v28;
    v20 = 0.0;
    v15[2] = v18;
    v21 = 0.0;
    v32 = &v9;
    v19 = *a1 + v16;
    v20 = a1[1] + *(float *)&v17;
    v7 = a1[2];
    v9 = v19;
    v21 = v7 + *(float *)&v18;
    v10 = v20;
    v11 = v21;
    *a1 = v19;
    a1[1] = v10;
    a1[2] = v11;
    return 0;
  }
}

//----- (00012618) --------------------------------------------------------
unsigned int __fastcall sub_12618(int a1)
{
  int v2; // esi
  void *v3; // eax
  unsigned int v4; // ebp
  LONG v5; // esi
  unsigned __int16 v7; // [esp+0h] [ebp-1Ch]

  v7 = *(_WORD *)(a1 + 5);
  v2 = *(_DWORD *)(a1 + 7);
  v3 = (void *)sub_1B084((unsigned int)dword_12FC20, v7);
  v4 = 0;
  v5 = v2 + 1;
  if ( v5 >= VFX_shape_count(v3) )
  {
    v4 = 0xFFFFFFFF;
    LOWORD(v5) = 0;
  }
  sub_156C0(a1, v7, v5);
  return v4;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00012674) --------------------------------------------------------
void __fastcall sub_12674(int a1)
{
  *(_BYTE *)(a1 + 0x4F37) = 0xFF;
  *(_DWORD *)(a1 + 0xB3) = 0;
  *(_WORD *)(a1 + 0x5034) = 0;
  *(_BYTE *)(a1 + 0xB7) = 4;
  sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x52, 0, 0, 0);
}

//----- (000126F8) --------------------------------------------------------
int __fastcall sub_126F8(int a1, int a2)
{
  int v3; // edx
  char v4; // al
  char v5; // bl
  int v6; // edx
  int v7; // edx
  int v8; // edx
  __int16 *v9; // ebx
  int v10; // esi
  int i; // ebx
  unsigned int v12; // edi
  int v13; // esi
  int j; // ebx
  __int64 v15; // rax
  int v16; // edx
  int v17; // esi

  if ( *(_BYTE *)(a1 + 0x4F37) != 0xFF )
  {
    goto LABEL_42;
  }
  sub_187EC(a1);
  sub_18C2C(a1, 0);
  v3 = *(_DWORD *)(a1 + 0xAB);
  *(_DWORD *)(a1 + 0x4F38) = 0;
  v4 = 0;
  v5 = *(_BYTE *)(v3 + 0xAB);
  v6 = v3 + 0xAB;
  if ( v5 != 3 )
  {
    if ( v5 != 2 )
    {
      goto LABEL_41;
    }
    v4 = 0x34;
    if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v6 + 1) + 0x6B) + 1) == 0x11 )
    {
      *(_BYTE *)(a1 + 0x4F37) = 3;
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  v7 = *(_DWORD *)(v6 + 1);
  v5 = *(_BYTE *)(v7 + 0x62);
  v8 = v7 + 0x62;
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      goto LABEL_41;
    }
    v4 = **(_BYTE **)(v8 + 1);
    switch ( v4 )
    {
      case '4':
        *(_BYTE *)(a1 + 0x4F37) = 3;
        goto LABEL_41;
      case '7':
        *(_BYTE *)(a1 + 0x4F37) = 4;
        goto LABEL_41;
      case ' ':
        *(_BYTE *)(a1 + 0x4F37) = 5;
        goto LABEL_41;
      case '8':
      case 'J':
        *(_BYTE *)(a1 + 0x4F37) = 6;
        goto LABEL_41;
      case ':':
        *(_BYTE *)(a1 + 0x4F37) = 7;
        goto LABEL_41;
      case '.':
        *(_BYTE *)(a1 + 0x4F37) = 8;
        goto LABEL_41;
      case '<':
        *(_BYTE *)(a1 + 0x4F37) = 9;
        goto LABEL_41;
      case ';':
      case 'D':
        *(_BYTE *)(a1 + 0x4F37) = 0xA;
        goto LABEL_41;
      case '-':
        *(_BYTE *)(a1 + 0x4F37) = 0xB;
        goto LABEL_41;
      case '(':
      case '\'':
        *(_BYTE *)(a1 + 0x4F37) = 0xC;
        goto LABEL_41;
      case '$':
        *(_BYTE *)(a1 + 0x4F37) = 0xD;
        goto LABEL_41;
      case 'H':
        *(_BYTE *)(a1 + 0x4F37) = 0xE;
        goto LABEL_41;
      case '&':
        *(_BYTE *)(a1 + 0x4F37) = 0xF;
        goto LABEL_41;
    }
    if ( (word_107053[0x35 * v4] & 0x40) == 0 )
    {
      *(_BYTE *)(a1 + 0x4F37) = 2;
      goto LABEL_41;
    }
LABEL_40:
    *(_BYTE *)(a1 + 0x4F37) = v5;
    goto LABEL_41;
  }
  *(_BYTE *)(a1 + 0x4F37) = 0;
LABEL_41:
  v9 = (__int16 *)(a1 + 4 * v4);
  sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 2 * v9[0xD49] + 0x19C6));
  sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 2 * v9[0xD4A] + 0x19C6));
  sub_50140((int)&unk_10914C, v9[0xDE7]);
  a2 = v9[0xDE8];
  sub_50140((int)&unk_10914C, a2);
LABEL_42:
  v10 = a1;
  for ( i = 0; i < *(__int16 *)(a1 + 0x5034); ++i )
  {
    a2 = *(_DWORD *)(v10 + 0x4F44);
    sub_12B4C(a1, a2);
    v10 += 4;
  }
  switch ( *(_BYTE *)(a1 + 0x4F37) )
  {
    case 0xFF:
      v12 = 0xFFFFFFFF;
      break;
    case 0:
      v12 = sub_12C98(a1, a2, i);
      break;
    case 1:
      v12 = sub_12E88(a1);
      break;
    case 2:
      v12 = sub_12F7C(a1);
      break;
    case 3:
      v12 = sub_13370(a1, a2, i);
      break;
    case 4:
      v12 = sub_136C4(a1);
      break;
    case 5:
      v12 = sub_1380C(a1);
      break;
    case 6:
      v12 = sub_13C10(a1);
      break;
    case 7:
      v12 = sub_14224(a1);
      break;
    case 8:
      v12 = sub_142D8(a1);
      break;
    case 9:
      v12 = sub_14490(a1);
      break;
    case 0xA:
      v12 = sub_145C0(a1);
      break;
    case 0xB:
      v12 = sub_147CC(a1);
      break;
    case 0xC:
      v12 = sub_14B18(a1, a2, i);
      break;
    case 0xD:
      v12 = sub_15078(a1);
      break;
    case 0xE:
      v12 = sub_15164(a1);
      break;
    case 0xF:
      v12 = sub_152E4(a1, a2, i, a1);
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0xF8);
  }
  if ( *(_DWORD *)(a1 + 0x5036) == 0xFFFFFFFF )
  {
    v12 = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x5036) = 0;
  }
  sub_18C2C(a1, 1);
  v13 = a1;
  for ( j = 0; j < *(__int16 *)(a1 + 0x5034); ++j )
  {
    sub_12B4C(a1, *(_DWORD *)(v13 + 0x4F44));
    v13 += 4;
  }
  LODWORD(v15) = (*(int (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 1);
  ++*(_DWORD *)(a1 + 0x4F38);
  if ( v12 == 0xFFFFFFFF )
  {
    v16 = *(_DWORD *)(a1 + 0x41);
    *(_BYTE *)(a1 + 0xB7) = 0;
    sub_564C0(&V_Type3_stru_10AE70, v16, 0x52);
    sub_12238(*(_DWORD *)(a1 + 0xAB), 0xFFFFFFFF);
    sub_187EC(a1);
    sub_18C2C(a1, 0);
    *(_BYTE *)(a1 + 0x4F37) = 0xFF;
    v15 = (unsigned int)a1;
    while ( SHIDWORD(v15) < *(__int16 *)(a1 + 0x5034) )
    {
      v17 = *(_DWORD *)(v15 + 0x4F44);
      LODWORD(v15) = v15 + 4;
      ++HIDWORD(v15);
      *(_BYTE *)(v17 + 0x33) &= 1u;
    }
  }
  return v15;
}
// 107053: using guessed type __int16 word_107053[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00012AE4) --------------------------------------------------------
int __fastcall sub_12AE4(int a1, int a2)
{
  int v4; // edi
  int v5; // edx
  int v6; // eax

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x122);
  }
  v4 = 0;
  v5 = 0;
  if ( *(int *)(a1 + 0x1D32) > 0 )
  {
    v6 = *(_DWORD *)(a1 + 0x1D2A);
    while ( a2 != *(_DWORD *)(v6 + 1) )
    {
      ++v5;
      v6 += 0x35;
      if ( v5 >= *(_DWORD *)(a1 + 0x1D32) )
      {
        goto LABEL_10;
      }
    }
    v4 = v6;
  }
LABEL_10:
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x12F);
  }
  return v4;
}

//----- (00012B4C) --------------------------------------------------------
void __fastcall sub_12B4C(int a1, int a2)
{
  int v2; // ebx
  int v3; // esi
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  double v8; // st7
  double v9; // st6
  double v10; // st5
  int v11; // [esp+Ch] [ebp-18h]

  if ( *(_BYTE *)a2 == 8 )
  {
    v2 = *(_DWORD *)(a2 + 1);
    if ( *(_WORD *)(a2 + 0x27) >= *(_WORD *)(v2 + 0x27) )
    {
      v3 = *(_DWORD *)(a1 + 8);
      dword_9A240 = v3 + *(__int16 *)(v2 + 0x27);
      v4 = *(__int16 *)(a2 + 0x27);
    }
    else
    {
      v3 = *(__int16 *)(v2 + 0x27);
      dword_9A240 = *(_DWORD *)(a1 + 8) + *(__int16 *)(a2 + 0x27);
      v4 = *(_DWORD *)(a1 + 8);
    }
    dword_9A248 = v3 + v4;
    if ( *(_WORD *)(a2 + 0x29) >= *(_WORD *)(v2 + 0x29) )
    {
      v6 = *(_DWORD *)(a1 + 0xC);
      v7 = *(__int16 *)(v2 + 0x29) + v6;
      v5 = *(__int16 *)(a2 + 0x29) + v6;
      dword_9A244 = v7;
    }
    else
    {
      dword_9A244 = *(__int16 *)(a2 + 0x29) + *(_DWORD *)(a1 + 0xC);
      v5 = *(__int16 *)(v2 + 0x29) + *(_DWORD *)(a1 + 0xC);
    }
    dword_9A24C = v5;
  }
  else
  {
    v11 = *(__int16 *)(a2 + 0x29) + *(_DWORD *)(a1 + 0xC);
    v8 = (double)*(unsigned int *)(a2 + 0xF) * dbl_9017F;
    v9 = (double)(*(__int16 *)(a2 + 0x27) + *(_DWORD *)(a1 + 8));
    dword_9A240 = (int)((double)*(__int16 *)(a2 + 0x13) * v8 + v9);
    v10 = (double)v11;
    dword_9A244 = (int)((double)*(__int16 *)(a2 + 0x15) * v8 + v10);
    dword_9A248 = (int)(v9 + (double)*(__int16 *)(a2 + 0x17) * v8);
    dword_9A24C = (int)(v8 * (double)*(__int16 *)(a2 + 0x19) + v10);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&unk_9A23C);
}
// 9017F: using guessed type double dbl_9017F;
// 9A240: using guessed type int dword_9A240;
// 9A244: using guessed type int dword_9A244;
// 9A248: using guessed type int dword_9A248;
// 9A24C: using guessed type int dword_9A24C;

//----- (00012C98) --------------------------------------------------------
unsigned int __fastcall sub_12C98(int a1, int a2, int a3)
{
  int v4; // edi
  unsigned int v5; // ebp
  char v6; // ah
  int v7; // edi
  int v8; // edi
  char v9; // dl
  int v10; // eax
  int v11; // eax
  int v13; // edi
  void *v14; // eax
  int v15; // edi
  int v16; // ecx
  unsigned __int16 v17; // [esp+0h] [ebp-1Ch]

  v4 = *(_DWORD *)(a1 + 0xAB);
  v5 = 0;
  v6 = *(_BYTE *)(v4 + 0xAB);
  v7 = v4 + 0xAB;
  if ( v6 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x16B);
  }
  v8 = *(_DWORD *)(v7 + 1);
  v9 = *(_BYTE *)(v8 + 0x67);
  if ( v9 != 3 && v9 != 1 && v9 != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x171);
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v10 = sub_12AE4(a1, v8);
    *(_DWORD *)(a1 + 0x4F44) = v10;
    *(_BYTE *)(v10 + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)(v8 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v8 + 0xA2);
    a3 = *(_DWORD *)(v8 + 0xA6);
    *(_DWORD *)(a1 + 0x4F88) = a3;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    if ( *(_DWORD *)(v8 + 0x94) )
    {
      if ( *(_DWORD *)(v8 + 0x88) )
      {
        sub_4FB90((int)&unk_10914C, 7);
      }
    }
  }
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    v17 = 7;
    if ( (*(_BYTE *)(*(_DWORD *)(v8 + 0x68) + 0x23) & 1) != 0 )
    {
      v17 = 8;
    }
    v13 = *(_DWORD *)(a1 + 0x4F3C);
    v14 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 2 * v17 + 0x19C6));
    v15 = v13 >> 2;
    v16 = VFX_shape_count(v14) - 1;
    if ( v15 <= v16 || v15 > 2 * v16 )
    {
      if ( v15 > 2 * v16 )
      {
        v5 = 0xFFFFFFFF;
        LOWORD(v15) = 0;
      }
    }
    else
    {
      LOWORD(v15) = 2 * v16 - v15;
    }
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), v17, v15);
    ++*(_DWORD *)(a1 + 0x4F3C);
  }
  else if ( sub_12480((float *)(a1 + 0x4F80), (float *)(v8 + 0x78), a3, v8 + 0x62, 20.0) == 0xFFFFFFFF )
  {
    if ( (*(_BYTE *)(v8 + 0x84) & 8) == 0
      || *(_BYTE *)(v8 + 0x67) != 2
      || sub_4960C(v8, *(_DWORD *)(v8 + 0x68)) != 0xFFFFFFFF )
    {
      return 0xFFFFFFFF;
    }
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
    *(_WORD *)(a1 + 0x5034) = 2;
    v11 = sub_12AE4(a1, *(_DWORD *)(v8 + 0x68));
    *(_DWORD *)(a1 + 0x4F3C) = 1;
    *(_DWORD *)(a1 + 0x4F48) = v11;
  }
  return v5;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00012E88) --------------------------------------------------------
unsigned int __fastcall sub_12E88(int a1)
{
  int v2; // ebp
  int v3; // edi
  char v4; // ah
  int v5; // ebp
  int v6; // eax
  char v7; // bl
  _BYTE *v8; // edx
  int v9; // eax
  int v10; // ebp

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x1BA);
  }
  v6 = *(_DWORD *)(v5 + 1);
  v7 = **(_BYTE **)(v6 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v8 = *(_BYTE **)(a1 + 0x1D2A);
    *(_WORD *)(a1 + 0x5034) = 1;
    v8 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *v8 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) = 0x12;
    v9 = v6 + 0x9E;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)v9;
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v9 + 4);
    v10 = a1 + 4 * v7;
    *(float *)(a1 + 0x4F88) = *(float *)(v9 + 8);
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), *(_WORD *)(v10 + 0x1A92), 0);
    sub_4FB90((int)&unk_10914C, *(_WORD *)(v10 + 0x1BCE));
  }
  if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618(*(_DWORD *)(a1 + 0x4F44)) == 0xFFFFFFFF )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}

//----- (00012F7C) --------------------------------------------------------
int __fastcall sub_12F7C(int a1)
{
  unsigned __int8 *v2; // edx
  int v3; // ebx
  int v4; // ebp
  int *v5; // ecx
  int v6; // ebp
  int v7; // ebp
  _DWORD *v8; // edi
  int v9; // ebp
  unsigned int v10; // eax
  _BYTE *v11; // eax
  int v12; // edi
  __int16 v14; // di
  unsigned __int16 v15; // ax
  _BYTE *v16; // eax
  char v17; // bl
  int v18; // eax
  __int64 x_4; // [esp+4h] [ebp-7Ch] BYREF
  float v20; // [esp+Ch] [ebp-74h]
  float v21; // [esp+10h] [ebp-70h]
  float v22; // [esp+14h] [ebp-6Ch]
  float v23; // [esp+18h] [ebp-68h]
  float v24; // [esp+1Ch] [ebp-64h]
  int v25[3]; // [esp+20h] [ebp-60h] BYREF
  float v26; // [esp+2Ch] [ebp-54h]
  int v27; // [esp+30h] [ebp-50h]
  int v28; // [esp+34h] [ebp-4Ch]
  int v29; // [esp+38h] [ebp-48h] BYREF
  char v30; // [esp+3Ch] [ebp-44h] BYREF
  unsigned int v31; // [esp+40h] [ebp-40h]
  int v32[2]; // [esp+48h] [ebp-38h] BYREF
  int v33; // [esp+50h] [ebp-30h]
  float v34; // [esp+54h] [ebp-2Ch]
  int v35; // [esp+58h] [ebp-28h]
  int v36; // [esp+5Ch] [ebp-24h]
  _BYTE *v37; // [esp+60h] [ebp-20h]
  char v38; // [esp+64h] [ebp-1Ch]

  v33 = 0;
  v2 = (unsigned __int8 *)(*(_DWORD *)(a1 + 0xAB) + 0xAB);
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0.0;
  HIDWORD(x_4) = 0;
  v20 = 0.0;
  v21 = 0.0;
  v32[0] = 0;
  v3 = *v2;
  v38 = 0;
  if ( (_BYTE)v3 == 3 )
  {
    v4 = *(_DWORD *)(v2 + 1);
    v22 = *(float *)(v4 + 0x9E);
    v23 = *(float *)(v4 + 0xA2);
    v24 = *(float *)(v4 + 0xA6);
    HIDWORD(x_4) = *(_DWORD *)(v4 + 0x78);
    v20 = *(float *)(v4 + 0x7C);
    v21 = *(float *)(v4 + 0x80);
    v36 = **(char **)(v4 + 0x63);
    v35 = *(_DWORD *)(v4 + 0x84);
    v5 = (int *)v36;
    v38 = *(_BYTE *)(v4 + 0x67);
    v6 = *(_DWORD *)(v4 + 0x68);
    v32[0] = *(int *)((char *)&dword_10705A + 0x6A * v36);
  }
  else
  {
    if ( (_BYTE)v3 != 2 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0x20E);
    }
    v7 = *(_DWORD *)(v2 + 1);
    v22 = *(float *)v7;
    v23 = *(float *)(v7 + 4);
    v8 = (_DWORD *)(v7 + 0x6B);
    v24 = *(float *)(v7 + 8);
    v9 = *(_DWORD *)(v7 + 0x6F);
    HIDWORD(x_4) = *(_DWORD *)(v9 + 0x9E);
    v20 = *(float *)(v9 + 0xA2);
    v21 = *(float *)(v9 + 0xA6);
    v35 = v8[2];
    LODWORD(x_4) = &v30;
    v6 = v8[1];
    v5 = &v29;
    v3 = (int)v32;
    v10 = *(unsigned __int8 *)(*v8 + 1);
    v31 = *(_DWORD *)(v2 + 1);
    sub_366C8(
      __SPAIR64__(v10, v31),
      &v29,
      v32,
      x_4,
      (_DWORD *)LODWORD(v20),
      (_DWORD *)LODWORD(v21),
      (_DWORD *)LODWORD(v22));
    LOBYTE(v5) = *(_BYTE *)(*v8 + 1);
    switch ( (_BYTE)v5 )
    {
      case 0x1C:
        v36 = 0x4C;
        break;
      case 0x1D:
        v36 = 0x4D;
        break;
      case 0x1E:
        v36 = 0x4E;
        break;
    }
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v11 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v11 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v11;
    *v11 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(float *)(a1 + 0x4F80) = v22;
    *(float *)(a1 + 0x4F84) = v23;
    HIWORD(v3) = 0;
    v12 = v36;
    *(float *)(a1 + 0x4F88) = v24;
    v5 = 0;
    LOWORD(v3) = *(_WORD *)(a1 + 4 * v12 + 0x1A92);
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v3, 0);
    *(_DWORD *)(a1 + 0x4F48) = sub_12AE4(a1, v6);
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v12 + 0x1BCE));
  }
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    v14 = 1;
    v34 = 1.0;
    v15 = 4;
    if ( (v35 & 4) != 0 || v36 == 0x3D )
    {
      v16 = *(_BYTE **)(a1 + 0x4F48);
      if ( *v16 == 2 )
      {
        LOWORD(v16) = *(char *)(v6 + 0xAA);
        v37 = v16;
        v34 = (double)(__int16)v16 * dbl_901BB + 1.0;
      }
      v14 = 5;
      v17 = v36;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
      v15 = (char)(((v17 & 1) == 0) + 5);
      if ( v36 != 0x3D )
      {
        goto LABEL_29;
      }
      v18 = 0x3D;
    }
    else
    {
      if ( (v35 & 2) == 0 && (v35 & 0x10) == 0 && v38 != 1 && v38 != 2 )
      {
        goto LABEL_29;
      }
      v18 = v36;
    }
    v14 = *(_WORD *)(a1 + 4 * v18 + 0x1BD0);
    v15 = *(_WORD *)(a1 + 4 * v18 + 0x1A94);
LABEL_29:
    if ( *(_DWORD *)(a1 + 0x4F3C) == 1 )
    {
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v15, 0);
      sub_4FB90((int)&unk_10914C, v14);
      *(_DWORD *)(a1 + 0x4F3C) = 2;
    }
    if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618(*(_DWORD *)(a1 + 0x4F44)) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
      v33 = 0xFFFFFFFF;
    }
    *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = v34;
    return v33;
  }
  v26 = *((float *)&x_4 + 1) - v22;
  v32[1] = (int)v25;
  *(float *)&v27 = v20 - v23;
  *(float *)&v28 = v21 - v24;
  *(float *)v25 = v26;
  v25[1] = v27;
  v25[2] = v28;
  *(float *)&x_4 = sqrt(*(float *)&v27 * *(float *)&v27 + v26 * v26 + *(float *)&v28 * *(float *)&v28) * flt_901C3
                 + flt_901C7;
  if ( sub_12480((float *)(a1 + 0x4F80), (float *)&x_4 + 1, v3, (int)v5, *(float *)&x_4) != 0xFFFFFFFF )
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F44));
    return v33;
  }
  *(_DWORD *)(a1 + 0x4F3C) = 1;
  return v33;
}
// 901BB: using guessed type double dbl_901BB;
// 901C3: using guessed type float flt_901C3;
// 901C7: using guessed type float flt_901C7;
// 10705A: using guessed type int dword_10705A;

//----- (00013370) --------------------------------------------------------
unsigned int __fastcall sub_13370(int a1, int a2, int a3)
{
  int v4; // ebp
  int v5; // eax
  char v6; // dl
  int v7; // edi
  int v8; // esi
  int *v9; // ebx
  float v10; // eax
  _BYTE *v11; // eax
  int v12; // eax
  int v13; // eax
  double v14; // st7
  double v15; // st7
  float v17; // [esp+8h] [ebp-6Ch] BYREF
  float v18; // [esp+Ch] [ebp-68h]
  float v19; // [esp+10h] [ebp-64h]
  float v20; // [esp+14h] [ebp-60h]
  float v21; // [esp+18h] [ebp-5Ch]
  float v22; // [esp+1Ch] [ebp-58h]
  float v23; // [esp+20h] [ebp-54h] BYREF
  float v24; // [esp+24h] [ebp-50h]
  float v25; // [esp+28h] [ebp-4Ch]
  float v26; // [esp+2Ch] [ebp-48h]
  float v27; // [esp+30h] [ebp-44h]
  float v28; // [esp+34h] [ebp-40h]
  float v29; // [esp+38h] [ebp-3Ch]
  float v30; // [esp+3Ch] [ebp-38h]
  float v31; // [esp+40h] [ebp-34h]
  int v32; // [esp+44h] [ebp-30h]
  float *v33; // [esp+48h] [ebp-2Ch]
  float *v34; // [esp+4Ch] [ebp-28h]
  float v35; // [esp+50h] [ebp-24h]
  int v36; // [esp+54h] [ebp-20h]
  float v37; // [esp+58h] [ebp-1Ch]

  v4 = 0;
  v5 = *(_DWORD *)(a1 + 0xAB) + 0xAB;
  v26 = 0.0;
  v27 = 0.0;
  v28 = 0.0;
  v6 = *(_BYTE *)v5;
  v36 = 0;
  if ( v6 == 3 )
  {
    v7 = *(_DWORD *)(v5 + 1);
    if ( *(_BYTE *)(v7 + 0x67) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x27D);
    }
    v8 = *(_DWORD *)(v7 + 0x68);
    v36 = sub_12AE4(a1, *(_DWORD *)(v5 + 1));
    v26 = *(float *)(v7 + 0x9E);
    v27 = *(float *)(v7 + 0xA2);
    v28 = *(float *)(v7 + 0xA6);
    v32 = 0x20 * dword_1085F2;
    v35 = (float)(0x20 * dword_1085F2);
  }
  else
  {
    if ( v6 != 2 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0x28E);
    }
    v9 = *(int **)(v5 + 1);
    v8 = *(int *)((char *)v9 + 0x6F);
    v36 = sub_12AE4(a1, (int)v9);
    v26 = *(float *)v9;
    v27 = *((float *)v9 + 1);
    v10 = *((float *)v9 + 2);
    a3 = 0x45480000;
    v28 = v10;
    v35 = 3200.0;
  }
  sub_12AE4(a1, v8);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v11 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v11 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v11;
    *v11 = 8;
    *(_DWORD *)(*(_DWORD *)(a1 + 0x4F44) + 1) = v36;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(float *)(a1 + 0x4F80) = v26;
    *(float *)(a1 + 0x4F84) = v27;
    *(float *)(a1 + 0x4F88) = v28;
    v12 = sub_12AE4(a1, v8);
    *(_DWORD *)(a1 + 0x4F48) = v12;
    *(_BYTE *)(v12 + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(v8 + 0x9E);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v8 + 0xA2);
    a3 = *(_DWORD *)(v8 + 0xA6);
    *(_DWORD *)(a1 + 0x4F94) = a3;
    sub_4FB90((int)&unk_10914C, 1);
  }
  v13 = *(_DWORD *)(a1 + 0x4F3C);
  if ( !v13 )
  {
    if ( sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), a3, a1, 40.0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 2u;
      v20 = 0.0;
      v21 = 0.0;
      v22 = 0.0;
      v33 = &v23;
      v20 = *(float *)(a1 + 0x4F8C) - v26;
      v21 = *(float *)(a1 + 0x4F90) - v27;
      v22 = *(float *)(a1 + 0x4F94) - v28;
      v23 = v20;
      v24 = v21;
      v25 = v22;
      v14 = sqrt(v21 * v21 + v20 * v20 + v22 * v22);
      v15 = v14 - v35;
      v37 = v15;
      if ( v15 < flt_901E5 )
      {
        v37 = 1280.0;
      }
      sub_53054(&v23, v37);
      v34 = &v17;
      v29 = v26 + v23;
      v17 = v29;
      v30 = v27 + v24;
      v18 = v30;
      v31 = v28 + v25;
      v19 = v31;
      *(float *)(a1 + 0x4F98) = v29;
      *(float *)(a1 + 0x4F9C) = v18;
      *(float *)(a1 + 0x4FA0) = v19;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
      return 0;
    }
    return v4;
  }
  if ( v13 != 1 )
  {
    return 0xFFFFFFFF;
  }
  if ( sub_12480((float *)(a1 + 0x4F8C), (float *)(a1 + 0x4F98), a3, a1, 4.0) == 0xFFFFFFFF )
  {
    *(_DWORD *)(a1 + 0x4F3C) = 2;
  }
  *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)(a1 + 0x4F8C);
  *(float *)(a1 + 0x4F84) = *(float *)(a1 + 0x4F90);
  *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)(a1 + 0x4F94);
  return 0;
}
// 901E5: using guessed type float flt_901E5;
// 1085F2: using guessed type int dword_1085F2;

//----- (000136C4) --------------------------------------------------------
unsigned int __fastcall sub_136C4(int a1)
{
  int v2; // edi
  int v3; // esi
  char v4; // ah
  int v5; // edi
  _DWORD *v6; // ebx
  int v7; // edi
  int v8; // eax
  int v9; // eax
  int v10; // ebx
  int v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+4h] [ebp-20h]
  int v14; // [esp+8h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x2D8);
  }
  v6 = *(_DWORD **)(v5 + 1);
  v7 = v6[0x1A];
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v8 = sub_12AE4(a1, (int)v6);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) = 0x14;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)((char *)v6 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)((char *)v6 + 0xA2);
    *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)((char *)v6 + 0xA6);
    v9 = sub_12AE4(a1, v7);
    *(_DWORD *)(a1 + 0x4F48) = v9;
    *(_BYTE *)(v9 + 0x33) = 0x14;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(v7 + 0x9E);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v7 + 0xA2);
    *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v7 + 0xA6);
  }
  v10 = *(_DWORD *)(a1 + 0x4F38);
  if ( v10 == 0x14 )
  {
    v12 = *(_DWORD *)(a1 + 0x4F8C);
    v13 = *(_DWORD *)(a1 + 0x4F90);
    v14 = *(_DWORD *)(a1 + 0x4F94);
    *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(a1 + 0x4F80);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(a1 + 0x4F84);
    *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(a1 + 0x4F88);
    *(_DWORD *)(a1 + 0x4F80) = v12;
    *(_DWORD *)(a1 + 0x4F84) = v13;
    *(_DWORD *)(a1 + 0x4F88) = v14;
  }
  else if ( v10 == 0x29 )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}

//----- (0001380C) --------------------------------------------------------
unsigned int __fastcall sub_1380C(int a1)
{
  int v2; // ecx
  int v3; // edi
  char v4; // ah
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // ebp
  int v9; // edx
  _BYTE *v10; // eax
  int v11; // eax
  double v12; // st7
  int v13; // eax
  int v14; // edx
  int v15; // ebx
  _BYTE *v16; // eax
  int v18[3]; // [esp+0h] [ebp-30h] BYREF
  int v19; // [esp+Ch] [ebp-24h]
  int v20; // [esp+10h] [ebp-20h]
  char v21; // [esp+14h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x30D);
  }
  v6 = *(_DWORD *)(v5 + 1);
  v20 = v6;
  v7 = v6 + 0x62;
  if ( *(_BYTE *)(v6 + 0x67) != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x312);
  }
  v8 = *(_DWORD *)(v6 + 0x68);
  v18[0] = *(_DWORD *)(v6 + 0x78);
  v18[1] = *(_DWORD *)(v6 + 0x7C);
  v18[2] = *(_DWORD *)(v6 + 0x80);
  v9 = *(_DWORD *)(a1 + 0x4F38);
  v21 = **(_BYTE **)(v6 + 0x63);
  if ( !v9 )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v10 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    v10 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v10;
    *v10 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) = 0x12;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    v11 = v20 + 0x9E;
    *(float *)(a1 + 0x4F80) = *(float *)(v20 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v11 + 4);
    v12 = *(float *)(v11 + 8);
    v13 = 4 * v21;
    *(float *)(a1 + 0x4F88) = v12;
    v7 = 0;
    v19 = a1 + v13;
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), *(_WORD *)(a1 + v13 + 0x1A92), 0);
    v14 = v19;
    *(_DWORD *)(a1 + 0x4F48) = sub_12AE4(a1, v8);
    sub_4FB90((int)&unk_10914C, *(_WORD *)(v14 + 0x1BCE));
  }
  v15 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v15 )
  {
    *(_DWORD *)(a1 + 0x4F3C) = v15 + 1;
    if ( v15 + 1 > 0x14 )
    {
      return 0xFFFFFFFF;
    }
  }
  else if ( sub_12480((float *)(a1 + 0x4F80), (float *)v18, 0, v7, 40.0) == 0xFFFFFFFF )
  {
    v16 = *(_BYTE **)(a1 + 0x4F44);
    *(_DWORD *)(a1 + 0x4F3C) = 1;
    *v16 = 0xFF;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 4u;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v21 + 0x1BD0));
  }
  return v3;
}

//----- (000139E0) --------------------------------------------------------
void __fastcall sub_139E0(int a1, int a2)
{
  switch ( *(_BYTE *)(a1 + 0x4F37) )
  {
    case 4:
      sub_13A28(a1, a2);
      break;
    case 5:
      sub_13AD8(a1, a2);
      break;
    case 7:
    case 0xA:
    case 0xC:
    case 0xD:
    case 0xE:
      sub_15630(a1, a2);
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batfx.cpp", 0x362);
  }
}

//----- (00013A28) --------------------------------------------------------
void __fastcall sub_13A28(int a1, int a2)
{
  double v3; // st7
  void *v4; // eax
  LONG v5; // [esp-20h] [ebp-3Ch]
  LONG v6; // [esp-1Ch] [ebp-38h]
  LONG v7; // [esp-18h] [ebp-34h]
  LONG v8; // [esp-Ch] [ebp-28h]
  float v9; // [esp+8h] [ebp-14h]

  if ( *(_BYTE *)a2 != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfx.cpp", 0x36B);
  }
  if ( *(int *)(a1 + 0x4F38) >= 0x14 )
  {
    v3 = (double)*(int *)(a1 + 0x4F38) + dbl_9022A;
  }
  else
  {
    v3 = dbl_9023A - (double)*(int *)(a1 + 0x4F38);
  }
  v9 = v3 * dbl_90232;
  v8 = (int)((double)*(int *)(a2 + 0xF) * v9);
  v7 = *(__int16 *)(a2 + 0x29);
  v6 = *(__int16 *)(a2 + 0x27);
  v5 = *(_DWORD *)(a2 + 7);
  v4 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a2 + 5));
  VFX_shape_transform((PANE *)(a1 + 4), v4, v5, v6, v7, buffer, 0, v8, v8, 0);
}
// 9022A: using guessed type double dbl_9022A;
// 90232: using guessed type double dbl_90232;
// 9023A: using guessed type double dbl_9023A;
// D8DA0: using guessed type UBYTE buffer[94816];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00013AD8) --------------------------------------------------------
void __fastcall sub_13AD8(int a1, int a2)
{
  void *v3; // eax
  PANE *v4; // edi
  LONG v5; // [esp-20h] [ebp-44h]
  LONG v6; // [esp-1Ch] [ebp-40h]
  LONG v7; // [esp-18h] [ebp-3Ch]
  LONG v8; // [esp-8h] [ebp-2Ch]
  LONG width; // [esp+10h] [ebp-14h]
  int widtha; // [esp+10h] [ebp-14h]

  width = *(_DWORD *)(a1 + 0x4F3C);
  if ( width > 0xA )
  {
    width = 0x14 - width;
    sub_1826C(a1, a2, *(_WORD *)(a1 + 0x1B14), 2u);
  }
  v8 = *(_DWORD *)(a2 + 0xF);
  v7 = *(__int16 *)(a2 + 0x29);
  v6 = *(__int16 *)(a2 + 0x27);
  v5 = *(_DWORD *)(a2 + 7);
  v3 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a2 + 5));
  v4 = (PANE *)(a1 + 4);
  VFX_shape_transform(v4, v3, v5, v6, v7, buffer, 0, v8, v8, 0);
  widtha = (int)((double)*(unsigned int *)(a2 + 0xF)
               * dbl_90242
               * (double)((*(__int16 *)(a2 + 0x17) - *(__int16 *)(a2 + 0x13)) * width)
               * flt_9024A);
  VFX_ellipse_fill(v4, *(__int16 *)(a2 + 0x27), *(__int16 *)(a2 + 0x29), widtha, widtha, 0x96);
}
// 90242: using guessed type double dbl_90242;
// 9024A: using guessed type float flt_9024A;
// D8DA0: using guessed type UBYTE buffer[94816];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00013BC0) --------------------------------------------------------
_DWORD *__fastcall sub_13BC0(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  return result;
}

//----- (00013BF0) --------------------------------------------------------
_DWORD *__fastcall sub_13BF0(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (00013C10) --------------------------------------------------------
unsigned int __fastcall sub_13C10(int a1)
{
  int v2; // ecx
  char v3; // ah
  int v4; // ecx
  int v5; // ecx
  int v6; // ebx
  int v7; // ebp
  char v8; // al
  int v9; // edi
  _BYTE *v10; // eax
  _DWORD *v11; // ecx
  int v12; // edx
  int v13; // eax
  float *v14; // ecx
  float *v15; // edx
  double v16; // st7
  int v17; // eax
  float *v18; // edx
  int v19; // ebp
  int v20; // eax
  int v22; // eax
  double v23; // st7
  double v24; // st7
  int v25; // edi
  int v26; // ebx
  int v27; // ecx
  int v28; // edx
  int v29; // edx
  double v30; // st7
  double v31; // st7
  int v32; // edx
  int v33[107]; // [esp+8h] [ebp-238h] BYREF
  float v34; // [esp+1B4h] [ebp-8Ch]
  float v35; // [esp+1B8h] [ebp-88h]
  float v36; // [esp+1BCh] [ebp-84h]
  float v37; // [esp+1C0h] [ebp-80h]
  float v38; // [esp+1C4h] [ebp-7Ch]
  float v39; // [esp+1C8h] [ebp-78h]
  float v40; // [esp+1CCh] [ebp-74h] BYREF
  float v41; // [esp+1D0h] [ebp-70h]
  float v42; // [esp+1D4h] [ebp-6Ch]
  float v43; // [esp+1D8h] [ebp-68h] BYREF
  float v44; // [esp+1DCh] [ebp-64h]
  float v45; // [esp+1E0h] [ebp-60h]
  float v46; // [esp+1E4h] [ebp-5Ch]
  float v47; // [esp+1E8h] [ebp-58h]
  float v48; // [esp+1ECh] [ebp-54h]
  float *v49; // [esp+1F0h] [ebp-50h]
  int v50; // [esp+1F4h] [ebp-4Ch]
  float v51; // [esp+1F8h] [ebp-48h]
  float *v52; // [esp+1FCh] [ebp-44h]
  int v53; // [esp+200h] [ebp-40h]
  float v54; // [esp+204h] [ebp-3Ch]
  int v55; // [esp+208h] [ebp-38h]
  int v56; // [esp+20Ch] [ebp-34h]
  int v57; // [esp+210h] [ebp-30h]
  float v58; // [esp+214h] [ebp-2Ch]
  float v59; // [esp+218h] [ebp-28h]
  float v60; // [esp+21Ch] [ebp-24h]
  int v61; // [esp+220h] [ebp-20h]
  char v62; // [esp+224h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v53 = 0;
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x31);
  }
  v5 = *(_DWORD *)(v4 + 1);
  v6 = 1;
  v7 = 0;
  v8 = **(_BYTE **)(v5 + 0x63);
  v55 = 1;
  v62 = v8;
  if ( v8 == 0x4A )
  {
    if ( *(_BYTE *)(v5 + 0x67) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x3A);
    }
    v7 = *(_DWORD *)(v5 + 0x68);
    v55 = 2;
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    LOBYTE(v6) = v62;
    v9 = sub_1D794(*(__int16 **)(v5 + 0x59), v33);
    *(_WORD *)(a1 + 0x5034) = 1;
    if ( (_BYTE)v6 == 0x4A )
    {
      *(_WORD *)(a1 + 0x5034) = 2;
      *(_DWORD *)(a1 + 0x4F44) = sub_12AE4(a1, v7);
      v10 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
      *(_DWORD *)(a1 + 0x4F48) = v10;
      *v10 = 7;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) = 0x12;
      v11 = (_DWORD *)(v5 + 0x9E);
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
      *(_DWORD *)(a1 + 0x4F8C) = *v11;
      *(_DWORD *)(a1 + 0x4F90) = v11[1];
      *(_DWORD *)(a1 + 0x4F94) = v11[2];
      v5 = 0;
      v6 = *(unsigned __int16 *)(a1 + 4 * v62 + 0x1A92);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), v6, 0);
      if ( v9 <= 0 )
      {
        goto LABEL_18;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 0x4F44) = sub_12AE4(a1, *(_DWORD *)(v5 + 0x59));
      if ( v9 <= 0 )
      {
LABEL_18:
        v17 = v62;
        *(_DWORD *)(a1 + 0x4F3C) = 0;
        sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v17 + 0x1BCE));
        goto LABEL_19;
      }
    }
    v6 = 0;
    v56 = a1 + 0x4F80;
    v57 = 4 * v9;
    do
    {
      if ( *(__int16 *)(a1 + 0x5034) >= 0xF )
      {
        break;
      }
      v12 = *(int *)((char *)v33 + v6);
      if ( *(_BYTE *)(v12 + 0x58) == 4 && v12 != v7 )
      {
        v13 = sub_12AE4(a1, v12);
        *(_BYTE *)(v13 + 0x33) |= 0x12u;
        *(_BYTE *)(v13 + 0x34) = *(_BYTE *)(a1 + 0x5034);
        v14 = *(float **)((char *)v33 + v6);
        v15 = (float *)(a1 + 0x4F80 + 0xC * *(char *)(v13 + 0x34));
        v16 = *(float *)((char *)v14 + 0x9E);
        v14 = (float *)((char *)v14 + 0x9E);
        *v15 = v16;
        v15[1] = v14[1];
        v15[2] = v14[2];
        LOWORD(v15) = *(_WORD *)(a1 + 0x5034);
        v5 = (__int16)v15;
        *(_WORD *)(a1 + 0x5034) = (_WORD)v15 + 1;
        *(_DWORD *)(a1 + 4 * (__int16)v15 + 0x4F44) = v13;
      }
      v6 += 4;
    }
    while ( v6 < v57 );
    goto LABEL_18;
  }
LABEL_19:
  v18 = (float *)(v7 + 0x9E);
  v19 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v19 )
  {
    if ( v19 == 1 )
    {
      *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) + flt_90278;
      v20 = *(_DWORD *)(a1 + 0x4F44);
      dword_9A234 = 0;
      if ( *(float *)(v20 + 0xB) >= (double)flt_9027C )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 2;
        return v53;
      }
    }
    else if ( v19 == 2 )
    {
      v46 = 0.0;
      v47 = 0.0;
      v48 = 0.0;
      if ( v62 == 0x4A )
      {
        v46 = *v18;
        v47 = v18[1];
        v48 = v18[2];
      }
      v22 = 0x6A * v62;
      v23 = (double)*(int *)((char *)&dword_10706A + v22);
      v61 = 0x20 * *(int *)((char *)&dword_10706E + v22);
      v54 = v23;
      v51 = (float)v61;
      v24 = v54 - *(float *)&dword_9A234;
      v58 = v24;
      if ( v24 > dbl_90270 )
      {
        v58 = 0.2;
      }
      v25 = a1 + 0x4F80;
      v50 = 0xFFFFFFFF;
      v26 = v55;
      *(float *)&dword_9A234 = *(float *)&dword_9A234 + v58;
      v27 = a1 + 4 * v55;
      while ( v26 < *(__int16 *)(a1 + 0x5034) )
      {
        v29 = *(char *)(*(_DWORD *)(v27 + 0x4F44) + 0x34);
        v49 = &v40;
        v34 = 0.0;
        v35 = 0.0;
        v36 = 0.0;
        v34 = *(float *)(v25 + 0xC * v29) - v46;
        v35 = *(float *)(v25 + 0xC * v29 + 4) - v47;
        v36 = *(float *)(v25 + 0xC * v29 + 8) - v48;
        v40 = v34;
        v41 = v35;
        v42 = v36;
        v30 = sqrt(v35 * v35 + v34 * v34 + v36 * v36);
        v59 = v30;
        if ( v30 > v51 )
        {
          v31 = v59 - v58 * flt_90280;
          v60 = v31;
          if ( v31 >= v51 )
          {
            v50 = 0;
          }
          else
          {
            v60 = v51;
          }
          v28 = 0xC * v29;
          sub_53054(&v40, v60);
          v52 = &v43;
          v37 = v46 + v40;
          v43 = v37;
          v38 = v47 + v41;
          v44 = v38;
          v39 = v48 + v42;
          v45 = v39;
          *(float *)(v28 + v25) = v37;
          *(float *)(v28 + v25 + 4) = v44;
          *(float *)(v28 + v25 + 8) = v45;
        }
        v27 += 4;
        ++v26;
      }
      if ( *(float *)&dword_9A234 >= (double)v54 || v50 == 0xFFFFFFFF )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 3;
        return v53;
      }
    }
    else
    {
      *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) + flt_9026C;
      v32 = *(_DWORD *)(a1 + 0x4F44);
      if ( *(float *)(v32 + 0xB) <= 1.0 )
      {
        *(_DWORD *)(v32 + 0xB) = 0x3F800000;
        return 0xFFFFFFFF;
      }
    }
  }
  else
  {
    if ( v62 == 0x4A )
    {
      if ( sub_12480((float *)(a1 + 0x4F8C), v18, v6, v5, 10.0) != 0xFFFFFFFF )
      {
        sub_12618(*(_DWORD *)(a1 + 0x4F48));
        return v53;
      }
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
    }
    *(_DWORD *)(a1 + 0x4F3C) = 1;
  }
  return v53;
}
// 9026C: using guessed type float flt_9026C;
// 90270: using guessed type double dbl_90270;
// 90278: using guessed type float flt_90278;
// 9027C: using guessed type float flt_9027C;
// 90280: using guessed type float flt_90280;
// 9A234: using guessed type int dword_9A234;
// 10706A: using guessed type int dword_10706A;
// 10706E: using guessed type int dword_10706E;

//----- (00014224) --------------------------------------------------------
unsigned int __fastcall sub_14224(int a1)
{
  int v2; // edi
  int v3; // esi
  char v4; // ah
  int v5; // edi
  int v6; // edx
  char v7; // bl
  int v8; // eax
  int v9; // eax

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0xCC);
  }
  v6 = *(_DWORD *)(v5 + 1);
  v7 = **(_BYTE **)(v6 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v8 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) |= 4u;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v7 + 0x1BCE));
  }
  v9 = *(_DWORD *)(a1 + 0x4F38);
  *(_DWORD *)(a1 + 0x4F40) += v9 & 1;
  if ( v9 == 0x24 )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}

//----- (000142D8) --------------------------------------------------------
int __fastcall sub_142D8(int a1)
{
  int v2; // esi
  char v3; // ah
  int v4; // esi
  int v5; // ebx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  double v9; // st7
  double v10; // st7
  int v11; // edx
  double v12; // st7
  double v13; // st6
  float v15; // [esp+8h] [ebp-40h] BYREF
  float v16; // [esp+Ch] [ebp-3Ch]
  float v17; // [esp+10h] [ebp-38h]
  float v18; // [esp+14h] [ebp-34h]
  float v19; // [esp+18h] [ebp-30h]
  float v20; // [esp+1Ch] [ebp-2Ch]
  float *v21; // [esp+20h] [ebp-28h]
  float v22; // [esp+24h] [ebp-24h]
  float v23; // [esp+28h] [ebp-20h]
  float v24; // [esp+2Ch] [ebp-1Ch]
  char v25; // [esp+30h] [ebp-18h]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0xF5);
  }
  v5 = *(_DWORD *)(v4 + 1);
  v6 = *(_DWORD *)(a1 + 0x4F38);
  v25 = **(_BYTE **)(v5 + 0x63);
  if ( !v6 )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v7 = sub_12AE4(a1, v5);
    *(_DWORD *)(a1 + 0x4F44) = v7;
    *(_BYTE *)(v7 + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    v8 = v5 + 0x9E;
    v9 = *(float *)(v5 + 0x9E);
    v5 = 0;
    *(float *)(a1 + 0x4F80) = v9;
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)(v8 + 8);
    v18 = 0.0;
    v19 = 0.0;
    v20 = 0.0;
    v21 = &v15;
    v18 = -*(float *)v8;
    v19 = -*(float *)(v8 + 4);
    v10 = -*(float *)(v8 + 8);
    v15 = v18;
    v20 = v10;
    v16 = v19;
    v17 = v20;
    *(float *)(a1 + 0x4F8C) = v18;
    *(float *)(a1 + 0x4F90) = v16;
    *(float *)(a1 + 0x4F94) = v17;
    v11 = v25;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v11 + 0x1BCE));
  }
  v12 = *(float *)(a1 + 0x4F90) * *(float *)(a1 + 0x4F90) + *(float *)(a1 + 0x4F8C) * *(float *)(a1 + 0x4F8C);
  v13 = *(float *)(a1 + 0x4F94) * *(float *)(a1 + 0x4F94);
  v24 = 0.0;
  v23 = sqrt(v12 + v13);
  v22 = sqrt(
          *(float *)(a1 + 0x4F84) * *(float *)(a1 + 0x4F84)
        + *(float *)(a1 + 0x4F80) * *(float *)(a1 + 0x4F80)
        + *(float *)(a1 + 0x4F88) * *(float *)(a1 + 0x4F88));
  if ( v23 > 1.0 )
  {
    v24 = (v23 - v22) * flt_902A0 / v23;
  }
  if ( v24 < dbl_902A4 )
  {
    v24 = 3.2;
  }
  return sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), v5, a1, v24);
}
// 902A0: using guessed type float flt_902A0;
// 902A4: using guessed type double dbl_902A4;

//----- (00014490) --------------------------------------------------------
int __fastcall sub_14490(int a1)
{
  int v2; // esi
  char v3; // ah
  int v4; // esi
  int v5; // esi
  _DWORD *v6; // ebx
  int v7; // eax
  float v9; // [esp+0h] [ebp-1Ch]
  char v10; // [esp+4h] [ebp-18h]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x127);
  }
  v5 = *(_DWORD *)(v4 + 1);
  if ( *(_BYTE *)(v5 + 0x67) != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x12B);
  }
  v6 = *(_DWORD **)(v5 + 0x68);
  v10 = **(_BYTE **)(v5 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v7 = sub_12AE4(a1, v5);
    *(_DWORD *)(a1 + 0x4F44) = v7;
    *(_BYTE *)(v7 + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)(v5 + 0x9E);
    *(_DWORD *)(a1 + 0x4F84) = *(_DWORD *)(v5 + 0xA2);
    *(_DWORD *)(a1 + 0x4F88) = *(_DWORD *)(v5 + 0xA6);
    *(_DWORD *)(a1 + 0x4F8C) = v6[5];
    *(_DWORD *)(a1 + 0x4F90) = v6[6];
    *(_DWORD *)(a1 + 0x4F94) = v6[7];
    if ( *(_DWORD *)(v5 + 0x59) == *v6 )
    {
      *(_DWORD *)(a1 + 0x4F8C) = v6[2];
      *(_DWORD *)(a1 + 0x4F90) = v6[3];
      v6 = (_DWORD *)v6[4];
      *(_DWORD *)(a1 + 0x4F94) = v6;
    }
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v10 + 0x1BCE));
  }
  v9 = (double)*(int *)(a1 + 0x4F38) * dbl_902C8;
  return sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), (int)v6, a1, v9);
}
// 902C8: using guessed type double dbl_902C8;

//----- (000145C0) --------------------------------------------------------
unsigned int __fastcall sub_145C0(int a1)
{
  int v2; // ecx
  char v3; // ah
  int v4; // ecx
  int v5; // ecx
  int v6; // edi
  int v7; // ebx
  int v8; // eax
  _BYTE *v9; // eax
  _DWORD *v10; // ecx
  int v11; // ebp
  int v12; // eax
  int v13; // eax
  int v14; // edi
  int v16; // ebx
  int v17; // [esp+0h] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v17 = 0;
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x158);
  }
  v5 = *(_DWORD *)(v4 + 1);
  if ( *(_BYTE *)(v5 + 0x67) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x15C);
  }
  v7 = *(_DWORD *)(v5 + 0x63);
  v6 = *(_DWORD *)(v5 + 0x68);
  LOBYTE(v7) = *(_BYTE *)v7;
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 3;
    v8 = sub_12AE4(a1, v5);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) |= 4u;
    v9 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
    *(_DWORD *)(a1 + 0x4F48) = v9;
    *v9 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) = 0x1A;
    v10 = (_DWORD *)(v5 + 0x9E);
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    *(_DWORD *)(a1 + 0x4F8C) = *v10;
    *(_DWORD *)(a1 + 0x4F90) = v10[1];
    *(_DWORD *)(a1 + 0x4F94) = v10[2];
    v11 = (char)v7;
    v5 = 0;
    v7 = *(unsigned __int16 *)(a1 + 4 * (char)v7 + 0x1A92);
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), v7, 0);
    v12 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    *(_DWORD *)(a1 + 0x4F4C) = v12;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v11 + 0x1BCE));
  }
  v13 = *(_DWORD *)(a1 + 0x4F3C);
  if ( !v13 )
  {
    v14 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
    *(_DWORD *)(a1 + 0x4F40) = v14;
    if ( v14 == 0x12 )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) &= ~4u;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) &= ~8u;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
      *(_DWORD *)(a1 + 0x4F40) = 0;
    }
    return v17;
  }
  if ( v13 != 1 )
  {
    v16 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
    *(_DWORD *)(a1 + 0x4F40) = v16;
    if ( v16 == 0x12 )
    {
      return 0xFFFFFFFF;
    }
    return v17;
  }
  if ( sub_12480((float *)(a1 + 0x4F8C), (float *)(v6 + 0x9E), v7, v5, 20.0) == 0xFFFFFFFF )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F4C) + 0x33) |= 4u;
    *(_DWORD *)(a1 + 0x4F3C) = 2;
  }
  else
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F48));
  }
  return 0;
}

//----- (000147CC) --------------------------------------------------------
unsigned int __fastcall sub_147CC(int a1)
{
  int v2; // edi
  char v3; // ah
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // ebp
  _BYTE *v9; // eax
  int v10; // eax
  double v11; // st7
  double v12; // st7
  int v13; // edx
  float *v14; // edx
  double v15; // st7
  float v17; // [esp+4h] [ebp-84h]
  int v18[3]; // [esp+8h] [ebp-80h] BYREF
  float v19; // [esp+14h] [ebp-74h] BYREF
  float v20; // [esp+18h] [ebp-70h]
  float v21; // [esp+1Ch] [ebp-6Ch]
  float v22; // [esp+20h] [ebp-68h] BYREF
  float v23; // [esp+24h] [ebp-64h]
  float v24; // [esp+28h] [ebp-60h]
  float v25; // [esp+2Ch] [ebp-5Ch]
  float v26; // [esp+30h] [ebp-58h]
  float v27; // [esp+34h] [ebp-54h]
  float v28; // [esp+38h] [ebp-50h]
  float v29; // [esp+3Ch] [ebp-4Ch]
  float v30; // [esp+40h] [ebp-48h]
  float v31; // [esp+44h] [ebp-44h]
  float v32; // [esp+48h] [ebp-40h]
  float v33; // [esp+4Ch] [ebp-3Ch]
  float *v34; // [esp+50h] [ebp-38h]
  int *v35; // [esp+54h] [ebp-34h]
  int v36; // [esp+58h] [ebp-30h]
  int v37; // [esp+5Ch] [ebp-2Ch]
  int v38; // [esp+60h] [ebp-28h]
  float v39; // [esp+64h] [ebp-24h]
  float *v40; // [esp+68h] [ebp-20h]
  int v41; // [esp+6Ch] [ebp-1Ch]

  v2 = *(_DWORD *)(a1 + 0xAB);
  v38 = 0;
  v3 = *(_BYTE *)(v2 + 0xAB);
  v4 = v2 + 0xAB;
  if ( v3 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x1AC);
  }
  v5 = *(_DWORD *)(v4 + 1);
  if ( *(_BYTE *)(v5 + 0x67) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x1B0);
  }
  v6 = **(char **)(v5 + 0x63);
  v36 = (int)&unk_107020 + 0x6A * v6;
  v7 = *(_DWORD *)(a1 + 0x4F38);
  v8 = *(_DWORD *)(v5 + 0x68);
  if ( !v7 )
  {
    v9 = *(_BYTE **)(a1 + 0x1D2A);
    *(_WORD *)(a1 + 0x5034) = 2;
    v9 += 0x35;
    *(_DWORD *)(a1 + 0x4F44) = v9;
    *v9 = 7;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 0x12u;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(float *)(a1 + 0x4F80) = *(float *)(v5 + 0x9E);
    *(float *)(a1 + 0x4F84) = *(float *)(v5 + 0xA2);
    *(float *)(a1 + 0x4F88) = *(float *)(v5 + 0xA6);
    v37 = a1 + 4 * v6;
    sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), *(_WORD *)(v37 + 0x1A92), 0);
    v10 = sub_12AE4(a1, v8);
    *(_DWORD *)(a1 + 0x4F48) = v10;
    *(_BYTE *)(v10 + 0x33) |= 0x12u;
    v5 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
    v7 = a1 + 0x4F8C;
    *(float *)(a1 + 0x4F8C) = *(float *)(v8 + 0x9E);
    *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v8 + 0xA2);
    *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v8 + 0xA6);
    v40 = &v19;
    v31 = 0.0;
    v32 = 0.0;
    v33 = 0.0;
    v31 = *(float *)(a1 + 0x4F8C) - *(float *)(a1 + 0x4F80);
    v32 = *(float *)(a1 + 0x4F90) - *(float *)(a1 + 0x4F84);
    v11 = *(float *)(a1 + 0x4F94) - *(float *)(a1 + 0x4F88);
    v19 = v31;
    v33 = v11;
    v20 = v32;
    v21 = v33;
    *(float *)(a1 + 0x4F98) = v31;
    *(float *)(a1 + 0x4F9C) = v20;
    *(float *)(a1 + 0x4FA0) = v21;
    v41 = 0x20 * *(_DWORD *)(v36 + 0x4A);
    v17 = (float)v41;
    sub_53054((float *)(a1 + 0x4F98), v17);
    v25 = 0.0;
    v26 = 0.0;
    v27 = 0.0;
    v34 = &v22;
    v25 = *(float *)(a1 + 0x4F8C) + *(float *)(a1 + 0x4F98);
    v26 = *(float *)(a1 + 0x4F90) + *(float *)(a1 + 0x4F9C);
    v12 = *(float *)(a1 + 0x4F94) + *(float *)(a1 + 0x4FA0);
    v22 = v25;
    v27 = v12;
    v23 = v26;
    v24 = v27;
    *(float *)(a1 + 0x4F98) = v25;
    *(float *)(a1 + 0x4F9C) = v23;
    *(float *)(a1 + 0x4FA0) = v24;
    v13 = v37;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(v13 + 0x1BCE));
  }
  v14 = (float *)(a1 + 0x4F8C);
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    v35 = v18;
    v28 = 0.0;
    v29 = 0.0;
    v30 = 0.0;
    v28 = *(float *)(a1 + 0x4F98) - *v14;
    v29 = *(float *)(a1 + 0x4F9C) - *(float *)(a1 + 0x4F90);
    v30 = *(float *)(a1 + 0x4FA0) - *(float *)(a1 + 0x4F94);
    *(float *)v18 = v28;
    *(float *)&v18[1] = v29;
    *(float *)&v18[2] = v30;
    v15 = sqrt(v29 * v29 + v28 * v28 + v30 * v30) * flt_90308;
    v39 = v15;
    if ( v15 >= dbl_9030C )
    {
      if ( v39 > (double)flt_90314 )
      {
        v39 = 50.0;
      }
    }
    else
    {
      v39 = 3.2;
    }
    if ( sub_12480((float *)(a1 + 0x4F8C), (float *)(a1 + 0x4F98), 0, v5, v39) == 0xFFFFFFFF )
    {
      return 0xFFFFFFFF;
    }
  }
  else
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F44));
    if ( sub_12480((float *)(a1 + 0x4F80), v14, v7, v5, 50.0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
    }
  }
  return v38;
}
// 90308: using guessed type float flt_90308;
// 9030C: using guessed type double dbl_9030C;
// 90314: using guessed type float flt_90314;

//----- (00014B18) --------------------------------------------------------
unsigned int __fastcall sub_14B18(int a1, int a2, int a3)
{
  int v4; // ecx
  char v5; // ah
  int v6; // ecx
  int v7; // ecx
  int v8; // ebp
  int v9; // edi
  _BYTE *v10; // eax
  _DWORD *v11; // ecx
  int v12; // edx
  int v13; // eax
  float *v14; // ecx
  float *v15; // edx
  double v16; // st7
  int v17; // eax
  float *v18; // edx
  int v19; // ebp
  int v20; // eax
  int v22; // edi
  int v23; // ecx
  int v24; // ebx
  int v25; // edx
  int v26; // edx
  double v27; // st7
  int v28; // ecx
  float v29; // [esp+4h] [ebp-228h]
  int v30[107]; // [esp+8h] [ebp-224h] BYREF
  float v31; // [esp+1B4h] [ebp-78h]
  float v32; // [esp+1B8h] [ebp-74h]
  float v33; // [esp+1BCh] [ebp-70h]
  float v34; // [esp+1C0h] [ebp-6Ch]
  float v35; // [esp+1C4h] [ebp-68h]
  float v36; // [esp+1C8h] [ebp-64h]
  float v37; // [esp+1CCh] [ebp-60h] BYREF
  float v38; // [esp+1D0h] [ebp-5Ch]
  float v39; // [esp+1D4h] [ebp-58h]
  float v40; // [esp+1D8h] [ebp-54h] BYREF
  float v41; // [esp+1DCh] [ebp-50h]
  float v42; // [esp+1E0h] [ebp-4Ch]
  float v43; // [esp+1E4h] [ebp-48h]
  float v44; // [esp+1E8h] [ebp-44h]
  float v45; // [esp+1ECh] [ebp-40h]
  int v46; // [esp+1F0h] [ebp-3Ch]
  float *v47; // [esp+1F4h] [ebp-38h]
  float v48; // [esp+1F8h] [ebp-34h]
  float *v49; // [esp+1FCh] [ebp-30h]
  int v50; // [esp+200h] [ebp-2Ch]
  int v51; // [esp+204h] [ebp-28h]
  int v52; // [esp+208h] [ebp-24h]
  float v53; // [esp+20Ch] [ebp-20h]
  char v54; // [esp+210h] [ebp-1Ch]

  v4 = *(_DWORD *)(a1 + 0xAB);
  v50 = 0;
  v5 = *(_BYTE *)(v4 + 0xAB);
  v6 = v4 + 0xAB;
  if ( v5 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x1F9);
  }
  v7 = *(_DWORD *)(v6 + 1);
  v8 = v7;
  v54 = **(_BYTE **)(v7 + 0x63);
  if ( v54 == 0x28 )
  {
    if ( *(_BYTE *)(v7 + 0x67) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x201);
    }
    v8 = *(_DWORD *)(v7 + 0x68);
  }
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    v9 = sub_1D794(*(__int16 **)(v7 + 0x59), v30);
    *(_WORD *)(a1 + 0x5034) = 2;
    *(_DWORD *)(a1 + 0x4F44) = sub_12AE4(a1, v8);
    v10 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
    *(_DWORD *)(a1 + 0x4F48) = v10;
    LOBYTE(a3) = v54;
    *v10 = 0xFF;
    if ( (_BYTE)a3 == 0x28 )
    {
      **(_BYTE **)(a1 + 0x4F48) = 7;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) = 0x12;
      v11 = (_DWORD *)(v7 + 0x9E);
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
      *(_DWORD *)(a1 + 0x4F8C) = *v11;
      *(_DWORD *)(a1 + 0x4F90) = v11[1];
      *(_DWORD *)(a1 + 0x4F94) = v11[2];
      v7 = 0;
      a3 = *(unsigned __int16 *)(a1 + 4 * v54 + 0x1A92);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), a3, 0);
    }
    if ( v9 > 0 )
    {
      a3 = 0;
      v46 = a1 + 0x4F80;
      v52 = 4 * v9;
      do
      {
        if ( *(__int16 *)(a1 + 0x5034) >= 0xF )
        {
          break;
        }
        v12 = *(int *)((char *)v30 + a3);
        if ( *(_BYTE *)(v12 + 0x58) == 4 && v12 != v8 )
        {
          v13 = sub_12AE4(a1, v12);
          *(_BYTE *)(v13 + 0x33) |= 0x12u;
          *(_BYTE *)(v13 + 0x34) = *(_BYTE *)(a1 + 0x5034);
          v14 = *(float **)((char *)v30 + a3);
          v15 = (float *)(a1 + 0x4F80 + 0xC * *(char *)(v13 + 0x34));
          v16 = *(float *)((char *)v14 + 0x9E);
          v14 = (float *)((char *)v14 + 0x9E);
          *v15 = v16;
          v15[1] = v14[1];
          v15[2] = v14[2];
          LOWORD(v15) = *(_WORD *)(a1 + 0x5034);
          *(_WORD *)(a1 + 0x5034) = (_WORD)v15 + 1;
          *(_DWORD *)(a1 + 4 * (__int16)v15 + 0x4F44) = v13;
        }
        v7 = v52;
        a3 += 4;
      }
      while ( a3 < v52 );
    }
    BYTE1(a3) = v54;
    *(_DWORD *)(a1 + 0x4F3C) = 1;
    if ( BYTE1(a3) == 0x28 )
    {
      *(_DWORD *)(a1 + 0x4F3C) = 0;
    }
    v17 = v54;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v17 + 0x1BCE));
    dword_9A238 = 0;
  }
  v18 = (float *)(v8 + 0x9E);
  v19 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v19 )
  {
    if ( v19 == 1 )
    {
      v20 = *(_DWORD *)(a1 + 0x4F44);
      *(_DWORD *)(a1 + 0x4F40) += *(_DWORD *)(a1 + 0x4F38) & 1;
      *(_BYTE *)(v20 + 0x33) |= 4u;
      if ( *(_DWORD *)(a1 + 0x4F40) == 9 )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 2;
        return v50;
      }
    }
    else if ( v19 == 2 )
    {
      v43 = *v18;
      v44 = v18[1];
      v45 = v18[2];
      v22 = a1 + 0x4F80;
      v23 = 2;
      v24 = a1 + 8;
      v48 = (float)*(int *)((char *)&dword_10706A + 0x6A * v54);
      v51 = 0xFFFFFFFF;
      *(float *)&dword_9A238 = *(float *)&dword_9A238 + flt_90334;
      while ( v23 < *(__int16 *)(a1 + 0x5034) )
      {
        v26 = *(char *)(*(_DWORD *)(v24 + 0x4F44) + 0x34);
        v47 = &v37;
        v31 = 0.0;
        v32 = 0.0;
        v33 = 0.0;
        v31 = *(float *)(v22 + 0xC * v26) - v43;
        v32 = *(float *)(v22 + 0xC * v26 + 4) - v44;
        v33 = *(float *)(v22 + 0xC * v26 + 8) - v45;
        v37 = v31;
        v38 = v32;
        v39 = v33;
        v27 = sqrt(v32 * v32 + v31 * v31 + v33 * v33) * flt_90338 + flt_90334;
        v53 = v27;
        if ( v27 < v48 )
        {
          v51 = 0;
        }
        else
        {
          v53 = v48;
        }
        v25 = 0xC * v26;
        v29 = v53 * flt_9033C;
        sub_53054(&v37, v29);
        v49 = &v40;
        v34 = v43 + v37;
        v40 = v34;
        v35 = v44 + v38;
        v41 = v35;
        v36 = v45 + v39;
        v42 = v36;
        *(float *)(v25 + v22) = v34;
        *(float *)(v25 + v22 + 4) = v41;
        v24 += 4;
        ++v23;
        *(float *)(v25 + v22 + 8) = v42;
      }
      if ( *(float *)&dword_9A238 >= (double)v48 || v51 == 0xFFFFFFFF )
      {
        *(_DWORD *)(a1 + 0x4F3C) = 3;
        return v50;
      }
    }
    else
    {
      v28 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
      *(_DWORD *)(a1 + 0x4F40) = v28;
      if ( v28 == 0x12 )
      {
        return 0xFFFFFFFF;
      }
    }
  }
  else
  {
    sub_12618(*(_DWORD *)(a1 + 0x4F48));
    if ( sub_12480((float *)(a1 + 0x4F8C), v18, a3, v7, 10.0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 8u;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
    }
  }
  return v50;
}
// 90334: using guessed type float flt_90334;
// 90338: using guessed type float flt_90338;
// 9033C: using guessed type float flt_9033C;
// 9A238: using guessed type int dword_9A238;
// 10706A: using guessed type int dword_10706A;

//----- (00015078) --------------------------------------------------------
unsigned int __fastcall sub_15078(int a1)
{
  int v2; // edi
  int v3; // esi
  char v4; // ah
  int v5; // edi
  int v6; // edx
  char v7; // bl
  int v8; // eax

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x283);
  }
  v6 = *(_DWORD *)(v5 + 1);
  v7 = **(_BYTE **)(v6 + 0x63);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 1;
    v8 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F44) = v8;
    *(_BYTE *)(v8 + 0x33) |= 4u;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 4 * v7 + 0x1BCE));
  }
  if ( *(_DWORD *)(a1 + 0x4F3C) )
  {
    *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) = *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) + flt_9034E;
    if ( *(float *)(*(_DWORD *)(a1 + 0x4F44) + 0xB) < dbl_90352 )
    {
      return 0xFFFFFFFF;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 0x4F40) += (*(_BYTE *)(a1 + 0x4F38) & 3) == 0;
    if ( *(_DWORD *)(a1 + 0x4F40) == 9 )
    {
      *(_DWORD *)(a1 + 0x4F3C) = 1;
    }
  }
  return v3;
}
// 9034E: using guessed type float flt_9034E;
// 90352: using guessed type double dbl_90352;

//----- (00015164) --------------------------------------------------------
unsigned int __fastcall sub_15164(int a1)
{
  int v2; // ecx
  unsigned int v3; // edi
  char v4; // ah
  int v5; // ecx
  int v6; // ebx
  int v7; // eax
  _BYTE *v8; // eax
  int v9; // ebp
  int v10; // edx

  v2 = *(_DWORD *)(a1 + 0xAB);
  v3 = 0;
  v4 = *(_BYTE *)(v2 + 0xAB);
  v5 = v2 + 0xAB;
  if ( v4 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x2B5);
  }
  v6 = *(_DWORD *)(v5 + 1);
  if ( !*(_DWORD *)(a1 + 0x4F38) )
  {
    *(_WORD *)(a1 + 0x5034) = 2;
    v7 = sub_12AE4(a1, v6);
    *(_DWORD *)(a1 + 0x4F44) = v7;
    *(_BYTE *)(v7 + 0x33) |= 4u;
    v8 = (_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + 0x35);
    *(_DWORD *)(a1 + 0x4F48) = v8;
    *v8 = 0xFF;
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    *(_DWORD *)(a1 + 0x4F40) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 0x1CEE));
  }
  v9 = *(_DWORD *)(a1 + 0x4F3C);
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618(*(_DWORD *)(a1 + 0x4F48)) == 0xFFFFFFFF )
      {
        v3 = 0xFFFFFFFF;
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0x4F48) + 0xB) = 0x40A00000;
    }
  }
  else
  {
    v10 = (*(_DWORD *)(a1 + 0x4F38) & 1) + *(_DWORD *)(a1 + 0x4F40);
    *(_DWORD *)(a1 + 0x4F40) = v10;
    if ( v10 == 9 )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 8u;
      **(_BYTE **)(a1 + 0x4F48) = 7;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x33) |= 0x10u;
      *(_BYTE *)(*(_DWORD *)(a1 + 0x4F48) + 0x34) = 1;
      *(float *)(a1 + 0x4F8C) = *(float *)(v6 + 0x9E);
      *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v6 + 0xA2);
      *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v6 + 0xA6);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F48), *(_WORD *)(a1 + 0x1BB2), 0);
      *(_DWORD *)(*(_DWORD *)(a1 + 0x4F48) + 0xB) = 0x40A00000;
      *(_DWORD *)(a1 + 0x4F3C) = 1;
      return 0;
    }
  }
  return v3;
}

//----- (000152E4) --------------------------------------------------------
unsigned int __fastcall sub_152E4(int a1, int a2, int a3, int a4)
{
  int v5; // esi
  char v6; // ah
  int v7; // esi
  int v8; // ebx
  _BYTE *v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // esi
  int v13; // edx
  unsigned int v14; // eax
  int v15; // ebp
  int v16; // edx
  int v17; // ebx
  _BYTE *v18; // eax
  int v20; // eax
  unsigned __int16 v21; // si
  char v22; // al
  int v23; // eax
  int v24[107]; // [esp+0h] [ebp-1DCh] BYREF
  int v25; // [esp+1ACh] [ebp-30h]
  int v26; // [esp+1B0h] [ebp-2Ch]
  int v27; // [esp+1B4h] [ebp-28h]
  int v28; // [esp+1B8h] [ebp-24h]
  int v29; // [esp+1BCh] [ebp-20h]
  char v30; // [esp+1C0h] [ebp-1Ch]

  v5 = *(_DWORD *)(a1 + 0xAB);
  v26 = 0;
  v6 = *(_BYTE *)(v5 + 0xAB);
  v7 = v5 + 0xAB;
  if ( v6 != 3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batfxa.cpp", 0x2FA);
  }
  v27 = *(_DWORD *)(v7 + 1);
  v8 = *(_DWORD *)(a1 + 0x4F38);
  v30 = 0x26;
  v25 = (int)&unk_107020 + 0xFBC;
  if ( !v8 )
  {
    v8 = 0;
    *(_WORD *)(a1 + 0x5034) = 1;
    v9 = *(_BYTE **)(a1 + 0x1D2A);
    *(_DWORD *)(a1 + 0x4F44) = v9;
    *v9 = 0xFF;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x33) |= 0x12u;
    v10 = v27 + 0x9E;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x4F44) + 0x34) = 0;
    *(_DWORD *)(a1 + 0x4F80) = *(_DWORD *)v10;
    a4 = *(_DWORD *)(v10 + 4);
    *(_DWORD *)(a1 + 0x4F84) = a4;
    *(float *)(a1 + 0x4F88) = *(float *)(v10 + 8);
    *(_DWORD *)(a1 + 0x4F3C) = 0;
    sub_4FB90((int)&unk_10914C, *(_WORD *)(a1 + 0x1C66));
  }
  if ( **(_BYTE **)(a1 + 0x4F44) == 0xFF )
  {
    v11 = sub_1D794(*(__int16 **)(v27 + 0x59), v24);
    v12 = (unsigned __int8)*(_DWORD *)(a1 + 0x4F3C);
    v13 = v11;
    if ( v12 < v11 )
    {
      v14 = 4 * v12;
      v15 = *(__int16 *)(v27 + 0x56);
      v28 = 4 * v13;
      while ( 1 )
      {
        v16 = v24[v14 / 4];
        v8 = *(__int16 *)(v16 + 0x56);
        if ( *(_BYTE *)(v16 + 0x58) == 4 && v15 != v8 && byte_A3132[0x1EE * v15 + v8] == 2 )
        {
          break;
        }
        a4 = v28;
        v14 += 4;
        ++v12;
        if ( (int)v14 >= v28 )
        {
          goto LABEL_15;
        }
      }
      *(_WORD *)(a1 + 0x5034) = 2;
      v17 = v24[v14 / 4];
      *(_DWORD *)(a1 + 0x4F8C) = *(_DWORD *)(v17 + 0x9E);
      *(_DWORD *)(a1 + 0x4F90) = *(_DWORD *)(v17 + 0xA2);
      *(_DWORD *)(a1 + 0x4F94) = *(_DWORD *)(v17 + 0xA6);
      **(_BYTE **)(a1 + 0x4F44) = 7;
      a4 = 0;
      *(_DWORD *)(a1 + 0x4F48) = sub_12AE4(a1, v24[v14 / 4]);
      v8 = *(unsigned __int16 *)(a1 + 4 * v30 + 0x1A92);
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v8, 0);
      *(_DWORD *)(a1 + 0x4F3C) = v12 + 1;
    }
LABEL_15:
    if ( **(_BYTE **)(a1 + 0x4F44) == 0xFF )
    {
      v26 = 0xFFFFFFFF;
    }
  }
  v18 = *(_BYTE **)(a1 + 0x4F44);
  if ( *v18 == 0xFF )
  {
    return 0xFFFFFFFF;
  }
  if ( (*(_BYTE *)(a1 + 0x4F3D) & 1) != 0 )
  {
    if ( (*(_BYTE *)(a1 + 0x4F38) & 3) == 0 && sub_12618((int)v18) == 0xFFFFFFFF )
    {
      **(_BYTE **)(a1 + 0x4F44) = 0xFF;
      *(_DWORD *)(a1 + 0x4F3C) = (unsigned __int8)*(_DWORD *)(a1 + 0x4F3C);
      return v26;
    }
  }
  else
  {
    sub_12618((int)v18);
    if ( sub_12480((float *)(a1 + 0x4F80), (float *)(a1 + 0x4F8C), v8, a4, 50.0) == 0xFFFFFFFF )
    {
      v20 = *(_DWORD *)(a1 + 0x4F48);
      LOWORD(v29) = 1;
      v21 = 4;
      v22 = sub_4B7A0(*(_DWORD *)(v20 + 1), 0, *(_DWORD *)(v25 + 0x4A), *(_WORD *)(v27 + 0x56));
      if ( (v22 & 4) != 0 )
      {
        v23 = *(_DWORD *)(a1 + 0x4F48);
        LOWORD(v29) = 5;
        v21 = 5;
        *(_BYTE *)(v23 + 0x33) |= 8u;
      }
      else if ( (v22 & 2) != 0 )
      {
        v21 = *(_WORD *)(a1 + 4 * v30 + 0x1A94);
        LOWORD(v29) = *(_WORD *)(a1 + 4 * v30 + 0x1BD0);
      }
      sub_1826C(a1, *(_DWORD *)(a1 + 0x4F44), v21, 0);
      sub_4FB90((int)&unk_10914C, v29);
      *(_BYTE *)(a1 + 0x4F3D) |= 1u;
    }
  }
  return v26;
}

//----- (00015630) --------------------------------------------------------
void __fastcall sub_15630(int a1, int a2)
{
  int v3; // eax
  void *v4; // eax
  LONG v5; // [esp-20h] [ebp-30h]
  LONG v6; // [esp-1Ch] [ebp-2Ch]
  LONG v7; // [esp-18h] [ebp-28h]
  LONG v8; // [esp-8h] [ebp-18h]

  v3 = *(_DWORD *)(a1 + 0x4F40);
  if ( v3 > 9 )
  {
    v3 = 0x12 - v3;
  }
  if ( v3 >= 0 )
  {
    if ( v3 > 9 )
    {
      v3 = 9;
    }
  }
  else
  {
    v3 = 0;
  }
  VFX_shape_lookaside((UBYTE *)((v3 << 8) + 0xB00 + dword_D8D8F));
  v8 = *(_DWORD *)(a2 + 0xF);
  v7 = *(__int16 *)(a2 + 0x29);
  v6 = *(__int16 *)(a2 + 0x27);
  v5 = *(_DWORD *)(a2 + 7);
  v4 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a2 + 5));
  VFX_shape_transform((PANE *)(a1 + 4), v4, v5, v6, v7, buffer, 0, v8, v8, 1);
}
// D8D8F: using guessed type int dword_D8D8F;
// D8DA0: using guessed type UBYTE buffer[94816];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (000156C0) --------------------------------------------------------
int __fastcall sub_156C0(int a1, int a2, unsigned __int16 a3)
{
  void *v4; // ebp
  int result; // eax
  LONG v6; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+4h] [ebp-20h]
  int v8; // [esp+8h] [ebp-1Ch]
  int v9; // [esp+Ch] [ebp-18h]
  int v10; // [esp+10h] [ebp-14h]

  v10 = a2;
  *(_DWORD *)(a1 + 0xB) = 0x3F800000;
  v4 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v10);
  if ( a3 >= VFX_shape_count(v4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x38);
  }
  VFX_shape_visible_rectangle(v4, a3, 0, 0, 0, &v6);
  if ( v6 > (int)&unk_F4240 || v6 < (int)0xFFF0BDC0 )
  {
    memset(&v6, 0, 0x10u);
  }
  *(_WORD *)(a1 + 0x13) = v6;
  *(_WORD *)(a1 + 0x15) = v7;
  *(_WORD *)(a1 + 0x17) = v8;
  *(_WORD *)(a1 + 0x19) = v9;
  *(_WORD *)(a1 + 5) = v10;
  result = a3;
  *(_DWORD *)(a1 + 7) = a3;
  return result;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0001577C) --------------------------------------------------------
int __fastcall sub_1577C(int a1)
{
  sub_15788(a1);
  return a1;
}

//----- (00015788) --------------------------------------------------------
int __fastcall sub_15788(int result)
{
  *(_DWORD *)(result + 0x800) = 0;
  return result;
}

//----- (00015794) --------------------------------------------------------
int __fastcall sub_15794(int result, int a2)
{
  int v2; // ebx

  v2 = *(_DWORD *)(result + 0x800);
  if ( v2 < 0x200 )
  {
    if ( a2 )
    {
      *(_DWORD *)(result + 4 * v2) = a2;
      ++*(_DWORD *)(result + 0x800);
    }
  }
  return result;
}

//----- (000157B4) --------------------------------------------------------
int __fastcall sub_157B4(const void *a1, const void *a2)
{
  int v2; // edx
  float v4; // [esp+0h] [ebp-8h]
  float v5; // [esp+4h] [ebp-4h]

  v5 = *(float *)(*(_DWORD *)a1 + 0x2F);
  v4 = *(float *)(*(_DWORD *)a2 + 0x2F);
  v2 = 0;
  if ( v5 > (double)v4 )
  {
    return 0xFFFFFFFF;
  }
  if ( v5 < (double)v4 )
  {
    return 1;
  }
  return v2;
}

//----- (000157EC) --------------------------------------------------------
void __fastcall sub_157EC(size_t *a1)
{
  qsort(a1, a1[0x200], 4u, sub_157B4);
}

//----- (00015808) --------------------------------------------------------
char *__fastcall sub_15808(int a1, int a2, int a3)
{
  int v3; // edi
  char **v4; // esi
  char *v5; // ecx
  float v7; // [esp+Ch] [ebp-24h]
  float v8; // [esp+10h] [ebp-20h]
  float v9; // [esp+18h] [ebp-18h]
  float v10; // [esp+1Ch] [ebp-14h]
  float v11; // [esp+20h] [ebp-10h]

  v3 = *(_DWORD *)(a1 + 0x800) - 1;
  v4 = (char **)(a1 + 4 * v3);
  while ( (v3 & 0x8000u) == 0 )
  {
    if ( !v4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x9E);
    }
    v5 = *v4;
    if ( **v4 >= 9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0xA2);
    }
    if ( *v5 == 5 )
    {
      if ( (*(__int16 *)(v5 + 0x27) - a2) * (*(__int16 *)(v5 + 0x27) - a2)
         + (*(__int16 *)(v5 + 0x29) - a3) * (*(__int16 *)(v5 + 0x29) - a3) < 0x50 )
      {
        return *v4;
      }
    }
    else if ( *v5 != 4 )
    {
      v8 = (double)*(unsigned int *)(v5 + 0xF) * flt_903A5;
      v7 = (float)*(__int16 *)(v5 + 0x27);
      v9 = (float)a2;
      if ( (double)*(__int16 *)(v5 + 0x13) * v8 + v7 <= v9 )
      {
        v11 = (float)*(__int16 *)(v5 + 0x29);
        v10 = (float)a3;
        if ( (double)*(__int16 *)(v5 + 0x15) * v8 + v11 <= v10
          && (double)*(__int16 *)(v5 + 0x17) * v8 + v7 >= v9
          && (double)*(__int16 *)(v5 + 0x19) * v8 + v11 >= v10 )
        {
          return *v4;
        }
      }
    }
    LOWORD(v3) = v3 - 1;
    v4 += 0xFFFFFFFF;
  }
  return 0;
}
// 903A5: using guessed type float flt_903A5;

//----- (00015948) --------------------------------------------------------
int __fastcall sub_15948(int a1, int a2)
{
  PANE *v2; // ebp
  unsigned int v3; // eax
  LONG v4; // eax
  int v5; // edx
  int v6; // edi
  __int64 v7; // rax
  double v8; // st7
  void *v9; // eax
  double v10; // st6
  int result; // eax
  _BYTE *v12; // esi
  LONG v13; // [esp-20h] [ebp-88h]
  LONG v14; // [esp-1Ch] [ebp-84h]
  LONG v15; // [esp-18h] [ebp-80h]
  LONG v16; // [esp-8h] [ebp-70h]
  int v17; // [esp-4h] [ebp-6Ch]
  int v19; // [esp+Ch] [ebp-5Ch]
  int v20; // [esp+18h] [ebp-50h]
  float v22; // [esp+20h] [ebp-48h]
  int v23; // [esp+24h] [ebp-44h]
  _BYTE **v24; // [esp+2Ch] [ebp-3Ch]
  int v25; // [esp+30h] [ebp-38h]
  __int16 v26; // [esp+40h] [ebp-28h]
  int v27; // [esp+4Ah] [ebp-1Eh]

  v24 = (_BYTE **)a1;
  v26 = 0;
  v2 = (PANE *)(a2 + 4);
  while ( 1 )
  {
    result = v26;
    if ( v26 >= *(_DWORD *)(a1 + 0x800) )
    {
      break;
    }
    v12 = *v24;
    if ( (**v24 != 4 || *(_DWORD *)(a2 + 0x504A)) && *v12 != 0xFF )
    {
      if ( *(_DWORD *)(v12 + 0x23) && (*(_DWORD *)(a2 + 0x5042) || *v12 == 6) && (v12[0x33] & 2) == 0 )
      {
        v3 = 0xFFFFFFFF;
      }
      else
      {
        v3 = 0;
      }
      if ( v3 )
      {
        v4 = 0x72;
        if ( *(_DWORD *)(v12 + 0x1F) )
        {
          v4 = 0x90;
        }
        if ( *v12 == 6 && *(_BYTE *)(a2 + 0xB7) == 3 )
        {
          v4 = 0xF3;
        }
        VFX_line_draw(
          v2,
          *(__int16 *)(v12 + 0x2B),
          *(__int16 *)(v12 + 0x2D),
          *(__int16 *)(v12 + 0x27),
          *(__int16 *)(v12 + 0x29),
          0,
          v4);
      }
      if ( (v12[0x33] & 8) == 0 )
      {
        if ( (v12[0x33] & 4) != 0 )
        {
          sub_139E0(a2, (int)v12);
        }
        else
        {
          v5 = *(unsigned __int16 *)(v12 + 5);
          if ( (unsigned __int16)v5 != 0xFFFF )
          {
            if ( *v12 == 8 )
            {
              v25 = v12[0x33] & 4;
              v6 = *(_DWORD *)(v12 + 1);
              v23 = v25;
              v7 = *(__int16 *)(v12 + 0x27) - *(__int16 *)(v6 + 0x27);
              v19 = (HIDWORD(v7) ^ v7) - HIDWORD(v7);
              if ( 2 * v19 )
              {
                v8 = flt_903AD / (double)(2 * v19);
                v25 = (int)((double)v19 * v8 + dbl_903B1);
                v23 = (int)(v8 * (double)v19 + dbl_903B1);
              }
              VFX_line_draw(
                v2,
                v25 + *(__int16 *)(v12 + 0x27),
                v23 + *(__int16 *)(v12 + 0x29),
                v25 + *(__int16 *)(v6 + 0x27),
                v23 + *(__int16 *)(v6 + 0x29),
                0,
                0x6A);
              VFX_line_draw(
                v2,
                *(__int16 *)(v12 + 0x27) - v25,
                *(__int16 *)(v12 + 0x29) - v23,
                *(__int16 *)(v6 + 0x27) - v25,
                *(__int16 *)(v6 + 0x29) - v23,
                0,
                0x6A);
              VFX_line_draw(
                v2,
                *(__int16 *)(v12 + 0x27),
                *(__int16 *)(v12 + 0x29),
                *(__int16 *)(v6 + 0x27),
                *(__int16 *)(v6 + 0x29),
                0,
                0x6D);
            }
            else
            {
              v17 = v12[0x33] & 4;
              v16 = *(_DWORD *)(v12 + 0xF);
              v15 = *(__int16 *)(v12 + 0x29);
              v14 = *(__int16 *)(v12 + 0x27);
              v13 = *(_DWORD *)(v12 + 7);
              v9 = (void *)sub_1B084((unsigned int)dword_12FC20, v5);
              VFX_shape_transform(v2, v9, v13, v14, v15, buffer, v17, v16, v16, v17);
            }
          }
        }
      }
      v22 = (double)*(unsigned int *)(v12 + 0xF) * flt_903A9;
      if ( *v12 == 1 && sub_361B8(*(_DWORD *)(v12 + 1)) == 0xFFFFFFFF )
      {
        v20 = (int)((double)*(__int16 *)(v12 + 0x17) * v22 + flt_903B9);
        VFX_ellipse_draw(
          v2,
          *(__int16 *)(v12 + 0x27),
          *(__int16 *)(v12 + 0x29),
          (__int16)v20,
          (__int16)v20,
          4 * (unsigned __int8)byte_A2F74[0x1EE * *(unsigned __int8 *)(*(_DWORD *)(v12 + 1) + 0x57)] + 0x13);
      }
      if ( v12 == *(_BYTE **)(a2 + 0xB3) )
      {
        v10 = (double)*(__int16 *)(v12 + 0x27);
        HIWORD(v27) = (int)((double)*(__int16 *)(v12 + 0x13) * v22 + v10);
        sub_2BB74(
          (int **)v2,
          (int *)(v27 >> 0x10),
          (int *)(__int16)(int)((double)*(__int16 *)(v12 + 0x15) * v22 + (double)*(__int16 *)(v12 + 0x29)),
          (int *)(__int16)(int)(v10 + (double)*(__int16 *)(v12 + 0x17) * v22),
          (int *)(__int16)(int)(v22 * (double)*(__int16 *)(v12 + 0x19) + (double)*(__int16 *)(v12 + 0x29)),
          0xF3u,
          0);
      }
    }
    ++v26;
    ++v24;
  }
  return result;
}
// 15C73: variable 'v27' is possibly undefined
// 903A9: using guessed type float flt_903A9;
// 903AD: using guessed type float flt_903AD;
// 903B1: using guessed type double dbl_903B1;
// 903B9: using guessed type float flt_903B9;
// D8DA0: using guessed type UBYTE buffer[94816];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00015D20) --------------------------------------------------------
int __fastcall sub_15D20(int a1)
{
  sub_15D2C(a1);
  return a1;
}

//----- (00015D2C) --------------------------------------------------------
int __fastcall sub_15D2C(int result)
{
  *(_DWORD *)(result + 0x1900) = 0;
  return result;
}

//----- (00015D38) --------------------------------------------------------
int __fastcall sub_15D38(int result, const void *a2)
{
  int v2; // ebx
  int v4; // edx

  v2 = result;
  v4 = *(_DWORD *)(result + 0x1900);
  if ( v4 < 0x40 )
  {
    result = 0x64 * v4;
    qmemcpy((void *)(v2 + 0x64 * v4), a2, 0x64u);
    ++*(_DWORD *)(v2 + 0x1900);
  }
  return result;
}

//----- (00015D74) --------------------------------------------------------
int __fastcall sub_15D74(int result, int a2)
{
  int v2; // esi
  int i; // ecx

  v2 = result;
  for ( i = 0; i < *(_DWORD *)(v2 + 0x1900); ++i )
  {
    result = sub_15DA4(v2, a2, i);
  }
  return result;
}

//----- (00015DA4) --------------------------------------------------------
int __fastcall sub_15DA4(int result, int a2, unsigned __int16 a3)
{
  int v4; // edx
  int v5; // ecx
  int v6; // eax

  if ( a3 < *(int *)(result + 0x1900) )
  {
    v4 = result + 0x64 * a3;
    v5 = *(_DWORD *)(v4 + 0x60);
    if ( v5 < 0 || v5 >= 7 )
    {
      v6 = 0;
    }
    else
    {
      v6 = (unsigned __int8)byte_A2F74[0x1EE * v5] + 1;
    }
    return sub_62DA5((_DWORD *)(a2 + 4), 4, v4, (v6 << 8) + 0x1F00 + *(_DWORD *)(a2 + 0x19BE));
  }
  return result;
}

//----- (00015E1C) --------------------------------------------------------
void __fastcall sub_15E1C(int *a1, int a2)
{
  int *v2; // ebp
  int v3; // eax
  LONG *v4; // esi
  int j; // edi
  LONG v6; // [esp-18h] [ebp-3Ch]
  LONG v7; // [esp-14h] [ebp-38h]
  int i; // [esp+4h] [ebp-20h]
  int parm; // [esp+Ch] [ebp-18h]

  v2 = a1;
  for ( i = 0; i < a1[0x640]; ++i )
  {
    v3 = v2[0x18];
    if ( v3 < 0 || v3 >= 7 )
    {
      parm = 0x6D;
    }
    else
    {
      parm = 4 * (unsigned __int8)byte_A2F74[0x1EE * v3] + 0x13;
    }
    v4 = v2;
    for ( j = 0; j < 4; VFX_line_draw((PANE *)(a2 + 4), v6, v7, v2[6 * (j & 3)], v2[6 * (j & 3) + 1], 0, parm) )
    {
      ++j;
      v7 = v4[1];
      v6 = *v4;
      v4 += 6;
    }
    v2 += 0x19;
  }
  JUMPOUT(0x15ED0);
}
// 15ECF: control flows out of bounds to 15ED0

//----- (00015ED4) --------------------------------------------------------
int __fastcall sub_15ED4(T_TypeA2 *a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // edx

  sub_2C830(a1);
  v1 = _wcpp_2_ctor_array_(&a1[1].a.c[0xB], 0x64, &unk_959D8);
  v2 = _wcpp_2_ctor_array_(v1 + 0x4B0, 0x64, &unk_95A3C);
  v3 = (_DWORD *)(_wcpp_2_ctor_array_(v2 + 0xFA0, 0x64, &unk_959D8) + 0x7FC);
  *v3 = 0;
  v3 += 5;
  v3[0xFFFFFFFC] = 0;
  v3[0xFFFFFFFD] = 0;
  v3[1] = 0;
  v3[2] = 0;
  *v3 = 0;
  v4 = sub_1577C((int)(v3 + 6));
  v5 = sub_1577C(v4 + 0x804);
  v6 = sub_1577C(v5 + 0x804);
  v7 = sub_15D20(v6 + 0x804);
  v8 = sub_1B4F0((_DWORD *)(v7 + 0x1904)) + 0x26;
  *v8 = 0;
  v8 += 3;
  v8[0xFFFFFFFE] = 0;
  v8[0xFFFFFFFF] = 0;
  *v8 = 0;
  v8 += 3;
  v8[0xFFFFFFFE] = 0;
  v8[0xFFFFFFFF] = 0;
  *v8 = 0;
  v8 += 3;
  v8[0xFFFFFFFE] = 0;
  v8[0xFFFFFFFF] = 0;
  *v8 = 0;
  v8 += 0xFFFFFFFA;
  v8[7] = 0;
  v8[8] = 0;
  v8[1] = 0;
  v8[2] = 0;
  *v8 = 0x3F800000;
  v8[3] = 0;
  v8[4] = 0x3F800000;
  v8[5] = 0;
  v8[6] = 0;
  v8[7] = 0;
  v8[8] = 0x3F800000;
  v9 = _wcpp_2_ctor_array_((char *)v8 + 0x96, 0xF, &unk_959D8) - 0x4F80;
  *(_DWORD *)(v9 + 0xA7) = off_95A50;
  sub_16120(v9);
  return v9;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 95A50: using guessed type int (*off_95A50[6])();

//----- (0001604C) --------------------------------------------------------
int __fastcall sub_1604C(int a1, char a2)
{
  void *v4; // eax
  void *v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  void *v16; // eax
  void *v17; // ebx

  if ( (a2 & 4) != 0 )
  {
    v4 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95A28);
    operator delete[](v4);
    return a1;
  }
  else
  {
    v6 = *(void **)(a1 + 0x19BE);
    *(_DWORD *)(a1 + 0xA7) = off_95A50;
    if ( v6 )
    {
      sub_2627C(v6);
    }
    operator delete[](*(void **)(a1 + 0x19BE));
    v7 = sub_1A9C0(a1 + 0x4F80);
    v8 = ((int (__fastcall *)(int, _DWORD))locret_1B66C)(v7 - 0x13A, 0);
    v9 = sub_15D2C(v8 - 0x1904);
    v10 = sub_15788(v9 - 0x804);
    v11 = sub_15788(v10 - 0x804);
    v12 = sub_15788(v11 - 0x804);
    v13 = sub_1A9E0(v12 - 0x828);
    v14 = sub_1AA00(v13 - 0xFA0);
    v15 = sub_1A9E0(v14 - 0x4B0);
    v16 = (void *)sub_2C848(v15 - 0xBE, 1);
    v17 = v16;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v16);
    }
    return (int)v17;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95A50: using guessed type int (*off_95A50[6])();

//----- (00016120) --------------------------------------------------------
int __fastcall sub_16120(int a1)
{
  int v1; // ebp
  int v2; // edx
  FILE *v3; // eax
  FILE *v4; // ecx
  int v5; // eax
  int v6; // edi
  int v7; // esi
  _WORD *v8; // ebx
  char s[200]; // [esp+0h] [ebp-12Ch] BYREF
  char v11[60]; // [esp+C8h] [ebp-64h] BYREF
  int v12; // [esp+104h] [ebp-28h] BYREF
  int v13; // [esp+108h] [ebp-24h] BYREF
  int v14; // [esp+10Ch] [ebp-20h] BYREF
  int v15; // [esp+110h] [ebp-1Ch] BYREF

  v1 = a1;
  *(_DWORD *)(a1 + 0xAB) = 0;
  *(_DWORD *)(a1 + 0x1D2A) = 0;
  v2 = a1 + 0x190;
  *(_DWORD *)(a1 + 0x19BE) = 0;
  do
  {
    a1 += 4;
    *(_DWORD *)(a1 + 0x137A) = 0;
  }
  while ( a1 != v2 );
  *(_DWORD *)(v1 + 0x1D1E) = 0;
  *(_DWORD *)(v1 + 0x1D22) = 0;
  *(_DWORD *)(v1 + 0x1D26) = 0;
  *(_DWORD *)(v1 + 0xB3) = 0;
  *(_DWORD *)(v1 + 0xAF) = 0;
  *(_BYTE *)(v1 + 0xB7) = 0;
  *(_BYTE *)(v1 + 0x4F2E) = 0;
  *(_DWORD *)(v1 + 0xB8) = 2;
  *(_WORD *)(v1 + 0xBC) = 0xFFFF;
  *(_DWORD *)(v1 + 0x4F2F) = 0;
  *(_DWORD *)(v1 + 0x4F33) = 0;
  *(_DWORD *)(v1 + 0x503A) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0x5042) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0x5046) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0x504A) = 0xFFFFFFFF;
  v3 = sub_1BB10("batfx.txt", 0);
  v4 = v3;
  if ( !v3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x1E4);
  }
  Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v3, s);
  sscanf(s, "%d", &v12);
  v5 = v12;
  *(_DWORD *)(v1 + 0x1A8E) = v12;
  if ( v5 >= 0x64 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x1EA);
  }
  v6 = 0;
  if ( *(int *)(v1 + 0x1A8E) > 0 )
  {
    v7 = v1;
    do
    {
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v4, s);
      sscanf(s, "%s", v11);
      *(_WORD *)(v7 + 0x19C6) = sub_1B270((int)dword_12FC20, v11, 0xFFFFFFFF);
      ++v6;
      v7 += 2;
    }
    while ( v6 < *(_DWORD *)(v1 + 0x1A8E) );
  }
  v8 = (_WORD *)v1;
  do
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v4, s);
    sscanf(s, "%d %d %d %d", &v12, &v13, &v14, &v15);
    v8[0xD49] = v12;
    v8[0xD4A] = v13;
    v8[0xDE7] = v14;
    v8 += 2;
    v8[0xDE6] = v15;
  }
  while ( v8 != (_WORD *)(v1 + 0x13C) );
  return fclose(v4);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 16120: using guessed type char var_64[60];

//----- (00016348) --------------------------------------------------------
int __fastcall sub_16348(int a1, unsigned __int16 a2, int a3, signed int a4)
{
  int result; // eax
  int v7; // edx
  char v8; // ah
  int v9; // ebx
  int v10; // edx
  int v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // edx
  int v15; // eax
  int v16; // ebx
  signed int v17; // esi
  int v18; // edi
  int v19; // ecx
  char v20; // ah
  char *v21; // edx
  char v22; // bl
  char v23; // al
  LONG v24; // edi
  int v25; // eax
  char v26; // ah
  char v27; // ch
  char v28; // bl
  char v29; // dl
  int v30; // edx
  char v31; // cl
  int v32; // edx
  int v33; // ecx
  int v34; // eax
  int v35; // edx
  int v36; // ebx
  int v37; // eax
  int v38; // eax
  int v39; // [esp-4h] [ebp-24h]
  int v40; // [esp-4h] [ebp-24h]
  _BYTE v41[5]; // [esp+8h] [ebp-18h]
  int v42; // [esp+10h] [ebp-10h]

  v42 = a3;
  if ( a2 < 0x3Au )
  {
    if ( a2 >= 6u )
    {
      if ( a2 <= 6u )
      {
        sub_5A270(&V_Type3_stru_10AE70, 0, 0, 0);
        sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 8);
        return 0xFFFFFFFF;
      }
      if ( a2 < 0xDu )
      {
        if ( a2 <= 7u )
        {
          if ( !*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x3B7);
          }
          sub_17260(a1);
          sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
          return 0xFFFFFFFF;
        }
        if ( a2 != 8 )
        {
          return sub_2F424(a1, a2, a3, a4);
        }
        if ( *(_BYTE *)(a1 + 0xB7) != 4 )
        {
          v15 = a3;
          v16 = *(_DWORD *)(a1 + 8);
          if ( v15 < v16
            || v15 > *(_DWORD *)(a1 + 0x10)
            || (v17 = *(_DWORD *)(a1 + 0xC), a4 < v17)
            || a4 > *(_DWORD *)(a1 + 0x14) )
          {
            *(_DWORD *)(a1 + 0xAF) = 0;
            *(_DWORD *)(a1 + 0x1D0E) = 0x49742400;
            sub_18C2C(a1, 0);
            return 0;
          }
          if ( !*(_DWORD *)(a1 + 0x4F2F) )
          {
            v18 = a4 - v17;
            v19 = v42 - v16;
            sub_17204(a1, v42 - v16, v18);
            if ( !*(_DWORD *)(a1 + 0xAF) )
            {
              v20 = *(_BYTE *)(a1 + 0xB7);
              if ( v20 == 2 )
              {
                sub_16FC0(a1, v19, v18, v19);
              }
              else if ( v20 == 3 )
              {
                sub_171D0(a1, v19, v18);
              }
            }
            sub_18C2C(a1, 0);
            if ( *(_BYTE *)(a1 + 0xB7) == 1 )
            {
              v21 = *(char **)(a1 + 0xAF);
              if ( v21 )
              {
                v22 = *v21;
                v23 = 0;
                if ( *v21 == 2 )
                {
                  v23 = 3;
                }
                else if ( v22 == 3 )
                {
                  v23 = 4;
                }
                else if ( v22 == 1 )
                {
                  v23 = 2;
                }
                v24 = 0x6B;
                if ( sub_56D30(
                       (int)&V_Type3_stru_10AE70,
                       *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
                       0x322,
                       v23,
                       *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1)) == 0xFFFFFFFF )
                {
                  v24 = 0xF3;
                }
                VFX_line_draw(
                  (PANE *)(a1 + 4),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xB3) + 0x27),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xB3) + 0x29),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xAF) + 0x27),
                  *(__int16 *)(*(_DWORD *)(a1 + 0xAF) + 0x29),
                  0,
                  v24);
                return 0;
              }
            }
          }
        }
      }
      else
      {
        if ( a2 > 0xDu )
        {
          if ( a2 < 0x32u || a2 > 0x33u && (a2 < 0x36u || a2 > 0x37u) )
          {
            return sub_2F424(a1, a2, a3, a4);
          }
          if ( *(_DWORD *)(a1 + 0x39) != 0xFFFFFFFF )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x2E5);
          }
          v25 = 0;
          if ( a2 == 0x32 )
          {
            v26 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v26 & 1) != 0 )
            {
              if ( (v26 & 2) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v26 & 0xFD;
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v26 & 0xFE;
                sub_18C2C(a1, 0);
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v26 & 0xFC | 1;
            }
            v25 = 3;
          }
          if ( a2 == 0x33 )
          {
            v27 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v27 & 1) != 0 )
            {
              if ( (v27 & 2) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v27 & 0xFE;
                sub_18C2C(a1, 0);
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v27 | 2;
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v27 | 3;
            }
            v25 = 3;
          }
          if ( a2 == 0x36 )
          {
            v28 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v28 & 4) != 0 )
            {
              if ( (v28 & 8) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v28 & 0xF7;
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v28 & 0xFB;
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v28 & 0xF3 | 4;
            }
            v25 = 0xC;
          }
          if ( a2 == 0x37 )
          {
            v29 = *(_BYTE *)(a1 + 0x4F2F);
            if ( (v29 & 4) != 0 )
            {
              if ( (v29 & 8) != 0 )
              {
                *(_BYTE *)(a1 + 0x4F2F) = v29 & 0xFB;
              }
              else
              {
                *(_BYTE *)(a1 + 0x4F2F) = v29 | 8;
              }
            }
            else
            {
              *(_BYTE *)(a1 + 0x4F2F) = v29 | 0xC;
            }
            v25 = 0xC;
          }
          if ( v42 == 4 )
          {
            sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 1, 0x3B, v25, 0);
          }
          return 0xFFFFFFFF;
        }
        if ( *(_BYTE *)(a1 + 0xB7) != 4 )
        {
          sub_187EC(a1);
          sub_18C2C(a1, 0);
          return 0;
        }
      }
      return 0;
    }
    if ( a2 < 3u )
    {
      if ( !a2 )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      if ( a2 <= 1u )
      {
        *(_DWORD *)(a1 + 0xAB) = sub_56DA8((int)&V_Type3_stru_10AE70, "BatControlWnd", 0);
        v7 = *(_DWORD *)(a1 + 0x41);
        sub_56400(&V_Type3_stru_10AE70, v7, 0x3A, 0, 0, 0);
        sub_186B8(a1, v7, a3);
        sub_2F424(a1, a2, a3, a4);
        *(_DWORD *)(a1 + 0x4F2F) = 0;
        return 0;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 0xB7) == 4 )
        {
          sub_12238(*(_DWORD *)(a1 + 0xAB), 0);
        }
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        sub_185CC(a1);
        sub_2F424(a1, a2, a3, a4);
        return 0;
      }
    }
    if ( a2 <= 3u )
    {
      if ( (unsigned int)a4 < 0xD )
      {
        if ( a4 != 0xC )
        {
          return 0;
        }
        if ( flt_12FC1C > dbl_9043E )
        {
          flt_12FC1C = flt_12FC1C * dbl_90446;
          return 0;
        }
      }
      else if ( (unsigned int)a4 <= 0xD )
      {
        if ( flt_12FC1C < (double)flt_90432 )
        {
          flt_12FC1C = flt_12FC1C * dbl_90436;
          return 0;
        }
      }
      else if ( (unsigned int)a4 >= 0x1C )
      {
        if ( (unsigned int)a4 > 0x1C && a4 != 0x39 )
        {
          return 0;
        }
        if ( *(_BYTE *)(a1 + 0xB7) == 4 )
        {
          *(_DWORD *)(a1 + 0x5036) = 0xFFFFFFFF;
        }
      }
      return 0;
    }
    if ( a2 > 4u )
    {
      if ( *(_BYTE *)(a1 + 0xB7) == 4 )
      {
        result = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x5036) = 0xFFFFFFFF;
        return result;
      }
      if ( a3 >= *(_DWORD *)(a1 + 8)
        && a3 <= *(_DWORD *)(a1 + 0x10)
        && a4 >= *(_DWORD *)(a1 + 0xC)
        && a4 <= *(_DWORD *)(a1 + 0x14) )
      {
        sub_4FB90((int)&unk_10914C, 0);
        if ( *(_DWORD *)(a1 + 0xAF) )
        {
          sub_16D6C(a1, a3, a4, 0);
        }
        else if ( *(_DWORD *)(a1 + 0xB3) )
        {
          v40 = *(_DWORD *)(a1 + 0xAF);
          v14 = *(_DWORD *)(a1 + 0xAB);
          *(_DWORD *)(a1 + 0xB3) = 0;
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v14 + 0x41), 0x320, 0, v40);
          *(_BYTE *)(a1 + 0xB7) = 0;
        }
        sub_18C2C(a1, 0);
        sub_17260(a1);
        return 0xFFFFFFFF;
      }
      return 0;
    }
    if ( *(_BYTE *)(a1 + 0xB7) == 4 )
    {
      return 0xFFFFFFFF;
    }
    if ( a3 < *(_DWORD *)(a1 + 8)
      || a3 > *(_DWORD *)(a1 + 0x10)
      || a4 < *(_DWORD *)(a1 + 0xC)
      || a4 > *(_DWORD *)(a1 + 0x14) )
    {
      return 0;
    }
    sub_4FB90((int)&unk_10914C, 0);
    if ( *(_DWORD *)(a1 + 0xAF) )
    {
      sub_16D6C(a1, a3, a4, 1);
    }
    else
    {
      v8 = *(_BYTE *)(a1 + 0xB7);
      if ( v8 == 2 )
      {
        if ( *(unsigned __int16 *)(a1 + 0xBC) == 0xFFFF )
        {
          *(_BYTE *)(a1 + 0xB7) = 0;
        }
        else
        {
          v9 = a4 - *(_DWORD *)(a1 + 0xC);
          v10 = v42 - *(_DWORD *)(a1 + 8);
          *(_BYTE *)(a1 + 0xB7) = 3;
          sub_171D0(a1, v10, v9);
        }
      }
      else
      {
        if ( v8 == 3 )
        {
          v11 = *(_DWORD *)(a1 + 0xAB);
          *(_BYTE *)(a1 + 0xB7) = 0;
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v11 + 0x41), 0x326, 5, a1 + 0x1D0A);
          *(_DWORD *)(a1 + 0xB3) = 0;
          sub_187EC(a1);
          v12 = a1;
LABEL_43:
          sub_18C2C(v12, 0);
          return 0xFFFFFFFF;
        }
        if ( v8 )
        {
          return 0xFFFFFFFF;
        }
        v39 = *(_DWORD *)(a1 + 0xAF);
        v13 = *(_DWORD *)(a1 + 0xAB);
        *(_DWORD *)(a1 + 0xB3) = 0;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v13 + 0x41), 0x320, 0, v39);
      }
    }
    v12 = a1;
    goto LABEL_43;
  }
  if ( a2 <= 0x3Au )
  {
    LOBYTE(a3) = *(_BYTE *)(a1 + 0x4F2F);
    if ( (a3 & 1) != 0 )
    {
      if ( (a3 & 2) != 0 )
      {
        v30 = 2;
      }
      else
      {
        v30 = 0xFFFFFFFE;
      }
      sub_17E50(a1, v30, a3, a4);
    }
    v31 = *(_BYTE *)(a1 + 0x4F2F);
    if ( (v31 & 4) != 0 )
    {
      if ( (v31 & 8) != 0 )
      {
        v32 = 0xA;
      }
      else
      {
        v32 = 0xFFFFFFF6;
      }
      sub_182B8(a1, v32);
    }
    if ( (*(_BYTE *)(a1 + 0x4F2F) & 5) != 0 )
    {
      goto LABEL_123;
    }
    return 0;
  }
  if ( a2 < 0x4Cu )
  {
    if ( a2 >= 0x47u )
    {
      if ( a2 <= 0x47u )
      {
        *(_DWORD *)(a1 + 0x4F2F) = 0;
        sub_17F54(a1);
        sub_18C2C(a1, 0);
        return 0xFFFFFFFF;
      }
      else
      {
        if ( a2 < 0x4Au )
        {
          return sub_2F424(a1, a2, a3, a4);
        }
        if ( a2 <= 0x4Au )
        {
          *(_DWORD *)(a1 + 0x503A) = ~*(_DWORD *)(a1 + 0x503A);
          sub_18C2C(a1, 0);
        }
        return 0;
      }
    }
    if ( a2 <= 0x3Bu )
    {
      *(_DWORD *)(a1 + 0x4F2F) &= ~a3;
      if ( (a3 & 1) != 0 )
      {
        sub_18C2C(a1, 0);
      }
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x3B);
      return 0xFFFFFFFF;
    }
    if ( a2 != 0x46 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    return 0;
  }
  if ( a2 <= 0x4Cu )
  {
    v33 = ~*(_DWORD *)(a1 + 0x5042);
    *(_DWORD *)(a1 + 0x5046) = v33;
    *(_DWORD *)(a1 + 0x5042) = v33;
    sub_18C2C(a1, 0);
    return 0;
  }
  if ( a2 < 0x52u )
  {
    if ( a2 < 0x50u )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( a2 > 0x50u )
    {
      *(_BYTE *)(a1 + 0xB7) = 1;
      return 0;
    }
    if ( a3 >= 1 && *(__int16 *)(dword_D3660 + 0x5A) >= a3 )
    {
      dword_D3664 = *(_DWORD *)(dword_D3660 + 4 * a3 + 0x42);
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
      return 0;
    }
    return 0;
  }
  if ( a2 <= 0x52u )
  {
    sub_126F8(a1, a3);
    return 0;
  }
  if ( a2 <= 0x53u )
  {
    *(_DWORD *)v41 = *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB);
    if ( !v41[0] )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x39A);
    }
    v41[4] = *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xAF);
    v34 = sub_12AE4(a1, *(int *)&v41[1]);
    *(_DWORD *)(a1 + 0xB3) = v34;
    v35 = *(__int16 *)(v34 + 0x27);
    if ( v35 < 0
      || (v36 = *(__int16 *)(v34 + 0x29), v36 < 0)
      || v35 > *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8)
      || v36 > *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) )
    {
      sub_17E88(a1, *(_DWORD *)(a1 + 0xB3));
    }
    v37 = *(_DWORD *)(a1 + 0xB3);
    if ( *(_BYTE *)v37 == 2 )
    {
      v38 = *(_DWORD *)(v37 + 1);
      if ( *(_WORD *)(v38 + 0x56) == (unsigned __int8)byte_104BEA && *(int *)(v38 + 0x88) > 0 )
      {
        *(_BYTE *)(a1 + 0xB7) = 2;
      }
    }
LABEL_123:
    sub_18C2C(a1, 0);
    return 0;
  }
  if ( a2 != 0x54 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  sub_172B0(a1);
  return 0;
}
// 90432: using guessed type float flt_90432;
// 90436: using guessed type double dbl_90436;
// 9043E: using guessed type double dbl_9043E;
// 90446: using guessed type double dbl_90446;
// 96BAC: using guessed type int dword_96BAC;
// D3660: using guessed type int dword_D3660;
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00016D6C) --------------------------------------------------------
void __fastcall sub_16D6C(int a1, int a2, int a3, int a4)
{
  unsigned int v5; // ebp
  char v6; // bh
  char v7; // al
  int v8; // edi
  char *v9; // eax
  char v10; // dl
  int v11; // eax
  char v12; // ch
  int v13; // ebx
  char v14; // bh
  int v15; // eax
  int v16; // edx
  char v17; // al
  char v18; // ah

  if ( !*(_DWORD *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x3D7);
  }
  v5 = 0;
  if ( !a4 )
  {
    sub_17E88(a1, *(_DWORD *)(a1 + 0xAF));
    goto LABEL_32;
  }
  if ( *(_BYTE *)(a1 + 0xB7) == 1 )
  {
    v6 = **(_BYTE **)(a1 + 0xAF);
    v7 = 0;
    switch ( v6 )
    {
      case 2:
        v7 = 3;
        break;
      case 1:
        v7 = 2;
        break;
      case 3:
        v7 = 4;
        break;
    }
    v8 = v7;
    if ( sub_56D30(
           (int)&V_Type3_stru_10AE70,
           *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
           0x322,
           v7,
           *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1)) == 0xFFFFFFFF )
    {
      *(_BYTE *)(a1 + 0xB7) = 0;
      sub_56D30(
        (int)&V_Type3_stru_10AE70,
        *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
        0x326,
        v8,
        *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1));
      *(_DWORD *)(a1 + 0xB3) = 0;
    }
  }
  else
  {
    v9 = *(char **)(a1 + 0xAF);
    v10 = *v9;
    if ( *v9 != 2 )
    {
      if ( v10 == 1 )
      {
        v12 = *(_BYTE *)(a1 + 0xB7);
        if ( v12 != 2 && v12 != 3 )
        {
          v13 = *(_DWORD *)(a1 + 0xB3);
          if ( v9 != (char *)v13 || v12 )
          {
            v5 = 0xFFFFFFFF;
            *(_DWORD *)(a1 + 0xB3) = *(_DWORD *)(a1 + 0xAF);
          }
          else
          {
            dword_D3664 = *(_DWORD *)(v13 + 1);
            *(_DWORD *)(a1 + 0xAF) = 0;
            sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
          }
          goto LABEL_32;
        }
        *(_BYTE *)(a1 + 0xB7) = 0;
        sub_56D30(
          (int)&V_Type3_stru_10AE70,
          *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
          0x326,
          2,
          *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1));
      }
      else
      {
        if ( v10 != 3 )
        {
          goto LABEL_32;
        }
        v14 = *(_BYTE *)(a1 + 0xB7);
        v15 = *(_DWORD *)(v9 + 1);
        if ( v14 != 2 && v14 != 3 )
        {
          goto LABEL_32;
        }
        v16 = *(_DWORD *)(a1 + 0xAB);
        *(_BYTE *)(a1 + 0xB7) = 0;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v16 + 0x41), 0x326, 4, v15);
      }
      sub_187EC(a1);
      sub_18C2C(a1, 0);
      goto LABEL_32;
    }
    if ( !*(_BYTE *)(a1 + 0xB7) )
    {
      *(_DWORD *)(a1 + 0xB3) = v9;
      v11 = *(_DWORD *)(v9 + 1);
      v5 = 0xFFFFFFFF;
      if ( *(_WORD *)(v11 + 0x56) == (unsigned __int8)byte_104BEA && *(int *)(v11 + 0x88) > 0 )
      {
        *(_BYTE *)(a1 + 0xB7) = 2;
      }
    }
  }
LABEL_32:
  if ( v5 == 0xFFFFFFFF )
  {
    v17 = 0;
    v18 = **(_BYTE **)(a1 + 0xB3);
    if ( v18 == 2 )
    {
      v17 = 3;
    }
    else if ( v18 == 1 )
    {
      v17 = 2;
    }
    sub_56D30(
      (int)&V_Type3_stru_10AE70,
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0x41),
      0x320,
      v17,
      *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 1));
  }
  sub_17260(a1);
}

//----- (00016FC0) --------------------------------------------------------
int __fastcall sub_16FC0(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  double v6; // st7
  float *v7; // ecx
  float v9; // [esp+0h] [ebp-90h]
  float v10; // [esp+4h] [ebp-8Ch]
  int v11; // [esp+8h] [ebp-88h]
  int v12; // [esp+Ch] [ebp-84h]
  float v13; // [esp+10h] [ebp-80h] BYREF
  float v14; // [esp+14h] [ebp-7Ch]
  float v15; // [esp+18h] [ebp-78h]
  float v16; // [esp+1Ch] [ebp-74h] BYREF
  float v17; // [esp+20h] [ebp-70h]
  float v18; // [esp+24h] [ebp-6Ch]
  float v19; // [esp+28h] [ebp-68h]
  int v20; // [esp+2Ch] [ebp-64h]
  int v21; // [esp+30h] [ebp-60h]
  float v22; // [esp+34h] [ebp-5Ch] BYREF
  float v23; // [esp+38h] [ebp-58h]
  float v24; // [esp+3Ch] [ebp-54h]
  float v25; // [esp+40h] [ebp-50h]
  float v26; // [esp+44h] [ebp-4Ch]
  float v27; // [esp+48h] [ebp-48h]
  int v28[3]; // [esp+4Ch] [ebp-44h] BYREF
  int v29[3]; // [esp+58h] [ebp-38h] BYREF
  float v30; // [esp+64h] [ebp-2Ch] BYREF
  float v31; // [esp+68h] [ebp-28h]
  float v32; // [esp+6Ch] [ebp-24h]
  int v33; // [esp+70h] [ebp-20h]
  int v34; // [esp+74h] [ebp-1Ch]
  int *v35; // [esp+78h] [ebp-18h]
  float v36; // [esp+7Ch] [ebp-14h]
  int *v37; // [esp+80h] [ebp-10h]
  float *v38; // [esp+84h] [ebp-Ch]
  float v39; // [esp+88h] [ebp-8h]
  int v40; // [esp+8Ch] [ebp-4h]

  v40 = a4;
  v33 = a2 - *(__int16 *)(a1 + 0x4F22);
  v5 = *(__int16 *)(a1 + 0x4F24);
  v22 = (float)v33;
  v35 = v28;
  v34 = v5 - a3;
  v23 = 0.0;
  v24 = (float)(v5 - a3);
  v36 = *(float *)(a1 + 0x4F16);
  v19 = v22 * v36;
  *(float *)&v20 = 0.0 * v36;
  *(float *)v28 = v19;
  *(float *)&v21 = v24 * v36;
  v28[1] = v20;
  v22 = v19 * flt_9045D;
  v28[2] = v21;
  v23 = *(float *)&v20;
  v24 = *(float *)&v21 * flt_90461;
  v13 = *(float *)(a1 + 0x4E5E);
  v14 = *(float *)(a1 + 0x4E62);
  v15 = *(float *)(a1 + 0x4E66);
  v14 = 0.0;
  v30 = 0.0;
  v32 = 1.0;
  v31 = 0.0;
  v39 = sub_5309C(&v13, &v30);
  v10 = v14 * v32 - v15 * v31;
  *(float *)&v11 = v15 * v30 - v13 * v32;
  v37 = v29;
  *(float *)v29 = v10;
  v29[1] = v11;
  *(float *)&v12 = v13 * v31 - v14 * v30;
  v29[2] = v12;
  if ( *(float *)&v11 >= 0.0 )
  {
    v9 = -v39;
    sub_532AC(&v22, v9);
  }
  else
  {
    sub_532AC(&v22, v39);
  }
  v38 = &v16;
  v25 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  v25 = v22 + *(float *)(a1 + 0x1D1E);
  v26 = v23 + *(float *)(a1 + 0x1D22);
  v6 = v24 + *(float *)(a1 + 0x1D26);
  v16 = v25;
  v27 = v6;
  v17 = v26;
  v18 = v27;
  *(float *)(a1 + 0x1D0A) = v25;
  *(float *)(a1 + 0x1D0E) = v17;
  v7 = (float *)(a1 + 0x1D0A);
  v7[2] = v18;
  return sub_53440(v7);
}
// 9045D: using guessed type float flt_9045D;
// 90461: using guessed type float flt_90461;

//----- (000171D0) --------------------------------------------------------
int __fastcall sub_171D0(int a1, int a2, int a3)
{
  double v3; // st7
  float *v4; // eax

  v3 = (double)(a3 - 0xF0) * *(float *)(a1 + 0x4F16) * flt_90465 + *(float *)(a1 + 0x1D22);
  v4 = (float *)(a1 + 0x1D0A);
  v4[1] = v3;
  return sub_53440(v4);
}
// 90465: using guessed type float flt_90465;

//----- (00017204) --------------------------------------------------------
char *__fastcall sub_17204(int a1, int a2, int a3)
{
  char *result; // eax

  result = sub_15808(a1 + 0x1D36, a2, a3);
  *(_DWORD *)(a1 + 0xAF) = result;
  if ( !result )
  {
    result = sub_15808(a1 + 0x253A, a2, a3);
    *(_DWORD *)(a1 + 0xAF) = result;
  }
  if ( !*(_DWORD *)(a1 + 0xAF) )
  {
    result = sub_15808(a1 + 0x2D3E, a2, a3);
    *(_DWORD *)(a1 + 0xAF) = result;
  }
  return result;
}

//----- (00017260) --------------------------------------------------------
void __fastcall sub_17260(int result)
{
  char v1; // bl
  int v2; // edx

  if ( *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(result + 0x41) )
  {
    v1 = *(_BYTE *)(result + 0xB7);
    v2 = *(_DWORD *)(result + 0xB8);
    if ( v1 == 1 )
    {
      v2 += 8;
    }
    else if ( v1 == 2 || v1 == 3 )
    {
      v2 += 6;
    }
    if ( *(_DWORD *)(result + 0xAF) )
    {
      ++v2;
    }
    sub_5A270(&V_Type3_stru_10AE70, v2, 0, 0);
  }
}

//----- (000172B0) --------------------------------------------------------
void __fastcall sub_172B0(int a1)
{
  _BYTE *v2; // edx
  int v3; // eax
  char *v4; // esi
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  int v14; // eax
  int v15; // edx
  char s[176]; // [esp+0h] [ebp-B0h] BYREF

  v2 = *(_BYTE **)(a1 + 0xB3);
  if ( v2 )
  {
    v3 = *(_DWORD *)(a1 + 0xB3);
    v4 = 0;
    v5 = 0;
    if ( *v2 == 2 && (v6 = *(_DWORD *)(v3 + 1), *(_WORD *)(v6 + 0x56) == (unsigned __int8)byte_104BEA) )
    {
      v4 = "abanship";
      v5 = v6 + 0x34;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 0xB3);
      if ( *(_BYTE *)v7 == 1 )
      {
        v8 = *(_DWORD *)(v7 + 1);
        if ( (_BYTE)byte_104BEA == *(_BYTE *)(v8 + 0x57) )
        {
          v4 = "abanplan";
          v5 = v8 + 0x24;
        }
      }
    }
    if ( v4 )
    {
      v9 = sub_56DA8((int)&V_Type3_stru_10AE70, "HELPWINDOW", 0);
      sub_2FCB0((_DWORD *)v9, "help.txt", v4);
      v10 = s;
      sprintf(s, *(const char **)(v9 + 0xC9A), v5);
      v11 = *(char **)(v9 + 0xC9A);
      do
      {
        v12 = *v10;
        *v11 = *v10;
        if ( !v12 )
        {
          break;
        }
        v13 = v10[1];
        v10 += 2;
        v11[1] = v13;
        v11 += 2;
      }
      while ( v13 );
      if ( sub_552F8((unsigned int)&V_Type3_stru_10AE70, v9, 0) )
      {
        v14 = *(_DWORD *)(a1 + 0xB3);
        if ( *(_BYTE *)v14 == 2 )
        {
          sub_49940(*(_DWORD *)(v14 + 1));
        }
        else
        {
          sub_37040(*(_DWORD *)(v14 + 1));
        }
        *(_DWORD *)(a1 + 0xB3) = 0;
        v15 = *(_DWORD *)(a1 + 0xAB);
        *(_BYTE *)(a1 + 0xB7) = 0;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v15 + 0x41), 0x320, 0, 0);
        sub_187EC(a1);
        sub_18C2C(a1, 0);
      }
    }
  }
}

//----- (000173F4) --------------------------------------------------------
int __fastcall sub_173F4(int a1, int a2, int a3, int a4)
{
  sub_1B958(a1 + 0x4E46, (float *)(a1 + 0x1D1E), a1, a4);
  return sub_17430(a1);
}

//----- (00017430) --------------------------------------------------------
int __fastcall sub_17430(int a1)
{
  int v2; // esi
  int *v3; // edi
  int result; // eax
  double v5; // st7
  int v6; // ebx
  char v7; // dl
  char v8; // bh
  int v9; // edx
  float v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // eax
  double v15; // st7
  char v16; // al
  double v17; // st7
  float *v18; // edx
  float v19; // eax
  int *v20; // edx
  int v21; // edx
  int v22; // eax
  float *v23; // ebx
  int v24; // edx
  double v25; // st7
  int v26; // eax
  int v27[3]; // [esp+0h] [ebp-180h]
  int v28[25]; // [esp+14h] [ebp-16Ch] BYREF
  int v29[12]; // [esp+78h] [ebp-108h] BYREF
  float v30; // [esp+A8h] [ebp-D8h] BYREF
  float v31; // [esp+ACh] [ebp-D4h]
  float v32; // [esp+B0h] [ebp-D0h]
  int v33[3]; // [esp+B4h] [ebp-CCh] BYREF
  float v34; // [esp+C0h] [ebp-C0h]
  float v35; // [esp+C4h] [ebp-BCh]
  int v36; // [esp+C8h] [ebp-B8h]
  float v37; // [esp+CCh] [ebp-B4h] BYREF
  float v38; // [esp+D0h] [ebp-B0h]
  float v39; // [esp+D4h] [ebp-ACh]
  float v40; // [esp+D8h] [ebp-A8h] BYREF
  float v41; // [esp+DCh] [ebp-A4h]
  float v42; // [esp+E0h] [ebp-A0h]
  float v43; // [esp+E4h] [ebp-9Ch]
  float v44; // [esp+E8h] [ebp-98h]
  float v45; // [esp+ECh] [ebp-94h]
  float v46; // [esp+F0h] [ebp-90h] BYREF
  float v47; // [esp+F4h] [ebp-8Ch]
  float v48; // [esp+F8h] [ebp-88h]
  int v49[3]; // [esp+FCh] [ebp-84h] BYREF
  float v50; // [esp+108h] [ebp-78h] BYREF
  float v51; // [esp+10Ch] [ebp-74h]
  int v52; // [esp+110h] [ebp-70h]
  __int64 v53; // [esp+114h] [ebp-6Ch]
  float v54; // [esp+11Ch] [ebp-64h]
  float *v55; // [esp+120h] [ebp-60h]
  int *v56; // [esp+124h] [ebp-5Ch]
  int v57; // [esp+128h] [ebp-58h]
  int *v58; // [esp+12Ch] [ebp-54h]
  int v59; // [esp+130h] [ebp-50h]
  float *v60; // [esp+134h] [ebp-4Ch]
  int v61; // [esp+138h] [ebp-48h]
  int v62; // [esp+13Ch] [ebp-44h]
  int v63; // [esp+140h] [ebp-40h]
  float *v64; // [esp+144h] [ebp-3Ch]
  int v65; // [esp+148h] [ebp-38h]
  float v66; // [esp+14Ch] [ebp-34h]
  int v67; // [esp+150h] [ebp-30h]
  float v68; // [esp+154h] [ebp-2Ch]
  float *v69; // [esp+158h] [ebp-28h]
  float v70; // [esp+15Ch] [ebp-24h]
  int v71; // [esp+160h] [ebp-20h] BYREF
  __int16 v72[14]; // [esp+164h] [ebp-1Ch] BYREF

  v2 = *(_DWORD *)(a1 + 0x1D2A);
  v40 = 0.0;
  v41 = 0.0;
  v42 = 0.0;
  v46 = 0.0;
  v47 = 0.0;
  v48 = 0.0;
  v37 = 0.0;
  v38 = 0.0;
  v39 = 0.0;
  _wcpp_2_ctor_array_(v29, 4, &unk_959D8);
  v46 = 0.0;
  v47 = 0.0;
  v48 = 0.0;
  sub_53384(&v46, (float *)(a1 + 0x4E86), &v40);
  v29[0] = 0x41800000;
  v29[2] = 0x41800000;
  v29[3] = 0x41800000;
  v46 = v40;
  v29[0xB] = 0x41800000;
  v47 = v41;
  v48 = v42;
  v3 = v29;
  v29[1] = 0;
  v29[4] = 0;
  v29[7] = 0;
  v29[5] = 0xC1800000;
  v29[6] = 0xC1800000;
  v29[8] = 0xC1800000;
  v29[9] = 0xC1800000;
  v29[0xA] = 0;
  v60 = &v30;
  do
  {
    sub_53384((float *)v3, (float *)(a1 + 0x4E86), &v40);
    v55 = &v50;
    v34 = v40 - v46;
    v50 = v34;
    v35 = v41 - v47;
    v51 = v35;
    *(float *)&v36 = v42 - v48;
    v52 = v36;
    *(float *)v3 = v34;
    *((float *)v3 + 1) = v51;
    v3 += 3;
    result = v52;
    v3[0xFFFFFFFF] = v52;
  }
  while ( v3 != (int *)v60 );
  v5 = *(float *)(a1 + 0x4F2A) * flt_9049E;
  v6 = *(_DWORD *)(a1 + 0x1D32);
  v59 = 0;
  v66 = v5;
  if ( v6 > 0 )
  {
    v61 = a1 + 0x1D36;
    v63 = a1 + 0x253A;
    v67 = a1 + 0x3542;
    v65 = a1 + 0x2D3E;
    v64 = (float *)(a1 + 0x4E46);
    v69 = (float *)(a1 + 0x1D1E);
    v62 = a1 + 0x4F80;
    do
    {
      if ( *(_BYTE *)v2 != 6
        || ((v7 = *(_BYTE *)(a1 + 0xB7), v7 == 2) || v7 == 3)
        && !*(_DWORD *)(a1 + 0xAF)
        && *(_DWORD *)(a1 + 0x1D0E) != 0x49742400 )
      {
        if ( *(_BYTE *)v2 != 0xFF )
        {
          v8 = *(_BYTE *)v2;
          *(_DWORD *)(v2 + 0x1B) = 0xFFFFFFFF;
          if ( v8 == 4 )
          {
            v9 = *(_DWORD *)(v2 + 1);
            v40 = *(float *)(v9 + 1);
            v41 = *(float *)(v9 + 5);
            v42 = *(float *)(v9 + 9);
            sub_53114(&v40, v64);
            if ( v42 > 0.0 )
            {
              sub_533D4(
                &v40,
                *(float *)(a1 + 0x4E6E),
                *(__int16 *)(a1 + 0x4F22),
                *(__int16 *)(a1 + 0x4F24),
                (int)v72,
                (int)&v71);
              *(_WORD *)(v2 + 0x27) = v72[0];
              *(_WORD *)(v2 + 0x29) = v71;
              v10 = v42;
              *(_DWORD *)(v2 + 0x1B) = 0;
              *(_DWORD *)(v2 + 0x23) = 0;
              *(float *)(v2 + 0x2F) = v10;
              v11 = v65;
              *(_DWORD *)(v2 + 0xF) = sub_10000;
              sub_15794(v11, v2);
            }
          }
          else
          {
            v13 = *(_BYTE *)(v2 + 0x33) & 0x10;
            v57 = 0xFFFFFFFF;
            if ( v13 )
            {
              v14 = 0xC * *(char *)(v2 + 0x34);
              v37 = *(float *)(v14 + v62);
              v38 = *(float *)(v14 + v62 + 4);
              v39 = *(float *)(v14 + v62 + 8);
            }
            else
            {
              switch ( *(_BYTE *)v2 )
              {
                case 0:
                  v37 = 0.0;
                  v38 = 0.0;
                  v39 = 0.0;
                  break;
                case 1:
                  v20 = *(int **)(v2 + 1);
                  v37 = *(float *)v20;
                  v38 = *((float *)v20 + 1);
                  v39 = *((float *)v20 + 2);
                  break;
                case 2:
                  v21 = *(_DWORD *)(v2 + 1);
                  v37 = *(float *)(v21 + 0x9E);
                  v38 = *(float *)(v21 + 0xA2);
                  v39 = *(float *)(v21 + 0xA6);
                  v57 = *(__int16 *)(*(_DWORD *)(v2 + 1) + 0x56);
                  break;
                case 3:
                  v18 = *(float **)(v2 + 1);
                  if ( (*(_BYTE *)(v2 + 0x33) & 1) != 0 )
                  {
                    v37 = v18[2];
                    v38 = v18[3];
                    v19 = v18[4];
                  }
                  else
                  {
                    v37 = v18[5];
                    v38 = v18[6];
                    v19 = v18[7];
                  }
                  v39 = v19;
                  break;
                case 6:
                  v37 = *(float *)(a1 + 0x1D0A);
                  v38 = *(float *)(a1 + 0x1D0E);
                  v39 = *(float *)(a1 + 0x1D12);
                  sub_53440(&v37);
                  break;
                default:
                  Q_AssertLogBreakExit_sub_261A8(0, "..\\batmode.cpp", 0x53E);
              }
            }
            v46 = v37;
            v47 = v38;
            v48 = v39;
            sub_53384(&v46, (float *)(a1 + 0x4E86), &v40);
            v47 = *(float *)(a1 + 0x1D22);
            v56 = v33;
            v43 = 0.0;
            v44 = 0.0;
            v45 = 0.0;
            v43 = v46 - *v69;
            v44 = v47 - v69[1];
            v45 = v48 - v69[2];
            *(float *)v33 = v43;
            *(float *)&v33[1] = v44;
            *(float *)&v33[2] = v45;
            v46 = v43;
            v47 = v44;
            v48 = v45;
            v15 = sqrt(v44 * v44 + v43 * v43 + v45 * v45);
            *(_DWORD *)(v2 + 0x23) = (v15 >= v66) - 1;
            if ( v42 > (double)*(float *)(a1 + 0x4E72) && v42 < (double)*(float *)(a1 + 0x4E76) )
            {
              sub_533D4(
                &v40,
                *(float *)(a1 + 0x4E6E),
                *(__int16 *)(a1 + 0x4F22),
                *(__int16 *)(a1 + 0x4F24),
                (int)v72,
                (int)&v71);
              *(_WORD *)(v2 + 0x27) = v72[0];
              *(_WORD *)(v2 + 0x29) = v71;
              *(float *)(v2 + 0x2F) = v42;
              v16 = *(_BYTE *)v2;
              *(_DWORD *)(v2 + 0x1B) = 0;
              if ( v16 == 7 )
              {
                *(float *)(v2 + 0x2F) = *(float *)(v2 + 0x2F) + flt_904AA;
              }
              v17 = *(float *)(a1 + 0x4F1A) * flt_904A2;
              v70 = 131072.0;
              v68 = v17;
              if ( *(float *)(v2 + 0x2F) >= (double)*(float *)(a1 + 0x4E72) )
              {
                v70 = v68 / *(float *)(v2 + 0x2F);
              }
              if ( v70 >= (double)flt_904A2 )
              {
                if ( v70 > (double)flt_904AE )
                {
                  v70 = 131072.0;
                }
              }
              else
              {
                v70 = 16384.0;
              }
              v53 = (__int64)(v70 * *(float *)(v2 + 0xB));
              *(_DWORD *)(v2 + 0xF) = v53;
              v22 = *(_DWORD *)(v2 + 0x23);
              v54 = *(float *)(a1 + 0x4F16) * flt_904A6 + *(float *)(a1 + 0x1D22);
              if ( v22 )
              {
                if ( (*(_BYTE *)(v2 + 0x33) & 2) == 0 )
                {
                  v46 = v37;
                  v48 = v39;
                  v47 = v54;
                  sub_53384(&v46, (float *)(a1 + 0x4E86), &v40);
                  v46 = v40;
                  v47 = v41;
                  v48 = v42;
                  sub_533D4(
                    &v40,
                    *(float *)(a1 + 0x4E6E),
                    *(__int16 *)(a1 + 0x4F22),
                    *(__int16 *)(a1 + 0x4F24),
                    (int)v72,
                    (int)&v71);
                  *(_WORD *)(v2 + 0x2B) = v72[0];
                  v23 = (float *)v29;
                  v24 = 0;
                  *(_WORD *)(v2 + 0x2D) = v71;
                  do
                  {
                    v58 = v49;
                    v30 = 0.0;
                    v31 = 0.0;
                    v32 = 0.0;
                    v30 = v46 + *v23;
                    v31 = v47 + v23[1];
                    v25 = v48 + v23[2];
                    *(float *)v49 = v30;
                    v32 = v25;
                    *(float *)&v49[1] = v31;
                    *(float *)&v49[2] = v32;
                    v40 = v30;
                    v41 = v31;
                    v42 = v32;
                    sub_533D4(
                      &v40,
                      *(float *)(a1 + 0x4E6E),
                      *(__int16 *)(a1 + 0x4F22),
                      *(__int16 *)(a1 + 0x4F24),
                      (int)v72,
                      (int)&v71);
                    v28[v24] = v72[0];
                    v24 += 6;
                    v23 += 3;
                    v27[v24] = (__int16)v71;
                  }
                  while ( v24 != 0x18 );
                  v28[0x18] = v57;
                  sub_15D38(v67, v28);
                  if ( *(_BYTE *)v2 == 6 )
                  {
                    *(_WORD *)(a1 + 0xBC) = *(_WORD *)(a1 + 0x4E42) - 1;
                  }
                }
              }
              if ( v38 - v54 > 0.0 )
              {
                v26 = v63;
                *(_DWORD *)(v2 + 0x1F) = 0;
              }
              else
              {
                v26 = v61;
                *(_DWORD *)(v2 + 0x1F) = 0xFFFFFFFF;
              }
              sub_15794(v26, v2);
            }
          }
        }
      }
      v2 += 0x35;
      result = v59 + 1;
      v12 = *(_DWORD *)(a1 + 0x1D32);
      v59 = result;
    }
    while ( result < v12 );
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 9049E: using guessed type float flt_9049E;
// 904A2: using guessed type float flt_904A2;
// 904A6: using guessed type float flt_904A6;
// 904AA: using guessed type float flt_904AA;
// 904AE: using guessed type float flt_904AE;
// 17430: using guessed type __int16 var_1C[14];

//----- (00017E50) --------------------------------------------------------
void __fastcall sub_17E50(int a1, int a2, int a3, int a4)
{
  int v4; // [esp+0h] [ebp-8h]

  *(float *)&v4 = (double)a2 * flt_12FC1C;
  sub_1BAF0((float *)(a1 + 0x4E46), a2, a3, a4, v4);
}
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00017E88) --------------------------------------------------------
float *__fastcall sub_17E88(int a1, int a2)
{
  float *result; // eax
  int v4; // ecx
  double v5; // st7
  int v6; // ecx
  int v7; // ecx
  double v8; // st7
  int v9; // ecx

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x5BD);
  }
  result = (float *)(a1 + 0x1D1E);
  switch ( *(_BYTE *)a2 )
  {
    case 0:
      *result = 0.0;
      *(_DWORD *)(a1 + 0x1D22) = 0;
      *(_DWORD *)(a1 + 0x1D26) = 0;
      break;
    case 1:
      v6 = *(_DWORD *)(a2 + 1);
      *result = *(float *)v6;
      *(_DWORD *)(a1 + 0x1D22) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a1 + 0x1D26) = *(_DWORD *)(v6 + 8);
      break;
    case 2:
      v4 = *(_DWORD *)(a2 + 1);
      v5 = *(float *)(v4 + 0x9E);
      v4 += 0x9E;
      *result = v5;
      *(_DWORD *)(a1 + 0x1D22) = *(_DWORD *)(v4 + 4);
      *(_DWORD *)(a1 + 0x1D26) = *(_DWORD *)(v4 + 8);
      break;
    case 3:
      v7 = *(_DWORD *)(a2 + 1);
      if ( dword_D3660 == *(_DWORD *)v7 )
      {
        v8 = *(float *)(v7 + 8);
        v9 = v7 + 8;
      }
      else
      {
        v8 = *(float *)(v7 + 0x14);
        v9 = v7 + 0x14;
      }
      *result = v8;
      *(_DWORD *)(a1 + 0x1D22) = *(_DWORD *)(v9 + 4);
      *(_DWORD *)(a1 + 0x1D26) = *(_DWORD *)(v9 + 8);
      break;
    default:
      return result;
  }
  return result;
}
// D3660: using guessed type int dword_D3660;

//----- (00017F54) --------------------------------------------------------
void __fastcall sub_17F54(int a1)
{
  *(_DWORD *)(a1 + 0x1D1E) = 0;
  *(_DWORD *)(a1 + 0x1D22) = 0;
  *(_DWORD *)(a1 + 0x1D26) = 0;
  *(float *)(a1 + 0x4F16) = *(float *)(a1 + 0x4F1A);
  *(_DWORD *)(a1 + 0x4E7A) = *(_DWORD *)(a1 + 0x4EDE);
  *(_DWORD *)(a1 + 0x4E7E) = *(_DWORD *)(a1 + 0x4EE2);
  *(_DWORD *)(a1 + 0x4E82) = *(_DWORD *)(a1 + 0x4EE6);
  *(float *)(a1 + 0x4E46) = *(float *)(a1 + 0x4EEA);
  *(float *)(a1 + 0x4E4A) = *(float *)(a1 + 0x4EEE);
  *(_DWORD *)(a1 + 0x4E4E) = *(_DWORD *)(a1 + 0x4EF2);
  *(_DWORD *)(a1 + 0x4E52) = *(_DWORD *)(a1 + 0x4EF6);
  *(_DWORD *)(a1 + 0x4E56) = *(_DWORD *)(a1 + 0x4EFA);
  *(_DWORD *)(a1 + 0x4E5A) = *(_DWORD *)(a1 + 0x4EFE);
  *(_DWORD *)(a1 + 0x4E5E) = *(_DWORD *)(a1 + 0x4F02);
  *(_DWORD *)(a1 + 0x4E62) = *(_DWORD *)(a1 + 0x4F06);
  *(_DWORD *)(a1 + 0x4E66) = *(_DWORD *)(a1 + 0x4F0A);
  sub_181F0(a1);
}

//----- (00017FF0) --------------------------------------------------------
void __fastcall sub_17FF0(int a1, int a2, int a3, int a4)
{
  double v5; // st6
  double x; // st6
  double v7; // st7
  int v8; // [esp+0h] [ebp-3Ch]
  int x_4; // [esp+Ch] [ebp-30h]
  float x_4a; // [esp+Ch] [ebp-30h]
  double v11; // [esp+10h] [ebp-2Ch]

  *(_DWORD *)(a1 + 0x1D1E) = 0;
  *(_DWORD *)(a1 + 0x4F26) = 0x23;
  v5 = (double)*(int *)(a1 + 0x4F26) * flt_959F4;
  *(_DWORD *)(a1 + 0x1D22) = 0;
  x = v5 * flt_904C1;
  *(_DWORD *)(a1 + 0x1D26) = 0;
  v11 = *(float *)(a1 + 0x4F1E);
  v7 = v11 / tan(x);
  x_4 = *(__int16 *)(a1 + 0x4F22);
  *(float *)(a1 + 0x4F16) = v7;
  *(float *)(a1 + 0x4F1A) = v7;
  *(float *)&v8 = (float)*(int *)(a1 + 0x4F26);
  sub_1B808((_DWORD *)(a1 + 0x4E46), a1, a1 + 0x4E46, a4, v8, 0x3F800000, 0x47C35000, x_4);
  *(_DWORD *)(a1 + 0x4EE6) = *(_DWORD *)(a1 + 0x4E6E);
  *(_BYTE *)(a1 + 0x4EE9) ^= 0x80u;
  *(float *)(a1 + 0x4EE2) = *(float *)(a1 + 0x4EE6) * flt_904C5;
  x_4a = *(float *)(a1 + 0x4F16);
  *(_DWORD *)(a1 + 0x4EDE) = 0;
  sub_53054((float *)(a1 + 0x4EDE), x_4a);
  *(_DWORD *)(a1 + 0x4E46) = 0x3F800000;
  *(_DWORD *)(a1 + 0x4E4A) = 0;
  *(_DWORD *)(a1 + 0x4E4E) = 0;
  *(_DWORD *)(a1 + 0x4E52) = 0;
  *(_DWORD *)(a1 + 0x4E56) = 0x3F800000;
  *(_DWORD *)(a1 + 0x4E5A) = 0;
  *(_DWORD *)(a1 + 0x4E5E) = 0;
  *(_DWORD *)(a1 + 0x4E62) = 0;
  *(_DWORD *)(a1 + 0x4E66) = 0x3F800000;
  *(float *)(a1 + 0x4EEA) = *(float *)(a1 + 0x4E46);
  *(float *)(a1 + 0x4EEE) = *(float *)(a1 + 0x4E4A);
  *(_DWORD *)(a1 + 0x4EF2) = *(_DWORD *)(a1 + 0x4E4E);
  *(_DWORD *)(a1 + 0x4EF6) = *(_DWORD *)(a1 + 0x4E52);
  *(_DWORD *)(a1 + 0x4EFA) = *(_DWORD *)(a1 + 0x4E56);
  *(_DWORD *)(a1 + 0x4EFE) = *(_DWORD *)(a1 + 0x4E5A);
  *(_DWORD *)(a1 + 0x4F02) = *(_DWORD *)(a1 + 0x4E5E);
  *(float *)(a1 + 0x4F06) = *(float *)(a1 + 0x4E62);
  *(float *)(a1 + 0x4F0A) = *(float *)(a1 + 0x4E66);
  *(float *)(a1 + 0x4F02) = -*(float *)(a1 + 0x4EDE);
  *(float *)(a1 + 0x4F06) = -*(float *)(a1 + 0x4EE2);
  *(float *)(a1 + 0x4F0A) = -*(float *)(a1 + 0x4EE6);
  sub_53864((float *)(a1 + 0x4EEA), a1, a1 + 0x4E46, a1 + 0x4EEA);
  *(_DWORD *)(a1 + 0x4E46) = *(_DWORD *)(a1 + 0x4EEA);
  *(_DWORD *)(a1 + 0x4E4A) = *(_DWORD *)(a1 + 0x4EEE);
  *(_DWORD *)(a1 + 0x4E4E) = *(_DWORD *)(a1 + 0x4EF2);
  *(_DWORD *)(a1 + 0x4E52) = *(_DWORD *)(a1 + 0x4EF6);
  *(_DWORD *)(a1 + 0x4E56) = *(_DWORD *)(a1 + 0x4EFA);
  *(_DWORD *)(a1 + 0x4E5A) = *(_DWORD *)(a1 + 0x4EFE);
  *(_DWORD *)(a1 + 0x4E5E) = *(_DWORD *)(a1 + 0x4F02);
  *(_DWORD *)(a1 + 0x4E62) = *(_DWORD *)(a1 + 0x4F06);
  *(_DWORD *)(a1 + 0x4E66) = *(_DWORD *)(a1 + 0x4F0A);
  *(_DWORD *)(a1 + 0x4E7A) = *(_DWORD *)(a1 + 0x4EDE);
  *(_DWORD *)(a1 + 0x4E7E) = *(_DWORD *)(a1 + 0x4EE2);
  *(_DWORD *)(a1 + 0x4E82) = *(_DWORD *)(a1 + 0x4EE6);
  sub_181F0(a1);
}
// 904C1: using guessed type float flt_904C1;
// 904C5: using guessed type float flt_904C5;
// 959F4: using guessed type float flt_959F4;

//----- (000181F0) --------------------------------------------------------
void __fastcall sub_181F0(int a1)
{
  *(float *)(a1 + 0x4F2A) = tan((double)*(int *)(a1 + 0x4F26) * flt_959F4 * flt_904C9);
  *(float *)(a1 + 0x4F2A) = *(float *)(a1 + 0x4F16) * *(float *)(a1 + 0x4F2A) * flt_904CD;
  *(float *)(a1 + 0x4F12) = *(float *)(a1 + 0x4F1A) * flt_904C9 + *(float *)(a1 + 0x4F16);
  *(float *)(a1 + 0x4F0E) = *(float *)(a1 + 0x4F16) - *(float *)(a1 + 0x4F2A) * flt_904C9;
}
// 904C9: using guessed type float flt_904C9;
// 904CD: using guessed type float flt_904CD;
// 959F4: using guessed type float flt_959F4;

//----- (0001826C) --------------------------------------------------------
int __fastcall sub_1826C(int a1, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  if ( a3 >= *(int *)(a1 + 0x1A8E) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x62B);
  }
  return sub_156C0(a2, *(unsigned __int16 *)(a1 + 2 * a3 + 0x19C6), a4);
}

//----- (000182B8) --------------------------------------------------------
void __fastcall sub_182B8(int a1, int a2)
{
  double v3; // st7
  double v4; // st7
  int v5; // eax
  float v6; // [esp+4h] [ebp-8h]
  float v7; // [esp+4h] [ebp-8h]
  float v8; // [esp+4h] [ebp-8h]

  v3 = (double)a2;
  v6 = v3;
  if ( v3 <= flt_904E0 )
  {
    if ( v6 < (double)flt_904E4 )
    {
      v6 = -50.0;
    }
  }
  else
  {
    v6 = 50.0;
  }
  v7 = v6 * flt_904E8 * flt_12FC1C;
  v8 = v7 + 1.0;
  v4 = *(float *)(a1 + 0x4F16) * v8;
  *(float *)(a1 + 0x4F16) = v4;
  if ( v4 < *(float *)(a1 + 0x4E6E) )
  {
    v5 = *(_DWORD *)(a1 + 0x4E6E);
LABEL_9:
    *(_DWORD *)(a1 + 0x4F16) = v5;
    goto LABEL_10;
  }
  if ( *(float *)(a1 + 0x4F16) > (double)*(float *)(a1 + 0x4F1A) )
  {
    v5 = *(_DWORD *)(a1 + 0x4F1A);
    goto LABEL_9;
  }
LABEL_10:
  sub_53054((float *)(a1 + 0x4E7A), *(float *)(a1 + 0x4F16));
  sub_181F0(a1);
}
// 904E0: using guessed type float flt_904E0;
// 904E4: using guessed type float flt_904E4;
// 904E8: using guessed type float flt_904E8;
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00018370) --------------------------------------------------------
unsigned int __fastcall sub_18370(int a1)
{
  __int16 v2; // ax
  __int16 v3; // cx
  __int16 v4; // bx
  __int16 v5; // ax
  void *v6; // eax
  void *v7; // eax
  char *v8; // ebp
  T_Type1 v10; // [esp+0h] [ebp-15Ch] BYREF
  char s[20]; // [esp+118h] [ebp-44h] BYREF
  _WORD v12[10]; // [esp+12Ch] [ebp-30h] BYREF
  int i; // [esp+140h] [ebp-1Ch]

  v2 = *(_WORD *)(a1 + 0x10) - *(_WORD *)(a1 + 8);
  v3 = *(_WORD *)(a1 + 0xC);
  *(_WORD *)(a1 + 0x4F22) = v2;
  v4 = v2;
  v5 = *(_WORD *)(a1 + 0x14);
  *(_WORD *)(a1 + 0x4F22) = v4 >> 1;
  *(_WORD *)(a1 + 0x4F24) = (__int16)(v5 - v3) >> 1;
  *(_DWORD *)(a1 + 0x1D1E) = 0;
  *(_DWORD *)(a1 + 0x1D22) = 0;
  *(_DWORD *)(a1 + 0x1D26) = 0;
  if ( *(_DWORD *)(a1 + 0x1D2A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x65E);
  }
  if ( *(_DWORD *)(a1 + 0x19BE) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x65F);
  }
  *(_DWORD *)(a1 + 0x1D2E) = 0x80;
  v6 = operator new[](0x35 * *(_DWORD *)(a1 + 0x1D2E));
  sub_2625C(v6, 1, "BATDISPLAYITEMS");
  *(_DWORD *)(a1 + 0x1D2A) = v6;
  if ( !v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x669);
  }
  *(_DWORD *)(a1 + 0x19C2) = 0x27;
  v7 = operator new[](*(_DWORD *)(a1 + 0x19C2) << 8);
  sub_2625C(v7, 1, "BATHAZE");
  *(_DWORD *)(a1 + 0x19BE) = v7;
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x66F);
  }
  v8 = *(char **)(a1 + 0x19BE);
  Q_InitFileInfo_sub_1BB78(&v10);
  for ( i = 0; i < 0x1F; ++i )
  {
    sprintf(s, "DATA\\BLACK%.2d.HAZ", i);
    if ( Q_CfilePreload_sub_1BBFC(&v10, s, 0x200, 0) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\batmode.cpp", 0x67B);
    }
    Q_CfileLoad_sub_1BF1C(&v10, v8);
    v8 += 0x100;
  }
  if ( Q_CfilePreload_sub_1BBFC(&v10, "DATA\\SLANE03.HAZ", 0x200, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\batmode.cpp", 0x680);
  }
  Q_CfileLoad_sub_1BF1C(&v10, v8);
  i = 0x41;
  strcpy((char *)v12, "DATA\\RACEA03.HAZ");
  HIBYTE(v12[8]) = aDataRacea03Haz[0x11];
  v12[9] = *(_WORD *)&aDataRacea03Haz[0x12];
  do
  {
    HIBYTE(v12[4]) = i;
    v8 += 0x100;
    if ( Q_CfilePreload_sub_1BBFC(&v10, (const char *)v12, 0x200, 0) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x68A);
    }
    Q_CfileLoad_sub_1BF1C(&v10, v8);
    ++i;
  }
  while ( i < 0x48 );
  Q_CloseFileAndDelete_sub_1BBC8(&v10);
  return 0xFFFFFFFF;
}

//----- (000185CC) --------------------------------------------------------
int __fastcall sub_185CC(int a1)
{
  int v2; // esi
  int v3; // edx
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // edx
  int result; // eax

  v2 = *(__int16 *)(dword_D3660 + 4);
  if ( v2 >= 0x64 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x697);
  }
  v3 = a1 + 0xBE;
  v4 = 0xC * v2;
  *(_DWORD *)(v3 + v4) = *(_DWORD *)(a1 + 0x4E7A);
  *(_DWORD *)(v3 + v4 + 4) = *(_DWORD *)(a1 + 0x4E7E);
  *(_DWORD *)(v3 + v4 + 8) = *(_DWORD *)(a1 + 0x4E82);
  v5 = 0x24 * v2 + a1 + 0x56E;
  v6 = (_DWORD *)(v5 + 0xC);
  *(float *)v5 = *(float *)(a1 + 0x4E46);
  v5 += 0x18;
  *(float *)(v5 - 0x14) = *(float *)(a1 + 0x4E4A);
  *(_DWORD *)(v5 - 0x10) = *(_DWORD *)(a1 + 0x4E4E);
  *v6 = *(_DWORD *)(a1 + 0x4E52);
  v6[1] = *(_DWORD *)(a1 + 0x4E56);
  v6[2] = *(_DWORD *)(a1 + 0x4E5A);
  *(_DWORD *)v5 = *(_DWORD *)(a1 + 0x4E5E);
  *(_DWORD *)(v5 + 4) = *(_DWORD *)(a1 + 0x4E62);
  v7 = a1 + 0x150E;
  *(float *)(v5 + 8) = *(float *)(a1 + 0x4E66);
  result = a1 + 0x1D1E;
  *(_DWORD *)(v7 + v4) = *(_DWORD *)(a1 + 0x1D1E);
  *(_DWORD *)(v7 + v4 + 4) = *(_DWORD *)(a1 + 0x1D22);
  *(_DWORD *)(v7 + v4 + 8) = *(_DWORD *)(a1 + 0x1D26);
  *(_DWORD *)(a1 + 0x4F2F) = 0;
  *(_BYTE *)(a1 + 0xB7) = 0;
  *(_DWORD *)(a1 + 0xB3) = 0;
  return result;
}
// D3660: using guessed type int dword_D3660;

//----- (000186B8) --------------------------------------------------------
void __fastcall sub_186B8(int a1, int a2, int a3)
{
  int v4; // esi
  int v5; // edx
  int v6; // ebx
  float *v7; // edi
  double v8; // st7

  sub_187EC(a1);
  v4 = *(__int16 *)(dword_D3660 + 4);
  if ( v4 >= 0x64 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x6AE);
  }
  v5 = a1 + 4 * v4;
  if ( *(_DWORD *)(v5 + 0x137E) )
  {
    *(_DWORD *)(a1 + 0x4E7A) = *(_DWORD *)(a1 + 0xBE + 0xC * v4);
    *(_DWORD *)(a1 + 0x4E7E) = *(_DWORD *)(a1 + 0xBE + 0xC * v4 + 4);
    v6 = 0x24 * v4 + a1 + 0x56E;
    *(float *)(a1 + 0x4E82) = *(float *)(a1 + 0xBE + 0xC * v4 + 8);
    v7 = (float *)(v6 + 0xC);
    *(float *)(a1 + 0x4E46) = *(float *)v6;
    v8 = *(float *)(v6 + 4);
    v6 += 0x18;
    *(float *)(a1 + 0x4E4A) = v8;
    *(float *)(a1 + 0x4E4E) = *(float *)(v6 - 0x10);
    *(float *)(a1 + 0x4E52) = *v7;
    *(float *)(a1 + 0x4E56) = v7[1];
    *(float *)(a1 + 0x4E5A) = v7[2];
    *(_DWORD *)(a1 + 0x4E5E) = *(_DWORD *)v6;
    *(_DWORD *)(a1 + 0x4E62) = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(a1 + 0x4E66) = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(a1 + 0x1D1E) = *(_DWORD *)(a1 + 0x150E + 0xC * v4);
    *(_DWORD *)(a1 + 0x1D22) = *(_DWORD *)(a1 + 0x150E + 0xC * v4 + 4);
    *(_DWORD *)(a1 + 0x1D26) = *(_DWORD *)(a1 + 0x150E + 0xC * v4 + 8);
    *(float *)(a1 + 0x4F16) = sqrt(
                                *(float *)(a1 + 0x4E7E) * *(float *)(a1 + 0x4E7E)
                              + *(float *)(a1 + 0x4E7A) * *(float *)(a1 + 0x4E7A)
                              + *(float *)(a1 + 0x4E82) * *(float *)(a1 + 0x4E82));
    sub_181F0(a1);
  }
  else
  {
    sub_17FF0(a1, v5, a3, a1);
    *(_DWORD *)(v5 + 0x137E) = 0xFFFFFFFF;
  }
  sub_18C2C(a1, 0);
}
// D3660: using guessed type int dword_D3660;

//----- (000187EC) --------------------------------------------------------
int __fastcall sub_187EC(int a1)
{
  __int16 i; // si
  int v3; // eax
  int v4; // esi
  __int16 v5; // ax
  int v6; // esi
  unsigned __int16 *v7; // eax
  int v8; // ecx
  int v9; // ebx
  int v10; // eax
  signed __int16 v11; // cx
  float *v12; // eax
  float v13; // eax
  int v14; // ebp
  __int16 *v15; // eax
  int v16; // ebp
  unsigned __int16 v17; // ax
  __int16 v18; // cx
  int v19; // ebp
  int v20; // eax
  __int16 v21; // bx
  int result; // eax
  int v23; // ecx
  double x; // [esp+0h] [ebp-1ECh]
  int v25[107]; // [esp+8h] [ebp-1E4h] BYREF
  float v26; // [esp+1B4h] [ebp-38h]
  float v27; // [esp+1B8h] [ebp-34h]
  float v28; // [esp+1BCh] [ebp-30h]
  float v29; // [esp+1C0h] [ebp-2Ch]
  int v30; // [esp+1C4h] [ebp-28h]
  int v31; // [esp+1C8h] [ebp-24h]
  int v32; // [esp+1CCh] [ebp-20h]
  int v33; // [esp+1D0h] [ebp-1Ch]

  for ( i = 0; i < *(_DWORD *)(a1 + 0x1D2E); ++i )
  {
    v3 = 0x35 * i;
    *(_BYTE *)(*(_DWORD *)(a1 + 0x1D2A) + v3 + 0x33) = 0;
  }
  v4 = *(_DWORD *)(a1 + 0x1D2A);
  *(_DWORD *)(a1 + 0x1D32) = 0;
  *(_BYTE *)v4 = 6;
  *(_DWORD *)(a1 + 0x1D16) = v4;
  *(_WORD *)(v4 + 5) = 0xFFFF;
  v5 = 0;
  v6 = v4 + 0x35;
  ++*(_DWORD *)(a1 + 0x1D32);
  while ( v5 < 1 )
  {
    *(_BYTE *)v6 = 0xFF;
    ++v5;
    v6 += 0x35;
    ++*(_DWORD *)(a1 + 0x1D32);
  }
  *(_BYTE *)v6 = 0;
  v7 = (unsigned __int16 *)dword_D3660;
  *(_DWORD *)(v6 + 1) = dword_D3660;
  sub_1826C(a1, v6, 1u, *v7);
  v8 = *(_DWORD *)(a1 + 0x1D32) + 1;
  LOWORD(v32) = 0;
  *(_DWORD *)(a1 + 0x1D32) = v8;
  while ( (__int16)v32 < *(__int16 *)(dword_D3660 + 0x5A) )
  {
    if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x6FC);
    }
    v6 += 0x35;
    v10 = *(_DWORD *)(dword_D3660 + 4 * (__int16)v32 + 0x46);
    *(_BYTE *)v6 = 1;
    *(_DWORD *)(v6 + 1) = v10;
    v11 = *(_WORD *)(v10 + 0x14) + 5 * *(_WORD *)(v10 + 0x16);
    if ( v11 >= 0x37 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x706);
    }
    sub_1826C(a1, v6, 0, v11);
    v9 = *(_DWORD *)(a1 + 0x1D32) + 1;
    LOWORD(v32) = v32 + 1;
    *(_DWORD *)(a1 + 0x1D32) = v9;
  }
  v12 = *(float **)(v6 + 1);
  x = v12[1] * v12[1] + *v12 * *v12 + v12[2] * v12[2];
  LOWORD(v33) = 0;
  *(float *)(a1 + 0x4F1E) = sqrt(x);
  while ( 1 )
  {
    v15 = (__int16 *)dword_D3660;
    if ( (__int16)v33 >= *(__int16 *)(dword_D3660 + 0x44) )
    {
      break;
    }
    if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x716);
    }
    v6 += 0x35;
    v16 = *(_DWORD *)(dword_D3660 + 4 * (__int16)v33 + 0x2C);
    *(_BYTE *)v6 = 3;
    *(_DWORD *)(v6 + 1) = v16;
    v17 = (*(_BYTE *)(v16 + 0x23) & 1) != 0;
    if ( (*(_BYTE *)(v16 + 0x23) & 2) != 0 )
    {
      v17 += 2;
    }
    sub_1826C(a1, v6, 2u, v17);
    v26 = 0.0;
    v27 = 0.0;
    v28 = 0.0;
    if ( dword_D3660 == *(_DWORD *)v16 )
    {
      *(_BYTE *)(v6 + 0x33) |= 1u;
      v26 = *(float *)(v16 + 8);
      v27 = *(float *)(v16 + 0xC);
      v13 = *(float *)(v16 + 0x10);
    }
    else
    {
      *(_BYTE *)(v6 + 0x33) &= ~1u;
      v26 = *(float *)(v16 + 0x14);
      v27 = *(float *)(v16 + 0x18);
      v13 = *(float *)(v16 + 0x1C);
    }
    v28 = v13;
    v29 = sqrt(v27 * v27 + v26 * v26 + v13 * v13);
    if ( *(float *)(a1 + 0x4F1E) < (double)v29 )
    {
      *(float *)(a1 + 0x4F1E) = v29;
    }
    v14 = *(_DWORD *)(a1 + 0x1D32) + 1;
    LOWORD(v33) = v33 + 1;
    *(_DWORD *)(a1 + 0x1D32) = v14;
  }
  v18 = 0;
  *(float *)(a1 + 0x4F1E) = *(float *)(a1 + 0x4F1E) + flt_905FA;
  v30 = sub_1D794(v15, v25);
  while ( v18 < v30 )
  {
    v19 = v25[v18];
    if ( *(_BYTE *)(v19 + 0x58) == 4 )
    {
      if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x750);
      }
      v6 += 0x35;
      *(_DWORD *)(v6 + 1) = v19;
      *(_BYTE *)v6 = 2;
      sub_156C0(v6, (unsigned __int16)word_FFEBC[*(__int16 *)(v19 + 0x56)], *(char *)(v19 + 0xAA));
      ++*(_DWORD *)(a1 + 0x1D32);
    }
    ++v18;
  }
  LOWORD(v31) = 0;
  if ( word_D365E > 0 )
  {
    do
    {
      if ( *(_DWORD *)(a1 + 0x1D32) >= *(_DWORD *)(a1 + 0x1D2E) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x761);
      }
      v20 = 0xD * (__int16)v31;
      v6 += 0x35;
      *(_BYTE *)v6 = 4;
      *(_DWORD *)(v6 + 1) = &byte_D35E9[v20];
      sub_1826C(a1, v6, 3u, byte_D35E9[v20]);
      v21 = v31;
      ++*(_DWORD *)(a1 + 0x1D32);
      LOWORD(v31) = v21 + 1;
    }
    while ( (__int16)(v21 + 1) < word_D365E );
  }
  for ( result = 0; (__int16)result < *(_DWORD *)(a1 + 0x1D32); ++result )
  {
    v23 = 0x35 * (__int16)result;
    *(_BYTE *)(v23 + *(_DWORD *)(a1 + 0x1D2A) + 0x33) &= ~4u;
  }
  return result;
}
// 905FA: using guessed type float flt_905FA;
// D365E: using guessed type __int16 word_D365E;
// D3660: using guessed type int dword_D3660;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// 187EC: using guessed type int var_1E4[107];

//----- (00018C2C) --------------------------------------------------------
void __fastcall sub_18C2C(int a1, int a2)
{
  size_t *v4; // ecx
  int v5; // edx

  v4 = (size_t *)(a1 + 0x1D36);
  v5 = a1 + 0x253A;
  sub_15788(a1 + 0x1D36);
  sub_15788(a1 + 0x253A);
  sub_15788(a1 + 0x2D3E);
  sub_15D2C(a1 + 0x3542);
  sub_173F4(a1, v5, a1, (int)v4);
  sub_157EC(v4);
  sub_157EC((size_t *)(a1 + 0x253A));
  if ( !a2 )
  {
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
  }
}

//----- (00018CA8) --------------------------------------------------------
void __fastcall sub_18CA8(int a1, int a2)
{
  char v3; // ah
  int v4; // eax
  char *v5; // eax
  int v6; // ebx
  int v7; // edx
  int v8; // edx
  __int16 v9; // bx
  const char *v10; // esi
  char *v11; // edi
  int v12; // edx
  char v13; // al
  char v14; // al
  int v15; // edx
  char *v16; // ecx
  int v17; // ebx
  char *v18; // eax
  int v19; // eax
  char *v20; // eax
  char *v21; // esi
  int v22; // edx
  char *v23; // edi
  char v24; // al
  char v25; // al
  __int16 v26; // dx
  int v27; // ebx
  char *v28; // esi
  char *v29; // eax
  char *v30; // edi
  char v31; // al
  char v32; // al
  char *v33; // edi
  char *v34; // esi
  char v35; // al
  char v36; // al
  char *v37; // edi
  char *v38; // esi
  char v39; // al
  char v40; // al
  int v41; // eax
  int v42; // ebx
  char *v43; // esi
  char *v44; // edi
  char v45; // al
  char v46; // al
  char *v47; // esi
  char *v48; // edi
  char v49; // al
  char v50; // al
  char *v51; // edi
  char *sub_1CEA8; // esi
  char v53; // al
  char v54; // al
  int v55; // eax
  char v56; // dl
  const char *v57; // ecx
  __int16 v58; // [esp-Ch] [ebp-198h]
  int v59; // [esp-4h] [ebp-190h]
  char *v60; // [esp-4h] [ebp-190h]
  _DWORD v61[50]; // [esp+0h] [ebp-18Ch] BYREF
  char v62[80]; // [esp+C8h] [ebp-C4h] BYREF
  char s[60]; // [esp+118h] [ebp-74h] BYREF
  char v64[32]; // [esp+154h] [ebp-38h] BYREF
  int v65; // [esp+174h] [ebp-18h]

  if ( !a2 )
  {
    unk_9A23C = *(_DWORD *)(a1 + 4);
    *((_DWORD *)&unk_9A23C + 1) = *(_DWORD *)(a1 + 8);
    *((_DWORD *)&unk_9A23C + 2) = *(_DWORD *)(a1 + 0xC);
    *((_DWORD *)&unk_9A23C + 3) = *(_DWORD *)(a1 + 0x10);
    *((_DWORD *)&unk_9A23C + 4) = *(_DWORD *)(a1 + 0x14);
  }
  VFX_pane_wipe((PANE *)(a1 + 4), *(unsigned __int8 *)(a1 + 0x4F2E));
  sub_15948(a1 + 0x2D3E, a1);
  sub_19AE8(a1);
  sub_15948(a1 + 0x253A, a1);
  if ( *(_DWORD *)(a1 + 0x5046) )
  {
    sub_15D74(a1 + 0x3542, a1);
  }
  if ( !*(_DWORD *)(a1 + 0xAF) )
  {
    v3 = *(_BYTE *)(a1 + 0xB7);
    if ( v3 == 2 || v3 == 3 )
    {
      sub_15DA4(a1 + 0x3542, a1, *(_WORD *)(a1 + 0xBC));
    }
  }
  if ( *(_DWORD *)(a1 + 0x503A) && (*(_BYTE *)(a1 + 0x4F2F) & 1) == 0 )
  {
    sub_1936C(a1);
  }
  if ( *(_DWORD *)(a1 + 0x5046) )
  {
    sub_15E1C((int *)(a1 + 0x3542), a1);
  }
  sub_15948(a1 + 0x1D36, a1);
  sub_53E38((P_Type5)(a1 + 4), 3, 3, (unsigned __int8)byte_104BEA);
  if ( !*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x7AC);
  }
  v4 = *(_DWORD *)(a1 + 0xAF);
  v65 = 0;
  if ( v4 )
  {
    v51 = s;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(2); // 2: "Unknown"
    do
    {
      v53 = *sub_1CEA8;
      *v51 = *sub_1CEA8;
      if ( !v53 )
      {
        break;
      }
      v54 = sub_1CEA8[1];
      sub_1CEA8 += 2;
      v51[1] = v54;
      v51 += 2;
    }
    while ( v54 );
    v55 = *(_DWORD *)(a1 + 0xAF);
    v26 = 0xF3;
    switch ( *(_BYTE *)v55 )
    {
      case 0:
        v59 = *(_DWORD *)(v55 + 1) + 0x1C;
        v5 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(3);    // 3: "Sun %s"
        sprintf(s, v5, v59);
        break;
      case 1:
        v17 = *(_DWORD *)(v55 + 1);
        v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(4);   // 4: "Planet %s"
        sprintf(s, v18, v17 + 0x24);
        v19 = *(unsigned __int8 *)(v17 + 0x57);
        if ( v19 != 0xFF )
        {
          v60 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v19)];
          v20 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(5); // 5: "\nOwned by %s"
          v21 = v64;
          sprintf(v64, v20, v60);
          v22 = 0;
          v23 = &s[strlen(s)];
          do
          {
            v24 = *v21;
            *v23 = *v21;
            if ( !v24 )
            {
              break;
            }
            v25 = v21[1];
            v21 += 2;
            v23[1] = v25;
            v23 += 2;
          }
          while ( v25 );
          LOBYTE(v22) = *(_BYTE *)(v17 + 0x57);
          v26 = 4 * (unsigned __int8)byte_A2F74[0x1EE * v22] + 0x13;
        }
        break;
      case 2:
        v65 = *(_DWORD *)(v55 + 1);
        v27 = v65;
        sprintf(
          s,
          "%s %s",
          &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(__int16 *)(v65 + 0x56))],
          (const char *)(v65 + 0x34));
        if ( *(_WORD *)(v27 + 0x56) == (unsigned __int8)byte_104BEA && *(_BYTE *)(v27 + 0x5D) )
        {
          v28 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(6); // 6: "\nMoving to Star Lane"
          v29 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(7); // 7: "\nMoving to Planet"
          if ( *(_BYTE *)(v27 + 0x5D) != 1 )
          {
            v28 = v29;
          }
          v30 = &s[strlen(s)];
          do
          {
            v31 = *v28;
            *v30 = *v28;
            if ( !v31 )
            {
              break;
            }
            v32 = v28[1];
            v28 += 2;
            v30[1] = v32;
            v30 += 2;
          }
          while ( v32 );
        }
        v26 = 4 * (unsigned __int8)byte_A2F74[0x1EE * *(__int16 *)(v27 + 0x56)] + 0x13;
        break;
      case 3:
        v33 = s;
        v34 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(8);   // 8: "Star Lane"
        do
        {
          v35 = *v34;
          *v33 = *v34;
          if ( !v35 )
          {
            break;
          }
          v36 = v34[1];
          v34 += 2;
          v33[1] = v36;
          v33 += 2;
        }
        while ( v36 );
        if ( (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 1) + 0x23) & 1) != 0 )
        {
          v37 = s;
          v38 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(9); // 9: "Red Link"
          do
          {
            v39 = *v38;
            *v37 = *v38;
            if ( !v39 )
            {
              break;
            }
            v40 = v38[1];
            v38 += 2;
            v37[1] = v40;
            v37 += 2;
          }
          while ( v40 );
        }
        v41 = *(_DWORD *)(a1 + 0xAF);
        if ( (*(_BYTE *)(v41 + 0x33) & 1) != 0 )
        {
          v42 = *(_DWORD *)(*(_DWORD *)(v41 + 1) + 4);
        }
        else
        {
          v42 = **(_DWORD **)(v41 + 1);
        }
        if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(v42 + 0x17)) != 0 )
        {
          v43 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xA);// 10: " to "
          v44 = &s[strlen(s)];
          do
          {
            v45 = *v43;
            *v44 = *v43;
            if ( !v45 )
            {
              break;
            }
            v46 = v43[1];
            v43 += 2;
            v44[1] = v46;
            v44 += 2;
          }
          while ( v46 );
          v47 = (char *)(v42 + 0x1C);
          v48 = &s[strlen(s)];
          do
          {
            v49 = *v47;
            *v48 = *v47;
            if ( !v49 )
            {
              break;
            }
            v50 = v47[1];
            v47 += 2;
            v48[1] = v50;
            v48 += 2;
          }
          while ( v50 );
        }
        break;
      default:
        break;
    }
    v58 = v26;
    v6 = *(_DWORD *)(a1 + 0x14) - 0x1E;
    v7 = *(_DWORD *)(a1 + 0x10) - 0xC8;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v7, v6, s, 0, v58, 0xFF, 0);
  }
  v8 = v65;
  sub_17260(a1);
  if ( v8 )
  {
    v9 = dword_A0CFC;
    if ( dword_A0CFC == 0xFFFFFFFF )
    {
      sprintf(
        v62,
        "%s %s",
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(__int16 *)(v8 + 0x56))],
        (const char *)(v8 + 0x34));
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xFA, 0xA, v62, 0, v9, v9, 0);
      sprintf(
        v62,
        "POWER %d MOVES %d INTEGRITY %d",
        *(_DWORD *)(v65 + 0x88),
        *(_DWORD *)(v65 + 0x94),
        *(_DWORD *)(v65 + 0x8C));
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xFA, 0x14, v62, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      qmemcpy(v61, "SONothing", sizeof(v61));
      v10 = "INVALID ORDER";
      v11 = v62;
      v12 = v65;
      do
      {
        v13 = *v10;
        *v11 = *v10;
        if ( !v13 )
        {
          break;
        }
        v14 = v10[1];
        v10 += 2;
        v11[1] = v14;
        v11 += 2;
      }
      while ( v14 );
      v15 = *(char *)(v12 + 0x5D);
      if ( v15 >= 0 && *(char *)(v65 + 0x5D) <= 7 )
      {
        v16 = (char *)&v61[5 * v15];
      }
      else
      {
        v16 = v62;
      }
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xFA, 0x1E, v16, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v56 = *(_BYTE *)(v65 + 0x5D);
      if ( v56 == 1 )
      {
        v57 = (const char *)(*(_DWORD *)(v65 + 0x5E) + 0x1C);
LABEL_68:
        *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x140, 0x1E, v57, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
        goto LABEL_69;
      }
      if ( v56 == 2 )
      {
        v57 = (const char *)(*(_DWORD *)(v65 + 0x5E) + 0x24);
        goto LABEL_68;
      }
    }
  }
LABEL_69:
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&unk_9A23C);
}
// 96BAC: using guessed type int dword_96BAC;
// A0CFC: using guessed type int dword_A0CFC;
// 18CA8: using guessed type char s[60];

//----- (0001936C) --------------------------------------------------------
void __fastcall sub_1936C(int a1)
{
  double v2; // st7
  int v3; // eax
  int v4; // edx
  double v5; // st7
  int v6; // ebp
  float *v7; // edi
  double v8; // st7
  double v9; // st7
  float *v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // ebp
  float *v14; // edi
  double v15; // st7
  double v16; // st7
  float *v17; // edx
  int v18; // ecx
  int v19; // ebx
  int v20[3]; // [esp+8h] [ebp-110h] BYREF
  float v21; // [esp+14h] [ebp-104h]
  float v22; // [esp+18h] [ebp-100h]
  float v23; // [esp+1Ch] [ebp-FCh]
  float v24; // [esp+20h] [ebp-F8h]
  float v25; // [esp+24h] [ebp-F4h]
  float v26; // [esp+28h] [ebp-F0h]
  float v27; // [esp+2Ch] [ebp-ECh]
  float v28; // [esp+30h] [ebp-E8h]
  float v29; // [esp+34h] [ebp-E4h]
  float v30[3]; // [esp+38h] [ebp-E0h] BYREF
  float v31; // [esp+44h] [ebp-D4h] BYREF
  float v32; // [esp+48h] [ebp-D0h]
  float v33; // [esp+4Ch] [ebp-CCh]
  float v34; // [esp+50h] [ebp-C8h] BYREF
  float v35; // [esp+54h] [ebp-C4h]
  float v36; // [esp+58h] [ebp-C0h]
  int v37[3]; // [esp+5Ch] [ebp-BCh] BYREF
  float v38; // [esp+68h] [ebp-B0h]
  float v39; // [esp+6Ch] [ebp-ACh]
  float v40; // [esp+70h] [ebp-A8h]
  int v41[3]; // [esp+74h] [ebp-A4h] BYREF
  int v42[3]; // [esp+80h] [ebp-98h] BYREF
  float v43; // [esp+8Ch] [ebp-8Ch]
  int *v44; // [esp+90h] [ebp-88h]
  int *v45; // [esp+94h] [ebp-84h]
  int v46; // [esp+98h] [ebp-80h]
  float v47; // [esp+9Ch] [ebp-7Ch]
  int *v48; // [esp+A0h] [ebp-78h]
  int *v49; // [esp+A4h] [ebp-74h]
  int v50; // [esp+A8h] [ebp-70h]
  PANE *v51; // [esp+ACh] [ebp-6Ch]
  PANE *pane; // [esp+B0h] [ebp-68h]
  int v53; // [esp+B4h] [ebp-64h]
  float *v54; // [esp+B8h] [ebp-60h]
  float *v55; // [esp+BCh] [ebp-5Ch]
  LONG parm; // [esp+C0h] [ebp-58h]
  int v57; // [esp+C4h] [ebp-54h]
  float v58; // [esp+C8h] [ebp-50h]
  int v59; // [esp+CCh] [ebp-4Ch]
  int v60; // [esp+D0h] [ebp-48h]
  int v61; // [esp+D4h] [ebp-44h]
  int v62; // [esp+D8h] [ebp-40h]
  float v63; // [esp+DCh] [ebp-3Ch]
  float v64; // [esp+E0h] [ebp-38h]
  float v65; // [esp+E4h] [ebp-34h]
  float v66; // [esp+E8h] [ebp-30h]
  float v67; // [esp+ECh] [ebp-2Ch]
  int v68; // [esp+F0h] [ebp-28h] BYREF
  int v69; // [esp+F4h] [ebp-24h] BYREF
  int v70; // [esp+F8h] [ebp-20h] BYREF
  __int16 v71[14]; // [esp+FCh] [ebp-1Ch] BYREF

  v31 = 0.0;
  v32 = 0.0;
  v33 = 0.0;
  v34 = 0.0;
  v35 = 0.0;
  v36 = 0.0;
  memset(v30, 0, sizeof(v30));
  v2 = *(float *)(a1 + 0x4F2A) * flt_90646;
  v58 = v2;
  v58 = v2 * v58;
  v46 = (int)(*(float *)(a1 + 0x4F2A) * flt_9064A);
  v59 = v46 + 2;
  v3 = 0x20 * ((v46 + 2) / 2);
  v46 = (int)(*(float *)(a1 + 0x4F2A) * flt_9064E);
  v50 = v3 + 0x10;
  v4 = (v46 + 2) / 2;
  v53 = 0x68;
  parm = 0x61;
  v60 = 0xA0 * v4 + 0x10;
  if ( v60 > v3 + 0x10 )
  {
    v60 = 0xA0 * v4 - 0x90;
  }
  v5 = *(float *)(a1 + 0x4F2A);
  v61 = 0xFFFFFFFF;
  v57 = 0;
  if ( v5 < flt_90652 )
  {
    v57 = 0xFFFFFFFF;
  }
  v6 = 0;
  v65 = *(float *)(a1 + 0x4F16) * flt_90656;
  v67 = (float)v50;
  if ( v59 > 0 )
  {
    v7 = (float *)(a1 + 0x1D1E);
    pane = (PANE *)(a1 + 4);
    v54 = (float *)(a1 + 0x4E86);
    do
    {
      if ( (double)v60 == v67 )
      {
        v61 = v6;
      }
      v63 = v58 - v67 * v67;
      if ( v63 > 0.0 )
      {
        v63 = sqrt(v63);
        v31 = v67;
        v32 = v65;
        v38 = 0.0;
        v33 = v63;
        v34 = v67;
        v43 = -v63;
        v35 = v65;
        v39 = 0.0;
        v36 = v43;
        v40 = 0.0;
        v45 = v37;
        v38 = v67 + *v7;
        v39 = v65 + *(float *)(a1 + 0x1D22);
        v8 = v63 + *(float *)(a1 + 0x1D26);
        *(float *)v37 = v38;
        v40 = v8;
        *(float *)&v37[1] = v39;
        *(float *)&v37[2] = v40;
        v31 = v38;
        v27 = 0.0;
        v32 = v39;
        v28 = 0.0;
        v33 = v40;
        v29 = 0.0;
        v44 = v41;
        v27 = v67 + *v7;
        v28 = v65 + *(float *)(a1 + 0x1D22);
        v9 = v43 + *(float *)(a1 + 0x1D26);
        *(float *)v41 = v27;
        v29 = v9;
        *(float *)&v41[1] = v28;
        *(float *)&v41[2] = v29;
        v34 = v27;
        v35 = v28;
        v36 = v29;
        sub_53384(&v31, v54, v30);
        v10 = v54;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)&v69,
          (int)&v70);
        sub_53384(&v34, v10, v30);
        v11 = v61;
        v12 = 0xFFFFFFFF;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)v71,
          (int)&v68);
        if ( v11 < 0 || (v6 - v11) % 5 )
        {
          if ( v57 )
          {
            v12 = v53;
          }
        }
        else
        {
          v12 = parm;
        }
        if ( v12 != 0xFFFFFFFF )
        {
          VFX_line_draw(pane, (__int16)v69, (__int16)v70, v71[0], (__int16)v68, 0, v12);
        }
      }
      ++v6;
      v67 = v67 + flt_9065A;
    }
    while ( v6 < v59 );
  }
  v66 = (float)v50;
  v13 = 0;
  v62 = 0xFFFFFFFF;
  if ( v59 > 0 )
  {
    v14 = (float *)(a1 + 0x1D1E);
    v51 = (PANE *)(a1 + 4);
    v55 = (float *)(a1 + 0x4E86);
    do
    {
      if ( (double)v60 == v66 )
      {
        v62 = v13;
      }
      v64 = v58 - v66 * v66;
      if ( v64 > 0.0 )
      {
        v64 = sqrt(v64);
        v31 = v64;
        v32 = v65;
        v47 = -v64;
        v33 = v66;
        v34 = v47;
        v35 = v65;
        v36 = v66;
        v48 = v42;
        v24 = 0.0;
        v25 = 0.0;
        v26 = 0.0;
        v24 = v64 + *v14;
        v25 = v65 + *(float *)(a1 + 0x1D22);
        v15 = v66 + *(float *)(a1 + 0x1D26);
        *(float *)v42 = v24;
        v26 = v15;
        *(float *)&v42[1] = v25;
        *(float *)&v42[2] = v26;
        v31 = v24;
        v21 = 0.0;
        v32 = v25;
        v22 = 0.0;
        v33 = v26;
        v23 = 0.0;
        v49 = v20;
        v21 = v47 + *v14;
        v22 = v65 + *(float *)(a1 + 0x1D22);
        v16 = v66 + *(float *)(a1 + 0x1D26);
        *(float *)v20 = v21;
        v23 = v16;
        *(float *)&v20[1] = v22;
        *(float *)&v20[2] = v23;
        v34 = v21;
        v35 = v22;
        v36 = v23;
        sub_53384(&v31, v55, v30);
        v17 = v55;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)&v69,
          (int)&v70);
        sub_53384(&v34, v17, v30);
        v18 = v62;
        v19 = 0xFFFFFFFF;
        sub_533D4(
          v30,
          *(float *)(a1 + 0x4E6E),
          *(__int16 *)(a1 + 0x4F22),
          *(__int16 *)(a1 + 0x4F24),
          (int)v71,
          (int)&v68);
        if ( v18 < 0 || (v13 - v18) % 5 )
        {
          if ( v57 )
          {
            v19 = v53;
          }
        }
        else
        {
          v19 = parm;
        }
        if ( v19 != 0xFFFFFFFF )
        {
          VFX_line_draw(v51, (__int16)v69, (__int16)v70, v71[0], (__int16)v68, 0, v19);
        }
      }
      ++v13;
      v66 = v66 + flt_9065A;
    }
    while ( v13 < v59 );
  }
}
// 90646: using guessed type float flt_90646;
// 9064A: using guessed type float flt_9064A;
// 9064E: using guessed type float flt_9064E;
// 90652: using guessed type float flt_90652;
// 90656: using guessed type float flt_90656;
// 9065A: using guessed type float flt_9065A;
// 1936C: using guessed type __int16 var_1C[14];

//----- (00019AE8) --------------------------------------------------------
int __fastcall sub_19AE8(int a1)
{
  int v1; // ebp
  int v2; // edi
  int *v3; // esi
  __int16 v4; // ax
  int result; // eax
  double v6; // st7
  __int16 v7; // bx
  int v8[100]; // [esp+8h] [ebp-384h]
  char v9[200]; // [esp+198h] [ebp-1F4h] BYREF
  char v10[200]; // [esp+260h] [ebp-12Ch] BYREF
  float v11; // [esp+328h] [ebp-64h]
  float v12; // [esp+32Ch] [ebp-60h]
  float v13; // [esp+330h] [ebp-5Ch]
  int v14[3]; // [esp+334h] [ebp-58h] BYREF
  float v15; // [esp+340h] [ebp-4Ch] BYREF
  float v16; // [esp+344h] [ebp-48h]
  float v17; // [esp+348h] [ebp-44h]
  int *v18; // [esp+34Ch] [ebp-40h]
  float *v19; // [esp+350h] [ebp-3Ch]
  PANE *pane; // [esp+354h] [ebp-38h]
  int v21; // [esp+358h] [ebp-34h]
  int v22; // [esp+35Ch] [ebp-30h]
  int v23; // [esp+360h] [ebp-2Ch]
  int v24; // [esp+364h] [ebp-28h]
  int v25; // [esp+368h] [ebp-24h]
  int v26; // [esp+36Ch] [ebp-20h]
  __int16 v27; // [esp+370h] [ebp-1Ch]

  v24 = a1;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v21 = *(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC);
  if ( !v21 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\batmode.cpp", 0x8E7);
  }
  pane = (PANE *)(v24 + 4);
  v1 = 0;
  v2 = 0;
  v19 = (float *)(v24 + 0x4E46);
  v3 = (int *)&word_A3D21[4];
  v23 = (int)v10;
  v25 = 0;
  v22 = (int)v9;
  while ( 1 )
  {
    result = word_A62A1;
    if ( v1 >= word_A62A1 )
    {
      break;
    }
    v15 = *(float *)v3;
    v16 = *((float *)v3 + 1);
    v17 = *((float *)v3 + 2);
    v18 = v14;
    v11 = 0.0;
    v12 = 0.0;
    v13 = 0.0;
    v11 = v15 - *(float *)(dword_D3660 + 8);
    v12 = v16 - *(float *)(dword_D3660 + 0xC);
    v6 = v17 - *(float *)(dword_D3660 + 0x10);
    *(float *)v14 = v11;
    v13 = v6;
    *(float *)&v14[1] = v12;
    *(float *)&v14[2] = v13;
    v15 = v11;
    v16 = v12;
    v17 = v13;
    v8[v2] = 0;
    if ( !sub_53078(&v15) )
    {
      sub_53114(&v15, v19);
      *(float *)&v8[v2] = v17;
      if ( *(float *)&v8[v2] > 0.0 )
      {
        sub_533D4(&v15, *(float *)(v24 + 0x4E6E), *(__int16 *)(v24 + 0x4F22), *(__int16 *)(v24 + 0x4F24), v23, v22);
        v7 = word_A3D21[0x30 * v1];
        v26 = (int)(sqrt(v16 * v16 + v15 * v15 + v17 * v17) + flt_9066D);
        v27 = v26;
        v4 = 3;
        if ( (__int16)v26 <= 0xDC )
        {
          if ( v27 <= 0 )
          {
            if ( v27 > (int)0xFFFFFF24 )
            {
              v4 = 2;
            }
          }
          else
          {
            v4 = 1;
          }
        }
        else
        {
          v4 = 0;
        }
        VFX_shape_draw(pane, *(void **)(v21 + 0xAB), v4 + 4 * v7, *(__int16 *)&v10[v25], *(__int16 *)&v9[v25]);
      }
    }
    ++v2;
    v3 += 0x18;
    ++v1;
    v23 += 2;
    v22 += 2;
    v25 += 2;
  }
  return result;
}
// 9066D: using guessed type float flt_9066D;
// 96BAC: using guessed type int dword_96BAC;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// D3660: using guessed type int dword_D3660;

//----- (00019E2C) --------------------------------------------------------
__int64 __fastcall sub_19E2C(int a1, unsigned int a2, int a3)
{
  char *v4; // edi
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  int *v11; // edx
  _DWORD *v12; // edx
  _DWORD *v13; // edx
  _DWORD *v14; // edx
  _DWORD *v15; // edx
  _DWORD *v16; // edx
  _DWORD *v17; // edx
  _DWORD *v18; // edx
  _DWORD *v19; // edx
  _DWORD *v20; // edx
  _DWORD *v21; // edx
  _DWORD *v22; // edx
  _DWORD *v23; // edx
  _DWORD *v24; // edx
  int v26; // eax
  int v27; // eax
  _DWORD *v28; // eax
  _DWORD *v29; // eax
  _DWORD *v30; // esi
  _DWORD *v31; // eax
  _BYTE v32[1200]; // [esp+0h] [ebp-3460h] BYREF
  char v33[3600]; // [esp+4B0h] [ebp-2FB0h] BYREF
  char v34[400]; // [esp+12C0h] [ebp-21A0h] BYREF
  char v35[1200]; // [esp+1450h] [ebp-2010h] BYREF
  int v36; // [esp+1900h] [ebp-1B60h]
  int v37; // [esp+1904h] [ebp-1B5Ch]
  int v38; // [esp+1908h] [ebp-1B58h]
  int v39[55]; // [esp+190Ch] [ebp-1B54h] BYREF
  __int16 v40; // [esp+19E8h] [ebp-1A78h]
  __int16 v41; // [esp+19EAh] [ebp-1A76h]
  int v42; // [esp+19ECh] [ebp-1A74h]
  int v43; // [esp+19F0h] [ebp-1A70h]
  int v44; // [esp+19F4h] [ebp-1A6Ch]
  int v45; // [esp+19F8h] [ebp-1A68h]
  int v46; // [esp+19FCh] [ebp-1A64h]
  int v47; // [esp+1A00h] [ebp-1A60h]
  int v48; // [esp+1A04h] [ebp-1A5Ch]
  char v49[1200]; // [esp+1A08h] [ebp-1A58h] BYREF
  char v50[3600]; // [esp+1EB8h] [ebp-15A8h] BYREF
  char v51[400]; // [esp+2CC8h] [ebp-798h] BYREF
  char v52[1200]; // [esp+2E58h] [ebp-608h] BYREF
  int v53; // [esp+3308h] [ebp-158h]
  int v54; // [esp+330Ch] [ebp-154h]
  int v55; // [esp+3310h] [ebp-150h]
  int v56[63]; // [esp+3314h] [ebp-14Ch] BYREF
  unsigned int count; // [esp+3410h] [ebp-50h]
  char *v58; // [esp+3414h] [ebp-4Ch]
  char *v59; // [esp+3418h] [ebp-48h]
  char *v60; // [esp+341Ch] [ebp-44h]
  _DWORD *v61; // [esp+3420h] [ebp-40h]
  _DWORD *v62; // [esp+3424h] [ebp-3Ch]
  _DWORD *v63; // [esp+3428h] [ebp-38h]
  _DWORD *v64; // [esp+342Ch] [ebp-34h]
  _DWORD *v65; // [esp+3430h] [ebp-30h]
  _DWORD *v66; // [esp+3434h] [ebp-2Ch]
  _DWORD *v67; // [esp+3438h] [ebp-28h]
  _DWORD *v68; // [esp+343Ch] [ebp-24h]
  _DWORD *v69; // [esp+3440h] [ebp-20h]
  _DWORD *v70; // [esp+3444h] [ebp-1Ch]
  int *v71; // [esp+3448h] [ebp-18h]
  _DWORD *v72; // [esp+344Ch] [ebp-14h]

  count = a2;
  v68 = (_DWORD *)(a1 + 0x4EEA);
  v69 = (_DWORD *)(a1 + 0x4EDE);
  v72 = (_DWORD *)(a1 + 0x4E46);
  v71 = (int *)(a1 + 0x1D1E);
  v60 = (char *)(a1 + 0x150E);
  v59 = (char *)(a1 + 0x137E);
  v4 = (char *)(a1 + 0xBE);
  v58 = (char *)(a1 + 0x56E);
  v64 = (_DWORD *)(a1 + 0x4F02);
  v63 = (_DWORD *)(a1 + 0x4EF6);
  v70 = (_DWORD *)(a1 + 0x4EBA);
  v65 = (_DWORD *)(a1 + 0x4E7A);
  v66 = (_DWORD *)(a1 + 0x4E5E);
  v67 = (_DWORD *)(a1 + 0x4E52);
  v62 = (_DWORD *)(a1 + 0x4ED2);
  v61 = (_DWORD *)(a1 + 0x4EC6);
  if ( a3 == 0xFFFFFFFF )
  {
    v5 = _wcpp_2_ctor_array_(v49, 0x64, &unk_959D8);
    v6 = _wcpp_2_ctor_array_(v5 + 0x4B0, 0x64, &unk_95A3C);
    v7 = (_DWORD *)(_wcpp_2_ctor_array_(v6 + 0xFA0, 0x64, &unk_959D8) + 0x4B0);
    *v7 = 0;
    v7 += 3;
    v7[0xFFFFFFFE] = 0;
    v7[0xFFFFFFFF] = 0;
    v8 = sub_1B4F0(v7) + 0x26;
    v8[1] = 0;
    v8[2] = 0;
    *v8 = 0;
    v8 += 3;
    v9 = v8 + 3;
    sub_1ACA0(v8);
    sub_1ACA0(v9);
    v10 = v9 + 3;
    v9 += 0xFFFFFFFD;
    sub_1ACA0(v10);
    sub_1AC70((float *)v9, 1, 0, 0);
    sub_1AC70((float *)v9 + 3, 0, 1, 0);
    sub_1AC70((float *)v9 + 6, 0, 0, 1);
    sub_1BF94((P_Type1)count, v49, 0x1A08u);
    qmemcpy(v4, v49, 0x4B0u);
    qmemcpy(v58, v50, 0xE10u);
    qmemcpy(v59, v51, 0x190u);
    v11 = v71;
    qmemcpy(v60, v52, 0x4B0u);
    *v11 = v53;
    v11[1] = v54;
    v11[2] = v55;
    v12 = v72;
    *v72 = v56[0];
    v12[1] = v56[1];
    v12[2] = v56[2];
    v13 = v67;
    *v67 = v56[3];
    v13[1] = v56[4];
    v13[2] = v56[5];
    v14 = v66;
    *v66 = v56[6];
    v14[1] = v56[7];
    v14[2] = v56[8];
    v15 = v72;
    v72[9] = v56[9];
    v15[0xA] = v56[0xA];
    v15[0xB] = v56[0xB];
    v15[0xC] = v56[0xC];
    v16 = v65;
    *v65 = v56[0xD];
    v16[1] = v56[0xE];
    v16[2] = v56[0xF];
    v17 = v72;
    v72[0x10] = v56[0x10];
    v17[0x11] = v56[0x11];
    v17[0x12] = v56[0x12];
    v17[0x13] = v56[0x13];
    v17[0x14] = v56[0x14];
    v17[0x15] = v56[0x15];
    v17[0x16] = v56[0x16];
    v17[0x17] = v56[0x17];
    v17[0x18] = v56[0x18];
    v17[0x19] = v56[0x19];
    v17[0x1A] = v56[0x1A];
    v17[0x1B] = v56[0x1B];
    v17[0x1C] = v56[0x1C];
    v18 = v70;
    *v70 = v56[0x1D];
    v18[1] = v56[0x1E];
    v18[2] = v56[0x1F];
    v19 = v61;
    *v61 = v56[0x20];
    v19[1] = v56[0x21];
    v19[2] = v56[0x22];
    v20 = v62;
    *v62 = v56[0x23];
    v20[1] = v56[0x24];
    v20[2] = v56[0x25];
    v21 = v69;
    *v69 = v56[0x26];
    v21[1] = v56[0x27];
    v21[2] = v56[0x28];
    v22 = v68;
    *v68 = v56[0x29];
    v22[1] = v56[0x2A];
    v22[2] = v56[0x2B];
    v23 = v63;
    *v63 = v56[0x2C];
    v23[1] = v56[0x2D];
    v23[2] = v56[0x2E];
    v24 = v64;
    *v64 = v56[0x2F];
    v24[1] = v56[0x30];
    v24[2] = v56[0x31];
    *(_DWORD *)(a1 + 0x4F0E) = v56[0x32];
    *(_DWORD *)(a1 + 0x4F12) = v56[0x33];
    *(_DWORD *)(a1 + 0x4F16) = v56[0x34];
    *(_DWORD *)(a1 + 0x4F1A) = v56[0x35];
    *(_DWORD *)(a1 + 0x4F1E) = v56[0x36];
    *(_DWORD *)(a1 + 0x4F22) = v56[0x37];
    *(_DWORD *)(a1 + 0x4F26) = v56[0x38];
    *(_DWORD *)(a1 + 0x4F2A) = v56[0x39];
    *(_DWORD *)(a1 + 0x503A) = v56[0x3A];
    *(_DWORD *)(a1 + 0x503E) = v56[0x3B];
    *(_DWORD *)(a1 + 0x5042) = v56[0x3C];
    *(_DWORD *)(a1 + 0x5046) = v56[0x3D];
    *(_DWORD *)(a1 + 0x504A) = v56[0x3E];
    ((void (__fastcall *)(int *, _DWORD))locret_1B66C)(v56, 0);
    sub_1A9E0((int)v52);
    sub_1AA00((int)v50);
    return (unsigned int)sub_1A9E0((int)v49);
  }
  else
  {
    v26 = _wcpp_2_ctor_array_(v32, 0x64, &unk_959D8);
    v27 = _wcpp_2_ctor_array_(v26 + 0x4B0, 0x64, &unk_95A3C);
    v28 = (_DWORD *)(_wcpp_2_ctor_array_(v27 + 0xFA0, 0x64, &unk_959D8) + 0x4B0);
    *v28 = 0;
    v28 += 3;
    v28[0xFFFFFFFE] = 0;
    v28[0xFFFFFFFF] = 0;
    v29 = sub_1B4F0(v28) + 0x26;
    v29[1] = 0;
    v29[2] = 0;
    *v29 = 0;
    v29 += 3;
    v30 = v29 + 3;
    sub_1ACA0(v29);
    sub_1ACA0(v30);
    v31 = v30 + 3;
    v30 += 0xFFFFFFFD;
    sub_1ACA0(v31);
    sub_1AC70((float *)v30, 1, 0, 0);
    sub_1AC70((float *)v30 + 3, 0, 1, 0);
    sub_1AC70((float *)v30 + 6, 0, 0, 1);
    qmemcpy(v32, v4, sizeof(v32));
    qmemcpy(v33, v58, sizeof(v33));
    qmemcpy(v34, v59, sizeof(v34));
    qmemcpy(v35, v60, sizeof(v35));
    v36 = *v71;
    v37 = v71[1];
    v38 = v71[2];
    v39[0] = *v72;
    v39[1] = v72[1];
    v39[2] = v72[2];
    v39[3] = *v67;
    v39[4] = v67[1];
    v39[5] = v67[2];
    v39[6] = *v66;
    v39[7] = v66[1];
    v39[8] = v66[2];
    v39[9] = v72[9];
    v39[0xA] = v72[0xA];
    v39[0xB] = v72[0xB];
    v39[0xC] = v72[0xC];
    v39[0xD] = *v65;
    v39[0xE] = v65[1];
    v39[0xF] = v65[2];
    v39[0x10] = v72[0x10];
    v39[0x11] = v72[0x11];
    v39[0x12] = v72[0x12];
    v39[0x13] = v72[0x13];
    v39[0x14] = v72[0x14];
    v39[0x15] = v72[0x15];
    v39[0x16] = v72[0x16];
    v39[0x17] = v72[0x17];
    v39[0x18] = v72[0x18];
    v39[0x19] = v72[0x19];
    v39[0x1A] = v72[0x1A];
    v39[0x1B] = v72[0x1B];
    v39[0x1C] = v72[0x1C];
    v39[0x1D] = *v70;
    v39[0x1E] = v70[1];
    v39[0x1F] = v70[2];
    v39[0x20] = *v61;
    v39[0x21] = v61[1];
    v39[0x22] = v61[2];
    v39[0x23] = *v62;
    v39[0x24] = v62[1];
    v39[0x25] = v62[2];
    v39[0x26] = *v69;
    v39[0x27] = v69[1];
    v39[0x28] = v69[2];
    v39[0x29] = *v68;
    v39[0x2A] = v68[1];
    v39[0x2B] = v68[2];
    v39[0x2C] = *v63;
    v39[0x2D] = v63[1];
    v39[0x2E] = v63[2];
    v39[0x2F] = *v64;
    v39[0x30] = v64[1];
    v39[0x31] = v64[2];
    v39[0x32] = *(_DWORD *)(a1 + 0x4F0E);
    v39[0x33] = *(_DWORD *)(a1 + 0x4F12);
    v39[0x34] = *(_DWORD *)(a1 + 0x4F16);
    v39[0x35] = *(_DWORD *)(a1 + 0x4F1A);
    v39[0x36] = *(_DWORD *)(a1 + 0x4F1E);
    v40 = *(_WORD *)(a1 + 0x4F22);
    v41 = *(_WORD *)(a1 + 0x4F24);
    v42 = *(_DWORD *)(a1 + 0x4F26);
    v43 = *(_DWORD *)(a1 + 0x4F2A);
    v44 = *(_DWORD *)(a1 + 0x503A);
    v45 = *(_DWORD *)(a1 + 0x503E);
    v46 = *(_DWORD *)(a1 + 0x5042);
    v47 = *(_DWORD *)(a1 + 0x5046);
    v48 = *(_DWORD *)(a1 + 0x504A);
    sub_1C098(count, (int)v32, 0x1A08u);
    ((void (__fastcall *)(int *, _DWORD))locret_1B66C)(v39, 0);
    sub_1A9E0((int)v35);
    sub_1AA00((int)v33);
    return (unsigned int)sub_1A9E0((int)v32);
  }
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001A9C0) --------------------------------------------------------
int __fastcall sub_1A9C0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0xF, &unk_959D8);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001A9E0) --------------------------------------------------------
int __fastcall sub_1A9E0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x64, &unk_959D8);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001AA00) --------------------------------------------------------
int __fastcall sub_1AA00(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x64, &unk_95A3C);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001AA40) --------------------------------------------------------
_DWORD *__fastcall sub_1AA40(float *a1, float *a2)
{
  float *v2; // ebx
  float *v3; // eax
  double v4; // st7
  float *v5; // edx
  _DWORD *result; // eax

  v2 = a2 + 3;
  *a1 = *a2;
  v3 = a1 + 3;
  v4 = a2[1];
  v5 = a2 + 6;
  v3[0xFFFFFFFE] = v4;
  v3 += 3;
  v3[0xFFFFFFFC] = v5[0xFFFFFFFC];
  result = v3 + 0xFFFFFFFA;
  result[3] = *(_DWORD *)v2;
  result[4] = *((_DWORD *)v2 + 1);
  result[5] = *((_DWORD *)v2 + 2);
  result[6] = *(_DWORD *)v5;
  result[7] = *((_DWORD *)v5 + 1);
  result[8] = *((_DWORD *)v5 + 2);
  return result;
}

//----- (0001AA90) --------------------------------------------------------
__int64 __fastcall sub_1AA90(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax

  v1 = ((int (__fastcall *)(int, _DWORD))locret_1B66C)(a1 + 0x190C, 0);
  v2 = sub_1A9E0(v1 - 0x4BC);
  v3 = sub_1AA00(v2 - 0xFA0);
  return (unsigned int)sub_1A9E0(v3 - 0x4B0);
}

//----- (0001AAC0) --------------------------------------------------------
_DWORD *__fastcall sub_1AAC0(int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // edx
  _DWORD *result; // eax

  v1 = _wcpp_2_ctor_array_(a1, 0x64, &unk_959D8);
  v2 = _wcpp_2_ctor_array_(v1 + 0x4B0, 0x64, &unk_95A3C);
  v3 = (_DWORD *)(_wcpp_2_ctor_array_(v2 + 0xFA0, 0x64, &unk_959D8) + 0x4B0);
  *v3 = 0;
  v3 += 3;
  v3[0xFFFFFFFE] = 0;
  v3[0xFFFFFFFF] = 0;
  v4 = sub_1B4F0(v3) + 0x26;
  *v4 = 0;
  v4 += 3;
  v4[0xFFFFFFFE] = 0;
  v4[0xFFFFFFFF] = 0;
  *v4 = 0;
  v4 += 3;
  v4[0xFFFFFFFE] = 0;
  v4[0xFFFFFFFF] = 0;
  *v4 = 0;
  v4 += 3;
  v4[0xFFFFFFFE] = 0;
  v4[0xFFFFFFFF] = 0;
  *v4 = 0;
  v4 += 0xFFFFFFFA;
  v4[7] = 0;
  v4[8] = 0;
  v4[1] = 0;
  v4[2] = 0;
  *v4 = 0x3F800000;
  v4[3] = 0;
  v4[4] = 0x3F800000;
  v4[5] = 0;
  v5 = v4 + 6;
  v4[6] = 0;
  v4[7] = 0;
  result = v4 + 0xFFFFF994;
  v5[2] = 0x3F800000;
  return result;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001ABE0) --------------------------------------------------------
_DWORD *__fastcall sub_1ABE0(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD *result; // eax

  *a1 = 0;
  v1 = a1 + 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  result = v1 + 0xFFFFFFFA;
  result[7] = 0;
  result[8] = 0;
  result[1] = 0;
  result[2] = 0;
  *result = 0x3F800000;
  result[3] = 0;
  result[4] = 0x3F800000;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[8] = 0x3F800000;
  return result;
}

//----- (0001AC70) --------------------------------------------------------
float *__fastcall sub_1AC70(float *result, int a2, int a3, int a4)
{
  *result = (float)a2;
  result[1] = (float)a3;
  result[2] = (float)a4;
  return result;
}

//----- (0001ACA0) --------------------------------------------------------
_DWORD *__fastcall sub_1ACA0(_DWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (0001ACC0) --------------------------------------------------------
int __fastcall sub_1ACC0(int result, int a2, int a3)
{
  *(_DWORD *)(result + 0x2EE4) = 0;
  *(_DWORD *)(result + 0x2EE8) = 0;
  *(_WORD *)(result + 0x2EE0) = 0;
  *(_WORD *)(result + 0x2EE2) = 0;
  return sub_1ACE8(result);
}

//----- (0001ACE8) --------------------------------------------------------
int __fastcall sub_1ACE8(int result)
{
  *(_DWORD *)(result + 0x2EEC) = 0xFFFFFFFF;
  return result;
}

//----- (0001ACF4) --------------------------------------------------------
int __fastcall sub_1ACF4(int a1)
{
  int result; // eax

  sub_262CC(*(void **)(a1 + 0x2EE4));
  *(_DWORD *)(a1 + 0x2EE4) = 0;
  result = a1;
  *(_DWORD *)(a1 + 0x2EE8) = 0;
  return result;
}

//----- (0001AD1C) --------------------------------------------------------
_DWORD *__fastcall sub_1AD1C(int a1, int a2)
{
  void *v3; // eax
  int v4; // edx
  _DWORD *result; // eax
  size_t size; // [esp+0h] [ebp-Ch]

  size = a2 + 3;
  LOBYTE(size) = (a2 + 3) & 0xFC;
  v3 = operator new[](size);
  sub_2625C(v3, 5, "SHAPE CACHE");
  *(_DWORD *)(a1 + 0x2EE4) = v3;
  if ( !v3 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x41);
  }
  *(_WORD *)(a1 + 0x2EE0) = 0;
  *(_WORD *)(a1 + 0x2EE2) = 0;
  v4 = a1;
  *(_DWORD *)(a1 + 0x2EE8) = size;
  result = (_DWORD *)a1;
  do
  {
    *result++ = 0;
    *(_BYTE *)(v4 + 0x7D0) = 0;
    v4 += 0x32;
    result[0xC7] = 0;
  }
  while ( result != (_DWORD *)(a1 + 0x320) );
  return result;
}

//----- (0001ADAC) --------------------------------------------------------
int __fastcall sub_1ADAC(int a1, const char *a2)
{
  const char *v3; // esi
  unsigned int v4; // kr04_4
  int v5; // eax
  int v6; // edx
  char *v7; // edi
  char v8; // al
  char v9; // al

  v3 = a2;
  if ( !*(_DWORD *)(a1 + 0x2EE4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x53);
  }
  v4 = strlen(a2) + 1;
  if ( (int)(v4 - 1) <= 0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x59);
  }
  if ( (int)(v4 - 1) >= 0x32 )
  {
    sub_2620C("Cache filename too long: %s", (char)a2);
    sub_261B8(0, "..\\cache.cpp", 0x5B);
  }
  if ( *(__int16 *)(a1 + 0x2EE0) >= 0xC8 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x5C);
  }
  v5 = a1;
  v6 = 0;
  while ( *(_BYTE *)(v5 + 0x7D0) )
  {
    ++v6;
    v5 += 0x32;
    if ( v6 >= 0xC8 )
    {
      return 0xFFFF;
    }
  }
  v7 = (char *)(0x32 * v6 + a1 + 0x7D0);
  do
  {
    v8 = *v3;
    *v7 = *v3;
    if ( !v8 )
    {
      break;
    }
    v9 = v3[1];
    v3 += 2;
    v7[1] = v9;
    v7 += 2;
  }
  while ( v9 );
  ++*(_WORD *)(a1 + 0x2EE0);
  return v6;
}

//----- (0001AEB0) --------------------------------------------------------
int __fastcall sub_1AEB0(unsigned int a1, unsigned __int16 a2, const char *a3)
{
  const char *v4; // esi
  unsigned int v5; // kr04_4
  int v6; // eax
  int result; // eax
  char *v8; // edi
  char v9; // al
  char v10; // al

  v4 = a3;
  if ( !*(_DWORD *)(a1 + 0x2EE4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x70);
  }
  v5 = strlen(a3) + 1;
  if ( (int)(v5 - 1) <= 0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x74);
  }
  if ( (int)(v5 - 1) >= 0x32 )
  {
    sub_2620C("Cache filename too long: %s", (char)a3);
    sub_261B8(0, "..\\cache.cpp", 0x76);
  }
  if ( *(__int16 *)(a1 + 0x2EE0) >= 0xC8 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x77);
  }
  if ( a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x78);
  }
  v6 = 0x32 * a2;
  if ( *(_BYTE *)(v6 + a1 + 0x7D0) )
  {
    if ( !stricmp(a3, (const char *)(v6 + a1 + 0x7D0)) )
    {
      return 0xFFFFFFFF;
    }
    sub_1B000(a1, a2);
  }
  v8 = (char *)(0x32 * a2 + a1 + 0x7D0);
  do
  {
    v9 = *v4;
    *v8 = *v4;
    if ( !v9 )
    {
      break;
    }
    v10 = v4[1];
    v4 += 2;
    v8[1] = v10;
    v8 += 2;
  }
  while ( v10 );
  result = 0xFFFFFFFF;
  ++*(_WORD *)(a1 + 0x2EE0);
  return result;
}

//----- (0001B000) --------------------------------------------------------
int __fastcall sub_1B000(unsigned int a1, unsigned __int16 a2)
{
  int result; // eax

  if ( a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x95);
  }
  if ( !*(_BYTE *)(a1 + 0x32 * a2 + 0x7D0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0x96);
  }
  sub_1B354(a1, a2);
  result = 0x19 * a2;
  *(_BYTE *)(a1 + 0x32 * a2 + 0x7D0) = 0;
  --*(_WORD *)(a1 + 0x2EE0);
  return result;
}

//----- (0001B084) --------------------------------------------------------
int __fastcall sub_1B084(unsigned int a1, int a2)
{
  unsigned __int16 v3; // di
  int v4; // eax
  int v5; // ecx
  void *v6; // edx
  unsigned int v8; // edx
  int i; // eax
  unsigned int j; // edx
  int v11; // ebx
  T_Type1 v12; // [esp+0h] [ebp-12Ch] BYREF

  v3 = a2;
  if ( !*(_DWORD *)(a1 + 0x2EEC) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0xA2);
  }
  if ( (unsigned __int16)a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0xA6);
  }
  if ( !*(_BYTE *)(a1 + 0x32 * (unsigned __int16)a2 + 0x7D0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cache.cpp", 0xA7);
  }
  HIWORD(a2) = 0;
  if ( *(_DWORD *)(a1 + 4 * (unsigned __int16)a2) )
  {
    v8 = a1;
    for ( i = 0; i < *(__int16 *)(a1 + 0x2EE2) && v3 != *(_WORD *)(v8 + 0x640); ++i )
    {
      v8 += 2;
    }
    for ( j = a1 + 2 * i; ; *(_WORD *)(j + 0x63E) = *(_WORD *)(j + 0x640) )
    {
      v11 = *(__int16 *)(a1 + 0x2EE2);
      if ( i >= v11 )
      {
        break;
      }
      j += 2;
      ++i;
    }
    *(_WORD *)(a1 + 2 * v11 + 0x63E) = v3;
    return *(_DWORD *)(a1 + 4 * v3);
  }
  else
  {
    Q_InitFileInfo_sub_1BB78(&v12);
    Q_CfilePreload_sub_1BBFC(&v12, (const char *)(0x32 * a2 + a1 + 0x7D0), 0x200, 0);
    v4 = sub_1BE28(&v12);
    v5 = v4 + 3;
    LOBYTE(v5) = (v4 + 3) & 0xFC;
    if ( v5 >= *(_DWORD *)(a1 + 0x2EE8) )
    {
      sub_2620C("Single item too big for cache: %s, %d", 0x32 * a2 + a1 - 0x30);
      sub_261B8(0, "..\\cache.cpp", 0xB8);
    }
    *(_DWORD *)(a1 + 4 * (unsigned __int16)a2) = sub_1B2DC(a1, v5);
    v6 = *(void **)(a1 + 4 * (unsigned __int16)a2);
    *(_DWORD *)(a1 + 4 * v3 + 0x320) = v5;
    if ( !Q_CfileLoad_sub_1BF1C(&v12, v6) )
    {
      sub_2620C("Cache unable to load file: %s", 0x32 * v3 + a1 - 0x30);
      sub_261B8(0, "..\\cache.cpp", 0xC0);
    }
    *(_WORD *)(a1 + 2 * (__int16)(*(_WORD *)(a1 + 0x2EE2))++ + 0x640) = v3;
    Q_CloseFileAndDelete_sub_1BBC8(&v12);
    return *(_DWORD *)(a1 + 4 * v3);
  }
}

//----- (0001B270) --------------------------------------------------------
int __fastcall sub_1B270(int a1, const char *a2, int a3)
{
  const char *v5; // ebx
  int v6; // ecx
  int v8; // [esp+0h] [ebp-14h]

  v5 = (const char *)(a1 + 0x7D0);
  v6 = 0;
  v8 = 0xFFFF;
  while ( v6 < *(__int16 *)(a1 + 0x2EE0) )
  {
    if ( !stricmp(a2, v5) )
    {
      v8 = v6;
      break;
    }
    v5 += 0x32;
    ++v6;
  }
  if ( a3 == 0xFFFFFFFF && (unsigned __int16)v8 == 0xFFFF )
  {
    return sub_1ADAC(a1, a2);
  }
  return v8;
}

//----- (0001B2DC) --------------------------------------------------------
int __fastcall sub_1B2DC(unsigned int a1, int a2)
{
  unsigned int v2; // ecx
  unsigned int v4; // edx
  int v5; // esi
  int v6; // ebx
  int v7; // edi
  int result; // eax
  int i; // esi
  unsigned __int16 v10; // dx

  v2 = a1;
  v4 = a1 + 0x320;
  v5 = 0;
  do
  {
    v6 = *(_DWORD *)(a1 + 0x320);
    a1 += 4;
    v5 += v6;
  }
  while ( a1 != v4 );
  v7 = 0;
  result = v5 + *(_DWORD *)(v2 + 0x2EE4);
  for ( i = *(_DWORD *)(v2 + 0x2EE8) - v5; i <= a2; result = sub_1B354(v2, v10) )
  {
    if ( v7 >= *(__int16 *)(v2 + 0x2EE0) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0xFF);
    }
    v10 = *(_WORD *)(v2 + 0x640);
    i += *(_DWORD *)(v2 + 4 * v10 + 0x320);
    ++v7;
  }
  return result;
}

//----- (0001B354) --------------------------------------------------------
int __fastcall sub_1B354(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // ebp
  int v4; // edx
  int v5; // ecx
  void *v6; // edx
  int v7; // ebx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // eax
  unsigned int i; // edx
  unsigned int v12; // edx
  unsigned int v13; // [esp+0h] [ebp-20h]
  int v14; // [esp+4h] [ebp-1Ch]
  int v15; // [esp+4h] [ebp-1Ch]

  v2 = a1;
  if ( a2 >= 0xC8u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cache.cpp", 0x10D);
  }
  if ( !*(_DWORD *)(a1 + 4 * a2) )
  {
    return 0;
  }
  v4 = 0;
  do
  {
    v5 = *(_DWORD *)(a1 + 0x320);
    a1 += 4;
    v4 += v5;
  }
  while ( a1 != v2 + 0x320 );
  v14 = v4 + *(_DWORD *)(v2 + 0x2EE4);
  v13 = 4 * a2 + v2;
  v6 = *(void **)v13;
  v7 = *(_DWORD *)(v13 + 0x320);
  qmemcpy(*(void **)v13, (const void *)(*(_DWORD *)v13 + v7), v14 - (*(_DWORD *)v13 + v7));
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 0x320) = 0;
  v8 = v2;
  v9 = v2 + 0x320;
  do
  {
    if ( (unsigned int)v6 < *(_DWORD *)v8 )
    {
      *(_DWORD *)v8 -= v7;
    }
    v8 += 4;
  }
  while ( v8 != v9 );
  v10 = v9 ^ v8;
  v15 = v14 - v7;
  --*(_WORD *)(v2 + 0x2EE2);
  for ( i = v2; v10 < *(__int16 *)(v2 + 0x2EE2) && a2 != *(_WORD *)(i + 0x640); i += 2 )
  {
    ++v10;
  }
  v12 = v2 + 2 * v10;
  while ( v10 < *(__int16 *)(v2 + 0x2EE2) )
  {
    v12 += 2;
    ++v10;
    *(_WORD *)(v12 + 0x63E) = *(_WORD *)(v12 + 0x640);
  }
  return v15;
}

//----- (0001B498) --------------------------------------------------------
_DWORD *__fastcall sub_1B498(_DWORD *result)
{
  _DWORD *v1; // ecx
  int i; // edx

  v1 = result;
  for ( i = 0; i < *((__int16 *)v1 + 0x1770); ++i )
  {
    *result = 0;
    result[0xC8] = 0;
    ++result;
  }
  *((_WORD *)v1 + 0x1771) = 0;
  return result;
}

//----- (0001B4D0) --------------------------------------------------------
_DWORD *__fastcall sub_1B4D0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = sub_1B498(a1);
  a1[0xBBB] = 0;
  return result;
}

//----- (0001B4F0) --------------------------------------------------------
_DWORD *__fastcall sub_1B4F0(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx

  *a1 = 0;
  v1 = a1 + 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 0xFFFFFFFA;
  v1[7] = 0;
  v1[8] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0x3F800000;
  v1[3] = 0;
  v1[4] = 0x3F800000;
  v1[5] = 0;
  v2 = v1 + 6;
  v1[6] = 0;
  v1[7] = 0;
  v1 += 0xD;
  v2[2] = 0x3F800000;
  *v1 = 0;
  v1 += 0x10;
  v1[0xFFFFFFF1] = 0;
  v1[0xFFFFFFF2] = 0;
  v1[0xFFFFFFFD] = 0x3F800000;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFF8] = v1[0xFFFFFFFD];
  v1[0xFFFFFFF3] = v1[0xFFFFFFF8];
  v1[0xFFFFFFFC] = v1[0xFFFFFFFE];
  v1[0xFFFFFFFB] = v1[0xFFFFFFFC];
  v1[0xFFFFFFFA] = v1[0xFFFFFFFB];
  v1[0xFFFFFFF9] = v1[0xFFFFFFFA];
  v1[0xFFFFFFF7] = v1[0xFFFFFFF9];
  v1[0xFFFFFFF6] = v1[0xFFFFFFF7];
  v1[0xFFFFFFF5] = v1[0xFFFFFFF6];
  v1[0xFFFFFFF4] = v1[0xFFFFFFF5];
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  v1 += 0xFFFFFFFA;
  *v1 = 0x3F800000;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v1[4] = 0x3F800000;
  v1[5] = 0;
  v1[6] = 0;
  v1[7] = 0;
  v1[8] = 0x3F800000;
  return v1 + 0xFFFFFFE3;
}

//----- (0001B808) --------------------------------------------------------
void __fastcall sub_1B808(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  a1[9] = a5;
  a1[0xB] = a6;
  a1[0xC] = a7;
  a1[0x1C] = 0x3F800000;
  sub_1B834((int)a1, a8);
}

//----- (0001B834) --------------------------------------------------------
void __fastcall sub_1B834(int a1, int a2)
{
  *(float *)(a1 + 0x28) = (double)a2 / tan(*(float *)(a1 + 0x24) * flt_95A68 * flt_907F4);
}
// 907F4: using guessed type float flt_907F4;
// 95A68: using guessed type float flt_95A68;

//----- (0001B864) --------------------------------------------------------
float *__fastcall sub_1B864(int a1, int a2, int a3, int a4)
{
  float *v5; // eax
  double v6; // st7
  int v8[9]; // [esp+0h] [ebp-70h] BYREF
  int v9[9]; // [esp+24h] [ebp-4Ch] BYREF
  float v10; // [esp+48h] [ebp-28h]
  float v11; // [esp+4Ch] [ebp-24h]
  float v12; // [esp+50h] [ebp-20h]
  int v13[7]; // [esp+54h] [ebp-1Ch] BYREF

  v13[5] = a4;
  v13[3] = (int)v13;
  v5 = (float *)(a1 + 0x34);
  v10 = 0.0;
  v11 = 0.0;
  v12 = 0.0;
  v10 = -*v5;
  v11 = -v5[1];
  v6 = -v5[2];
  *(float *)v13 = v10;
  v12 = v6;
  *(float *)&v13[1] = v11;
  *(float *)&v13[2] = v12;
  v8[0] = *(_DWORD *)(a1 + 0x74);
  v8[1] = *(_DWORD *)(a1 + 0x78);
  v8[2] = *(_DWORD *)(a1 + 0x7C);
  v8[3] = *(_DWORD *)(a1 + 0x80);
  v8[4] = *(_DWORD *)(a1 + 0x84);
  v8[5] = *(_DWORD *)(a1 + 0x88);
  v8[6] = *(_DWORD *)(a1 + 0x8C);
  v8[7] = *(_DWORD *)(a1 + 0x90);
  v8[8] = *(_DWORD *)(a1 + 0x94);
  v9[0] = *(_DWORD *)a1;
  v9[1] = *(_DWORD *)(a1 + 4);
  v9[2] = *(_DWORD *)(a1 + 8);
  v9[3] = *(_DWORD *)(a1 + 0xC);
  v9[4] = *(_DWORD *)(a1 + 0x10);
  v9[5] = *(_DWORD *)(a1 + 0x14);
  v9[6] = *(_DWORD *)(a1 + 0x18);
  v9[7] = *(_DWORD *)(a1 + 0x1C);
  v9[8] = *(_DWORD *)(a1 + 0x20);
  return sub_53B08((float *)(a1 + 0x40), (float *)v9, (float *)v8, (float *)v13);
}

//----- (0001B958) --------------------------------------------------------
float *__fastcall sub_1B958(int a1, float *a2, int a3, int a4)
{
  int v5[9]; // [esp+0h] [ebp-88h] BYREF
  int v6[9]; // [esp+24h] [ebp-64h] BYREF
  int v7[3]; // [esp+48h] [ebp-40h] BYREF
  float v8; // [esp+54h] [ebp-34h]
  int v9; // [esp+58h] [ebp-30h]
  int v10; // [esp+5Ch] [ebp-2Ch]
  float v11; // [esp+60h] [ebp-28h]
  float v12; // [esp+64h] [ebp-24h]
  float v13; // [esp+68h] [ebp-20h]
  int v14[7]; // [esp+6Ch] [ebp-1Ch] BYREF

  v14[5] = a4;
  v14[3] = (int)v7;
  v11 = 0.0;
  v12 = 0.0;
  v13 = 0.0;
  v11 = *a2 + *(float *)(a1 + 0x34);
  v12 = a2[1] + *(float *)(a1 + 0x38);
  v13 = a2[2] + *(float *)(a1 + 0x3C);
  *(float *)v7 = v11;
  v8 = -v11;
  *(float *)&v7[1] = v12;
  *(float *)&v9 = -v12;
  *(float *)&v7[2] = v13;
  v14[4] = (int)v14;
  *(float *)v14 = v8;
  *(float *)&v10 = -v13;
  v14[1] = v9;
  v14[2] = v10;
  v6[0] = *(_DWORD *)(a1 + 0x74);
  v6[1] = *(_DWORD *)(a1 + 0x78);
  v6[2] = *(_DWORD *)(a1 + 0x7C);
  v6[3] = *(_DWORD *)(a1 + 0x80);
  v6[4] = *(_DWORD *)(a1 + 0x84);
  v6[5] = *(_DWORD *)(a1 + 0x88);
  v6[6] = *(_DWORD *)(a1 + 0x8C);
  v6[7] = *(_DWORD *)(a1 + 0x90);
  v6[8] = *(_DWORD *)(a1 + 0x94);
  v5[0] = *(_DWORD *)a1;
  v5[1] = *(_DWORD *)(a1 + 4);
  v5[2] = *(_DWORD *)(a1 + 8);
  v5[3] = *(_DWORD *)(a1 + 0xC);
  v5[4] = *(_DWORD *)(a1 + 0x10);
  v5[5] = *(_DWORD *)(a1 + 0x14);
  v5[6] = *(_DWORD *)(a1 + 0x18);
  v5[7] = *(_DWORD *)(a1 + 0x1C);
  v5[8] = *(_DWORD *)(a1 + 0x20);
  return sub_53B08((float *)(a1 + 0x40), (float *)v5, (float *)v6, (float *)v14);
}

//----- (0001BAF0) --------------------------------------------------------
void __fastcall sub_1BAF0(float *a1, int a2, int a3, int a4, int a5)
{
  sub_532AC(a1 + 0xD, *(float *)&a5);
  sub_535E4(a1, (int)a1, a3, a4, a5);
}

//----- (0001BB10) --------------------------------------------------------
FILE *__fastcall sub_1BB10(const char *aFName, fpos_t *pos)
{
  FILE *v3; // eax
  FILE *v4; // edi
  T_Type1 v1; // [esp+0h] [ebp-128h] BYREF

  Q_InitFileInfo_sub_1BB78(&v1);
  Q_CfilePreload_sub_1BBFC(&v1, aFName, O_TEXT, 0);
  v3 = fdopen(v1.fh, "r");
  v4 = v3;
  if ( pos )
  {
    fgetpos(v3, pos);
    *pos += sub_1BE28(&v1);
  }
  v1.fh = 0xFFFFFFFF;
  Q_CloseFileAndDelete_sub_1BBC8(&v1);
  return v4;
}
// 1BB10: using guessed type T_Type1 v1;

//----- (0001BB78) --------------------------------------------------------
void __fastcall Q_InitFileInfo_sub_1BB78(P_Type1 a1)
{
  if ( !V_CobCfgLoaded_dword_9A250 )
  {
    Q_CobCfgLoad_sub_1C3C4(&V_CobFilesIndex_stru_9A254);
    V_CobCfgLoaded_dword_9A250 = 0xFFFFFFFF;
  }
  a1->fh = 0xFFFFFFFF;
  a1->fname[0] = 0;
  a1->d = 0;
  a1->e = 0;
  a1->index = 0xFFFFFFFF;
}
// 9A250: using guessed type int V_CobCfgLoaded_dword_9A250;

//----- (0001BBC8) --------------------------------------------------------
void __fastcall Q_CloseFileAndDelete_sub_1BBC8(P_Type1 a1)
{
  Q_CloseFile_sub_1BE00(a1);
  if ( a1->e == 0xFFFFFFFF && a1->d )
  {
    sub_2627C(a1->d);
  }
  operator delete[](a1->d);
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0001BBFC) --------------------------------------------------------
BOOL __fastcall Q_CfilePreload_sub_1BBFC(P_Type1 a1, const char *aFName, int aOFlags, int a4)
{
  BOOL result; // eax
  int len; // eax
  unsigned int v7; // ecx
  void *pData; // eax

  if ( a1->fh != 0xFFFFFFFF )
  {
    Q_CloseFile_sub_1BE00(a1);
  }
  a1->e = 0;
  strncpy(a1->fname, aFName, 0x100u);
  a1->fname[0xFF] = 0;
  result = Q_CFILE_CPP_sub_1BCBC(a1, aOFlags);
  if ( !result )
  {
    if ( a4 == 0xFFFFFFFF )
    {
      len = filelength(a1->fh);
      v7 = len;
      if ( len > 0 )
      {
        pData = operator new[](len);
        sub_2625C(pData, 1, "CFILE PRELOAD");
        a1->d = pData;
        if ( pData )
        {
          if ( !sub_1BF94(a1, pData, v7) )
          {
            a1->e = 0xFFFFFFFF;
            return 0;
          }
          sub_2627C(a1->d);
          operator delete[](a1->d);
          a1->d = 0;
        }
      }
    }
    return 0;
  }
  return result;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0001BCA8) --------------------------------------------------------
BOOL __fastcall sub_1BCA8(T_Type1 *a1, const char *a2)
{
  return Q_CfilePreload_sub_1BBFC(a1, a2, 0x21, 0);
}

//----- (0001BCBC) --------------------------------------------------------
BOOL __fastcall Q_CFILE_CPP_sub_1BCBC(T_Type1 *a1, int aOFlags)
{
  int v2; // eax
  int v3; // edi
  int v4; // ecx
  T_CobFilesIndex *v5; // ebx
  int v6; // esi
  int v7; // eax
  unsigned int v9; // [esp+0h] [ebp-20h]
  int oflag; // [esp+4h] [ebp-1Ch]

  oflag = aOFlags;
  if ( a1->fh != 0xFFFFFFFF )
  {
    Q_CloseFile_sub_1BE00(a1);
  }
  if ( (aOFlags & 0x20) != 0 )
  {
    LOWORD(oflag) = aOFlags | 0x240;
    v2 = open(a1->fname, oflag, 0x180);
LABEL_19:
    a1->fh = v2;
    goto LABEL_20;
  }
  v9 = 0;
  if ( (aOFlags & 3) == 0 )
  {
    v3 = 0;
    v4 = 0;
    if ( V_CobFilesIndex_stru_9A254.files > 0 )
    {
      v5 = &V_CobFilesIndex_stru_9A254;
      v6 = 0;
      while ( 1 )
      {
        if ( v4 == V_CobFilesIndex_stru_9A254.cobfiles[v6] )
        {
          ++v6;
          ++v3;
        }
        if ( !stricmp(a1->fname, (const char *)v5) )
        {
          break;
        }
        ++v4;
        v5 = (T_CobFilesIndex *)((char *)v5 + 0x32);
        if ( v4 >= V_CobFilesIndex_stru_9A254.files )
        {
          goto LABEL_17;
        }
      }
      a1->index = v4;
      v7 = open(V_CobFilesIndex_stru_9A254.cobnames[v3], aOFlags);
      a1->fh = v7;
      if ( v7 == 0xFFFFFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cfile.cpp", 0xC4);
      }
      lseek(a1->fh, V_CobFilesIndex_stru_9A254.flengths[v4], 0);
      v9 = 0xFFFFFFFF;
    }
  }
LABEL_17:
  if ( !v9 )
  {
    v2 = open(a1->fname, aOFlags);
    goto LABEL_19;
  }
LABEL_20:
  a1->d4 = oflag;
  return a1->fh == 0xFFFFFFFF;
}

//----- (0001BE00) --------------------------------------------------------
int __fastcall Q_CloseFile_sub_1BE00(P_Type1 a1)
{
  int v3; // ebx

  if ( a1->fh == 0xFFFFFFFF )
  {
    return 0;
  }
  v3 = close(a1->fh);
  if ( !v3 )
  {
    a1->fh = 0xFFFFFFFF;
  }
  return v3;
}

//----- (0001BE28) --------------------------------------------------------
int __fastcall sub_1BE28(P_Type1 a1)
{
  int index; // ecx
  int v4; // esi
  int v5; // eax

  if ( a1->fh == 0xFFFFFFFF )
  {
    return 0xFFFFFFFF;
  }
  index = a1->index;
  if ( index == 0xFFFFFFFF )
  {
    return filelength(a1->fh);
  }
  v4 = V_CobFilesIndex_stru_9A254.flengths[index + 1];
  if ( V_CobFilesIndex_stru_9A254.cobindex > 0 )
  {
    v5 = 0;
    do
    {
      if ( V_CobFilesIndex_stru_9A254.cobfiles[v5] - 1 == a1->index )
      {
        v4 = V_CobFilesIndex_stru_9A254.coblengths[v5];
      }
      ++v5;
    }
    while ( v5 < V_CobFilesIndex_stru_9A254.cobindex );
  }
  return v4 - V_CobFilesIndex_stru_9A254.flengths[index];
}

//----- (0001BEA0) --------------------------------------------------------
int __fastcall sub_1BEA0(int *a1)
{
  int v2; // eax
  int v3; // ebx
  int v4; // ecx

  v2 = tell(*a1);
  v3 = v2;
  if ( v2 != 0xFFFFFFFF )
  {
    v4 = a1[0x42];
    if ( v4 != 0xFFFFFFFF )
    {
      return v2 - V_CobFilesIndex_stru_9A254.flengths[v4];
    }
  }
  return v3;
}

//----- (0001BECC) --------------------------------------------------------
int __fastcall sub_1BECC(int *a1, int offset, int a3)
{
  int v3; // esi
  int v4; // ecx

  if ( a1[0x44] && a3 != 0xFFFFFFFF )
  {
    return offset + a1[0x43];
  }
  v3 = a1[0x42];
  v4 = offset;
  if ( v3 != 0xFFFFFFFF )
  {
    v4 = offset + V_CobFilesIndex_stru_9A254.flengths[v3];
  }
  return lseek(*a1, v4, 0);
}

//----- (0001BF0C) --------------------------------------------------------
int __fastcall sub_1BF0C(int *a1, int a2)
{
  return lseek(*a1, a2, 1);
}

//----- (0001BF1C) --------------------------------------------------------
void *__fastcall Q_CfileLoad_sub_1BF1C(T_Type1 *a1, void *a2)
{
  void *v3; // ecx
  int v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // ebp
  void *result; // eax

  v3 = a2;
  if ( a1->fh != 0xFFFFFFFF )
  {
    v4 = sub_1BE28(a1);
    v5 = v4;
    v6 = 0;
    if ( v4 > 0 )
    {
      if ( !a2 )
      {
        result = operator new[](v4);
        sub_2625C(result, 5, "CFILE LOAD");
        v3 = result;
        if ( !result )
        {
          return result;
        }
        v6 = 0xFFFFFFFF;
      }
      if ( sub_1BF94(a1, v3, v5) == v5 )
      {
        return v3;
      }
      if ( v6 == 0xFFFFFFFF )
      {
        sub_2627C(v3);
      }
      operator delete[](v3);
      _get_errno_ptr();
    }
  }
  return 0;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0001BF94) --------------------------------------------------------
int __fastcall sub_1BF94(P_Type1 a1, void *aBuf, unsigned int aLen)
{
  int index; // esi
  int v5; // esi
  unsigned int v6; // eax

  index = a1->index;
  if ( index != 0xFFFFFFFF )
  {
    v5 = tell(a1->fh) - V_CobFilesIndex_stru_9A254.flengths[index];
    v6 = sub_1BE28(a1);
    if ( v5 + aLen > v6 )
    {
      aLen = v6 - v5;
    }
  }
  return read(a1->fh, aBuf, aLen);
}

//----- (0001BFD4) --------------------------------------------------------
unsigned int __fastcall sub_1BFD4(int *a1, void *buf, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v7; // ebp
  void *v8; // ebx
  unsigned int v9; // edx
  unsigned int result; // eax
  unsigned int i; // ecx
  unsigned int v12; // edx
  unsigned int v14; // [esp+4h] [ebp-1Ch]
  unsigned int len; // [esp+Ch] [ebp-14h]
  int v17; // [esp+10h] [ebp-10h]

  v7 = 0;
  len = a3 / a4;
  v17 = 0;
  v14 = a4 - 1;
  if ( a4 == 1 )
  {
LABEL_9:
    result = read(*a1, buf, a3 - v17);
    if ( result != 0xFFFFFFFF )
    {
      v17 += result;
      ((void (*)(void))a5)();
      return v17;
    }
  }
  else
  {
    while ( 1 )
    {
      result = read(*a1, buf, len);
      if ( result == 0xFFFFFFFF )
      {
        break;
      }
      v17 += result;
      if ( result < len )
      {
        for ( i = v7; i < a4; ((void (__fastcall *)(unsigned int, unsigned int, _DWORD, unsigned int))a5)(a4, v12, 0, i) )
        {
          v12 = i++;
        }
        return v17;
      }
      v8 = buf;
      v9 = v7++;
      buf = (char *)buf + result;
      ((void (__fastcall *)(unsigned int, unsigned int, void *, unsigned int))a5)(a4, v9, v8, v14);
      if ( v7 >= v14 )
      {
        goto LABEL_9;
      }
    }
  }
  return result;
}

//----- (0001C098) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __fastcall sub_1C098(unsigned int count, int a2, unsigned int a3)
{
  unsigned int v4; // edi
  int v5; // esi
  int v6; // eax
  unsigned int result; // eax
  const void far *v8; // [esp-Ch] [ebp-30h] BYREF
  int *v9; // [esp-4h] [ebp-28h]
  unsigned int *v10; // [esp+0h] [ebp-24h]
  int v11; // [esp+4h] [ebp-20h]
  unsigned int v12; // [esp+Ch] [ebp-18h]
  int v13; // [esp+10h] [ebp-14h]

  v9 = (int *)count;
  v4 = a3;
  if ( !a3 )
  {
    return v12;
  }
  while ( 1 )
  {
    v5 = v4 <= 0xFFF0 ? v4 : 0xFFF0;
    LODWORD(v8) = (char *)&v8 + 4;
    v6 = *v9;
    v11 = v5;
    result = dos_write(v6, v8, (unsigned int)v9, v10);
    v12 = result;
    if ( result )
    {
      break;
    }
    if ( v5 != v11 )
    {
      _assert(0, "chunksize==byteswritten", "..\\cfile.cpp", 0x244);
    }
    a2 += v13;
    v4 -= v13;
    if ( !v4 )
    {
      return v12;
    }
  }
  return result;
}
// 1C10A: positive sp value C has been found

//----- (0001C278) --------------------------------------------------------
void __fastcall Q_CFILE_CPP_IndexOneCob_sub_1C278(P_CobFilesIndex a1, char *CobFileName)
{
  int cobindex; // ebx
  int fh; // edi MAPDST
  int files; // edx
  int files_new; // esi
  int buf[6]; // [esp+0h] [ebp-18h] BYREF

  if ( a1->cobindex >= 5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cfile.cpp", 0x28C);
  }
  cobindex = a1->cobindex;
  if ( cobindex < 5 )
  {
    strncpy(a1->cobnames[cobindex], CobFileName, 50u);
    fh = open(CobFileName, O_BINARY);
    if ( fh != 0xFFFFFFFF )
    {
      a1->coblengths[a1->cobindex] = filelength(fh);
      read(fh, buf, 4u);
      if ( 0x1F4 - a1->files < buf[0] )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cfile.cpp", 0x2A0);
      }
      files = a1->files;
      if ( 0x1F4 - files >= buf[0] )
      {
        read(fh, a1->fnames[files], 50 * buf[0]);
        read(fh, &a1->flengths[a1->files], 4 * buf[0]);
        close(fh);
        files_new = buf[0] + a1->files;
        a1->cobfiles[a1->cobindex] = files_new;
        a1->files = files_new;
        ++a1->cobindex;
      }
    }
  }
}

//----- (0001C3C4) --------------------------------------------------------
void __fastcall Q_CobCfgLoad_sub_1C3C4(P_CobFilesIndex a1)
{
  FILE *v2; // ecx
  char v3[100]; // [esp+0h] [ebp-64h] BYREF

  v2 = fopen("cob.cfg", "r");
  if ( v2 )
  {
    while ( fscanf(v2, "%s", v3) != 0xFFFFFFFF )
    {
      Q_CFILE_CPP_IndexOneCob_sub_1C278(a1, v3);
    }
    fclose(v2);
  }
}
// 1C3C4: using guessed type char anonymous_0[100];

//----- (0001C410) --------------------------------------------------------
void Q_AtExitFunc_sub_1C410(void)
{
  sub_26160();
  UVB_sub_7501C();
}

//----- (0001C424) --------------------------------------------------------
int __fastcall main(int argc, char *argv[])
{
  clock_t v3; // edx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char v6; // al
  char v7; // al
  char *v8; // eax
  int v9; // eax
  int v10; // edx
  char *v11; // eax
  char *v12; // eax
  BOOL v13; // edx
  char *v14; // edi
  char *v15; // esi
  char v16; // al
  char v17; // al
  int v18; // eax
  char *v19; // eax
  UBYTE *v20; // ebx
  FILE *v21; // eax
  FILE *v22; // eax
  char *v23; // edi
  char *v24; // esi
  char v25; // al
  char v26; // al
  unsigned int v27; // eax
  FILE *v28; // eax
  FILE *v29; // edi
  int v30; // esi
  int v31; // edx
  int v32; // ebx
  char *v33; // edx
  int result; // eax
  int v35; // [esp-4h] [ebp-574h]
  int v36; // [esp-4h] [ebp-574h]
  RGB palette; // [esp+0h] [ebp-570h] BYREF
  T_Type1 v1Type1; // [esp+300h] [ebp-270h] BYREF
  T_Type1 a1; // [esp+418h] [ebp-158h] BYREF
  char v40; // [esp+530h] [ebp-40h] BYREF
  int v41; // [esp+542h] [ebp-2Eh] BYREF
  char v42; // [esp+548h] [ebp-28h] BYREF
  _WORD v43[3]; // [esp+54Ah] [ebp-26h] BYREF
  unsigned int seed; // [esp+550h] [ebp-20h] BYREF
  MACRO_VFX_BOOL forceUNIVBE; // [esp+554h] [ebp-1Ch]
  char **__attribute__((__org_arrdim(0,0))) v48; // [esp+558h] [ebp-18h]

  v48 = argv;
  v3 = clock();
  printf("\nAscendancy\nCopyright (c) 1995 The Logic Factory, Inc.\nAll rights reserved\n");
  while ( clock() - v3 < 0xFA )
  {
    ;
  }
  v4 = "Thank you for playing Ascendancy.";
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAB);// 171: "Thank you for playing Ascendancy."
  do
  {
    v6 = *sub_1CEA8;
    *v4 = *sub_1CEA8;
    if ( !v6 )
    {
      break;
    }
    v7 = sub_1CEA8[1];
    sub_1CEA8 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  atexit(Q_AtExitFunc_sub_1C410);
  if ( argc > 1 && *v48[1] == 'v' )
  {
    v35 = off_964E0;
    v8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAC);     // 172: "\n\nAscendancy version %s\n\n"
    printf(v8, v35);
    getch();
  }
  forceUNIVBE = FALSE;
  if ( argc > 1 && *v48[1] == 'u' )
  {
    forceUNIVBE = TRUE;
  }
  v9 = Q_CheckFreeMemory_sub_53DEC();
  v10 = v9;
  if ( argc > 1 && *v48[1] == 'm' )
  {
    v36 = v9;
    v11 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAD);    // 173: "\n\nFree memory: %ld\n\n"
    printf(v11, v36);
    getch();
  }
  if ( v10 < 0x300000 )
  {
    v12 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAE);    // 174: "Your computer does not have enough free extended memory to run\n
                                                       // Ascendancy.  You will need an additional %ldK bytes of free extended memory."
    sprintf(
      "Thank you for playing Ascendancy.",
      v12,
      ((0x300000 - v10 - (__CFSHL__((0x300000 - v10) >> 0x1F, 0xA) + ((0x300000 - v10) >> 0x1F << 0xA))) >> 0xA) + 1);
    exit(1);
  }
  Q_InitFileInfo_sub_1BB78(&v1Type1);
  v13 = Q_CfilePreload_sub_1BBFC(&v1Type1, "data\\theme00.raw", O_BINARY, 0);
  Q_CloseFile_sub_1BE00(&v1Type1);
  if ( v13 )
  {
    v14 = "Thank you for playing Ascendancy.";
    v15 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAF);    // 175: "Please place the Ascendancy CD in your CDROM drive."
    do
    {
      v16 = *v15;
      *v14 = *v15;
      if ( !v16 )
      {
        break;
      }
      v17 = v15[1];
      v15 += 2;
      v14[1] = v17;
      v14 += 2;
    }
    while ( v17 );
    exit(1);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v1Type1);
  v18 = sub_53D22(0x101);
  if ( (!v18 || forceUNIVBE == TRUE) && !UVB_sub_75098(v18, 0, 0, O_BINARY, ".\\", 1) )
  {
    v19 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xB0);    // 176: "\n\nAscendancy was unable to find VESA support for your\n
                                                       // video card.  To configure the VESA driver that comes with\n
                                                       // Ascendancy, run the UVCONFIG program in this directory, and\n
                                                       // then try running Ascendancy again.  If this solution does\n
                                                       // not work, you may have to install the VESA driver supplied\n
                                                       // with your video card.  Consult your video card documentation\n
                                                       // for further information."
    printf(v19);
    s[0] = 0;
    exit(1);
  }
  if ( !sub_2BD88(&V_Type6_stru_D8654, "DATA", "VESA480.DLL") )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\corn.cpp", 0x9B);
  }
  VFX_area_wipe(0, 0, 639, 479, 0);
  Q_LoadPal_sub_2C158(&V_Type6_stru_D8654, "data\\logo.pal", 0, 0x100u);
  memset(&palette, 0, 0x300u);
  sub_2C224(&V_Type6_stru_D8654, 0, 0x100, &palette);
  Q_InitFileInfo_sub_1BB78(&a1);
  Q_CfilePreload_sub_1BBFC(&a1, "data\\logo.gif", O_BINARY, 0);
  v20 = &buffer[sub_1BE28(&a1)];
  Q_CfileLoad_sub_1BF1C(&a1, buffer);
  VFX_GIF_draw(&V_Type6_stru_D8654.pane, buffer, v20);
  VFX_pane_refresh(&V_Type6_stru_D8654.pane, 0, 0, 0x27F, 0x1DF);
  VFX_window_fade(&V_Type6_stru_D8654.window, V_Type6_stru_D8654.palette, 25);
  if ( Q_StartSoundSystem_sub_4EFB0((int)&unk_10914C, TRUE, FALSE) )
  {
    if ( dword_109357 == 0xFFFFFFFF && !sub_4F65C((int)&unk_10914C, "music.txt") )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xBB);
    }
  }
  else
  {
    sub_4FF08((int)&unk_10914C);
  }
  v21 = fopen("nougat.lf", "r");
  if ( v21 )
  {
    dword_A0CFC = 0xFFFFFFFF;
    fclose(v21);
  }
  v22 = fopen("flash.pop", "r");
  if ( v22 )
  {
    dword_A0D00 = 0xFFFFFFFF;
    fclose(v22);
  }
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xD8);
  }
  if ( sub_545EC(&V_Type3_stru_10AE70) != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\corn.cpp", 0xE1);
  }
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xE3);
  }
  if ( !sub_2633C() )
  {
    v23 = "Thank you for playing Ascendancy.";
    v24 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xB1);    // 177: "Ascendancy could not find a mouse driver.  Please make sure your\n
                                                       // mouse driver is loaded, and then run Ascendancy again."
    do
    {
      v25 = *v24;
      *v23 = *v24;
      if ( !v25 )
      {
        break;
      }
      v26 = v24[1];
      v24 += 2;
      v23[1] = v26;
      v23 += 2;
    }
    while ( v26 );
    exit(1);
  }
  Q_GSYSTEM_CPP_PreloadMouseShp_sub_2C744(&V_Type6_stru_D8654, "r", FALSE, 0);
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0xEE);
  }
  v27 = time(0);
  srand(v27);
  sub_1CF14(0);
  v28 = fopen("cosmos.txt", "r");
  v29 = v28;
  if ( v28 )
  {
    fscanf(v28, "%s %d %s %d %s %d", &v40, (char *)&v41 + 2, &v40, &v43[1], &v40, &seed);
    v30 = 0;
    if ( seed != 0xFFFFFFFF )
    {
      srand(seed);
    }
    sub_1E10C((int)dword_A2F6C, SHIWORD(v41), v43[1], 0);
    sub_1F404((int)dword_A2F6C);
    v31 = 0;
    while ( fscanf(v29, "%d", &v42) != 0xFFFFFFFF && v30 < *(int *)&v43[1] )
    {
      v31 += 0x1EE;
      ++v30;
      V_StaticStrings_dword_A0D04.buffer[v31 + 0x1D61] = v42;
    }
    fclose(v29);
  }
  else
  {
    sub_1E10C((int)dword_A2F6C, 0x32, 7, 0);
    sub_1F404((int)dword_A2F6C);
  }
  sub_1EE08((int)dword_A2F6C, 0);
  if ( access("resume.gam", 0) )
  {
    sub_1F038((int)dword_A2F6C);
  }
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x300A] = &V_Type6_stru_D8654;
  sub_575BC(&V_Type3_stru_10AE70);
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x11F);
  }
  sub_1EEA4((int)dword_A2F6C);
  sub_574F0(&V_Type3_stru_10AE70, 0, (int)sub_1CC94);
  sub_574F0(&V_Type3_stru_10AE70, 1, (int)sub_5A320);
  sub_57510((int)&V_Type3_stru_10AE70, 1, (int)sub_22468);
  sub_574F0(&V_Type3_stru_10AE70, 2, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 3, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 4, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 7, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 8, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 9, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xA, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xC, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xD, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xE, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0xF, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0x10, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0x12, (int)sub_5A320);
  sub_574F0(&V_Type3_stru_10AE70, 0x14, (int)sub_5A320);
  sub_59828((int)&V_Type3_stru_10AE70, 0x14, (int)sub_5A320, 0);
  VFX_window_fade(&V_Type6_stru_D8654.window, &palette, 0x32);
  dword_132B60 = 0xFFFFFFFF;
  VFX_area_wipe(0, 0, 0x27F, 0x1DF, 0);
  Q_LoadPal_sub_2C158(&V_Type6_stru_D8654, "DATA\\game.pal", 0, 0x100u);
  sub_2C224(&V_Type6_stru_D8654, 0, 0x100, &palette);
  v32 = 0xFFFFFFFF;
  v33 = 0;
  sub_56E9C(&V_Type3_stru_10AE70, 0, 0xFFFFFFFF);
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x146);
  }
  if ( argc == 4 )
  {
    v32 = 0;
    v33 = v48[3];
    if ( sub_59988(&V_Type3_stru_10AE70, v33, 0) != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\corn.cpp", 0x14C);
    }
  }
  MOUSE_show();
  while ( dword_96774 == 0xFFFFFFFF )
  {
    if ( V_Type3_stru_10AE70.bbb == 0xFFFFFFFF )
    {
      sub_59B80((int)&V_Type3_stru_10AE70);
    }
    else
    {
      sub_2656C((__int16)&unk_D85F8);
    }
    sub_5469C(&V_Type3_stru_10AE70, (int)v33, v32, (int)&palette);
    sub_5508C(&V_Type3_stru_10AE70);
    if ( V_Type3_stru_10AE70.bbb )
    {
      sub_59A54((int)&V_Type3_stru_10AE70);
    }
  }
  sub_5989C(&V_Type3_stru_10AE70, (int)v33, v32, (int)&palette);
  sub_54048("resume.gam", 0, v32, (int)&palette);
  Q_CloseFileAndDelete_sub_1BBC8(&a1);
  return result;
}
// 96774: using guessed type int dword_96774;
// A0CFC: using guessed type int dword_A0CFC;
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// D8DA0: using guessed type UBYTE buffer[94816];
// 109357: using guessed type int dword_109357;
// 132B60: using guessed type int dword_132B60;

//----- (0001CC94) --------------------------------------------------------
void sub_1CC94()
{
  void *v0; // edi
  UBYTE *v1; // esi
  T_Type1 v2; // [esp+0h] [ebp-128h] BYREF

  v0 = sub_262B0(0x502Eu, 1u, 1, "GIF SCRATCH");
  Q_InitFileInfo_sub_1BB78(&v2);
  Q_CfilePreload_sub_1BBFC(&v2, "DATA\\0OPENING.GIF", O_BINARY, 0);
  v1 = (UBYTE *)Q_CfileLoad_sub_1BF1C(&v2, 0);
  if ( !v1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x180);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v2);
  if ( v0 )
  {
    VFX_GIF_draw(&V_Type6_stru_D8654.pane, v1, v0);
    sub_552CC(&V_Type3_stru_10AE70, 0);
  }
  sub_2627C(v1);
  operator delete(v1);
  sub_262CC(v0);
}
// 1CCF9: conditional instruction was optimized away because esi.4!=0
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0001CD3C) --------------------------------------------------------
int Q_CORN_CPP_StaticTxtLoad_sub_1CD3C()
{
  FILE *fp; // edi
  char *pText; // esi
  char *pLetter; // ecx
  unsigned int v3; // ebp
  char letter; // dl
  int count; // eax
  char v6; // bh
  char line[201]; // [esp+1h] [ebp-E5h] BYREF
  int endOfFile; // [esp+CAh] [ebp-1Ch]

  fp = sub_1BB10("static.txt", 0);
  if ( !fp )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1A0);
  }
  pText = V_StaticStrings_dword_A0D04.buffer;
  V_StaticStrings_dword_A0D04.count = 0;
  endOfFile = 0;
  do
  {
    if ( V_StaticStrings_dword_A0D04.count >= 200 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1AE);
    }
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(fp, &line[1]);
    if ( !stricmp(&line[1], "end\n") )
    {
      endOfFile = 0xFFFFFFFF;
      continue;
    }
    if ( line[1] == '"' )
    {
      pLetter = &line[1];
      v3 = 0;
      V_StaticStrings_dword_A0D04.index[V_StaticStrings_dword_A0D04.count] = pText;
      do
      {
        ++pLetter;
        if ( pText - V_StaticStrings_dword_A0D04.buffer >= 8000 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1C6);
        }
        letter = *pLetter;
        if ( *pLetter == '"' )
        {
          v3 = 0xFFFFFFFF;
          count = V_StaticStrings_dword_A0D04.count;
          *pText++ = 0;
          V_StaticStrings_dword_A0D04.count = count + 1;
        }
        else if ( letter != '\n' )
        {
          if ( letter )
          {
            if ( letter != '\\' )
            {
              *pText++ = letter;
              continue;
            }
            v6 = *++pLetter;
            if ( v6 == 'n' )
            {
              *pText++ = '\n';
              continue;
            }
            if ( v6 )
            {
              *pText++ = v6;
              continue;
            }
          }
          pLetter = line;
          fgets(&line[1], 200, fp);
        }
      }
      while ( !v3 );
    }
  }
  while ( !endOfFile );
  V_StaticStrings_dword_A0D04.loaded = 0xFFFFFFFF;
  return fclose(fp);
}

//----- (0001CEA8) --------------------------------------------------------
char *__fastcall Q_CORN_CPP_StaticTxtRead_sub_1CEA8(int aTextIndex)
{
  if ( !V_StaticStrings_dword_A0D04.loaded )
  {
    Q_CORN_CPP_StaticTxtLoad_sub_1CD3C();
  }
  if ( aTextIndex < 0 || aTextIndex >= V_StaticStrings_dword_A0D04.count )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\corn.cpp", 0x1F3);
  }
  return V_StaticStrings_dword_A0D04.index[aTextIndex];
}

//----- (0001CEF0) --------------------------------------------------------
int sub_1CEF0()
{
  int result; // eax

  _wcpp_2_mod_register_(&unk_964E4);
  result = sub_1DE64((int)dword_A2F6C);
  dword_964EC = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 964EC: using guessed type int dword_964EC;
// A2F6C: using guessed type int dword_A2F6C[];

//----- (0001CF14) --------------------------------------------------------
unsigned __int8 __fastcall sub_1CF14(unsigned __int8 result)
{
  unsigned __int8 v1; // dh
  char v2; // dl

  if ( result == 0xFF )
  {
    v1 = 0;
    v2 = 0xFF;
  }
  else
  {
    v1 = result;
    v2 = 1 << result;
  }
  LOBYTE(byte_104BEA) = v1;
  byte_968DC = v2;
  return result;
}
// 968DC: using guessed type char byte_968DC;

//----- (0001CF40) --------------------------------------------------------
_DWORD *__fastcall sub_1CF40(_DWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

//----- (0001CF68) --------------------------------------------------------
int __fastcall sub_1CF68(int a1, int a2)
{
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  float *v8; // edx
  double v9; // st7
  int v11[3]; // [esp+8h] [ebp-A4h] BYREF
  int v12[3]; // [esp+14h] [ebp-98h] BYREF
  float v13; // [esp+20h] [ebp-8Ch]
  float v14; // [esp+24h] [ebp-88h]
  float v15; // [esp+28h] [ebp-84h]
  float v16; // [esp+2Ch] [ebp-80h]
  int v17; // [esp+30h] [ebp-7Ch]
  int v18; // [esp+34h] [ebp-78h]
  float v19; // [esp+38h] [ebp-74h]
  float v20; // [esp+3Ch] [ebp-70h]
  float v21; // [esp+40h] [ebp-6Ch]
  float v22; // [esp+44h] [ebp-68h]
  float v23; // [esp+48h] [ebp-64h]
  float v24; // [esp+4Ch] [ebp-60h]
  float v25; // [esp+50h] [ebp-5Ch]
  float v26; // [esp+54h] [ebp-58h]
  float v27; // [esp+58h] [ebp-54h]
  float v28; // [esp+5Ch] [ebp-50h] BYREF
  float v29; // [esp+60h] [ebp-4Ch]
  float v30; // [esp+64h] [ebp-48h]
  int v31[3]; // [esp+68h] [ebp-44h] BYREF
  float v32; // [esp+74h] [ebp-38h]
  int v33; // [esp+78h] [ebp-34h]
  int v34; // [esp+7Ch] [ebp-30h]
  int *v35; // [esp+80h] [ebp-2Ch]
  int *v36; // [esp+88h] [ebp-24h]
  int *v37; // [esp+8Ch] [ebp-20h]
  float *v38; // [esp+90h] [ebp-1Ch]
  float v39; // [esp+98h] [ebp-14h]

  v4 = *(__int16 *)(a1 + 0x44);
  if ( v4 < 0 || v4 >= 6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7F);
  }
  v5 = *(__int16 *)(a2 + 0x44);
  if ( v5 < 0 || v5 >= 6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x81);
  }
  v6 = 0;
  if ( *(_WORD *)(a1 + 0x44) != word_9652E[*(_DWORD *)a1] && *(_WORD *)(a2 + 0x44) != word_9652E[*(_DWORD *)a2] )
  {
    v7 = sub_205A0((int)dword_A2F6C, a1, a2);
    v8 = (float *)v7;
    v6 = v7;
    if ( v7 )
    {
      *(_DWORD *)(a1 + 4 * (__int16)(*(_WORD *)(a1 + 0x44))++ + 0x2C) = v7;
      *(_DWORD *)(a2 + 4 * (__int16)(*(_WORD *)(a2 + 0x44))++ + 0x2C) = v7;
      v19 = 0.0;
      v20 = 0.0;
      v21 = 0.0;
      v22 = *(float *)(a2 + 8);
      v23 = *(float *)(a2 + 0xC);
      v24 = *(float *)(a2 + 0x10);
      v13 = 0.0;
      v14 = 0.0;
      v15 = 0.0;
      v35 = v11;
      v13 = v22 - *(float *)(a1 + 8);
      v14 = v23 - *(float *)(a1 + 0xC);
      v15 = v24 - *(float *)(a1 + 0x10);
      *(float *)v11 = v13;
      *(float *)&v11[1] = v14;
      *(float *)&v11[2] = v15;
      v22 = v13;
      v23 = v14;
      v24 = v15;
      v9 = sqrt(v14 * v14 + v13 * v13 + v15 * v15);
      v36 = v12;
      v32 = v22 * (1.0 / v9);
      *(float *)v12 = v32;
      *(float *)&v33 = v23 * (1.0 / v9);
      v12[1] = v33;
      *(float *)&v34 = 1.0 / v9 * v24;
      v12[2] = v34;
      v39 = v9 * flt_90A84;
      v22 = v32;
      v23 = *(float *)&v33;
      v39 = v39 * flt_90A88 + flt_90A8C;
      v24 = *(float *)&v34;
      v16 = v32 * v39;
      v37 = v31;
      *(float *)&v17 = *(float *)&v33 * v39;
      *(float *)v31 = v16;
      *(float *)&v18 = *(float *)&v34 * v39;
      v31[1] = v17;
      v31[2] = v18;
      v19 = v16;
      v20 = *(float *)&v17;
      v21 = *(float *)&v18;
      v8[2] = v16;
      v8[3] = v20;
      v8[4] = v21;
      v25 = -v19;
      v38 = &v28;
      v26 = -v20;
      v28 = v25;
      v27 = -v21;
      v29 = v26;
      v30 = v27;
      v8[5] = v25;
      v8[6] = v29;
      v8[7] = v30;
    }
  }
  return v6;
}
// 90A84: using guessed type float flt_90A84;
// 90A88: using guessed type float flt_90A88;
// 90A8C: using guessed type float flt_90A8C;
// 9652E: using guessed type __int16 word_9652E[];
// A2F6C: using guessed type int dword_A2F6C[];

//----- (0001D234) --------------------------------------------------------
__int16 __fastcall sub_1D234(int a1, int a2, __int16 a3)
{
  int v5; // eax
  __int16 v6; // bx
  __int16 v7; // ax
  int v8; // ebx
  int v9; // edx
  char v10; // bh
  char *v11; // eax
  __int16 v13; // [esp+2h] [ebp-10h]

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB3);
  }
  if ( a3 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB4);
  }
  if ( *(unsigned __int8 *)(a2 + 0x57) == a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB5);
  }
  if ( *(unsigned __int8 *)(a2 + 0x57) == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB7);
  }
  v13 = *(unsigned __int8 *)(a2 + 0x57);
  v5 = *(unsigned __int8 *)(a2 + 0x57);
  if ( v5 != 0xFF )
  {
    if ( a3 == 0xFFFFFFFF )
    {
      *(_BYTE *)(a2 + 0x57) = 0xFF;
    }
    else
    {
      *(_BYTE *)(a2 + 0x57) = a3;
      *(_BYTE *)(a1 + 0x14) |= 1 << a3;
    }
    v6 = *(_WORD *)(a1 + 0x5A);
    v7 = 0;
    *(_BYTE *)(a1 + 0x14) &= ~(1 << v13);
    if ( v6 > 0 )
    {
      while ( *(unsigned __int8 *)(*(_DWORD *)(a1 + 4 * v7 + 0x46) + 0x57) != v13 )
      {
        if ( ++v7 >= *(__int16 *)(a1 + 0x5A) )
        {
          goto LABEL_18;
        }
      }
      *(_BYTE *)(a1 + 0x14) |= 1 << v13;
    }
LABEL_18:
    LOWORD(v5) = v13;
    v8 = *(int *)((char *)&dword_A2F79 + 0x1EE * v13);
    if ( a1 == v8 )
    {
      v9 = *(unsigned __int8 *)(v8 + 0x14);
      v5 = 1 << v13;
      if ( ((1 << v13) & v9) == 0 )
      {
        *(_BYTE *)(a1 + 0x14) = v9 & 0x7F;
      }
    }
  }
  v10 = *(_BYTE *)(a2 + 0x54);
  if ( v10 != (char)0xFF )
  {
    if ( v10 == 0x17 )
    {
      v11 = sub_35A70(a2, *(_WORD *)(a2 + 0x52));
      if ( v13 != *((_WORD *)v11 + 0x2B) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xE0);
      }
      sub_49940((int)v11);
    }
    v5 = *(unsigned __int16 *)(a2 + 0x52);
    if ( (unsigned __int16)v5 != 0xFFFF && *(_BYTE *)(a2 + 0x54) != 0x23 )
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 0x10) + 4 * v5 + 1) = 0xFF;
      v5 = *(unsigned __int16 *)(a2 + 0x52);
      *(_WORD *)(*(_DWORD *)(a2 + 0x10) + 4 * v5 + 2) = 0;
    }
    *(_BYTE *)(a2 + 0x54) = 0xFF;
    *(_WORD *)(a2 + 0x50) = 0;
    *(_WORD *)(a2 + 0x52) = 0xFFFF;
  }
  return v5;
}
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001D3E8) --------------------------------------------------------
unsigned int __fastcall sub_1D3E8(int a1, int a2, int a3)
{
  char v5; // ah
  float *v6; // eax
  int i; // edx
  int v8; // eax
  float v10; // [esp+0h] [ebp-1Ch] BYREF
  float v11; // [esp+4h] [ebp-18h]
  float v12; // [esp+8h] [ebp-14h]
  int v13; // [esp+Ch] [ebp-10h]

  if ( a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xFD);
  }
  v5 = *(_BYTE *)(a2 + 0x58);
  if ( v5 == 5 )
  {
    v6 = *(float **)(a2 + 0x59);
    v10 = 0.0;
    v11 = 0.0;
    v12 = 0.0;
    if ( a1 == *(_DWORD *)v6 )
    {
      v10 = v6[2];
      v11 = v6[3];
      v12 = v6[4];
    }
    else
    {
      if ( a1 != *((_DWORD *)v6 + 1) )
      {
        Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0x10A);
      }
      v10 = v6[5];
      v11 = v6[6];
      v12 = v6[7];
    }
    v11 = v11 + flt_90AF2;
    v12 = (double)(rand() % 0xC8) + v12;
    v13 = rand() % 0xC8;
    v10 = (double)v13 + v10;
    sub_496BC(a2, &v10);
    *(_BYTE *)(a2 + 0x58) = 4;
  }
  else if ( v5 != 4 )
  {
    goto LABEL_12;
  }
  *(_DWORD *)(a2 + 0x59) = a1;
LABEL_12:
  *(_BYTE *)(a1 + 0x15) |= 1 << *(_BYTE *)(a2 + 0x56);
  *(_BYTE *)(a1 + 0x17) |= 1 << *(_BYTE *)(a2 + 0x56);
  for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x44); ++i )
  {
    v8 = *(_DWORD *)(a1 + 4 * (__int16)i + 0x2C);
    *(_BYTE *)(v8 + 0x20) |= 1 << *(_BYTE *)(a2 + 0x56);
    *(_BYTE *)(*(_DWORD *)v8 + 0x16) |= 1 << *(_BYTE *)(a2 + 0x56);
    *(_BYTE *)(*(_DWORD *)(v8 + 4) + 0x16) |= 1 << *(_BYTE *)(a2 + 0x56);
  }
  return 0xFFFFFFFF;
}
// 90AF2: using guessed type float flt_90AF2;

//----- (0001D538) --------------------------------------------------------
unsigned int __fastcall sub_1D538(int a1, int a2)
{
  char v4; // ah
  int v5; // edx
  int v6; // esi
  unsigned int v7; // ebp
  __int16 i; // dx
  int v9; // eax
  int v11[107]; // [esp+0h] [ebp-1C4h] BYREF
  int v12; // [esp+1ACh] [ebp-18h]

  LOWORD(v12) = *(_WORD *)(a2 + 0x56);
  if ( (v12 & 0x8000u) != 0 || (__int16)v12 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x139);
  }
  v4 = *(_BYTE *)(a2 + 0x58);
  if ( (v4 == 3 || v4 == 1 || v4 == 2) && !sub_35C38(*(_DWORD *)(a2 + 0x59), a2) )
  {
    v5 = *(__int16 *)(*(_DWORD *)(a2 + 0x59) + 0xC);
    *(_BYTE *)(a2 + 0x58) = 4;
    *(_DWORD *)(a2 + 0x59) = &word_A3D21[0x30 * v5];
  }
  if ( *(_BYTE *)(a2 + 0x58) != 4 || a1 != *(_DWORD *)(a2 + 0x59) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x149);
  }
  v6 = sub_1D794((__int16 *)a1, v11);
  if ( v6 <= 0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0x14E);
  }
  v7 = 0xFFFFFFFF;
  for ( i = 0; i < v6; ++i )
  {
    v9 = v11[i];
    if ( *(_WORD *)(v9 + 0x56) == (_WORD)v12 && v9 != a2 && *(_BYTE *)(v9 + 0x58) != 1 )
    {
      v7 = 0;
      break;
    }
  }
  if ( v7 == 0xFFFFFFFF )
  {
    *(_BYTE *)(a1 + 0x15) &= ~(1 << v12);
  }
  return 0xFFFFFFFF;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// 1D538: using guessed type int var_1C4[107];

//----- (0001D654) --------------------------------------------------------
int __fastcall sub_1D654(__int16 *a1, int a2, int a3)
{
  int result; // eax
  __int16 v5; // si
  int v6; // ecx
  int v7[107]; // [esp+0h] [ebp-1C4h] BYREF
  int v8; // [esp+1ACh] [ebp-18h]
  int v9; // [esp+1B0h] [ebp-14h]

  v9 = a3;
  if ( !a2 || !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x16C);
  }
  result = sub_1D794(a1, v7);
  v5 = 0;
  v8 = result;
  while ( v5 < v8 )
  {
    v6 = v7[v5];
    result = *(__int16 *)(v6 + 0x56);
    if ( result == (unsigned __int8)byte_104BEA )
    {
      sub_1D538((int)a1, v6);
      *(_DWORD *)(v6 + 0x59) = v9;
      *(_BYTE *)(v6 + 0x58) = 5;
      result = sub_1D3E8(a2, v6, 0);
    }
    ++v5;
  }
  return result;
}
// 1D654: could not find valid save-restore pair for ebx
// 1D654: using guessed type int var_1C4[107];

//----- (0001D734) --------------------------------------------------------
void __fastcall sub_1D734(int a1, int a2)
{
  int v3; // ebx
  __int16 v4; // ax
  int v5; // edx
  int v6; // ecx
  unsigned __int8 v7; // [esp+0h] [ebp-14h]

  v3 = 0;
  v7 = *(_BYTE *)(a1 + 0x14) | *(_BYTE *)(a1 + 0x15);
  v4 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    v5 = 0;
    do
    {
      if ( (v7 & (unsigned __int8)(1 << v4)) != 0 )
      {
        v6 = v5;
        ++v3;
        v5 += 2;
        *(_WORD *)(v6 + a2) = v4;
      }
      ++v4;
    }
    while ( v4 < SHIWORD(dword_A3CF2) );
  }
  JUMPOUT(0x1D78B);
}
// 1D789: control flows out of bounds to 1D78B
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001D794) --------------------------------------------------------
int __fastcall sub_1D794(__int16 *a1, _DWORD *a2)
{
  char *v2; // eax
  _DWORD *v3; // ebx
  int v4; // edi
  int v5; // esi
  __int16 i; // dx
  char v7; // cl

  v2 = (char *)&unk_CA1F1;
  v3 = a2;
  v4 = 0;
  v5 = 0;
  for ( i = 0; i < 0x6B && v5 < SHIWORD(dword_D35E5); ++i )
  {
    if ( *((__int16 *)v2 + 0x2B) != 0xFFFFFFFF )
    {
      if ( ((v7 = v2[0x58], ++v5, v7 == 3) || v7 == 1 || v7 == 2)
        && &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(v2 + 0x59) + 0xC)] == a1
        || v2[0x58] == 4 && a1 == *(__int16 **)(v2 + 0x59) )
      {
        if ( a2 )
        {
          *v3 = v2;
        }
        ++v3;
        ++v4;
      }
    }
    v2 += 0x162;
  }
  return v4;
}
// A3D21: using guessed type __int16 word_A3D21[];
// D35E5: using guessed type int dword_D35E5;

//----- (0001D834) --------------------------------------------------------
unsigned int __fastcall sub_1D834(int a1, __int16 a2)
{
  __int16 *v3; // ecx
  __int16 v4; // di
  int v5; // eax
  __int16 v6; // dx
  int v7; // eax
  __int16 v10; // [esp+6h] [ebp-18h]

  v3 = (__int16 *)&unk_CA1F1;
  v4 = 0;
  v10 = 0;
  while ( 1 )
  {
    if ( v4 >= 0x6B || v10 >= SHIWORD(dword_D35E5) )
    {
      return 0;
    }
    v5 = v3[0x2B];
    if ( v5 != 0xFFFFFFFF )
    {
      ++v10;
      if ( *((_BYTE *)v3 + 0x58) == 5
        && (byte_A3132[0x1EE * a2 + v5] == 2 || v5 == (unsigned __int8)byte_104BEA || a2 == v3[0x2B]) )
      {
        v6 = 0;
        if ( *(__int16 *)(a1 + 0x44) > 0 )
        {
          break;
        }
      }
    }
LABEL_2:
    ++v4;
    v3 += 0xB1;
  }
  while ( 1 )
  {
    v7 = a1 + 4 * v6;
    if ( *(_DWORD *)((char *)v3 + 0x59) == *(_DWORD *)(v7 + 0x2C)
      && (a1 == **(_DWORD **)(v7 + 0x2C) && (*(_DWORD *)(v3 + 0x51) & 0x7FFFFFFF) == 0
       || a1 == *(_DWORD *)(*(_DWORD *)(a1 + 4 * v6 + 0x2C) + 4) && *(_DWORD *)(v3 + 0x51) == 0x3F800000) )
    {
      return 0xFFFFFFFF;
    }
    if ( ++v6 >= *(__int16 *)(a1 + 0x44) )
    {
      goto LABEL_2;
    }
  }
}
// D35E5: using guessed type int dword_D35E5;

//----- (0001D920) --------------------------------------------------------
int *__fastcall sub_1D920(int a1, unsigned int count, int a3)
{
  int v4; // eax
  int *result; // eax
  int v6[5]; // [esp+0h] [ebp-70h] BYREF
  char v7; // [esp+14h] [ebp-5Ch]
  char v8; // [esp+15h] [ebp-5Bh]
  char v9; // [esp+16h] [ebp-5Ah]
  char v10; // [esp+17h] [ebp-59h]
  int v11; // [esp+18h] [ebp-58h]
  int v12; // [esp+1Ch] [ebp-54h]
  int v13; // [esp+20h] [ebp-50h]
  int v14; // [esp+24h] [ebp-4Ch]
  int v15; // [esp+28h] [ebp-48h]
  char v16[24]; // [esp+2Ch] [ebp-44h] BYREF
  _WORD v17[3]; // [esp+44h] [ebp-2Ch]
  int v18; // [esp+4Ah] [ebp-26h]
  int v19; // [esp+4Eh] [ebp-22h]
  int v20; // [esp+52h] [ebp-1Eh]
  int v21; // [esp+56h] [ebp-1Ah]
  __int16 v22[11]; // [esp+5Ah] [ebp-16h]

  if ( a3 != 0xFFFFFFFF )
  {
    return (int *)sub_1C098(count, a1, 0x60u);
  }
  sub_1CF40(v6);
  sub_1BF94((P_Type1)count, v6, 0x60u);
  *(_DWORD *)a1 = v6[0];
  *(_DWORD *)(a1 + 4) = v6[1];
  *(_DWORD *)(a1 + 8) = v6[2];
  *(_DWORD *)(a1 + 0xC) = v6[3];
  *(_DWORD *)(a1 + 0x10) = v6[4];
  *(_BYTE *)(a1 + 0x14) = v7;
  *(_BYTE *)(a1 + 0x15) = v8;
  *(_BYTE *)(a1 + 0x16) = v9;
  *(_BYTE *)(a1 + 0x17) = v10;
  *(_DWORD *)(a1 + 0x18) = v11;
  *(_DWORD *)(a1 + 0x1C) = v12;
  *(_DWORD *)(a1 + 0x20) = v13;
  *(_DWORD *)(a1 + 0x24) = v14;
  *(_DWORD *)(a1 + 0x28) = v15;
  qmemcpy((void *)(a1 + 0x2C), v16, 0x18u);
  *(_WORD *)(a1 + 0x44) = v17[0];
  *(_DWORD *)(a1 + 0x46) = *(_DWORD *)&v17[1];
  *(_DWORD *)(a1 + 0x4A) = v18;
  *(_DWORD *)(a1 + 0x4E) = v19;
  *(_DWORD *)(a1 + 0x52) = v20;
  *(_DWORD *)(a1 + 0x56) = v21;
  *(_WORD *)(a1 + 0x5A) = v22[0];
  v4 = *(_DWORD *)&v22[1];
  *(_WORD *)(a1 + 0x44) = 0;
  *(_DWORD *)(a1 + 0x5C) = v4;
  result = v6;
  *(_WORD *)(a1 + 0x5A) = 0;
  return result;
}
// 1D920: using guessed type _WORD var_16[11];

//----- (0001DA04) --------------------------------------------------------
int __fastcall sub_1DA04(int a1, int a2)
{
  int result; // eax

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x21A);
  }
  result = *(__int16 *)(a2 + 4);
  LOWORD(result) = (unsigned __int8)byte_D5D47[0x64 * *(__int16 *)(a1 + 4) + result];
  return result;
}

//----- (0001DA4C) --------------------------------------------------------
int __fastcall sub_1DA4C(int a1, __int16 a2, int a3, int a4)
{
  int v5; // ebx
  int *v6; // ecx
  int i; // edi
  int v8; // eax
  int v9; // edx
  int v10; // ecx

  if ( a2 > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x248);
  }
  if ( a4 >= 0x6B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x249);
  }
  v5 = 0;
  if ( ((1 << a2) & *(unsigned __int8 *)(a1 + 0x16)) == 0 )
  {
    return 0x2BC;
  }
  v6 = (int *)(a1 + 0x46);
  for ( i = 0; i < *(__int16 *)(a1 + 0x5A); ++i )
  {
    if ( *(unsigned __int8 *)(*v6 + 0x57) != a2 )
    {
      v5 += sub_364B4(*v6, a2);
    }
    ++v6;
  }
  v8 = 0;
  v9 = 0;
  while ( v8 < SHIWORD(dword_A3CF2) )
  {
    if ( v8 != a2 )
    {
      v10 = *(int *)((char *)&dword_A2F79 + v9);
      if ( a1 == v10 && (*(_BYTE *)(v10 + 0x14) & 0x80) != 0 && byte_A3132[0x1EE * a2 + v8] == 2 )
      {
        v5 = 3 * v5 + 0xC8;
      }
    }
    v9 += 0x1EE;
    ++v8;
  }
  if ( !*(_BYTE *)(a1 + 0x14) )
  {
    v5 *= 2;
  }
  if ( v5 < 0 )
  {
    v5 = 0;
  }
  if ( ((1 << a2) & *(unsigned __int8 *)(a1 + 0x17)) == 0 )
  {
    return 4 * v5 + 0x12C;
  }
  return v5;
}
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001DB70) --------------------------------------------------------
int __fastcall sub_1DB70(int a1, __int16 a2, int *a3, int a4)
{
  char v6; // al
  int v7; // eax
  unsigned int v8; // ebp
  int v9; // ecx
  int v10; // ebp
  int v11; // ecx
  int *v12; // ecx
  int i; // ebp
  int v14; // edx
  int v15; // edx
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  int v19; // eax
  int v21[107]; // [esp+0h] [ebp-1D4h] BYREF
  int *v22; // [esp+1ACh] [ebp-28h]
  int v23; // [esp+1B0h] [ebp-24h]
  int v24; // [esp+1B4h] [ebp-20h]
  int v25; // [esp+1B8h] [ebp-1Ch]
  int v26; // [esp+1BCh] [ebp-18h]
  int *v27; // [esp+1C0h] [ebp-14h]
  float v28; // [esp+1C4h] [ebp-10h]

  v27 = a3;
  v26 = a4;
  if ( a2 > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x2BD);
  }
  v23 = 0;
  if ( ((1 << a2) & *(unsigned __int8 *)(a1 + 0x16)) != 0 && ((1 << a2) & *(unsigned __int8 *)(a1 + 0x14)) != 0 )
  {
    v6 = *(_BYTE *)(a1 + 0x15);
    v28 = 0.0;
    if ( v6 )
    {
      if ( v27 && v26 >= 0 )
      {
        v10 = 0;
        if ( v26 > 0 )
        {
          v22 = v27;
          do
          {
            v11 = *v22;
            if ( !*v22 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x2F1);
            }
            if ( (*(_BYTE *)(v11 + 0x58) == 4 && a1 == *(_DWORD *)(v11 + 0x59)
               || *(_BYTE *)(v11 + 0x58) == 3 && *(_WORD *)(a1 + 4) == *(_WORD *)(*(_DWORD *)(v11 + 0x59) + 0xC))
              && a2 != *(_WORD *)(v11 + 0x56)
              && byte_A3132[0x1EE * a2 + *(__int16 *)(v11 + 0x56)] == 2 )
            {
              v24 = sub_4A988(*v22);
              v28 = (double)v24 + v28;
            }
            ++v10;
            ++v22;
          }
          while ( v10 < v26 );
        }
      }
      else
      {
        v7 = sub_1D794((__int16 *)a1, v21);
        if ( v7 > 0 )
        {
          v8 = 0;
          v25 = 4 * v7;
          do
          {
            v9 = v21[v8 / 4];
            if ( !v9 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x2D6);
            }
            if ( (*(_BYTE *)(v9 + 0x58) == 4 && a1 == *(_DWORD *)(v9 + 0x59)
               || *(_BYTE *)(v9 + 0x58) == 3 && *(_WORD *)(a1 + 4) == *(_WORD *)(*(_DWORD *)(v9 + 0x59) + 0xC))
              && a2 != *(_WORD *)(v9 + 0x56)
              && byte_A3132[0x1EE * a2 + *(__int16 *)(v9 + 0x56)] == 2 )
            {
              v24 = sub_4A988(v21[v8 / 4]);
              v28 = (double)v24 + v28;
            }
            v8 += 4;
          }
          while ( (int)v8 < v25 );
        }
      }
      v28 = v28 * flt_90B90 * flt_90B94;
    }
    if ( v28 > 0.0 )
    {
      v12 = (int *)(a1 + 0x46);
      for ( i = 0; i < *(__int16 *)(a1 + 0x5A); ++i )
      {
        if ( *(unsigned __int8 *)(*v12 + 0x57) == a2 )
        {
          v14 = v23;
          v15 = sub_363B0(*v12) + v14;
          sub_360D8(*v12);
          v17 = v15 - 0xA * v16;
          v18 = *v12;
          v23 = v15;
          sub_36158(v18);
          v23 = v17 - 5 * v19;
        }
        ++v12;
      }
      if ( a1 == *(int *)((char *)&dword_A2F79 + 0x1EE * a2) )
      {
        v23 += 0x4E20;
      }
      v23 = (int)((double)v23 * v28);
    }
    if ( v23 < 0 )
    {
      v23 = 0;
    }
  }
  return 5 * v23;
}
// 1DDC9: variable 'v16' is possibly undefined
// 1DDE0: variable 'v19' is possibly undefined
// 90B90: using guessed type float flt_90B90;
// 90B94: using guessed type float flt_90B94;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;

//----- (0001DE64) --------------------------------------------------------
int __fastcall sub_1DE64(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edx

  v1 = _wcpp_2_ctor_array_(a1 + 6, 7, &unk_95AF0);
  v2 = _wcpp_2_ctor_array_(v1 + 0xDAF, 0x64, &unk_95B04);
  v3 = _wcpp_2_ctor_array_(v2 + 0x2582, 0x94, &unk_95ADC);
  v4 = _wcpp_2_ctor_array_(v3 + 0x14F10, 0x1F4, &unk_95AC8);
  v5 = _wcpp_2_ctor_array_(v4 + 0xF03E, 0x6B, &unk_95AB4);
  v6 = _wcpp_2_ctor_array_(v5 + 0x93F8, 9, &unk_95AA0);
  v7 = _wcpp_2_ctor_array_(v6 + 0x84, 0x18, &unk_95A8C) - 0x30701;
  sub_1E094(v7);
  return v7;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);

//----- (0001E03C) --------------------------------------------------------
int __fastcall sub_1E03C(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax

  v1 = sub_222C0((int)&off_30701 + a1);
  v2 = sub_222E0(v1 - 0x84);
  v3 = sub_222A0(v2 - 0x93F8);
  v4 = sub_22300(v3 - 0xF03E);
  v5 = sub_22320(v4 - 0x14F10);
  v6 = sub_22280(v5 - 0x2582);
  return sub_22260(v6 - 0xDAF) - 6;
}
// 30701: using guessed type void *off_30701;

//----- (0001E094) --------------------------------------------------------
char __fastcall sub_1E094(int a1)
{
  char *v2; // edx
  int v3; // ebx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char result; // al

  v2 = byte_D84C4;
  v3 = 0xB2;
  do
  {
    v4 = v2;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3);
    do
    {
      result = *sub_1CEA8;
      *v4 = *sub_1CEA8;
      if ( !result )
      {
        break;
      }
      result = sub_1CEA8[1];
      sub_1CEA8 += 2;
      v4[1] = result;
      v4 += 2;
    }
    while ( result );
    v2 += 0x14;
    ++v3;
  }
  while ( v2 != &byte_D84C4[0x104] );
  *(_WORD *)(a1 + 0x3335) = 0;
  *(_WORD *)(a1 + 0x49C3) = 0;
  *(_WORD *)(a1 + 0xD88) = 0;
  *(_WORD *)((char *)sub_3067B + a1) = 0;
  *(_BYTE *)(a1 + 0xDB4) = 1;
  return result;
}

//----- (0001E10C) --------------------------------------------------------
void __fastcall sub_1E10C(int a1, __int16 a2, __int16 a3, __int16 a4)
{
  *(_WORD *)(a1 + 4) = 0;
  dword_96B88 = 0x20;
  sub_1E2A0(a1, a2);
  sub_1E150(a1, 9);
  sub_1EFC0(a1);
  sub_1E70C(a1, a3, a4);
}
// 96B88: using guessed type int dword_96B88;

//----- (0001E150) --------------------------------------------------------
int __fastcall sub_1E150(int a1, __int16 a2)
{
  int v3; // ebx
  __int64 v4; // rax
  int v5; // ecx
  char *v6; // ebx
  int v7; // edi
  int v8; // esi
  int result; // eax
  float v10; // [esp+0h] [ebp-44h]
  int v11; // [esp+10h] [ebp-34h] BYREF
  float v12; // [esp+14h] [ebp-30h]
  int v13; // [esp+18h] [ebp-2Ch]
  int v14; // [esp+1Ch] [ebp-28h]
  int v15; // [esp+20h] [ebp-24h]
  int v16; // [esp+24h] [ebp-20h]
  _BYTE v17[6]; // [esp+28h] [ebp-1Ch]

  *(_WORD *)&v17[4] = a2;
  if ( a2 > 9 )
  {
    *(_WORD *)&v17[4] = 9;
  }
  v3 = *(_DWORD *)&v17[2];
  *(_WORD *)((char *)sub_306F0 + a1 + 2) = 0;
  v11 = 0;
  v12 = 0.0;
  v13 = 0;
  v16 = 0x168 / (v3 >> 0x10);
  v4 = (3 * v16 - (__CFSHL__((3 * v16) >> 0x1F, 2) + 4 * ((3 * v16) >> 0x1F))) >> 2;
  v15 = v4;
  v5 = 0;
  v6 = (char *)&loc_3067E + a1;
  v7 = 0;
  v8 = a1;
  v14 = ((int)v4 - HIDWORD(v4)) >> 1;
  while ( 1 )
  {
    result = *(__int16 *)&v17[4];
    if ( v5 >= *(__int16 *)&v17[4] )
    {
      break;
    }
    *((_BYTE *)sub_3067B + v8 + 2) = v5;
    v11 = 0x447A0000;
    v12 = 300.0;
    v13 = 0;
    *(_DWORD *)v17 = v7 + rand() % v15 - v14;
    v10 = (float)*(int *)v17;
    sub_532AC((float *)&v11, v10);
    *(_DWORD *)v17 = rand() % 0x258 - 0x12C;
    v12 = (double)*(int *)v17 + v12;
    *(_DWORD *)v6 = v11;
    *((float *)v6 + 1) = v12;
    v6 += 0xD;
    v8 += 0xD;
    *(_DWORD *)(v6 + 0xFFFFFFFB) = v13;
    ++v5;
    v7 += v16;
    ++*(_WORD *)((char *)sub_306F0 + a1 + 2);
  }
  return result;
}
// 306F0: using guessed type int sub_306F0();

//----- (0001E2A0) --------------------------------------------------------
int __fastcall sub_1E2A0(int a1, __int16 a2)
{
  __int16 v2; // bx
  FILE *v3; // ebp
  __int16 i; // ax
  int v5; // edx
  int v6; // eax
  _DWORD *v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // ebp
  __int16 v11; // ax
  char *v12; // edx
  char *v13; // edi
  char *v14; // esi
  int v15; // ebx
  char v16; // al
  char v17; // al
  int v18; // ebx
  char *v19; // edi
  char *v20; // esi
  char v21; // al
  char v22; // al
  double v23; // st7
  __int64 v24; // rax
  __int16 v25; // bx
  __int16 v26; // si
  __int16 j; // dx
  int v28; // ebp
  __int16 v29; // cx
  int v30; // edx
  __int16 v31; // si
  char *v33; // [esp-4h] [ebp-840h]
  _DWORD v34[500]; // [esp+0h] [ebp-83Ch] BYREF
  int v35[3]; // [esp+7D0h] [ebp-6Ch] BYREF
  float v36; // [esp+7DCh] [ebp-60h]
  int v37; // [esp+7E0h] [ebp-5Ch]
  int v38; // [esp+7E4h] [ebp-58h]
  float v39; // [esp+7E8h] [ebp-54h] BYREF
  float v40; // [esp+7ECh] [ebp-50h]
  float v41; // [esp+7F0h] [ebp-4Ch]
  fpos_t v42; // [esp+7F4h] [ebp-48h] BYREF
  fpos_t pos; // [esp+7F8h] [ebp-44h] BYREF
  int v44; // [esp+7FCh] [ebp-40h]
  int v45; // [esp+800h] [ebp-3Ch]
  int *v46; // [esp+804h] [ebp-38h]
  FILE *fp; // [esp+808h] [ebp-34h]
  int v48; // [esp+80Ch] [ebp-30h]
  int v49; // [esp+810h] [ebp-2Ch]
  int v50; // [esp+814h] [ebp-28h]
  _DWORD *v51; // [esp+818h] [ebp-24h]
  int v52; // [esp+81Ch] [ebp-20h]
  float v53; // [esp+820h] [ebp-1Ch]
  int v54; // [esp+824h] [ebp-18h]

  v48 = a1;
  v39 = 0.0;
  v40 = 0.0;
  v41 = 0.0;
  v49 = 0;
  v2 = 0;
  fp = sub_1BB10("names.txt", &v42);
  v53 = 440.0;
  v3 = fp;
  while ( v2 < 0x64 )
  {
    fgetpos(fp, &pos);
    if ( v42 > pos )
    {
      fscanf(v3, "%s", &v34[5 * v2]);
    }
    else
    {
      sprintf((char *)&v34[5 * v2], "XM%02d", v2);
    }
    ++v2;
  }
  fclose(fp);
  v52 = 0x64;
  *(_WORD *)(v48 + 0x3335) = a2;
  v50 = a2 / 2;
  for ( i = 0; i < 0xD; ++i )
  {
    v5 = *(int *)((char *)&off_96512 + 2 * i) >> 0x10;
    v49 += v5;
  }
  v6 = v48;
  *(_WORD *)((char *)&loc_27281 + v48 + 2) = 0;
  v7 = (_DWORD *)v48;
  *(_WORD *)((char *)&loc_18241 + v6 + 4) = 0;
  v8 = v6 + 0xDB5;
  *v7 = 0;
  *(_DWORD *)((char *)v7 + (_DWORD)&loc_306F3 + 1) = v8;
  *(_DWORD *)((char *)v7 + (_DWORD)&loc_306F7 + 1) = (char *)&loc_18247 + (_DWORD)v7;
  LOWORD(v54) = 0;
  if ( *(__int16 *)(v48 + 0x3335) > 0 )
  {
    v44 = v8;
    v51 = &v34[5 * v52];
    do
    {
      v9 = (__int16)v54;
      v10 = v44 + 0x60 * (__int16)v54;
      *(_BYTE *)(v10 + 0x14) = 0;
      *(_BYTE *)(v10 + 0x15) = 0;
      *(_BYTE *)(v10 + 0x16) = 0;
      *(_BYTE *)(v10 + 0x17) = 0;
      *(_WORD *)(v10 + 0x44) = 0;
      *(_WORD *)(v10 + 6) = 0xFFFF;
      v11 = v54;
      *(_WORD *)(v10 + 0x5A) = 0;
      *(_WORD *)(v10 + 4) = v11;
      v12 = (char *)&v34[5 * (rand() % v52)];
      v13 = (char *)(v10 + 0x1C);
      v14 = v12;
      v15 = v52;
      v33 = (char *)(v10 + 0x1C);
      do
      {
        v16 = *v14;
        *v13 = *v14;
        if ( !v16 )
        {
          break;
        }
        v17 = v14[1];
        v14 += 2;
        v13[1] = v17;
        v13 += 2;
      }
      while ( v17 );
      v18 = v15 - 1;
      v19 = v12;
      v20 = (char *)(v51 + 0xFFFFFFFB);
      v51 += 0xFFFFFFFB;
      v33 = v12;
      do
      {
        v21 = *v20;
        *v19 = *v20;
        if ( !v21 )
        {
          break;
        }
        v22 = v20[1];
        v20 += 2;
        v19[1] = v22;
        v19 += 2;
      }
      while ( v22 );
      v52 = v18;
      if ( v9 > v50 )
      {
        v23 = v53 + flt_90BC8;
        v53 = v23;
        if ( v23 < flt_90BCC )
        {
          v53 = 50.0;
        }
        v24 = *(__int16 *)(v48 + 0x3335) - (__int16)v54;
        v50 += ((int)v24 - HIDWORD(v24)) >> 1;
      }
      *(_DWORD *)v10 = 0xC;
      v25 = 0;
      v26 = rand() % v49 + 1;
      for ( j = 0; j < 0xD; ++j )
      {
        v25 += *((_WORD *)&off_96512 + j + 1);
        if ( v26 <= v25 )
        {
          *(_DWORD *)v10 = j;
          break;
        }
      }
      v45 = rand() % 0x3E8 - 0x1F4;
      v39 = (float)v45;
      v45 = rand() % 0x3E8 - 0x1F4;
      v40 = (float)v45;
      v45 = rand() % 0x3E8 - 0x1F4;
      v41 = (float)v45;
      sub_53000(&v39);
      v46 = v35;
      v36 = v39 * v53;
      *(float *)v35 = v36;
      *(float *)&v37 = v40 * v53;
      v35[1] = v37;
      *(float *)&v38 = v53 * v41;
      v35[2] = v38;
      v39 = v36;
      v40 = *(float *)&v37;
      v41 = *(float *)&v38;
      *(float *)(v10 + 8) = v36;
      v28 = v10 + 8;
      *(float *)(v28 + 4) = v40;
      v29 = v54;
      v30 = v48;
      *(float *)(v28 + 8) = v41;
      v31 = *(_WORD *)(v30 + 0x3335);
      LOWORD(v54) = v29 + 1;
    }
    while ( (__int16)(v29 + 1) < v31 );
  }
  return fclose(fp);
}
// 90BC8: using guessed type float flt_90BC8;
// 90BCC: using guessed type float flt_90BCC;
// 96512: using guessed type void *off_96512;

//----- (0001E70C) --------------------------------------------------------
void __fastcall sub_1E70C(int a1, __int16 a2, unsigned __int8 a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // eax
  __int16 k; // di
  int v9; // eax
  __int16 m; // ax
  int *v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // ebx
  int v15; // edx
  int v16; // eax
  int v17; // edx
  char v18; // bl
  __int16 v19; // dx
  int *v20; // eax
  int v21; // ecx
  int v22; // eax
  int ii; // ecx
  unsigned __int8 v24; // bl
  char v25; // dl
  _BYTE *v26; // eax
  unsigned int v27; // edi
  __int16 v28; // ax
  int mm; // edx
  int v30; // eax
  int v31; // ecx
  int v32; // edi
  int jj; // edx
  int v34; // eax
  int v35; // ecx
  int v36; // edi
  int kk; // edx
  int v38; // eax
  int v39; // ecx
  int v40; // edi
  unsigned __int8 v41; // al
  int v42; // eax
  int v43; // eax
  int v44; // edx
  int v45; // ebx
  char v46; // ch
  int v47; // eax
  int v48; // edx
  char v49; // bl
  int v50; // ecx
  int v51; // eax
  int v52; // ebx
  int v53; // [esp+4h] [ebp-28h]
  int v54; // [esp+8h] [ebp-24h]
  __int16 v56; // [esp+10h] [ebp-1Ch]
  int v57; // [esp+14h] [ebp-18h]
  __int16 i; // [esp+14h] [ebp-18h]
  __int16 j; // [esp+14h] [ebp-18h]
  __int16 nn; // [esp+14h] [ebp-18h]
  __int16 i1; // [esp+14h] [ebp-18h]
  __int16 n; // [esp+18h] [ebp-14h]

  *(_DWORD *)((char *)&loc_306F9 + a1 + 3) = 0xFFFFFFFF;
  byte_30700[a1] = 0;
  *(_WORD *)(a1 + 0xD88) = a2;
  v54 = 0;
  for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
  {
    v4 = 0x60 * i;
    *(_BYTE *)(a1 + v4 + 0xDC9) = 0;
    *(_BYTE *)(a1 + v4 + 0xDCA) = 0;
    *(_BYTE *)(a1 + v4 + 0xDCB) = 0;
    *(_BYTE *)(a1 + v4 + 0xDCC) = 0;
  }
  for ( j = 0; j < *(__int16 *)(a1 + 0x49C3); ++j )
  {
    *(_BYTE *)(a1 + 0x27 * j + 0x3357) = 0;
  }
  v5 = 0;
  sub_46480((unsigned __int16 *)&word_105258, 0);
  while ( 1 )
  {
    LOWORD(v57) = v5;
    v6 = (__int16)v5;
    if ( (__int16)v5 >= 7 )
    {
      break;
    }
    word_106FA6[(__int16)v5] = 0xFFFF;
    v5 = v57 + 1;
    word_106FB4[v6] = 0;
  }
  v56 = 0x258;
  v7 = *(__int16 *)(a1 + 0x3335);
  *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = 0;
  if ( v7 < 0x19 )
  {
    v56 = 0x1C2;
  }
  while ( v56 > *(__int16 *)((char *)&loc_32DD2 + a1 + 1) )
  {
    if ( v54 )
    {
      for ( k = 0; k < *(__int16 *)(a1 + 0xD88); ++k )
      {
        v9 = 0x1EE * k;
        *(_BYTE *)(*(_DWORD *)(a1 + v9 + 0xD) + 0x14) = 0;
        *(_BYTE *)(*(_DWORD *)(a1 + v9 + 0xD) + 0x17) = 0;
        for ( m = 0; ; ++m )
        {
          v13 = *(_DWORD *)(0x1EE * k + a1 + 0xD);
          if ( m >= *(__int16 *)(v13 + 0x44) )
          {
            break;
          }
          v11 = *(int **)(v13 + 4 * m + 0x2C);
          v12 = *v11;
          *((_BYTE *)v11 + 0x20) = 0;
          *(_BYTE *)(v12 + 0x16) = 0;
          *(_BYTE *)(v11[1] + 0x16) = 0;
        }
      }
    }
    for ( n = 0; n < *(__int16 *)(a1 + 0xD88); ++n )
    {
      v14 = *(_DWORD *)(a1 + 0x3333);
      v15 = 0x60 * (rand() % (v14 >> 0x10));
      v16 = a1 + 0x1EE * n;
      v17 = a1 + 0xDB5 + v15;
      *(_DWORD *)(v16 + 0xD) = v17;
      if ( *(_BYTE *)(v17 + 0x14) )
      {
        --n;
      }
      else
      {
        *(_BYTE *)(v17 + 0x14) = 0x80;
        v18 = 1 << n;
        *(_BYTE *)(*(_DWORD *)(v16 + 0xD) + 0x14) |= 1 << n;
        *(_BYTE *)(v16 + 6) = n;
        v19 = 0;
        *(_BYTE *)(*(_DWORD *)(v16 + 0xD) + 0x17) |= 1 << n;
        while ( 1 )
        {
          v22 = *(_DWORD *)(a1 + 0x1EE * n + 0xD);
          if ( v19 >= *(__int16 *)(v22 + 0x44) )
          {
            break;
          }
          v20 = *(int **)(v22 + 4 * v19 + 0x2C);
          v21 = *v20;
          *((_BYTE *)v20 + 0x20) |= v18;
          *(_BYTE *)(v21 + 0x16) |= v18;
          ++v19;
          *(_BYTE *)(v20[1] + 0x16) |= v18;
        }
      }
    }
    v5 = v54 + 1;
    sub_220CC(a1);
    ++v54;
  }
  for ( ii = 0; (__int16)ii < *(__int16 *)(a1 + 0xD88); ++ii )
  {
    if ( (_WORD)ii )
    {
      do
      {
        v27 = 0;
        v24 = rand() % 0x15;
        v28 = 0;
        if ( (__int16)ii > 0 )
        {
          while ( v24 != *(_BYTE *)(0x1EE * v28 + a1 + 7) )
          {
            if ( ++v28 >= (__int16)ii )
            {
              goto LABEL_37;
            }
          }
          v27 = 0xFFFFFFFF;
        }
LABEL_37:
        ;
      }
      while ( v27 );
    }
    else
    {
      v24 = a3;
    }
    v25 = ii;
    HIWORD(v5) = (unsigned int)(a1 + 6) >> 0x10;
    v26 = (_BYTE *)(a1 + 6 + 0x1EE * (__int16)ii);
    sub_3B1FC(v26, v25, v24);
  }
  sub_1EE08(a1, *(_BYTE *)(a1 + 8));
  v41 = *(_BYTE *)(a1 + 0xDB4);
  if ( v41 )
  {
    if ( v41 <= 1u )
    {
      for ( jj = 0; (__int16)jj < *(__int16 *)(a1 + 0xD88); ++jj )
      {
        v34 = 0x1EE * (__int16)jj;
        LOWORD(ii) = *(_WORD *)(a1 + v34 + 0x1CF);
        v35 = ii + 0x1E;
        LOWORD(v5) = *(_WORD *)(a1 + v34 + 0x1D1);
        *(_WORD *)(a1 + v34 + 0x1CF) = v35;
        v36 = v5 + 0x1E;
        LOWORD(v35) = *(_WORD *)(a1 + v34 + 0x1D3);
        *(_WORD *)(a1 + v34 + 0x1D1) = v36;
        v35 += 0x1E;
        LOWORD(v36) = *(_WORD *)(a1 + v34 + 0x1D5);
        *(_WORD *)(a1 + v34 + 0x1D3) = v35;
        v36 += 0x1E;
        LOWORD(v35) = *(_WORD *)(a1 + v34 + 0x1D7);
        *(_WORD *)(a1 + v34 + 0x1D5) = v36;
        v35 += 0x1E;
        LOWORD(v36) = *(_WORD *)(a1 + v34 + 0x1D9);
        *(_WORD *)(a1 + v34 + 0x1D7) = v35;
        v5 = v36 + 0x28;
        LOWORD(v35) = *(_WORD *)(a1 + v34 + 0x1DB);
        *(_WORD *)(a1 + v34 + 0x1D9) = v5;
        ii = v35 - 0x1E;
        *(_WORD *)(a1 + v34 + 0x1DB) = ii;
      }
    }
    else if ( v41 == 2 )
    {
      for ( kk = 0; (__int16)kk < *(__int16 *)(a1 + 0xD88); ++kk )
      {
        v38 = 0x1EE * (__int16)kk;
        LOWORD(ii) = *(_WORD *)(a1 + v38 + 0x1CF);
        v39 = ii + 0x14;
        LOWORD(v5) = *(_WORD *)(a1 + v38 + 0x1D1);
        *(_WORD *)(a1 + v38 + 0x1CF) = v39;
        v40 = v5 + 0x14;
        LOWORD(v39) = *(_WORD *)(a1 + v38 + 0x1D3);
        *(_WORD *)(a1 + v38 + 0x1D1) = v40;
        v39 += 0x14;
        LOWORD(v40) = *(_WORD *)(a1 + v38 + 0x1D5);
        *(_WORD *)(a1 + v38 + 0x1D3) = v39;
        v40 += 0x14;
        LOWORD(v39) = *(_WORD *)(a1 + v38 + 0x1D7);
        *(_WORD *)(a1 + v38 + 0x1D5) = v40;
        v39 += 0x14;
        LOWORD(v40) = *(_WORD *)(a1 + v38 + 0x1D9);
        *(_WORD *)(a1 + v38 + 0x1D7) = v39;
        v5 = v40 + 0x1E;
        LOWORD(v39) = *(_WORD *)(a1 + v38 + 0x1DB);
        *(_WORD *)(a1 + v38 + 0x1D9) = v5;
        ii = v39 - 0x14;
        *(_WORD *)(a1 + v38 + 0x1DB) = ii;
      }
    }
  }
  else
  {
    for ( mm = 0; (__int16)mm < *(__int16 *)(a1 + 0xD88); ++mm )
    {
      v30 = 0x1EE * (__int16)mm;
      LOWORD(ii) = *(_WORD *)(a1 + v30 + 0x1CF);
      v31 = ii + 0x14;
      LOWORD(v5) = *(_WORD *)(a1 + v30 + 0x1D1);
      *(_WORD *)(a1 + v30 + 0x1CF) = v31;
      v32 = v5 + 0x14;
      LOWORD(v31) = *(_WORD *)(a1 + v30 + 0x1D3);
      *(_WORD *)(a1 + v30 + 0x1D1) = v32;
      v31 += 0x14;
      LOWORD(v32) = *(_WORD *)(a1 + v30 + 0x1D5);
      *(_WORD *)(a1 + v30 + 0x1D3) = v31;
      v32 += 0x14;
      LOWORD(v31) = *(_WORD *)(a1 + v30 + 0x1D7);
      *(_WORD *)(a1 + v30 + 0x1D5) = v32;
      v31 += 0x14;
      LOWORD(v32) = *(_WORD *)(a1 + v30 + 0x1D9);
      *(_WORD *)(a1 + v30 + 0x1D7) = v31;
      v5 = v32 + 0x1E;
      LOWORD(v31) = *(_WORD *)(a1 + v30 + 0x1DB);
      *(_WORD *)(a1 + v30 + 0x1D9) = v5;
      ii = v31 - 0x14;
      *(_WORD *)(a1 + v30 + 0x1DB) = ii;
    }
  }
  *(_DWORD *)((char *)&loc_306F3 + a1 + 1) = *(_DWORD *)(a1 + 0xD);
  *(_WORD *)((char *)sub_3067B + a1) = 0;
  for ( nn = 0; nn < 0x6B; ++nn )
  {
    v42 = 0x162 * nn;
    *(_WORD *)((char *)&loc_272D8 + a1 + v42 + 3) = 0xFFFF;
    *((_BYTE *)&loc_272D8 + a1 + v42 + 5) = 0;
    *(_DWORD *)((char *)&loc_272D8 + a1 + v42 + 6) = 0;
  }
  for ( i1 = 0; i1 < *(__int16 *)(a1 + 0xD88); ++i1 )
  {
    if ( *(_BYTE *)(0x1EE * i1 + a1 + 0x1A3) == 3 && i1 == (unsigned __int8)byte_104BEA )
    {
      v43 = (unsigned __int8)byte_104BEA ^ i1;
      v44 = a1;
      while ( v43 < *(__int16 *)(a1 + 0xD88) )
      {
        v45 = *(_DWORD *)(v44 + 0xD);
        v44 += 0x1EE;
        ++v43;
        *(_BYTE *)(v45 + 0x17) |= 1 << i1;
      }
    }
    else
    {
      v46 = *(_BYTE *)(a1 + 0x1EE * i1 + 0x1A3);
      if ( v46 == 0xF )
      {
        v47 = 0;
        v48 = a1;
        while ( v47 < *(__int16 *)(a1 + 0x49C3) )
        {
          v49 = *(_BYTE *)(v48 + 0x3357);
          v48 += 0x27;
          ++v47;
          *(_BYTE *)(v48 + 0x3330) = (1 << i1) | v49;
        }
      }
      else if ( v46 == 4 )
      {
        v50 = 0;
        v51 = a1;
        v53 = 0;
        while ( v50 < *(__int16 *)(a1 + 0xD88) )
        {
          if ( i1 != v50 )
          {
            v52 = a1 + 0x1EE * i1;
            *(_WORD *)(v52 + v53 + 0x1B8) = *(_WORD *)(v52 + 0x1DB);
            *(_BYTE *)(v50 + v52 + 0x1C6) = 1;
            *(_WORD *)(v51 + 2 * i1 + 0x1B8) = *(_WORD *)(v51 + 0x1DB);
            *(_BYTE *)(i1 + v51 + 0x1C6) = 1;
          }
          v51 += 0x1EE;
          ++v50;
          v53 += 2;
        }
      }
    }
  }
  JUMPOUT(0x21299);
}
// 1ECC5: control flows out of bounds to 21299
// 1E7E7: variable 'v57' is possibly undefined
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];

//----- (0001EE08) --------------------------------------------------------
char __fastcall sub_1EE08(int a1, char a2)
{
  int v2; // esi
  __int16 v3; // cx
  unsigned int v4; // edi
  __int16 v5; // ax
  __int16 v7; // [esp+2h] [ebp-14h]

  v2 = a1;
  *(_BYTE *)(a1 + 8) = a2;
  v3 = 1;
  v4 = 0xFFFFFFFF;
  if ( *(__int16 *)(a1 + 0xD88) > 1 )
  {
    do
    {
LABEL_4:
      while ( v4 )
      {
        v4 = 0;
        v7 = rand() % 7;
        v5 = 0;
        if ( v3 > 0 )
        {
          while ( *(unsigned __int8 *)(0x1EE * v5 + v2 + 8) != v7 )
          {
            if ( ++v5 >= v3 )
            {
              goto LABEL_4;
            }
          }
          v4 = 0xFFFFFFFF;
        }
      }
      LOBYTE(a1) = v7;
      *(_BYTE *)(0x1EE * v3++ + v2 + 8) = v7;
      v4 = 0xFFFFFFFF;
    }
    while ( v3 < *(__int16 *)(v2 + 0xD88) );
  }
  return a1;
}
// 1EE39: variable 'v7' is possibly undefined

//----- (0001EEA4) --------------------------------------------------------
__int16 __fastcall sub_1EEA4(int a1)
{
  int v1; // ebp
  int v2; // ecx
  int v3; // edi
  int v4; // edx
  __int16 v5; // si
  int v6; // esi
  char s[24]; // [esp+0h] [ebp-38h] BYREF
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]

  v1 = a1;
  v2 = 0;
  if ( *(__int16 *)(a1 + 0xD88) > 0 )
  {
    v3 = 0xE;
    v10 = 0x15;
    v9 = 7;
    do
    {
      v4 = 0x1EE * (__int16)v2;
      v5 = *(unsigned __int8 *)(v4 + v1 + 7);
      sprintf(s, "DATA\\SMRACE%02d.SHP", *(unsigned __int8 *)(v4 + v1 + 7));
      sub_1AEB0((unsigned int)dword_12FC20, v2, s);
      sprintf(s, "DATA\\LGRACE%02d.SHP", v5);
      sub_1AEB0((unsigned int)dword_12FC20, v9, s);
      sprintf(s, "DATA\\SMSHIP%02d.SHP", v5);
      sub_1AEB0((unsigned int)dword_12FC20, v3, s);
      ++v2;
      ++v3;
      sprintf(s, "DATA\\DKSHIP%02d.SHP", v5);
      v6 = v9;
      sub_1AEB0((unsigned int)dword_12FC20, v10, s);
      LOWORD(a1) = *(_WORD *)(v1 + 0xD88);
      v9 = v6 + 1;
      ++v10;
    }
    while ( (__int16)v2 < (__int16)a1 );
  }
  return a1;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0001EFC0) --------------------------------------------------------
void __fastcall sub_1EFC0(int a1)
{
  int i; // eax

  memset((void *)(a1 + 0x3337), 0, 0x168Cu);
  *(_WORD *)(a1 + 0x49C3) = 0;
  sub_1F91C();
  *(_WORD *)((char *)&loc_32DCD + a1 + 4) = 2;
  while ( *(int *)((char *)&loc_32DCD + a1 + 2) >> 0x10 > 1 )
  {
    for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); ++i )
    {
      *(_WORD *)(a1 + 0x60 * (__int16)i + 0xDBB) = 0xFFFF;
    }
    sub_1FB34(a1);
    sub_201D8(a1);
  }
  JUMPOUT(0x1EFBA);
}
// 1EFFE: control flows out of bounds to 1EFBA

//----- (0001F038) --------------------------------------------------------
unsigned int __fastcall sub_1F038(int a1)
{
  int v2; // edi
  UBYTE *v3; // edx
  int i; // ecx
  int j; // eax
  int v6; // ecx
  int v7; // eax
  _DWORD *v8; // edi
  int k; // ecx
  unsigned __int8 v10; // bl
  int v11; // edx
  unsigned __int8 v12; // bh
  unsigned __int8 v13; // bh
  unsigned __int8 v14; // bh
  unsigned __int8 v15; // al
  UBYTE *v16; // eax
  UBYTE *v17; // edx
  unsigned int result; // eax
  char *v19; // ebp
  int v20; // ebx
  int v21; // edx
  char v22; // cl
  char *v23; // eax
  int v24; // edx
  char v25[1100]; // [esp+0h] [ebp-48Ch]
  int v26; // [esp+44Ch] [ebp-40h]
  UBYTE *v27; // [esp+450h] [ebp-3Ch]
  int v28; // [esp+454h] [ebp-38h]
  int v29; // [esp+458h] [ebp-34h]
  int v30; // [esp+45Ch] [ebp-30h]
  unsigned int v31; // [esp+460h] [ebp-2Ch]
  int v32; // [esp+464h] [ebp-28h]
  unsigned __int8 v33; // [esp+468h] [ebp-24h]
  unsigned __int8 v34; // [esp+46Ch] [ebp-20h]
  unsigned __int8 v35; // [esp+470h] [ebp-1Ch]

  if ( *(int *)((char *)&loc_32DCD + a1 + 2) >> 0x10 != 1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5BA);
  }
  v2 = (*(__int16 *)(a1 + 0x3335) - 1) * *(__int16 *)(a1 + 0x3335);
  v27 = buffer;
  if ( !buffer )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5C2);
  }
  v3 = v27;
  for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
  {
    for ( j = i + 1; j < *(__int16 *)(a1 + 0x3335); ++j )
    {
      v3 += 2;
      v3[0xFFFFFFFF] = j;
      v3[0xFFFFFFFE] = i;
    }
  }
  if ( v3 - v27 != v2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5D1);
  }
  memset(&byte_32DDB[a1], 0xFF, 0x2710u);
  v6 = 0;
  v30 = v2 >> 1;
  v7 = a1;
  while ( v6 < *(__int16 *)(a1 + 0x3335) )
  {
    byte_32DDA[++v6 + v7] = 0;
    v7 += 0x64;
    v25[v6 + 0x3E7] = 0;
  }
  v8 = (_DWORD *)(a1 + 0x3337);
  for ( k = 0; k < *(__int16 *)(a1 + 0x49C3); ++k )
  {
    v10 = *(_BYTE *)(*v8 + 4);
    v35 = *(_BYTE *)(v8[1] + 4);
    v11 = v35;
    byte_32DDB[0x64 * v10 + v35 + a1] = 1;
    byte_32DDB[0x64 * v11 + v10 + a1] = 1;
    v12 = v25[v10 + 0x3E8];
    v28 = v12;
    v25[v10 + 0x3E8] = v12 + 1;
    v13 = v25[v11 + 0x3E8];
    v25[0xA * v10 + v28] = v11;
    v28 = v13;
    v14 = v13 + 1;
    v25[v11 + 0x3E8] = v14;
    v15 = v25[v10 + 0x3E8];
    v25[0xA * v11 + v28] = v10;
    if ( v15 >= 0xAu || v14 >= 0xAu )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x5F3);
    }
    v8 = (_DWORD *)((char *)v8 + 0x27);
  }
  v16 = v27;
  v17 = &v27[2 * v30 - 2];
  if ( v17 >= v27 )
  {
    do
    {
      if ( byte_32DDB[0x64 * *v16 + v16[1] + a1] == 1 )
      {
        *v16 = *v17;
        v16[1] = v17[1];
        v17 += 0xFFFFFFFE;
        --v30;
      }
      else
      {
        v16 += 2;
      }
    }
    while ( v16 <= v17 );
  }
  result = v30;
  v26 = 2;
  if ( v30 > 0 )
  {
    v29 = 1;
    do
    {
      if ( *(__int16 *)(a1 + 0x3335) <= v26 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x610);
      }
      v19 = (char *)v27;
      result = (unsigned int)&v27[2 * v30 - 2];
      v31 = result;
      if ( (unsigned int)v27 <= result )
      {
        v32 = v29;
        do
        {
          v34 = *v19;
          v33 = v19[1];
          for ( result = 0; (__int16)result < (int)(unsigned __int8)v25[v34 + 0x3E8]; ++result )
          {
            v20 = v34;
            v21 = v33;
            if ( (unsigned __int8)byte_32DDB[0x64 * (unsigned __int8)v25[0xA * v34 + (__int16)result] + a1 + v33] == v32 )
            {
              v22 = v26;
              byte_32DDB[0x64 * v34 + v33 + a1] = v26;
              v23 = (char *)v31;
              byte_32DDB[0x64 * v21 + a1 + v20] = v22;
              *v19 = *v23;
              v19 += 0xFFFFFFFE;
              v24 = v30;
              v19[3] = *(_BYTE *)(v31 + 1);
              result = v31 - 2;
              v30 = v24 - 1;
              v31 -= 2;
              break;
            }
          }
          v19 += 2;
        }
        while ( (unsigned int)v19 <= v31 );
      }
      ++v29;
      ++v26;
    }
    while ( v30 > 0 );
  }
  return result;
}
// D8DA0: using guessed type UBYTE buffer[94816];

//----- (0001F404) --------------------------------------------------------
int __fastcall sub_1F404(int a1)
{
  char *v1; // ebp
  int v2; // eax
  _DWORD *v3; // edx
  double v4; // st7
  int v5; // ebx
  int v6; // edx
  int v7; // edx
  __int16 v8; // ax
  int v9; // ecx
  __int16 v10; // ax
  int v11; // edx
  double v12; // st7
  int v13; // edx
  int result; // eax
  float v15; // [esp+0h] [ebp-134h]
  int v16[21]; // [esp+4h] [ebp-130h] BYREF
  int v17[22]; // [esp+58h] [ebp-DCh] BYREF
  int v18; // [esp+B0h] [ebp-84h]
  int v19; // [esp+B4h] [ebp-80h]
  int v20[3]; // [esp+B8h] [ebp-7Ch] BYREF
  int v21; // [esp+C4h] [ebp-70h] BYREF
  int v22; // [esp+C8h] [ebp-6Ch]
  int v23; // [esp+CCh] [ebp-68h]
  int v24; // [esp+D0h] [ebp-64h]
  int *v25; // [esp+D4h] [ebp-60h]
  const char *v26; // [esp+D8h] [ebp-5Ch]
  int v27; // [esp+DCh] [ebp-58h]
  const char *v28; // [esp+E0h] [ebp-54h]
  int v29; // [esp+E4h] [ebp-50h]
  int v30; // [esp+E8h] [ebp-4Ch]
  float v31; // [esp+ECh] [ebp-48h]
  int v32; // [esp+F0h] [ebp-44h]
  int v33; // [esp+F4h] [ebp-40h]
  int v34; // [esp+F8h] [ebp-3Ch]
  int v35; // [esp+FCh] [ebp-38h]
  int v36; // [esp+100h] [ebp-34h]
  int v37; // [esp+104h] [ebp-30h]
  unsigned int v38; // [esp+108h] [ebp-2Ch]
  int v39; // [esp+10Ch] [ebp-28h]
  char *s; // [esp+110h] [ebp-24h]
  int v41; // [esp+114h] [ebp-20h]
  int v42; // [esp+118h] [ebp-1Ch]

  v41 = a1;
  v33 = a1 + 0xDB5;
  v27 = a1 + 0x49C5;
  v1 = (char *)&loc_18247 + a1;
  v32 = 0;
  v26 = (const char *)(a1 + 0xDD1);
  while ( 1 )
  {
    result = *(__int16 *)(v41 + 0x3335);
    if ( result <= v32 )
    {
      return result;
    }
    v34 = rand() % 5 + 1;
    if ( v34 > 5 )
    {
      v34 = 5;
    }
    v39 = 0xFFFFFFFF;
    v42 = 0;
    v2 = v41;
    while ( *(__int16 *)(v41 + 0xD88) > v42 )
    {
      if ( v33 == *(_DWORD *)(v2 + 0xD) )
      {
        v39 = v42;
        break;
      }
      v2 += 0x1EE;
      ++v42;
    }
    if ( v39 >= 0 && !v34 )
    {
      v34 = 1;
    }
    v35 = 0;
    if ( v39 >= 0 )
    {
      v35 = rand() % v34;
    }
    v3 = (_DWORD *)v33;
    *(_WORD *)(v33 + 0x5A) = v34;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v4 = (double)word_964FA[*v3];
    v37 = 0;
    v42 = 0;
    v31 = v4;
    v29 = 0x168 / v34;
    if ( v34 > 0 )
    {
      v28 = v26;
      v38 = 0;
      v36 = v33;
      v30 = 0x1EE * v39 + v41;
      s = v1 + 0x24;
      do
      {
        *(_DWORD *)(v36 + 0x46) = v1;
        LOWORD(v5) = rand() % 5;
        LOWORD(v6) = rand() % 0xB;
        if ( v39 >= 0 && v35 == v42 )
        {
          qmemcpy(v16, &unk_96548, sizeof(v16));
          qmemcpy(v17, &unk_9659C, 0x54u);
          v7 = *(unsigned __int8 *)(v30 + 7);
          v5 = v16[v7];
          v6 = v17[v7];
        }
        *((_WORD *)v1 + 0xD) = 0;
        *((_DWORD *)v1 + 4) = 0;
        v8 = v32;
        *(_DWORD *)(v1 + 0x5A) = 0;
        *((_WORD *)v1 + 6) = v8;
        v9 = v41;
        *((_WORD *)v1 + 7) = v42;
        v10 = sub_33AF0((int)v1, v5, v6, v27 + 4 * (*(int *)((char *)&loc_18241 + v9 + 2) >> 0x10));
        v11 = v41;
        *(_WORD *)((char *)&loc_18241 + v41 + 4) += v10;
        if ( *(int *)((char *)&loc_18241 + v11 + 2) >> 0x10 > 0x4E20 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x67B);
        }
        sprintf(s, "%s ", v28);
        sub_31E60(s, v42 + 1);
        v12 = ((double)word_964F0[v38 / 2] + v31) * flt_90C86 * flt_90C8A;
        v25 = v20;
        *(float *)&v24 = v12;
        v17[0x15] = v24;
        *(float *)&v18 = 0.0 * *(float *)&v24;
        v19 = v18;
        v20[0] = v24;
        v20[1] = v18;
        v20[2] = v18;
        v21 = v24;
        v22 = v18;
        v23 = v18;
        v15 = (float)v37;
        sub_532AC((float *)&v21, v15);
        sub_362C8((int)v1, &v21);
        if ( v39 >= 0 && v35 == v42 )
        {
          v1[0x57] = v39;
          *((_WORD *)v1 + 0x21) = 2;
          sub_34AE4((int)v1, 5u, 0xFFFFFFFF);
        }
        v1 += 0x7B;
        v36 += 4;
        v38 += 2;
        ++v42;
        s += 0x7B;
        v37 += v29;
      }
      while ( v42 < v34 );
    }
    v13 = v41;
    *(_WORD *)((char *)&loc_27281 + v41 + 2) += HIWORD(v34);
    if ( *(int *)((char *)&loc_27281 + v13) >= 0x1F4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x697);
    }
    ++v32;
    v26 += 0x60;
    v33 += 0x60;
  }
}
// 90C86: using guessed type float flt_90C86;
// 90C8A: using guessed type float flt_90C8A;
// 964F0: using guessed type __int16 word_964F0[];
// 964FA: using guessed type __int16 word_964FA[12];
// 1F404: using guessed type int var_130[21];

//----- (0001F91C) --------------------------------------------------------
int sub_1F91C()
{
  int result; // eax
  __int16 v1; // di
  int v2; // edx
  int v3; // eax
  int v4; // esi
  __int16 v5; // ax
  __int16 v6; // dx
  float *v7; // ebx
  __int16 v8; // dx
  int v9; // eax
  double v10; // st7
  int v11[3]; // [esp+14h] [ebp-48h] BYREF
  float v12; // [esp+20h] [ebp-3Ch]
  float v13; // [esp+24h] [ebp-38h]
  float v14; // [esp+28h] [ebp-34h]
  int *v15; // [esp+2Ch] [ebp-30h]
  int v16; // [esp+30h] [ebp-2Ch]
  int v17; // [esp+34h] [ebp-28h]
  int v18; // [esp+38h] [ebp-24h]
  int v19; // [esp+3Ch] [ebp-20h]
  __int16 v20; // [esp+40h] [ebp-1Ch]

  memset(&byte_32DDB[(_DWORD)dword_A2F6C], 0, 0x2710u);
  result = 0;
  if ( word_A62A1 > 0 )
  {
    do
    {
      byte_32DDB[(_DWORD)&dword_A2F6C[0x19 * (__int16)result] + (__int16)result] = 1;
      ++result;
    }
    while ( (__int16)result < *(__int16 *)((char *)&dword_A2F6C[0xCCD] + 1) );
  }
  v1 = *(_WORD *)((char *)&dword_A2F6C[0xCCD] + 1);
  LOWORD(v19) = 0;
  if ( v1 > 0 )
  {
    v17 = (int)&dword_A2F6C[0x36D] + 1;
    do
    {
      v2 = 0x60 * (__int16)v19 + v17;
      v3 = *(_DWORD *)v2;
      v16 = v2;
      if ( *(_WORD *)(v2 + 0x44) != word_9652E[v3] )
      {
        v4 = 0x1388;
        v5 = *(_WORD *)((char *)&dword_A2F6C[0xCCD] + 1);
        v6 = 0;
        v20 = 0xFFFF;
        v7 = (float *)(v16 + 8);
        if ( v5 > 0 )
        {
          do
          {
            if ( !byte_32DDB[(_DWORD)&dword_A2F6C[0x19 * (__int16)v19] + v6] )
            {
              v9 = v17 + 0x60 * v6;
              if ( *(_WORD *)(v9 + 0x44) != word_9652E[*(_DWORD *)v9] )
              {
                v15 = v11;
                v12 = 0.0;
                v13 = 0.0;
                v14 = 0.0;
                v12 = *v7 - *(float *)(v9 + 8);
                v13 = v7[1] - *(float *)(v9 + 0xC);
                v14 = v7[2] - *(float *)(v9 + 0x10);
                *(float *)v11 = v12;
                *(float *)&v11[1] = v13;
                *(float *)&v11[2] = v14;
                v10 = sqrt(v13 * v13 + v12 * v12 + v14 * v14);
                v18 = (int)v10;
                if ( v4 > (int)v10 )
                {
                  v4 = (int)v10;
                  v20 = v6;
                }
              }
            }
            ++v6;
          }
          while ( v6 < *(__int16 *)((char *)&dword_A2F6C[0xCCD] + 1) );
        }
        if ( v20 != 0xFFFFFFFF && !sub_1CF68(v16, 0x60 * v20 + v17) )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x6D0);
        }
      }
      result = v19 + 1;
      v8 = *(_WORD *)((char *)&dword_A2F6C[0xCCD] + 1);
      LOWORD(v19) = result;
    }
    while ( (__int16)result < v8 );
  }
  return result;
}
// 9652E: using guessed type __int16 word_9652E[];
// A2F6C: using guessed type int dword_A2F6C[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (0001FB34) --------------------------------------------------------
int __fastcall sub_1FB34(int a1)
{
  _WORD *v2; // eax
  __int16 i; // bx
  int v4; // eax
  __int16 v5; // dx
  char *v6; // ecx
  int v7; // ebx
  float *j; // edx
  float *v9; // eax
  double v10; // st7
  double v11; // st7
  double v12; // st7
  __int16 v13; // bx
  __int16 v14; // ax
  __int16 v15; // dx
  __int16 v16; // cx
  int result; // eax
  float v18; // [esp+0h] [ebp-58h] BYREF
  float v19; // [esp+4h] [ebp-54h]
  float v20; // [esp+8h] [ebp-50h]
  float v21; // [esp+Ch] [ebp-4Ch]
  float v22; // [esp+10h] [ebp-48h]
  float v23; // [esp+14h] [ebp-44h]
  float v24; // [esp+18h] [ebp-40h] BYREF
  float v25; // [esp+1Ch] [ebp-3Ch]
  float v26; // [esp+20h] [ebp-38h]
  float v27; // [esp+24h] [ebp-34h]
  float v28; // [esp+28h] [ebp-30h]
  float v29; // [esp+2Ch] [ebp-2Ch]
  float *v30; // [esp+30h] [ebp-28h]
  float *v31; // [esp+34h] [ebp-24h]
  int v32; // [esp+38h] [ebp-20h]
  int v33; // [esp+3Ch] [ebp-1Ch]

  v2 = (_WORD *)((char *)&off_30701 + a1);
  v2[0x1368] = 0;
  memset(v2, 0, 0x26D0u);
  for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
  {
    v4 = 0x60 * i;
    if ( *(__int16 *)(a1 + v4 + 0xDBB) == 0xFFFFFFFF )
    {
      sub_1FD18(a1, a1 + 0xDB5 + v4);
      ++*(_WORD *)((char *)&loc_32DCD + a1 + 4);
    }
  }
  *(_WORD *)((char *)&loc_32DD4 + a1 + 1) = 0;
  v5 = *(_WORD *)((char *)&loc_32DCD + a1 + 4);
  LOWORD(v33) = 0;
  if ( v5 > 0 )
  {
    do
    {
      v6 = (char *)&off_30701 + 0x19E * (__int16)v33 + a1;
      v7 = 0;
      for ( j = (float *)(v6 + 0x192); (__int16)v7 < *((__int16 *)v6 + 0xC8); ++v7 )
      {
        v9 = *(float **)&v6[4 * (__int16)v7];
        v30 = &v18;
        v21 = 0.0;
        v22 = 0.0;
        v23 = 0.0;
        v21 = *j + v9[2];
        v22 = *(float *)(v6 + 0x196) + v9[3];
        v10 = *(float *)(v6 + 0x19A) + v9[4];
        v18 = v21;
        v23 = v10;
        v19 = v22;
        v20 = v23;
        *j = v21;
        *(float *)(v6 + 0x196) = v19;
        *(float *)(v6 + 0x19A) = v20;
      }
      v11 = 1.0 / (double)*((__int16 *)v6 + 0xC8);
      v31 = &v24;
      v27 = 0.0;
      v28 = 0.0;
      v29 = 0.0;
      v27 = *j * v11;
      v28 = *(float *)(v6 + 0x196) * v11;
      v12 = v11 * *(float *)(v6 + 0x19A);
      v24 = v27;
      v29 = v12;
      v25 = v28;
      v26 = v29;
      *j = v27;
      *(float *)(v6 + 0x196) = v25;
      v13 = v33;
      *(float *)(v6 + 0x19A) = v26;
      ++v13;
      v14 = *((_WORD *)v6 + 0xC8);
      v15 = *(_WORD *)((char *)&loc_32DD4 + a1 + 1);
      LOWORD(v33) = v13;
      v16 = *(_WORD *)((char *)&loc_32DCD + a1 + 4);
      *(_WORD *)((char *)&loc_32DD4 + a1 + 1) = v14 + v15;
    }
    while ( v13 < v16 );
  }
  v32 = (int)((double)*(__int16 *)((char *)&loc_32DD4 + a1 + 1) / (double)*(__int16 *)((char *)&loc_32DCD + a1 + 4));
  result = v32;
  *(_WORD *)((char *)&loc_32DD4 + a1 + 1) = v32;
  return result;
}
// 30701: using guessed type void *off_30701;

//----- (0001FD18) --------------------------------------------------------
void __fastcall sub_1FD18(int a1, int a2)
{
  __int16 i; // bx
  int v5; // edx
  int v6; // edx

  *(_WORD *)(a2 + 6) = *(_WORD *)((char *)&loc_32DCD + a1 + 4);
  sub_2016C(a1, a2, HIWORD(*(_DWORD *)((char *)&loc_32DCD + a1 + 2)));
  for ( i = 0; i < *(__int16 *)(a2 + 0x44); ++i )
  {
    v5 = **(_DWORD **)(a2 + 4 * i + 0x2C);
    if ( *(__int16 *)(v5 + 6) == 0xFFFFFFFF )
    {
      sub_1FD18(a1, v5);
    }
    v6 = *(_DWORD *)(*(_DWORD *)(a2 + 4 * i + 0x2C) + 4);
    if ( *(__int16 *)(v6 + 6) == 0xFFFFFFFF )
    {
      sub_1FD18(a1, v6);
    }
  }
  JUMPOUT(0x1E706);
}
// 1FD43: control flows out of bounds to 1E706

//----- (0001FD90) --------------------------------------------------------
int __fastcall sub_1FD90(int a1, int a2, int a3)
{
  int v6; // eax
  __int16 v7; // bx
  int v8; // edx

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x71E);
  }
  v6 = 0;
  if ( word_A62A1 > 0 )
  {
    do
    {
      v7 = word_A62A1;
      v8 = (__int16)v6++;
      *(_BYTE *)(v8 + a2) = 0;
    }
    while ( (__int16)v6 < v7 );
  }
  return sub_1FDF0(a1, *(_DWORD *)(a1 + 0x1EE * a3 + 0xD), a2, a3);
}
// A62A1: using guessed type __int16 word_A62A1;

//----- (0001FDF0) --------------------------------------------------------
int __fastcall sub_1FDF0(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  _BYTE *v6; // ebp
  __int16 v7; // dx
  __int16 j; // bx
  int v9; // eax
  int v11; // [esp+4h] [ebp-24h]
  __int16 i; // [esp+14h] [ebp-14h]
  __int16 v15; // [esp+14h] [ebp-14h]
  char v16; // [esp+18h] [ebp-10h]

  v16 = 0;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    if ( *(_BYTE *)(0x1EE * a4 + a1 + i + 0x1C6) == 3 )
    {
      v16 |= 1 << i;
    }
  }
  v15 = 0;
  result = a2;
  if ( *(__int16 *)(a2 + 0x44) > 0 )
  {
    v11 = 1 << a4;
    do
    {
      v5 = *(_DWORD *)(a2 + 4 * v15 + 0x2C);
      result = *(__int16 *)(v5 + 0x21);
      if ( result != a4 )
      {
        if ( *(_DWORD *)v5 == a2 )
        {
          v6 = *(_BYTE **)(v5 + 4);
        }
        else
        {
          v6 = *(_BYTE **)v5;
        }
        if ( ((unsigned __int8)v11 & v6[0x17]) != 0 )
        {
          if ( (~v11 & ((unsigned __int8)(v6[0x15] & ~v16) | (unsigned __int8)(~v16 & v6[0x14])) & 0x7F) != 0 )
          {
            result = a3 + *(__int16 *)(a2 + 4);
            ++*(_BYTE *)result;
          }
          else
          {
            v7 = 0;
            for ( j = 0; j < 0x6B; ++j )
            {
              if ( v7 >= SHIWORD(dword_D35E5) )
              {
                break;
              }
              v9 = *(int *)((char *)&dword_CA245 + 0x162 * j) >> 0x10;
              if ( v9 != 0xFFFFFFFF )
              {
                ++v7;
                if ( v5 == *(int *)((char *)&dword_CA24A + 0x162 * j)
                  && v9 != a4
                  && *(_BYTE *)(0x1EE * a4 + a1 + v9 + 0x1C6) != 3 )
                {
                  break;
                }
              }
            }
            if ( v7 < SHIWORD(dword_D35E5) )
            {
              result = a3 + *(__int16 *)(a2 + 4);
              ++*(_BYTE *)result;
            }
            else
            {
              *(_WORD *)(v5 + 0x21) = a4;
              result = sub_1FDF0(a1, (int)v6, a3, a4);
            }
          }
        }
        else
        {
          result = a3 + *(__int16 *)(a2 + 4);
          ++*(_BYTE *)result;
        }
      }
      ++v15;
    }
    while ( v15 < *(__int16 *)(a2 + 0x44) );
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;
// CA245: using guessed type int dword_CA245;
// CA24A: using guessed type int dword_CA24A;
// D35E5: using guessed type int dword_D35E5;

//----- (0001FFE0) --------------------------------------------------------
int __fastcall sub_1FFE0(int a1, int a2)
{
  int result; // eax
  _BYTE *v4; // edi
  __int16 v5; // dx
  __int16 k; // bx
  int v7; // esi
  __int16 i; // [esp+4h] [ebp-1Ch]
  __int16 j; // [esp+4h] [ebp-1Ch]
  char v11; // [esp+8h] [ebp-18h]

  v11 = 0;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    if ( byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + i] == 3 )
    {
      v11 |= 1 << i;
    }
  }
  result = a2;
  for ( j = 0; j < *(__int16 *)(a2 + 0x44); ++j )
  {
    result = a2 + 4 * j;
    v7 = *(_DWORD *)(result + 0x2C);
    if ( !*(_WORD *)(v7 + 0x21) )
    {
      v4 = *(_DWORD *)v7 == a2 ? *(_BYTE **)(v7 + 4) : *(_BYTE **)v7;
      result = (unsigned __int8)v4[0x17];
      if ( ((1 << byte_104BEA) & result) != 0 )
      {
        result = ((unsigned __int8)(v4[0x15] & ~v11) | (unsigned __int8)(~v11 & v4[0x14])) & 0x7F;
        if ( (~(1 << byte_104BEA) & result) == 0 )
        {
          v5 = 0;
          for ( k = 0; ; ++k )
          {
            result = k;
            if ( k >= 0x6B )
            {
              break;
            }
            if ( v5 >= SHIWORD(dword_D35E5) )
            {
              break;
            }
            result = *(int *)((char *)&dword_CA245 + 0x162 * k) >> 0x10;
            if ( result != 0xFFFFFFFF )
            {
              ++v5;
              if ( v7 == *(int *)((char *)&dword_CA24A + 0x162 * k)
                && result != (unsigned __int8)byte_104BEA
                && byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + result] != 3 )
              {
                break;
              }
            }
          }
          if ( v5 >= SHIWORD(dword_D35E5) )
          {
            *(_WORD *)(v7 + 0x21) = 1;
            ++*(_DWORD *)(a1 + 0x354EB);
            result = sub_1FFE0(a1, (int)v4);
          }
        }
      }
    }
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;
// CA245: using guessed type int dword_CA245;
// CA24A: using guessed type int dword_CA24A;
// D35E5: using guessed type int dword_D35E5;

//----- (0002016C) --------------------------------------------------------
int __fastcall sub_2016C(int a1, int a2, __int16 a3)
{
  int result; // eax
  char *v5; // ecx

  if ( a3 >= 0x18 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7BB);
  }
  result = 0x19E * a3;
  v5 = (char *)&off_30701 + a1 + result;
  if ( *((__int16 *)v5 + 0xC8) >= 0x64 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7BE);
  }
  *(_DWORD *)&v5[4 * (__int16)(*((_WORD *)v5 + 0xC8))++] = a2;
  return result;
}
// 30701: using guessed type void *off_30701;

//----- (000201D8) --------------------------------------------------------
int __fastcall sub_201D8(int a1)
{
  int v1; // ecx
  int result; // eax
  __int16 v3; // si
  int v4; // esi
  __int16 v5; // dx
  __int16 v6; // ax
  int v7; // edi
  int v8; // eax
  int v9; // ebx
  __int16 i; // dx
  int v11; // ebx
  double v12; // st7
  __int16 j; // bx
  int v14; // edx
  double v15; // st7
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // edx
  float v20; // [esp+8h] [ebp-88h]
  int v21; // [esp+Ch] [ebp-84h]
  int v22; // [esp+10h] [ebp-80h]
  float v23; // [esp+14h] [ebp-7Ch]
  int v24; // [esp+18h] [ebp-78h]
  int v25; // [esp+1Ch] [ebp-74h]
  int v26[3]; // [esp+20h] [ebp-70h] BYREF
  int v27[3]; // [esp+2Ch] [ebp-64h] BYREF
  float v28; // [esp+38h] [ebp-58h]
  int v29; // [esp+3Ch] [ebp-54h]
  int v30; // [esp+40h] [ebp-50h]
  int v31; // [esp+44h] [ebp-4Ch]
  int *v32; // [esp+48h] [ebp-48h]
  int *v33; // [esp+4Ch] [ebp-44h]
  int v34; // [esp+50h] [ebp-40h]
  int assert; // [esp+54h] [ebp-3Ch]
  int v36; // [esp+58h] [ebp-38h]
  int v37; // [esp+5Ch] [ebp-34h]
  int v38; // [esp+60h] [ebp-30h]
  int v39; // [esp+64h] [ebp-2Ch]
  int v40; // [esp+68h] [ebp-28h]
  int v41; // [esp+6Ch] [ebp-24h]
  __int16 v42; // [esp+70h] [ebp-20h]
  int v43; // [esp+74h] [ebp-1Ch]

  v38 = a1;
  v1 = 0;
  v28 = 0.0;
  v29 = 0;
  v30 = 0;
  if ( !*(_WORD *)((char *)&loc_32DCD + a1 + 4) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7DD);
  }
  result = *(_DWORD *)((char *)&loc_32DCD + SHIWORD(v38) + 2);
  if ( result != 1 )
  {
    result = v38;
    v3 = *(_WORD *)((char *)&loc_32DCD + v38 + 4);
    LOWORD(v43) = 0;
    if ( v3 > 0 )
    {
      v34 = (int)&off_30701 + v38;
      do
      {
        v4 = 0x19E * (__int16)v43 + v34;
        v5 = 0;
        v36 = (int)&loc_18696 + 9;
        v37 = (int)&loc_18696 + 9;
        assert = 0;
        v6 = *(_WORD *)(v4 + 0x190);
        v42 = 0;
        v7 = 0;
        if ( v6 > 0 )
        {
          do
          {
            v8 = *(_DWORD *)(v4 + 4 * v5);
            v9 = *(_DWORD *)v8;
            v31 = *(int *)((char *)&unk_9652C + v9 * 2) >> 0x10;
            v41 = *(__int16 *)(v8 + 0x44);
            v31 -= v41;
            v41 = v42;
            if ( v31 > v42 )
            {
              v7 = v8;
              v42 = word_9652E[v9] - *(_WORD *)(v8 + 0x44);
            }
            ++v5;
          }
          while ( v5 < *(__int16 *)(v4 + 0x190) );
        }
        if ( !v7 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x7FF);
        }
        for ( i = 0; i < *(__int16 *)((char *)&loc_32DCD + v38 + 4); ++i )
        {
          if ( i != (_WORD)v43 )
          {
            v11 = v34 + 0x19E * i;
            v33 = v26;
            v20 = *(float *)(v7 + 8) - *(float *)(v11 + 0x192);
            *(float *)&v21 = *(float *)(v7 + 0xC) - *(float *)(v11 + 0x196);
            *(float *)&v22 = *(float *)(v7 + 0x10) - *(float *)(v11 + 0x19A);
            *(float *)v26 = v20;
            v26[1] = v21;
            v26[2] = v22;
            v28 = v20;
            v29 = v21;
            v30 = v22;
            v12 = sqrt(*(float *)&v21 * *(float *)&v21 + v20 * v20 + *(float *)&v22 * *(float *)&v22);
            v40 = (int)v12;
            if ( (int)v12 < v36 )
            {
              v1 = v11;
              v36 = (int)v12;
            }
          }
        }
        if ( !v1 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x813);
        }
        for ( j = 0; j < *(__int16 *)(v1 + 0x190); ++j )
        {
          v14 = *(_DWORD *)(v1 + 4 * j);
          if ( !byte_32DDB[0x64 * *(__int16 *)(v7 + 4) + v38 + *(__int16 *)(v14 + 4)] )
          {
            v32 = v27;
            v23 = *(float *)(v7 + 8) - *(float *)(v14 + 8);
            *(float *)&v24 = *(float *)(v7 + 0xC) - *(float *)(v14 + 0xC);
            *(float *)&v25 = *(float *)(v7 + 0x10) - *(float *)(v14 + 0x10);
            *(float *)v27 = v23;
            v27[1] = v24;
            v27[2] = v25;
            v28 = v23;
            v29 = v24;
            v30 = v25;
            v15 = sqrt(*(float *)&v24 * *(float *)&v24 + v23 * v23 + *(float *)&v25 * *(float *)&v25);
            v41 = *(int *)((char *)&unk_9652C + 2 * *(_DWORD *)v14) >> 0x10;
            v16 = *(__int16 *)(v14 + 0x44);
            v39 = (int)v15;
            if ( v41 != v16 && v39 < v37 )
            {
              assert = v14;
              v37 = v39;
            }
          }
        }
        if ( !assert )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x82C);
        }
        v17 = sub_1CF68(v7, assert);
        if ( !v17 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x832);
        }
        *(_BYTE *)(v17 + 0x23) |= 1u;
        v18 = assert;
        *(_BYTE *)(v7 + 0x18) |= 1u;
        *(_BYTE *)(v18 + 0x18) |= 1u;
        v19 = v43 + 1;
        LOWORD(v43) = v43 + 1;
        result = v19;
      }
      while ( (__int16)v19 < *(__int16 *)((char *)&loc_32DCD + v38 + 4) );
    }
  }
  return result;
}
// 30701: using guessed type void *off_30701;
// 9652E: using guessed type __int16 word_9652E[];

//----- (000205A0) --------------------------------------------------------
int __fastcall sub_205A0(int a1, int a2, int a3)
{
  int v5; // ebx
  int v6; // edx

  if ( !a2 || !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x83F);
  }
  v5 = *(__int16 *)(a1 + 0x49C3);
  if ( v5 == 0x94 || byte_32DDB[0x64 * *(__int16 *)(a2 + 4) + a1 + *(__int16 *)(a3 + 4)] )
  {
    return 0;
  }
  v6 = 0x27 * v5 + a1 + 0x3337;
  *(_BYTE *)(v6 + 0x20) = 0;
  *(_DWORD *)v6 = a2;
  *(_DWORD *)(v6 + 4) = a3;
  ++*(_WORD *)(a1 + 0x49C3);
  byte_32DDB[0x64 * *(__int16 *)(a2 + 4) + a1 + *(__int16 *)(a3 + 4)] = 1;
  byte_32DDB[0x64 * *(__int16 *)(a3 + 4) + a1 + *(__int16 *)(a2 + 4)] = 1;
  return v6;
}

//----- (00020684) --------------------------------------------------------
char *__fastcall sub_20684(int a1, __int16 a2)
{
  char *v4; // ebx
  __int16 i; // dx
  char *result; // eax

  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xD88) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x863);
  }
  if ( *(__int16 *)(a1 + 0x3067B) >= 0x6B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x864);
  }
  v4 = (char *)&loc_27281 + a1 + 4;
  for ( i = 0; ; ++i )
  {
    if ( i >= 0x6B )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0x873);
    }
    if ( *((__int16 *)v4 + 0x2B) == 0xFFFFFFFF )
    {
      break;
    }
    v4 += 0x162;
  }
  sub_48C5C((int)v4, 0);
  *((_WORD *)v4 + 0x2B) = a2;
  result = v4;
  ++*(_WORD *)((char *)sub_3067B + a1);
  return result;
}

//----- (00020720) --------------------------------------------------------
__int16 __fastcall sub_20720(int a1, int a2)
{
  __int16 result; // ax

  if ( *(__int16 *)(a2 + 0x56) < 0 || (result = *(_WORD *)(a2 + 0x56), result >= *(__int16 *)(a1 + 0xD88)) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x87E);
  }
  if ( !*(_BYTE *)(a2 + 0x58) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x87F);
  }
  *(_WORD *)(a2 + 0x56) = 0xFFFF;
  *(_BYTE *)(a2 + 0x58) = 0;
  *(_BYTE *)(a2 + 0x34) = 0;
  --*(_WORD *)((char *)sub_3067B + a1);
  if ( *(__int16 *)(a1 + 0x3067B) < 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x887);
  }
  return result;
}

//----- (000207A0) --------------------------------------------------------
char __fastcall sub_207A0(int a1)
{
  int i; // eax
  int v3; // ebp
  int v4; // edx
  int v5; // edx
  int v6; // ebx
  int v7; // edx
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // ecx
  int j; // eax
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  int k; // eax
  char v18; // bl
  int v19; // edx
  int v20; // eax
  char v21; // ch
  double v22; // st6
  int v24; // [esp+8h] [ebp-24h]
  size_t v25; // [esp+8h] [ebp-24h]
  int v26; // [esp+8h] [ebp-24h]
  unsigned __int8 v27; // [esp+Ch] [ebp-20h]
  char v28; // [esp+10h] [ebp-1Ch]

  v28 = 0;
  i = 0x1EE * (unsigned __int8)byte_104BEA;
  v3 = i + a1 + 6;
  if ( *(_DWORD *)(v3 + 3) == 0xFFFFFFFF )
  {
    v28 = 1;
  }
  if ( !v28 )
  {
    v4 = a1;
    i = 0;
    v28 = 2;
    while ( i < *(__int16 *)(a1 + 0xD88) )
    {
      if ( i != (unsigned __int8)byte_104BEA && !*(_DWORD *)(v4 + 9) )
      {
        v28 = 0;
        break;
      }
      v4 += 0x1EE;
      ++i;
    }
  }
  if ( !v28 )
  {
    v5 = a1;
    i = 0;
    v28 = 3;
    while ( i < *(__int16 *)(a1 + 0xD88) )
    {
      if ( (*(_BYTE *)(*(_DWORD *)(v5 + 0xD) + 0x14) & 0x7F) != 1 << byte_104BEA )
      {
        LOBYTE(i) = 0;
        v28 = 0;
        break;
      }
      v5 += 0x1EE;
      ++i;
    }
  }
  if ( !v28 )
  {
    v27 = 0;
    v6 = v3;
    v28 = 4;
    i = 0;
    v7 = a1;
    while ( i < *(__int16 *)(a1 + 0xD88) )
    {
      if ( !*(_DWORD *)(v7 + 9) )
      {
        v27 |= 1 << i;
      }
      if ( i != (unsigned __int8)byte_104BEA && !*(_DWORD *)(v7 + 9) && *(_BYTE *)(v6 + 0x1C0) != 3 )
      {
        v28 = 0;
        break;
      }
      v7 += 0x1EE;
      ++v6;
      ++i;
    }
    if ( v28 == 4 )
    {
      v8 = a1;
      for ( i = 0; i < *(__int16 *)(a1 + 0x3335); ++i )
      {
        if ( (v27 & *(_BYTE *)(v8 + 0xDCC)) == 0 )
        {
          v28 = 0;
          break;
        }
        v8 += 0x60;
      }
    }
  }
  if ( !v28 )
  {
    i = 2 * *(__int16 *)(a1 + 0x3335) / 3 + 1;
    if ( i <= *(_DWORD *)(a1 + 0x354EB) )
    {
      v28 = 5;
    }
  }
  if ( v28 )
  {
    v9 = 0;
    v10 = 0;
    v24 = 0;
    while ( v10 < (unsigned __int16)word_105258 )
    {
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + v9) >> 0x18)) != 0 )
      {
        ++v24;
      }
      v9 += 0x4B;
      ++v10;
    }
    v11 = a1;
    for ( j = 0; j < *(int *)((char *)&loc_27281 + a1) >> 0x10; ++j )
    {
      if ( (_BYTE)byte_104BEA == *((_BYTE *)&loc_1829D + v11 + 1) )
      {
        v24 += 2;
      }
      v11 += 0x7B;
    }
    v13 = 0;
    v25 = sub_40224((unsigned __int8 *)v3, 0, 0) + v24;
    v14 = a1;
    while ( v13 < *(__int16 *)(a1 + 0x3335) )
    {
      if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(v14 + 0xDCC)) != 0 )
      {
        ++v25;
      }
      v14 += 0x60;
      ++v13;
    }
    v15 = a1;
    v16 = v3;
    for ( k = 0; k < *(__int16 *)(a1 + 0xD88); ++k )
    {
      if ( k != (unsigned __int8)byte_104BEA && *(_DWORD *)(v15 + 9) != 0xFFFFFFFF )
      {
        v18 = *(_BYTE *)(v16 + 0x1C0);
        if ( v18 == 3 )
        {
          v25 += 0xF;
        }
        else if ( v18 == 2 )
        {
          v25 -= 0xA;
        }
      }
      v15 += 0x1EE;
      ++v16;
    }
    if ( v28 == 4 )
    {
      v25 += 0x32;
    }
    v19 = 0x64 - 0x4B * *(_DWORD *)a1 / 0xFA0;
    v20 = v19;
    if ( v19 >= 0x19 )
    {
      if ( v19 > 0x64 )
      {
        v20 = 0x64;
      }
    }
    else
    {
      v20 = 0x19;
    }
    v21 = *(_BYTE *)(a1 + 0xDB4);
    v26 = (int)(v20 * v25) / 0x64;
    if ( v21 == 1 )
    {
      v22 = (double)v26 * dbl_90D76;
    }
    else
    {
      if ( v21 != 2 )
      {
LABEL_71:
        if ( v26 < 0 )
        {
          v26 = 0;
        }
        byte_30700[a1] = v28;
        *(_DWORD *)(a1 + 0x306FC) = 0x64 * v26 / 0x258;
        *(_WORD *)&V_Type3_stru_10AE70.z2[0x14A] = 0;
        LOBYTE(i) = sub_56B60((int)&V_Type3_stru_10AE70, 1, 9, 1);
        return i;
      }
      v22 = (double)v26 * dbl_90D6E;
    }
    v26 = (int)v22;
    goto LABEL_71;
  }
  return i;
}
// 90D6E: using guessed type double dbl_90D6E;
// 90D76: using guessed type double dbl_90D76;
// 10529F: using guessed type int dword_10529F;

//----- (00020B3C) --------------------------------------------------------
int __fastcall sub_20B3C(int a1)
{
  int v2; // esi
  int i; // eax
  __int16 j; // di
  int v5; // ecx
  __int16 k; // ax
  int v7; // edx
  int v9[107]; // [esp+0h] [ebp-1CCh] BYREF
  unsigned __int8 v10; // [esp+1ACh] [ebp-20h]
  unsigned __int8 v11; // [esp+1B0h] [ebp-1Ch]

  v11 = 1 << byte_104BEA;
  v2 = a1 + 0xDB5;
  v10 = sub_43374((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], 0xFFFFFFFF);
  if ( !*(_WORD *)(a1 + 4) )
  {
    for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); ++i )
    {
      byte_D8460[(__int16)i] &= ~1u;
    }
  }
  for ( j = 0; j < *(__int16 *)(a1 + 0x3335); v2 += 0x60 )
  {
    if ( (byte_D8460[j] & 1) == 0 )
    {
      byte_D8460[j] |= 1u;
      if ( (v11 & *(_BYTE *)(v2 + 0x15)) != 0 && (v10 & *(_BYTE *)(v2 + 0x15)) != 0 )
      {
        v5 = sub_1D794((__int16 *)v2, v9);
        for ( k = 0; k < v5; ++k )
        {
          v7 = *(__int16 *)(v9[k] + 0x56);
          if ( (v7 == (unsigned __int8)byte_104BEA || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v7] == 2)
            && *(int *)(v9[k] + 0x88) > 0 )
          {
            ++*(_WORD *)(a1 + 4);
            return v2;
          }
        }
      }
    }
    ++j;
  }
  return 0;
}
// 20B3C: using guessed type int var_1CC[107];

//----- (00020C94) --------------------------------------------------------
char __fastcall sub_20C94(int a1, int a2, int a3, int a4)
{
  __int16 v5; // cx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  char *v11; // esi
  int v12; // edx
  int v13; // esi
  __int16 *v14; // esi
  int v15; // ebx
  __int16 v16; // dx
  __int16 i; // cx
  __int16 v18; // dx
  int v19; // eax
  int v20; // edx
  int j; // eax
  int v22; // eax
  char v23; // ch
  int v25; // [esp-10h] [ebp-1E8h]
  int v26; // [esp-Ch] [ebp-1E4h]
  int v27; // [esp-8h] [ebp-1E0h]
  int v28; // [esp-4h] [ebp-1DCh]
  int v29[107]; // [esp+0h] [ebp-1D8h] BYREF
  FILE *fp; // [esp+1ACh] [ebp-2Ch]
  const char *v31; // [esp+1B0h] [ebp-28h]
  const char *v32; // [esp+1B4h] [ebp-24h]
  const char *v33; // [esp+1B8h] [ebp-20h]
  int v34; // [esp+1BCh] [ebp-1Ch]

  if ( dword_A0D00 == 0xFFFFFFFF && *(int *)a1 >= 0x1388 )
  {
    v5 = rand() % 0x15;
    v6 = rand() % 5 + 3;
    v7 = rand();
    sub_1E10C(a1, v7 % 0x4C + 0x19, v6, v5);
    sub_1F038(a1);
    sub_1F404(a1);
    sub_1EEA4(a1);
    v8 = rand();
    sub_1EE08(a1, v8 % 6);
    *(_DWORD *)a1 = 0;
    v9 = sub_56E18((int)&V_Type3_stru_10AE70, "RACECONTROLS", 1, 0);
    a4 = v9;
    if ( !v9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0x9B7);
    }
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v9 + 0xA7) + 0xC))(v9, 0);
  }
  *(_WORD *)(a1 + 4) = 0;
  memset(byte_D8460, 0, sizeof(byte_D8460));
  sub_21170(a1);
  sub_21314(a1);
  v10 = 0;
  sub_466FC((unsigned int)&word_105258);
  v11 = (char *)&loc_18247 + a1;
  while ( v10 < *(int *)((char *)&loc_27281 + a1) >> 0x10 )
  {
    sub_352E0((int)v11);
    ++v10;
    v11 += 0x7B;
  }
  sub_2106C(a1);
  v12 = 0;
  v13 = a1 + 6;
  while ( v12 < *(__int16 *)(a1 + 0xD88) )
  {
    if ( v12 != (unsigned __int8)byte_104BEA )
    {
      sub_3B220(v13, v12, 0x64, a4);
    }
    v13 += 0x1EE;
    ++v12;
  }
  sub_3B220((int)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], (unsigned __int8)byte_104BEA, 0x64, a4);
  if ( dword_A0CFC == 0xFFFFFFFF )
  {
    v14 = word_A3D21;
    fp = fopen("numships.dbg", "at");
    v34 = 0;
    if ( word_A62A1 > 0 )
    {
      v31 = (const char *)&word_A3D21[0xE];
      do
      {
        v15 = sub_1D794(v14, v29);
        v16 = 0;
        if ( SHIWORD(dword_A3CF2) > 0 )
        {
          v33 = v31;
          do
          {
            if ( ((1 << v16) & *((unsigned __int8 *)v14 + 0x15)) != 0 )
            {
              for ( i = 0; i < v15 && v16 != *(_WORD *)(v29[i] + 0x56); ++i )
              {
                ;
              }
              if ( i >= v15 )
              {
                v27 = *((unsigned __int8 *)v14 + 0x15);
                ++word_D845C;
                fprintf(fp, "T%04d: %s flags (%d) show R%d ship, but none found.\n", *(_DWORD *)a1 + 1, v33, v27, v16);
              }
            }
            ++v16;
          }
          while ( v16 < SHIWORD(dword_A3CF2) );
        }
        v18 = 0;
        v32 = v31;
        while ( v18 < v15 )
        {
          v19 = v29[v18];
          if ( *(_BYTE *)(v19 + 0x58) != 1 && ((1 << *(_WORD *)(v19 + 0x56)) & *((unsigned __int8 *)v14 + 0x15)) == 0 )
          {
            v28 = *((unsigned __int8 *)v14 + 0x15);
            v26 = *(__int16 *)(v19 + 0x56);
            v25 = *(_DWORD *)a1 + 1;
            ++word_D845C;
            fprintf(fp, "T%04d: R%d ship exists at %s, flags (%d) indicate otherwise.\n", v25, v26, v32, v28);
          }
          ++v18;
        }
        v14 += 0x30;
        v31 += 0x60;
        ++v34;
      }
      while ( (__int16)v34 < word_A62A1 );
    }
    fclose(fp);
  }
  v20 = a1 + 0x3337;
  for ( j = 0; (__int16)j < word_A792F; v20 += 0x27 )
  {
    *(_WORD *)(v20 + 0x21) = 0;
    ++j;
  }
  v22 = 0x1EE * (unsigned __int8)byte_104BEA;
  if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*(int *)((char *)&dword_A2F79 + v22) + 0x14)) != 0 )
  {
    *(_DWORD *)(a1 + 0x354EB) = 1;
    LOBYTE(v22) = sub_1FFE0(a1, *(int *)((char *)&dword_A2F79 + v22));
  }
  else
  {
    *(_DWORD *)(a1 + 0x354EB) = 0;
  }
  v23 = byte_30700[a1];
  ++*(_DWORD *)a1;
  if ( !v23 && !dword_A0D00 )
  {
    LOBYTE(v22) = sub_207A0(a1);
  }
  return v22;
}
// A0CFC: using guessed type int dword_A0CFC;
// A0D00: using guessed type int dword_A0D00;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// A792F: using guessed type __int16 word_A792F;
// D845C: using guessed type __int16 word_D845C;
// 20C94: using guessed type int var_1D8[107];

//----- (0002106C) --------------------------------------------------------
int __fastcall sub_2106C(int result)
{
  int v1; // edi
  __int16 i; // si
  int v3; // edx
  __int16 j; // si
  __int16 v5; // bx
  __int16 k; // ax
  size_t v7; // [esp+0h] [ebp-20h] BYREF
  __int16 v8; // [esp+4h] [ebp-1Ch]

  v1 = result;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    v3 = 6 * i;
    v7 = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * i], 0, &v7);
    *(_WORD *)(v3 + v1 + 0xD8C) = v7;
    result = sub_402E0(&byte_A2F72[0x1EE * i]);
    *(_WORD *)(v3 + v1 + 0xD8E) = result;
  }
  for ( j = 0; j < SHIWORD(dword_A3CF2); ++j )
  {
    v8 = *(_WORD *)(v1 + 6 * j + 0xD8E) + *(_WORD *)(v1 + 6 * j + 0xD8C);
    v5 = 0;
    for ( k = 0; k < SHIWORD(dword_A3CF2); ++k )
    {
      if ( j != k && *(__int16 *)(6 * k + v1 + 0xD8C) + *(__int16 *)(6 * k + v1 + 0xD8E) > v8 )
      {
        ++v5;
      }
    }
    result = 6 * j;
    *(_WORD *)(v1 + result + 0xD8A) = v5;
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;

//----- (00021170) --------------------------------------------------------
unsigned __int8 __fastcall sub_21170(int a1)
{
  int v2; // esi
  unsigned __int8 result; // al
  int i; // ecx
  unsigned __int8 v5; // [esp+0h] [ebp-18h]

  v2 = a1 + 0xDB5;
  result = 1 << byte_104BEA;
  v5 = 1 << byte_104BEA;
  for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); v2 += 0x60 )
  {
    result = *(_BYTE *)(v2 + 0x14) | *(_BYTE *)(v2 + 0x15);
    *(_DWORD *)(v2 + 0x5C) = 0;
    if ( (result & v5) == 0 )
    {
      if ( result )
      {
        result = sub_211EC(a1, v2, 0);
      }
      *(_DWORD *)(v2 + 0x5C) = 0xFFFFFFFF;
    }
    ++i;
  }
  return result;
}

//----- (000211EC) --------------------------------------------------------
int __fastcall sub_211EC(int a1, int a2, int a3)
{
  __int16 v6; // cx
  __int16 v7; // ax
  int v8; // ebx
  int result; // eax
  int v10; // ebp
  int v11; // edi
  __int16 i; // cx
  __int16 v13[8]; // [esp+2h] [ebp-2Ch]
  unsigned __int8 v14; // [esp+12h] [ebp-1Ch] BYREF
  int v15; // [esp+13h] [ebp-1Bh]
  int v16; // [esp+1Ah] [ebp-14h]

  if ( dword_A0D00 == 0xFFFFFFFF )
  {
    a3 = dword_A0D00;
  }
  v6 = *(_WORD *)(a1 + 0xD88);
  v7 = 0;
  LOWORD(v16) = 0;
  if ( v6 > 0 )
  {
    do
    {
      if ( a3 || (a3 = 0, v7 != (unsigned __int8)byte_104BEA) )
      {
        if ( ((unsigned __int8)(*(_BYTE *)(a2 + 0x15) | *(_BYTE *)(a2 + 0x14)) & (unsigned __int8)(1 << v7)) != 0 )
        {
          v8 = (__int16)v16;
          LOWORD(v16) = v16 + 1;
          v13[v8] = v7;
        }
      }
      ++v7;
    }
    while ( v7 < *(__int16 *)(a1 + 0xD88) );
  }
  result = (__int16)v16;
  if ( (_WORD)v16 )
  {
    v10 = a1 + 6;
    do
    {
      result = v16;
      v11 = 0;
      for ( i = 0; i < (__int16)v16; ++i )
      {
        v14 = 0;
        result = sub_406C4((unsigned __int8 *)(v10 + 0x1EE * v13[i]), (__int16 *)a2, (int)&v14);
        v11 |= result;
        BYTE1(result) = v14;
        if ( v14 )
        {
          if ( v14 < 2u )
          {
            goto LABEL_24;
          }
          if ( v14 <= 2u )
          {
            result = sub_3676C(v15, 1);
          }
          else
          {
            if ( v14 != 3 )
            {
LABEL_24:
              Q_AssertLogBreakExit_sub_261A8(0, "..\\cosmos.cpp", 0xAE2);
            }
            result = sub_49B3C(v15, 1);
          }
        }
      }
    }
    while ( v11 );
  }
  return result;
}
// A0D00: using guessed type int dword_A0D00;
// 211EC: using guessed type __int16 var_2C[8];

//----- (00021314) --------------------------------------------------------
void __fastcall sub_21314(int a1)
{
  int v2; // ecx
  int i; // edi

  v2 = a1 + 0xDB5;
  for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x3335); v2 += 0x60 )
  {
    if ( *(_DWORD *)(v2 + 0x5C) != 0xFFFFFFFF )
    {
      if ( *(unsigned __int8 *)(v2 + 0x14) | *(unsigned __int8 *)(v2 + 0x15) )
      {
        sub_211EC(a1, v2, 0xFFFFFFFF);
      }
      *(_DWORD *)(v2 + 0x5C) = 0xFFFFFFFF;
    }
    ++i;
  }
  JUMPOUT(0x211E4);
}
// 2132D: control flows out of bounds to 211E4

//----- (00021374) --------------------------------------------------------
int __fastcall sub_21374(int a1, unsigned int count)
{
  __int16 v3; // cx
  int v4; // esi
  __int16 v5; // cx
  char *v6; // esi
  __int16 v7; // si
  __int16 v8; // cx
  char *v9; // edi
  int v10; // eax
  __int16 v11; // cx
  int v12; // esi
  __int16 v13; // cx
  int v14; // esi
  int v15; // edx
  __int16 v16; // si
  int i; // eax
  __int16 v18; // di
  __int16 v19; // bx
  int result; // eax
  __int16 v21; // cx
  int v22; // esi
  int v23[104]; // [esp+0h] [ebp-24Ch] BYREF
  int v24; // [esp+1A0h] [ebp-ACh] BYREF
  int v25; // [esp+1A4h] [ebp-A8h]
  int v26; // [esp+1A8h] [ebp-A4h]
  int v27; // [esp+1ACh] [ebp-A0h]
  int v28; // [esp+1B0h] [ebp-9Ch]
  int v29; // [esp+1B4h] [ebp-98h]
  int v30; // [esp+1B8h] [ebp-94h]
  int v31; // [esp+1BCh] [ebp-90h]
  char v32; // [esp+1C0h] [ebp-8Ch]
  __int16 v33; // [esp+1C1h] [ebp-8Bh]
  int v34; // [esp+1C3h] [ebp-89h]
  int v35[8]; // [esp+1C8h] [ebp-84h] BYREF
  int v36; // [esp+1E8h] [ebp-64h]
  int v37; // [esp+1ECh] [ebp-60h] BYREF
  int v38; // [esp+1F0h] [ebp-5Ch] BYREF
  int v39; // [esp+1F4h] [ebp-58h] BYREF
  int v40; // [esp+1F8h] [ebp-54h] BYREF
  int v41; // [esp+1FCh] [ebp-50h] BYREF
  int v42; // [esp+200h] [ebp-4Ch] BYREF
  int v43; // [esp+204h] [ebp-48h] BYREF
  int v44; // [esp+208h] [ebp-44h] BYREF
  int v45; // [esp+20Ch] [ebp-40h] BYREF
  int v46; // [esp+210h] [ebp-3Ch] BYREF
  int v47; // [esp+214h] [ebp-38h] BYREF
  int v48; // [esp+218h] [ebp-34h] BYREF
  int v49; // [esp+21Ch] [ebp-30h] BYREF
  int v50; // [esp+220h] [ebp-2Ch] BYREF
  int v51; // [esp+224h] [ebp-28h] BYREF
  int v52; // [esp+228h] [ebp-24h] BYREF
  int v53; // [esp+22Ch] [ebp-20h] BYREF
  int v54; // [esp+230h] [ebp-1Ch]
  int v55; // [esp+234h] [ebp-18h]

  v36 = a1;
  v35[0] = 0x1D72;
  v35[1] = 0x60;
  v35[2] = 0x7B;
  v35[3] = 0x1EE;
  v35[5] = 0x19E;
  v35[6] = 0xD;
  v35[7] = 0x354EF;
  v35[4] = 0x27;
  sub_1C098(count, (int)v35, 0x20u);
  v37 = *(_DWORD *)v36;
  sub_1C098(count, (int)&v37, 4u);
  v38 = *(__int16 *)(*(_DWORD *)(v36 + 0x306F4) + 4);
  sub_1C098(count, (int)&v38, 4u);
  v39 = (*(_DWORD *)(v36 + 0x306F8) - ((int)&loc_18247 + v36)) / 0x7B;
  sub_1C098(count, (int)&v39, 4u);
  v40 = *(char *)(v36 + 0x30700);
  sub_1C098(count, (int)&v40, 4u);
  v41 = *(_DWORD *)(v36 + 0x306FC);
  sub_1C098(count, (int)&v41, 4u);
  v42 = dword_105248;
  sub_1C098(count, (int)&v42, 4u);
  v43 = dword_10524C;
  sub_1C098(count, (int)&v43, 4u);
  v44 = dword_105250;
  sub_1C098(count, (int)&v44, 4u);
  sub_46BB0(&word_105258, count, 0);
  v45 = *(__int16 *)(v36 + 0x3335);
  sub_1C098(count, (int)&v45, 4u);
  v3 = 0;
  if ( *(__int16 *)(v36 + 0x3335) > 0 )
  {
    v4 = v36 + 0xDB5;
    do
    {
      sub_1D920(v4 + 0x60 * v3++, count, 0);
    }
    while ( v3 < *(__int16 *)(v36 + 0x3335) );
  }
  v46 = *(_DWORD *)((char *)&loc_18241 + SHIWORD(v36) + 2);
  sub_1C098(count, (int)&v46, 4u);
  sub_1C098(count, v36 + 0x49C5, 4 * *(_DWORD *)((char *)&loc_18241 + SHIWORD(v36) + 2));
  v47 = *(_DWORD *)((char *)&loc_27281 + SHIWORD(v36));
  sub_1C098(count, (int)&v47, 4u);
  v5 = 0;
  if ( *(__int16 *)((char *)&loc_27281 + v36 + 2) > 0 )
  {
    v6 = (char *)&loc_18247 + v36;
    do
    {
      sub_370B8((int)&v6[0x7B * v5++], count, 0);
    }
    while ( v5 < *(__int16 *)((char *)&loc_27281 + v36 + 2) );
  }
  v7 = 0;
  v8 = 0;
  v48 = *(__int16 *)(v36 + 0x3067B);
  v9 = (char *)&loc_27281 + v36 + 4;
  sub_1C098(count, (int)&v48, 4u);
  while ( v8 < 0x6B )
  {
    v10 = v36 + 0x162 * v8;
    if ( *(int *)((char *)&loc_272D8 + v10 + 1) >> 0x10 != 0xFFFFFFFF )
    {
      if ( !*((_BYTE *)&loc_272D8 + v10 + 5) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB57);
      }
      v49 = v8;
      sub_1C098(count, (int)&v49, 4u);
      ++v7;
      sub_4AE8C((int)&v9[0x162 * v8], count, 0);
    }
    ++v8;
  }
  if ( v7 != *(_WORD *)((char *)sub_3067B + v36) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xB65);
  }
  v50 = *(__int16 *)(v36 + 0xD88);
  sub_1C098(count, (int)&v50, 4u);
  v11 = 0;
  if ( *(__int16 *)(v36 + 0xD88) > 0 )
  {
    v12 = v36 + 6;
    do
    {
      sub_43BDC(v12 + 0x1EE * v11++, count, 0);
    }
    while ( v11 < *(__int16 *)(v36 + 0xD88) );
  }
  v51 = *(__int16 *)(v36 + 0x49C3);
  sub_1C098(count, (int)&v51, 4u);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v30 = 0;
  v31 = 0;
  v29 = 0;
  v13 = 0;
  if ( *(__int16 *)(v36 + 0x49C3) > 0 )
  {
    v14 = v36 + 0x3337;
    do
    {
      v15 = v14 + 0x27 * v13;
      v24 = *(_DWORD *)v15;
      v25 = *(_DWORD *)(v15 + 4);
      v26 = *(_DWORD *)(v15 + 8);
      v27 = *(_DWORD *)(v15 + 0xC);
      v28 = *(_DWORD *)(v15 + 0x10);
      v29 = *(_DWORD *)(v15 + 0x14);
      v30 = *(_DWORD *)(v15 + 0x18);
      v31 = *(_DWORD *)(v15 + 0x1C);
      v32 = *(_BYTE *)(v15 + 0x20);
      v33 = *(_WORD *)(v15 + 0x21);
      v34 = *(_DWORD *)(v15 + 0x23);
      v24 = *(__int16 *)(v24 + 4);
      v25 = *(__int16 *)(v25 + 4);
      sub_1C098(count, (int)&v24, 0x27u);
      ++v13;
    }
    while ( v13 < *(__int16 *)(v36 + 0x49C3) );
  }
  sub_1C098(count, (int)&byte_32DDB[v36], 0x2710u);
  v52 = *(__int16 *)(v36 + 0x32DD1);
  sub_1C098(count, (int)&v52, 4u);
  *(int *)((char *)&v23[0x65] + 2) = 0;
  *(int *)((char *)&v23[0x66] + 2) = 0;
  *(int *)((char *)&v23[0x64] + 2) = 0;
  v16 = *(_WORD *)(v36 + 0x32DD1);
  LOWORD(v55) = 0;
  if ( v16 > 0 )
  {
    v54 = (int)&off_30701 + v36;
    do
    {
      qmemcpy(v23, (const void *)(v54 + 0x19E * (__int16)v55), 0x19Eu);
      for ( i = 0; (__int16)i < SLOWORD(v23[0x64]); ++i )
      {
        v23[(__int16)i] = *(__int16 *)(v23[(__int16)i] + 4);
      }
      v18 = v55;
      sub_1C098(count, (int)v23, 0x19Eu);
      v19 = *(_WORD *)(v36 + 0x32DD1);
      LOWORD(v55) = v18 + 1;
    }
    while ( (__int16)(v18 + 1) < v19 );
  }
  v53 = *(_DWORD *)((char *)sub_306F0 + SHIWORD(v36));
  sub_1C098(count, (int)&v53, 4u);
  result = v36;
  v21 = 0;
  if ( *(__int16 *)(v36 + 0x306F2) > 0 )
  {
    v22 = v36 + 0x3067D;
    do
    {
      sub_1C098(count, v22 + 0xD * v21, 0xDu);
      result = v36;
      ++v21;
    }
    while ( v21 < *(__int16 *)(v36 + 0x306F2) );
  }
  return result;
}
// 30701: using guessed type void *off_30701;
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00021AA0) --------------------------------------------------------
__int16 __fastcall sub_21AA0(int a1, unsigned int count)
{
  __int16 v4; // ax
  __int16 v5; // cx
  int v6; // eax
  int v7; // ebp
  __int16 v8; // ax
  __int16 v9; // cx
  int v10; // eax
  __int16 i; // ax
  int v12; // edx
  __int16 v13; // cx
  __int16 v14; // ax
  __int16 v15; // cx
  int v16; // eax
  __int16 v17; // ax
  int v18; // ebp
  int v19; // ecx
  int v20; // ebx
  int v21; // eax
  int v22; // edx
  int v23; // eax
  int v24; // ebp
  __int16 v25; // cx
  int j; // eax
  __int16 v27; // dx
  __int16 v28; // ax
  __int16 v29; // cx
  void *v30; // edx
  int v32[100]; // [esp+0h] [ebp-1F4h] BYREF
  _WORD v33[3]; // [esp+190h] [ebp-64h]
  int v34; // [esp+196h] [ebp-5Eh]
  int v35; // [esp+19Ah] [ebp-5Ah]
  int v36[8]; // [esp+1A0h] [ebp-54h] BYREF
  int v37; // [esp+1C0h] [ebp-34h] BYREF
  int v38; // [esp+1C4h] [ebp-30h]
  int v39; // [esp+1C8h] [ebp-2Ch]
  int v40; // [esp+1CCh] [ebp-28h]
  int v41; // [esp+1D0h] [ebp-24h]
  __int16 v42; // [esp+1D4h] [ebp-20h]
  int v43; // [esp+1D8h] [ebp-1Ch]
  int v44; // [esp+1DCh] [ebp-18h]

  sub_1BF94((P_Type1)count, v36, 0x20u);
  if ( v36[0] != 0x1D72 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAA);
  }
  if ( v36[1] != 0x60 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAB);
  }
  if ( v36[2] != 0x7B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAC);
  }
  if ( v36[3] != 0x1EE )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAD);
  }
  if ( v36[4] != 0x27 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAE);
  }
  if ( v36[5] != 0x19E )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBAF);
  }
  if ( v36[6] != 0xD )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBB0);
  }
  if ( v36[7] != 0x354EF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\cosmos.cpp", 0xBB1);
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)a1 = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)(a1 + 0x306F4) = 0x60 * v37 + a1 + 0xDB5;
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)(a1 + 0x306F8) = (char *)&loc_18247 + 0x7B * v37 + a1;
  sub_1BF94((P_Type1)count, &v37, 4u);
  byte_30700[a1] = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_DWORD *)(a1 + 0x306FC) = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  dword_105248 = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  dword_10524C = v37;
  sub_1BF94((P_Type1)count, &v37, 4u);
  dword_105250 = v37;
  sub_46BB0(&word_105258, count, 0xFFFFFFFF);
  sub_1BF94((P_Type1)count, &v37, 4u);
  v4 = v37;
  v5 = 0;
  *(_WORD *)(a1 + 0x3335) = v37;
  if ( v4 > 0 )
  {
    do
    {
      v6 = a1 + 0xDB5 + 0x60 * v5++;
      sub_1D920(v6, count, 0xFFFFFFFF);
    }
    while ( v5 < *(__int16 *)(a1 + 0x3335) );
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_WORD *)((char *)&loc_18241 + a1 + 4) = v37;
  v7 = a1 + 0x49C5;
  sub_1BF94((P_Type1)count, (void *)(a1 + 0x49C5), 4 * (*(int *)((char *)&loc_18241 + a1 + 2) >> 0x10));
  sub_1BF94((P_Type1)count, &v37, 4u);
  v8 = v37;
  v9 = 0;
  *(_WORD *)((char *)&loc_27281 + a1 + 2) = v37;
  if ( v8 > 0 )
  {
    v40 = (int)&loc_18247 + a1;
    do
    {
      v38 = 0x7B * v9;
      sub_370B8(v38 + v40, count, 0xFFFFFFFF);
      v10 = v38;
      *(_DWORD *)((char *)&loc_18253 + a1 + v38 + 4) = v7;
      ++v9;
      v7 += 4 * *(unsigned __int16 *)((char *)&loc_1825F + a1 + v10 + 2);
    }
    while ( v9 < *(__int16 *)((char *)&loc_27281 + a1 + 2) );
  }
  for ( i = 0; i < 0x6B; ++i )
  {
    v12 = 0x162 * i;
    *(_WORD *)((char *)&loc_272D8 + v12 + a1 + 3) = 0xFFFF;
    *((_BYTE *)&loc_272D8 + v12 + a1 + 5) = 0;
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v13 = 0;
  *(_WORD *)((char *)sub_3067B + a1) = v37;
  while ( v13 < 0x6B )
  {
    if ( v13 < *(__int16 *)((char *)sub_3067B + a1) )
    {
      sub_1BF94((P_Type1)count, &v37, 4u);
      sub_4AE8C((int)&loc_27281 + 0x162 * v37 + a1 + 4, count, 0xFFFFFFFF);
    }
    ++v13;
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v14 = v37;
  v15 = 0;
  *(_WORD *)(a1 + 0xD88) = v37;
  if ( v14 > 0 )
  {
    do
    {
      v16 = a1 + 6 + 0x1EE * v15++;
      sub_43BDC(v16, count, 0xFFFFFFFF);
    }
    while ( v15 < *(__int16 *)(a1 + 0xD88) );
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v17 = v37;
  LOWORD(v43) = 0;
  *(_WORD *)(a1 + 0x49C3) = v37;
  if ( v17 > 0 )
  {
    v41 = a1 + 0x3337;
    v39 = a1 + 0xDB5;
    do
    {
      v18 = 0x27 * (__int16)v43;
      v19 = v18 + v41;
      sub_1BF94((P_Type1)count, (void *)(v18 + v41), 0x27u);
      v20 = v39 + 0x60 * *(_DWORD *)(a1 + v18 + 0x3337);
      v21 = 0x60 * *(_DWORD *)(a1 + v18 + 0x333B);
      v22 = v39;
      *(_DWORD *)(a1 + v18 + 0x3337) = v20;
      v23 = v22 + v21;
      *(_DWORD *)(a1 + v18 + 0x333B) = v23;
      v42 = *(_WORD *)(v20 + 0x44);
      v24 = v42;
      *(_WORD *)(v20 + 0x44) = v42 + 1;
      *(_DWORD *)(v20 + 4 * v24 + 0x2C) = v19;
      LOWORD(v22) = *(_WORD *)(v23 + 0x44);
      *(_WORD *)(v23 + 0x44) = v22 + 1;
      *(_DWORD *)(4 * (__int16)v22 + v23 + 0x2C) = v19;
      LOWORD(v22) = *(_WORD *)(a1 + 0x49C3);
      LOWORD(v43) = v43 + 1;
    }
    while ( (__int16)v43 < (__int16)v22 );
  }
  sub_1BF94((P_Type1)count, &byte_32DDB[a1], 0x2710u);
  sub_1BF94((P_Type1)count, &v37, 4u);
  *(_WORD *)(a1 + 0x32DD1) = v37;
  v34 = 0;
  v35 = 0;
  *(_DWORD *)&v33[1] = 0;
  v25 = *(_WORD *)(a1 + 0x32DD1);
  v44 = 0;
  if ( v25 > 0 )
  {
    do
    {
      sub_1BF94((P_Type1)count, v32, 0x19Eu);
      for ( j = 0; (__int16)j < v33[0]; ++j )
      {
        v32[(__int16)j] = a1 + 0xDB5 + 0x60 * v32[(__int16)j];
      }
      v27 = *(_WORD *)(a1 + 0x32DD1);
      ++v44;
    }
    while ( (__int16)v44 < v27 );
  }
  sub_1BF94((P_Type1)count, &v37, 4u);
  v28 = v37;
  v29 = 0;
  *(_WORD *)(a1 + 0x306F2) = v37;
  if ( v28 > 0 )
  {
    do
    {
      v30 = (void *)(0xD * v29++ + a1 + 0x3067D);
      sub_1BF94((P_Type1)count, v30, 0xDu);
    }
    while ( v29 < *(__int16 *)(a1 + 0x306F2) );
  }
  return sub_1EEA4(a1);
}
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;
// 21AA0: using guessed type int var_1F4[100];

//----- (000220CC) --------------------------------------------------------
__int16 __fastcall sub_220CC(int a1)
{
  __int16 v2; // di
  __int16 v3; // dx
  double v4; // st6
  __int16 v5; // bx
  __int16 i; // dx
  float *v7; // ebx
  float *v8; // eax
  __int16 result; // ax
  double v10[7]; // [esp+8h] [ebp-84h] BYREF
  float v11; // [esp+40h] [ebp-4Ch]
  float v12; // [esp+44h] [ebp-48h]
  float v13; // [esp+48h] [ebp-44h]
  float v14; // [esp+4Ch] [ebp-40h]
  float v15; // [esp+50h] [ebp-3Ch]
  float v16; // [esp+54h] [ebp-38h]
  int v17[6]; // [esp+58h] [ebp-34h] BYREF
  int v18; // [esp+70h] [ebp-1Ch]

  v2 = 0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  memset(v10, 0, sizeof(v10));
  v3 = *(_WORD *)(a1 + 0xD88);
  *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = 0;
  if ( v3 > 0 )
  {
    do
    {
      for ( i = 0; i < *(__int16 *)(a1 + 0xD88); ++i )
      {
        if ( v2 != i )
        {
          v7 = *(float **)(a1 + 0x1EE * i + 0xD);
          v8 = *(float **)(a1 + 0x1EE * v2 + 0xD);
          v17[5] = (int)v17;
          v11 = 0.0;
          v12 = 0.0;
          v13 = 0.0;
          v11 = v8[2] - v7[2];
          v12 = v8[3] - v7[3];
          v13 = v8[4] - v7[4];
          *(float *)v17 = v11;
          *(float *)&v17[1] = v12;
          *(float *)&v17[2] = v13;
          v14 = v11;
          v15 = v12;
          v16 = v13;
          v10[v2] = sqrt(v12 * v12 + v11 * v11 + v13 * v13) + v10[v2];
        }
      }
      v18 = *(__int16 *)(a1 + 0xD88) - 1;
      v10[v2] = v10[v2] / (double)v18;
      v4 = (double)*(__int16 *)((char *)&loc_32DD2 + a1 + 1) + v10[v2++];
      v18 = (int)v4;
      v5 = *(_WORD *)(a1 + 0xD88);
      *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = (int)v4;
    }
    while ( v2 < v5 );
  }
  result = *(__int16 *)((char *)&loc_32DD2 + a1 + 1) / *(__int16 *)(a1 + 0xD88);
  *(_WORD *)((char *)&loc_32DD2 + a1 + 1) = result;
  return result;
}
// 220CC: using guessed type double var_84[7];

//----- (00022260) --------------------------------------------------------
int __fastcall sub_22260(int a1)
{
  return _wcpp_2_dtor_array_(a1, 7, &unk_95AF0);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022280) --------------------------------------------------------
int __fastcall sub_22280(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x64, &unk_95B04);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (000222A0) --------------------------------------------------------
int __fastcall sub_222A0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x6B, &unk_95AB4);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (000222C0) --------------------------------------------------------
int __fastcall sub_222C0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x18, &unk_95A8C);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (000222E0) --------------------------------------------------------
int __fastcall sub_222E0(int a1)
{
  return _wcpp_2_dtor_array_(a1, 9, &unk_95AA0);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022300) --------------------------------------------------------
int __fastcall sub_22300(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x1F4, &unk_95AC8);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022320) --------------------------------------------------------
int __fastcall sub_22320(int a1)
{
  return _wcpp_2_dtor_array_(a1, 0x94, &unk_95ADC);
}
// 7760C: using guessed type int __fastcall _wcpp_2_dtor_array_(_DWORD, _DWORD, _DWORD);

//----- (00022360) --------------------------------------------------------
_DWORD *__fastcall sub_22360(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 8);
  *v1 = 0;
  v1 += 3;
  v1[0xFFFFFFFE] = 0;
  v1[0xFFFFFFFF] = 0;
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return v1 + 0xFFFFFFFB;
}

//----- (000223B0) --------------------------------------------------------
char *__fastcall sub_223B0(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 1);
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return (char *)v1 + 0xFFFFFFFF;
}

//----- (000223E0) --------------------------------------------------------
char *__fastcall sub_223E0(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)(a1 + 0x192);
  v1[1] = 0;
  v1[2] = 0;
  *v1 = 0;
  return (char *)v1 + 0xFFFFFE6E;
}

//----- (00022400) --------------------------------------------------------
int __fastcall sub_22400(int result)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_WORD *)(result + 0x1A) = 0;
  *(_DWORD *)(result + 0x10) = 0;
  *(_DWORD *)(result + 0x5A) = 0;
  return result;
}

//----- (00022430) --------------------------------------------------------
int __fastcall sub_22430(const void *a1, const void *a2)
{
  int v2; // edx
  float v4; // [esp+0h] [ebp-8h]
  float v5; // [esp+4h] [ebp-4h]

  v5 = *(float *)(*(_DWORD *)a1 + 0xD);
  v4 = *(float *)(*(_DWORD *)a2 + 0xD);
  v2 = 0;
  if ( v5 > (double)v4 )
  {
    return 0xFFFFFFFF;
  }
  if ( v5 < (double)v4 )
  {
    return 1;
  }
  return v2;
}

//----- (00022468) --------------------------------------------------------
int sub_22468()
{
  int result; // eax

  result = sub_56E18((int)&V_Type3_stru_10AE70, "NEXTTURNCONT", 1, 0);
  if ( !result )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x69);
  }
  *(_DWORD *)(result + 0xAB) = 0;
  return result;
}

//----- (000224A4) --------------------------------------------------------
char *__fastcall sub_224A4(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // eax
  char v3; // cl
  char *result; // eax

  sub_2C830((P_TypeA2)a1);
  v1 = sub_1B4F0((_DWORD *)(a1 + 0xDA));
  v2 = (_DWORD *)sub_254A4((int)(v1 + 0x26));
  *(_DWORD *)((char *)v2 + 0xFFFFFF35) = off_95BB4;
  *(_DWORD *)((char *)v2 + 0xFFFFFF39) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF3D) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF41) = 0;
  *(_WORD *)((char *)v2 + 0xFFFFFF45) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF49) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF4E) = 0;
  *(_DWORD *)((char *)v2 + 0xFFFFFF52) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF56) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF5A) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF5E) = 0xFFFFFFFF;
  *(_DWORD *)((char *)v2 + 0xFFFFFF62) = 0;
  v2[0x108] = 0;
  *((_BYTE *)v2 + 0xFFFFFF66) = 0xFF;
  v2[0x103] = 2;
  v2[0x107] = 0;
  v2[0x106] = 0;
  v3 = byte_104BEA;
  v2[0x104] = 0;
  result = (char *)v2 + 0xFFFFFE8E;
  result[0xD9] = 1 << v3;
  return result;
}
// 95BB4: using guessed type int (*off_95BB4[2])();

//----- (00022588) --------------------------------------------------------
char *__fastcall sub_22588(char *a1, char a2)
{
  char *v2; // ebx
  void *v4; // eax
  void *v5; // edx
  int v6; // eax
  int v7; // eax
  char *v8; // eax

  v2 = a1;
  if ( (a2 & 4) != 0 )
  {
    v4 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95B70);
    operator delete[](v4);
  }
  else
  {
    v5 = *(void **)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xA7) = off_95BB4;
    if ( v5 )
    {
      sub_2627C(v5);
    }
    operator delete[](*(void **)(v2 + 0xAB));
    if ( *(_DWORD *)(v2 + 0xAF) )
    {
      sub_2627C(*(void **)(v2 + 0xAF));
    }
    operator delete[](*(void **)(v2 + 0xAF));
    if ( *(_DWORD *)(v2 + 0xB3) )
    {
      sub_2627C(*(void **)(v2 + 0xB3));
    }
    operator delete[](*(void **)(v2 + 0xB3));
    v6 = sub_254B0((int)(v2 + 0x172));
    v7 = ((int (__fastcall *)(int, _DWORD))locret_1B66C)(v6 - 0x98, 0);
    v8 = (char *)sub_2C848(v7 - 0xDA, 1);
    v2 = v8;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v8);
    }
  }
  return v2;
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95BB4: using guessed type int (*off_95BB4[2])();

//----- (00022644) --------------------------------------------------------
unsigned int __fastcall Q_COSWND_CPP_sub_22644(int a1, const char *a2, const char *a3)
{
  void *v4; // eax
  int v5; // ecx
  void *v6; // eax
  int v7; // ebx
  __int16 v8; // ax
  void *v9; // eax
  T_Type1 v11; // [esp+0h] [ebp-128h] BYREF

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x9E);
  }
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x9F);
  }
  Q_InitFileInfo_sub_1BB78(&v11);
  if ( *(_DWORD *)(a1 + 0xAB) )
  {
    sub_2627C(*(void **)(a1 + 0xAB));
  }
  operator delete[](*(void **)(a1 + 0xAB));
  if ( Q_CfilePreload_sub_1BBFC(&v11, a2, O_BINARY, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0xAA);
  }
  v4 = Q_CfileLoad_sub_1BF1C(&v11, 0);
  *(_DWORD *)(a1 + 0xAB) = v4;
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0xAC);
  }
  if ( *(_DWORD *)(a1 + 0xAF) )
  {
    sub_2627C(*(void **)(a1 + 0xAF));
  }
  operator delete[](*(void **)(a1 + 0xAF));
  HIWORD(v5) = 0;
  if ( Q_CfilePreload_sub_1BBFC(&v11, a3, O_BINARY, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0xB5);
  }
  v6 = Q_CfileLoad_sub_1BF1C(&v11, 0);
  *(_DWORD *)(a1 + 0xAF) = v6;
  if ( !v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0xB7);
  }
  LOWORD(v6) = *(_WORD *)(a1 + 0x10) - *(_WORD *)(a1 + 8);
  LOWORD(v5) = *(_WORD *)(a1 + 0xC);
  *(_WORD *)(a1 + 0x576) = (_WORD)v6;
  v7 = (int)v6;
  v8 = *(_WORD *)(a1 + 0x14);
  LOWORD(v7) = (__int16)v7 >> 1;
  *(_WORD *)(a1 + 0x576) = v7;
  *(_WORD *)(a1 + 0x578) = (__int16)(v8 - v5) >> 1;
  sub_2280C(a1, 0, v7, v5);
  if ( *(_DWORD *)(a1 + 0xB3) )
  {
    sub_2627C(*(void **)(a1 + 0xB3));
  }
  operator delete[](*(void **)(a1 + 0xB3));
  v9 = operator new[](0x1D1Fu);
  sub_2625C(v9, 1, "CW DISPLAYITEMS");
  *(_DWORD *)(a1 + 0xB3) = v9;
  if ( !v9 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0xCC);
  }
  *(_WORD *)(a1 + 0xB7) = 0;
  *(_WORD *)(a1 + 0xB9) = 0x163;
  Q_CloseFileAndDelete_sub_1BBC8(&v11);
  return 0xFFFFFFFF;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0002280C) --------------------------------------------------------
_DWORD *__fastcall sub_2280C(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // edx
  char *v5; // eax
  _DWORD *result; // eax

  v4 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 0x57A) = 0x420C0000;
  sub_1B808(
    (_DWORD *)(a1 + 0xDA),
    (int)v4,
    a3,
    a4,
    *(_DWORD *)((char *)v4 + 0x57A),
    0x3F800000,
    0x47C35000,
    *(__int16 *)(a1 + 0x576));
  v5 = (char *)v4 + 0x10E;
  *(_DWORD *)((char *)v4 + 0x10E) = 0;
  *(_DWORD *)((char *)v4 + 0x112) = 0;
  v4 = (_DWORD *)((char *)v4 + 0x14E);
  *((_DWORD *)v5 + 2) = 0xC4BB8000;
  *v4 = 0x3F800000;
  v4[1] = 0;
  result = v4 + 3;
  v4[2] = 0;
  v4[3] = 0;
  v4[4] = 0x3F800000;
  v4 += 6;
  result[2] = 0;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0x3F800000;
  return result;
}

//----- (000228A4) --------------------------------------------------------
#error "228A4: function frame is wrong (funcsize=0)"

//----- (00023BF0) --------------------------------------------------------
void __fastcall sub_23BF0(int a1, int a2)
{
  int v3; // eax
  int v4; // eax
  char *v5; // edi
  char *v6; // esi
  char v7; // al
  char v8; // al
  __int16 i; // si
  char v10; // dl
  int v11; // ebx
  int v12; // edx
  int v13; // ebx
  int v14; // edx
  const char *v15; // ecx
  int *v16; // eax
  int v17; // ebx
  int v18; // edx
  __int16 v19; // dx
  char *v20; // esi
  char *v21; // edi
  char v22; // al
  char v23; // al
  int v24; // ebx
  int v25; // edx
  char s[128]; // [esp+0h] [ebp-F8h] BYREF
  char v27[40]; // [esp+80h] [ebp-78h] BYREF
  _DWORD v28[9]; // [esp+A8h] [ebp-50h] BYREF
  char v29[20]; // [esp+CCh] [ebp-2Ch] BYREF
  int v30; // [esp+E0h] [ebp-18h]

  v30 = a2;
  sub_254F8((int *)(a1 + 0x172), a1);
  if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 3 )
  {
    v3 = sub_56E18((int)&V_Type3_stru_10AE70, "NEWGAMEWND", 3, 0);
    if ( !v3 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x414);
    }
    (*(void (__fastcall **)(int, int))(*(_DWORD *)(v3 + 0xA7) + 0xC))(v3, 1);
  }
  if ( *(_DWORD *)(a1 + 0xD4) == 0xFFFFFFFF )
  {
    sub_23FD4(a1);
  }
  if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 3 )
  {
    sub_53E38((P_Type5)(a1 + 4), 3, 3, (unsigned __int8)byte_104BEA);
  }
  if ( *(_DWORD *)(a1 + 0xBB) )
  {
    s[0] = 0;
    v16 = *(int **)(a1 + 0xBB);
    v10 = 1;
    if ( !*((_BYTE *)v16 + 4) )
    {
      v4 = *v16;
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(v4 + 0x17)) != 0 )
      {
        v5 = s;
        v6 = (char *)(v4 + 0x1C);
        do
        {
          v7 = *v6;
          *v5 = *v6;
          if ( !v7 )
          {
            break;
          }
          v8 = v6[1];
          v6 += 2;
          v5[1] = v8;
          v5 += 2;
        }
        while ( v8 );
        for ( i = 0;
              i < 7
           && (*(_BYTE *)(**(_DWORD **)(a1 + 0xBB) + 0x14) & (unsigned __int8)(*(_BYTE *)(a1 + 0xD9) & v10)) == 0;
              ++i )
        {
          v10 *= 2;
        }
      }
      v11 = *(_DWORD *)(a1 + 0x14) - 0x1B;
      v12 = *(_DWORD *)(a1 + 0x10) - 0x82;
      *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v12, v11, s, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v13 = *(_DWORD *)(a1 + 0x14) - 0xC;
      v14 = *(_DWORD *)(a1 + 0x10) - 0x82;
      v15 = &byte_D84C4[0x14 * ***(_DWORD ***)(a1 + 0xBB)];
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], v14, v13, v15, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
    }
  }
  if ( v30 != 0xA )
  {
    unk_D85E4 = *(_DWORD *)(a1 + 4);
    *((_DWORD *)&unk_D85E4 + 1) = *(_DWORD *)(a1 + 8);
    *((_DWORD *)&unk_D85E4 + 2) = *(_DWORD *)(a1 + 0xC);
    *((_DWORD *)&unk_D85E4 + 3) = *(_DWORD *)(a1 + 0x10);
    *((_DWORD *)&unk_D85E4 + 4) = *(_DWORD *)(a1 + 0x14);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&unk_D85E4);
  if ( dword_A0CFC == 0xFFFFFFFF && dword_A0CFC == *(_DWORD *)(a1 + 0x58E) )
  {
    sprintf(s, "STARS CONTROLLED %d", dword_D8457);
    *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xA, 0x18C, s, 0, 0xFFFFFFFF, 0xFF, 0);
    sprintf(s, "PERCENT CONTROLLED %d", 0x64 * dword_D8457 / word_A62A1);
    qmemcpy(v28, "Peaceful", sizeof(v28));
    sprintf(s, "%d Biorythym (%s)\n", word_104BE8, &v28[3 * byte_A3D20]);
    v17 = *(_DWORD *)(a1 + 0xC) + 0x1E;
    v18 = *(_DWORD *)(a1 + 8) + 5;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v18, v17, s, 0, 0xFFFFFFFF, 0xFF, 0);
    v19 = 0;
    s[0] = 0;
    qmemcpy(v27, "Unknown", sizeof(v27));
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      do
      {
        sprintf(
          v29,
          "R%d %10s %d\n",
          v19,
          &v27[0xA * (*(int *)((char *)&unk_A312F + 0x1EE * (unsigned __int8)byte_104BEA + v19) >> 0x18)],
          *(int *)((char *)&unk_A3122 + 0x1EE * (unsigned __int8)byte_104BEA + 2 * v19) >> 0x10);
        v20 = v29;
        ++v19;
        v21 = &s[strlen(s)];
        do
        {
          v22 = *v20;
          *v21 = *v20;
          if ( !v22 )
          {
            break;
          }
          v23 = v20[1];
          v20 += 2;
          v21[1] = v23;
          v21 += 2;
        }
        while ( v23 );
      }
      while ( v19 < SHIWORD(dword_A3CF2) );
    }
    v24 = *(_DWORD *)(a1 + 0xC) + 0x37;
    v25 = *(_DWORD *)(a1 + 8) + 5;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v25, v24, s, 0, 0xFFFFFFFF, 0xFF, 0);
  }
}
// 968DC: using guessed type char byte_968DC;
// A0CFC: using guessed type int dword_A0CFC;
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;
// A62A1: using guessed type __int16 word_A62A1;
// D8457: using guessed type int dword_D8457;
// 104BE8: using guessed type __int16 word_104BE8;
// 23BF0: using guessed type char s[128];
// 23BF0: using guessed type char var_78[40];

//----- (00023FD4) --------------------------------------------------------
int __fastcall sub_23FD4(int a1)
{
  char *v1; // ebp
  int v2; // esi
  int v3; // edi
  int result; // eax
  void *v5; // eax
  void *v6; // eax
  LONG v7; // [esp-Ch] [ebp-44h]
  int v8; // [esp+0h] [ebp-38h]
  PANE *pane; // [esp+8h] [ebp-30h]
  int hotY; // [esp+Ch] [ebp-2Ch]
  int hotX; // [esp+10h] [ebp-28h]
  LONG flags; // [esp+14h] [ebp-24h]
  unsigned __int16 v14; // [esp+18h] [ebp-20h]
  char v15; // [esp+1Ch] [ebp-1Ch]

  v1 = byte_A2F72;
  v2 = 0;
  v15 = 1;
  v3 = 0;
  v8 = 0;
  pane = (PANE *)(a1 + 4);
  while ( 1 )
  {
    result = SHIWORD(dword_A3CF2);
    if ( v2 >= SHIWORD(dword_A3CF2) )
    {
      break;
    }
    hotX = dword_D85C6[v3] >> 0x10;
    hotY = *(int *)((char *)&dword_D85C6[v3] + 2) >> 0x10;
    if ( (*(unsigned __int8 *)(a1 + 0xD8) & v15) != 0
      && (byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v2] || v2 == (unsigned __int8)byte_104BEA) )
    {
      flags = 0;
      v14 = word_FFEA0[v8];
      if ( *(_DWORD *)(v1 + 3) == 0xFFFFFFFF )
      {
        flags = 1;
        VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x1600));
      }
      v5 = (void *)sub_1B084((unsigned int)dword_12FC20, v14);
      VFX_shape_transform(pane, v5, 0, hotX, hotY, buffer, 0, (LONG)sub_10000, (LONG)sub_10000, flags);
    }
    if ( (*(unsigned __int8 *)(a1 + 0xD8) & v15) != 0 )
    {
      v7 = (unsigned __int8)v1[2];
      v6 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE2);
      VFX_shape_draw(pane, v6, v7, hotX, hotY);
    }
    ++v3;
    ++v2;
    v1 += 0x1EE;
    v15 *= 2;
    ++v8;
  }
  return result;
}
// 10000: using guessed type void __noreturn sub_10000();
// A3CF2: using guessed type int dword_A3CF2;
// D85C6: using guessed type int dword_D85C6[];
// D8D8F: using guessed type int dword_D8D8F;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEE2: using guessed type __int16 word_FFEE2;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00024154) --------------------------------------------------------
void __fastcall sub_24154(int a1, int a2, int a3, int a4, float a5)
{
  float *v6; // eax
  int v7; // [esp+0h] [ebp-8h]

  sub_254B0(a1 + 0x172);
  v6 = (float *)(a1 + 0x14E);
  *(float *)&v7 = a5 * flt_12FC1C;
  if ( a2 == 0xFFFFFFFF )
  {
    sub_535E4(v6, 0xFFFFFFFF, a1, a4, v7);
  }
  else
  {
    sub_535B4(v6, a2, a1, a4, v7);
  }
}
// 12FC1C: using guessed type float flt_12FC1C;

//----- (00024198) --------------------------------------------------------
void __fastcall sub_24198(int a1, int a2, int a3, int a4)
{
  int v5; // [esp-4h] [ebp-10h]

  if ( (*(float *)(a1 + 0x57A) >= (double)flt_9103C || a2 >= 0)
    && (*(float *)(a1 + 0x57A) <= (double)flt_91040 || a2 <= 0) )
  {
    v5 = *(__int16 *)(a1 + 0x576);
    *(float *)(a1 + 0x57A) = (double)a2 * flt_12FC1C + *(float *)(a1 + 0x57A);
    sub_1B808((_DWORD *)(a1 + 0xDA), a2, a1, a4, *(_DWORD *)(a1 + 0x57A), 0x3F800000, 0x47C35000, v5);
    sub_254B0(a1 + 0x172);
  }
  else
  {
    *(_BYTE *)(a1 + 0xC0) &= ~0x10u;
  }
}
// 9103C: using guessed type float flt_9103C;
// 91040: using guessed type float flt_91040;
// 12FC1C: using guessed type float flt_12FC1C;

//----- (0002422C) --------------------------------------------------------
void __fastcall sub_2422C(int a1, int a2, int a3, int a4)
{
  size_t *v5; // edx
  int v6; // esi
  int v7; // eax
  size_t *v8; // eax
  int v9; // ebp
  double v10; // st7
  size_t *v11; // eax
  int v12; // edx
  int **v13; // ebx
  int *v14; // ebp
  int *v15; // ebx
  int *v16; // ebp
  double v17; // st7
  double v18; // st7
  float v19; // eax
  int v20; // ebp
  __int16 v21; // dx
  int v22; // ebp
  int v23; // ebx
  int i; // eax
  double v25; // st7
  unsigned __int8 v26; // al
  int v27[3]; // [esp+8h] [ebp-114h] BYREF
  int v28[3]; // [esp+14h] [ebp-108h] BYREF
  int v29[3]; // [esp+20h] [ebp-FCh] BYREF
  float v30; // [esp+2Ch] [ebp-F0h]
  int v31; // [esp+30h] [ebp-ECh]
  int v32; // [esp+34h] [ebp-E8h]
  int v33[2]; // [esp+38h] [ebp-E4h] BYREF
  float v34; // [esp+40h] [ebp-DCh]
  int v35[3]; // [esp+44h] [ebp-D8h] BYREF
  float v36; // [esp+50h] [ebp-CCh]
  float v37; // [esp+54h] [ebp-C8h]
  float v38; // [esp+58h] [ebp-C4h]
  float v39; // [esp+5Ch] [ebp-C0h]
  int v40; // [esp+60h] [ebp-BCh]
  int v41; // [esp+64h] [ebp-B8h]
  int v42[3]; // [esp+68h] [ebp-B4h] BYREF
  float v43; // [esp+74h] [ebp-A8h]
  int v44; // [esp+78h] [ebp-A4h]
  int v45; // [esp+7Ch] [ebp-A0h]
  float v46; // [esp+80h] [ebp-9Ch]
  int v47; // [esp+84h] [ebp-98h]
  int v48; // [esp+88h] [ebp-94h]
  float v49; // [esp+8Ch] [ebp-90h]
  float v50; // [esp+90h] [ebp-8Ch]
  float v51; // [esp+94h] [ebp-88h]
  float v52; // [esp+98h] [ebp-84h]
  int v53; // [esp+9Ch] [ebp-80h]
  int v54; // [esp+A0h] [ebp-7Ch]
  int v55[2]; // [esp+A4h] [ebp-78h] BYREF
  float v56; // [esp+ACh] [ebp-70h]
  int *v57; // [esp+B0h] [ebp-6Ch]
  int *v58; // [esp+B8h] [ebp-64h]
  int *v59; // [esp+BCh] [ebp-60h]
  float v60; // [esp+C0h] [ebp-5Ch]
  int *v61; // [esp+C4h] [ebp-58h]
  int *v62; // [esp+C8h] [ebp-54h]
  int v63; // [esp+D0h] [ebp-4Ch]
  size_t *v64; // [esp+D4h] [ebp-48h]
  int v65; // [esp+D8h] [ebp-44h]
  size_t *v66; // [esp+DCh] [ebp-40h]
  int v67; // [esp+E0h] [ebp-3Ch]
  float *v68; // [esp+E4h] [ebp-38h]
  int v69; // [esp+E8h] [ebp-34h]
  int v70; // [esp+ECh] [ebp-30h]
  int v71; // [esp+F0h] [ebp-2Ch]
  int v72; // [esp+F4h] [ebp-28h] BYREF
  int v73; // [esp+F8h] [ebp-24h] BYREF
  int v74; // [esp+FCh] [ebp-20h] BYREF
  __int16 v75[14]; // [esp+100h] [ebp-1Ch] BYREF

  v55[0] = 0;
  v55[1] = 0;
  v56 = 0.0;
  v33[0] = 0;
  v33[1] = 0;
  v34 = 0.0;
  v5 = (size_t *)(a1 + 0x172);
  v6 = *(_DWORD *)(a1 + 0xB3);
  sub_254B0(a1 + 0x172);
  sub_1B864(a1 + 0xDA, (int)v5, 0, a4);
  v63 = 0;
  v64 = v5;
  v68 = (float *)(a1 + 0x11A);
  v7 = v6 - 0x15;
  v66 = v5;
  while ( 1 )
  {
    v70 = v7;
    if ( *(__int16 *)(a1 + 0xB7) <= v63 )
    {
      break;
    }
    v26 = *(_BYTE *)(v6 + 4);
    if ( v26 )
    {
      if ( v26 <= 1u )
      {
        v9 = *(_DWORD *)v6;
        sub_53384((float *)(**(_DWORD **)v6 + 8), v68, (float *)v55);
        sub_53384((float *)(*(_DWORD *)(v9 + 4) + 8), v68, (float *)v33);
        *(_DWORD *)(v6 + 0x11) = 0xFFFFFFFF;
        if ( v56 > (double)*(float *)(a1 + 0x106)
          && v56 < (double)*(float *)(a1 + 0x10A)
          && v34 > (double)*(float *)(a1 + 0x106)
          && v34 < (double)*(float *)(a1 + 0x10A) )
        {
          sub_533D4(
            (float *)v55,
            *(float *)(a1 + 0x102),
            *(__int16 *)(a1 + 0x576),
            *(__int16 *)(a1 + 0x578),
            (int)v75,
            (int)&v74);
          sub_533D4(
            (float *)v33,
            *(float *)(a1 + 0x102),
            *(__int16 *)(a1 + 0x576),
            *(__int16 *)(a1 + 0x578),
            (int)&v73,
            (int)&v72);
          *(_WORD *)(v6 + 5) = v75[0];
          *(_WORD *)(v6 + 7) = v74;
          *(_WORD *)(v6 + 9) = v73;
          *(_WORD *)(v6 + 0xB) = v72;
          v10 = (v56 + v34) * flt_91060;
          *(_DWORD *)(v6 + 0x11) = 0;
          v11 = v66;
          *(float *)(v6 + 0xD) = v10;
          sub_254BC((int)v11, v6);
        }
      }
      else
      {
        if ( v26 != 2 )
        {
          Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0x588);
        }
        v12 = *(_DWORD *)v6;
        if ( *(_BYTE *)(*(_DWORD *)v6 + 0x58) == 5 )
        {
          v13 = *(int ***)(v12 + 0x59);
          v49 = 0.0;
          v50 = 0.0;
          v51 = 0.0;
          v36 = 0.0;
          v37 = 0.0;
          v38 = 0.0;
          if ( (*(_DWORD *)(v12 + 0xA2) & 0x7FFFFFFF) != 0 )
          {
            v16 = *v13;
            v49 = *((float *)*v13 + 2);
            v50 = *((float *)v16 + 3);
            v51 = *((float *)v16 + 4);
            v15 = v13[1];
          }
          else
          {
            v14 = v13[1];
            v49 = *((float *)v14 + 2);
            v50 = *((float *)v14 + 3);
            v51 = *((float *)v14 + 4);
            v15 = *v13;
          }
          v36 = *((float *)v15 + 2);
          v37 = *((float *)v15 + 3);
          v38 = *((float *)v15 + 4);
          v52 = v36 - v49;
          v57 = v27;
          *(float *)&v53 = v37 - v50;
          *(float *)&v54 = v38 - v51;
          *(float *)v27 = v52;
          v27[1] = v53;
          v27[2] = v54;
          v17 = sqrt(*(float *)&v53 * *(float *)&v53 + v52 * v52 + *(float *)&v54 * *(float *)&v54);
          v58 = v35;
          v43 = v36 - v49;
          *(float *)v35 = v43;
          *(float *)&v44 = v37 - v50;
          v35[1] = v44;
          *(float *)&v45 = v38 - v51;
          v35[2] = v45;
          v59 = v42;
          v60 = *(float *)(v12 + 0x9E);
          v46 = v43 * v60;
          *(float *)&v47 = *(float *)&v44 * v60;
          *(float *)&v48 = *(float *)&v45 * v60;
          v18 = 1.0 / v17;
          *(float *)v42 = v46;
          v42[1] = v47;
          v42[2] = v48;
          v30 = v46 * v18;
          v61 = v29;
          *(float *)&v31 = *(float *)&v47 * v18;
          *(float *)v29 = v30;
          v29[1] = v31;
          *(float *)&v32 = v18 * *(float *)&v48;
          v29[2] = v32;
          v39 = v49 + v30;
          v62 = v28;
          *(float *)&v40 = v50 + *(float *)&v31;
          *(float *)v28 = v39;
          *(float *)&v41 = v51 + *(float *)&v32;
          v28[1] = v40;
          v28[2] = v41;
          sub_53384((float *)v28, v68, (float *)v55);
          *(_DWORD *)(v6 + 0x11) = 0xFFFFFFFF;
          if ( v56 > (double)*(float *)(a1 + 0x106) && v56 < (double)*(float *)(a1 + 0x10A) )
          {
            sub_533D4(
              (float *)v55,
              *(float *)(a1 + 0x102),
              *(__int16 *)(a1 + 0x576),
              *(__int16 *)(a1 + 0x578),
              (int)v75,
              (int)&v74);
            *(_WORD *)(v6 + 5) = v75[0] + 3;
            *(_WORD *)(v6 + 7) = v74;
            v19 = v56;
            *(_DWORD *)(v6 + 0x11) = 0;
            *(float *)(v6 + 0xD) = v19;
            sub_254BC((int)v64, v6);
            goto LABEL_29;
          }
        }
        else
        {
          v20 = *(_DWORD *)(v70 + 0x11);
          v69 = v70;
          if ( !v20 )
          {
            if ( *(_BYTE *)(v70 + 4) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x56E);
            }
            v21 = 4;
            v22 = *(unsigned __int8 *)(v67 + 0x14);
            v23 = *(unsigned __int8 *)(a1 + 0xD8);
            v65 = *(_DWORD *)v69;
            v71 = v23;
            for ( i = 0; i < 7; ++i )
            {
              if ( (v71 & v22 & (1 << i)) != 0 )
              {
                v21 += 2;
              }
            }
            if ( v65 == dword_D3660 )
            {
              v21 += 2;
            }
            *(_WORD *)(v6 + 5) = v21 + *(_WORD *)(v69 + 5);
            *(_WORD *)(v6 + 7) = *(_WORD *)(v69 + 7);
            v25 = *(float *)(v69 + 0xD) + 1.0;
            *(_DWORD *)(v6 + 0x11) = 0;
            *(float *)(v6 + 0xD) = v25;
          }
        }
        sub_254BC((int)v64, v6);
      }
    }
    else
    {
      v67 = *(_DWORD *)v6;
      sub_53384((float *)(v67 + 8), v68, (float *)v55);
      *(_DWORD *)(v6 + 0x11) = 0xFFFFFFFF;
      if ( v56 > (double)*(float *)(a1 + 0x106) && v56 < (double)*(float *)(a1 + 0x10A) )
      {
        sub_533D4(
          (float *)v55,
          *(float *)(a1 + 0x102),
          *(__int16 *)(a1 + 0x576),
          *(__int16 *)(a1 + 0x578),
          (int)v75,
          (int)&v74);
        *(_WORD *)(v6 + 5) = v75[0];
        *(_WORD *)(v6 + 7) = v74;
        *(float *)(v6 + 0xD) = v56;
        v8 = v66;
        *(_DWORD *)(v6 + 0x11) = 0;
        sub_254BC((int)v8, v6);
      }
    }
LABEL_29:
    v6 += 0x15;
    v7 = v70 + 0x15;
    ++v63;
  }
  sub_254DC(v66);
}
// 91060: using guessed type float flt_91060;
// D3660: using guessed type int dword_D3660;
// 2422C: using guessed type _WORD var_1C[14];

//----- (00024948) --------------------------------------------------------
int __fastcall sub_24948(int result, int a2, int a3)
{
  int v3; // ebp
  int v4; // ebx
  int v5; // edi
  int v6; // edx
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  __int16 v10; // si
  int i; // ebx
  int v12; // eax
  int v13; // edx
  int v14; // edi
  char v15; // dl
  int v16; // eax
  char *v17; // edi
  char *v18; // esi
  char v19; // al
  char v20; // al
  __int16 j; // si
  int v22; // ebx
  int v23; // edx
  int v24; // ebx
  int v25; // edx
  const char *v26; // ecx
  _DWORD v27[5]; // [esp+0h] [ebp-2Ch] BYREF
  int v28; // [esp+14h] [ebp-18h]
  int v29; // [esp+18h] [ebp-14h]

  v3 = result;
  v28 = a2;
  v29 = a3;
  if ( *(_DWORD *)(result + 0xD4) == 0xFFFFFFFF )
  {
    return result;
  }
  v4 = *(_DWORD *)(result + 0xBB);
  if ( v4 )
  {
    v5 = 0x28;
    v6 = *(__int16 *)(v4 + 5) - v28;
    v7 = *(__int16 *)(v4 + 7) - v29;
    if ( *(_BYTE *)(v4 + 4) == 2 )
    {
      v6 += unk_965F8;
      v5 = 0x14;
      v7 += SHIBYTE(dword_965FD);
    }
    result = v6 * v6 + v7 * v7;
    if ( result <= v5 )
    {
      return result;
    }
    v8 = *(_DWORD *)(v3 + 0x57E);
    *(_DWORD *)(v3 + 0xBB) = 0;
    sub_5A270(&V_Type3_stru_10AE70, v8, 0, 0);
    dword_D85E8 = *(_DWORD *)(v3 + 0x10) - 0x82;
    v9 = *(_DWORD *)(v3 + 0xA7);
    dword_D85EC = *(_DWORD *)(v3 + 0x14) - 0x1B;
    (*(void (__fastcall **)(int, int))(v9 + 0xC))(v3, 0xA);
  }
  v10 = *(_WORD *)(v3 + 0xB7) - 1;
  for ( i = 0x15 * (*(__int16 *)(v3 + 0xB7) - 1) + *(_DWORD *)(v3 + 0xB3); ; i -= 0x15 )
  {
    result = v10;
    if ( v10 < 0 )
    {
      break;
    }
    if ( *(_BYTE *)(i + 4) != 1 )
    {
      v12 = *(__int16 *)(i + 5) - v28;
      v13 = *(__int16 *)(i + 7) - v29;
      v14 = 0x28;
      if ( *(_BYTE *)(i + 4) == 2 )
      {
        v12 += unk_965F8;
        v13 += SHIBYTE(dword_965FD);
        v14 = 0x14;
      }
      result = v13 * v13 + v12 * v12;
      if ( result < v14 )
      {
        *(_DWORD *)(v3 + 0xBB) = i;
        break;
      }
    }
    --v10;
  }
  if ( *(_DWORD *)(v3 + 0xBB) )
  {
    sub_5A270(&V_Type3_stru_10AE70, *(_DWORD *)(v3 + 0x57E) + 1, 0, 0);
    result = *(_DWORD *)(v3 + 0xBB);
    if ( !*(_BYTE *)(result + 4) )
    {
      v27[0] = dword_96654[0];
      v27[1] = dword_96654[1];
      v27[2] = dword_96654[2];
      v27[3] = dword_96654[3];
      v27[4] = dword_96654[4];
      v15 = 1;
      v16 = **(_DWORD **)(v3 + 0xBB);
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(v16 + 0x17)) != 0 )
      {
        v17 = (char *)v27;
        v18 = (char *)(v16 + 0x1C);
        do
        {
          v19 = *v18;
          *v17 = *v18;
          if ( !v19 )
          {
            break;
          }
          v20 = v18[1];
          v18 += 2;
          v17[1] = v20;
          v17 += 2;
        }
        while ( v20 );
        for ( j = 0;
              j < 7
           && (*(_BYTE *)(**(_DWORD **)(v3 + 0xBB) + 0x14) & (unsigned __int8)(*(_BYTE *)(v3 + 0xD9) & v15)) == 0;
              ++j )
        {
          v15 *= 2;
        }
      }
      if ( LOBYTE(v27[0]) )
      {
        v22 = *(_DWORD *)(v3 + 0x14) - 0x1B;
        v23 = *(_DWORD *)(v3 + 0x10) - 0x82;
        *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v23, v22, (const char *)v27, 0, 0xFFFFFFFF, 0xFF, 0);
      }
      v24 = *(_DWORD *)(v3 + 0x14) - 0xC;
      v25 = *(_DWORD *)(v3 + 0x10) - 0x82;
      v26 = &byte_D84C4[0x14 * ***(_DWORD ***)(v3 + 0xBB)];
      *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = V_Type6_stru_D8654.pane;
      return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], v25, v24, v26, 0, 0xFFFFFFFF, 0xFF, 0);
    }
  }
  return result;
}
// 965FD: using guessed type int dword_965FD;
// 96654: using guessed type _DWORD dword_96654[5];
// 968DC: using guessed type char byte_968DC;
// D85E8: using guessed type int dword_D85E8;
// D85EC: using guessed type int dword_D85EC;

//----- (00024BE0) --------------------------------------------------------
int __fastcall sub_24BE0(int a1)
{
  int result; // eax
  int v3; // eax
  int v4; // edx
  int i; // ecx
  _DWORD *v6; // ebx
  __int16 *v7; // ecx
  int v8; // edx

  result = *(_DWORD *)(a1 + 0xBB);
  if ( !*(_BYTE *)(result + 4) )
  {
    if ( *(_DWORD *)(a1 + 0x582) )
    {
      result = *(_DWORD *)result;
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(result + 0x16)) != 0 )
      {
        v4 = result;
        for ( i = 0; i < *(__int16 *)(result + 0x44); ++i )
        {
          v6 = *(_DWORD **)(v4 + 0x2C);
          if ( result == *v6 && v6[1] == **(_DWORD **)(a1 + 0x586)
            || *v6 == **(_DWORD **)(a1 + 0x586) && result == v6[1] )
          {
            v7 = **(__int16 ***)(a1 + 0x586);
            v8 = result;
            sub_1D654(v7, result, (int)v6);
            *(_DWORD *)(a1 + 0x582) = 0;
            sub_24D30(a1, v8, (int)v6, (int)v7);
            sub_2422C(a1, v8, (int)v6, (int)v7);
            return (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          }
          v4 += 4;
        }
      }
    }
    else if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 1 )
    {
      result = *(_DWORD *)result;
      if ( ((unsigned __int8)byte_968DC & *(_BYTE *)(result + 0x17)) != 0 )
      {
        dword_D3660 = result;
        *(_DWORD *)(a1 + 0xBB) = 0;
        return sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 1);
      }
    }
    else if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 0xD )
    {
      dword_D3660 = *(_DWORD *)result;
      v3 = sub_56E18((int)&V_Type3_stru_10AE70, "NEGSCREEN", 0xD, 0);
      if ( !v3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x612);
      }
      sub_32A1C(v3);
      return (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
  }
  return result;
}
// 968DC: using guessed type char byte_968DC;
// D3660: using guessed type int dword_D3660;

//----- (00024D30) --------------------------------------------------------
int __fastcall __spoils<> sub_24D30(int a1, int a2, int a3, int a4)
{
  __int16 i; // di
  __int16 *v6; // esi
  __int16 v7; // bx
  int v8; // esi
  __int16 j; // si
  char *v10; // edi
  __int16 v11; // di
  __int16 k; // si
  int result; // eax
  char *v14; // eax
  int v15[107]; // [esp+0h] [ebp-1D4h] BYREF
  char s[32]; // [esp+1ACh] [ebp-28h] BYREF
  int v17; // [esp+1CCh] [ebp-8h]

  v17 = a4;
  *(_WORD *)(a1 + 0xB7) = 0;
  for ( i = 0; i < word_A62A1; ++i )
  {
    if ( *(_WORD *)(a1 + 0xB7) >= *(_WORD *)(a1 + 0xB9) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x659);
    }
    v6 = &word_A3D21[0x30 * i];
    *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * (*(int *)(a1 + 0xB5) >> 0x10)) = v6;
    *(_BYTE *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * *(__int16 *)(a1 + 0xB7) + 4) = 0;
    v7 = *(_WORD *)(a1 + 0xB7) + 1;
    *(_WORD *)(a1 + 0xB7) = v7;
    if ( *((_BYTE *)v6 + 0x15) )
    {
      if ( v7 >= *(__int16 *)(a1 + 0xB9) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x66B);
      }
      v8 = sub_1D794(&word_A3D21[0x30 * i], v15);
      if ( !v8 && dword_A0CFC == 0xFFFFFFFF )
      {
        sprintf(s, "cos%05d.bug", dword_A2F6C[0]);
        sub_54048(s, (int)"..\\coswnd.cpp", 0x676, a1);
        Q_AssertLogBreakExit_sub_261A8(0, "..\\coswnd.cpp", 0x676);
      }
      if ( v8 > 0 )
      {
        *(_DWORD *)(0x15 * *(__int16 *)(a1 + 0xB7) + *(_DWORD *)(a1 + 0xB3)) = v15[0];
        *(_BYTE *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * (__int16)(*(_WORD *)(a1 + 0xB7))++ + 4) = 2;
      }
    }
  }
  for ( j = 0; j < word_A792F; ++j )
  {
    v10 = (char *)&unk_A62A3 + 0x27 * j;
    if ( ((unsigned __int8)byte_968DC & (unsigned __int8)v10[0x20]) != 0 )
    {
      if ( *(_WORD *)(a1 + 0xB7) >= *(_WORD *)(a1 + 0xB9) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x68B);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * *(__int16 *)(a1 + 0xB7)) = v10;
      *(_BYTE *)(*(_DWORD *)(a1 + 0xB3) + 0x15 * (__int16)(*(_WORD *)(a1 + 0xB7))++ + 4) = 1;
    }
  }
  v11 = 0;
  for ( k = 0; ; ++k )
  {
    result = k;
    if ( k >= 0x6B || v11 >= SHIWORD(dword_D35E5) )
    {
      break;
    }
    if ( *(_WORD *)(a1 + 0xB7) >= *(_WORD *)(a1 + 0xB9) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x698);
    }
    v14 = (char *)&unk_CA1F1 + 0x162 * k;
    if ( *((__int16 *)v14 + 0x2B) != 0xFFFFFFFF )
    {
      ++v11;
      if ( v14[0x58] == 5 )
      {
        *(_DWORD *)(0x15 * *(__int16 *)(a1 + 0xB7) + *(_DWORD *)(a1 + 0xB3)) = v14;
        *(_BYTE *)(0x15 * (__int16)(*(_WORD *)(a1 + 0xB7))++ + *(_DWORD *)(a1 + 0xB3) + 4) = 2;
      }
    }
  }
  return result;
}
// 968DC: using guessed type char byte_968DC;
// A0CFC: using guessed type int dword_A0CFC;
// A2F6C: using guessed type int dword_A2F6C[];
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// A792F: using guessed type __int16 word_A792F;
// D35E5: using guessed type int dword_D35E5;
// 24D30: using guessed type int var_1D4[107];

//----- (00024FCC) --------------------------------------------------------
__int64 __fastcall sub_24FCC(int a1, T_Type1 *a2, int a3)
{
  _DWORD *v4; // ecx
  _DWORD *v5; // edi
  _DWORD *v6; // ebp
  _DWORD *v7; // edx
  _DWORD *v8; // edx
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  int v12; // [esp+0h] [ebp-1A4h] BYREF
  int v13; // [esp+4h] [ebp-1A0h]
  int v14; // [esp+8h] [ebp-19Ch]
  int v15; // [esp+Ch] [ebp-198h]
  int v16; // [esp+10h] [ebp-194h]
  int v17; // [esp+14h] [ebp-190h]
  int v18; // [esp+18h] [ebp-18Ch]
  _BYTE v19[158]; // [esp+1Ch] [ebp-188h] BYREF
  int v20[7]; // [esp+C0h] [ebp-E4h] BYREF
  char v21; // [esp+DCh] [ebp-C8h]
  char v22; // [esp+DDh] [ebp-C7h]
  int v23[40]; // [esp+DEh] [ebp-C6h] BYREF
  P_Type1 v24; // [esp+180h] [ebp-24h]
  _DWORD *v25; // [esp+184h] [ebp-20h]
  _DWORD *v26; // [esp+188h] [ebp-1Ch]
  _DWORD *v27; // [esp+18Ch] [ebp-18h]
  _DWORD *v28; // [esp+190h] [ebp-14h]

  v24 = a2;
  v4 = (_DWORD *)(a1 + 0xDA);
  v25 = (_DWORD *)(a1 + 0x14E);
  v5 = (_DWORD *)(a1 + 0xF2);
  v28 = (_DWORD *)(a1 + 0x10E);
  v6 = (_DWORD *)(a1 + 0x166);
  v27 = (_DWORD *)(a1 + 0xE6);
  v26 = (_DWORD *)(a1 + 0x15A);
  if ( a3 == 0xFFFFFFFF )
  {
    sub_1B4F0(v23);
    sub_1BF94(v24, v20, 0xBEu);
    *(_DWORD *)(a1 + 0xC0) = v20[0];
    *(_DWORD *)(a1 + 0xC4) = v20[1];
    *(_DWORD *)(a1 + 0x58A) = v20[2];
    *(_DWORD *)(a1 + 0xC8) = v20[3];
    *(_DWORD *)(a1 + 0xCC) = v20[4];
    *(_DWORD *)(a1 + 0xD0) = v20[5];
    *(_DWORD *)(a1 + 0xD4) = v20[6];
    *(_BYTE *)(a1 + 0xD8) = v21;
    *(_BYTE *)(a1 + 0xD9) = v22;
    *v4 = v23[0];
    v4[1] = v23[1];
    v4[2] = v23[2];
    v7 = v27;
    *v27 = v23[3];
    v7[1] = v23[4];
    v7[2] = v23[5];
    *v5 = v23[6];
    v5[1] = v23[7];
    v5[2] = v23[8];
    v4[9] = v23[9];
    v4[0xA] = v23[0xA];
    v4[0xB] = v23[0xB];
    v4[0xC] = v23[0xC];
    v8 = v28;
    *v28 = v23[0xD];
    v8[1] = v23[0xE];
    v8[2] = v23[0xF];
    v4[0x10] = v23[0x10];
    v4[0x11] = v23[0x11];
    v4[0x12] = v23[0x12];
    v4[0x13] = v23[0x13];
    v4[0x14] = v23[0x14];
    v4[0x15] = v23[0x15];
    v4[0x16] = v23[0x16];
    v4[0x17] = v23[0x17];
    v4[0x18] = v23[0x18];
    v4[0x19] = v23[0x19];
    v4[0x1A] = v23[0x1A];
    v4[0x1B] = v23[0x1B];
    v4[0x1C] = v23[0x1C];
    v9 = v25;
    *v25 = v23[0x1D];
    v9[1] = v23[0x1E];
    v9[2] = v23[0x1F];
    v10 = v26;
    *v26 = v23[0x20];
    v10[1] = v23[0x21];
    v10[2] = v23[0x22];
    *v6 = v23[0x23];
    v6[1] = v23[0x24];
    v6[2] = v23[0x25];
    *(float *)(a1 + 0x57A) = (float)v23[0x26];
    return (unsigned int)((int (*)(void))locret_1B66C)();
  }
  else
  {
    sub_1B4F0(&v19[2]);
    v12 = *(_DWORD *)(a1 + 0xC0);
    v13 = *(_DWORD *)(a1 + 0xC4);
    v14 = *(_DWORD *)(a1 + 0x58A);
    v15 = *(_DWORD *)(a1 + 0xC8);
    v16 = *(_DWORD *)(a1 + 0xCC);
    v17 = *(_DWORD *)(a1 + 0xD0);
    v18 = *(_DWORD *)(a1 + 0xD4);
    v19[0] = *(_BYTE *)(a1 + 0xD8);
    v19[1] = *(_BYTE *)(a1 + 0xD9);
    *(_DWORD *)&v19[2] = *v4;
    *(_DWORD *)&v19[6] = v4[1];
    *(_DWORD *)&v19[0xA] = v4[2];
    *(_DWORD *)&v19[0xE] = *v27;
    *(_DWORD *)&v19[0x12] = v27[1];
    *(_DWORD *)&v19[0x16] = v27[2];
    *(_DWORD *)&v19[0x1A] = *v5;
    *(_DWORD *)&v19[0x1E] = v5[1];
    *(_DWORD *)&v19[0x22] = v5[2];
    *(_DWORD *)&v19[0x26] = v4[9];
    *(_DWORD *)&v19[0x2A] = v4[0xA];
    *(_DWORD *)&v19[0x2E] = v4[0xB];
    *(_DWORD *)&v19[0x32] = v4[0xC];
    *(_DWORD *)&v19[0x36] = *v28;
    *(_DWORD *)&v19[0x3A] = v28[1];
    *(_DWORD *)&v19[0x3E] = v28[2];
    *(_DWORD *)&v19[0x42] = v4[0x10];
    *(_DWORD *)&v19[0x46] = v4[0x11];
    *(_DWORD *)&v19[0x4A] = v4[0x12];
    *(_DWORD *)&v19[0x4E] = v4[0x13];
    *(_DWORD *)&v19[0x52] = v4[0x14];
    *(_DWORD *)&v19[0x56] = v4[0x15];
    *(_DWORD *)&v19[0x5A] = v4[0x16];
    *(_DWORD *)&v19[0x5E] = v4[0x17];
    *(_DWORD *)&v19[0x62] = v4[0x18];
    *(_DWORD *)&v19[0x66] = v4[0x19];
    *(_DWORD *)&v19[0x6A] = v4[0x1A];
    *(_DWORD *)&v19[0x6E] = v4[0x1B];
    *(_DWORD *)&v19[0x72] = v4[0x1C];
    *(_DWORD *)&v19[0x76] = *v25;
    *(_DWORD *)&v19[0x7A] = v25[1];
    *(_DWORD *)&v19[0x7E] = v25[2];
    *(_DWORD *)&v19[0x82] = *v26;
    *(_DWORD *)&v19[0x86] = v26[1];
    *(_DWORD *)&v19[0x8A] = v26[2];
    *(_DWORD *)&v19[0x8E] = *v6;
    *(_DWORD *)&v19[0x92] = v6[1];
    *(_DWORD *)&v19[0x96] = v6[2];
    *(_DWORD *)&v19[0x9A] = (int)*(float *)(a1 + 0x57A);
    sub_1C098((unsigned int)v24, (int)&v12, 0xBEu);
    return (unsigned int)((int (__cdecl *)(int, int, int, int, int, int, int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))locret_1B66C)(
                           v12,
                           v13,
                           v14,
                           v15,
                           v16,
                           v17,
                           v18,
                           *(_DWORD *)v19,
                           *(_DWORD *)&v19[4],
                           *(_DWORD *)&v19[8],
                           *(_DWORD *)&v19[0xC],
                           *(_DWORD *)&v19[0x10],
                           *(_DWORD *)&v19[0x14],
                           *(_DWORD *)&v19[0x18],
                           *(_DWORD *)&v19[0x1C],
                           *(_DWORD *)&v19[0x20],
                           *(_DWORD *)&v19[0x24],
                           *(_DWORD *)&v19[0x28],
                           *(_DWORD *)&v19[0x2C],
                           *(_DWORD *)&v19[0x30],
                           *(_DWORD *)&v19[0x34],
                           *(_DWORD *)&v19[0x38],
                           *(_DWORD *)&v19[0x3C],
                           *(_DWORD *)&v19[0x40],
                           *(_DWORD *)&v19[0x44],
                           *(_DWORD *)&v19[0x48],
                           *(_DWORD *)&v19[0x4C],
                           *(_DWORD *)&v19[0x50],
                           *(_DWORD *)&v19[0x54],
                           *(_DWORD *)&v19[0x58],
                           *(_DWORD *)&v19[0x5C],
                           *(_DWORD *)&v19[0x60],
                           *(_DWORD *)&v19[0x64],
                           *(_DWORD *)&v19[0x68],
                           *(_DWORD *)&v19[0x6C],
                           *(_DWORD *)&v19[0x70],
                           *(_DWORD *)&v19[0x74],
                           *(_DWORD *)&v19[0x78],
                           *(_DWORD *)&v19[0x7C],
                           *(_DWORD *)&v19[0x80],
                           *(_DWORD *)&v19[0x84],
                           *(_DWORD *)&v19[0x88],
                           *(_DWORD *)&v19[0x8C],
                           *(_DWORD *)&v19[0x90],
                           *(_DWORD *)&v19[0x94],
                           *(_DWORD *)&v19[0x98]);
  }
}

//----- (000254A4) --------------------------------------------------------
int __fastcall sub_254A4(int a1)
{
  sub_254B0(a1);
  return a1;
}

//----- (000254B0) --------------------------------------------------------
int __fastcall sub_254B0(int result)
{
  *(_DWORD *)(result + 0x400) = 0;
  return result;
}

//----- (000254BC) --------------------------------------------------------
int __fastcall sub_254BC(int result, int a2)
{
  int v2; // ebx

  v2 = *(_DWORD *)(result + 0x400);
  if ( v2 < 0x100 )
  {
    if ( a2 )
    {
      *(_DWORD *)(result + 4 * v2) = a2;
      ++*(_DWORD *)(result + 0x400);
    }
  }
  return result;
}

//----- (000254DC) --------------------------------------------------------
void __fastcall sub_254DC(size_t *a1)
{
  qsort(a1, a1[0x100], 4u, sub_22430);
}

//----- (000254F8) --------------------------------------------------------
void __fastcall sub_254F8(int *a1, int a2)
{
  int v2; // esi
  unsigned __int8 v3; // al
  LONG v4; // edi
  int v5; // ebp
  int v6; // ecx
  int v7; // ebx
  LONG v8; // eax
  int v9; // ebp
  int v10; // eax
  char v11; // dl
  int v12; // edi
  int v13; // ecx
  LONG v14; // [esp-Ch] [ebp-78h]
  LONG v15; // [esp-8h] [ebp-74h]
  int v16; // [esp-8h] [ebp-74h]
  PANE *v17; // [esp+0h] [ebp-6Ch]
  int *v19; // [esp+8h] [ebp-64h]
  int v20; // [esp+Ch] [ebp-60h]
  T_Type5 *v21; // [esp+10h] [ebp-5Ch]
  int v22; // [esp+14h] [ebp-58h]
  PANE *v23; // [esp+18h] [ebp-54h]
  T_Type5 *v24; // [esp+1Ch] [ebp-50h]
  PANE *v25; // [esp+20h] [ebp-4Ch]
  T_Type5 *v26; // [esp+24h] [ebp-48h]
  int v27; // [esp+28h] [ebp-44h]
  PANE *v28; // [esp+2Ch] [ebp-40h]
  PANE *pane; // [esp+30h] [ebp-3Ch]
  __int16 *v30; // [esp+34h] [ebp-38h]
  int v31; // [esp+38h] [ebp-34h]
  int i; // [esp+40h] [ebp-2Ch]
  __int16 v34; // [esp+44h] [ebp-28h]
  __int16 j; // [esp+48h] [ebp-24h]
  unsigned __int8 v36; // [esp+4Ch] [ebp-20h]
  char v37; // [esp+50h] [ebp-1Ch]
  char v38; // [esp+54h] [ebp-18h]

  VFX_pane_wipe((PANE *)(a2 + 4), *(unsigned __int8 *)(a2 + 0xBF));
  v19 = a1;
  v36 = 4 * byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  v27 = 0;
  if ( a1[0x100] > 0 )
  {
    v28 = (PANE *)(a2 + 4);
    v26 = (T_Type5 *)(a2 + 4);
    v25 = (PANE *)(a2 + 4);
    v21 = (T_Type5 *)(a2 + 4);
    pane = (PANE *)(a2 + 4);
    v17 = (PANE *)(a2 + 4);
    v23 = (PANE *)(a2 + 4);
    v24 = (T_Type5 *)(a2 + 4);
    do
    {
      v2 = *v19;
      v3 = *(_BYTE *)(*v19 + 4);
      v20 = (int)(*(float *)(*v19 + 0xD) + flt_910EA);
      if ( v3 )
      {
        if ( v3 <= 1u )
        {
          if ( *(_DWORD *)(a2 + 0xC4) || *(_DWORD *)(a2 + 0x58A) )
          {
            v6 = 7;
            v7 = *(_DWORD *)v2;
            if ( v20 <= 0xDC )
            {
              if ( v20 <= 0x93 )
              {
                if ( v20 <= 0x49 )
                {
                  if ( v20 <= 0 )
                  {
                    if ( v20 <= (int)0xFFFFFFB7 )
                    {
                      if ( v20 <= (int)0xFFFFFF6D )
                      {
                        if ( v20 > (int)0xFFFFFF24 )
                        {
                          v6 = 6;
                        }
                      }
                      else
                      {
                        v6 = 5;
                      }
                    }
                    else
                    {
                      v6 = 4;
                    }
                  }
                  else
                  {
                    v6 = 3;
                  }
                }
                else
                {
                  v6 = 2;
                }
              }
              else
              {
                v6 = 1;
              }
            }
            else
            {
              v6 = 0;
            }
            if ( *(_DWORD *)(a2 + 0x58A) == 0xFFFFFFFF )
            {
              if ( *(_WORD *)(v7 + 0x21) )
              {
                v8 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x10 + v6 / 2;
              }
              else
              {
                v8 = v6 + 0x30;
              }
            }
            else
            {
              v8 = v6 + 0x68;
            }
            if ( !*(_DWORD *)(a2 + 0x58A) && (*(_BYTE *)(v7 + 0x23) & 1) != 0 )
            {
              v8 = v6 / 2 + 0x70;
            }
            VFX_line_draw(
              v23,
              *(__int16 *)(v2 + 5),
              *(__int16 *)(v2 + 7),
              *(__int16 *)(v2 + 9),
              *(__int16 *)(v2 + 0xB),
              0,
              v8);
          }
        }
        else if ( v3 == 2 && *(_DWORD *)(a2 + 0xC8) )
        {
          v9 = 3;
          v10 = *(_DWORD *)v2;
          if ( v20 <= 0xDC )
          {
            if ( v20 <= 0 )
            {
              if ( v20 > (int)0xFFFFFF24 )
              {
                v9 = 2;
              }
            }
            else
            {
              v9 = 1;
            }
          }
          else
          {
            v9 = 0;
          }
          v11 = *(_BYTE *)(v10 + 0x58);
          if ( v11 == 5 )
          {
            if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*(_DWORD *)(v10 + 0x59) + 0x20)) != 0
              && ((1 << *(_WORD *)(v10 + 0x56)) & *(unsigned __int8 *)(a2 + 0xD8)) != 0 )
            {
              sub_53EB8(
                v24,
                *(_DWORD *)(a2 + 0xAF),
                v9,
                *(__int16 *)(v2 + 5),
                *(__int16 *)(v2 + 7),
                *(_WORD *)(v10 + 0x56));
            }
          }
          else
          {
            v37 = 1;
            if ( v11 == 4 )
            {
              v30 = *(__int16 **)(v10 + 0x59);
            }
            else
            {
              v30 = &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(v10 + 0x59) + 0xC)];
            }
            if ( !v30 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x822);
            }
            if ( ((1 << byte_104BEA) & *((unsigned __int8 *)v30 + 0x17)) != 0 )
            {
              v12 = 0;
              for ( i = 0; SHIWORD(dword_A3CF2) > i; ++i )
              {
                if ( (*(_BYTE *)(a2 + 0xD8) & (unsigned __int8)(v37 & *((_BYTE *)v30 + 0x15))) != 0 )
                {
                  v16 = *(__int16 *)(v2 + 7) + (*(int *)((char *)&dword_965FD + v12) >> 0x18);
                  v13 = *(__int16 *)(v2 + 5) + (*(int *)&aCosdip[v12++ + 5] >> 0x18);
                  sub_53EB8(v21, *(_DWORD *)(a2 + 0xAF), v9, v13, v16, i);
                }
                v37 *= 2;
              }
            }
          }
        }
      }
      else
      {
        v22 = *(_DWORD *)v2;
        v31 = 3;
        if ( v20 <= 0xDC )
        {
          if ( v20 <= 0 )
          {
            if ( v20 > (int)0xFFFFFF24 )
            {
              v31 = 2;
            }
          }
          else
          {
            v31 = 1;
          }
        }
        else
        {
          v31 = 0;
        }
        VFX_shape_draw(v17, *(void **)(a2 + 0xAB), v31 + 4 * *(_DWORD *)v22, *(__int16 *)(v2 + 5), *(__int16 *)(v2 + 7));
        v34 = *(_WORD *)&V_Type3_stru_10AE70.z1[0x4228];
        v4 = 4;
        if ( (((1 << byte_104BEA) & *(unsigned __int8 *)(v22 + 0x17)) != 0
           || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 3)
          && *(_DWORD *)(a2 + 0xCC)
          && *(_BYTE *)(v22 + 0x14) )
        {
          v5 = 0;
          v38 = 1;
          do
          {
            if ( (*(_BYTE *)(a2 + 0xD8) & (unsigned __int8)(*(_BYTE *)(v22 + 0x14) & v38)) != 0 )
            {
              v15 = v4;
              v14 = v4;
              v4 += 2;
              VFX_ellipse_draw(
                pane,
                *(__int16 *)(v2 + 5),
                *(__int16 *)(v2 + 7),
                v14,
                v15,
                v31 + (unsigned __int8)(4 * byte_A2F74[v5] + 0x13) - 3);
            }
            v5 += 0x1EE;
            v38 *= 2;
          }
          while ( v5 != 0xD82 );
        }
        if ( v22 == dword_D3660 && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 3 )
        {
          VFX_ellipse_draw(v25, *(__int16 *)(v2 + 5), *(__int16 *)(v2 + 7), v4, v4, 0xF3);
        }
        if ( (((1 << byte_104BEA) & *(unsigned __int8 *)(v22 + 0x17)) != 0 || v34 == 3)
          && (*(_BYTE *)(v22 + 0x14) & 0x80) != 0
          && *(_DWORD *)(a2 + 0xD0) == 0xFFFFFFFF )
        {
          for ( j = 0; j < SHIWORD(dword_A3CF2); ++j )
          {
            if ( v22 == *(int *)((char *)&dword_A2F79 + 0x1EE * j) )
            {
              break;
            }
          }
          if ( j >= SHIWORD(dword_A3CF2) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\coswnd.cpp", 0x786);
          }
          if ( (*(_BYTE *)(a2 + 0xD8) & (unsigned __int8)(1 << j)) != 0
            || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 3 )
          {
            sub_53E38(v26, *(__int16 *)(v2 + 5) - 7, *(__int16 *)(v2 + 7) + 3, j);
          }
        }
        if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(v22 + 0x17)) != 0
          && *(_DWORD *)(a2 + 0xCC)
          && ((1 << byte_104BEA) & *(unsigned __int8 *)(v22 + 0x14)) == 0 )
        {
          VFX_pixel_write(v28, *(__int16 *)(v2 + 5) - 4, *(__int16 *)(v2 + 7), v36);
          VFX_pixel_write(v28, *(__int16 *)(v2 + 5), *(__int16 *)(v2 + 7) - 4, v36);
          VFX_pixel_write(v28, *(__int16 *)(v2 + 5) + 4, *(__int16 *)(v2 + 7), v36);
          VFX_pixel_write(v28, *(__int16 *)(v2 + 5), *(__int16 *)(v2 + 7) + 4, v36);
        }
      }
      ++v27;
      ++v19;
    }
    while ( v27 < a1[0x100] );
  }
}
// 910EA: using guessed type float flt_910EA;
// 965FD: using guessed type int dword_965FD;
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// D3660: using guessed type int dword_D3660;

//----- (00025BF8) --------------------------------------------------------
void __fastcall __spoils<> sub_25BF8(P_TypeA2 a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95B9C;
}
// 95B9C: using guessed type int (*off_95B9C[5])();

//----- (00025C08) --------------------------------------------------------
void *__fastcall sub_25C08(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95B48);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95B9C;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95B9C: using guessed type int (*off_95B9C[5])();

//----- (00025C4C) --------------------------------------------------------
void __fastcall sub_25C4C(unsigned int a1, int a2)
{
  int v3; // edi
  __int16 v4; // si
  T_Type5 *v5; // ebp

  sub_2CD24(a1, a2);
  v3 = 0x2F;
  v4 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    v5 = (T_Type5 *)(a1 + 4);
    do
    {
      if ( v4 == (unsigned __int8)byte_104BEA || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v4] )
      {
        sub_53E38(v5, (__int16)v3, 3, v4);
        v3 += 0x10;
      }
      ++v4;
    }
    while ( v4 < SHIWORD(dword_A3CF2) );
  }
  JUMPOUT(0x25BF1);
}
// 25C69: control flows out of bounds to 25BF1
// A3CF2: using guessed type int dword_A3CF2;

//----- (00025CB8) --------------------------------------------------------
int __fastcall sub_25CB8(int result)
{
  sub_2C830((P_TypeA2)result);
  *(_DWORD *)(result + 0xA7) = off_95B84;
  *(_WORD *)(result + 0xAB) = 0;
  return result;
}
// 95B84: using guessed type int (*off_95B84[5])();

//----- (00025CD4) --------------------------------------------------------
void *__fastcall sub_25CD4(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95B34);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95B84;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95B84: using guessed type int (*off_95B84[5])();

//----- (00025D18) --------------------------------------------------------
void __fastcall sub_25D18(int result, LONG a2)
{
  unsigned int v3; // esi
  int v4; // ecx
  unsigned __int8 v5; // al
  __int16 v6; // cx
  __int16 i; // ax
  char *sub_1CEA8; // eax
  char *v9; // eax
  __int16 v10; // eax^2
  _DWORD *v11; // esi
  const char *v12; // ecx
  _DWORD *v13; // esi
  int v14; // ecx
  LONG v15; // ebx
  void *v16; // eax
  __int16 v17; // [esp-8h] [ebp-68h]
  int v18; // [esp-4h] [ebp-64h]
  char s[52]; // [esp+0h] [ebp-60h] BYREF
  int v20; // [esp+34h] [ebp-2Ch]
  int v21; // [esp+38h] [ebp-28h]
  char *v22; // [esp+3Ch] [ebp-24h]
  LONG color; // [esp+40h] [ebp-20h]
  int v24; // [esp+44h] [ebp-1Ch]
  char v25; // [esp+48h] [ebp-18h]

  if ( *(_DWORD *)(result + 0x39) )
  {
    v3 = 0xFFFFFFFF;
    v24 = 0;
    color = 0xF2;
    if ( a2 )
    {
      color = a2;
    }
    v4 = *(__int16 *)(result + 0xAB);
    v20 = *(int *)((char *)&dword_A2F75 + 0x1EE * v4);
    v25 = byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v4];
    if ( !v25 || v20 )
    {
      v24 = 0xFFFFFFFF;
    }
    else
    {
      v5 = *((_BYTE *)&byte_A2F73 + 0x1EE * v4);
      v21 = 4 * (unsigned __int8)byte_A2F74[0x1EE * v4] + 0x13;
      v22 = &byte_1050A4[0x14 * v5];
    }
    if ( *(_WORD *)(result + 0xAB) == (unsigned __int8)byte_104BEA )
    {
      v6 = 0;
      for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
      {
        if ( i != (unsigned __int8)byte_104BEA && byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + i] )
        {
          ++v6;
        }
      }
      v18 = SHIWORD(dword_A3CF2) - 1;
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xB);// 11: "%d of %d Species Known"
      sprintf(s, sub_1CEA8, v6, v18);
      v22 = s;
      v24 = 0;
      v21 = 0xF3;
      color = 0xF2;
      v3 = 0;
    }
    if ( v20 == 0xFFFFFFFF )
    {
      v9 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xC);    // 12: "Extinct"
      sprintf(s, v9);
      v22 = s;
      v21 = 0xF3;
      v24 = 0;
    }
    if ( !v24 )
    {
      if ( v3 == 0xFFFFFFFF )
      {
        VFX_pane_wipe((PANE *)(result + 4), color);
        v17 = color;
        v10 = v21;
        v11 = (_DWORD *)(result + 4);
      }
      else
      {
        v10 = v21;
        v11 = (_DWORD *)(result + 4);
        v17 = 0xFF;
      }
      v12 = v22;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *v11;
      v13 = v11 + 1;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *v13++;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *v13++;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *v13;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v13[1];
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, v12, 0x43, v10, v17, 0);
    }
    if ( v25 )
    {
      v14 = *(__int16 *)(result + 0xAB);
      if ( v14 != (unsigned __int8)byte_104BEA && v24 != 0xFFFFFFFF )
      {
        sub_53E38((P_Type5)(result + 4), 0xE, 3, v14);
        v15 = 0xFFFFFFFF;
        if ( !v20 )
        {
          if ( v25 == 3 )
          {
            v15 = 9;
          }
          else if ( v25 == 2 )
          {
            v15 = 8;
          }
        }
        if ( v15 != 0xFFFFFFFF )
        {
          v16 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
          VFX_shape_draw((PANE *)(result + 4), v16, v15, 0xE, 3);
        }
      }
    }
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(result + 4));
  }
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// FFEF2: using guessed type __int16 word_FFEF2;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00025FB4) --------------------------------------------------------
int __fastcall sub_25FB4(int result)
{
  if ( *(_DWORD *)(result + 0x39) )
  {
    return (*(int (**)(void))(*(_DWORD *)(result + 0xA7) + 0xC))();
  }
  return result;
}

//----- (00026000) --------------------------------------------------------
unsigned int __fastcall sub_26000(int a1, __int16 a2, __int16 a3, int a4)
{
  __int16 v5; // ax
  unsigned int result; // eax
  LONG v7; // ecx
  LONG v8; // edx
  LONG v9; // ebx
  int v10; // eax
  int v11; // [esp-4h] [ebp-14h]

  switch ( a2 )
  {
    case 1:
      v5 = *(char *)(a1 + 0x25) - 0x31;
      *(_WORD *)(a1 + 0xAB) = v5;
      if ( v5 < SHIWORD(dword_A3CF2) )
      {
        goto LABEL_10;
      }
      result = 0;
      break;
    case 2:
      *(_DWORD *)(a1 + 0x39) = 0;
      v7 = *(_DWORD *)(a1 + 0x10);
      v8 = *(_DWORD *)(a1 + 8);
      v11 = *(_DWORD *)(a1 + 0x14);
      v9 = *(_DWORD *)(a1 + 0xC);
      *(_DWORD *)(a1 + 0x35) = 0;
      sub_55214((int)&V_Type3_stru_10AE70, v8, v9, v7, v11);
      result = 0;
      break;
    case 4:
    case 5:
      v10 = *(__int16 *)(a1 + 0xAB);
      if ( byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v10]
        && v10 != (unsigned __int8)byte_104BEA
        && *(int *)((char *)&dword_A2F75 + 0x1EE * v10) != 0xFFFFFFFF )
      {
        byte_968DD = *(_BYTE *)(a1 + 0xAB);
        goto LABEL_10;
      }
      result = 0;
      break;
    case 6:
      goto LABEL_13;
    case 7:
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0x10))();
      result = 0xFFFFFFFF;
      break;
    case 0xB:
      *(_WORD *)(a1 + 0xAB) = a3;
LABEL_13:
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
      result = 0xFFFFFFFF;
      break;
    case 0xD:
      (*(void (__fastcall **)(int, _DWORD, __int16, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0, a3, a4);
      result = sub_2F424(a1, a2, a3, a4);
      break;
    default:
LABEL_10:
      result = sub_2F424(a1, a2, a3, a4);
      break;
  }
  return result;
}
// 968DD: using guessed type char byte_968DD;
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00026140) --------------------------------------------------------
int __fastcall sub_26140(int a1)
{
  return ((int (__fastcall *)(int, _DWORD))locret_1B66C)(a1 + 0x1E, 0) - 0x1E;
}

//----- (00026150) --------------------------------------------------------
char *__fastcall sub_26150(int a1)
{
  return (char *)sub_1B4F0((_DWORD *)(a1 + 0x1E)) + 0xFFFFFFE2;
}

//----- (00026160) --------------------------------------------------------
int sub_26160()
{
  sub_2632C();
  sub_2C6CC(&V_Type6_stru_D8654);
  sub_4FE8C((int)&unk_10914C);
  return printf("\n%s\n\n", "Thank you for playing Ascendancy.");
}

//----- (00026194) --------------------------------------------------------
void Q_debugbreak_sub_26194()
{
  __debugbreak();
}

//----- (00026198) --------------------------------------------------------
void __fastcall __noreturn Q_AssertLogBreakExit_sub_26198(int ignore, const char *sourcefile, int line)
{
  if ( !ignore )
  {
    sprintf("Thank you for playing Ascendancy.", "Assert Failed: <%s> Line %d\n\n", sourcefile, line);
    Q_debugbreak_exit_sub_2624C();
  }
  JUMPOUT(0x26195);
}
// 2619A: control flows out of bounds to 26195

//----- (000261A8) --------------------------------------------------------
void __fastcall __noreturn Q_AssertLogBreakExit_sub_261A8(int ignore, const char *sourcefile, int line)
{
  if ( !ignore )
  {
    sprintf("Thank you for playing Ascendancy.", "Assert Failed: <%s> Line %d\n\n", sourcefile, line);
    Q_debugbreak_exit_sub_2624C();
  }
  JUMPOUT(0x26195);
}
// 261AA: control flows out of bounds to 26195

//----- (000261B8) --------------------------------------------------------
int __fastcall sub_261B8(int result, const char *a2, int a3)
{
  const char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char v7[264]; // [esp+0h] [ebp-108h] BYREF

  if ( !result )
  {
    v3 = "Thank you for playing Ascendancy.";
    v4 = v7;
    do
    {
      v5 = *v3;
      *v4 = *v3;
      if ( !v5 )
      {
        break;
      }
      v6 = v3[1];
      v3 += 2;
      v4[1] = v6;
      v4 += 2;
    }
    while ( v6 );
    sprintf("Thank you for playing Ascendancy.", "Assert Failed: <%s> Line %d\n\n%s\n", a2, a3, v7);
    Q_debugbreak_exit_sub_2624C();
  }
  return result;
}

//----- (0002620C) --------------------------------------------------------
int __cdecl sub_2620C(char *format, char a2)
{
  char *v3; // [esp+0h] [ebp-Ch] BYREF

  v3 = &a2;
  return vsprintf("Thank you for playing Ascendancy.", format, &v3);
}

//----- (0002624C) --------------------------------------------------------
void __noreturn Q_debugbreak_exit_sub_2624C()
{
  Q_debugbreak_sub_26194();
  exit(1);
}

//----- (0002625C) --------------------------------------------------------
void __fastcall __spoils<edx,ebx> sub_2625C(void *aData, int a2, char *a3)
{
  if ( aData )
  {
    Q_WINMGR_CPP_sub_5A094(&V_Type3_stru_10AE70, aData, a2, a3);
  }
}

//----- (0002627C) --------------------------------------------------------
void __fastcall sub_2627C(void *a1)
{
  Q_WINMGR_CPP_sub_5A144(&V_Type3_stru_10AE70, a1);
}

//----- (0002628C) --------------------------------------------------------
void *__fastcall sub_2628C(size_t a1, int a2, char *s2)
{
  void *result; // eax
  void *v4; // esi

  result = malloc(a1);
  v4 = result;
  if ( result )
  {
    Q_WINMGR_CPP_sub_5A094(&V_Type3_stru_10AE70, result, a2, s2);
    return v4;
  }
  return result;
}

//----- (000262B0) --------------------------------------------------------
void *__fastcall sub_262B0(size_t a1, size_t a2, int a3, char *a4)
{
  void *result; // eax
  void *v5; // esi

  result = calloc(a1, a2);
  v5 = result;
  if ( result )
  {
    Q_WINMGR_CPP_sub_5A094(&V_Type3_stru_10AE70, result, a3, a4);
    return v5;
  }
  return result;
}

//----- (000262CC) --------------------------------------------------------
void __fastcall sub_262CC(void *ptr)
{
  Q_WINMGR_CPP_sub_5A144(&V_Type3_stru_10AE70, ptr);
  free(ptr);
}

//----- (000262F0) --------------------------------------------------------
void sub_262F0()
{
  _wcpp_2_mod_register_(&unk_96768);
  sub_26314();
  dword_96770 = 1;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96770: using guessed type int dword_96770;

//----- (00026314) --------------------------------------------------------
void sub_26314()
{
  ;
}

//----- (0002631C) --------------------------------------------------------
void sub_2631C()
{
  sub_2632C();
  sub_26328();
}

//----- (0002632C) --------------------------------------------------------
void sub_2632C()
{
  if ( dword_D8628 )
  {
    MOUSE_shutdown();
  }
  else
  {
    sub_26328();
  }
}
// D8628: using guessed type int dword_D8628;

//----- (0002633C) --------------------------------------------------------
int __fastcall sub_2633C(int a1, int a2, LONG a3)
{
  dword_D8628 = MOUSE_init(640, 480, a3);
  return (dword_D8628 == 0) - 1;
}
// D8628: using guessed type int dword_D8628;

//----- (00026360) --------------------------------------------------------
__int16 __fastcall __spoils<> sub_26360(__int16 a1)
{
  bool v1; // zf
  int v2; // eax

  HIBYTE(a1) = 2;
  __asm { int     16h; KEYBOARD - GET SHIFT STATUS }
  HIWORD(dword_D8622) = a1;
  if ( (a1 & 1) != 0 || (a1 & 2) != 0 )
  {
    a3 = 0xFFFFFFFF;
  }
  else
  {
    a3 = 0;
  }
  dword_D8604 = ((a1 & 4) == 0) - 1;
  dword_D8600 = ((a1 & 8) == 0) - 1;
  dword_D8614 = ((a1 & 0x10) == 0) - 1;
  dword_D8610 = ((a1 & 0x20) == 0) - 1;
  dword_D860C = ((a1 & 0x40) == 0) - 1;
  v2 = ((a1 & 0x80) == 0) - 1;
  v1 = v2 == 0;
  dword_D8618 = v2;
  BYTE1(v2) = 1;
  __asm { int     16h; KEYBOARD - CHECK BUFFER, DO NOT CLEAR }
  if ( v1 )
  {
    LOWORD(v2) = 0;
  }
  if ( (_WORD)v2 )
  {
    __asm { int     16h; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY }
    LOWORD(dword_D8622) = (unsigned __int8)v2;
    LOWORD(v2) = 0;
    dword_D85FC = 0xFFFFFFFF;
    word_D8620 = 0;
  }
  else
  {
    dword_D85FC = 0;
  }
  return v2;
}
// D85FC: using guessed type int dword_D85FC;
// D8600: using guessed type int dword_D8600;
// D8604: using guessed type int dword_D8604;
// D860C: using guessed type int dword_D860C;
// D8610: using guessed type int dword_D8610;
// D8614: using guessed type int dword_D8614;
// D8618: using guessed type int dword_D8618;
// D8620: using guessed type __int16 word_D8620;
// D8622: using guessed type int dword_D8622;

//----- (000264B4) --------------------------------------------------------
LONG sub_264B4()
{
  LONG result; // eax
  LONG mx; // [esp+0h] [ebp-2Ch] BYREF
  LONG my; // [esp+4h] [ebp-28h] BYREF
  LONG ml; // [esp+8h] [ebp-24h] BYREF
  LONG mr; // [esp+Ch] [ebp-20h] BYREF
  int mc[7]; // [esp+10h] [ebp-1Ch] BYREF

  MOUSE_status(&mx, &my, &ml, &mr, mc);
  if ( mx == new_x && (result = my, my == dword_D864C) )
  {
    dword_D8644 = 0;
  }
  else
  {
    new_x = mx;
    result = my;
    dword_D8644 = 0xFFFFFFFF;
    dword_D864C = my;
  }
  if ( ml == dword_D862C )
  {
    dword_D8638 = 0;
  }
  else
  {
    result = 0xFFFFFFFF;
    dword_D862C = ml;
    dword_D8638 = 0xFFFFFFFF;
  }
  if ( mr == dword_D8630 )
  {
    dword_D863C = 0;
  }
  else
  {
    dword_D8630 = mr;
    dword_D863C = 0xFFFFFFFF;
  }
  return result;
}
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// 264B4: using guessed type LONG mc;

//----- (0002656C) --------------------------------------------------------
int __fastcall sub_2656C(__int16 a1)
{
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D8644 = 0;
  dword_D85FC = 0;
  sub_26360(a1);
  if ( dword_D8628 )
  {
    sub_264B4();
  }
  return dword_96774;
}
// 96774: using guessed type int dword_96774;
// D85FC: using guessed type int dword_D85FC;
// D8628: using guessed type int dword_D8628;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;

//----- (000265A8) --------------------------------------------------------
void __fastcall sub_265A8(int a1)
{
  unsigned __int16 v1; // dx
  LONG v2; // edx
  LONG v3; // eax
  __int16 v4; // dx
  __int16 v5; // dx

  dword_D8644 = 0;
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D85FC = 0;
  v1 = *(_WORD *)(a1 + 8);
  if ( v1 < 2u )
  {
    if ( v1 == 1 )
    {
      v2 = *(_DWORD *)(a1 + 0xC);
      v3 = *(_DWORD *)(a1 + 0x10);
      new_x = v2;
      dword_D864C = v3;
      MOUSE_force_move(v2, v3);
      dword_D8644 = 0xFFFFFFFF;
    }
  }
  else if ( v1 <= 2u )
  {
    if ( *(_DWORD *)(a1 + 0xC) )
    {
      dword_D8630 = *(_DWORD *)(a1 + 0x10);
      dword_D863C = 0xFFFFFFFF;
    }
    else
    {
      dword_D862C = *(_DWORD *)(a1 + 0x10);
      v4 = *(_WORD *)(a1 + 0xA);
      dword_D8638 = 0xFFFFFFFF;
      if ( v4 && dword_D862C )
      {
        a3 = 0xFFFFFFFF;
      }
      else
      {
        a3 = 0;
      }
    }
  }
  else if ( v1 == 3 )
  {
    HIWORD(dword_D8622) = *(_WORD *)(a1 + 0xA);
    v5 = *(_WORD *)(a1 + 0xC);
    LOWORD(dword_D8622) = *(_WORD *)(a1 + 0x10);
    word_D8620 = v5;
    dword_D85FC = 0xFFFFFFFF;
    if ( (dword_D8622 & 0x10000) != 0 || (dword_D8622 & 0x20000) != 0 )
    {
      a3 = 0xFFFFFFFF;
    }
    else
    {
      a3 = 0;
    }
    dword_D8604 = ((dword_D8622 & 0x40000) == 0) - 1;
    dword_D8600 = ((dword_D8622 & 0x80000) == 0) - 1;
    dword_D8614 = ((dword_D8622 & 0x100000) == 0) - 1;
    dword_D8610 = ((dword_D8622 & 0x200000) == 0) - 1;
    dword_D860C = ((dword_D8622 & 0x400000) == 0) - 1;
    if ( (dword_D8622 & 0x800000) != 0 )
    {
      dword_D8618 = 0xFFFFFFFF;
    }
    else
    {
      dword_D8618 = 0;
    }
  }
}
// D85FC: using guessed type int dword_D85FC;
// D8600: using guessed type int dword_D8600;
// D8604: using guessed type int dword_D8604;
// D860C: using guessed type int dword_D860C;
// D8610: using guessed type int dword_D8610;
// D8614: using guessed type int dword_D8614;
// D8618: using guessed type int dword_D8618;
// D8620: using guessed type __int16 word_D8620;
// D8622: using guessed type int dword_D8622;
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;

//----- (000267A0) --------------------------------------------------------
void __fastcall __spoils<> sub_267A0(P_TypeA5 a1)
{
  sub_2FC50(&a1->a);
  a1->a.b = (int)off_95C70;
  sub_26800(a1);
}
// 95C70: using guessed type int (*off_95C70[5])();

//----- (000267BC) --------------------------------------------------------
void *__fastcall sub_267BC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95C2C);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95C70;
    v5 = sub_2FC68(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95C70: using guessed type int (*off_95C70[5])();

//----- (00026800) --------------------------------------------------------
void __fastcall __spoils<> sub_26800(P_TypeA5 result)
{
  result->b[0x341] = 0;
}

//----- (00026874) --------------------------------------------------------
char __fastcall sub_26874(int a1, __int16 *a2)
{
  char *v3; // edi
  char *v4; // esi
  char v5; // al
  char v6; // al
  __int16 *v7; // ebx
  int v8; // edx
  int v9; // esi
  __int16 v10; // kr00_2
  char *v11; // eax
  unsigned __int8 v12; // bl
  int v13; // ebx
  _WORD *v14; // edx
  int v15; // ebx
  int v16; // esi
  int v17; // ebx
  int v18; // eax
  int v19; // esi
  int v20; // edx
  int v21; // eax
  int v22; // eax
  char *v23; // eax
  int v24; // edx
  int v25; // edi
  int v26; // esi
  int v27; // edi
  int v28; // esi
  _DWORD *v29; // edi
  int v30; // eax
  int v31; // edx
  __int16 v32; // bx
  int v33; // edx
  int v34; // eax
  int v35; // edx
  int v36; // eax
  int v37; // ebx
  __int16 v38; // ax
  int v39; // ecx
  __int16 v40; // ax
  int v41; // edx
  int v42; // edx
  int v43; // edx
  int v45; // [esp-8h] [ebp-298h]
  char *sub_1CEA8; // [esp-4h] [ebp-294h]
  char format[600]; // [esp+0h] [ebp-290h] BYREF
  char s[32]; // [esp+258h] [ebp-38h] BYREF
  int v49; // [esp+27Ch] [ebp-14h]
  int v50; // [esp+280h] [ebp-10h]
  int v51; // [esp+284h] [ebp-Ch]
  int v52; // [esp+288h] [ebp-8h]
  int v53; // [esp+28Ch] [ebp-4h]

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x48);
  }
  *(_DWORD *)(a1 + 0xDAF) = a2;
  sprintf(s, "event%02d", *a2);
  sub_2FCB0((_DWORD *)a1, "help.txt", s);
  v50 = a1 + 0xC95;
  v53 = a1 + 0xCB0;
  if ( *(_BYTE *)(a1 + 0xC95) != 1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x55);
  }
  if ( *(int *)(a1 + 0xDA3) > 1 && *(_BYTE *)v53 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x57);
  }
  v3 = format;
  v4 = *(char **)(v50 + 5);
  do
  {
    v5 = *v4;
    *v3 = *v4;
    if ( !v5 )
    {
      break;
    }
    v6 = v4[1];
    v4 += 2;
    v3[1] = v6;
    v3 += 2;
  }
  while ( v6 );
  v7 = *(__int16 **)(a1 + 0xDAF);
  v8 = *(_DWORD *)(v7 + 1);
  v9 = *(_DWORD *)(v7 + 3);
  v10 = *v7;
  v52 = v8 + 0x24;
  v51 = v9 + 0x24;
  v49 = 5 * v8;
  v11 = &byte_10525A[0x4B * v8];
  switch ( v10 )
  {
    case 0:
      sprintf(
        *(char **)(v50 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
        &byte_10525A[0x4B * v8]);
      v11 = (char *)v53;
      *(_WORD *)(v53 + 1) = 0x1F;
      *(_WORD *)(v11 + 3) = v8;
      break;
    case 1:
      v12 = *((_BYTE *)v7 + 6);
      sprintf(
        *(char **)(v50 + 5),
        format,
        &dword_103F9A[0xA * v12 + 3],
        v52,
        v52,
        *(unsigned __int16 *)(v8 + 0x42) - *(unsigned __int16 *)(v8 + 0x4C));
      *(_WORD *)(v53 + 1) = 0x1E;
      *(_WORD *)(v53 + 3) = v12;
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = *(_WORD *)(v8 + 0x14);
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * *(_WORD *)(v8 + 0x16);
      break;
    case 2:
      v32 = v7[1];
      sprintf(*(char **)(v50 + 5), format, &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v32)]);
      v11 = (char *)v53;
      *(_WORD *)(v53 + 3) = 0;
      *(_WORD *)(v11 + 1) = v32;
      break;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 0x14:
      v18 = *(_DWORD *)(a1 + 0xDAF);
      v19 = *(_DWORD *)(v18 + 2);
      if ( *(_BYTE *)(v19 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xB3);
      }
      v20 = *(_DWORD *)(v19 + 0x59);
      if ( **(_WORD **)(a1 + 0xDAF) == 0x14 )
      {
        if ( *(_WORD *)(v20 + 0x44) == 1 )
        {
          v21 = 0xD;
        }
        else
        {
          v21 = 0xE;
        }
        sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v21);
        v45 = *(__int16 *)(v20 + 0x44);
        if ( *(_WORD *)(v20 + 0x5A) == 1 )
        {
          v22 = 0xD;
        }
        else
        {
          v22 = 0xE;
        }
        v23 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v22);
        sprintf(*(char **)(v50 + 5), format, v19 + 0x34, v20 + 0x1C, *(__int16 *)(v20 + 0x5A), v23, v45, sub_1CEA8);
      }
      else
      {
        sprintf(
          *(char **)(v50 + 5),
          format,
          v19 + 0x34,
          v20 + 0x1C,
          &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(_DWORD *)(v18 + 6))]);
      }
      v24 = v53;
      *(_WORD *)(v53 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      LOWORD(v11) = *(char *)(v19 + 0xAA);
      *(_WORD *)(v24 + 3) = (_WORD)v11;
      break;
    case 8:
    case 9:
      v25 = *(_DWORD *)(a1 + 0xDAF);
      v26 = *(_DWORD *)(v25 + 2);
      v27 = *(_DWORD *)(v25 + 6);
      if ( *(_BYTE *)(v26 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xCD);
      }
      if ( **(_WORD **)(a1 + 0xDAF) == 9 )
      {
        sprintf(
          *(char **)(v50 + 5),
          format,
          &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v27)],
          *(_DWORD *)(v26 + 0x59) + 0x1C);
      }
      else
      {
        sprintf(*(char **)(v50 + 5), format, *(_DWORD *)(v26 + 0x59) + 0x1C);
      }
      *(_WORD *)(v53 + 1) = v27 + 0xE;
      LOWORD(v11) = *(char *)(v26 + 0xAA);
      *(_WORD *)(v53 + 3) = (_WORD)v11;
      break;
    case 0xA:
      sprintf(*(char **)(v50 + 5), format, &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v8)]);
      v33 = v53;
      LOWORD(v11) = *(_WORD *)(*(_DWORD *)(a1 + 0xDAF) + 2);
      *(_WORD *)(v53 + 3) = 0;
      *(_WORD *)(v33 + 1) = (_WORD)v11;
      break;
    case 0xB:
    case 0xC:
      v34 = *(_DWORD *)(a1 + 0xDAF);
      v35 = *(_DWORD *)(v34 + 2);
      v36 = *(_DWORD *)(v34 + 6);
      if ( v36 )
      {
        sprintf(*(char **)(v50 + 5), format, v36 + 0x1C);
      }
      v37 = v53;
      v38 = (unsigned __int8)byte_104BEA;
      *(_WORD *)(v53 + 3) = v35;
      LOWORD(v11) = v38 + 0xE;
      *(_WORD *)(v37 + 1) = (_WORD)v11;
      break;
    case 0xD:
      v39 = v8;
      if ( !v8 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x114);
      }
      sprintf(
        *(char **)(v50 + 5),
        format,
        v8 + 0x24,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(unsigned __int8 *)(v8 + 0x57))]);
      v40 = sub_1B270((int)dword_12FC20, "data\\planets.shp", 0);
      v41 = v53;
      *(_WORD *)(v53 + 1) = v40;
      if ( *(unsigned __int16 *)(v41 + 1) == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x118);
      }
      LOWORD(v11) = 5 * *(_WORD *)(v39 + 0x16) + *(_WORD *)(v39 + 0x14);
      *(_WORD *)(v53 + 3) = (_WORD)v11;
      break;
    case 0xF:
      sprintf(*(char **)(v50 + 5), format, v52);
      *(_WORD *)(v53 + 1) = 0x1D;
      LOWORD(v11) = 5 * *(_WORD *)(v8 + 0x16) + *(_WORD *)(v8 + 0x14);
      *(_WORD *)(v53 + 3) = (_WORD)v11;
      *(_WORD *)(a1 + 0xCCC) = 0x2C;
      *(_WORD *)(a1 + 0xCCE) = 2;
      break;
    case 0x10:
      sprintf(*(char **)(v50 + 5), format, v8 + 0x34, v51);
      v17 = v53;
      *(_WORD *)(v53 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      *(_WORD *)(v17 + 3) = *(char *)(v8 + 0xAA);
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = *(_WORD *)(v9 + 0x14);
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * *(_WORD *)(v9 + 0x16);
      break;
    case 0x11:
    case 0x12:
      v13 = *(_DWORD *)(a1 + 0xDAF);
      v14 = *(_WORD **)(v13 + 6);
      v15 = *(_DWORD *)(v13 + 2);
      sprintf(
        *(char **)(v50 + 5),
        format,
        v15 + 0x34,
        v14 + 0x12,
        v14 + 0x12,
        (unsigned __int16)v14[0x21] - (unsigned __int16)v14[0x26]);
      v16 = v53;
      *(_WORD *)(v53 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      *(_WORD *)(v16 + 3) = *(char *)(v15 + 0xAA);
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = v14[0xA];
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * v14[0xB];
      break;
    case 0x13:
      LOBYTE(v11) = sprintf(*(char **)(v50 + 5), format, v8 + 0x1C);
      break;
    case 0x15:
      v42 = v53;
      sprintf(
        *(char **)(v50 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)]);
      *(_WORD *)(v42 + 3) = 0;
      LOBYTE(v11) = byte_104BEA;
      *(_WORD *)(v42 + 1) = (unsigned __int8)byte_104BEA;
      break;
    case 0x16:
      sprintf(
        *(char **)(v50 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
        v51,
        &byte_10525A[0x4B * v8]);
      v11 = (char *)v53;
      *(_WORD *)(v53 + 1) = 0x1F;
      *(_WORD *)(v11 + 3) = v8;
      *(_WORD *)(a1 + 0xCCC) = 0x1D;
      LOWORD(v11) = *(_WORD *)(v9 + 0x14);
      *(_WORD *)(a1 + 0xCCE) = (_WORD)v11 + 5 * *(_WORD *)(v9 + 0x16);
      break;
    case 0x17:
      v28 = v8;
      if ( *(_BYTE *)(v8 + 0x58) != 5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xE0);
      }
      v29 = *(_DWORD **)(v8 + 0x59);
      if ( !v29 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0xE3);
      }
      v30 = *v29;
      if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*v29 + 0x17)) == 0 )
      {
        v30 = v29[1];
      }
      sprintf(*(char **)(v50 + 5), format, v8 + 0x34, v30 + 0x1C);
      v31 = v53;
      *(_WORD *)(v53 + 1) = (unsigned __int8)byte_104BEA + 0xE;
      LOWORD(v11) = *(char *)(v28 + 0xAA);
      *(_WORD *)(v31 + 3) = (_WORD)v11;
      break;
    case 0x19:
      sprintf(
        *(char **)(v50 + 5),
        format,
        &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)]);
      v43 = v53;
      LOBYTE(v11) = byte_104BEA;
      *(_WORD *)(v53 + 3) = 0;
      *(_WORD *)(v43 + 1) = (unsigned __int8)v11;
      break;
    default:
      return (char)v11;
  }
  return (char)v11;
}
// 26D02: conditional instruction was optimized away because bh.1!=4
// 103F9A: using guessed type int dword_103F9A[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (000270F4) --------------------------------------------------------
unsigned int __fastcall sub_270F4(int a1, __int16 a2, int a3, int a4)
{
  int v5; // ebx

  if ( !a2 || (unsigned __int16)a2 > 1u )
  {
    return sub_2FD68(a1, a2, a3, a4);
  }
  *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
  v5 = *(_DWORD *)(a1 + 0xA7);
  *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
  (*(void (**)(void))(v5 + 0xC))();
  return 0;
}

//----- (0002712C) --------------------------------------------------------
void __fastcall __spoils<> sub_2712C(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95C58;
}
// 95C58: using guessed type int (*off_95C58[5])();

//----- (0002713C) --------------------------------------------------------
void *__fastcall sub_2713C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95C18);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95C58;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95C58: using guessed type int (*off_95C58[5])();

//----- (00027184) --------------------------------------------------------
unsigned int __fastcall sub_27184(int a1, __int16 a2, int a3, int a4)
{
  if ( !a2 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 1u )
  {
    sub_4F8CC((int)&unk_10914C, *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA) + 8, 0);
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( a2 != 2 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  sub_56B60((int)&V_Type3_stru_10AE70, 1, 1, 1);
  return 0xFFFFFFFF;
}

//----- (000271FC) --------------------------------------------------------
__int64 __fastcall sub_271FC(int a1)
{
  int v1; // ecx
  FILE *v2; // ebp
  char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char *v7; // esi
  char *v8; // edi
  char v9; // al
  char v10; // al
  char *v11; // esi
  char *v12; // edi
  char v13; // al
  char v14; // al
  char *v15; // esi
  char *v16; // edi
  char v17; // al
  char v18; // al
  char *v19; // esi
  char *v20; // edi
  char v21; // al
  char v22; // al
  char *v23; // esi
  char *v24; // edi
  char v25; // al
  char v26; // al
  char *v27; // ecx
  int v28; // esi
  char v29; // ah
  char v30; // bl
  char *v31; // ecx
  int v32; // esi
  char v33; // al
  char v34; // dh
  void *v35; // eax
  unsigned __int8 v36; // al
  const char *v37; // ecx
  int v38; // esi
  unsigned __int8 v39; // al
  char v41[1004]; // [esp+0h] [ebp-624h] BYREF
  char s[204]; // [esp+3ECh] [ebp-238h] BYREF
  char v43[204]; // [esp+4B8h] [ebp-16Ch] BYREF
  char s1[60]; // [esp+584h] [ebp-A0h] BYREF
  T_Type5 v45; // [esp+5C0h] [ebp-64h] BYREF
  int v46; // [esp+5D4h] [ebp-50h]
  char *v47; // [esp+5D8h] [ebp-4Ch]
  int v48; // [esp+5DCh] [ebp-48h]
  int v49; // [esp+5E0h] [ebp-44h] BYREF
  int v50; // [esp+5E4h] [ebp-40h]
  int v51; // [esp+5E8h] [ebp-3Ch]
  int v52; // [esp+5ECh] [ebp-38h]
  int v53; // [esp+5F0h] [ebp-34h]
  int v54; // [esp+5F4h] [ebp-30h]
  int v55; // [esp+5F8h] [ebp-2Ch]
  int v56; // [esp+5FCh] [ebp-28h]
  int v57; // [esp+600h] [ebp-24h]
  char *v58; // [esp+604h] [ebp-20h]
  int v59; // [esp+608h] [ebp-1Ch]
  int v60; // [esp+60Ch] [ebp-18h]

  v46 = a1;
  v1 = *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA);
  v58 = (char *)buffer;
  buffer[0] = 0;
  v41[0] = 0;
  v2 = sub_1BB10("history.txt", 0);
  if ( !v2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x1C1);
  }
  v51 = 0;
  do
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
    sscanf(s, "%s", s1);
    if ( !stricmp(s1, "SPECNUM") )
    {
      sscanf(s, "%s %d", s1, &v49);
      if ( v1 == v49 )
      {
        v51 = 1;
      }
    }
    else if ( !stricmp(s1, "END") )
    {
      sub_2620C("Species %d not found in history file.\n", v1);
      sub_261B8(0, "..\\eventwnd.cpp", 0x1E8);
    }
  }
  while ( !v51 );
  v48 = 0;
  if ( v51 != 2 )
  {
    v47 = &byte_1050A4[0x14 * v1];
    do
    {
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
      sscanf(s, "%s", s1);
      if ( !stricmp(s1, "SPECNUM") || !stricmp(s1, "END") )
      {
        v51 = 2;
      }
      else if ( !stricmp(s1, "POWER") )
      {
        v53 = 0;
        v56 = 0;
        sprintf(v43, "%s: ", v47);
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDPOWER", 8u) )
          {
            v53 = 0xFFFFFFFF;
          }
          else
          {
            v56 += strlen(s);
            if ( v56 >= 0xC4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x238);
            }
            v3 = s;
            v4 = &v43[strlen(v43)];
            do
            {
              v5 = *v3;
              *v4 = *v3;
              if ( !v5 )
              {
                break;
              }
              v6 = v3[1];
              v3 += 2;
              v4[1] = v6;
              v4 += 2;
            }
            while ( v6 );
          }
        }
        while ( !v53 );
      }
      else if ( !stricmp(s1, "INTRO") )
      {
        v59 = 0;
        v55 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDINTRO", 8u) )
          {
            v59 = 0xFFFFFFFF;
            v48 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x24D);
            }
            v7 = s;
            v8 = &v41[strlen(v41)];
            do
            {
              v9 = *v7;
              *v8 = *v7;
              if ( !v9 )
              {
                break;
              }
              v10 = v7[1];
              v7 += 2;
              v8[1] = v10;
              v8 += 2;
            }
            while ( v10 );
          }
        }
        while ( !v59 );
      }
      else if ( !stricmp(s1, "PEACE") && v48 == 0xFFFFFFFF && !byte_A3D20 )
      {
        v50 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDPEACE", 8u) )
          {
            v50 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x25F);
            }
            v11 = s;
            v12 = &v41[strlen(v41)];
            do
            {
              v13 = *v11;
              *v12 = *v11;
              if ( !v13 )
              {
                break;
              }
              v14 = v11[1];
              v11 += 2;
              v12[1] = v14;
              v12 += 2;
            }
            while ( v14 );
          }
        }
        while ( !v50 );
      }
      else if ( !stricmp(s1, "NEUTRAL") && v48 == 0xFFFFFFFF && byte_A3D20 == 1 )
      {
        v57 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDNEUTRAL", 0xAu) )
          {
            v57 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x271);
            }
            v15 = s;
            v16 = &v41[strlen(v41)];
            do
            {
              v17 = *v15;
              *v16 = *v15;
              if ( !v17 )
              {
                break;
              }
              v18 = v15[1];
              v15 += 2;
              v16[1] = v18;
              v16 += 2;
            }
            while ( v18 );
          }
        }
        while ( !v57 );
      }
      else if ( !stricmp(s1, "HOSTILE") && v48 == 0xFFFFFFFF && byte_A3D20 == 2 )
      {
        v52 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDHOSTILE", 0xAu) )
          {
            v52 = 0xFFFFFFFF;
          }
          else
          {
            v55 += strlen(s);
            if ( v55 >= 0x3E4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x283);
            }
            v19 = s;
            v20 = &v41[strlen(v41)];
            do
            {
              v21 = *v19;
              *v20 = *v19;
              if ( !v21 )
              {
                break;
              }
              v22 = v19[1];
              v19 += 2;
              v20[1] = v22;
              v20 += 2;
            }
            while ( v22 );
          }
        }
        while ( !v52 );
      }
      else if ( !stricmp(s1, "TEXT") )
      {
        v60 = 0;
        v54 = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v2, s);
          if ( !strnicmp(s, "ENDTEXT", 7u) )
          {
            v60 = 0xFFFFFFFF;
          }
          else
          {
            v54 += strlen(s);
            if ( v54 >= 0xBB4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x295);
            }
            v23 = s;
            v24 = &v58[strlen(v58)];
            do
            {
              v25 = *v23;
              *v24 = *v23;
              if ( !v25 )
              {
                break;
              }
              v26 = v23[1];
              v23 += 2;
              v24[1] = v26;
              v24 += 2;
            }
            while ( v26 );
          }
        }
        while ( !v60 );
      }
    }
    while ( v51 != 2 );
  }
  v27 = v41;
  fclose(v2);
  v28 = 0;
  if ( v41[0] )
  {
    while ( 1 )
    {
      if ( v28 >= 0x3E5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x2AB);
      }
      v29 = *v27;
      if ( *v27 == 0xA )
      {
        break;
      }
      if ( v29 == 0x40 )
      {
        *v27 = 0xA;
      }
      else if ( v29 == 0x5F )
      {
        break;
      }
LABEL_95:
      v30 = *++v27;
      ++v28;
      if ( !v30 )
      {
        goto LABEL_96;
      }
    }
    *v27 = 0x20;
    goto LABEL_95;
  }
LABEL_96:
  if ( !v58 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x2B7);
  }
  v31 = v58;
  v32 = 0;
  if ( *v58 )
  {
    while ( 1 )
    {
      if ( v32 >= 0xBB5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x2BD);
      }
      v33 = *v31;
      if ( *v31 == 0xA )
      {
        break;
      }
      if ( v33 == 0x40 )
      {
        *v31 = 0xA;
      }
      else if ( v33 == 0x5F )
      {
        break;
      }
LABEL_106:
      v34 = *++v31;
      ++v32;
      if ( !v34 )
      {
        goto LABEL_107;
      }
    }
    *v31 = 0x20;
    goto LABEL_106;
  }
LABEL_107:
  v35 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEAE[(unsigned __int8)byte_104BEA]);
  VFX_shape_draw(&V_Type6_stru_D8654.pane, v35, 0, 7, 0x2E);
  v45.a = *(P_Type6 *)(v46 + 4);
  v45.rect.x2 = 0x278;
  v45.rect.x1 = 7;
  v45.rect.y1 = 0x105;
  v45.rect.y2 = 0x1D1;
  v36 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v37 = v58;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v45.a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = 7;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v45.rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v45.rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v45.rect.y2;
  v38 = v46;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0xA, v37, 0, 4 * v36 + 0x13, 0xFF, 0x257);
  v45.a = *(P_Type6 *)(v38 + 4);
  v45.rect.x2 = 0x278;
  v45.rect.y2 = 0xF5;
  v45.rect.x1 = 0x138;
  v45.rect.y1 = 0x2E;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v45.a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = 0x138;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v45.rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v45.rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v45.rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0xA, v41, 0, 0xF3, 0xFF, 0x126);
  v45.a = *(P_Type6 *)(v46 + 4);
  v45.rect.x1 = 7;
  v45.rect.y1 = 7;
  v45.rect.x2 = 0x278;
  v45.rect.y2 = 0x25;
  sub_53E38(&v45, 3, 3, (unsigned __int8)byte_104BEA);
  v39 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v45;
  return (unsigned int)sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xA, v43, 2, 4 * v39 + 0x13, 0xFF, 0x25A);
}
// A3D20: using guessed type char byte_A3D20;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEAE: using guessed type __int16 word_FFEAE[7];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 271FC: using guessed type char var_624[1004];
// 271FC: using guessed type char var_16C[204];

//----- (00027BF8) --------------------------------------------------------
void __fastcall __spoils<> sub_27BF8(P_TypeA2 a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95C40;
}
// 95C40: using guessed type int (*off_95C40[5])();

//----- (00027C08) --------------------------------------------------------
void *__fastcall sub_27C08(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95C04);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95C40;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95C40: using guessed type int (*off_95C40[5])();

//----- (00027C50) --------------------------------------------------------
unsigned int __fastcall sub_27C50(int a1, __int16 a2, int a3, int a4)
{
  __int16 v5; // ax
  char v7[2]; // [esp+0h] [ebp-10h] BYREF
  __int16 v8[7]; // [esp+2h] [ebp-Eh]

  v8[1] = a2;
  if ( a2 != 1 )
  {
    return sub_2F424(a1, v8[1], a3, a4);
  }
  LOBYTE(v8[0]) = 0;
  v7[1] = 0;
  v7[0] = 0;
  sub_2C2F8((int)&V_Type6_stru_D8654, v7);
  v5 = 5;
  dword_132B64 = 0;
  dword_132B60 = 0xFFFFFFFF;
  if ( byte_D366C == 1 )
  {
    v5 = *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA) + 8;
  }
  sub_4F8CC((int)&unk_10914C, v5, 0);
  return sub_2F424(a1, v8[1], a3, a4);
}
// D366C: using guessed type char byte_D366C;
// 132B60: using guessed type int dword_132B60;
// 132B64: using guessed type int dword_132B64;

//----- (00027D18) --------------------------------------------------------
void __fastcall sub_27D18(int a1, int a2, int a3, int a4)
{
  LONG v4; // eax
  FILE *v5; // ebp
  char *v6; // esi
  char *v7; // edi
  char v8; // al
  char v9; // al
  char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  LONG v14; // ebx
  LONG v15; // ecx
  char *v16; // esi
  char *v17; // edi
  char v18; // al
  char v19; // al
  char *v20; // ecx
  char v21; // bh
  char v22; // dl
  char *v23; // ecx
  char v24; // bl
  char v25; // ah
  char *v26; // ecx
  char v27; // dh
  char v28; // al
  void *v29; // eax
  unsigned __int8 v30; // al
  int v31; // ebp
  char *sub_1CEA8; // eax
  unsigned __int8 v33; // al
  unsigned __int8 v34; // al
  const char *v35; // ecx
  void *v36; // eax
  LONG v37; // edi
  LONG v38; // esi
  LONG v39; // ebx
  void *v40; // eax
  int v41; // eax
  void *v42; // eax
  __int16 v43; // bp
  int v44; // eax
  char v45; // dl
  int v46; // esi
  signed int v47; // eax
  __int16 *v48; // edi
  unsigned int v49; // ebp
  int v50; // eax
  int v51; // eax
  LONG v52; // ebx
  int v53; // ecx
  LONG v54; // ecx
  void *v55; // eax
  int v56; // esi
  int v57; // eax
  char *v58; // edi
  unsigned int v59; // ebp
  char v60; // al
  LONG v61; // ebx
  int v62; // ecx
  int v63; // eax
  LONG y0; // edx
  int v65; // ecx
  void *v66; // eax
  LONG v67; // ebp
  int v68; // edi
  LONG v69; // esi
  void *v70; // eax
  LONG v71; // [esp-20h] [ebp-378h]
  LONG v72; // [esp-20h] [ebp-378h]
  LONG v73; // [esp-20h] [ebp-378h]
  LONG v74; // [esp-1Ch] [ebp-374h]
  LONG v75; // [esp-18h] [ebp-370h]
  LONG v76; // [esp-18h] [ebp-370h]
  LONG v77; // [esp-Ch] [ebp-364h]
  __int16 v78; // [esp-4h] [ebp-35Ch]
  char v79[204]; // [esp+0h] [ebp-358h] BYREF
  char v80[204]; // [esp+CCh] [ebp-28Ch] BYREF
  char v81[204]; // [esp+198h] [ebp-1C0h] BYREF
  char s1[60]; // [esp+264h] [ebp-F4h] BYREF
  PANE pane; // [esp+2A0h] [ebp-B8h] BYREF
  char s[16]; // [esp+2B4h] [ebp-A4h] BYREF
  __int16 *v85; // [esp+2C4h] [ebp-94h]
  int v86; // [esp+2C8h] [ebp-90h]
  int v87; // [esp+2CCh] [ebp-8Ch]
  LONG shape_number; // [esp+2D0h] [ebp-88h]
  int assert; // [esp+2D4h] [ebp-84h]
  int v90; // [esp+2D8h] [ebp-80h]
  int v91; // [esp+2DCh] [ebp-7Ch]
  LONG v92; // [esp+2E0h] [ebp-78h]
  int v93; // [esp+2E4h] [ebp-74h]
  int v94; // [esp+2E8h] [ebp-70h]
  int v95; // [esp+2ECh] [ebp-6Ch]
  int v96; // [esp+2F0h] [ebp-68h]
  int v97; // [esp+2F4h] [ebp-64h]
  int v98; // [esp+2F8h] [ebp-60h]
  int v99; // [esp+2FCh] [ebp-5Ch]
  int v100; // [esp+300h] [ebp-58h]
  int v101; // [esp+304h] [ebp-54h]
  int v102; // [esp+308h] [ebp-50h]
  int v103; // [esp+30Ch] [ebp-4Ch]
  int v104; // [esp+310h] [ebp-48h]
  char *v105; // [esp+314h] [ebp-44h]
  int v106; // [esp+318h] [ebp-40h]
  int v107; // [esp+31Ch] [ebp-3Ch]
  PANE *v108; // [esp+320h] [ebp-38h]
  unsigned int v109; // [esp+324h] [ebp-34h]
  int v110; // [esp+328h] [ebp-30h]
  LONG hotX; // [esp+32Ch] [ebp-2Ch]
  int v112; // [esp+330h] [ebp-28h]
  int v113; // [esp+334h] [ebp-24h]
  int v114; // [esp+338h] [ebp-20h]
  int v115; // [esp+33Ch] [ebp-1Ch]
  int v116; // [esp+340h] [ebp-18h]

  v86 = a1;
  v87 = dword_D3668;
  v4 = dword_D3668 / 0xA - 1;
  shape_number = v4;
  if ( v4 >= 0 )
  {
    if ( v4 > 9 )
    {
      shape_number = 9;
    }
  }
  else
  {
    shape_number = 0;
  }
  buffer[0] = 0;
  assert = (int)buffer;
  switch ( byte_D366C )
  {
    case 1:
      sprintf(s, "end-xtnc.txt");
      break;
    case 2:
      sprintf(s, "end-dest.txt");
      break;
    case 3:
      sprintf(s, "end-capt.txt");
      break;
    case 4:
      sprintf(s, "end-unit.txt");
      break;
    case 5:
      sprintf(s, "end-ctrl.txt");
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\eventwnd.cpp", 0x34E);
  }
  v5 = sub_1BB10(s, 0);
  if ( !v5 )
  {
    sub_2620C("Couldn't open %s", (char)s);
    sub_261B8(0, "..\\eventwnd.cpp", 0x370);
  }
  v79[0] = 0;
  v91 = 0;
  do
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
    sscanf(v81, "%s", s1);
    if ( !stricmp(s1, "END") )
    {
      v91 = 0xFFFFFFFF;
    }
    else if ( !stricmp(s1, "ENDDESC") )
    {
      v99 = 0;
      v100 = 0;
      do
      {
        Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
        if ( !strnicmp(v81, "ENDTEXT", 7u) )
        {
          v99 = 0xFFFFFFFF;
        }
        else
        {
          v100 += strlen(v81);
          if ( v100 >= 0xC4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3A1);
          }
          v6 = v81;
          v7 = &v79[strlen(v79)];
          do
          {
            v8 = *v6;
            *v7 = *v6;
            if ( !v8 )
            {
              break;
            }
            v9 = v6[1];
            v6 += 2;
            v7[1] = v9;
            v7 += 2;
          }
          while ( v9 );
        }
      }
      while ( !v99 );
    }
    else if ( !stricmp(s1, "CONGRAT") )
    {
      v101 = 0;
      v102 = 0;
      do
      {
        Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
        if ( !strnicmp(v81, "ENDTEXT", 7u) )
        {
          v101 = 0xFFFFFFFF;
        }
        else
        {
          v102 += strlen(v81);
          if ( v102 >= 0x3E4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3B3);
          }
          v10 = v81;
          v11 = (char *)(assert + strlen((const char *)assert));
          do
          {
            v12 = *v10;
            *v11 = *v10;
            if ( !v12 )
            {
              break;
            }
            v13 = v10[1];
            v10 += 2;
            v11[1] = v13;
            v11 += 2;
          }
          while ( v13 );
        }
      }
      while ( !v101 );
    }
    else if ( !stricmp(s1, "RANKS") )
    {
      v14 = 0;
      if ( shape_number > 0 )
      {
        v15 = shape_number;
        do
        {
          ++v14;
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
        }
        while ( v14 < v15 );
      }
      v16 = v81;
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v81);
      v80[0] = 0;
      v17 = &v80[strlen(v80)];
      do
      {
        v18 = *v16;
        *v17 = *v16;
        if ( !v18 )
        {
          break;
        }
        v19 = v16[1];
        v16 += 2;
        v17[1] = v19;
        v17 += 2;
      }
      while ( v19 );
    }
  }
  while ( v91 != 0xFFFFFFFF );
  v20 = v79;
  fclose(v5);
  v92 = 0;
  if ( v79[0] )
  {
    while ( 1 )
    {
      if ( v92 >= 0xC5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3D7);
      }
      v21 = *v20;
      if ( *v20 == 0xA )
      {
        break;
      }
      if ( v21 == 0x40 )
      {
        *v20 = 0xA;
      }
      else if ( v21 == 0x5F )
      {
        break;
      }
LABEL_55:
      v22 = *++v20;
      ++v92;
      if ( !v22 )
      {
        goto LABEL_56;
      }
    }
    *v20 = 0x20;
    goto LABEL_55;
  }
LABEL_56:
  v92 = 0;
  v23 = v80;
  if ( v80[0] )
  {
    while ( 1 )
    {
      if ( v92 >= 0xC5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3E9);
      }
      v24 = *v23;
      if ( *v23 == 0xA )
      {
        break;
      }
      if ( v24 == 0x40 )
      {
        *v23 = 0xA;
      }
      else if ( v24 == 0x5F )
      {
        break;
      }
LABEL_64:
      v25 = *++v23;
      ++v92;
      if ( !v25 )
      {
        goto LABEL_65;
      }
    }
    *v23 = 0x20;
    goto LABEL_64;
  }
LABEL_65:
  if ( !assert )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3F5);
  }
  v26 = (char *)assert;
  v92 = 0;
  if ( *(_BYTE *)assert )
  {
    while ( 1 )
    {
      if ( v92 >= 0x3E5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\eventwnd.cpp", 0x3FB);
      }
      v27 = *v26;
      if ( *v26 == 0xA )
      {
        break;
      }
      if ( v27 == 0x40 )
      {
        *v26 = 0xA;
      }
      else if ( v27 == 0x5F )
      {
        break;
      }
LABEL_75:
      v28 = *++v26;
      ++v92;
      if ( !v28 )
      {
        goto LABEL_76;
      }
    }
    *v26 = 0x20;
    goto LABEL_75;
  }
LABEL_76:
  pane.window = *(WINDOW **)(v86 + 4);
  pane.x0 = 7;
  pane.y0 = 0xD7;
  pane.x1 = 0x12F;
  pane.y1 = 0x17D;
  if ( byte_D366C != 1 )
  {
    v77 = shape_number;
    v29 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF6);
    VFX_shape_draw(&pane, v29, v77, 0x94, 0x53);
  }
  pane.x1 = 0x12F;
  pane.x0 = 7;
  pane.y0 = 0xD7;
  pane.y1 = 0x107;
  sprintf(v81, "%s", v79);
  v30 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v31 = v87;
  *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = pane;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xE, 0, v81, 1, 4 * v30 + 0x13, 0xFF, 0x118);
  pane.x1 = 0x12F;
  pane.y1 = 0x17D;
  pane.x0 = 7;
  pane.y0 = 0x14D;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xF); // 15: "Your score is %d%%.\nThis gives you the title of %s"
  sprintf(v81, sub_1CEA8, v31, v80);
  v33 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = pane;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, v81, 3, 4 * v33 + 0x13, 0xFF, 0x118);
  pane.x1 = 0x278;
  pane.x0 = 7;
  pane.y0 = 0x18D;
  pane.y1 = 0x1D1;
  v34 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v35 = (const char *)assert;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = pane.window;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = 7;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = pane.y0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = pane.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = pane.y1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 7, 0, v35, 1, 4 * v34 + 0x13, 0xFF, 0x25A);
  v36 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEAE[(unsigned __int8)byte_104BEA]);
  v37 = 0x2A;
  VFX_shape_draw(&V_Type6_stru_D8654.pane, v36, 0, 7, 7);
  v92 = 1;
  v109 = 2;
  v38 = 0x15B;
  sub_53E38((P_Type5)(v86 + 4), 0xA, 0xA, (unsigned __int8)byte_104BEA);
  while ( 1 )
  {
    v41 = SHIWORD(dword_A3CF2);
    if ( SHIWORD(dword_A3CF2) <= v92 )
    {
      break;
    }
    if ( v92 == 4 )
    {
      v38 = 0x15B;
      v37 = 0x85;
    }
    v42 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[v109 / 2]);
    VFX_shape_transform(&V_Type6_stru_D8654.pane, v42, 0, v38, v37, buffer, 0, 0x8000, 0x8000, 0);
    v43 = v92;
    v78 = v92;
    v44 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8((P_Type5)&V_Type6_stru_D8654.pane, v44, 3, v38, v37, v78);
    sub_53E38((P_Type5)&V_Type6_stru_D8654.pane, v38 - 7, v37 + 0x21, v43);
    v45 = byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA + 0x1C0 + v92];
    v39 = 0xFFFFFFFF;
    if ( v45 == 3 )
    {
      v39 = 9;
    }
    else if ( v45 == 2 )
    {
      v39 = 8;
    }
    if ( v39 != 0xFFFFFFFF )
    {
      v40 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
      VFX_shape_draw(&V_Type6_stru_D8654.pane, v40, v39, v38 - 7, v37 + 0x21);
    }
    v38 += 0x3E;
    v109 += 2;
    ++v92;
  }
  v93 = 0x278;
  LOWORD(v41) = word_FFEBC[(unsigned __int8)byte_104BEA];
  pane.x0 = 0x138;
  v115 = v41;
  pane.y0 = 7;
  pane.x1 = 0x278;
  pane.y1 = 0x17D;
  v46 = 7;
  v47 = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], 0, 0);
  v94 = v47;
  if ( v47 < 0x14 )
  {
    v46 = 7 - 7 * (0x14 - v47) / 0x11;
  }
  if ( v46 >= 0 )
  {
    if ( v46 > 6 )
    {
      v46 = 6;
    }
  }
  else
  {
    v46 = 0;
  }
  v95 = v94 / (v46 + 1);
  v96 = 0;
  v98 = 0x9F;
  v97 = v93 - 0x212;
  if ( v93 - 0x212 < 2 )
  {
    v97 = 2;
  }
  v92 = 0;
  v90 = 0x208;
  v103 = 0x11;
  v48 = (__int16 *)&unk_CA1F1;
  v49 = 0xFFFFFF00 * v46 + 0x700;
  while ( 1 )
  {
    v50 = SHIWORD(dword_D35E5);
    if ( SHIWORD(dword_D35E5) <= v92 )
    {
      break;
    }
    v51 = v48[0x2B];
    v85 = v48;
    if ( v51 == (unsigned __int8)byte_104BEA )
    {
      v52 = 0;
      if ( v96 > v95 && v46 > 0 )
      {
        v49 += 0x100;
        --v46;
      }
      if ( v46 > 0 )
      {
        VFX_shape_lookaside((UBYTE *)(v49 + dword_D8D8F));
        v52 = 1;
      }
      v53 = v90 - pane.x0;
      v54 = rand() % v97 + v53;
      hotX = v103 - pane.y0;
      v75 = hotX + rand() % v98;
      v71 = *((char *)v85 + 0xAA);
      v55 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v115);
      VFX_shape_transform(&pane, v55, v71, v54, v75, buffer, 0, 0x5555, 0x5555, v52);
    }
    v48 += 0xB1;
    ++v92;
    ++v96;
  }
  LOWORD(v50) = word_FFEDA;
  v116 = v50;
  v112 = 0x1FF;
  v56 = 7;
  v57 = sub_402E0(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
  if ( v57 < 0x14 )
  {
    v56 = 7 - 7 * (0x14 - v57) / 0x11;
  }
  if ( v56 >= 0 )
  {
    if ( v56 > 6 )
    {
      v56 = 6;
    }
  }
  else
  {
    v56 = 0;
  }
  v113 = v94 / (v56 + 1);
  v110 = v112 - 0x14C;
  v114 = 0;
  v104 = 0x97;
  if ( v112 - 0x14C < 2 )
  {
    v110 = 2;
  }
  v58 = (char *)&unk_BB1B3;
  v92 = 0;
  v106 = 0x142;
  v107 = 0xDC;
  v59 = 0xFFFFFF00 * v56 + 0x700;
  while ( SHIWORD(dword_CA1ED) > v92 )
  {
    v60 = v58[0x57];
    v105 = v58;
    if ( v60 == (_BYTE)byte_104BEA )
    {
      v61 = 0;
      if ( v114 > v113 && v56 > 0 )
      {
        v59 += 0x100;
        --v56;
      }
      if ( v56 > 0 )
      {
        VFX_shape_lookaside((UBYTE *)(v59 + dword_D8D8F));
        v61 = 1;
      }
      v62 = v106 - pane.x0;
      v63 = rand();
      y0 = pane.y0;
      hotX = v63 % v110 + v62;
      v65 = v107;
      v76 = v65 - y0 + rand() % v104;
      v74 = hotX;
      v72 = 5 * *((unsigned __int16 *)v105 + 0xB) + *((unsigned __int16 *)v105 + 0xA);
      v66 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v116);
      VFX_shape_transform(&pane, v66, v72, v74, v76, buffer, 0, 0x5555, 0x5555, v61);
    }
    v58 += 0x7B;
    ++v92;
    ++v114;
  }
  v67 = 0xCB;
  v68 = 0;
  v92 = 0;
  v69 = 0x213;
  v108 = (PANE *)(v86 + 4);
  while ( (unsigned __int16)word_105258 > v92 )
  {
    if ( v92 && !(v92 % 6) )
    {
      v69 = 0x213;
      v67 += 0x11;
    }
    if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + v68) >> 0x18)) != 0 )
    {
      v73 = v92;
      v70 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
      VFX_shape_transform(v108, v70, v73, v69, v67, buffer, 0, 0x5555, 0x5555, 0);
    }
    v69 += 0x11;
    v68 += 0x4B;
    ++v92;
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&V_Type6_stru_D8654.pane);
}
// 28784: conditional instruction was optimized away because %var_60.4==9F
// 289D7: conditional instruction was optimized away because %var_48.4==97
// A3CF2: using guessed type int dword_A3CF2;
// CA1ED: using guessed type int dword_CA1ED;
// D35E5: using guessed type int dword_D35E5;
// D3668: using guessed type int dword_D3668;
// D366C: using guessed type char byte_D366C;
// D8D8F: using guessed type int dword_D8D8F;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEAE: using guessed type __int16 word_FFEAE[7];
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDA: using guessed type __int16 word_FFEDA;
// FFEDE: using guessed type __int16 word_FFEDE;
// FFEF2: using guessed type __int16 word_FFEF2;
// FFEF6: using guessed type __int16 word_FFEF6;
// 10529F: using guessed type int dword_10529F;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 27D18: using guessed type char var_358[204];
// 27D18: using guessed type char var_28C[204];

//----- (00028C40) --------------------------------------------------------
void __cdecl callback_fn()
{
  dword_D8650 = 0xFFFFFFFF;
}
// D8650: using guessed type int dword_D8650;

//----- (00028C4C) --------------------------------------------------------
int __fastcall sub_28C4C(__int16 *a1, __int16 *a2)
{
  return *a1 - *a2;
}

//----- (00028C74) --------------------------------------------------------
void __fastcall __spoils<> sub_28C74(P_Type2 a1)
{
  _DWORD *v1; // eax
  P_Type2 v2; // ecx

  Q_InitFileInfo_sub_1BB78(&a1->a);
  v1 = (_DWORD *)((char *)v1 + 0x90A);
  sub_2B2C0(v1);
  v2 = (P_Type2)((char *)v1 + 0xFFFFF6F6);
  v2->dword198 = 0;
  v2->dword1A8 = 0;
  v2->dword1AC = 0;
  v2->dword1B0 = 0;
  v2->dword1B4 = 0;
  v2->dword19C = 0xFFFFFFFF;
  memset((char *)v1 + 0xFFFFF6F6 + 0x118, 0, 0x80u);
  v2->dword1E4 = 0;
  v2->dword1E8 = 0;
  v2->dword1EC = 0;
  v2->dword1F0 = 0;
  v2->dword946 = 0;
  memset(v2->char204, 0, sizeof(v2->char204));
  memset(v2->char808, 0, sizeof(v2->char808));
  v2->word804 = 0;
  v2->word806 = 0;
  v2->word908 = 0;
  v2->dword92E = 0;
  v2->word932 = 0;
  v2->word934 = 0;
  v2->dword936 = 0xFFFFFFFF;
  v2->dword1E0 = 0x12;
  v2->dword93A = 0;
  v2->dword93E = 0xFFFFFFFF;
  v2->dword942 = 0;
}
// 28C7E: variable 'v1' is possibly undefined

//----- (00028DA4) --------------------------------------------------------
void __fastcall sub_28DA4(int a1)
{
  int v2; // edx
  int i; // ebx
  int v4; // ebx
  int v5; // edx
  void **v6; // eax

  if ( *(_DWORD *)(a1 + 0x1B0) == 0xFFFFFFFF )
  {
    sub_2627C(*(void **)(a1 + 0x1AC));
  }
  operator delete(*(void **)(a1 + 0x1AC));
  if ( *(_DWORD *)(a1 + 0x1B4) == 0xFFFFFFFF )
  {
    sub_2627C(*(void **)(a1 + 0x198));
    operator delete(*(void **)(a1 + 0x198));
    sub_2627C(*(void **)(a1 + 0x1A8));
    operator delete(*(void **)(a1 + 0x1A8));
  }
  v2 = a1;
  for ( i = 0; i < *(__int16 *)(a1 + 0x908); ++i )
  {
    sub_2627C(*(void **)(v2 + 0x808));
    v2 += 8;
  }
  operator delete(*(void **)(v2 + 0x808));
  v4 = 0;
  v5 = a1;
  while ( v4 < *(__int16 *)(a1 + 0x806) )
  {
    if ( *(_WORD *)(v5 + 0x206) == 0xA )
    {
      sub_2627C(*(void **)(v5 + 0x20C));
      operator delete(*(void **)(v5 + 0x20C));
      *(_DWORD *)(v5 + 0x20C) = 0;
    }
    v5 += 0xC;
    ++v4;
  }
  if ( *(_DWORD *)(a1 + 0x92E) )
  {
    sub_2627C(*(void **)(a1 + 0x92E));
  }
  operator delete(*(void **)(a1 + 0x92E));
  sub_2AD08(a1);
  v6 = sub_2B2E0((void **)(a1 + 0x90A));
  Q_CloseFileAndDelete_sub_1BBC8((P_Type1)((char *)v6 + 0xFFFFF6F6));
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (00028EB4) --------------------------------------------------------
UBYTE *__fastcall sub_28EB4(int a1, const char *a2, int a3, int a4, int a5)
{
  UBYTE *result; // eax
  __int64 v7; // rax
  int v8; // eax
  __int64 v9; // rax
  int v10; // eax
  int v11; // eax

  if ( !a2 )
  {
    return 0;
  }
  sub_2A1DC(a1, "SUBTITLE.TXT");
  if ( Q_CfilePreload_sub_1BBFC((P_Type1)a1, a2, 0x200, 0) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0xE9);
  }
  if ( sub_1BF94((P_Type1)a1, (void *)(a1 + 0x118), 0x80u) == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0xE3);
  }
  if ( *(unsigned __int16 *)(a1 + 0x11C) != 0xAF12 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0xEF);
  }
  if ( a4 == 0xFFFFFFFF )
  {
    v7 = 0x280 - *(unsigned __int16 *)(a1 + 0x120);
    v8 = ((int)v7 - HIDWORD(v7)) >> 1;
  }
  else
  {
    v8 = a4;
  }
  *(_DWORD *)(a1 + 0x1A0) = v8;
  if ( a5 == 0xFFFFFFFF )
  {
    v9 = 0x1E0 - *(unsigned __int16 *)(a1 + 0x122);
    v10 = ((int)v9 - HIDWORD(v9)) >> 1;
  }
  else
  {
    v10 = a5;
  }
  *(_DWORD *)(a1 + 0x1BC) = 0x27F;
  *(_DWORD *)(a1 + 0x1C0) = 0x1DF;
  *(_DWORD *)(a1 + 0x1A4) = v10;
  *(_DWORD *)(a1 + 0x1CC) = a1 + 0x1B8;
  if ( a3 )
  {
    *(_DWORD *)(a1 + 0x1B0) = 0;
    *(_DWORD *)(a1 + 0x1AC) = a3;
  }
  else
  {
    result = V_Type6_stru_D8654.window.buffer;
    *(_DWORD *)(a1 + 0x1AC) = V_Type6_stru_D8654.window.buffer;
    if ( !result )
    {
      return result;
    }
    *(_DWORD *)(a1 + 0x1B0) = 0;
  }
  *(_DWORD *)(a1 + 0x1C4) = 0;
  v11 = *(_DWORD *)(a1 + 0x1AC);
  *(_DWORD *)(a1 + 0x1C8) = 0;
  *(_DWORD *)(a1 + 0x1B8) = v11;
  return (UBYTE *)0xFFFFFFFF;
}

//----- (00029038) --------------------------------------------------------
int __fastcall sub_29038(int a1, size_t a2, unsigned int a3, int a4, int a5, int a6)
{
  int v8; // edi
  int v9; // edx
  void *v10; // eax
  int v11; // eax
  size_t v12; // eax
  int v13; // edx
  int v14; // ebp
  int v15; // eax

  v8 = a3;
  *(_WORD *)(a1 + 0x804) = 0;
  *(_WORD *)(a1 + 0x92A) = 0;
  *(_DWORD *)(a1 + 0x942) = 0;
  *(_WORD *)(a1 + 0x92C) = 0;
  if ( a2 < a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x15E);
  }
  if ( a2 - a4 < a3 )
  {
    v8 = a2 - a4;
  }
  v9 = *(_DWORD *)(a1 + 0x1B4);
  *(_DWORD *)(a1 + 0x19C) = 0xFFFFFFFF;
  if ( v9 == 0xFFFFFFFF )
  {
    sub_2627C(*(void **)(a1 + 0x198));
    operator delete[](*(void **)(a1 + 0x198));
    sub_2627C(*(void **)(a1 + 0x1A8));
    operator delete[](*(void **)(a1 + 0x1A8));
    *(_DWORD *)(a1 + 0x198) = 0;
    *(_DWORD *)(a1 + 0x1A8) = 0;
    *(_DWORD *)(a1 + 0x1B4) = 0;
  }
  if ( a6 )
  {
    *(_DWORD *)(a1 + 0x1E8) = a6;
  }
  if ( !*(_DWORD *)(a1 + 0x1E8) )
  {
    v10 = operator new[](a2);
    sub_2625C(v10, 1, "FLIC BUFFER");
    *(_DWORD *)(a1 + 0x1E8) = v10;
    if ( !v10 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x183);
    }
  }
  v11 = *(_DWORD *)(a1 + 0x1E8);
  *(_DWORD *)(a1 + 0x1F4) = a2;
  v12 = a2 + v11;
  v13 = *(_DWORD *)(a1 + 0x168);
  *(_DWORD *)(a1 + 0x1EC) = v12;
  *(_DWORD *)(a1 + 0x1F0) = v12 - a4;
  v14 = *(_DWORD *)(a1 + 0x1F0) - v8;
  *(_DWORD *)(a1 + 0x1FC) = a5;
  *(_DWORD *)(a1 + 0x1E4) = v14;
  sub_1BECC((int *)a1, v13, 0);
  *(_DWORD *)(a1 + 0x200) = ((int)sub_1BFD4((int *)a1, *(void **)(a1 + 0x1E4), v8, 0x40u, (int)sub_2BCF4) >= v8) - 1;
  VFX_area_wipe(0, 0, 639, 479, 0);
  v15 = *(_DWORD *)(a1 + 0x1E4);
  *(_DWORD *)(a1 + 0x198) = v15;
  *(_DWORD *)(a1 + 0x1A8) = v15 + 0x10;
  *(_DWORD *)(a1 + 0x1E4) = *(_DWORD *)(a1 + 0x1E8);
  *(_DWORD *)(a1 + 0x1F8) = *(_DWORD *)(a1 + 0x198) - *(_DWORD *)(a1 + 0x1E4);
  return 0xFFFFFFFF;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (000296B4) --------------------------------------------------------
unsigned int __fastcall sub_296B4(int a1, int a2, int a3, int a4)
{
  int v5; // edx
  int v7; // eax
  _DWORD *v8; // esi
  int i; // edi
  _DWORD *v10; // edx
  unsigned __int16 v11; // ax
  unsigned __int16 *v12; // edx
  unsigned __int16 v13; // ax
  _DWORD *v14; // esi
  unsigned int v15; // edx
  int v16; // edx
  void *v17; // edi
  const void *v18; // esi
  signed int v19; // ecx
  char *v20; // ecx
  int v21; // esi
  int v22; // edx
  int v23; // esi
  int v24; // edi
  unsigned int v25; // edx
  unsigned int v26; // eax
  int v27; // esi
  int v28; // edx
  int v29; // ecx
  int v30; // ecx
  unsigned int v31; // esi
  unsigned int v32; // eax

  if ( dword_D8650 )
  {
    if ( *(_DWORD *)(a1 + 0x946) == 0xFFFFFFFF )
    {
      sub_29B24((_DWORD *)a1, a2, a3, a4);
    }
    if ( dword_D8650 != 0xFFFFFFFF && *(_DWORD *)(a1 + 0x93A) != 0xFFFFFFFF )
    {
      goto LABEL_54;
    }
    if ( !*(_DWORD *)(a1 + 0x93A) )
    {
      _disable();
      dword_D8650 = 0;
      _enable();
    }
    v5 = *(_DWORD *)(a1 + 0x19C) + 1;
    *(_DWORD *)(a1 + 0x19C) = v5;
    if ( !v5 )
    {
      VFX_area_wipe(0, 0, 639, 479, *(_DWORD *)(a1 + 0x926));
    }
    if ( *(unsigned __int16 *)(a1 + 0x11E) <= *(int *)(a1 + 0x19C) )
    {
      return 0;
    }
    v7 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 0x198) + 4);
    ++dword_A0CF8;
    if ( v7 != 0xF1FA )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x32E);
    }
    v8 = *(_DWORD **)(a1 + 0x1A8);
    for ( i = 0; i < *(unsigned __int16 *)(*(_DWORD *)(a1 + 0x198) + 6); ++i )
    {
      v10 = v8;
      v8 = (_DWORD *)((char *)v8 + *v8);
      v11 = *((_WORD *)v10 + 2);
      v12 = (unsigned __int16 *)v10 + 3;
      if ( v11 < 0xFu )
      {
        if ( v11 < 4u )
        {
          goto LABEL_19;
        }
        if ( v11 <= 4u )
        {
          *(_WORD *)(a1 + 0x92C) = 0;
          sub_29C6C(a1, v12);
        }
        else
        {
          if ( v11 != 7 )
          {
LABEL_19:
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x355);
          }
          sub_2AD40(v12, *(_DWORD *)(a1 + 0x1A0), *(_DWORD *)(a1 + 0x1A4));
        }
      }
      else if ( v11 <= 0xFu )
      {
        sub_29D54(a1, (unsigned __int8 *)v12);
      }
      else if ( v11 <= 0x10u )
      {
        sub_29F58(a1, v12);
      }
      else if ( v11 != 0x12 )
      {
        goto LABEL_19;
      }
    }
    v13 = *(_WORD *)(a1 + 0x92A);
    if ( v13 )
    {
      if ( v13 <= 1u )
      {
        sub_2C4C0((int)&V_Type6_stru_D8654, *(__int16 *)(a1 + 0x932), *(__int16 *)(a1 + 0x934));
      }
      else if ( v13 == 2 )
      {
        sub_2C418((int)&V_Type6_stru_D8654, *(__int16 *)(a1 + 0x932), *(_WORD *)(a1 + 0x934));
      }
    }
    if ( *(__int16 *)(a1 + 0xC * *(__int16 *)(a1 + 0x804) + 0x204) == *(_DWORD *)(a1 + 0x19C) )
    {
      sub_2AA88(a1);
    }
    if ( *(_WORD *)(a1 + 0x92C) )
    {
      sub_2C5E4((int)&V_Type6_stru_D8654, *(_BYTE *)(a1 + 0x92C) - 1);
      if ( (__int16)++*(_WORD *)(a1 + 0x92C) > 0x40 )
      {
        *(_WORD *)(a1 + 0x92C) = 0;
      }
    }
    if ( *(_DWORD *)(a1 + 0x93A) == 0xFFFFFFFF && *(_DWORD *)(a1 + 0x93E) == *(_DWORD *)(a1 + 0x19C) )
    {
      getch();
      *(_DWORD *)(a1 + 0x93A) = 0;
      *(_DWORD *)(a1 + 0x93E) = 0xFFFFFFFF;
    }
    *(_DWORD *)(a1 + 0x1F8) += **(_DWORD **)(a1 + 0x198);
    v14 = (_DWORD *)(**(_DWORD **)(a1 + 0x198) + *(_DWORD *)(a1 + 0x198));
    v15 = *(_DWORD *)(a1 + 0x1F0);
    *(_DWORD *)(a1 + 0x198) = v14;
    if ( (unsigned int)v14 >= v15 )
    {
      *(_DWORD *)(a1 + 0x198) = (char *)v14 + *(_DWORD *)(a1 + 0x1E8) - v15;
LABEL_53:
      *(_DWORD *)(a1 + 0x1A8) = *(_DWORD *)(a1 + 0x198) + 0x10;
LABEL_54:
      if ( !*(_DWORD *)(a1 + 0x200) )
      {
        if ( *(_DWORD *)(a1 + 0x1F8) < *(_DWORD *)(a1 + 0x1FC) )
        {
          v22 = *(_DWORD *)(a1 + 0x1F8);
        }
        else
        {
          v22 = *(_DWORD *)(a1 + 0x1FC);
        }
        v23 = v22;
        if ( v22 + *(_DWORD *)(a1 + 0x1E4) - *(_DWORD *)(a1 + 0x1F0) > 0 )
        {
          v23 = *(_DWORD *)(a1 + 0x1F0) - *(_DWORD *)(a1 + 0x1E4);
        }
        if ( sub_1BF94((P_Type1)a1, *(void **)(a1 + 0x1E4), v23) < v23 )
        {
          *(_DWORD *)(a1 + 0x200) = 0xFFFFFFFF;
        }
        v24 = *(_DWORD *)(a1 + 0x1F8);
        v25 = *(_DWORD *)(a1 + 0x1F0);
        *(_DWORD *)(a1 + 0x1E4) += v23;
        v26 = *(_DWORD *)(a1 + 0x1E4);
        *(_DWORD *)(a1 + 0x1F8) = v24 - v23;
        if ( v26 >= v25 )
        {
          *(_DWORD *)(a1 + 0x1E4) = *(_DWORD *)(a1 + 0x1E8);
        }
      }
      if ( (unsigned int)(*(_DWORD *)(a1 + 0x1EC)
                        + **(_DWORD **)(a1 + 0x198)
                        + *(_DWORD *)(a1 + 0x1F8)
                        - *(_DWORD *)(a1 + 0x1F0)) >= *(_DWORD *)(a1 + 0x1F4) )
      {
        v27 = *(_DWORD *)(a1 + 0x1F8);
        v28 = *(_DWORD *)(a1 + 0x1F0);
        if ( v27 + *(_DWORD *)(a1 + 0x1E4) - v28 > 0 )
        {
          v27 = v28 - *(_DWORD *)(a1 + 0x1E4);
        }
        if ( sub_1BF94((P_Type1)a1, *(void **)(a1 + 0x1E4), v27) < v27 )
        {
          *(_DWORD *)(a1 + 0x200) = 0xFFFFFFFF;
        }
        v29 = *(_DWORD *)(a1 + 0x1F8);
        *(_DWORD *)(a1 + 0x1E4) += v27;
        v30 = v29 - v27;
        v31 = *(_DWORD *)(a1 + 0x1F0);
        v32 = *(_DWORD *)(a1 + 0x1E4);
        *(_DWORD *)(a1 + 0x1F8) = v30;
        if ( v32 >= v31 )
        {
          *(_DWORD *)(a1 + 0x1E4) = *(_DWORD *)(a1 + 0x1E8);
        }
      }
      return 0xFFFFFFFF;
    }
    v16 = (int)v14 - *(_DWORD *)(a1 + 0x1F0) + 0x10;
    if ( v16 <= 0 )
    {
      v20 = (char *)v14 + *v14;
      v21 = *(_DWORD *)(a1 + 0x1F0);
      v19 = (signed int)&v20[-v21];
      if ( v19 <= 0 )
      {
        goto LABEL_53;
      }
      if ( v19 >= *(_DWORD *)(a1 + 0x1EC) - v21 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x3D0);
      }
      v18 = *(const void **)(a1 + 0x1E8);
      v17 = *(void **)(a1 + 0x1F0);
    }
    else
    {
      qmemcpy(*(void **)(a1 + 0x1F0), *(const void **)(a1 + 0x1E8), (unsigned int)v14 - *(_DWORD *)(a1 + 0x1F0) + 0x10);
      v17 = v14 + 4;
      v18 = (const void *)(v16 + *(_DWORD *)(a1 + 0x1E8));
      v19 = **(_DWORD **)(a1 + 0x198) - 0x10;
    }
    qmemcpy(v17, v18, v19);
    goto LABEL_53;
  }
  return 0xFFFFFFFF;
}
// A0CF8: using guessed type int dword_A0CF8;
// D8650: using guessed type int dword_D8650;

//----- (00029B24) --------------------------------------------------------
void __fastcall sub_29B24(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ecx
  signed int v5; // ebx
  int v6; // edi
  int v7; // eax
  LONG v8; // esi
  RGB v9[4]; // [esp+0h] [ebp-18h] BYREF
  int v10; // [esp+Ch] [ebp-Ch]
  int v11; // [esp+10h] [ebp-8h]

  v11 = a4;
  v10 = a2;
  v4 = a1[0x7A];
  v5 = a1[0x7D] / 0x27Fu;
  v6 = (a1[0x79] - v4) / v5;
  v7 = (a1[0x66] - v4) / v5;
  v9[0].g = 0;
  v9[0].b = 0;
  v8 = v7;
  v9[0].r = 0xFF;
  VFX_DAC_write(0xFE, v9);
  v9[0].r = 0;
  v9[0].g = 0xFF;
  VFX_DAC_write(0xFF, v9);
  if ( v8 < v6 )
  {
    VFX_area_wipe(0, 450, v8, 479, 254);
    VFX_area_wipe(v8, 450, v6, 479, 255);
    VFX_area_wipe(v6, 450, 639, 479, 254);
  }
  else
  {
    VFX_area_wipe(0, 450, v6, 479, 255);
    VFX_area_wipe(v6, 450, v8, 479, 254);
    VFX_area_wipe(v8, 450, 639, 479, 255);
  }
  VFX_area_wipe(v8, 450, v8, 479, 254);
}

//----- (00029C6C) --------------------------------------------------------
unsigned __int16 __fastcall sub_29C6C(int a1, _WORD *a2)
{
  RGB *v3; // esi
  unsigned __int16 result; // ax
  unsigned __int16 v5; // ax
  UBYTE *p_g; // esi
  unsigned __int8 v7; // dl
  unsigned __int16 j; // di
  int v9; // edx
  UBYTE r; // dh
  UBYTE b; // bh
  unsigned __int16 v12; // [esp+0h] [ebp-24h]
  unsigned __int16 v13; // [esp+4h] [ebp-20h]
  int v14; // [esp+8h] [ebp-1Ch]
  unsigned __int8 i; // [esp+Ch] [ebp-18h]

  v3 = (RGB *)(a2 + 1);
  result = *a2;
  v12 = *a2;
  v14 = 0;
  HIBYTE(result) = 0;
  for ( i = 0; (unsigned __int16)v14 < v12; ++v14 )
  {
    LOBYTE(v5) = v3->r;
    p_g = &v3->g;
    v7 = v5 + i;
    v5 = (unsigned __int8)v5;
    LOBYTE(v5) = *p_g;
    v3 = (RGB *)(p_g + 1);
    v13 = v5;
    result = v3[0xFFFFFFFF].b;
    i = v7;
    if ( !v3[0xFFFFFFFF].b )
    {
      result = 0;
      v13 = 0x100;
    }
    for ( j = 0; j < v13; ++j )
    {
      v9 = *(__int16 *)(a1 + 0x932);
      if ( j < v9 || j >= *(__int16 *)(a1 + 0x934) + v9 )
      {
        r = v3->r;
        v3->g >>= 2;
        b = v3->b;
        v3->r = r >> 2;
        v3->b = b >> 2;
        VFX_DAC_write(i++, v3++);
      }
      result = v13;
    }
  }
  return result;
}

//----- (00029D54) --------------------------------------------------------
int __fastcall sub_29D54(int a1, unsigned __int8 *a2)
{
  int v3; // edx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebp
  int result; // eax
  int i; // [esp+0h] [ebp-2Ch]
  char *s; // [esp+8h] [ebp-24h]
  char v10[4]; // [esp+Ch] [ebp-20h] BYREF
  int v11; // [esp+10h] [ebp-1Ch]
  signed __int8 v12; // [esp+14h] [ebp-18h]

  s = *(char **)(a1 + 0x1AC);
  for ( i = 0; *(unsigned __int16 *)(a1 + 0x122) > i; ++i )
  {
    v11 = 0;
    ++a2;
    if ( *(_WORD *)(a1 + 0x120) )
    {
      do
      {
        v12 = *a2;
        v5 = a2 + 1;
        if ( v12 >= 0 )
        {
          v3 = *v5;
          a2 = v5 + 1;
          memset(s, v3, v12);
        }
        else
        {
          v12 = -v12;
          v3 = v12;
          qmemcpy(s, v5, v12);
          a2 = &v5[v12];
        }
        LOWORD(v3) = v12;
        s += v12;
        v4 = *(_WORD *)(a1 + 0x120);
        v11 += v3;
      }
      while ( (unsigned __int16)v11 < v4 );
    }
    s += 0x280 - *(unsigned __int16 *)(a1 + 0x120);
  }
  v10[0] = 0;
  v10[1] = 0;
  v10[2] = 0;
  sub_2C2B0((int)&V_Type6_stru_D8654, 0, 0x100, 0);
  sub_2C670((int)&V_Type6_stru_D8654, 0, 0x100, v10);
  *(_DWORD *)(a1 + 0x1D0) = 0;
  *(_DWORD *)(a1 + 0x1D4) = 0;
  *(_DWORD *)(a1 + 0x1D8) = *(unsigned __int16 *)(a1 + 0x120) - 1;
  *(_DWORD *)(a1 + 0x1DC) = *(unsigned __int16 *)(a1 + 0x122) - 1;
  VFX_pane_refresh(
    (PANE *)(a1 + 0x1CC),
    *(_DWORD *)(a1 + 0x1A0),
    *(_DWORD *)(a1 + 0x1A4),
    *(_DWORD *)(a1 + 0x1D8) + *(_DWORD *)(a1 + 0x1A0),
    *(_DWORD *)(a1 + 0x1DC) + *(_DWORD *)(a1 + 0x1A4));
  for ( *(_WORD *)(a1 + 0x92C) = 0; *(__int16 *)(a1 + 0x92C) < 0x20; ++*(_WORD *)(a1 + 0x92C) )
  {
    result = sub_2C5E4((int)&V_Type6_stru_D8654, *(_BYTE *)(a1 + 0x92C));
  }
  ++*(_WORD *)(a1 + 0x92C);
  return result;
}

//----- (00029F58) --------------------------------------------------------
void __fastcall sub_29F58(int a1, const void *a2)
{
  LONG v3; // edi
  LONG v4; // [esp-Ch] [ebp-1Ch]
  LONG v5; // [esp-8h] [ebp-18h]
  LONG v6; // [esp-4h] [ebp-14h]

  qmemcpy(*(void **)(a1 + 0x1AC), a2, *(unsigned __int16 *)(a1 + 0x122) * *(unsigned __int16 *)(a1 + 0x120));
  *(_DWORD *)(a1 + 0x1D8) = *(unsigned __int16 *)(a1 + 0x120) - 1;
  *(_DWORD *)(a1 + 0x1DC) = *(unsigned __int16 *)(a1 + 0x122) - 1;
  v6 = *(_DWORD *)(a1 + 0x1DC) + *(_DWORD *)(a1 + 0x1A4);
  v5 = *(_DWORD *)(a1 + 0x1D8) + *(_DWORD *)(a1 + 0x1A0);
  v4 = *(_DWORD *)(a1 + 0x1A4);
  v3 = *(_DWORD *)(a1 + 0x1A0);
  *(_DWORD *)(a1 + 0x1D0) = 0;
  *(_DWORD *)(a1 + 0x1D4) = 0;
  VFX_pane_refresh((PANE *)(a1 + 0x1CC), v3, v4, v5, v6);
}

//----- (0002A1DC) --------------------------------------------------------
FILE *__fastcall sub_2A1DC(int a1, const char *a2)
{
  FILE *result; // eax
  FILE *v4; // ebx
  int v5; // esi
  unsigned int v6; // kr04_4
  char *v7; // eax
  int v9; // eax
  int v10; // ecx
  void *v11; // eax
  char *v12; // esi
  char *v13; // edi
  char v14; // al
  char v15; // al
  int v16; // eax
  __int16 v17; // dx
  FILE *v18; // ecx
  __int16 v19; // si
  FILE *v20; // esi
  __int16 v21; // bx
  FILE *v22; // esi
  __int16 v23; // cx
  void *v24; // eax
  FILE *v25; // edi
  int v26; // ebx
  FILE *v27; // [esp-10h] [ebp-304h]
  T_Type1 v28; // [esp+0h] [ebp-2F4h] BYREF
  char v29[256]; // [esp+118h] [ebp-1DCh] BYREF
  char v30[128]; // [esp+218h] [ebp-DCh] BYREF
  char v31[52]; // [esp+298h] [ebp-5Ch] BYREF
  unsigned int v32; // [esp+2CCh] [ebp-28h] BYREF
  FILE *fp; // [esp+2D0h] [ebp-24h]
  int v34; // [esp+2D4h] [ebp-20h]
  int v35; // [esp+2D8h] [ebp-1Ch]
  __int16 v36; // [esp+2DCh] [ebp-18h]

  result = (FILE *)a2;
  if ( a2 )
  {
    v36 = 0;
    result = sub_1BB10(a2, 0);
    fp = result;
    if ( result )
    {
      v34 = 0;
      v35 = a1 + 0x90A;
      while ( 1 )
      {
        v4 = fp;
        fscanf(fp, "%s %d", v31, &v32);
        if ( v32 == 0xFFFFFFFF )
        {
          break;
        }
        v5 = ++v34;
        if ( v32 < 2 )
        {
          if ( v32 )
          {
            fscanf(v4, "%s %s", v31, v30);
            if ( !sub_2B360((void **)v35, v30) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x5E3);
            }
            fscanf(fp, "%s %s", v31, v30);
            Q_InitFileInfo_sub_1BB78(&v28);
            if ( Q_CfilePreload_sub_1BBFC(&v28, v30, 0x200, 0) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x5EB);
            }
            v24 = Q_CfileLoad_sub_1BF1C(&v28, 0);
            *(_DWORD *)(a1 + 0x92E) = v24;
            if ( !v24 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x5EE);
            }
            v25 = fp;
            fscanf(fp, "%s %d", v31, &v32);
            *(_WORD *)(a1 + 0x932) = v32;
            fscanf(v25, "%s %d", v31, &v32);
            *(_WORD *)(a1 + 0x934) = v32;
            fscanf(v25, "%s %d", v31, &v32);
            v26 = v34 + 6;
            *(_DWORD *)(a1 + 0x926) = v32;
            v34 = v26;
            Q_CloseFileAndDelete_sub_1BBC8(&v28);
          }
          else
          {
            fscanf(v4, "%s %d", v31, &v32);
            *(_DWORD *)(a1 + 0x916) = v32;
            fscanf(v4, "%s %d", v31, &v32);
            *(_DWORD *)(a1 + 0x91A) = v32;
            fscanf(v4, "%s %d", v31, &v32);
            *(_DWORD *)(a1 + 0x91E) = v32;
            fscanf(v4, "%s %d", v31, &v32);
            v34 = v5 + 5;
            *(_DWORD *)(a1 + 0x922) = v32;
          }
        }
        else if ( v32 <= 2 )
        {
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x5FF);
          }
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 1;
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v36;
          fscanf(fp, "%s %s", v31, v29);
          v6 = strlen(v29) + 1;
          v7 = v29;
          if ( v29[0] )
          {
            do
            {
              if ( *v7 == 0x5F )
              {
                *v7 = 0x20;
              }
            }
            while ( *++v7 );
          }
          v9 = sub_2B5BC((int *)v35, v29);
          if ( v9 == 0xFFFFFFFF )
          {
            Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x613);
          }
          v10 = v36;
          *(_DWORD *)(a1 + 8 * v36 + 0x80C) = v9;
          v11 = operator new[]((__int16)(v6 - 1) + 1);
          sub_2625C(v11, 1, "SUBTITLE");
          *(_DWORD *)(a1 + 8 * v10 + 0x808) = v11;
          if ( !v11 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x61B);
          }
          v12 = v29;
          v13 = *(char **)(a1 + 8 * v36 + 0x808);
          do
          {
            v14 = *v12;
            *v13 = *v12;
            if ( !v14 )
            {
              break;
            }
            v15 = v12[1];
            v12 += 2;
            v13[1] = v15;
            v13 += 2;
          }
          while ( v15 );
          fscanf(fp, "%s %d", v31, &v32);
          v32 -= 0x20;
          if ( (int)v32 <= 0 )
          {
            Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x622);
          }
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v32;
          v27 = fp;
          ++*(_WORD *)(a1 + 0x806);
          fscanf(v27, "%s %d", v31, &v32);
          v16 = 0xC * *(__int16 *)(a1 + 0x806);
          ++v36;
          *(_WORD *)(v16 + a1 + 0x204) = v32;
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 2;
          v17 = *(_WORD *)(a1 + 0x806);
          v34 += 4;
          *(_WORD *)(a1 + 0x806) = v17 + 1;
        }
        else if ( v32 < 0xB )
        {
          if ( v32 != 3 )
          {
LABEL_10:
            sprintf(
              "Thank you for playing Ascendancy.",
              "\n  ** Bad Subtitle Data: %s, %d (line %d)\n\n",
              v31,
              v32,
              v34);
            Q_debugbreak_exit_sub_2624C();
          }
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x635);
          }
          v18 = fp;
          fscanf(fp, "%s %d", v31, &v32);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v32;
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 3;
          fscanf(v18, "%s %d", v31, &v32);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v32;
          v19 = *(_WORD *)(a1 + 0x806);
          v34 += 3;
          *(_WORD *)(a1 + 0x806) = v19 + 1;
        }
        else if ( v32 <= 0xB )
        {
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x703);
          }
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = 0xB;
          v22 = fp;
          fscanf(fp, "%s %d", v31, &v32);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v32;
          fscanf(v22, "%s %d", v31, &v32);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x20C) = v32;
          fscanf(v22, "%s %d", v31, &v32);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v32;
          v23 = *(_WORD *)(a1 + 0x806);
          v34 += 4;
          *(_WORD *)(a1 + 0x806) = v23 + 1;
        }
        else
        {
          if ( v32 != 0x10 )
          {
            goto LABEL_10;
          }
          if ( *(__int16 *)(a1 + 0x806) >= 0x80 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\flic.cpp", 0x68A);
          }
          v20 = fp;
          fscanf(fp, "%s %d", v31, &v32);
          *(_DWORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x208) = v32;
          fscanf(v20, "%s %d", v31, &v32);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x206) = (v32 != 1) + 0x1E;
          fscanf(v20, "%s %d", v31, &v32);
          *(_WORD *)(0xC * *(__int16 *)(a1 + 0x806) + a1 + 0x204) = v32;
          v21 = *(_WORD *)(a1 + 0x806) + 1;
          v34 += 4;
          *(_WORD *)(a1 + 0x806) = v21;
        }
      }
      fclose(v4);
      qsort(
        (void *)(a1 + 0x204),
        *(__int16 *)(a1 + 0x806),
        0xCu,
        (int (__fastcall *)(const void *, const void *))sub_28C4C);
      return (FILE *)0xFFFFFFFF;
    }
  }
  return result;
}
// 2A1DC: using guessed type char var_5C[52];

//----- (0002AA88) --------------------------------------------------------
void __fastcall sub_2AA88(int a1)
{
  int v2; // edx
  int v3; // ebx
  int v4; // ecx
  int v5; // edi
  ULONG v6; // edx
  HTIMER v7; // eax
  unsigned __int16 v8; // ax
  int v9; // [esp+0h] [ebp-8h]
  int v10; // [esp+4h] [ebp-4h]

  v9 = a1 + 0x808;
  v10 = a1 + 0x90A;
  while ( 1 )
  {
    v2 = a1 + 0xC * *(__int16 *)(a1 + 0x804);
    v3 = *(__int16 *)(v2 + 0x204);
    v4 = *(_DWORD *)(a1 + 0x19C);
    if ( v3 != v4 )
    {
      break;
    }
    v8 = *(_WORD *)(v2 + 0x206);
    if ( v8 < 3u )
    {
      if ( !v8 )
      {
LABEL_23:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x80F);
      }
      if ( v8 <= 1u )
      {
        if ( !*(_DWORD *)(a1 + 0x942) )
        {
          v5 = 8 * *(_DWORD *)(v2 + 0x208) + v9;
          sub_2C1E0((int)&V_Type6_stru_D8654, *(_WORD *)(a1 + 0x932), *(_WORD *)(a1 + 0x934), *(_DWORD *)(a1 + 0x92E));
          sub_2C670((int)&V_Type6_stru_D8654, *(__int16 *)(a1 + 0x932), *(__int16 *)(a1 + 0x934), 0);
          sub_2B8A8(
            v10,
            *(__int16 *)(v5 + 4),
            *(__int16 *)(v5 + 6),
            *(const char **)v5,
            0x80,
            0xFFFFFFFF,
            0xFFFFFFFF,
            0);
          *(_WORD *)(a1 + 0x92A) = 1;
        }
        goto LABEL_6;
      }
      if ( *(_DWORD *)(a1 + 0x942) )
      {
        goto LABEL_6;
      }
      *(_WORD *)(a1 + 0x92A) = 2;
      ++*(_WORD *)(a1 + 0x804);
    }
    else if ( v8 <= 3u )
    {
      v6 = *(_DWORD *)(v2 + 0x208);
      v7 = *(_DWORD *)(a1 + 0x936);
      *(_DWORD *)(a1 + 0x1E0) = v6;
      if ( v7 == 0xFFFFFFFF )
      {
        goto LABEL_6;
      }
      if ( v6 )
      {
        AIL_set_timer_frequency(v7, v6);
      }
      else
      {
        AIL_stop_timer(v7);
      }
      ++*(_WORD *)(a1 + 0x804);
    }
    else if ( v8 < 0x1Eu )
    {
      if ( v8 != 0xB )
      {
        goto LABEL_23;
      }
      if ( dword_109357 == 0xFFFFFFFF )
      {
        sub_4FF4C((int)&unk_10914C, *(_DWORD *)(v2 + 0x20C));
        ++*(_WORD *)(a1 + 0x804);
      }
      else
      {
LABEL_6:
        ++*(_WORD *)(a1 + 0x804);
      }
    }
    else if ( v8 <= 0x1Eu )
    {
      sub_4F8CC((int)&unk_10914C, *(_DWORD *)(v2 + 0x208), v4 ^ v3);
      ++*(_WORD *)(a1 + 0x804);
    }
    else
    {
      if ( v8 != 0x1F )
      {
        goto LABEL_23;
      }
      sub_4FA1C((int)&unk_10914C);
      ++*(_WORD *)(a1 + 0x804);
    }
  }
}
// 109357: using guessed type int dword_109357;

//----- (0002AC84) --------------------------------------------------------
int __fastcall sub_2AC84(int a1, ULONG hertz)
{
  HTIMER v4; // edx
  HTIMER v5; // eax

  *(_DWORD *)(a1 + 0x1E0) = hertz;
  v4 = *(_DWORD *)(a1 + 0x936);
  if ( v4 == 0xFFFFFFFF )
  {
    v5 = AIL_register_timer((AILTIMERCB)callback_fn);
    *(_DWORD *)(a1 + 0x936) = v5;
    if ( v5 == 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\flic.cpp", 0x823);
    }
    AIL_set_timer_frequency(*(_DWORD *)(a1 + 0x936), hertz);
    AIL_start_timer(*(_DWORD *)(a1 + 0x936));
  }
  else
  {
    AIL_set_timer_frequency(v4, hertz);
  }
  return (*(_DWORD *)(a1 + 0x936) == 0xFFFFFFFF) - 1;
}

//----- (0002AD08) --------------------------------------------------------
void __fastcall sub_2AD08(int a1)
{
  if ( *(_DWORD *)(a1 + 0x936) != 0xFFFFFFFF )
  {
    AIL_stop_timer(*(_DWORD *)(a1 + 0x936));
    AIL_release_timer_handle(*(_DWORD *)(a1 + 0x936));
    *(_DWORD *)(a1 + 0x936) = 0xFFFFFFFF;
  }
}

//----- (0002AD40) --------------------------------------------------------
__int16 __cdecl sub_2AD40(unsigned __int16 *a1, int a2, LONG y)
{
  int v4; // ecx
  __int16 *v5; // esi
  __int16 result; // ax
  int v7; // edx
  int v8; // eax
  _BYTE *v9; // esi
  LONG v10; // edx
  char v11; // al
  __int16 *v12; // esi
  int v13; // ecx
  __int16 v14; // ax
  int v15; // edx
  unsigned int v16; // ecx
  __int16 v17; // ax
  UBYTE *v18; // edi
  LONG v19; // edx
  ULONG i; // ecx
  unsigned int j; // ecx
  int v22; // edx
  unsigned int v23; // ecx
  UBYTE *v24; // edi
  ULONG v25; // ecx
  LONG v26; // edx
  int v27; // [esp-2Eh] [ebp-42h]
  int v28; // [esp-2Eh] [ebp-42h]
  LONG v29; // [esp-2Ah] [ebp-3Eh]
  int v30; // [esp-26h] [ebp-3Ah]
  int v31; // [esp-26h] [ebp-3Ah]
  LONG v32; // [esp-22h] [ebp-36h]
  LONG v33; // [esp-22h] [ebp-36h]
  int v34; // [esp-1Eh] [ebp-32h]
  __int16 v35; // [esp-1Eh] [ebp-32h]
  __int16 v36; // [esp-1Ah] [ebp-2Eh]
  ULONG v37; // [esp-1Ah] [ebp-2Eh]
  int v38; // [esp-16h] [ebp-2Ah]
  unsigned int v39; // [esp-16h] [ebp-2Ah]
  __int16 v40; // [esp-12h] [ebp-26h]
  int v41; // [esp-10h] [ebp-24h]
  ULONG v42; // [esp+4h] [ebp-10h] BYREF
  UBYTE *v43; // [esp+8h] [ebp-Ch] BYREF
  ULONG nbytes; // [esp+Ch] [ebp-8h] BYREF
  UBYTE *addr; // [esp+10h] [ebp-4h] BYREF

  v4 = *a1;
  v5 = (__int16 *)(a1 + 1);
  do
  {
    while ( 1 )
    {
      result = *v5++;
      if ( result > 0 )
      {
        break;
      }
      if ( (result & 0x4000) != 0 )
      {
        LOWORD(y) = y - result;
      }
    }
    v7 = a2;
    v41 = v4;
    do
    {
      v40 = result;
      v8 = *(unsigned __int8 *)v5;
      v9 = (char *)v5 + 1;
      v10 = v8 + v7;
      v11 = *v9;
      v12 = (__int16 *)(v9 + 1);
      if ( (v11 & 0x80) != 0 )
      {
        v13 = -v11;
        v14 = *v12;
        v5 = v12 + 1;
        v36 = v14;
        v34 = 2 * v13;
        VFX_line_address(v10, y, &addr, &nbytes);
        v15 = v27;
        v16 = v34;
        v17 = v36;
        v18 = addr;
        if ( v34 > (int)nbytes )
        {
          v37 = v34 - nbytes;
          v19 = nbytes + v27;
          for ( i = nbytes >> 1; i; --i )
          {
            *(_WORD *)v18 = v17;
            v18 += 2;
          }
          v35 = v17;
          VFX_line_address(v19, v29, &addr, &nbytes);
          v15 = v28;
          v17 = v35;
          v16 = v37;
          v18 = addr;
        }
        v7 = v16 + v15;
        for ( j = v16 >> 1; j; --j )
        {
          *(_WORD *)v18 = v17;
          v18 += 2;
        }
      }
      else
      {
        v38 = 2 * v11;
        VFX_line_address(v10, y, &v43, &v42);
        v22 = v30;
        y = v32;
        v23 = v38;
        v24 = v43;
        if ( v38 > (int)v42 )
        {
          v39 = v38 - v42;
          v25 = v42;
          v26 = v42 + v30;
          qmemcpy(v43, v12, v42);
          v12 = (__int16 *)((char *)v12 + v25);
          VFX_line_address(v26, v32, &v43, &v42);
          v22 = v31;
          y = v33;
          v23 = v39;
          v24 = v43;
        }
        v7 = v23 + v22;
        qmemcpy(v24, v12, v23);
        v5 = (__int16 *)((char *)v12 + v23);
      }
      result = v40 - 1;
    }
    while ( v40 != 1 );
    LOWORD(y) = y + 1;
    v4 = v41 - 1;
  }
  while ( v41 != 1 );
  return result;
}
// 2ADAB: variable 'v27' is possibly undefined
// 2ADD3: variable 'v29' is possibly undefined
// 2ADD9: variable 'v28' is possibly undefined
// 2AE00: variable 'v30' is possibly undefined
// 2AE01: variable 'v32' is possibly undefined
// 2AE29: variable 'v31' is possibly undefined
// 2AE2A: variable 'v33' is possibly undefined

//----- (0002AE80) --------------------------------------------------------
void __fastcall __spoils<> sub_2AE80(P_TypeA9 a1)
{
  T_Type2 *__shifted(T_TypeA9,0xAB) v1; // eax

  sub_2C830(&a1->a);
  v1 = &a1->b;
  sub_28C74(v1);
  ADJ(v1)->a.b = (int)off_95CB4;
  ADJ(v1)->c = 1;
  ADJ(v1)->d = 0;
}
// 95CB4: using guessed type int (*off_95CB4[3])();

//----- (0002AEB0) --------------------------------------------------------
int __fastcall sub_2AEB0(int a1, char a2)
{
  void *v3; // eax
  int v5; // eax
  int v6; // eax
  void *v7; // eax
  void *v8; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95CA0);
    operator delete[](v3);
    return a1;
  }
  else
  {
    v5 = a1 + 0xAB;
    *(_DWORD *)(v5 - 4) = off_95CB4;
    sub_28DA4(v5);
    v7 = (void *)sub_2C848(v6 - 0xAB, 1);
    v8 = v7;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v7);
    }
    return (int)v8;
  }
}
// 2AEE7: variable 'v6' is possibly undefined
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95CB4: using guessed type int (*off_95CB4[3])();

//----- (0002AF04) --------------------------------------------------------
UBYTE *__fastcall sub_2AF04(int a1, const char *a2)
{
  UBYTE *result; // eax

  result = sub_28EB4(a1 + 0xAB, a2, **(_DWORD **)&V_Type3_stru_10AE70.z1[0x300A], 0xFFFFFFFF, 0xFFFFFFFF);
  if ( !result )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flicwin.cpp", 0x4E);
  }
  return result;
}

//----- (0002AF3C) --------------------------------------------------------
int __fastcall sub_2AF3C(int a1)
{
  signed int v2; // esi
  int v3; // ebx
  unsigned int v4; // ebx

  v2 = *(__int16 *)(a1 + 0xA01) << 0x14;
  if ( v2 > dword_132B08 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\flicwin.cpp", 0x67);
  }
  v3 = *(__int16 *)(a1 + 0xA03);
  if ( v3 == 0xFFFFFFFF )
  {
    v2 = dword_132B08;
    v4 = dword_132B08;
  }
  else
  {
    v4 = v3 << 0x14;
  }
  sub_1B4D0(dword_12FC20);
  return sub_29038(a1 + 0xAB, v2, v4, *(__int16 *)(a1 + 0xA05) << 0xA, *(__int16 *)(a1 + 0xA07) << 0xA, dword_132B04);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002AFF0) --------------------------------------------------------
unsigned int __fastcall sub_2AFF0(int a1, __int16 a2, int a3, int a4)
{
  __int16 v6; // cx
  __int16 v7; // dx
  __int16 v8; // bx
  unsigned int result; // eax
  RGB v10[256]; // [esp+0h] [ebp-31Ch] BYREF
  int v11; // [esp+300h] [ebp-1Ch]
  int v12; // [esp+304h] [ebp-18h]
  int v13; // [esp+308h] [ebp-14h]
  char v14; // [esp+30Ch] [ebp-10h]

  LOWORD(v13) = a2;
  v12 = 0;
  v11 = a1 + 0xAB;
  switch ( a2 )
  {
    case 1:
      *(_DWORD *)(a1 + 0x247) = 0xFFFFFFFF;
      *(_WORD *)(a1 + 0x9F7) = 0;
      *(_DWORD *)(a1 + 0x9F9) = 0;
      *(_DWORD *)(a1 + 0x9FD) = 0;
      MOUSE_hide();
      dword_132B60 = 0;
      if ( sub_2AF3C(a1) )
      {
        sub_4FA1C((int)&unk_10914C);
        sub_2F424(a1, v13, a3, a4);
        sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xA, 0, 0, 0);
        sub_2AC84(v11, 0x12u);
      }
      else
      {
        sub_1ACE8((int)dword_12FC20);
        MOUSE_show();
        sub_56B60((int)&V_Type3_stru_10AE70, *(_WORD *)(a1 + 0x45), *(_DWORD *)(a1 + 0x47), *(_DWORD *)(a1 + 0x4B));
      }
      result = v12;
      break;
    case 2:
      v6 = 0;
      sub_2AD08(a1 + 0xAB);
      v14 = 0x81;
      while ( v6 < 0x40 )
      {
        sub_2BD04((int)&V_Type6_stru_D8654, v6, 0);
        sub_4FF4C((int)&unk_10914C, v14);
        ++v6;
        v14 -= 2;
      }
      sub_4FA1C((int)&unk_10914C);
      sub_1ACE8((int)dword_12FC20);
      memset(v10, 0, sizeof(v10));
      sub_2C224(&V_Type6_stru_D8654, 0, 0x100, v10);
      VFX_area_wipe(0, 0, 0x27F, 0x1DF, 0);
      Q_LoadPal_sub_2C158(&V_Type6_stru_D8654, "DATA\\game.pal", 0, 0x100u);
      sub_2C224(&V_Type6_stru_D8654, 0, 0x100, v10);
      dword_132B60 = 0xFFFFFFFF;
      dword_132B64 = 0;
      MOUSE_show();
      sub_2F424(a1, v13, a3, a4);
      result = v12;
      break;
    case 3:
    case 4:
    case 5:
      goto LABEL_14;
    case 0xA:
      if ( !sub_296B4(a1 + 0xAB, a1 + 0xAB, a3, a4) )
      {
        v7 = *(_WORD *)(a1 + 0x9F7) + 1;
        v8 = *(_WORD *)(a1 + 0x9F5);
        *(_WORD *)(a1 + 0x9F7) = v7;
        if ( v7 < v8 )
        {
          sub_2AF3C(a1);
        }
      }
      if ( *(_WORD *)(a1 + 0x9F7) >= *(_WORD *)(a1 + 0x9F5) )
      {
LABEL_14:
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xA);
        sub_56B60((int)&V_Type3_stru_10AE70, *(_WORD *)(a1 + 0x45), *(_DWORD *)(a1 + 0x47), *(_DWORD *)(a1 + 0x4B));
      }
      v12 = 0xFFFFFFFF;
      result = 0xFFFFFFFF;
      break;
    default:
      result = sub_2F424(a1, v13, a3, a4);
      break;
  }
  return result;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 132B60: using guessed type int dword_132B60;
// 132B64: using guessed type int dword_132B64;

//----- (0002B2C0) --------------------------------------------------------
void __fastcall __spoils<> sub_2B2C0(_DWORD *a1)
{
  *a1 = 0;
  a1[2] = 0;
  sub_2B2FC((int)a1, 0);
}

//----- (0002B2E0) --------------------------------------------------------
void **__fastcall sub_2B2E0(void **a1)
{
  if ( *a1 )
  {
    sub_2627C(*a1);
  }
  operator delete(*a1);
  return a1;
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0002B2FC) --------------------------------------------------------
unsigned int __fastcall sub_2B2FC(int a1, const char *aFName)
{
  void *v4; // eax
  int i; // eax

  *(_DWORD *)(a1 + 8) = &V_Type6_stru_D8654;
  if ( aFName )
  {
    return sub_2B360((void **)a1, aFName);
  }
  v4 = operator new[](0x100u);
  sub_2625C(v4, 1, "FONT TRANSLATE");
  *(_DWORD *)(a1 + 4) = v4;
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x5D);
  }
  for ( i = 0; i < 0x100; ++i )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + i) = i;
  }
  return 0xFFFFFFFF;
}

//----- (0002B360) --------------------------------------------------------
unsigned int __fastcall sub_2B360(void **a1, const char *aFName)
{
  void *v4; // eax
  T_Type1 v6; // [esp+0h] [ebp-124h] BYREF

  if ( !aFName )
  {
    return 0xFFFFFFFF;
  }
  Q_InitFileInfo_sub_1BB78(&v6);
  if ( !Q_CfilePreload_sub_1BBFC(&v6, aFName, O_BINARY, 0) )
  {
    if ( *a1 )
    {
      sub_2627C(*a1);
    }
    operator delete(*a1);
    v4 = Q_CfileLoad_sub_1BF1C(&v6, 0);
    *a1 = v4;
    if ( v4 )
    {
      Q_CloseFileAndDelete_sub_1BBC8(&v6);
      return 0xFFFFFFFF;
    }
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v6);
  return 0;
}
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0002B3E0) --------------------------------------------------------
_DWORD *__fastcall sub_2B3E0(_DWORD *result, int a2, int a3, int a4, int a5)
{
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  result[6] = a5;
  return result;
}

//----- (0002B3F4) --------------------------------------------------------
int __fastcall sub_2B3F4(int a1, char *s2, char *s1, int a4)
{
  char *v6; // esi
  char v7; // al
  int v8; // ecx
  const char *v9; // ebp
  _BYTE *v10; // esi
  char v11; // al
  char v13; // bl
  char *v14; // esi
  char v15; // al
  char v16; // al
  char v17[4]; // [esp+0h] [ebp-14h] BYREF
  int v18; // [esp+4h] [ebp-10h]

  v18 = a1;
  v6 = s2;
  while ( *v6 != 0x7C )
  {
    if ( *v6 )
    {
      v7 = *++v6;
      if ( *v6 == 0x7C )
      {
        break;
      }
      ++v6;
      if ( v7 )
      {
        continue;
      }
    }
    v6 = 0;
    break;
  }
  v8 = 0;
  if ( v6 )
  {
    if ( v6 != s2 )
    {
      strncpy(s1, s2, v6 - s2);
      s1[v6 - s2] = 0;
      return v6 - s2;
    }
    v9 = v6 + 1;
    v10 = v6 + 1;
    *s1 = 0;
    while ( *v10 != 0x7C )
    {
      if ( *v10 )
      {
        v11 = *++v10;
        if ( *v10 == 0x7C )
        {
          break;
        }
        ++v10;
        if ( v11 )
        {
          continue;
        }
      }
      v10 = 0;
      break;
    }
    if ( v10 )
    {
      v8 = v10 - v9 + 2;
      if ( v10 == v9 )
      {
        s1[1] = 0;
        *s1 = 0x7C;
        return v10 - v9 + 2;
      }
      if ( a4 == 0xFFFFFFFF )
      {
        strncpy(v17, v9, 3u);
        v17[3] = 0;
        v13 = atoi(v17);
        *(_BYTE *)(*(_DWORD *)(v18 + 4) + 0xF3) = v13;
        return v10 - v9 + 2;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v14 = s2;
    do
    {
      v15 = *v14;
      *s1 = *v14;
      if ( !v15 )
      {
        break;
      }
      v16 = v14[1];
      v14 += 2;
      s1[1] = v16;
      s1 += 2;
    }
    while ( v16 );
  }
  return v8;
}

//----- (0002B4F4) --------------------------------------------------------
int __fastcall sub_2B4F4(_DWORD *a1, char *string)
{
  int v3; // edi
  char *v4; // esi
  LONG v6; // [esp-4h] [ebp-24h]
  int i; // [esp+0h] [ebp-20h]
  char *ptr; // [esp+4h] [ebp-1Ch]
  char *s2; // [esp+8h] [ebp-18h]

  if ( !string )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0xD7);
  }
  if ( !*a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0xD8);
  }
  s2 = string;
  v3 = 0;
  ptr = strdup(string);
  do
  {
    v4 = ptr;
    for ( i = sub_2B3F4((int)a1, s2, ptr, 0); *v4; v3 += VFX_character_width((void *)*a1, v6) )
    {
      v6 = (unsigned __int8)*v4++;
    }
    s2 += i;
  }
  while ( i > 0 );
  free(ptr);
  return v3;
}

//----- (0002B594) --------------------------------------------------------
LONG __fastcall sub_2B594(int *a1)
{
  if ( !*a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x104);
  }
  return VFX_font_height((void *)*a1);
}

//----- (0002B5BC) --------------------------------------------------------
int __fastcall sub_2B5BC(int *a1, char *a2)
{
  LONG v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // ebx

  v3 = sub_2B594(a1);
  v4 = sub_2B4F4(a1, a2);
  v5 = a1[6] - a1[4] - v3;
  v6 = a1[5] - a1[3] - v4;
  if ( v5 >= 0 && v6 >= 0 )
  {
    return (v6 >> 1) + (v5 >> 1 << 0x10);
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (0002B610) --------------------------------------------------------
void __fastcall sub_2B610(_DWORD *a1, LONG a2, LONG a3, char *a4, int a5, int a6, __int16 a7)
{
  __int16 v8; // cx
  LONG v9; // ebx
  LONG v10; // edx
  LONG v11; // edi
  LONG v12; // eax
  LONG v13; // edx
  char *v14; // esi
  char *v15; // edi
  int v16; // eax
  PANE v17; // [esp+0h] [ebp-38h] BYREF
  int v18; // [esp+14h] [ebp-24h]
  LONG v19; // [esp+18h] [ebp-20h]
  char *string; // [esp+1Ch] [ebp-1Ch]
  PANE *pane; // [esp+20h] [ebp-18h]
  LONG y; // [esp+24h] [ebp-14h]
  LONG x; // [esp+28h] [ebp-10h]

  v19 = a2;
  y = a3;
  string = a4;
  v8 = a6;
  if ( !string )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x13B);
  }
  if ( !*a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\font.cpp", 0x13C);
  }
  if ( a7 == 0xFFFFFFFF )
  {
    a7 = *((_WORD *)a1 + 0xE);
  }
  if ( (__int16)a6 == 0xFFFFFFFF )
  {
    v8 = 0xF3;
  }
  if ( v8 != 0xFFFFFFFE )
  {
    *(_BYTE *)(a1[1] + 0xF3) = v8;
  }
  v9 = sub_2B594(a1);
  v17.window = (WINDOW *)a1[2];
  v17.x0 = a1[3];
  v17.y0 = a1[4];
  v17.x0 += v19;
  v17.y0 += y;
  v10 = sub_2B4F4(a1, string) + v17.x0;
  v17.x1 = v10;
  v17.y1 = v9 + v17.y0;
  v11 = a1[5];
  if ( v17.x0 <= v11 )
  {
    v12 = v10;
    v13 = a1[3];
    if ( v12 >= v13 && v17.y0 <= a1[6] && v17.y1 >= a1[4] )
    {
      if ( v13 <= v17.x0 )
      {
        if ( v11 < v17.x1 )
        {
          v17.x1 = a1[5];
        }
      }
      else
      {
        v17.x0 = a1[3];
      }
      if ( v17.y0 >= a1[4] )
      {
        if ( v17.y1 > a1[6] )
        {
          v17.y1 = a1[6];
        }
      }
      else
      {
        v17.y0 = a1[4];
      }
      if ( a7 != 0xFF )
      {
        VFX_pane_wipe(&v17, a7);
      }
      v14 = strdup(string);
      x = v19;
      v15 = string;
      pane = (PANE *)(a1 + 2);
      do
      {
        v18 = sub_2B3F4((int)a1, v15, v14, 0xFFFFFFFF);
        if ( *v14 )
        {
          VFX_string_draw(pane, x, y, (void *)*a1, v14, (UBYTE *)a1[1]);
        }
        v16 = sub_2B4F4(a1, v14);
        v15 += v18;
        x += v16;
      }
      while ( v18 > 0 );
      free(v14);
      if ( (a5 & 0xC0) == 0 )
      {
        sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&v17);
      }
    }
  }
}

//----- (0002B8A8) --------------------------------------------------------
int __fastcall sub_2B8A8(int a1, int a2, int a3, const char *a4, __int16 a5, __int16 a6, __int16 a7, int a8)
{
  __int16 v9; // ax
  char *v10; // ebp
  char *v11; // ebx
  char *v12; // ecx
  unsigned int v13; // edi
  int v14; // eax
  int v15; // eax
  int v16; // edx
  __int64 v17; // rax
  char *v18; // ebp
  int v19; // edx
  int v20; // edx
  int v22; // [esp+0h] [ebp-40h]
  int v23; // [esp+4h] [ebp-3Ch]
  char *ptr; // [esp+Ch] [ebp-34h]
  int i; // [esp+14h] [ebp-2Ch]
  int v27; // [esp+18h] [ebp-28h]
  int v29; // [esp+20h] [ebp-20h]
  char v30; // [esp+30h] [ebp-10h]

  if ( (a5 & 0x80) != 0 && a7 != 0xFF )
  {
    v9 = a7;
    if ( a7 == 0xFFFFFFFF )
    {
      v9 = *(_WORD *)(a1 + 0x1C);
    }
    VFX_pane_wipe((PANE *)(a1 + 8), v9);
  }
  if ( a6 == 0xFFFFFFFF )
  {
    LOBYTE(a6) = 0xF3;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 0xF3) = a6;
  if ( a8 < 1 )
  {
    a8 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  }
  ptr = strdup(a4);
  v10 = ptr;
  v11 = ptr;
  v12 = ptr;
  v29 = 1;
  v13 = 0;
  do
  {
    if ( !*v11 )
    {
      v13 = 0xFFFFFFFF;
    }
    v30 = *v11;
    *v11 = 0;
    v14 = sub_2B4F4((_DWORD *)a1, v10);
    *v11 = v30;
    if ( v30 == 0xA )
    {
      *v11++ = 0;
      v10 = v11;
      ++v29;
    }
    else if ( v14 <= a8 || v12 <= v10 )
    {
      if ( *v11 == 0x20 )
      {
        v12 = v11;
      }
      ++v11;
    }
    else
    {
      v10 = v12 + 1;
      *v12 = 0;
      v11 = v12 + 1;
      ++v29;
    }
  }
  while ( !v13 );
  v27 = sub_2B594((int *)a1) + 2;
  v22 = v29 * v27;
  if ( (a5 & 0x10) != 0 )
  {
    v15 = a3 - v22;
  }
  else
  {
    v16 = v22 + 1;
    if ( (a5 & 1) != 0 )
    {
      v17 = *(_DWORD *)(a1 + 0x18) - *(_DWORD *)(a1 + 0x10) - v16;
      v15 = ((int)v17 - HIDWORD(v17)) >> 1;
    }
    else
    {
      if ( (a5 & 4) != 0 )
      {
        v23 = a3 - v16 / 2;
        goto LABEL_30;
      }
      v15 = a3;
    }
  }
  v23 = v15;
LABEL_30:
  v18 = ptr;
  for ( i = 0; i < v29; ++i )
  {
    v19 = sub_2B4F4((_DWORD *)a1, v18);
    if ( (a5 & 0x20) != 0 )
    {
      v20 = a2 - v19;
    }
    else if ( (a5 & 2) != 0 )
    {
      v20 = (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) - v19) / 2;
    }
    else if ( (a5 & 8) != 0 )
    {
      v20 = a2 - v19 / 2;
    }
    else
    {
      v20 = a2;
    }
    sub_2B610((_DWORD *)a1, v20, v23, v18, a5, 0xFFFFFFFE, a7);
    v18 += strlen(v18) + 1;
    v23 += v27;
  }
  if ( (a5 & 0x80) != 0 )
  {
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 8));
  }
  free(ptr);
  return v29 * v27;
}
// 2B8A8: could not find valid save-restore pair for ebx

//----- (0002BB50) --------------------------------------------------------
int sub_2BB50()
{
  int result; // eax

  _wcpp_2_mod_register_(&unk_96780);
  result = sub_2BD4C((int)&V_Type6_stru_D8654);
  dword_96788 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96788: using guessed type int dword_96788;

//----- (0002BB74) --------------------------------------------------------
LONG __fastcall sub_2BB74(int **a1, int *a2, int *a3, int *a4, int *y0, unsigned __int8 a6, int a7)
{
  PANE source; // [esp+0h] [ebp-2Ch] BYREF
  LONG x1; // [esp+14h] [ebp-18h]
  LONG v11; // [esp+18h] [ebp-14h]
  LONG x0; // [esp+1Ch] [ebp-10h]

  x0 = (LONG)a2;
  v11 = (LONG)a3;
  x1 = (LONG)a4;
  if ( a7 == 0xFFFFFFFF )
  {
    source.window = (WINDOW *)*a1;
    source.x0 = x0;
    source.y1 = (LONG)y0;
    source.x1 = (LONG)a4;
    source.y0 = (LONG)a3;
    return VFX_pane_copy(&source, 0, 0, (PANE *)a1, x0, (LONG)a3, a6);
  }
  else
  {
    VFX_line_draw((PANE *)a1, x0, (LONG)a3, (LONG)a4, (LONG)a3, 0, a6);
    VFX_line_draw((PANE *)a1, x0, (LONG)y0, x1, (LONG)y0, 0, a6);
    VFX_line_draw((PANE *)a1, x0, v11, x0, (LONG)y0, 0, a6);
    return VFX_line_draw((PANE *)a1, x1, v11, x1, (LONG)y0, 0, a6);
  }
}
// 2BB74: could not find valid save-restore pair for ebx

//----- (0002BC40) --------------------------------------------------------
int __fastcall sub_2BC40(_DWORD *a1, void *a2, LONG a3, int *a4, int *a5)
{
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int result; // eax
  LONG v10; // [esp+0h] [ebp-24h] BYREF
  int v11; // [esp+4h] [ebp-20h]
  int v12; // [esp+8h] [ebp-1Ch]
  int v13; // [esp+Ch] [ebp-18h]
  LONG shape_number; // [esp+10h] [ebp-14h]
  void *shape_table; // [esp+14h] [ebp-10h]

  shape_table = a2;
  shape_number = a3;
  if ( !a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x40);
  }
  if ( !shape_table )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x41);
  }
  VFX_shape_visible_rectangle(shape_table, shape_number, 0, 0, 0, &v10);
  v6 = v13 - v11;
  v7 = a1[3] - a1[1] - (v12 - v10);
  *a4 = v7;
  if ( v7 )
  {
    *a4 = v7 / 2;
  }
  v8 = a1[4] - a1[2] - v6;
  *a5 = v8;
  if ( v8 )
  {
    *a5 = v8 / 2;
  }
  *a4 -= v10;
  result = v11;
  *a5 -= v11;
  return result;
}

//----- (0002BCF4) --------------------------------------------------------
__int64 __fastcall sub_2BCF4(int a1, unsigned __int8 a2)
{
  return sub_2BD04((int)&V_Type6_stru_D8654, a2, 0);
}

//----- (0002BD04) --------------------------------------------------------
__int64 __fastcall sub_2BD04(int a1, char a2, char *a3)
{
  char v4; // dh
  _BYTE *v5; // eax
  char v6; // dl
  char v7; // dl
  char v8; // dl
  char v10; // [esp+0h] [ebp-14h]
  char v11; // [esp+1h] [ebp-13h]
  char v12; // [esp+2h] [ebp-12h]

  if ( !a2 )
  {
    sub_2C2B0(a1, 0, 0x100, a1 + 0x133);
  }
  if ( a3 )
  {
    v10 = *a3;
    v11 = a3[1];
    v12 = a3[2];
  }
  else
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
  }
  v4 = 0x40 - a2;
  if ( (char)(0x40 - a2) < 0 )
  {
    v4 = 0;
  }
  v5 = (_BYTE *)a1;
  do
  {
    v8 = v5[0x133] - v10;
    if ( v8 >= 0 )
    {
      if ( (char)(v8 - v4) > 0 )
      {
        --v5[0x133];
      }
    }
    else if ( (char)(v4 + v8) < 0 )
    {
      ++v5[0x133];
    }
    v6 = v5[0x134] - v11;
    if ( v6 >= 0 )
    {
      if ( (char)(v6 - v4) > 0 )
      {
        --v5[0x134];
      }
    }
    else if ( (char)(v4 + v6) < 0 )
    {
      ++v5[0x134];
    }
    v7 = v5[0x135] - v12;
    if ( v7 >= 0 )
    {
      if ( (char)(v7 - v4) > 0 )
      {
        --v5[0x135];
      }
    }
    else if ( (char)(v4 + v7) < 0 )
    {
      ++v5[0x135];
    }
    v5 += 3;
  }
  while ( v5 != (_BYTE *)(a1 + 0x300) );
  return (unsigned int)sub_2C224((P_Type6)a1, 0, 0x100, (RGB *)(a1 + 0x133));
}

//----- (0002BD4C) --------------------------------------------------------
int __fastcall sub_2BD4C(int result)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 0x14) = 0;
  *(_DWORD *)(result + 0x12F) = 0;
  *(_BYTE *)(result + 0x30) = 0;
  *(_DWORD *)(result + 0x73B) = 0;
  *(_WORD *)(result + 0x73F) = 0;
  return result;
}

//----- (0002BD7C) --------------------------------------------------------
T_Type6 *__fastcall sub_2BD7C(T_Type6 *a1)
{
  sub_2C6CC(a1);
  return a1;
}

//----- (0002BD88) --------------------------------------------------------
unsigned int __fastcall sub_2BD88(P_Type6 a1, const char *a2, const char *a3)
{
  void *fname; // edx
  const char *v5; // esi
  char *v6; // edi
  char v7; // al
  char v8; // al
  const char *v9; // esi
  char *v10; // edi
  char v11; // al
  char v12; // al
  char *v13; // edi
  const char *v14; // esi
  char *v15; // edi
  char v16; // al
  char v17; // al
  const char *v18; // esi
  char *v19; // edi
  char v20; // al
  char v21; // al
  void *v22; // esi
  unsigned int result; // eax
  char *v24; // edi
  BYTE *v25; // esi
  int v26; // ecx
  bool v27; // zf
  BYTE *v28; // edi
  BYTE v29; // al
  BYTE v30; // al
  const char *v31; // esi
  char *v32; // edi
  char v33; // al
  char v34; // al
  UBYTE *buffer; // ecx
  UBYTE *v36; // eax
  int a; // eax
  int b; // eax
  int v39; // eax
  int v40; // eax
  UBYTE *v41; // edi
  char *v42; // [esp-4h] [ebp-234h]
  T_Type1 v43; // [esp+0h] [ebp-230h] BYREF
  char v44[256]; // [esp+118h] [ebp-118h] BYREF
  const char *v45; // [esp+218h] [ebp-18h]
  void *drvr; // [esp+21Ch] [ebp-14h]

  v45 = a2;
  fname = a1->fname;
  v5 = v45;
  v6 = a1->fname;
  v42 = a1->fname;
  do
  {
    v7 = *v5;
    *v6 = *v5;
    if ( !v7 )
    {
      break;
    }
    v8 = v5[1];
    v5 += 2;
    v6[1] = v8;
    v6 += 2;
  }
  while ( v8 );
  v9 = "\\";
  v10 = &v42[strlen(v42)];
  do
  {
    v11 = *v9;
    *v10 = *v9;
    if ( !v11 )
    {
      break;
    }
    v12 = v9[1];
    v9 += 2;
    v10[1] = v12;
    v10 += 2;
  }
  while ( v12 );
  v13 = v42;
  if ( a3 )
  {
    v31 = a3;
    v26 = 0xFFFFFFFF;
    do
    {
      if ( !v26 )
      {
        break;
      }
      v27 = *v13++ == 0;
      --v26;
    }
    while ( !v27 );
    v32 = v13 + 0xFFFFFFFF;
    do
    {
      v33 = *v31;
      *v32 = *v31;
      if ( !v33 )
      {
        break;
      }
      v34 = v31[1];
      v31 += 2;
      v32[1] = v34;
      v32 += 2;
    }
    while ( v34 );
  }
  else
  {
    v14 = v45;
    v15 = v44;
    do
    {
      v16 = *v14;
      *v15 = *v14;
      if ( !v16 )
      {
        break;
      }
      v17 = v14[1];
      v14 += 2;
      v15[1] = v17;
      v15 += 2;
    }
    while ( v17 );
    v18 = "\\VFXSCAN.DLL";
    a3 = (const char *)0x200;
    v19 = &v44[strlen(v44)];
    do
    {
      v20 = *v18;
      *v19 = *v18;
      if ( !v20 )
      {
        break;
      }
      v21 = v18[1];
      v18 += 2;
      v19[1] = v21;
      v19 += 2;
    }
    while ( v21 );
    Q_InitFileInfo_sub_1BB78(&v43);
    Q_CfilePreload_sub_1BBFC(&v43, v44, 0x200, 0);
    v22 = Q_CfileLoad_sub_1BF1C(&v43, 0);
    if ( !v22 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x9F);
    }
    Q_CloseFileAndDelete_sub_1BBC8(&v43);
    drvr = DLL_load(v22, 5u, 0);
    sub_2627C(v22);
    fname = drvr;
    operator delete(v22);
    if ( !fname )
    {
      return 0;
    }
    v24 = a1->fname;
    v25 = VFX_driver_name(fname);
    v26 = 0xFFFFFFFF;
    do
    {
      if ( !v26 )
      {
        break;
      }
      v27 = *v24++ == 0;
      --v26;
    }
    while ( !v27 );
    v28 = v24 + 0xFFFFFFFF;
    do
    {
      v29 = *v25;
      *v28 = *v25;
      if ( !v29 )
      {
        break;
      }
      v30 = v25[1];
      v25 += 2;
      v28[1] = v30;
      v28 += 2;
    }
    while ( v30 );
    free(drvr);
  }
  result = Q_GSYSTEM_CPP_sub_2BFDC(a1, (int)fname, (int)a3, v26);
  if ( result )
  {
    VFX_init_driver();
    buffer = a1->window.buffer;
    *(_DWORD *)&a1->fname[0xFF] = 0xFFFFFFFF;
    if ( buffer )
    {
      sub_262CC(buffer);
    }
    v36 = (UBYTE *)sub_262B0(a1->b * a1->a, 1u, 1, "OFFSCREEN BUFFER");
    a1->window.stencil = 0;
    a1->window.buffer = v36;
    a = a1->a;
    a1->window.shadow = 0;
    a1->window.x_max = a - 1;
    b = a1->b;
    a1->pane.x0 = 0;
    a1->window.y_max = b - 1;
    v39 = a1->a;
    a1->pane.y0 = 0;
    a1->pane.x1 = v39 - 1;
    v40 = a1->b;
    a1->pane.window = &a1->window;
    v41 = a1->window.buffer;
    a1->pane.y1 = v40 - 1;
    if ( !v41 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0xD9);
    }
    return 0xFFFFFFFF;
  }
  return result;
}
// 2BE8B: conditional instruction was optimized away because esi.4!=0
// 76D64: using guessed type void __fastcall operator delete(void *);
// 2BD88: using guessed type char var_118[256];

//----- (0002BFDC) --------------------------------------------------------
unsigned int __fastcall Q_GSYSTEM_CPP_sub_2BFDC(P_Type6 a1, int a2, int a3, int a4)
{
  void *v5; // esi
  void *v6; // edx
  VFX_DESC *VFX; // eax
  T_Type1 v9; // [esp-128h] [ebp-12Ch] BYREF
  int v10; // [esp-4h] [ebp-8h]

  v10 = a4;
  Q_InitFileInfo_sub_1BB78(&v9);
  Q_CfilePreload_sub_1BBFC(&v9, a1->fname, O_BINARY, 0);
  v5 = Q_CfileLoad_sub_1BF1C(&v9, 0);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0xEB);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v9);
  v6 = DLL_load(v5, DLLMEM_ALLOC|DLLSRC_MEM, 0);
  sub_2627C(v5);
  operator delete(v5);
  if ( !v6 )
  {
    return 0;
  }
  VFX_register_driver(v6);
  VFX = VFX_describe_driver();
  a1->a = VFX->scrn_width;
  a1->b = VFX->scrn_height;
  return 0xFFFFFFFF;
}
// 2C02A: conditional instruction was optimized away because esi.4!=0
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0002C08C) --------------------------------------------------------
void *__fastcall sub_2C08C(int a1, unsigned __int16 a2)
{
  void *result; // eax

  result = operator new[](a2 << 8);
  sub_2625C(result, 1, "GSYSTEM HAZE TABLES");
  *(_DWORD *)(a1 + 0x73B) = result;
  *(_WORD *)(a1 + 0x73F) = a2;
  return result;
}

//----- (0002C0C0) --------------------------------------------------------
int __fastcall sub_2C0C0(int a1, const char *a2, unsigned __int16 a3)
{
  void *v4; // eax
  int v5; // edi
  T_Type1 v7; // [esp+0h] [ebp-128h] BYREF

  if ( a3 >= *(__int16 *)(a1 + 0x73F) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x11F);
  }
  Q_InitFileInfo_sub_1BB78(&v7);
  Q_CfilePreload_sub_1BBFC(&v7, a2, 0x200, 0);
  v4 = Q_CfileLoad_sub_1BF1C(&v7, (void *)((a3 << 8) + *(_DWORD *)(a1 + 0x73B)));
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\gsystem.cpp", 0x127);
  }
  v5 = (v4 == 0) - 1;
  Q_CloseFileAndDelete_sub_1BBC8(&v7);
  return v5;
}

//----- (0002C158) --------------------------------------------------------
unsigned int __fastcall Q_LoadPal_sub_2C158(P_Type6 a1, const char *aFName, int a3, unsigned __int16 a4)
{
  T_Type1 v8; // [esp+0h] [ebp-124h] BYREF
  int v9; // [esp+118h] [ebp-Ch]

  v9 = a3;
  Q_InitFileInfo_sub_1BB78(&v8);
  Q_CfilePreload_sub_1BBFC(&v8, aFName, O_BINARY, 0);
  if ( !Q_CfileLoad_sub_1BF1C(&v8, a1->palette) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x13C);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v8);
  sub_2C224(a1, v9, a4, a1->palette);
  return 0xFFFFFFFF;
}
// 2C1AD: conditional instruction was optimized away because ecx.4!=0

//----- (0002C1E0) --------------------------------------------------------
int __fastcall sub_2C1E0(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned int a4)
{
  __int64 v5; // rax
  int v6; // ebx
  int v7; // esi

  v5 = a4;
  while ( SHIDWORD(v5) < a3 )
  {
    v6 = 3 * (HIDWORD(v5) + a2);
    v7 = v5;
    LODWORD(v5) = v5 + 3;
    ++HIDWORD(v5);
    *(_WORD *)(v6 + a1 + 0x433) = *(_WORD *)v7;
    *(_BYTE *)(v6 + a1 + 0x435) = *(_BYTE *)(v7 + 2);
  }
  return v5;
}

//----- (0002C224) --------------------------------------------------------
int __fastcall sub_2C224(P_Type6 a1, unsigned __int16 a2, __int16 a3, RGB *a4)
{
  LONG i; // esi
  int result; // eax
  RGB *v7; // [esp-2h] [ebp-10h]
  __int16 v8; // [esp+2h] [ebp-Ch]

  v8 = a2 + a3;
  VFX_wait_vblank_leading();
  for ( i = a2; ; ++i )
  {
    result = v8;
    if ( i >= v8 )
    {
      break;
    }
    v7 = a4++;
    VFX_DAC_write(i, v7);
  }
  return result;
}

//----- (0002C2B0) --------------------------------------------------------
int __fastcall sub_2C2B0(int a1, unsigned __int16 a2, __int16 a3, int a4)
{
  int v4; // edi
  LONG i; // esi
  int result; // eax
  RGB *v7; // [esp-2h] [ebp-10h]
  __int16 v8; // [esp+2h] [ebp-Ch]

  v4 = a4;
  if ( !a4 )
  {
    v4 = a1 + 0x433;
  }
  v8 = a2 + a3;
  VFX_wait_vblank_leading();
  for ( i = a2; ; ++i )
  {
    result = v8;
    if ( i >= v8 )
    {
      break;
    }
    v7 = (RGB *)v4;
    v4 += 3;
    VFX_DAC_read(i, v7);
  }
  return result;
}

//----- (0002C2F8) --------------------------------------------------------
void __fastcall sub_2C2F8(int a1, char *a2)
{
  int i; // ecx
  unsigned int v5; // eax

  for ( i = 0; i < 0x40; ++i )
  {
    sub_2BD04(a1, i, a2);
    v5 = i;
    delay(v5);
  }
}

//----- (0002C418) --------------------------------------------------------
void __fastcall sub_2C418(int a1, int a2, __int16 a3)
{
  __int16 v3; // si
  LONG v4; // [esp-8h] [ebp-1Ch]
  RGB v5; // [esp+0h] [ebp-14h] BYREF
  int v6; // [esp+4h] [ebp-10h]

  v6 = a2;
  v3 = a2;
  VFX_wait_vblank_leading();
  if ( (__int16)(a3 + a2) > (__int16)a2 )
  {
    do
    {
      VFX_DAC_read(v3, &v5);
      if ( v5.r )
      {
        --v5.r;
      }
      if ( v5.r )
      {
        --v5.r;
      }
      if ( v5.g )
      {
        --v5.g;
      }
      if ( v5.g )
      {
        --v5.g;
      }
      if ( v5.b )
      {
        --v5.b;
      }
      if ( v5.b )
      {
        --v5.b;
      }
      v4 = v3++;
      VFX_DAC_write(v4, &v5);
    }
    while ( v3 < (__int16)(a3 + a2) );
  }
  JUMPOUT(0x2C40E);
}
// 2C433: control flows out of bounds to 2C40E

//----- (0002C4C0) --------------------------------------------------------
void __fastcall sub_2C4C0(int a1, int a2, int a3)
{
  __int16 i; // si
  RGB v5; // [esp+0h] [ebp-1Ch] BYREF
  int v6; // [esp+4h] [ebp-18h]
  int v7; // [esp+8h] [ebp-14h]

  v6 = a2;
  VFX_wait_vblank_leading();
  v7 = a3 + a2;
  for ( i = a2; i < (__int16)v7; ++i )
  {
    VFX_DAC_read(i, &v5);
    if ( v5.r < *(_BYTE *)(a1 + 3 * i + 0x433) )
    {
      ++v5.r;
    }
    if ( v5.r < *(_BYTE *)(a1 + 3 * i + 0x433) )
    {
      ++v5.r;
    }
    if ( v5.g < *(_BYTE *)(a1 + 3 * i + 0x434) )
    {
      ++v5.g;
    }
    if ( v5.g < *(_BYTE *)(a1 + 3 * i + 0x434) )
    {
      ++v5.g;
    }
    if ( v5.b < *(_BYTE *)(a1 + 3 * i + 0x435) )
    {
      ++v5.b;
    }
    if ( v5.b < *(_BYTE *)(a1 + 3 * i + 0x435) )
    {
      ++v5.b;
    }
    VFX_DAC_write(i, &v5);
  }
}

//----- (0002C5E4) --------------------------------------------------------
__int64 __fastcall sub_2C5E4(int a1, char a2)
{
  _BYTE *v3; // ebx
  char v4; // dh
  _BYTE *v5; // eax
  char v6; // dl

  if ( !a2 )
  {
    sub_2C2B0(a1, 0, 0x100, a1 + 0x133);
  }
  v3 = (_BYTE *)(a1 + 0x433);
  v4 = 0x40 - a2;
  v5 = (_BYTE *)(a1 + 0x133);
  do
  {
    v6 = *v5 - *v3;
    if ( v6 >= 0 )
    {
      if ( (char)(v6 - v4) > 0 )
      {
        --*v5;
      }
    }
    else if ( (char)(v4 + v6) < 0 )
    {
      ++*v5;
    }
    ++v5;
    ++v3;
  }
  while ( v5 != (_BYTE *)(a1 + 0x433) );
  return (unsigned int)sub_2C224((P_Type6)a1, 0, 0x100, (RGB *)(a1 + 0x133));
}

//----- (0002C670) --------------------------------------------------------
void __fastcall sub_2C670(int a1, int a2, int a3, char *a4)
{
  RGB *v4; // edi
  __int16 v5; // si
  char v6[4]; // [esp+0h] [ebp-14h] BYREF
  int v7; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]

  v8 = a2;
  v4 = (RGB *)a4;
  if ( !a4 )
  {
    v4 = (RGB *)v6;
    v6[1] = 0;
    v6[2] = 0;
    v6[0] = 0;
  }
  v5 = v8;
  v7 = a3 + v8;
  VFX_wait_vblank_leading();
  for ( ; v5 < (__int16)v7; ++v5 )
  {
    VFX_DAC_write(v5, v4);
  }
}

//----- (0002C6CC) --------------------------------------------------------
void __fastcall sub_2C6CC(P_Type6 a1)
{
  UBYTE *buffer; // ebx

  if ( *(_DWORD *)&a1->fname[0xFF] == 0xFFFFFFFF )
  {
    VFX_shutdown_driver();
  }
  buffer = a1->window.buffer;
  *(_DWORD *)&a1->fname[0xFF] = 0;
  if ( buffer )
  {
    sub_262CC(buffer);
    a1->window.buffer = 0;
  }
  if ( a1->window.shadow )
  {
    sub_262CC(a1->window.shadow);
    a1->window.shadow = 0;
  }
  sub_2627C((void *)a1[1].window.x_max);
  operator delete[]((void *)a1[1].window.x_max);
  a1[1].window.x_max = 0;
  LOWORD(a1[1].window.y_max) = 0;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (0002C744) --------------------------------------------------------
void __fastcall Q_GSYSTEM_CPP_PreloadMouseShp_sub_2C744(P_Type6 a1, char *a2, int a3, int a4)
{
  void *v5; // eax
  T_Type1 v6; // [esp-124h] [ebp-128h] BYREF
  char *v7; // [esp-8h] [ebp-Ch]
  int v8; // [esp-4h] [ebp-8h]

  v8 = a4;
  v7 = a2;
  if ( dword_D8628 )
  {
    if ( !a1->c )
    {
      Q_InitFileInfo_sub_1BB78(&v6);
      Q_CfilePreload_sub_1BBFC(&v6, "DATA\\MOUSE.SHP", O_BINARY, 0);
      v5 = Q_CfileLoad_sub_1BF1C(&v6, 0);
      a1->c = (int)v5;
      if ( !v5 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x2B3);
      }
      a1[1].window.buffer = 0;
      Q_CloseFileAndDelete_sub_1BBC8(&v6);
    }
    MOUSE_set_pointer((void *)a1->c, (LONG)a1[1].window.buffer);
  }
}
// D8628: using guessed type int dword_D8628;

//----- (0002C7D0) --------------------------------------------------------
void __fastcall Q_GSYSTEM_CPP_sub_2C7D0(T_Type6 *a1, int a2, int a3)
{
  void *c; // ecx

  c = (void *)a3;
  if ( !a3 )
  {
    c = (void *)a1->c;
  }
  if ( !c )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x2C7);
  }
  if ( a2 < 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gsystem.cpp", 0x2C8);
  }
  MOUSE_set_pointer(c, a2);
}
// 2C80C: conditional instruction was optimized away because ecx.4!=0

//----- (0002C830) --------------------------------------------------------
void __fastcall __spoils<> sub_2C830(P_TypeA2 a1)
{
  a1->b = (int)off_95E20;
  sub_2C8E4(&a1->a);
}
// 95E20: using guessed type int (*off_95E20[5])();

//----- (0002C848) --------------------------------------------------------
int __fastcall sub_2C848(int a1, char a2)
{
  void *v3; // eax
  int v4; // edx
  __int16 i; // ax
  int v6; // edx
  _DWORD *v7; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D7C);
    operator delete[](v3);
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 0x67);
    *(_DWORD *)(a1 + 0xA7) = off_95E20;
    if ( v4 )
    {
      for ( i = 0; i < 0x14; ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * i);
        if ( v6 )
        {
          *(_DWORD *)(v6 + 0x63) = 0;
        }
      }
      sub_262CC(*(void **)(a1 + 0x67));
    }
    v7 = *(_DWORD **)(a1 + 0x63);
    if ( v7 )
    {
      sub_2CA0C(*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * (_DWORD)v7), a1, v7);
    }
    if ( (a2 & 2) != 0 )
    {
      operator delete((void *)a1);
    }
  }
  return a1;
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E20: using guessed type int (*off_95E20[5])();

//----- (0002C8E4) --------------------------------------------------------
void __fastcall __spoils<> sub_2C8E4(P_TypeA1 result)
{
  result->l = 0;
  result->b = 0;
  result->d = 0xFFFF;
  result->e = 0;
  result->f = 0xFFFF;
  result->g = 0;
  result->i = 0;
  result->j = 0;
  result->k = 0;
  result->r = 0xFFFF;
  result->s = 0xFFFF;
  result->t = 0xFFFF;
  result->u = 0;
  result->m = 0;
  result->n = 0;
  result->o = 0;
  result->p = 0;
  result->v = 0;
  result->w = 0;
  result->x = 0;
  result->z = 0;
  result->zz = 0xFFFFFFFF;
}

//----- (0002C978) --------------------------------------------------------
int __fastcall sub_2C978(P_TypeA1 a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0002C990) --------------------------------------------------------
unsigned int __fastcall sub_2C990(int a1, int a2)
{
  void *v3; // eax
  __int16 v4; // ax

  if ( !*(_WORD *)(a1 + 0x6B) )
  {
    if ( *(_DWORD *)(a1 + 0x67) )
    {
      sub_262CC(*(void **)(a1 + 0x67));
    }
    v3 = sub_2628C(0x50u, 1, "CHILD WINDOWS");
    *(_DWORD *)(a1 + 0x67) = v3;
    memset(v3, 0, 0x50u);
  }
  if ( *(__int16 *)(a1 + 0x6B) >= 0x14 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x94);
  }
  v4 = *(_WORD *)(a1 + 0x6B);
  *(_WORD *)(a1 + 0x6B) = v4 + 1;
  *(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * v4) = a2;
  return 0xFFFFFFFF;
}

//----- (0002CA0C) --------------------------------------------------------
unsigned int __fastcall sub_2CA0C(int a1, int a2, _DWORD *a3)
{
  unsigned int v3; // esi
  __int16 i; // kr00_2

  v3 = 0;
  if ( *(_DWORD *)(a1 + 0x67) )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      if ( a2 == *a3 )
      {
        *a3 = 0;
        v3 = 0xFFFFFFFF;
        --*(_WORD *)(a1 + 0x6B);
      }
    }
  }
  return v3;
}

//----- (0002CA78) --------------------------------------------------------
_DWORD *__fastcall sub_2CA78(_DWORD *result, __int16 a2, __int16 a3)
{
  int v3; // edi
  int v4; // ebp
  int v5; // esi

  v3 = result[3];
  v4 = result[5];
  v5 = a2 + result[4];
  result[2] += a2;
  result[4] = v5;
  result[3] = a3 + v3;
  result[5] = a3 + v4;
  return result;
}

//----- (0002CD24) --------------------------------------------------------
void __fastcall sub_2CD24(unsigned int a1, int a2)
{
  void *v2; // eax
  __int16 v3; // ax
  LONG v4; // [esp-18h] [ebp-1Ch]
  LONG v5; // [esp-14h] [ebp-18h]
  LONG v6; // [esp-Ch] [ebp-10h]

  if ( *(_DWORD *)(a1 + 0x39) )
  {
    if ( (*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(a1 + 0x41) || a2 == 3)
      && *(_DWORD *)(a1 + 0x3D)
      && a2 != 2 )
    {
      (*(void (__fastcall **)(unsigned int, int))(*(_DWORD *)(a1 + 0xA7) + 0x10))(a1, a2);
    }
    else
    {
      if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
      {
        if ( *(_WORD *)(a1 + 0xA1) )
        {
          sub_2D0F4(a1, 0);
        }
        else
        {
          VFX_pane_wipe((PANE *)(a1 + 4), 0xF2);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
          *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
          v3 = 0;
          if ( *(__int16 *)(a1 + 0x5B) == 0xFFFFFFFF )
          {
            v3 = 2;
          }
          if ( *(__int16 *)(a1 + 0x5D) == 0xFFFFFFFF )
          {
            LOBYTE(v3) = v3 | 1;
          }
          sub_2B8A8(
            (int)&V_Type3_stru_10AE70.z1[0x3046],
            *(__int16 *)(a1 + 0x5B),
            *(__int16 *)(a1 + 0x5D),
            (const char *)(a1 + 0x20),
            v3,
            0xFFFFFFFF,
            0xFF,
            0);
          if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
          {
            VFX_line_draw((PANE *)(a1 + 4), 0, 0, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), 0, 0, 0xF3);
            VFX_line_draw((PANE *)(a1 + 4), 0, 0, 0, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), 0, 0xF3);
            v5 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
            VFX_line_draw((PANE *)(a1 + 4), *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), v5, 0, v5, 0, 0xF3);
            v4 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
            VFX_line_draw((PANE *)(a1 + 4), v4, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), v4, 0, 0, 0xF3);
          }
        }
      }
      else
      {
        v6 = *(__int16 *)(a1 + 0x1E);
        v2 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
        VFX_shape_draw((PANE *)(a1 + 4), v2, v6, 0, 0);
      }
      sub_55274(
        &V_Type3_stru_10AE70,
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 0xC),
        *(_DWORD *)(a1 + 0x10),
        *(_DWORD *)(a1 + 0x14));
    }
    if ( *(_WORD *)(a1 + 0x6B) )
    {
      sub_2D218((_DWORD *)a1);
    }
  }
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002CF28) --------------------------------------------------------
void __fastcall sub_2CF28(unsigned int a1)
{
  PANE *v1; // esi
  void *v2; // eax
  __int16 v3; // ax
  LONG v4; // [esp-18h] [ebp-1Ch]
  LONG v5; // [esp-14h] [ebp-18h]
  LONG v6; // [esp-Ch] [ebp-10h]

  v1 = (PANE *)(a1 + 4);
  if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
  {
    if ( *(_WORD *)(a1 + 0xA1) )
    {
      sub_2D0F4(a1, 1);
    }
    else
    {
      VFX_pane_wipe((PANE *)(a1 + 4), 0x96);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
      v3 = 0;
      if ( *(__int16 *)(a1 + 0x5B) == 0xFFFFFFFF )
      {
        v3 = 2;
      }
      if ( *(__int16 *)(a1 + 0x5D) == 0xFFFFFFFF )
      {
        LOBYTE(v3) = v3 | 1;
      }
      sub_2B8A8(
        (int)&V_Type3_stru_10AE70.z1[0x3046],
        *(__int16 *)(a1 + 0x5B),
        *(__int16 *)(a1 + 0x5D),
        (const char *)(a1 + 0x20),
        v3,
        0xFFFFFFFF,
        0xFF,
        0);
      if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
      {
        VFX_line_draw((PANE *)(a1 + 4), 0, 0, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), 0, 0, 0xF3);
        VFX_line_draw((PANE *)(a1 + 4), 0, 0, 0, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), 0, 0xF3);
        v5 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
        VFX_line_draw((PANE *)(a1 + 4), *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), v5, 0, v5, 0, 0xF3);
        v4 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
        VFX_line_draw((PANE *)(a1 + 4), v4, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), v4, 0, 0, 0xF3);
      }
    }
  }
  else
  {
    VFX_shape_lookaside(*(UBYTE **)&V_Type3_stru_10AE70.z1[0x3012]);
    v6 = *(__int16 *)(a1 + 0x1E);
    v2 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    VFX_shape_translate_draw(v1, v2, v6, 0, 0);
  }
  sub_55274(
    &V_Type3_stru_10AE70,
    *(_DWORD *)(a1 + 8),
    *(_DWORD *)(a1 + 0xC),
    *(_DWORD *)(a1 + 0x10),
    *(_DWORD *)(a1 + 0x14));
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002D0F4) --------------------------------------------------------
unsigned int __fastcall sub_2D0F4(unsigned int a1, int a2)
{
  LONG v2; // eax
  PANE *v3; // esi
  unsigned int result; // eax
  unsigned int i; // ebp
  char *v6; // eax
  int v7; // ebx
  int v8; // edx
  void *v9; // eax
  __int16 v10; // [esp-10h] [ebp-30h]
  LONG v11; // [esp-Ch] [ebp-2Ch]
  LONG v12; // [esp-8h] [ebp-28h]
  LONG v13; // [esp-4h] [ebp-24h]
  int v15; // [esp+8h] [ebp-18h]

  v2 = 0xF2;
  if ( a2 )
  {
    v2 = 0x96;
  }
  v3 = (PANE *)(a1 + 4);
  VFX_pane_wipe((PANE *)(a1 + 4), v2);
  result = a1;
  v15 = 0;
  for ( i = a1 + 0x6D; (__int16)v15 < *(__int16 *)(a1 + 0xA1); ++v15 )
  {
    if ( !i )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x1CE);
    }
    if ( *(_BYTE *)i )
    {
      if ( *(_BYTE *)i != 1 )
      {
        Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x1DF);
      }
      v13 = *(__int16 *)(i + 0xB);
      v12 = *(__int16 *)(i + 9);
      v11 = *(_DWORD *)(i + 5);
      v9 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(i + 1));
      VFX_shape_draw(v3, v9, v11, v12, v13);
    }
    else
    {
      v6 = sub_2D3D0(*(_DWORD *)(i + 1));
      v7 = *(__int16 *)(i + 0xB);
      v8 = *(int *)(i + 7) >> 0x10;
      v10 = *(_WORD *)(i + 5);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v3->window;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
      result = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], v8, v7, v6, v10, 0xF3, 0xFF, 0);
    }
    i += 0xD;
  }
  return result;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002D218) --------------------------------------------------------
void __fastcall sub_2D218(_DWORD *a1)
{
  __int16 i; // kr00_2
  int v2; // ecx

  if ( *(_DWORD *)((char *)a1 + 0x67) )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      v2 = *a1;
      if ( *a1 )
      {
        a1 = (_DWORD *)*a1;
        if ( *(_DWORD *)(v2 + 0x39) == 0xFFFFFFFF )
        {
          (*(void (__fastcall **)(_DWORD *, _DWORD))(*(_DWORD *)(v2 + 0xA7) + 0xC))(a1, 0);
        }
      }
    }
  }
  JUMPOUT(0x2D210);
}
// 2D222: control flows out of bounds to 2D210

//----- (0002D258) --------------------------------------------------------
int __fastcall sub_2D258(int result, __int16 a2)
{
  int v2; // edi
  __int16 i; // si
  int v4; // ebx

  v2 = result;
  if ( *(_DWORD *)(result + 0x67) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= 0x14 )
      {
        break;
      }
      v4 = *(_DWORD *)(4 * i + *(_DWORD *)(v2 + 0x67));
      if ( v4 && (*(_DWORD *)(v4 + 0x35) || a2 == 1) )
      {
        (*(void (**)(void))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 0x67) + 4 * i) + 0xA7) + 8))();
      }
    }
  }
  return result;
}

//----- (0002D2CC) --------------------------------------------------------
int __fastcall sub_2D2CC(int a1, int a2, int a3, int a4)
{
  FILE *v4; // ecx
  int i; // ebx
  char v7[56]; // [esp+0h] [ebp-40h] BYREF
  int v8; // [esp+38h] [ebp-8h]

  v8 = a4;
  v4 = sub_1BB10("gwshare.txt", 0);
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x214);
  }
  for ( i = 0; i != 0x2D; word_FFE9E[i] = sub_1ADAC((int)dword_12FC20, v7) )
  {
    fscanf(v4, "%s", v7);
    ++i;
  }
  return fclose(v4);
}
// FFE9E: using guessed type __int16 word_FFE9E[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 2D2CC: using guessed type char var_40[56];

//----- (0002D334) --------------------------------------------------------
int __fastcall sub_2D334(const char *a1)
{
  const char *v1; // esi
  unsigned int v2; // kr04_4
  char *v3; // edi
  char v4; // al
  char v5; // al
  int result; // eax

  v1 = a1;
  if ( !a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x226);
  }
  v2 = strlen(a1) + 1;
  if ( (int)(v2 - 1 + SHIWORD(dword_100302)) >= 0x400 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x229);
  }
  v3 = (char *)&unk_FFF04 + SHIWORD(dword_100302);
  do
  {
    v4 = *v1;
    *v3 = *v1;
    if ( !v4 )
    {
      break;
    }
    v5 = v1[1];
    v1 += 2;
    v3[1] = v5;
    v3 += 2;
  }
  while ( v5 );
  result = SHIWORD(dword_100302);
  HIWORD(dword_100302) += v2;
  return result;
}
// 100302: using guessed type int dword_100302;

//----- (0002D3D0) --------------------------------------------------------
char *__fastcall sub_2D3D0(int a1)
{
  if ( a1 >= SHIWORD(dword_100302) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x237);
  }
  return (char *)&unk_FFF04 + a1;
}
// 100302: using guessed type int dword_100302;

//----- (0002D400) --------------------------------------------------------
unsigned int __fastcall sub_2D400(int a1, int a2)
{
  __int16 v3; // cx
  unsigned int result; // eax

  if ( *(__int16 *)(a1 + 0xA1) >= 4 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x241);
  }
  v3 = *(_WORD *)(a1 + 0xA1);
  *(_WORD *)(a1 + 0xA1) = v3 + 1;
  result = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0xD * v3 + 0x6D) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 0xD * v3 + 0x71) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 0xD * v3 + 0x75) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 0xD * v3 + 0x79) = *(_BYTE *)(a2 + 0xC);
  return result;
}

//----- (0002D464) --------------------------------------------------------
void __fastcall __spoils<> sub_2D464(P_TypeA4 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95E08;
  sub_2D4C4(a1);
}
// 95E08: using guessed type int (*off_95E08[5])();

//----- (0002D480) --------------------------------------------------------
void *__fastcall sub_2D480(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D68);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95E08;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E08: using guessed type int (*off_95E08[5])();

//----- (0002D4C4) --------------------------------------------------------
void __fastcall __spoils<> sub_2D4C4(P_TypeA4 result)
{
  result->b = 0;
}

//----- (0002D4D0) --------------------------------------------------------
unsigned int __fastcall sub_2D4D0(_DWORD *a1, __int16 a2, int a3, int a4)
{
  if ( (unsigned __int16)a2 < 4u || (unsigned __int16)a2 > 5u || a3 < a1[2] || a3 > a1[4] || a4 < a1[3] || a4 > a1[5] )
  {
    return sub_2F424((int)a1, a2, a3, a4);
  }
  *(_DWORD *)((char *)a1 + 0xAB) = ~*(_DWORD *)((char *)a1 + 0xAB);
  (*(void (__fastcall **)(_DWORD *, _DWORD))(*(_DWORD *)((char *)a1 + 0xA7) + 0x10))(a1, 0);
  return sub_2F424((int)a1, a2, a3, a4);
}

//----- (0002D528) --------------------------------------------------------
void __fastcall sub_2D528(int a1, int a2)
{
  PANE *v2; // esi
  void *v3; // eax
  void *v4; // eax
  LONG v5; // eax
  LONG v6; // [esp-18h] [ebp-1Ch]
  LONG v7; // [esp-14h] [ebp-18h]
  LONG v8; // [esp-Ch] [ebp-10h]
  LONG v9; // [esp-Ch] [ebp-10h]
  UBYTE *v10; // [esp-4h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 0x39) )
  {
    if ( (*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(a1 + 0x41) || a2 == 3)
      && *(_DWORD *)(a1 + 0x3D)
      && a2 != 2 )
    {
      (*(void (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0x10))(a1, a2);
    }
    else
    {
      if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
      {
        v5 = 0xF2;
        if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
        {
          v5 = 0x50;
        }
        VFX_pane_wipe((PANE *)(a1 + 4), v5);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
        if ( *(__int16 *)(a1 + 0x5B) == 0xFFFFFFFF && *(__int16 *)(a1 + 0x5D) == 0xFFFFFFFF )
        {
          sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, (const char *)(a1 + 0x20), 3, 0xFFFFFFFF, 0xFF, 0);
        }
        else
        {
          sub_2B8A8(
            (int)&V_Type3_stru_10AE70.z1[0x3046],
            *(__int16 *)(a1 + 0x5B),
            *(__int16 *)(a1 + 0x5D),
            (const char *)(a1 + 0x20),
            0,
            0xFFFFFFFF,
            0xFF,
            0);
        }
        if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
        {
          VFX_line_draw((PANE *)(a1 + 4), 0, 0, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), 0, 0, 0xF3);
          VFX_line_draw((PANE *)(a1 + 4), 0, 0, 0, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), 0, 0xF3);
          v7 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
          VFX_line_draw((PANE *)(a1 + 4), *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), v7, 0, v7, 0, 0xF3);
          v6 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
          VFX_line_draw((PANE *)(a1 + 4), v6, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), v6, 0, 0, 0xF3);
        }
      }
      else
      {
        v2 = (PANE *)(a1 + 4);
        if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
        {
          v10 = *(UBYTE **)&V_Type3_stru_10AE70.z1[0x3012];
          *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0x50;
          VFX_shape_lookaside(v10);
          v8 = *(__int16 *)(a1 + 0x1E);
          v3 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
          VFX_shape_translate_draw(v2, v3, v8, 0, 0);
          *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0x96;
        }
        else
        {
          v9 = *(__int16 *)(a1 + 0x1E);
          v4 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
          VFX_shape_draw(v2, v4, v9, 0, 0);
        }
      }
      sub_55274(
        &V_Type3_stru_10AE70,
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 0xC),
        *(_DWORD *)(a1 + 0x10),
        *(_DWORD *)(a1 + 0x14));
    }
    if ( *(_WORD *)(a1 + 0x6B) )
    {
      sub_2D218((_DWORD *)a1);
    }
  }
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002D79C) --------------------------------------------------------
void __fastcall sub_2D79C(int a1)
{
  PANE *v1; // esi
  void *v2; // eax
  void *v3; // eax
  LONG v4; // eax
  LONG v5; // [esp-18h] [ebp-20h]
  LONG v6; // [esp-14h] [ebp-1Ch]
  LONG v7; // [esp-Ch] [ebp-14h]
  LONG v8; // [esp-Ch] [ebp-14h]
  UBYTE *v9; // [esp-4h] [ebp-Ch]
  PANE *pane; // [esp+0h] [ebp-8h]

  if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
  {
    v4 = 0x96;
    if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
    {
      v4 = 0xCA;
    }
    pane = (PANE *)(a1 + 4);
    VFX_pane_wipe((PANE *)(a1 + 4), v4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, (const char *)(a1 + 0x20), 3, 0xFFFFFFFF, 0xFF, 0);
    if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
    {
      VFX_line_draw(pane, 0, 0, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), 0, 0, 0xF3);
      VFX_line_draw(pane, 0, 0, 0, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), 0, 0xF3);
      v6 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
      VFX_line_draw(pane, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), v6, 0, v6, 0, 0xF3);
      v5 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
      VFX_line_draw(pane, v5, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), v5, 0, 0, 0xF3);
    }
  }
  else
  {
    v1 = (PANE *)(a1 + 4);
    if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
    {
      v9 = *(UBYTE **)&V_Type3_stru_10AE70.z1[0x3012];
      *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0xCA;
      VFX_shape_lookaside(v9);
      v7 = *(__int16 *)(a1 + 0x1E);
      v2 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
      VFX_shape_translate_draw(v1, v2, v7, 0, 0);
      *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = 0x96;
    }
    else
    {
      VFX_shape_lookaside(*(UBYTE **)&V_Type3_stru_10AE70.z1[0x3012]);
      v8 = *(__int16 *)(a1 + 0x1E);
      v3 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
      VFX_shape_translate_draw(v1, v3, v8, 0, 0);
    }
  }
  sub_55274(
    &V_Type3_stru_10AE70,
    *(_DWORD *)(a1 + 8),
    *(_DWORD *)(a1 + 0xC),
    *(_DWORD *)(a1 + 0x10),
    *(_DWORD *)(a1 + 0x14));
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002D99C) --------------------------------------------------------
int __fastcall sub_2D99C(int a1, unsigned int count, int a3)
{
  void *v5; // edx

  v5 = (void *)(a1 + 0xAB);
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, v5, 4u);
  }
  else
  {
    return sub_1C098(count, (int)v5, 4u);
  }
}

//----- (0002D9C4) --------------------------------------------------------
int __fastcall sub_2D9C4(int a1)
{
  sub_2C830((P_TypeA2)a1);
  *(_DWORD *)(a1 + 0xA7) = off_95DF0;
  *(_DWORD *)(a1 + 0xAB) = 0;
  *(_WORD *)(a1 + 0xAF) = 0;
  *(_WORD *)(a1 + 0xB1) = 0xFFFF;
  sub_2DA60(a1);
  return a1;
}
// 95DF0: using guessed type int (*off_95DF0[5])();

//----- (0002D9FC) --------------------------------------------------------
void *__fastcall sub_2D9FC(int a1, char a2)
{
  void *v4; // eax
  void *v6; // edx
  void *v7; // eax
  void *v8; // ebx

  if ( (a2 & 4) != 0 )
  {
    v4 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D54);
    operator delete[](v4);
    return (void *)a1;
  }
  else
  {
    v6 = *(void **)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xA7) = off_95DF0;
    if ( v6 )
    {
      sub_262CC(v6);
      *(_DWORD *)(a1 + 0xAB) = 0;
    }
    v7 = (void *)sub_2C848(a1, 1);
    v8 = v7;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v7);
    }
    return v8;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DF0: using guessed type int (*off_95DF0[5])();

//----- (0002DA60) --------------------------------------------------------
int __fastcall sub_2DA60(int result)
{
  *(_WORD *)(result + 0x59) = 7;
  return result;
}

//----- (0002DA68) --------------------------------------------------------
int __fastcall sub_2DA68(T_TypeA1 *a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0002DA80) --------------------------------------------------------
void *__fastcall sub_2DA80(int a1, __int16 a2)
{
  void *result; // eax

  if ( a2 <= 0 )
  {
    return 0;
  }
  result = sub_262B0(a2, 0xEu, 1, "CONTROLS");
  *(_DWORD *)(a1 + 0xAB) = result;
  if ( result )
  {
    result = (void *)0xFFFFFFFF;
    *(_WORD *)(a1 + 0xAF) = a2;
  }
  return result;
}

//----- (0002DAC8) --------------------------------------------------------
unsigned int __fastcall sub_2DAC8(int a1, __int16 a2, __int16 a3, int a4)
{
  int v6; // eax
  int i; // edx
  int v8; // eax
  int v9; // edi

  v6 = 0;
  for ( i = 0; v6 < *(__int16 *)(a1 + 0xAF) && a2 != *(_WORD *)(i + *(_DWORD *)(a1 + 0xAB)); i += 0xE )
  {
    ++v6;
  }
  if ( v6 >= *(__int16 *)(a1 + 0xAF) )
  {
    return 0;
  }
  v8 = 0xE * v6;
  if ( a4 )
  {
    v9 = v8 + *(_DWORD *)(a1 + 0xAB);
    qmemcpy((void *)v9, (const void *)a4, 0xCu);
    qmemcpy((void *)(v9 + 0xC), (const void *)(a4 + 0xC), 2u);
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + v8 + 0xA) = a3;
  }
  return 0xFFFFFFFF;
}

//----- (0002DB54) --------------------------------------------------------
int __fastcall sub_2DB54(int result, __int16 a2, __int16 a3)
{
  int v4; // edi
  int v5; // ebp
  int v6; // ecx
  int v7; // ebx
  __int16 v8; // dx
  int v9; // edx

  v4 = *(_DWORD *)(result + 0xC);
  v5 = *(_DWORD *)(result + 0x14);
  v6 = a2 + *(_DWORD *)(result + 0x10);
  *(_DWORD *)(result + 8) += a2;
  *(_DWORD *)(result + 0x10) = v6;
  v7 = 0;
  *(_DWORD *)(result + 0xC) = a3 + v4;
  v8 = *(_WORD *)(result + 0xAF);
  *(_DWORD *)(result + 0x14) = a3 + v5;
  if ( v8 > 0 )
  {
    do
    {
      v9 = 0xE * (__int16)v7;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 2) += a2;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 4) += a2;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 6) += a3;
      *(_WORD *)(*(_DWORD *)(result + 0xAB) + v9 + 8) += a3;
      ++v7;
    }
    while ( (__int16)v7 < *(__int16 *)(result + 0xAF) );
  }
  return result;
}

//----- (0002DBE4) --------------------------------------------------------
int __fastcall sub_2DBE4(int a1, int a2, int a3)
{
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // eax

  v4 = a2;
  v5 = *(__int16 *)(a1 + 0xB1);
  if ( v5 != 0xFFFFFFFF )
  {
    v6 = 0xE * v5 + *(_DWORD *)(a1 + 0xAB);
    if ( a2 <= *(__int16 *)(v6 + 4)
      && a2 >= *(int *)v6 >> 0x10
      && a3 <= *(__int16 *)(v6 + 8)
      && a3 >= *(__int16 *)(v6 + 6) )
    {
      LOWORD(a2) = *(_WORD *)(a1 + 0xB1);
      return a2;
    }
  }
  v7 = 0;
  if ( *(__int16 *)(a1 + 0xAF) <= 0 )
  {
    return 0xFFFFFFFF;
  }
  while ( 1 )
  {
    v8 = *(_DWORD *)(a1 + 0xAB) + 0xE * (__int16)v7;
    if ( v4 <= *(__int16 *)(v8 + 4)
      && v4 >= *(int *)v8 >> 0x10
      && a3 <= *(__int16 *)(v8 + 8)
      && a3 >= *(__int16 *)(v8 + 6) )
    {
      break;
    }
    if ( (__int16)++v7 >= *(__int16 *)(a1 + 0xAF) )
    {
      return 0xFFFFFFFF;
    }
  }
  return v7;
}

//----- (0002DCA0) --------------------------------------------------------
int __fastcall sub_2DCA0(int result, __int16 a2)
{
  int v2; // ecx
  int v4; // edx

  v2 = result;
  if ( a2 != *(_WORD *)(result + 0xB1) )
  {
    if ( a2 >= *(__int16 *)(result + 0xAF) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x396);
    }
    v4 = *(__int16 *)(result + 0xB1);
    if ( v4 != 0xFFFFFFFF )
    {
      result = 7 * v4;
      *(_BYTE *)(*(_DWORD *)(v2 + 0xAB) + 0xE * v4 + 0xA) &= ~2u;
    }
    if ( a2 != 0xFFFFFFFF )
    {
      result = *(_DWORD *)(v2 + 0xAB) + 0xE * a2;
      if ( (*(_WORD *)(result + 0xA) & 1) != 0 )
      {
        *(_BYTE *)(result + 0xA) |= 2u;
      }
    }
    *(_WORD *)(v2 + 0xB1) = a2;
  }
  return result;
}

//----- (0002DD70) --------------------------------------------------------
int __fastcall sub_2DD70(int a1)
{
  int result; // eax

  for ( result = 0; (__int16)result < SHIWORD(dword_A3CF2); ++result )
  {
    *(_WORD *)(0xE * (__int16)result + *(_DWORD *)(a1 + 0xAB) + 0xC) = 5
                                                                     * (unsigned __int8)byte_A2F74[0x1EE
                                                                                                 * (__int16)result]
                                                                     + 0x14;
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;

//----- (0002DDB8) --------------------------------------------------------
unsigned int __fastcall sub_2DDB8(int a1, __int16 a2)
{
  int v2; // eax

  if ( a2 >= *(__int16 *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x3CD);
  }
  if ( a2 == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x3CE);
  }
  v2 = 0xE * a2 + *(_DWORD *)(a1 + 0xAB);
  if ( (*(_WORD *)(v2 + 0xA) & 1) == 0 )
  {
    return 0;
  }
  if ( (*(_WORD *)(v2 + 0xA) & 4) != 0 )
  {
    *(_BYTE *)(v2 + 0xA) &= ~4u;
  }
  else
  {
    *(_BYTE *)(v2 + 0xA) |= 4u;
  }
  return 0xFFFFFFFF;
}

//----- (0002DE68) --------------------------------------------------------
unsigned int __fastcall sub_2DE68(int a1, __int16 a2, int a3, int a4)
{
  unsigned int result; // eax
  __int16 v6; // ax
  __int16 v7; // bx
  int v8; // edx
  int v9; // edi
  unsigned int v10; // ebx
  __int16 i; // [esp+6h] [ebp-Ch]

  switch ( a2 )
  {
    case 1:
      sub_2DD70(a1);
      sub_2F424(a1, a2, a3, a4);
      goto LABEL_3;
    case 4:
    case 5:
      if ( a3 < *(_DWORD *)(a1 + 8)
        || a3 > *(_DWORD *)(a1 + 0x10)
        || a4 < *(_DWORD *)(a1 + 0xC)
        || a4 > *(_DWORD *)(a1 + 0x14) )
      {
LABEL_3:
        result = 0;
      }
      else
      {
        v7 = sub_2DBE4(a1, a3, a4);
        if ( v7 != 0xFFFFFFFF )
        {
          v8 = *(__int16 *)(a1 + 0x59);
          if ( v8 != 0xFFFFFFFF )
          {
            sub_4FB90((int)&unk_10914C, v8);
          }
          v9 = v7;
          sub_2DCA0(a1, v7);
          v10 = sub_2DDB8(a1, v7);
          (*(void (__fastcall **)(int, _DWORD, unsigned int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0, v10);
          if ( v10 == 0xFFFFFFFF )
          {
            if ( *(_DWORD *)(a1 + 0x63) )
            {
              sub_56D30(
                (int)&V_Type3_stru_10AE70,
                *(_DWORD *)(a1 + 0x63),
                *(__int16 *)(a1 + 0x45),
                *(__int16 *)(*(_DWORD *)(a1 + 0xAB) + 0xE * v9),
                0);
            }
          }
        }
        result = 0xFFFFFFFF;
      }
      break;
    case 6:
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      result = 0xFFFFFFFF;
      break;
    case 7:
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
      result = 0xFFFFFFFF;
      break;
    case 8:
      v6 = sub_2DBE4(a1, a3, a4);
      if ( v6 != *(_WORD *)(a1 + 0xB1) )
      {
        sub_2DCA0(a1, v6);
        (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
      }
      result = 0xFFFFFFFF;
      break;
    case 9:
      if ( a3 == 0xFFFFFFFF )
      {
        for ( i = 0; i < *(__int16 *)(a1 + 0xAF); ++i )
        {
          sub_2DAC8(a1, 1 << i, a4, 0);
        }
      }
      else
      {
        sub_2DAC8(a1, a3, a4, 0);
      }
      result = 0xFFFFFFFF;
      break;
    default:
      result = sub_2F424(a1, a2, a3, a4);
      break;
  }
  return result;
}

//----- (0002E084) --------------------------------------------------------
void __fastcall sub_2E084(int a1)
{
  void *v2; // eax
  int v3; // ecx
  __int16 v4; // si
  void *v5; // eax
  LONG v6; // [esp-Ch] [ebp-18h]
  LONG v7; // [esp-Ch] [ebp-18h]
  LONG v8; // [esp-8h] [ebp-14h]
  LONG v9; // [esp-4h] [ebp-10h]
  __int16 i; // [esp+8h] [ebp-4h]
  __int16 savedregs_4; // [esp+10h] [ebp+4h]

  v6 = *(__int16 *)(a1 + 0x1E);
  v2 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  VFX_shape_draw((PANE *)(a1 + 4), v2, v6, 0, 0);
  for ( i = 0; i < *(__int16 *)(a1 + 0xAF); ++i )
  {
    v3 = 0xE * savedregs_4 + *(_DWORD *)(a1 + 0xAB);
    switch ( *(_WORD *)(v3 + 0xA) )
    {
      case 0:
        v4 = 4;
        break;
      case 1:
        v4 = 0;
        break;
      case 3:
        v4 = 1;
        break;
      case 5:
        v4 = 2;
        break;
      case 7:
        v4 = 3;
        break;
      default:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x48A);
    }
    v9 = *(__int16 *)(v3 + 6) - *(_DWORD *)(a1 + 0xC);
    v8 = (*(int *)v3 >> 0x10) - *(_DWORD *)(a1 + 8);
    v7 = *(__int16 *)(v3 + 0xC) + v4;
    v5 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    VFX_shape_draw((PANE *)(a1 + 4), v5, v7, v8, v9);
  }
  sub_55274(
    &V_Type3_stru_10AE70,
    *(_DWORD *)(a1 + 8),
    *(_DWORD *)(a1 + 0xC),
    *(_DWORD *)(a1 + 0x10),
    *(_DWORD *)(a1 + 0x14));
}
// 2E0DC: variable 'savedregs_4' is possibly undefined
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002E1B4) --------------------------------------------------------
int __fastcall sub_2E1B4(int a1, unsigned int count, int a3)
{
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, *(void **)(a1 + 0xAB), 0xE * *(__int16 *)(a1 + 0xAF));
  }
  else
  {
    return sub_1C098(count, *(_DWORD *)(a1 + 0xAB), 0xE * *(__int16 *)(a1 + 0xAF));
  }
}

//----- (0002E208) --------------------------------------------------------
int __fastcall sub_2E208(_DWORD *a1, const char *a2, int a3, int a4)
{
  __int16 v4; // bx

  v4 = 0xF2;
  if ( a4 == 0xFFFFFFFF )
  {
    v4 = 0x96;
  }
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 1, 1, a2, 0, 0xFFFFFFFF, v4, 0);
}

//----- (0002E248) --------------------------------------------------------
T_TypeA2 *__fastcall sub_2E248(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95DD8;
  sub_2E2B8((int)a1);
  return a1;
}
// 95DD8: using guessed type int (*off_95DD8[5])();

//----- (0002E264) --------------------------------------------------------
void *__fastcall sub_2E264(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D40);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95DD8;
    sub_2ED4C(a1);
    sub_2F2B4(a1);
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DD8: using guessed type int (*off_95DD8[5])();

//----- (0002E2B8) --------------------------------------------------------
int __fastcall sub_2E2B8(int a1)
{
  __int16 v2; // ax

  sub_2C8E4((P_TypeA1)a1);
  *(_DWORD *)(a1 + 0xAB) = 0;
  *(_DWORD *)(a1 + 0xAF) = 0;
  *(_DWORD *)(a1 + 0xB3) = 0;
  *(_DWORD *)(a1 + 0xB7) = 0;
  *(_DWORD *)(a1 + 0xBB) = 0;
  *(_BYTE *)(a1 + 0xC4) = 0x31;
  *(_BYTE *)(a1 + 0xC5) = 0xF2;
  *(_BYTE *)(a1 + 0xC6) = 0;
  memset((void *)(a1 + 0xC7), 0, 0x800u);
  *(_WORD *)(a1 + 0x8C7) = 0;
  v2 = sub_2B594((int *)&V_Type3_stru_10AE70.z1[0x3046]);
  *(_WORD *)(a1 + 0x8CB) = 0;
  *(_WORD *)(a1 + 0x8CD) = 0;
  *(_WORD *)(a1 + 0x8CF) = 0xFFFF;
  *(_BYTE *)(a1 + 0x8E5) = 0;
  *(_DWORD *)(a1 + 0x8E6) = 0;
  *(_DWORD *)(a1 + 0x8EA) = 0;
  *(_DWORD *)(a1 + 0x8EE) = 0;
  *(_DWORD *)(a1 + 0x8F2) = 0;
  *(_WORD *)(a1 + 0x8C9) = v2 + 3;
  *(_DWORD *)(a1 + 0x8F6) = 0;
  sub_2F1C8(a1, (int)sub_2E208);
  *(_WORD *)(a1 + 0x18) = word_FFEE8;
  return sub_2E9CC(a1, 1);
}
// FFEE8: using guessed type __int16 word_FFEE8;

//----- (0002E3BC) --------------------------------------------------------
int __fastcall sub_2E3BC(T_TypeA1 *a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0002E3D4) --------------------------------------------------------
unsigned int __fastcall sub_2E3D4(int a1, __int16 a2, signed int a3, signed int a4)
{
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  __int16 v10; // ax
  int v11; // eax
  int v12; // edx
  unsigned __int16 v13; // dx
  int v14; // ebx

  if ( (unsigned __int16)a2 < 8u )
  {
    if ( (unsigned __int16)a2 < 4u )
    {
      if ( a2 == 1 )
      {
        sub_2E9CC(a1, *(_BYTE *)(a1 + 0xC3));
        return sub_2F424(a1, 1, a3, a4);
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 > 5u )
    {
      if ( (unsigned __int16)a2 <= 6u )
      {
        sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        *(_WORD *)(a1 + 0x8CF) = 0xFFFF;
        v7 = *(_DWORD *)(a1 + 0xA7);
        *(_BYTE *)(a1 + 0x8E5) = 0;
        (*(void (__fastcall **)(int, _DWORD))(v7 + 0xC))(a1, 0);
      }
      else
      {
        sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
        sub_2EDC8(a1, new_x, dword_D864C);
      }
      return 0xFFFFFFFF;
    }
LABEL_11:
    if ( a3 < *(_DWORD *)(a1 + 8)
      || a3 > *(_DWORD *)(a1 + 0x10)
      || a4 < *(_DWORD *)(a1 + 0xC)
      || a4 > *(_DWORD *)(a1 + 0x14) )
    {
      return 0;
    }
    if ( a2 == 0xC && *(_BYTE *)(a1 + 0x4F) != 0x30 )
    {
      return sub_2F424(a1, 0xC, a3, a4);
    }
    sub_2F090(a1, a3, a4, a2);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)a2 <= 8u )
  {
    sub_2EDC8(a1, a3, a4);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)a2 < 0x191u )
  {
    if ( a2 != 0xC )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    goto LABEL_11;
  }
  if ( (unsigned __int16)a2 <= 0x191u )
  {
    v8 = sub_56528((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2);
    if ( v8 != 0xFFFF )
    {
      v9 = 2 * v8 / 3 - 1;
      if ( v9 < 0 )
      {
        v9 = 0;
      }
      sub_56564((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2, v9);
    }
    v10 = *(_WORD *)(a1 + 0x8CD);
    if ( v10 )
    {
      *(_WORD *)(a1 + 0x8CD) = v10 - 1;
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  else
  {
    if ( (unsigned __int16)a2 > 0x192u )
    {
      if ( a2 == 0x193 )
      {
        sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x193);
        sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
        return 0xFFFFFFFF;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    v11 = sub_56528((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2);
    if ( v11 != 0xFFFF )
    {
      v12 = 2 * v11 / 3 - 1;
      if ( v12 < 0 )
      {
        v12 = 0;
      }
      sub_56564((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), a2, v12);
    }
    v13 = *(_WORD *)(a1 + 0x8CD);
    if ( v13 < *(unsigned __int16 *)(a1 + 0x8C7)
             - (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / *(unsigned __int16 *)(a1 + 0x8C9) )
    {
      v14 = *(_DWORD *)(a1 + 0xA7);
      *(_WORD *)(a1 + 0x8CD) = v13 + 1;
      (*(void (__fastcall **)(int, _DWORD))(v14 + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
}

//----- (0002E6C0) --------------------------------------------------------
void __fastcall sub_2E6C0(int a1)
{
  LONG v2; // edi
  __int16 v3; // di
  unsigned int v4; // ebp
  unsigned __int16 v5; // ax
  int v6; // ecx
  _DWORD *v7; // ebx
  int v8[2]; // [esp+0h] [ebp-30h] BYREF
  int v9; // [esp+8h] [ebp-28h]
  int v10; // [esp+Ch] [ebp-24h]
  int v11; // [esp+10h] [ebp-20h]
  LONG x1; // [esp+14h] [ebp-1Ch]
  int v13; // [esp+18h] [ebp-18h]

  VFX_pane_wipe((PANE *)(a1 + 4), *(unsigned __int8 *)(a1 + 0xC5));
  x1 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
  v2 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  VFX_line_draw((PANE *)(a1 + 4), 0, 0, x1, 0, 0, *(unsigned __int8 *)(a1 + 0xC4));
  VFX_line_draw((PANE *)(a1 + 4), 0, 0, 0, v2, 0, *(unsigned __int8 *)(a1 + 0xC4));
  VFX_line_draw((PANE *)(a1 + 4), x1, v2, x1, 0, 0, *(unsigned __int8 *)(a1 + 0xC4));
  VFX_line_draw((PANE *)(a1 + 4), x1, v2, 0, v2, 0, *(unsigned __int8 *)(a1 + 0xC4));
  if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
  {
    sub_2E868(a1, 0);
  }
  v8[1] = *(_DWORD *)(a1 + 8) + 1;
  v9 = *(_DWORD *)(a1 + 0xC) + 1;
  v8[0] = *(_DWORD *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 0x10) - 1;
  if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
  {
    v10 -= *(_DWORD *)(a1 + 0xBF);
  }
  v3 = *(_WORD *)(a1 + 0x8CD);
  v4 = 0;
  v13 = a1 + 0xC7;
  while ( v3 < (int)*(unsigned __int16 *)(a1 + 0x8C7) && !v4 )
  {
    v7 = (_DWORD *)(8 * v3 + v13);
    if ( *(_DWORD *)(a1 + 0x8F6) )
    {
      v5 = (*(int (__fastcall **)(_DWORD, _DWORD))(a1 + 0x8F6))(*v7, v7[1]);
    }
    else
    {
      v5 = *(_WORD *)(a1 + 0x8C9);
    }
    v11 = v9 + v5 - 1;
    v6 = *(_DWORD *)(a1 + 0x14);
    if ( v11 >= v6 )
    {
      v4 = 0xFFFFFFFF;
      v11 = v6 - 1;
    }
    (*(void (__fastcall **)(int *, _DWORD, _DWORD, int))(a1 + 0x8FA))(
      v8,
      *v7,
      v7[1],
      (v3++ != *(_WORD *)(a1 + 0x8CF)) - 1);
    v9 = v11 + 1;
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
}

//----- (0002E868) --------------------------------------------------------
void __fastcall sub_2E868(int a1, int a2)
{
  int v3; // edi
  int v4; // edx
  int v5; // ebx
  LONG v6; // edi
  int v7; // edx
  void *v8; // eax
  void *v9; // eax
  LONG v10; // [esp-Ch] [ebp-34h]
  LONG v11; // [esp-Ch] [ebp-34h]
  LONG v12; // [esp-8h] [ebp-30h]
  LONG v13; // [esp-4h] [ebp-2Ch]
  LONG v14; // [esp-4h] [ebp-2Ch]
  PANE v15; // [esp+0h] [ebp-28h] BYREF
  LONG hotX; // [esp+14h] [ebp-14h]
  PANE *pane; // [esp+18h] [ebp-10h]
  int v18; // [esp+1Ch] [ebp-Ch]
  LONG v19; // [esp+20h] [ebp-8h]
  LONG y1; // [esp+24h] [ebp-4h]

  v18 = a2;
  v3 = *(_DWORD *)(a1 + 0x10);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 0xBF);
  y1 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  v6 = v3 - v4 - v5;
  VFX_line_draw((PANE *)(a1 + 4), v6, 0, v6, y1, 0, *(unsigned __int8 *)(a1 + 0xC4));
  v7 = *(_DWORD *)(a1 + 0xC) + (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / 2;
  v15.window = *(WINDOW **)(a1 + 4);
  v15.x0 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 0xBF) + 1;
  v15.x1 = *(_DWORD *)(a1 + 0x10) - 1;
  v15.y0 = *(_DWORD *)(a1 + 0xC) + 1;
  v15.y1 = *(_DWORD *)(a1 + 0x14) - 1;
  v13 = *(unsigned __int8 *)(a1 + 0xC6);
  v19 = v7;
  VFX_pane_wipe(&v15, v13);
  if ( *(unsigned __int8 *)(a1 + 0x8E5) > 1u )
  {
    if ( *(_BYTE *)(a1 + 0x8E5) == 2 )
    {
      v15.y1 = v19;
    }
    else
    {
      v15.y0 = v19;
    }
    VFX_pane_wipe(&v15, 0x96);
  }
  hotX = v6 + 2;
  v10 = *(__int16 *)(a1 + 0x1E);
  v8 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  pane = (PANE *)(a1 + 4);
  VFX_shape_draw((PANE *)(a1 + 4), v8, v10, v6 + 2, 2);
  v14 = y1 - *(_DWORD *)(a1 + 0xBF) + 2;
  v12 = hotX;
  v11 = *(__int16 *)(a1 + 0x1E) + 1;
  v9 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  VFX_shape_draw(pane, v9, v11, v12, v14);
  if ( v18 == 0xFFFFFFFF )
  {
    sub_55274(
      &V_Type3_stru_10AE70,
      v6 + *(_DWORD *)(a1 + 8),
      *(_DWORD *)(a1 + 0xC),
      *(_DWORD *)(a1 + 0x10),
      *(_DWORD *)(a1 + 0x14));
  }
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002E9CC) --------------------------------------------------------
int __fastcall sub_2E9CC(int a1, char a2)
{
  LONG v3; // eax
  void *v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // ecx
  LONG v11; // [esp-4h] [ebp-10h]

  if ( a2 == 1 )
  {
    *(_WORD *)(a1 + 0x1E) = 0;
  }
  else
  {
    *(_WORD *)(a1 + 0x1E) = 2;
  }
  v3 = *(__int16 *)(a1 + 0x1E);
  *(_BYTE *)(a1 + 0xC3) = a2;
  v11 = v3;
  v4 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  v5 = VFX_shape_resolution(v4, v11);
  *(_DWORD *)(a1 + 0xBF) = v5;
  *(_DWORD *)(a1 + 0x8D1) = *(_DWORD *)(a1 + 4);
  v6 = HIWORD(v5);
  v7 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 0xBF) = v6;
  *(_DWORD *)(a1 + 0x8D5) = v7 + 1;
  v8 = *(_DWORD *)(a1 + 0x10);
  *(_DWORD *)(a1 + 0xBF) = v6 + 3;
  result = v8 - 1;
  v10 = *(_DWORD *)(a1 + 0xB3);
  *(_DWORD *)(a1 + 0x8DD) = result;
  if ( v10 == 0xFFFFFFFF )
  {
    result = *(_DWORD *)(a1 + 0xBF);
    *(_DWORD *)(a1 + 0x8DD) -= result;
  }
  return result;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002EA8C) --------------------------------------------------------
int __fastcall sub_2EA8C(int a1, const char *a2, __int16 a3, int a4)
{
  __int16 v6; // di
  int v7; // edx
  int v8; // eax
  int v9; // edi
  size_t v10; // kr04_4
  void *v11; // eax
  int v12; // ecx
  char *v13; // edi
  char v14; // al
  char v15; // al
  int v16; // eax
  const char *v19; // [esp+4h] [ebp-10h]

  v6 = a3;
  if ( *(unsigned __int16 *)(a1 + 0x8C7) >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x62A);
  }
  if ( a3 == 0xFFFFFFFF )
  {
    v6 = *(_WORD *)(a1 + 0x8C9);
  }
  *(_WORD *)(a1 + 0x8CB) += v6;
  v7 = *(unsigned __int16 *)(a1 + 0x8CB);
  if ( (unsigned __int16)v7 > *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) - 1 )
  {
    if ( *(_DWORD *)(a1 + 0xB7) == 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0x14) = *(_DWORD *)(a1 + 0xC) + v7 + 2;
    }
    else if ( !*(_DWORD *)(a1 + 0xB3) )
    {
      v8 = *(_DWORD *)(a1 + 0xBF);
      v9 = *(_DWORD *)(a1 + 0x8DD);
      *(_DWORD *)(a1 + 0xB3) = 0xFFFFFFFF;
      *(_DWORD *)(a1 + 0x8DD) = v9 - v8;
    }
  }
  if ( *(_DWORD *)(a1 + 0xAB) == 0xFFFFFFFF )
  {
    v10 = strlen(a2) + 1;
    if ( *(_DWORD *)(a1 + 0x8E6) )
    {
      v12 = *(_DWORD *)(a1 + 0x8EE);
      if ( *(_DWORD *)(a1 + 0x8F2) - v12 < v10 )
      {
        Q_AssertLogBreakExit_sub_261A8(0, "..\\gwindow.cpp", 0x653);
      }
      v19 = (const char *)(*(_DWORD *)(a1 + 0x8EA) + v12);
      *(_DWORD *)(a1 + 0x8EE) += v10;
    }
    else
    {
      v11 = operator new[](v10);
      sub_2625C(v11, 1, "LISTBOX STRING");
      v19 = (const char *)v11;
      if ( !v11 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x648);
      }
    }
    v13 = (char *)v19;
    do
    {
      v14 = *a2;
      *v13 = *a2;
      if ( !v14 )
      {
        break;
      }
      v15 = a2[1];
      a2 += 2;
      v13[1] = v15;
      v13 += 2;
    }
    while ( v15 );
    a2 = v19;
  }
  *(_DWORD *)(a1 + 8 * *(unsigned __int16 *)(a1 + 0x8C7) + 0xC7) = a2;
  *(_DWORD *)(a1 + 8 * *(unsigned __int16 *)(a1 + 0x8C7) + 0xCB) = 0;
  HIWORD(v16) = HIWORD(a4);
  ++*(_WORD *)(a1 + 0x8C7);
  if ( a4 == 0xFFFFFFFF )
  {
    v16 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
  }
  LOWORD(v16) = *(_WORD *)(a1 + 0x8C7);
  return v16 - 1;
}

//----- (0002EC50) --------------------------------------------------------
unsigned int __fastcall sub_2EC50(int a1, unsigned __int16 a2, int a3)
{
  int v3; // esi
  unsigned int result; // eax

  if ( a2 >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x66B);
  }
  v3 = 8 * a2 + a1;
  if ( !*(_DWORD *)(v3 + 0xC7) )
  {
    return 0;
  }
  result = 0xFFFFFFFF;
  *(_DWORD *)(v3 + 0xCB) = a3;
  return result;
}

//----- (0002ECA4) --------------------------------------------------------
int __fastcall sub_2ECA4(int a1, unsigned __int16 a2)
{
  if ( a2 >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x679);
  }
  return *(_DWORD *)(a1 + 8 * a2 + 0xCB);
}

//----- (0002ECDC) --------------------------------------------------------
int __fastcall sub_2ECDC(int result, unsigned __int16 a2)
{
  if ( *(unsigned __int16 *)(result + 0x8CB) > *(_DWORD *)(result + 0x14) - *(_DWORD *)(result + 0xC) - 1
    && a2 < *(_WORD *)(result + 0x8C7) )
  {
    *(_WORD *)(result + 0x8CF) = 0xFFFF;
    *(_WORD *)(result + 0x8CD) = a2;
  }
  return result;
}

//----- (0002ED14) --------------------------------------------------------
int __fastcall sub_2ED14(int a1, unsigned __int16 a2)
{
  if ( a2 >= 0x100u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x68D);
  }
  return *(_DWORD *)(a1 + 8 * a2 + 0xC7);
}

//----- (0002ED4C) --------------------------------------------------------
int __fastcall sub_2ED4C(int a1)
{
  int v1; // ecx
  int i; // edx
  int v3; // eax
  int result; // eax
  int v5; // edx

  v1 = a1;
  *(_DWORD *)(a1 + 0x8EE) = 0;
  for ( i = 0; i < *(unsigned __int16 *)(v1 + 0x8C7); ++i )
  {
    if ( *(_DWORD *)(a1 + 0xC7) )
    {
      *(_DWORD *)(a1 + 0xC7) = 0;
    }
    a1 += 8;
  }
  *(_WORD *)(v1 + 0x8C7) = 0;
  *(_WORD *)(v1 + 0x8CB) = 0;
  *(_WORD *)(v1 + 0x8CF) = 0xFFFF;
  v3 = *(_DWORD *)(v1 + 0x10);
  *(_WORD *)(v1 + 0x8CD) = 0;
  result = v3 - 1;
  v5 = *(_DWORD *)(v1 + 0xAF);
  *(_DWORD *)(v1 + 0x8DD) = result;
  if ( !v5 )
  {
    *(_DWORD *)(v1 + 0xB3) = 0;
  }
  return result;
}

//----- (0002EDC8) --------------------------------------------------------
void __fastcall sub_2EDC8(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5; // eax
  unsigned __int16 v6; // di
  unsigned __int16 v7; // dx
  unsigned int v8; // ebx
  unsigned __int16 v9; // cx
  int v10; // eax
  int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // eax
  char v14; // al
  int v15; // edx
  int v16; // eax
  LONG v17; // [esp-4h] [ebp-18h]

  if ( *(__int16 *)(a1 + 0x8CF) != 0xFFFFFFFF )
  {
    if ( a3 >= *(_DWORD *)(a1 + 0x8D9) && a3 <= *(_DWORD *)(a1 + 0x8E1) && a2 <= *(_DWORD *)(a1 + 0x8DD) )
    {
      if ( *(_DWORD *)(a1 + 0xBB) == 0xFFFFFFFF )
      {
        VFX_pane_wipe((PANE *)(a1 + 0x8D1), *(unsigned __int8 *)(a1 + 0xC5));
        (*(void (__fastcall **)(int, _DWORD, _DWORD, unsigned int))(a1 + 0x8FA))(
          a1 + 0x8D1,
          *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xC7),
          *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xCB),
          0xFFFFFFFF);
        sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 0x8D1));
      }
      return;
    }
    VFX_pane_wipe((PANE *)(a1 + 0x8D1), *(unsigned __int8 *)(a1 + 0xC5));
    (*(void (__fastcall **)(int, _DWORD, _DWORD, _DWORD))(a1 + 0x8FA))(
      a1 + 0x8D1,
      *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xC7),
      *(_DWORD *)(a1 + 8 * *(__int16 *)(a1 + 0x8CF) + 0xCB),
      0);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 0x8D1));
    *(_WORD *)(a1 + 0x8CF) = 0xFFFF;
  }
  v5 = *(_DWORD *)(a1 + 0x10);
  if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
  {
    v5 -= *(_DWORD *)(a1 + 0xBF);
  }
  if ( v5 <= a2 )
  {
    if ( *(_DWORD *)(a1 + 0xB3) != 0xFFFFFFFF )
    {
      return;
    }
    v12 = *(_DWORD *)(a1 + 0xC) + (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / 2;
    v13 = *(unsigned __int8 *)(a1 + 0x8E5);
    if ( v13 > 1 )
    {
      if ( a3 <= v12 )
      {
        if ( v13 == 2 )
        {
          return;
        }
        v15 = *(_DWORD *)(a1 + 0xB3);
        v16 = a1;
        *(_BYTE *)(a1 + 0x8E5) = 2;
      }
      else
      {
        if ( v13 == 3 )
        {
          return;
        }
        v15 = *(_DWORD *)(a1 + 0xB3);
        v16 = a1;
        *(_BYTE *)(a1 + 0x8E5) = 3;
      }
    }
    else
    {
      v14 = (a3 > v12) + 2;
      v15 = *(_DWORD *)(a1 + 0xB3);
      *(_BYTE *)(a1 + 0x8E5) = v14;
      v16 = a1;
    }
    sub_2E868(v16, v15);
  }
  else
  {
    if ( *(unsigned __int8 *)(a1 + 0x8E5) > 1u )
    {
      *(_BYTE *)(a1 + 0x8E5) = 1;
      sub_2E868(a1, 0xFFFFFFFF);
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x193);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
    }
    v6 = *(_WORD *)(a1 + 0x8CD);
    v7 = *(_WORD *)(a1 + 0x8C7);
    v8 = 0;
    *(_DWORD *)(a1 + 0x8D9) = *(_DWORD *)(a1 + 0xC) + 1;
    if ( v6 < v7 )
    {
      while ( !v8 )
      {
        v8 = 0;
        v10 = *(_DWORD *)(a1 + 0x8F6);
        if ( v10 )
        {
          v10 = (*(unsigned __int16 (__fastcall **)(_DWORD, _DWORD, _DWORD))(a1 + 0x8F6))(
                  *(_DWORD *)(a1 + 8 * v6 + 0xC7),
                  *(_DWORD *)(a1 + 8 * v6 + 0xCB),
                  0);
        }
        else
        {
          LOWORD(v10) = *(_WORD *)(a1 + 0x8C9);
        }
        *(_DWORD *)(a1 + 0x8E1) = *(_DWORD *)(a1 + 0x8D9) + v10 - 1;
        v11 = *(_DWORD *)(a1 + 0x14);
        if ( *(_DWORD *)(a1 + 0x8E1) >= v11 )
        {
          v8 = 0xFFFFFFFF;
          *(_DWORD *)(a1 + 0x8E1) = v11 - 1;
        }
        if ( a3 >= *(_DWORD *)(a1 + 0x8D9) && a3 <= *(_DWORD *)(a1 + 0x8E1) )
        {
          v17 = *(unsigned __int8 *)(a1 + 0xC5);
          *(_WORD *)(a1 + 0x8CF) = v6;
          VFX_pane_wipe((PANE *)(a1 + 0x8D1), v17);
          (*(void (__fastcall **)(int, _DWORD, _DWORD, unsigned int))(a1 + 0x8FA))(
            a1 + 0x8D1,
            *(_DWORD *)(a1 + 8 * v6 + 0xC7),
            *(_DWORD *)(a1 + 8 * v6 + 0xCB),
            0xFFFFFFFF);
          sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 0x8D1));
          return;
        }
        ++v6;
        v9 = *(_WORD *)(a1 + 0x8C7);
        *(_DWORD *)(a1 + 0x8D9) = *(_DWORD *)(a1 + 0x8E1) + 1;
        if ( v6 >= v9 )
        {
          return;
        }
      }
    }
  }
}

//----- (0002F090) --------------------------------------------------------
void __fastcall sub_2F090(int a1, unsigned int a2, unsigned int a3, __int16 a4)
{
  int v6; // ecx
  int v7; // edx
  int v8; // ebx

  if ( *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 0xBF) <= a2 )
  {
    if ( *(_DWORD *)(a1 + 0xB3) == 0xFFFFFFFF )
    {
      if ( *(_DWORD *)(a1 + 0xC) + (*(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC)) / 2 <= a3 )
      {
        (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 8))(a1, 0x192, 0, 0);
        sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x192, 0, 0, 0x1E);
      }
      else
      {
        (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 8))(a1, 0x191, 0, 0);
        sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x191, 0, 0, 0x1E);
      }
      v8 = 1;
      if ( a4 == 5 )
      {
        v8 = 2;
      }
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), v8, 0x193, 0, 0);
    }
  }
  else
  {
    v6 = *(__int16 *)(a1 + 0x8CF);
    if ( v6 != 0xFFFFFFFF )
    {
      if ( dword_12FC14 )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x63), 0x1C02, v6, a4);
      }
      else
      {
        v7 = *(__int16 *)(a1 + 0x59);
        if ( v7 != 0xFFFFFFFF )
        {
          sub_4FB90((int)&unk_10914C, v7);
        }
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x63), 0x1C01, *(__int16 *)(a1 + 0x8CF), a4);
      }
      sub_2EDC8(a1, a2, a3);
    }
  }
}
// 12FC14: using guessed type int dword_12FC14;

//----- (0002F1C8) --------------------------------------------------------
int __fastcall sub_2F1C8(int result, int a2)
{
  *(_DWORD *)(result + 0x8FA) = a2;
  return result;
}

//----- (0002F1D8) --------------------------------------------------------
int __fastcall sub_2F1D8(int result, int a2)
{
  *(_DWORD *)(result + 0x8FE) = a2;
  return result;
}

//----- (0002F1E0) --------------------------------------------------------
void __fastcall sub_2F1E0(int a1)
{
  if ( !*(_DWORD *)(a1 + 0x8FE) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x7AB);
  }
  qsort(
    (void *)(a1 + 0xC7),
    *(unsigned __int16 *)(a1 + 0x8C7),
    8u,
    *(int (__fastcall **)(const void *, const void *))(a1 + 0x8FE));
}

//----- (0002F228) --------------------------------------------------------
int __fastcall sub_2F228(int a1, size_t a2, int a3)
{
  int result; // eax

  sub_2ED4C(a1);
  if ( *(_DWORD *)(a1 + 0x8EA) )
  {
    sub_262CC(*(void **)(a1 + 0x8EA));
    *(_DWORD *)(a1 + 0x8EA) = 0;
  }
  if ( a3 )
  {
    *(_DWORD *)(a1 + 0x8EA) = a3;
  }
  else
  {
    *(_DWORD *)(a1 + 0x8EA) = sub_2628C(a2, 1, "LISTBOX MEMPOOL");
  }
  if ( *(_DWORD *)(a1 + 0x8EA) )
  {
    *(_DWORD *)(a1 + 0x8E6) = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x8EE) = 0;
    result = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x8F2) = a2;
  }
  else
  {
    *(_DWORD *)(a1 + 0x8E6) = 0;
    *(_DWORD *)(a1 + 0x8F2) = 0;
    result = 0;
    *(_DWORD *)(a1 + 0x8EE) = 0;
  }
  return result;
}

//----- (0002F2B4) --------------------------------------------------------
void __fastcall sub_2F2B4(int a1)
{
  if ( *(_DWORD *)(a1 + 0x8EA) )
  {
    sub_262CC(*(void **)(a1 + 0x8EA));
    *(_DWORD *)(a1 + 0x8EA) = 0;
  }
  *(_DWORD *)(a1 + 0x8F2) = 0;
  *(_DWORD *)(a1 + 0x8EE) = 0;
  *(_DWORD *)(a1 + 0x8E6) = 0;
}

//----- (0002F2F4) --------------------------------------------------------
T_TypeA2 *__fastcall sub_2F2F4(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_95DC0;
  return result;
}
// 95DC0: using guessed type int (*off_95DC0[5])();

//----- (0002F30C) --------------------------------------------------------
void *__fastcall sub_2F30C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D2C);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95DC0;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DC0: using guessed type int (*off_95DC0[5])();

//----- (0002F354) --------------------------------------------------------
void __fastcall sub_2F354(int a1)
{
  void *v2; // eax
  __int16 v3; // si
  int v4; // ecx
  int v5; // ebx
  int v6; // eax
  LONG v7; // [esp-Ch] [ebp-20h]
  __int16 v8; // [esp-4h] [ebp-18h]
  char s[12]; // [esp+0h] [ebp-14h] BYREF
  int v10; // [esp+Ch] [ebp-8h]
  int a2; // [esp+10h] [ebp-4h]
  void *retaddr; // [esp+28h] [ebp+14h]

  v7 = *(_DWORD *)(a1 + 0xAB) + 0xC;
  v2 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  v10 = a1 + 4;
  VFX_shape_draw((PANE *)(a1 + 4), v2, v7, 0, 0);
  v3 = 0;
  sprintf(s, "%05d", dword_A2F6C[0]);
  a2 = v10;
  while ( v3 < 5 )
  {
    v4 = 0x1F * v3 + 2;
    v8 = (unsigned __int8)byte_104BEA;
    v5 = *(_DWORD *)(a1 + 0xAB) + *((char *)&retaddr + v3) - 0x30;
    v6 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    ++v3;
    sub_53EB8((P_Type5)a2, v6, v5, v4, 0, v8);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)a2);
}
// A2F6C: using guessed type int dword_A2F6C[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 2F354: using guessed type char s[12];

//----- (0002F414) --------------------------------------------------------
int __fastcall sub_2F414(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
}

//----- (0002F420) --------------------------------------------------------
unsigned int __fastcall sub_2F420(int a1, __int16 a2, int a3, int a4)
{
  return sub_2F424(a1, a2, a3, a4);
}

//----- (0002F424) --------------------------------------------------------
unsigned int __fastcall sub_2F424(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ebp
  __int16 v5; // cx
  int v6; // ebx
  int v7; // edx
  int v10; // [esp+2h] [ebp-10h]

  if ( (unsigned __int16)a2 < 7u )
  {
    if ( (unsigned __int16)a2 < 2u )
    {
      if ( a2 == 1 )
      {
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        v4 = *(_DWORD *)(a1 + 0xA7);
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        (*(void (**)(void))(v4 + 0xC))();
        sub_2D258(a1, 1);
        return 0;
      }
      return 0;
    }
    if ( (unsigned __int16)a2 <= 2u )
    {
      sub_2D258(a1, a2);
      *(_DWORD *)(a1 + 0x39) = 0;
      *(_DWORD *)(a1 + 0x35) = 0;
      if ( *(_DWORD *)(a1 + 0x41) == *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] )
      {
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] = 0xFFFFFFFF;
      }
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      return 0;
    }
    else
    {
      if ( (unsigned __int16)a2 < 4u )
      {
        return 0;
      }
      if ( (unsigned __int16)a2 <= 5u )
      {
        if ( a3 < *(_DWORD *)(a1 + 8)
          || a3 > *(_DWORD *)(a1 + 0x10)
          || a4 < *(_DWORD *)(a1 + 0xC)
          || a4 > *(_DWORD *)(a1 + 0x14) )
        {
          return 0;
        }
        v5 = *(_WORD *)(a1 + 0x45);
        v10 = *(_DWORD *)(a1 + 0x47);
        v6 = *(_DWORD *)(a1 + 0x4B);
        if ( v5 == 0x3E7 )
        {
          v5 = a2;
        }
        if ( v10 == 0x3E7 )
        {
          v10 = a2;
        }
        if ( v6 == 0x3E7 )
        {
          v6 = a2;
        }
        v7 = *(__int16 *)(a1 + 0x59);
        if ( v7 != 0xFFFFFFFF )
        {
          sub_4FB90((int)&unk_10914C, v7);
        }
        if ( *(_DWORD *)(a1 + 0x63) )
        {
          if ( v5 == 0x3E6 )
          {
            sub_56B60((int)&V_Type3_stru_10AE70, v10, v6, 0);
            return 0xFFFFFFFF;
          }
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x63), v5, v10, v6);
        }
        else
        {
          sub_56B60((int)&V_Type3_stru_10AE70, v5, v10, v6);
        }
        return 0xFFFFFFFF;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 0x39) && *(_DWORD *)(a1 + 0x35) && *(_DWORD *)(a1 + 0x3D) )
        {
          (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
        }
        return 0xFFFFFFFF;
      }
    }
  }
  else if ( (unsigned __int16)a2 <= 7u )
  {
    if ( *(_DWORD *)(a1 + 0x39) && *(_DWORD *)(a1 + 0x35) && *(_DWORD *)(a1 + 0x3D) )
    {
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
    }
    return 0xFFFFFFFF;
  }
  else
  {
    if ( (unsigned __int16)a2 >= 0xEu )
    {
      if ( (unsigned __int16)a2 <= 0xEu )
      {
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        return 0;
      }
      if ( (unsigned __int16)a2 <= 0xFu )
      {
        *(_DWORD *)(a1 + 0x35) = 0;
        return 0;
      }
      if ( (unsigned __int16)a2 >= 0xC9u )
      {
        if ( (unsigned __int16)a2 > 0xCAu )
        {
          return 0;
        }
        sub_56B60((int)&V_Type3_stru_10AE70, 6, a2, 0);
        return 0xFFFFFFFF;
      }
      return 0;
    }
    if ( a2 != 0xC )
    {
      return 0;
    }
    if ( a3 < *(_DWORD *)(a1 + 8)
      || a3 > *(_DWORD *)(a1 + 0x10)
      || a4 < *(_DWORD *)(a1 + 0xC)
      || a4 > *(_DWORD *)(a1 + 0x14) )
    {
      return 0;
    }
    if ( *(_BYTE *)(a1 + 0x4F) != 0x30 )
    {
      sub_56B60((int)&V_Type3_stru_10AE70, 5, a1 + 0x4F, 0);
    }
    return 0xFFFFFFFF;
  }
}

//----- (0002F478) --------------------------------------------------------
unsigned int __fastcall sub_2F478(int a1, __int16 a2, int a3, int a4)
{
  if ( a2 != 0xD )
  {
    return sub_2F420(a1, a2, a3, a4);
  }
  (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
  return 0;
}

//----- (0002F48C) --------------------------------------------------------
T_TypeA2 *__fastcall sub_2F48C(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95DA8;
  sub_2F4EC((int)a1);
  return a1;
}
// 95DA8: using guessed type int (*off_95DA8[4])();

//----- (0002F4A8) --------------------------------------------------------
void *__fastcall sub_2F4A8(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D18);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95DA8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95DA8: using guessed type int (*off_95DA8[4])();

//----- (0002F4EC) --------------------------------------------------------
int __fastcall sub_2F4EC(int result)
{
  *(_DWORD *)(result + 0xAB) = 0;
  *(_WORD *)(result + 0xB1) = 0;
  *(_WORD *)(result + 0xAF) = 0;
  *(_WORD *)(result + 0xB3) = 0;
  *(_WORD *)(result + 0xB7) = 0xF2;
  *(_DWORD *)(result + 0xB9) = &V_Type3_stru_10AE70.z1[0x3046];
  *(_DWORD *)(result + 0xBD) = 0xFFFFFFFF;
  *(_WORD *)(result + 0xB5) = (unsigned __int8)byte_96778;
  return result;
}
// 96778: using guessed type char byte_96778;

//----- (0002F540) --------------------------------------------------------
void __fastcall sub_2F540(int a1)
{
  _DWORD *v2; // eax
  const char *v3; // ecx
  int v4; // edx
  int v5; // eax
  int v6; // eax
  LONG v7; // [esp-18h] [ebp-30h]
  LONG v8; // [esp-14h] [ebp-2Ch]
  __int16 v9; // [esp-Ch] [ebp-24h]
  PANE *a2; // [esp+0h] [ebp-18h]

  a2 = (PANE *)(a1 + 4);
  VFX_pane_wipe((PANE *)(a1 + 4), *(__int16 *)(a1 + 0xB7));
  VFX_line_draw(a2, 0, 0, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), 0, 0, 0xF3);
  VFX_line_draw(a2, 0, 0, 0, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), 0, 0xF3);
  v8 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
  VFX_line_draw(a2, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), v8, 0, v8, 0, 0xF3);
  v7 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
  VFX_line_draw(a2, v7, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), v7, 0, 0, 0xF3);
  v2 = *(_DWORD **)(a1 + 0xB9);
  v9 = *(_WORD *)(a1 + 0xB5);
  v3 = *(const char **)(a1 + 0xAB);
  v2[2] = a2->window;
  v2[3] = a2->x0;
  v2[4] = a2->y0;
  v2[5] = a2->x1;
  v2[6] = a2->y1;
  sub_2B8A8((int)v2, 2, 4, v3, 0, v9, 0xFF, 0);
  v4 = *(__int16 *)(a1 + 0xB3);
  v5 = *(_DWORD *)(a1 + 0xAB);
  LOBYTE(v3) = *(_BYTE *)(v4 + v5);
  *(_BYTE *)(v4 + v5) = 0;
  v6 = sub_2B4F4(*(_DWORD **)(a1 + 0xB9), *(char **)(a1 + 0xAB));
  *(_BYTE *)(*(__int16 *)(a1 + 0xB3) + *(_DWORD *)(a1 + 0xAB)) = (_BYTE)v3;
  VFX_line_draw(a2, v6 + 2, 3, v6 + 2, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC) - 3, 0, 0x98);
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)a2);
}

//----- (0002F6B0) --------------------------------------------------------
unsigned int __fastcall sub_2F6B0(int a1, __int16 a2, char a3, unsigned int a4)
{
  int v6; // ecx
  int v8; // ebx
  __int16 v9; // ax
  int v10; // ebx

  if ( a2 != 3 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  v6 = *(_DWORD *)(a1 + 0xBD);
  *(_DWORD *)(a1 + 0xBD) = 0;
  if ( a3 >= 0x30 && a3 <= 0x39 || a3 >= 0x41 && a3 <= 0x5A || a3 >= 0x61 && a3 <= 0x7A || a3 == 0x20 || a3 == 0x2D )
  {
    if ( v6 )
    {
      *(_WORD *)(a1 + 0xB3) = 0;
      *(_WORD *)(a1 + 0xB1) = *(_WORD *)(a1 + 0xB3);
      **(_BYTE **)(a1 + 0xAB) = 0;
    }
    if ( *(_WORD *)(a1 + 0xB1) < *(_WORD *)(a1 + 0xAF)
      && sub_2B4F4(&V_Type3_stru_10AE70.z1[0x3046], *(char **)(a1 + 0xAB)) < 0x5F )
    {
      sub_2F8F8(a1, *(_WORD *)(a1 + 0xB3), a3, a2);
      ++*(_WORD *)(a1 + 0xB3);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  if ( a4 < 0x4B )
  {
    if ( a4 >= 0xE )
    {
      if ( a4 > 0xE )
      {
        if ( a4 == 0x1C )
        {
          sub_56B60((int)&V_Type3_stru_10AE70, 6, 3, 0);
          return 0xFFFFFFFF;
        }
        return sub_2F424(a1, a2, a3, a4);
      }
      if ( *(__int16 *)(a1 + 0xB3) > 0 )
      {
        sub_2F8A4(a1, (__int16)--*(_WORD *)(a1 + 0xB3));
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( a4 <= 0x4B )
  {
    if ( *(__int16 *)(a1 + 0xB3) > 0 )
    {
      v8 = *(_DWORD *)(a1 + 0xA7);
      --*(_WORD *)(a1 + 0xB3);
      (*(void (__fastcall **)(int, _DWORD))(v8 + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  if ( a4 < 0x4D )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( a4 <= 0x4D )
  {
    v9 = *(_WORD *)(a1 + 0xB3);
    if ( v9 < *(__int16 *)(a1 + 0xB1) )
    {
      v10 = *(_DWORD *)(a1 + 0xA7);
      *(_WORD *)(a1 + 0xB3) = v9 + 1;
      (*(void (__fastcall **)(int, _DWORD))(v10 + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  else
  {
    if ( a4 != 0x53 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( *(_WORD *)(a1 + 0xB3) < *(_WORD *)(a1 + 0xB1) )
    {
      sub_2F8A4(a1, *(__int16 *)(a1 + 0xB3));
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
}

//----- (0002F8A4) --------------------------------------------------------
int __fastcall sub_2F8A4(int a1, int a2)
{
  __int16 v3; // bx
  int result; // eax

  if ( (__int16)a2 >= *(__int16 *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x8F2);
  }
  v3 = *(_WORD *)(a1 + 0xB1);
  result = a2;
  if ( (__int16)a2 < v3 )
  {
    do
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + (__int16)result) = *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + (__int16)result + 1);
      ++result;
    }
    while ( (__int16)result < *(__int16 *)(a1 + 0xB1) );
  }
  --*(_WORD *)(a1 + 0xB1);
  return result;
}

//----- (0002F8F8) --------------------------------------------------------
char __usercall sub_2F8F8@<al>(int a1@<eax>, __int16 a2@<dx>, char a3@<bl>, int a4@<edi>)
{
  int i; // eax
  _BYTE *v7; // edx
  char result; // al

  if ( a2 > *(__int16 *)(a1 + 0xB1) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x903);
  }
  if ( *(_WORD *)(a1 + 0xB1) >= *(_WORD *)(a1 + 0xAF) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x904);
  }
  LOWORD(a4) = *(_WORD *)(a1 + 0xB1);
  if ( a2 == (_WORD)a4 )
  {
    *(_BYTE *)((__int16)a4 + *(_DWORD *)(a1 + 0xAB)) = a3;
    *(_BYTE *)((__int16)a4 + *(_DWORD *)(a1 + 0xAB) + 1) = 0;
  }
  else
  {
    for ( i = a4; (__int16)i >= a2; v7[1] = *v7 )
    {
      v7 = (_BYTE *)((__int16)i-- + *(_DWORD *)(a1 + 0xAB));
    }
  }
  result = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + a2) = a3;
  ++*(_WORD *)(a1 + 0xB1);
  return result;
}

//----- (0002F9A4) --------------------------------------------------------
int __fastcall sub_2F9A4(int a1, const char *a2, __int16 a3)
{
  int result; // eax
  unsigned int v5; // kr04_4

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x91B);
  }
  *(_DWORD *)(a1 + 0xAB) = a2;
  *(_WORD *)(a1 + 0xAF) = a3;
  result = 0;
  v5 = strlen(a2) + 1;
  *(_WORD *)(a1 + 0xB1) = v5 - 1;
  if ( (__int16)(v5 - 1) > a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x921);
  }
  *(_WORD *)(a1 + 0xB3) = *(_WORD *)(a1 + 0xB1);
  return result;
}

//----- (0002FA18) --------------------------------------------------------
void __fastcall __spoils<> sub_2FA18(P_TypeA3 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95D90;
  sub_2FA78(a1);
}
// 95D90: using guessed type int (*off_95D90[5])();

//----- (0002FA34) --------------------------------------------------------
void *__fastcall sub_2FA34(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95D04);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95D90;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95D90: using guessed type int (*off_95D90[5])();

//----- (0002FA78) --------------------------------------------------------
void __fastcall __spoils<> sub_2FA78(P_TypeA3 result)
{
  result->c = 0;
  result->d = 3;
  result->e = 0xF3;
}

//----- (0002FA98) --------------------------------------------------------
void __fastcall sub_2FA98(int a1)
{
  PANE *v2; // esi
  const char *v3; // ecx
  LONG v4; // [esp-18h] [ebp-2Ch]
  LONG v5; // [esp-14h] [ebp-28h]
  __int16 v6; // [esp-10h] [ebp-24h]
  __int16 v7; // [esp-Ch] [ebp-20h]
  int v8; // [esp-4h] [ebp-18h]

  v2 = (PANE *)(a1 + 4);
  VFX_pane_wipe((PANE *)(a1 + 4), 0xF2);
  if ( *(_DWORD *)(a1 + 0x5F) == 0xFFFFFFFF )
  {
    VFX_line_draw(v2, 0, 0, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), 0, 0, 0xF3);
    VFX_line_draw(v2, 0, 0, 0, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), 0, 0xF3);
    v5 = *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC);
    VFX_line_draw(v2, *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8), v5, 0, v5, 0, 0xF3);
    v4 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8);
    VFX_line_draw(v2, v4, *(_DWORD *)(a1 + 0x14) - *(_DWORD *)(a1 + 0xC), v4, 0, 0, 0xF3);
  }
  if ( *(_DWORD *)(a1 + 0xAB) )
  {
    v3 = *(const char **)(a1 + 0xAB);
    v8 = *(_DWORD *)(a1 + 0x10) - *(_DWORD *)(a1 + 8) - 5;
    v7 = *(_WORD *)(a1 + 0xB1);
    v6 = *(_WORD *)(a1 + 0xAF);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, v3, v6, v7, 0xFF, v8);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
}

//----- (0002FBA4) --------------------------------------------------------
void __fastcall sub_2FBA4(int a1, int a2)
{
  int v3; // ecx
  LONG v4; // eax
  int v5; // ebx
  int v6; // eax
  __int16 v7; // [esp-4h] [ebp-14h]

  v3 = *(_DWORD *)(a1 + 0x41);
  v4 = 0xF2;
  if ( *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == v3 && a2 != 2 || a2 == 3 )
  {
    v4 = 0x96;
  }
  VFX_pane_wipe((PANE *)(a1 + 4), v4);
  if ( *(__int16 *)(a1 + 0x1E) == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\gwindow.cpp", 0x9A0);
  }
  v5 = *(__int16 *)(a1 + 0x1E);
  if ( v5 != 0xFFFFFFFF )
  {
    v7 = (unsigned __int8)byte_104BEA;
    v6 = sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
    sub_53EB8((P_Type5)(a1 + 4), v6, v5, 0, 0, v7);
  }
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0002FC3C) --------------------------------------------------------
int __fastcall sub_2FC3C(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
}

//----- (0002FC50) --------------------------------------------------------
void __fastcall __spoils<> sub_2FC50(P_TypeA2 a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95E54;
}
// 95E54: using guessed type int (*off_95E54[5])();

//----- (0002FC68) --------------------------------------------------------
void *__fastcall sub_2FC68(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95E40);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95E54;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E54: using guessed type int (*off_95E54[5])();

//----- (0002FCB0) --------------------------------------------------------
int __fastcall sub_2FCB0(_DWORD *a1, char *a2, char *a3)
{
  char *v4; // edi
  char v6; // al
  char v7; // al
  char *v8; // edi
  char v10; // al
  char v11; // al
  int result; // eax
  int v13; // ebx

  *(_DWORD *)((char *)a1 + 0xDAB) = 0;
  v4 = (char *)a1 + 0xAB;
  *(_DWORD *)((char *)a1 + 0xDA7) = *(_DWORD *)((char *)a1 + 0xDAB);
  do
  {
    v6 = *a2;
    *v4 = *a2;
    if ( !v6 )
    {
      break;
    }
    v7 = a2[1];
    a2 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  v8 = (char *)a1 + 0xC9;
  do
  {
    v10 = *a3;
    *v8 = *a3;
    if ( !v10 )
    {
      break;
    }
    v11 = a3[1];
    a3 += 2;
    v8[1] = v11;
    v8 += 2;
  }
  while ( v11 );
  ((void (__fastcall *)(_DWORD *))sub_2FEB8)(a1);
  result = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
  v13 = 0x98;
  if ( !*(_WORD *)&V_Type3_stru_10AE70.z1[0x4228]
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 1
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 7
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 8
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 0x10
    || *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 0x14 )
  {
    v13 = 0x50;
  }
  a1[2] = v13;
  a1[3] = 0x78;
  a1[4] = v13 + 0x14F;
  a1[5] = 0x177;
  return result;
}
// 2FEB8: using guessed type int sub_2FEB8();

//----- (0002FD68) --------------------------------------------------------
unsigned int __fastcall sub_2FD68(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ebx
  int v6; // edx
  int v7; // ebx

  if ( (unsigned __int16)a2 < 6u )
  {
    if ( (unsigned __int16)a2 < 2u )
    {
      if ( a2 == 1 )
      {
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        v4 = *(_DWORD *)(a1 + 0xA7);
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        (*(void (**)(void))(v4 + 0xC))();
        return 0;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 > 2u && a2 == 5 )
    {
      goto LABEL_9;
    }
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 7u )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 < 0xDu )
  {
    if ( a2 != 0xC )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
LABEL_9:
    sub_56B60((int)&V_Type3_stru_10AE70, 6, 0xCA, 0);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)a2 <= 0xDu || (unsigned __int16)a2 < 0x32u || (unsigned __int16)a2 > 0x32u )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  v6 = *(_DWORD *)(a1 + 0xDA7);
  if ( v6 >= *(_DWORD *)(a1 + 0xDAB) )
  {
    sub_56B60((int)&V_Type3_stru_10AE70, 6, a3, a4);
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 0xA7);
    *(_DWORD *)(a1 + 0xDA7) = v6 + 1;
    (*(void (**)(void))(v7 + 0xC))();
  }
  return 0;
}

//----- (0002FE58) --------------------------------------------------------
void __fastcall Q_HELPWIN_CPP_FgetsLine_sub_2FE58(FILE *fp, char *line)
{
  unsigned int found; // edi
  char first; // ah

  found = 0;
  do
  {
    if ( !fgets(line, 200, fp) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\helpwin.cpp", 0x9E);
    }
    first = *line;
    if ( *line != ' ' && first != '\t' && first != '\n' && first != '\r' && first != '/' && first != '#' )
    {
      found = 0xFFFFFFFF;
    }
  }
  while ( !found );
}

//----- (0003067B) --------------------------------------------------------
void __usercall sub_3067B(const char *a1@<edx>, int a2@<ebp>)
{
  if ( !stricmp((const char *)(a2 - 0x32), a1) )
  {
    sscanf(
      (const char *)(a2 - 0x13A),
      "%s %s %s %s %s %s",
      a2 - 0x32,
      a2 + 0xA,
      a2 + 0x14,
      a2 + 0x1E,
      a2 + 0x28,
      a2 + 0x32);
    JUMPOUT(0x30714);
  }
  JUMPOUT(0x30731);
}
// 306C5: control flows out of bounds to 30714
// 30685: control flows out of bounds to 30731

//----- (000306F0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_306F0(int a1@<ecx>, const char *a2@<ebx>, int a3@<ebp>, int a4@<esi>)
{
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  _DWORD *v10; // edx
  _DWORD *v11; // ebx
  int v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // eax
  _BYTE *v16; // edx
  int v17; // eax
  int v18; // edx
  signed int v19; // edi
  char *v20; // esi
  char *v21; // edi
  char v22; // al
  char v23; // al
  _BYTE *v24; // ecx
  int v25; // esi
  char v26; // bl

LABEL_1:
  *(_BYTE *)(*(_DWORD *)(a3 + 0x42) + 0xF) |= 0x20u;
  while ( 1 )
  {
    ++a1;
    a2 += 0xA;
    if ( a1 >= a4 )
    {
      break;
    }
    if ( !stricmp(a2, "TJ_HC") )
    {
      *(_BYTE *)(*(_DWORD *)(a3 + 0x42) + 0xF) |= 2u;
    }
    else
    {
      if ( stricmp(a2, "TJ_VC") )
      {
        if ( stricmp(a2, "TJ_R") )
        {
          JUMPOUT(0x30700);
        }
        goto LABEL_1;
      }
      *(_BYTE *)(*(_DWORD *)(a3 + 0x42) + 0xF) |= 1u;
    }
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    while ( 1 )
                    {
                      while ( 1 )
                      {
                        if ( *(_DWORD *)(a3 + 0x6E) == 2 )
                        {
                          fclose(*(FILE **)(a3 + 0x3E));
                          return;
                        }
                        Q_HELPWIN_CPP_FgetsLine_sub_2FE58(*(FILE **)(a3 + 0x3E), (char *)(a3 - 0x13A));
                        sscanf((const char *)(a3 - 0x13A), "%s", a3 - 0x32);
                        if ( stricmp((const char *)(a3 - 0x32), "HELP") )
                        {
                          break;
                        }
                        *(_DWORD *)(a3 + 0x6E) = 2;
                      }
                      if ( stricmp((const char *)(a3 - 0x32), "POS") )
                      {
                        break;
                      }
                      v4 = *(_DWORD *)(a3 + 0x42);
                      sscanf((const char *)(a3 - 0x13A), "%s %d %d", a3 - 0x32, a3 + 0x46, a3 + 0x4A);
                      *(_WORD *)(v4 + 0x13) = *(_DWORD *)(a3 + 0x46);
                      *(_WORD *)(v4 + 0x15) = *(_DWORD *)(a3 + 0x4A);
                    }
                    if ( stricmp((const char *)(a3 - 0x32), "SHAPE") )
                    {
                      break;
                    }
                    v5 = *(_DWORD *)(a3 + 0x76);
                    v6 = *(_DWORD *)(v5 + 0xDA3) + 1;
                    *(_DWORD *)(v5 + 0xDA3) = v6;
                    if ( v6 >= 0xA )
                    {
                      Q_AssertLogBreakExit_sub_26198(0, "..\\helpwin.cpp", 0x124);
                    }
                    if ( *(_DWORD *)(a3 + 0x6A) == 0xFFFFFFFF )
                    {
                      *(_DWORD *)(a3 + 0x6A) = 0;
                    }
                    else
                    {
                      *(_DWORD *)(a3 + 0x42) += 0x1B;
                    }
                    v7 = *(_DWORD *)(a3 + 0x42);
                    *(_BYTE *)v7 = 0;
                    *(_WORD *)(v7 + 1) = 0;
                    *(_WORD *)(v7 + 3) = 0;
                    *(_WORD *)(v7 + 0x13) = 0;
                    *(_WORD *)(v7 + 0x15) = 0;
                    if ( sscanf(
                           (const char *)(a3 - 0x13A),
                           "%s %d %d %d %d",
                           a3 - 0x32,
                           a3 + 0x46,
                           a3 + 0x4A,
                           a3 + 0x4E,
                           a3 + 0x52) == 5 )
                    {
                      v8 = *(_DWORD *)(a3 + 0x42);
                      *(_WORD *)(v8 + 1) = *(_DWORD *)(a3 + 0x46);
                      *(_WORD *)(v8 + 3) = *(_DWORD *)(a3 + 0x4A);
                      *(_WORD *)(v8 + 0x13) = *(_DWORD *)(a3 + 0x4E);
                      *(_WORD *)(v8 + 0x15) = *(_DWORD *)(a3 + 0x52);
                    }
                  }
                  if ( stricmp((const char *)(a3 - 0x32), "BUTTON") )
                  {
                    break;
                  }
                  if ( *(_DWORD *)(a3 + 0x5A) == 0xFFFFFFFF )
                  {
                    *(_DWORD *)(a3 + 0x5A) = 0;
                  }
                  else
                  {
                    v9 = *(_DWORD *)(a3 + 0x66) + 1;
                    *(_DWORD *)(a3 + 0x72) += 4;
                    *(_DWORD *)(a3 + 0x66) = v9;
                  }
                  if ( *(__int16 *)(*(_DWORD *)(a3 + 0x76) + 0x6B) <= *(_DWORD *)(a3 + 0x66) )
                  {
                    Q_AssertLogBreakExit_sub_26198(0, "..\\helpwin.cpp", 0x145);
                  }
                  sub_56D30(
                    (int)&V_Type3_stru_10AE70,
                    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a3 + 0x72) + *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x67)) + 0x41),
                    0xE,
                    0,
                    0);
                }
                if ( stricmp((const char *)(a3 - 0x32), "TITLE") )
                {
                  break;
                }
                sscanf(
                  (const char *)(a3 - 0x13A),
                  "%s %s",
                  a3 - 0x32,
                  *(_DWORD *)(*(_DWORD *)(a3 + 0x72) + *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x67)) + 0x20);
              }
              if ( stricmp((const char *)(a3 - 0x32), "MSG") )
              {
                break;
              }
              sscanf((const char *)(a3 - 0x13A), "%s %d", a3 - 0x32, a3 + 0x46);
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a3 + 0x72) + *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x67)) + 0x47) = *(_DWORD *)(a3 + 0x46);
            }
            if ( stricmp((const char *)(a3 - 0x32), "PANE") )
            {
              break;
            }
            sscanf((const char *)(a3 - 0x13A), "%s %d %d %d %d", a3 - 0x32, a3 + 0x46, a3 + 0x4A, a3 + 0x4E, a3 + 0x52);
            v10 = *(_DWORD **)(*(_DWORD *)(a3 + 0x72) + *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x67));
            v10[2] = *(_DWORD *)(a3 + 0x46);
            v10[3] = *(_DWORD *)(a3 + 0x4A);
            v10[4] = *(_DWORD *)(a3 + 0x4E);
            v10[5] = *(_DWORD *)(a3 + 0x52);
          }
          if ( stricmp((const char *)(a3 - 0x32), "BPOS") )
          {
            break;
          }
          sscanf((const char *)(a3 - 0x13A), "%s %s", a3 - 0x32, a3 + 0xA);
          v11 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a3 + 0x72) + *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x67)) + 4);
          if ( !stricmp((const char *)(a3 + 0xA), "BL") )
          {
            v11[1] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 8) + 0xF;
            v11[2] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x14) - 0x32;
            v11[3] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 8) + 0x5A;
            v11[4] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x14) - 0xF;
          }
          else if ( !stricmp((const char *)(a3 + 0xA), "BR") )
          {
            v11[1] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x10) - 0x5A;
            v11[2] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x14) - 0x32;
            v11[3] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x10) - 0xF;
            v11[4] = *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x14) - 0xF;
          }
        }
        if ( stricmp((const char *)(a3 - 0x32), "TEXT") )
        {
          break;
        }
        v12 = *(_DWORD *)(a3 + 0x76);
        v13 = *(_DWORD *)(v12 + 0xDA3) + 1;
        *(_DWORD *)(v12 + 0xDA3) = v13;
        if ( v13 >= 0xA )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\helpwin.cpp", 0x177);
        }
        if ( *(int *)(a3 + 0x62) >= 5 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\helpwin.cpp", 0x178);
        }
        if ( *(_DWORD *)(a3 + 0x6A) == 0xFFFFFFFF )
        {
          *(_DWORD *)(a3 + 0x6A) = 0;
        }
        else
        {
          *(_DWORD *)(a3 + 0x42) += 0x1B;
        }
        v14 = *(_DWORD *)(a3 + 0x42);
        *(_BYTE *)v14 = 1;
        *(_DWORD *)(v14 + 0xF) = 0;
        v15 = *(_DWORD *)(a3 + 0x5E);
        *(_DWORD *)(a3 + 0x5E) = v15 + 0x258;
        v16 = (_BYTE *)(v15 + *(_DWORD *)(a3 + 0x56));
        v17 = *(_DWORD *)(a3 + 0x42);
        *(_DWORD *)(v17 + 5) = v16;
        *v16 = 0;
        *(_DWORD *)(v17 + 0xB) = &V_Type3_stru_10AE70.z1[0x3046];
        *(_WORD *)(v17 + 0x13) = 0;
        *(_WORD *)(v17 + 0x15) = 0;
        *(_WORD *)(v17 + 9) = 0xFFFF;
        ++*(_DWORD *)(a3 + 0x62);
        if ( sscanf((const char *)(a3 - 0x13A), "%s %d %d %d", a3 - 0x32, a3 + 0x46, a3 + 0x4A, a3 + 0x4E) == 4 )
        {
          v18 = *(_DWORD *)(a3 + 0x42);
          *(_WORD *)(v18 + 0x13) = *(_DWORD *)(a3 + 0x46);
          *(_WORD *)(v18 + 0x15) = *(_DWORD *)(a3 + 0x4A);
          *(_WORD *)(v18 + 9) = *(_DWORD *)(a3 + 0x4E);
        }
        *(_DWORD *)(a3 + 0x7A) = 0;
        *(_DWORD *)(a3 + 0x7E) = 0;
        do
        {
          Q_HELPWIN_CPP_FgetsLine_sub_2FE58(*(FILE **)(a3 + 0x3E), (char *)(a3 - 0x13A));
          if ( !strnicmp((const char *)(a3 - 0x13A), "ENDTEXT", 7u) )
          {
            *(_DWORD *)(a3 + 0x7A) = 0xFFFFFFFF;
          }
          else
          {
            v19 = strlen((const char *)(a3 - 0x13A)) + *(_DWORD *)(a3 + 0x7E);
            *(_DWORD *)(a3 + 0x7E) = v19;
            if ( v19 >= 0x254 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\helpwin.cpp", 0x19E);
            }
            v20 = (char *)(a3 - 0x13A);
            v21 = (char *)(*(_DWORD *)(*(_DWORD *)(a3 + 0x42) + 5) + strlen(*(const char **)(*(_DWORD *)(a3 + 0x42) + 5)));
            do
            {
              v22 = *v20;
              *v21 = *v20;
              if ( !v22 )
              {
                break;
              }
              v23 = v20[1];
              v20 += 2;
              v21[1] = v23;
              v21 += 2;
            }
            while ( v23 );
          }
        }
        while ( !*(_DWORD *)(a3 + 0x7A) );
        if ( !*(_DWORD *)(*(_DWORD *)(a3 + 0x42) + 5) )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\helpwin.cpp", 0x1A6);
        }
        v24 = *(_BYTE **)(*(_DWORD *)(a3 + 0x42) + 5);
        v25 = 0;
        if ( *v24 )
        {
          do
          {
            if ( v25 >= 0x255 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\helpwin.cpp", 0x1AC);
            }
            if ( *v24 == 0xA )
            {
              *v24 = 0x20;
            }
            else if ( *v24 == 0x40 )
            {
              *v24 = 0xA;
            }
            v26 = *++v24;
            ++v25;
          }
          while ( v26 );
        }
      }
      if ( stricmp((const char *)(a3 - 0x32), "CENTERPOS") )
      {
        break;
      }
      *(_WORD *)(*(_DWORD *)(a3 + 0x42) + 0x13) = (*(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x10)
                                                 - *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 8))
                                                / 2;
      *(_WORD *)(*(_DWORD *)(a3 + 0x42) + 0x15) = (*(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0x14)
                                                 - 0x32
                                                 - *(_DWORD *)(*(_DWORD *)(a3 + 0x76) + 0xC))
                                                / 2;
    }
    if ( stricmp((const char *)(a3 - 0x32), "FONT") )
    {
      break;
    }
    sscanf((const char *)(a3 - 0x13A), "%s %s", a3 - 0x32, a3 + 0xA);
    if ( !stricmp((const char *)(a3 + 0xA), "LARGE") )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 0x42) + 0xB) = &V_Type3_stru_10AE70.z1[0x3046];
    }
    else if ( !stricmp((const char *)(a3 + 0xA), "SMALL") )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 0x42) + 0xB) = &V_Type3_stru_10AE70.z1[0x3026];
    }
  }
  sub_3067B("FLAGS", a3);
}
// 30773: positive sp value 96 has been found
// 306FE: control flows out of bounds to 30700

//----- (00030774) --------------------------------------------------------
void __fastcall sub_30774(int a1)
{
  PANE *v1; // esi
  int v2; // eax
  void *v3; // eax
  int v4; // edi
  int v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // esi
  int v9; // ebx
  int v10; // ecx
  int v11; // ebp
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  int v14; // esi
  _DWORD *v15; // edi
  _DWORD *v16; // eax
  int v17; // edx
  int v18; // ebx
  int v19; // esi
  char *v20; // ebp
  char v21; // ah
  void *v22; // eax
  int v23; // edx
  int v24; // ebx
  int v25; // eax
  const char *v26; // ecx
  int v27; // eax
  int v28; // edx
  int v29; // edi
  __int16 v30; // [esp-Ch] [ebp-A4h]
  LONG v31; // [esp-8h] [ebp-A0h]
  LONG v32; // [esp-8h] [ebp-A0h]
  __int16 v33; // [esp-8h] [ebp-A0h]
  LONG v34; // [esp-4h] [ebp-9Ch]
  int v35[21]; // [esp+0h] [ebp-98h]
  PANE pane; // [esp+54h] [ebp-44h] BYREF
  int v37; // [esp+68h] [ebp-30h]
  int v38; // [esp+6Ch] [ebp-2Ch]
  int v39; // [esp+70h] [ebp-28h]
  int v40; // [esp+74h] [ebp-24h]
  _DWORD *v41; // [esp+78h] [ebp-20h]
  __int16 v42; // [esp+7Ch] [ebp-1Ch]
  __int16 v43; // [esp+80h] [ebp-18h]

  v41 = (_DWORD *)a1;
  v1 = (PANE *)(a1 + 4);
  VFX_pane_wipe((PANE *)(a1 + 4), 0xF2);
  v2 = *((unsigned __int16 *)v41 + 0xC);
  if ( (unsigned __int16)v2 != 0xFFFF )
  {
    v35[0] = 0;
    v31 = *((__int16 *)v41 + 0xF);
    v3 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[v2]);
    VFX_shape_draw(v1, v3, v31, 0, 0);
  }
  v4 = 0;
  v5 = 0;
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(v41 + 1));
  v6 = 0;
  v7 = 0;
  while ( v6 < *(__int16 *)((char *)v41 + 0x6B) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(v7 + *(_DWORD *)((char *)v41 + 0x67)) + 0x35) == 0xFFFFFFFF )
    {
      ++v5;
      ++v4;
      v35[v5] = v6;
    }
    v7 += 4;
    ++v6;
  }
  v8 = v41[2] + 8;
  v9 = v41[2] + 0x147;
  if ( v4 > 0 )
  {
    v10 = v4;
    v11 = 0;
    v38 = 4 * v4;
    do
    {
      v12 = *(_DWORD **)(*(_DWORD *)((char *)v41 + 0x67) + 4 * v35[v11 / 4u + 1]);
      v13 = v41;
      v12[2] = v8;
      v12[3] = v13[3] + 0xD9;
      v12[5] = v41[3] + 0xF7;
      v14 = (v9 - v8) / v10 + v8;
      v15 = v12 + 1;
      if ( v14 > v9 )
      {
        v14 = v9;
      }
      --v10;
      v11 += 4;
      v15[3] = v14;
      v8 = v14 + 1;
    }
    while ( v11 < v38 );
  }
  pane = *(PANE *)(v41 + 1);
  pane.x0 = v41[2] + 0xA;
  pane.y0 = v41[3] + 0xA;
  pane.x1 = v41[2] + 0x145;
  pane.y1 = v41[3] + 0xCF;
  v16 = v41;
  v17 = 0;
  v18 = *(_DWORD *)((char *)v41 + 0xDA7);
  v40 = 0;
  if ( v18 > 0 )
  {
    do
    {
      if ( v40 >= *(_DWORD *)((char *)v41 + 0xDA3) )
      {
        break;
      }
      if ( v16[0x32B] == 0xFFFFFFFF )
      {
        ++v17;
      }
      v16 = (_DWORD *)((char *)v16 + 0x1B);
      v19 = *(_DWORD *)((char *)v41 + 0xDA7);
      ++v40;
    }
    while ( v17 < v19 );
  }
  v39 = 0;
  v20 = (char *)v41 + 0x1B * v40 + 0xC95;
  if ( v40 < *(_DWORD *)((char *)v41 + 0xDA3) )
  {
    do
    {
      if ( v39 == 0xFFFFFFFF )
      {
        break;
      }
      v39 = *(_DWORD *)(v20 + 0x17);
      v21 = *v20;
      if ( *v20 )
      {
        if ( v21 == 1 )
        {
          v23 = 0;
          if ( (v20[0xF] & 2) == 0 )
          {
            v23 = pane.x1 - pane.x0 - *(__int16 *)(v20 + 0x13);
          }
          v35[0] = v23;
          v24 = *(_DWORD *)(v20 + 0x13);
          v25 = *(_DWORD *)(v20 + 0x11);
          v26 = *(const char **)(v20 + 5);
          v42 = *(_WORD *)(v20 + 0xF);
          v43 = *(_WORD *)(v20 + 9);
          v37 = v25 >> 0x10;
          v27 = *(_DWORD *)(v20 + 0xB);
          v33 = v43;
          v30 = v42;
          v28 = v37;
          *(PANE *)(v27 + 8) = pane;
          sub_2B8A8(v27, v28, v24 >> 0x10, v26, v30, v33, 0xFF, v35[0]);
        }
        else if ( v21 != 2 )
        {
          Q_AssertLogBreakExit_sub_261A8(0, "..\\helpwin.cpp", 0x245);
        }
      }
      else
      {
        v35[0] = *(__int16 *)(v20 + 0x15);
        v34 = *(__int16 *)(v20 + 0x13);
        v32 = *(unsigned __int16 *)(v20 + 3);
        v22 = (void *)sub_1B084(
                        (unsigned int)dword_12FC20,
                        (unsigned __int16)word_FFEA0[*(unsigned __int16 *)(v20 + 1)]);
        VFX_shape_draw(&pane, v22, v32, v34, v35[0]);
      }
      v20 += 0x1B;
      v29 = *(_DWORD *)((char *)v41 + 0xDA3);
      ++v40;
    }
    while ( v40 < v29 );
  }
  sub_2D218(v41);
}
// FFEA0: using guessed type __int16 word_FFEA0[7];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00030A90) --------------------------------------------------------
int __fastcall sub_30A90(T_Type5 *a1, int edx0, int a3, int a4)
{
  int v5; // edx
  int v6; // eax
  char *sub_1CEA8; // eax
  int result; // eax
  int *v9; // eax
  LONG v10; // edx
  void *v11; // eax
  LONG v12; // edx
  char *v13; // eax
  int v14; // edx
  int v15; // ebx
  int v16; // ecx
  int v17; // esi
  char *v18; // eax
  void *v19; // eax
  void *v20; // eax
  int v21; // eax
  char *v22; // eax
  __int16 v23; // di
  LONG v24; // ecx
  void *v25; // eax
  __int16 v26; // edx^2
  char *v27; // eax
  __int16 v28; // di
  LONG v29; // ecx
  void *v30; // eax
  __int16 v31; // edx^2
  int v32; // eax
  char *v33; // eax
  __int16 v34; // di
  LONG v35; // ecx
  void *v36; // eax
  LONG v37; // esi
  LONG v38; // ebx
  void *v39; // eax
  int *v40; // edi
  LONG v41; // ebx
  void *v42; // eax
  int v43; // ecx
  LONG v44; // [esp-20h] [ebp-B0h]
  __int16 v45; // [esp-Ch] [ebp-9Ch]
  __int16 v46; // [esp-Ch] [ebp-9Ch]
  __int16 v47; // [esp-Ch] [ebp-9Ch]
  __int16 v48; // [esp-Ch] [ebp-9Ch]
  __int16 v49; // [esp-Ch] [ebp-9Ch]
  int v50; // [esp-8h] [ebp-98h]
  int v51; // [esp-8h] [ebp-98h]
  int v52; // [esp-8h] [ebp-98h]
  int v53; // [esp-8h] [ebp-98h]
  char v54; // [esp-4h] [ebp-94h]
  int v55; // [esp-4h] [ebp-94h]
  char v56; // [esp-4h] [ebp-94h]
  char v57; // [esp-4h] [ebp-94h]
  char v58; // [esp-4h] [ebp-94h]
  char v59; // [esp-4h] [ebp-94h]
  __int16 v60; // [esp-4h] [ebp-94h]
  char s[52]; // [esp+0h] [ebp-90h] BYREF
  int v62; // [esp+34h] [ebp-5Ch]
  int v63; // [esp+38h] [ebp-58h]
  LONG shape_number; // [esp+3Ch] [ebp-54h]
  char *v65; // [esp+40h] [ebp-50h]
  int a2; // [esp+44h] [ebp-4Ch]
  int v67; // [esp+48h] [ebp-48h]
  LONG v68; // [esp+4Ch] [ebp-44h]
  int v69; // [esp+50h] [ebp-40h]
  int v70; // [esp+54h] [ebp-3Ch]
  int v71; // [esp+58h] [ebp-38h]
  int v72; // [esp+5Ch] [ebp-34h]
  int v73; // [esp+60h] [ebp-30h]
  LONG v74; // [esp+64h] [ebp-2Ch]
  LONG v75; // [esp+68h] [ebp-28h]
  LONG hotY; // [esp+6Ch] [ebp-24h]
  int *v77; // [esp+70h] [ebp-20h]
  int v78; // [esp+74h] [ebp-1Ch]
  int v79; // [esp+78h] [ebp-18h]
  __int16 i; // [esp+7Ch] [ebp-14h]
  int v81; // [esp+80h] [ebp-10h]

  v77 = (int *)edx0;
  v67 = 9;
  if ( a4 && (a3 == 1 || *(_DWORD *)(edx0 + 8) != 0xFFFFFFFF) )
  {
    v67 = 0xF3;
  }
  else
  {
    v5 = v77[2];
    if ( v5 != 0xFFFFFFFF )
    {
      v67 = 4 * v77[v5 + 0xA] + 0x13;
    }
  }
  sprintf(s, "%d.", v77[0x1B]);
  v45 = v67;
  a2 = (__int16)v67;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 5, 5, s, 0, v45, 0xFF, 0);
  HIWORD(v6) = HIWORD(v77);
  if ( v77[2] == 0xFFFFFFFF )
  {
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x10);
    v46 = a2;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
    return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x1E, 5, sub_1CEA8, 0, v46, 0xFF, 0);
  }
  LOWORD(v6) = word_FFEE0;
  v81 = v6;
  v9 = &v77[v77[2]];
  v10 = v9[3];
  v78 = v9[0xA];
  shape_number = v10;
  v54 = v78;
  v11 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v81);
  sub_53F40(a1, v11, v10, 0x19, 5, v54);
  v12 = shape_number;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 5, &byte_1050A4[0x14 * v12], 0, a2, 0xFF, 0);
  v55 = *v77;
  v13 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x11);
  sprintf(s, v13, v55);
  v47 = a2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 0x14, s, 0, v47, 0xFF, 0);
  v14 = ((v77[0x1C] & 0xFE00) >> 9) + 0x50;
  v15 = v77[0x1C] & 0x1F;
  v16 = (v77[0x1C] & 0x1E0) >> 5;
  v69 = (*((_WORD *)v77 + 0x39) & 0xF800) >> 0xB;
  v17 = v69;
  v65 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x12);
  if ( v17 )
  {
    if ( v17 == 0xC )
    {
      v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x13);
    }
    else
    {
      if ( v17 <= 0xC )
      {
        goto LABEL_16;
      }
      v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x13);
      v69 = v17 - 0xC;
    }
    v65 = v18;
    goto LABEL_16;
  }
  v69 = 0xC;
LABEL_16:
  v62 = (*((_WORD *)v77 + 0x39) & 0x7E0) >> 5;
  sprintf(s, "%d/%d/%d", v16, v15, v14);
  v48 = v67;
  v63 = (__int16)v67;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 0x32, s, 0, v48, 0xFF, 0);
  sprintf(s, "%d : %.2d %s", v69, v62, v65);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1->rect.y2;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x2D, 0x41, s, 0, v63, 0xFF, 0);
  v44 = shape_number;
  v19 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
  VFX_shape_transform((PANE *)a1, v19, v44, 0x96, 0x1E, buffer, 0, 0x8000, 0x8000, 0);
  v56 = v78;
  v20 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
  sub_53F40(a1, v20, 3, 0x96, 0x1E, v56);
  LOWORD(v21) = word_FFEF2;
  v79 = v21;
  v68 = 0xC8;
  v22 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x14);
  v73 = 0x14;
  v49 = v63;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v23 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xC8, 5, v22, 0, v49, 0xFF, 0);
  while ( v23 < v77[0x18] )
  {
    v24 = v68;
    v57 = v78;
    v50 = v73;
    v25 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v79);
    sub_53F40(a1, v25, 5, v24, v50, v57);
    v68 += 8;
    if ( v23 % 9 == 8 )
    {
      v68 = 0xC8;
      v73 += 8;
    }
    ++v23;
  }
  v26 = v67;
  v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x15);
  v74 = 0x118;
  v72 = 0x14;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v28 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x118, 5, v27, 0, v26, 0xFF, 0);
  while ( v28 < v77[0x19] )
  {
    v29 = v74;
    v58 = v78;
    v51 = v72;
    v30 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v79);
    sub_53F40(a1, v30, 6, v29, v51, v58);
    v74 += 8;
    if ( v28 % 9 == 8 )
    {
      v74 = 0x118;
      v72 += 8;
    }
    ++v28;
  }
  v31 = v67;
  v32 = v77[0x1A] >> 2;
  v75 = 0x168;
  v70 = v32;
  v71 = 0x14;
  v33 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x16);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v34 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x168, 5, v33, 0, v31, 0xFF, 0);
  while ( v34 < v70 )
  {
    v59 = v78;
    v52 = v71;
    v35 = v75;
    v36 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v79);
    sub_53F40(a1, v36, 7, v35, v52, v59);
    v75 += 8;
    if ( v34 % 9 == 8 )
    {
      v75 = 0x168;
      v71 += 8;
    }
    ++v34;
  }
  hotY = 5;
  v37 = 0x1CC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v77[1] )
    {
      break;
    }
    if ( i != v77[2] )
    {
      v40 = &v77[i];
      if ( v40[0x11] )
      {
        v60 = *((_WORD *)v40 + 0x14);
        v53 = hotY;
        v41 = v40[3];
        v42 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v81);
        sub_53F40(a1, v42, v41, v37, v53, v60);
        v43 = v40[0x11];
        v38 = 0xFFFFFFFF;
        if ( v43 == 3 )
        {
          v38 = 9;
        }
        else if ( v43 == 2 )
        {
          v38 = 8;
        }
        if ( v38 != 0xFFFFFFFF )
        {
          v39 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
          VFX_shape_draw((PANE *)a1, v39, v38, v37, hotY);
        }
        v37 += 0x39;
        if ( v37 > 0x258 )
        {
          v37 = 0x1CC;
          hotY += 0x1B;
        }
      }
    }
  }
  return result;
}
// 30E3F: variable 'v21' is possibly undefined
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEE0: using guessed type __int16 word_FFEE0;
// FFEF2: using guessed type __int16 word_FFEF2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00031158) --------------------------------------------------------
int __fastcall sub_31158(_DWORD *a1, int a2, int a3, int a4)
{
  __int16 v5; // dx
  char s[12]; // [esp+0h] [ebp-20h] BYREF
  int v8; // [esp+Ch] [ebp-14h]
  int v9; // [esp+10h] [ebp-10h]

  v9 = a2;
  v5 = 9;
  if ( a4 )
  {
    v5 = 0xF3;
  }
  sprintf(s, "%d.", *(_DWORD *)(v9 + 0xDC));
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  v8 = v5;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 5, 5, s, 0, v5, 0xFF, 0);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x1E, 5, (const char *)(v9 + 0x14), 0, v8, 0xFF, 0x226);
}

//----- (00031200) --------------------------------------------------------
T_TypeA2 *__fastcall sub_31200(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_95E88;
  sub_2C8E4(&result->a);
  return result;
}
// 95E88: using guessed type int (*off_95E88[5])();

//----- (0003121C) --------------------------------------------------------
void *__fastcall sub_3121C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95E74);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95E88;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95E88: using guessed type int (*off_95E88[5])();

//----- (00031268) --------------------------------------------------------
unsigned int __fastcall sub_31268(int a1, unsigned __int16 a2, int a3, int a4)
{
  const char *v6; // ecx
  int v7; // eax
  char v8; // bl
  int v9; // edx
  char *v10; // edi
  const char *v11; // esi
  int v12; // ebx
  char v13; // al
  char v14; // al
  const char *v15; // esi
  int v16; // edx
  char *v17; // edi
  int v18; // ecx
  char v19; // al
  char v20; // al
  int v21; // eax
  int v22; // ebx
  int v23; // eax
  int v24; // edx
  int v25; // esi
  char v26; // ah
  int v27; // ebp
  char *v28; // edi
  char *v29; // esi
  char v30; // al
  char v31; // al
  const char *v32; // esi
  unsigned int v33; // kr04_4
  char *v34; // edi
  char v35; // al
  char v36; // al
  char *v37; // edi
  char *v38; // esi
  char v39; // al
  char v40; // al
  const char *v41; // esi
  char *v42; // edi
  char v43; // al
  char v44; // al
  T_Type1 v45; // [esp+0h] [ebp-150h] BYREF
  char s[32]; // [esp+118h] [ebp-38h] BYREF
  int v47; // [esp+138h] [ebp-18h]
  _BYTE v48[6]; // [esp+13Ch] [ebp-14h]

  *(_WORD *)&v48[4] = a2;
  *(_DWORD *)v48 = a3;
  v47 = a4;
  if ( a2 < 3u )
  {
    if ( a2 != 1 )
    {
      return sub_2F424(a1, *(__int16 *)&v48[4], *(int *)v48, v47);
    }
    v6 = "savescr";
    if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 2 )
    {
      *(_BYTE *)(a1 + 0xAF) = 1;
    }
    else if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] == 4 )
    {
      v6 = "loadscr";
      *(_BYTE *)(a1 + 0xAF) = 0;
    }
    else
    {
      v6 = "tutscr";
      *(_BYTE *)(a1 + 0xAF) = 2;
    }
    v7 = sub_56DA8((int)&V_Type3_stru_10AE70, "LOADLIST", 0);
    v8 = *(_BYTE *)(a1 + 0xAF);
    *(_DWORD *)(a1 + 0xAB) = v7;
    if ( v8 == 2 )
    {
      *(_WORD *)(v7 + 0x8C9) = 0x3C;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_31158);
      sub_317D0(a1);
    }
    else
    {
      *(_WORD *)(v7 + 0x8C9) = 0x55;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_30A90);
      sub_316A8(a1, (int)sub_30A90);
    }
    v9 = *(_DWORD *)&v48[2];
    v10 = (char *)(a1 + 0x4F);
    v11 = v6;
    v12 = *(_DWORD *)v48;
    do
    {
      v13 = *v11;
      *v10 = *v11;
      if ( !v13 )
      {
        break;
      }
      v14 = v11[1];
      v11 += 2;
      v10[1] = v14;
      v10 += 2;
    }
    while ( v14 );
    v15 = v6;
    v16 = v9 >> 0x10;
    v17 = (char *)(*(_DWORD *)(a1 + 0xAB) + 0x4F);
    v18 = v47;
    do
    {
      v19 = *v15;
      *v17 = *v15;
      if ( !v19 )
      {
        break;
      }
      v20 = v15[1];
      v15 += 2;
      v17[1] = v20;
      v17 += 2;
    }
    while ( v20 );
    sub_2F424(a1, v16, v12, v18);
    return 0;
  }
  if ( a2 <= 3u )
  {
    if ( a3 >= 0x31 && a3 <= 0x39 )
    {
      v21 = 9;
      v22 = a3 - 0x30;
      if ( *(_BYTE *)(a1 + 0xAF) == 1 )
      {
        v21 = 0xA;
      }
      if ( v22 < v21 )
      {
        (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 8))();
        return 0xFFFFFFFF;
      }
    }
    return 0;
  }
  if ( a2 != 0x1C01 )
  {
    return sub_2F424(a1, *(__int16 *)&v48[4], *(int *)v48, v47);
  }
  v23 = sub_2ED14(*(_DWORD *)(a1 + 0xAB), *(unsigned __int16 *)v48);
  v24 = *(_DWORD *)(v23 + 0x6C);
  v25 = v23;
  sprintf(s, "%02d.sav", v24);
  Q_InitFileInfo_sub_1BB78(&v45);
  v26 = *(_BYTE *)(a1 + 0xAF);
  if ( v26 == 1 )
  {
    sub_54048(s, 3, a3, a4);
    sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
  }
  else if ( v26 )
  {
    v27 = 0xE0 * a3 + a1 + 0x9C0;
    v28 = s;
    v29 = (char *)v27;
    do
    {
      v30 = *v29;
      *v28 = *v29;
      if ( !v30 )
      {
        break;
      }
      v31 = v29[1];
      v29 += 2;
      v28[1] = v31;
      v28 += 2;
    }
    while ( v31 );
    v32 = ".tsv";
    v33 = strlen(s) + 1;
    v34 = &s[v33 - 1];
    do
    {
      v35 = *v32;
      *v34 = *v32;
      if ( !v35 )
      {
        break;
      }
      v36 = v32[1];
      v32 += 2;
      v34[1] = v36;
      v34 += 2;
    }
    while ( v36 );
    v37 = s;
    sub_53FB0(s, 3, 0, ~v33);
    v38 = (char *)v27;
    sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
    srand(0);
    dword_96BBC = LODWORD(flt_12FC1C);
    flt_12FC1C = 1.0;
    do
    {
      v39 = *v38;
      *v37 = *v38;
      if ( !v39 )
      {
        break;
      }
      v40 = v38[1];
      v38 += 2;
      v37[1] = v40;
      v37 += 2;
    }
    while ( v40 );
    v41 = ".bin";
    v42 = &s[strlen(s)];
    do
    {
      v43 = *v41;
      *v42 = *v41;
      if ( !v43 )
      {
        break;
      }
      v44 = v41[1];
      v41 += 2;
      v42[1] = v44;
      v42 += 2;
    }
    while ( v44 );
    sub_59988(&V_Type3_stru_10AE70, s, 0);
  }
  else if ( *(_DWORD *)(v25 + 8) != 0xFFFFFFFF )
  {
    sub_53FB0(s, v24, 1, a4);
    *(_WORD *)&V_Type3_stru_10AE70.z2[0x148] = 1;
    *(_WORD *)&V_Type3_stru_10AE70.z2[0x126] = 0;
    *(_WORD *)&V_Type3_stru_10AE70.z2[0x146] = 1;
    sub_56B60((int)&V_Type3_stru_10AE70, 1, 1, 0);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v45);
  return 0xFFFFFFFF;
}
// 96BBC: using guessed type int dword_96BBC;
// 12FC1C: using guessed type float flt_12FC1C;
// 31268: using guessed type char s[32];

//----- (0003160C) --------------------------------------------------------
void __fastcall sub_3160C(int a1)
{
  char v2; // ah
  LONG v3; // edx
  char *v4; // eax
  char *sub_1CEA8; // [esp+0h] [ebp-18h]

  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x17);
  v2 = *(_BYTE *)(a1 + 0xAF);
  v3 = 0x10;
  if ( v2 == 1 )
  {
    v3 = 0x73;
    v4 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x18);
  }
  else
  {
    if ( v2 != 2 )
    {
      goto LABEL_6;
    }
    v4 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x19);
    v3 = 0;
  }
  sub_1CEA8 = v4;
LABEL_6:
  if ( v3 )
  {
    VFX_pane_wipe((PANE *)(a1 + 4), v3);
  }
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 4, sub_1CEA8, 3, 0xFFFFFFFF, 0xFF, 0);
  sub_2D218((_DWORD *)a1);
}

//----- (000316A8) --------------------------------------------------------
void __fastcall sub_316A8(int a1, int a2)
{
  int v3; // edi
  int v4; // esi
  unsigned __int16 v5; // dx
  T_Type1 handle; // [esp+0h] [ebp-158h] BYREF
  char s[32]; // [esp+118h] [ebp-40h] BYREF
  int v8; // [esp+138h] [ebp-20h]
  int v9; // [esp+13Ch] [ebp-1Ch]

  v9 = a1;
  sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
  v3 = 0;
  Q_InitFileInfo_sub_1BB78(&handle);
  v4 = a1 + 0xB0;
  do
  {
    v8 = v3 + 1;
    sprintf(s, "%02d.sav", v3 + 1);
    if ( access(s, 0) )
    {
      *(_DWORD *)(v4 + 8) = 0xFFFFFFFF;
    }
    else
    {
      Q_CfilePreload_sub_1BBFC(&handle, s, 0x200, 0);
      sub_1BF94(&handle, (void *)v4, 0x74u);
      dos_getftime(handle.fh, (unsigned __int16 *)(v4 + 0x70), (unsigned __int16 *)(v4 + 0x72));
    }
    *(_DWORD *)(v4 + 0x6C) = v8;
    sub_2EA8C(*(_DWORD *)(v9 + 0xAB), (const char *)v4, 0xFFFFFFFF, 0);
    v4 += 0x74;
    v5 = v3++;
    sub_2EC50(*(_DWORD *)(v9 + 0xAB), v5, *(_BYTE *)(v9 + 0xAF) == 1);
  }
  while ( v3 < 0x14 );
  Q_CloseFileAndDelete_sub_1BBC8(&handle);
}
// 316A8: using guessed type T_Type1 handle;

//----- (000317D0) --------------------------------------------------------
int __fastcall sub_317D0(int a1)
{
  FILE *v1; // ebp
  int v2; // esi
  char *v3; // edi
  int v4; // eax
  int v6; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+4h] [ebp-20h]
  int v8; // [esp+8h] [ebp-1Ch]

  v7 = a1;
  sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
  v1 = sub_1BB10("tutindex.txt", 0);
  fscanf(v1, "%d", &v6);
  if ( v6 > 7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\loadwin.cpp", 0x1EA);
  }
  v2 = v7 + 0x9C0;
  v8 = 0;
  if ( v6 > 0 )
  {
    v3 = (char *)(v7 + 0x9D4);
    do
    {
      fscanf(v1, "%s", v2);
      Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v1, v3);
      sub_2EA8C(*(_DWORD *)(v7 + 0xAB), (const char *)v2, 0xFFFFFFFF, 0);
      v4 = v8 + 1;
      v3 += 0xE0;
      *(_DWORD *)(v2 + 0xDC) = v8 + 1;
      v2 += 0xE0;
      v8 = v4;
    }
    while ( v4 < v6 );
  }
  return fclose(v1);
}

//----- (000318A0) --------------------------------------------------------
int __fastcall sub_318A0(unsigned __int16 a1, unsigned __int8 a2)
{
  int v3; // esi
  unsigned int v4; // edx
  int v5; // edi
  _DWORD *v7; // eax
  int v8; // ebx

  v3 = *((unsigned __int16 *)dword_10032C + a1);
  if ( (unsigned __int16)v3 == 0xFFFF )
  {
    return 0;
  }
  v4 = dword_100328 + 4 * (unsigned __int16)word_100330;
  v5 = a2;
  v7 = (_DWORD *)(dword_100328 + 4 * v3);
  v8 = (v5 << 0x10) + a1;
  if ( (unsigned int)v7 >= v4 )
  {
    return 0;
  }
  while ( v8 != *v7 )
  {
    if ( (unsigned int)++v7 >= v4 )
    {
      return 0;
    }
  }
  return (unsigned __int16)((int)((int)v7
                                + -dword_100328
                                - __CFSHL__(((int)v7 - dword_100328) >> 0x1F, 2)
                                + 0xFFFFFFFC * (((int)v7 - dword_100328) >> 0x1F)) >> 2)
       + 0x102;
}
// 100328: using guessed type int dword_100328;
// 100330: using guessed type __int16 word_100330;

//----- (00031934) --------------------------------------------------------
char __fastcall sub_31934(int a1)
{
  char v1; // ch
  unsigned __int16 v2; // si
  char v3; // dh
  char v4; // al
  int v5; // edx
  char result; // al
  char v7; // ch
  int v8; // ebx

  v1 = byte_100335;
  v2 = a1;
  v3 = (a1 << byte_100335) | *(_BYTE *)dword_100324++;
  *(_BYTE *)(dword_100324 - 1) = v3;
  v4 = byte_100334;
  if ( (unsigned __int16)(dword_100324 - dword_100338) == 0x100 )
  {
    *(_BYTE *)dword_100338 = 0xFF;
    dword_100338 = dword_100324++;
  }
  v5 = (int)v2 >> (8 - v1);
  result = v4 - (8 - v1);
  v7 = 0;
  v8 = dword_100324;
  *(_BYTE *)dword_100324 = v5;
  if ( (unsigned __int8)result >= 8u )
  {
    dword_100324 = v8 + 1;
    if ( (unsigned __int16)(v8 + 1 - dword_100338) == 0x100 )
    {
      *(_BYTE *)dword_100338 = 0xFF;
      dword_100338 = dword_100324++;
    }
    if ( (unsigned __int8)result > 8u )
    {
      v7 = result - 8;
      *(_BYTE *)dword_100324 = BYTE1(v5);
    }
  }
  else
  {
    v7 = result;
  }
  byte_100335 = v7;
  return result;
}
// 100324: using guessed type int dword_100324;
// 100334: using guessed type char byte_100334;
// 100335: using guessed type char byte_100335;
// 100338: using guessed type int dword_100338;

//----- (00031A34) --------------------------------------------------------
int __fastcall sub_31A34(unsigned __int16 a1, char a2)
{
  int v2; // ecx
  unsigned __int16 v3; // bx
  _WORD *v4; // edx
  int result; // eax

  v2 = dword_100328;
  v3 = word_100330;
  *(_BYTE *)(dword_100328 + 4 * (unsigned __int16)word_100330 + 2) = a2;
  *(_WORD *)(v2 + 4 * v3) = a1;
  v4 = (char *)dword_10032C + 2 * a1;
  if ( (unsigned __int16)*v4 == 0xFFFF )
  {
    *v4 = word_100330;
  }
  sub_31934(a1);
  result = (unsigned __int16)++word_100330 + 0x102;
  if ( result > (unsigned __int16)word_100332 )
  {
    if ( result <= 0x1000 )
    {
      BYTE1(result) = byte_100334 + 1;
      word_100332 *= 2;
      ++byte_100334;
    }
    else
    {
      sub_31934(0x100);
      byte_100334 = 9;
      word_100332 = 0x200;
      word_100330 = 0;
      return (int)memset(dword_10032C, 0xFF, 0x2008u);
    }
  }
  return result;
}
// 100328: using guessed type int dword_100328;
// 100330: using guessed type __int16 word_100330;
// 100332: using guessed type __int16 word_100332;
// 100334: using guessed type char byte_100334;

//----- (00031B08) --------------------------------------------------------
int __spoils<> sub_31B08()
{
  int v0; // ebx
  int v1; // esi
  unsigned __int16 v2; // ax
  UBYTE v3; // cl
  int v4; // ebx
  int v5; // eax
  char v6; // dh
  int result; // eax
  _BYTE *v8; // ebx
  int v9; // ebx
  char v10; // bl

  v0 = dword_100324;
  byte_100334 = 9;
  word_100332 = 0x200;
  *(_BYTE *)dword_100324 = 8;
  byte_100335 = 0;
  dword_100338 = v0 + 1;
  dword_100324 = v0 + 2;
  sub_31934(0x100);
  v1 = 1;
  v2 = *V_Window1.buffer;
  do
  {
    v3 = V_Window1.buffer[v1];
    v4 = v2;
    v2 = sub_318A0(v2, v3);
    if ( !v2 )
    {
      sub_31A34(v4, v3);
      v2 = v3;
    }
    ++v1;
  }
  while ( v1 < 0x4B000 );
  sub_31934(v2);
  sub_31934(0x101);
  LOWORD(v5) = dword_100324;
  LOWORD(v4) = dword_100338;
  v6 = byte_100335;
  result = v5 - v4;
  if ( byte_100335 )
  {
    *(_BYTE *)dword_100338 = result;
    v8 = (_BYTE *)(dword_100324 + 1);
    dword_100324 = (int)v8;
    *v8 = 0;
    v9 = (int)(v8 + 1);
  }
  else
  {
    v10 = result;
    if ( (unsigned __int16)result == 1 )
    {
      result = dword_100338;
      *(_BYTE *)dword_100338 = byte_100335;
      return result;
    }
    result = dword_100338;
    *(_BYTE *)dword_100338 = v10 - 1;
    v9 = dword_100324 + 1;
    *(_BYTE *)dword_100324 = v6;
  }
  dword_100324 = v9;
  return result;
}
// 31BC0: variable 'v5' is possibly undefined
// 100324: using guessed type int dword_100324;
// 100332: using guessed type __int16 word_100332;
// 100334: using guessed type char byte_100334;
// 100335: using guessed type char byte_100335;
// 100338: using guessed type int dword_100338;

//----- (00031C18) --------------------------------------------------------
int __fastcall sub_31C18(int result, int a2)
{
  RGB *v2; // edi
  LONG v3; // esi
  int v4; // edi
  _BYTE *v5; // ebp
  int v6; // esi
  _BYTE *v7; // ebp
  int v8; // ebx
  _WORD *v9; // ebp
  int v10; // ebp
  void *v11; // ecx
  int v12; // esi
  RGB *v13; // [esp-4h] [ebp-30h]
  int v14; // [esp-4h] [ebp-30h]
  char s[20]; // [esp+0h] [ebp-2Ch] BYREF
  RGB *triplet; // [esp+14h] [ebp-18h]

  if ( a2 >= (int)&V_CobFilesIndex_stru_9A254.fnames[0x17][0x16] )
  {
    V_Window1.buffer = (UBYTE *)result;
    V_Window1.x_max = 0x27F;
    V_Window1.y_max = 0x1DF;
    V_Window1.shadow = 0;
    V_Window1.stencil = 0;
    triplet = (RGB *)(result + 0x4B000);
    VFX_window_read(&V_Window1, 0, 0, 0x27F, 0x1DF);
    dword_100308 = (int)triplet;
    v2 = triplet;
    v3 = 0;
    triplet += 0x100;
    do
    {
      v13 = v2++;
      VFX_DAC_read(v3++, v13);
    }
    while ( v3 < 0x100 );
    buf = triplet;
    memset(triplet, 0, (size_t)&loc_493DC + 4);
    dword_100328 = (int)triplet + (_DWORD)&loc_493DC + 4;
    word_100330 = 0;
    triplet = (RGB *)((char *)triplet + (_DWORD)&loc_493DC + 4 + 0x4000);
    dword_10032C = triplet;
    dword_100324 = (int)buf;
    memset(triplet, 0xFF, 0x2008u);
    v4 = dword_100324;
    qmemcpy((void *)dword_100324, "GIF87a", 4u);
    qmemcpy((void *)(v4 + 4), "7a", 2u);
    v5 = (_BYTE *)(dword_100324 + 6);
    *(_WORD *)(dword_100324 + 6) = 0x280;
    v5 += 2;
    *(_WORD *)v5 = 0x1E0;
    v5 += 2;
    *v5++ = 0x87;
    *v5++ = 0xFF;
    v6 = 0;
    *v5 = 0;
    v7 = v5 + 1;
    do
    {
      ++v7;
      v8 = 0xFF * *(unsigned __int8 *)(v6 + dword_100308) / 0x3F;
      ++v6;
      v7[0xFFFFFFFF] = v8;
    }
    while ( v6 < 0x300 );
    *v7 = 0x2C;
    v9 = v7 + 1;
    *v9++ = 0;
    *v9++ = 0;
    *v9++ = 0x280;
    *v9++ = 0x1E0;
    *(_BYTE *)v9 = 7;
    dword_100324 = (int)v9 + 1;
    sub_31B08();
    v14 = dword_10033C;
    v10 = dword_100324;
    *(_BYTE *)dword_100324 = 0x3B;
    ++v10;
    v11 = buf;
    dword_100324 = v10;
    sprintf(s, "scr%03d.gif", v14);
    v12 = open(s, 0x262, 0x1C0);
    write(v12, buf, v10 - (_DWORD)v11);
    result = close(v12);
    dword_100324 = 0;
    dword_10032C = 0;
    dword_100328 = 0;
    buf = 0;
    V_Window1.buffer = 0;
    dword_100308 = 0;
    ++dword_10033C;
  }
  return result;
}
// 100308: using guessed type int dword_100308;
// 100324: using guessed type int dword_100324;
// 100328: using guessed type int dword_100328;
// 100330: using guessed type __int16 word_100330;
// 10033C: using guessed type int dword_10033C;

//----- (00031E60) --------------------------------------------------------
char __fastcall sub_31E60(const char *a1, int a2)
{
  int v3; // edx
  const char *v4; // esi
  char *v5; // edi
  char v6; // al
  char v7; // al
  const char *v8; // edi
  char *v9; // esi
  char *v10; // edi
  char v11; // al
  char v12; // al
  char *v13; // esi
  char *v14; // edi
  char v15; // al
  char v16; // al
  char *v17; // esi
  char *v18; // edi
  char result; // al
  const char *v20; // [esp-4h] [ebp-1Ch]

  if ( a2 < 0 || !a1 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\name.cpp", 0x29);
  }
  v3 = 0x3E8;
  if ( a2 > 0x3E8 )
  {
    v8 = a1;
    do
    {
      if ( v3 >= 0xFA0 )
      {
        break;
      }
      v4 = "M";
      v20 = v8;
      v5 = (char *)&v8[strlen(v8)];
      do
      {
        v6 = *v4;
        *v5 = *v4;
        if ( !v6 )
        {
          break;
        }
        v7 = v4[1];
        v4 += 2;
        v5[1] = v7;
        v5 += 2;
      }
      while ( v7 );
      v8 = v20;
      v3 += 0x3E8;
    }
    while ( v3 < a2 );
  }
  v9 = (char *)&unk_9678C + 5 * (a2 / 0x64 % 0xA);
  v10 = (char *)&a1[strlen(a1)];
  do
  {
    v11 = *v9;
    *v10 = *v9;
    if ( !v11 )
    {
      break;
    }
    v12 = v9[1];
    v9 += 2;
    v10[1] = v12;
    v10 += 2;
  }
  while ( v12 );
  v13 = (char *)&unk_967BE + 5 * (a2 / 0xA % 0xA);
  v14 = (char *)&a1[strlen(a1)];
  do
  {
    v15 = *v13;
    *v14 = *v13;
    if ( !v15 )
    {
      break;
    }
    v16 = v13[1];
    v13 += 2;
    v14[1] = v16;
    v14 += 2;
  }
  while ( v16 );
  v17 = (char *)&unk_967F0 + 5 * (a2 % 0xA);
  v18 = (char *)&a1[strlen(a1)];
  do
  {
    result = *v17;
    *v18 = *v17;
    if ( !result )
    {
      break;
    }
    result = v17[1];
    v17 += 2;
    v18[1] = result;
    v18 += 2;
  }
  while ( result );
  return result;
}

//----- (00031FB0) --------------------------------------------------------
int __fastcall sub_31FB0(_DWORD *a1, const char *a2, int a3, int a4)
{
  unsigned __int8 v5; // dl
  int v7; // [esp-4h] [ebp-10h]

  v5 = 4 * byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  if ( a4 == 0xFFFFFFFF )
  {
    v5 = 0xF3;
  }
  v7 = a1[3] - a1[1] - 0x10;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 8, 3, a2, 0, v5, 0xFF, v7);
}

//----- (0003201C) --------------------------------------------------------
void __fastcall __spoils<> sub_3201C(P_TypeA7 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95F1C;
  sub_3207C(a1);
}
// 95F1C: using guessed type int (*off_95F1C[5])();

//----- (00032038) --------------------------------------------------------
void *__fastcall sub_32038(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95ED8);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F1C;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F1C: using guessed type int (*off_95F1C[5])();

//----- (0003207C) --------------------------------------------------------
void __fastcall __spoils<> sub_3207C(P_TypeA7 result)
{
  result->b = 0;
  result->c = 0;
  result->d = 0;
  result->f = 0xFFFF;
  result->g = 0xFFFF;
  result->h = 0xFFFF;
}

//----- (000320B8) --------------------------------------------------------
unsigned int __fastcall sub_320B8(int a1, __int16 a2, int a3, int a4)
{
  int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char v9; // bl
  int v10; // eax
  char *v11; // eax
  __int16 v12; // ax
  __int16 v13; // ax
  int v15; // edx
  char v16[32]; // [esp+0h] [ebp-44h] BYREF
  char v17[16]; // [esp+20h] [ebp-24h] BYREF
  int v18; // [esp+30h] [ebp-14h]
  int v19; // [esp+34h] [ebp-10h]
  int v20; // [esp+38h] [ebp-Ch]
  int v21; // [esp+3Ch] [ebp-8h]
  __int16 v22; // [esp+40h] [ebp-4h]
  _BYTE savedregs[12]; // [esp+44h] [ebp+0h]
  void *retaddr; // [esp+50h] [ebp+Ch]

  v22 = a2;
  v5 = a3;
  v21 = a4;
  v18 = (unsigned __int8)byte_104BEA;
  v20 = (unsigned __int8)byte_968DD;
  if ( (unsigned __int16)a2 < 4u )
  {
    if ( !a2 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    if ( (unsigned __int16)a2 <= 1u )
    {
      if ( !*(_DWORD *)(a1 + 0xAB) )
      {
        a3 = 0xD;
        a4 = 0;
        v6 = sub_56E18((int)&V_Type3_stru_10AE70, "PLAYERDIP", 0xD, 0);
        *(_DWORD *)(a1 + 0xAB) = v6;
        if ( !v6 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x7B);
        }
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x1D;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_31FB0);
      sub_2E9CC(*(_DWORD *)(a1 + 0xAB), 0);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC6) = 0xF2;
      if ( !*(_DWORD *)(a1 + 0xAF) )
      {
        a3 = 0xD;
        a4 = 0;
        v7 = sub_56E18((int)&V_Type3_stru_10AE70, "ALIENDIP", 0xD, 0);
        *(_DWORD *)(a1 + 0xAF) = v7;
        if ( !v7 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x88);
        }
      }
      if ( !*(_DWORD *)(a1 + 0xB3) )
      {
        a3 = 0xD;
        a4 = 0;
        v8 = sub_56E18((int)&V_Type3_stru_10AE70, "COSMOSWnd", 0xD, 0);
        *(_DWORD *)(a1 + 0xB3) = v8;
        if ( !v8 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x8F);
        }
      }
      sub_32658(a1);
      sub_32E84(a1, 0, a3, a4);
      *(_WORD *)(*(_DWORD *)(a1 + 0xAF) + 0xB1) = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_968DD]
                                                + 0x13;
      memset(byte_101DC4, 0, 0xFu);
      v9 = byte_A315B[0x1EE * v20];
      v10 = 0x1EE * v18;
      *(_DWORD *)(a1 + 0xB7) = 0;
      v11 = &byte_A2F72[v10];
      if ( v9 == 0xE )
      {
        v13 = sub_44238(
                (int)v11,
                (unsigned __int8)byte_968DD,
                v17,
                HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF))));
        sub_32A48(a1, (int)v17, v13, 0xFFFFFFFF, 0xFFFFFFFF);
        sub_32C14(a1, 0x1D);
      }
      else
      {
        v19 = v9;
        *(_DWORD *)(a1 + 0xB7) = 0xFFFFFFFF;
        v12 = sub_44A2C(v11, (__int16)retaddr, v9, v16);
        sub_32B44(a1, (int)v16, v12);
        sub_32BDC(a1, v19);
      }
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    if ( a2 != 2 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    sub_2D258(a1, *(__int16 *)&savedregs[4]);
    return 0;
  }
  if ( (unsigned __int16)a2 <= 5u )
  {
    if ( a3 >= 0xAE && a3 <= 0x147 && a4 >= 0x145 && a4 <= 0x1D8 )
    {
      sub_4FB90((int)&unk_10914C, 0);
      sub_32714(a1, a3, a4);
      return 0xFFFFFFFF;
    }
    return 0;
  }
  if ( (unsigned __int16)a2 < 0xCu )
  {
    return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
  }
  if ( (unsigned __int16)a2 <= 0xCu )
  {
    if ( a3 < 0xAE || a3 > 0x147 || a4 < 0x145 || a4 > 0x1D8 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    sub_56B60((int)&V_Type3_stru_10AE70, 5, (int)"tinyrace", 0);
    return 0xFFFFFFFF;
  }
  else
  {
    if ( a2 != 0x1C01 )
    {
      return sub_2F424(a1, *(__int16 *)&savedregs[4], v5, v21);
    }
    v15 = sub_2ECA4(*(_DWORD *)(a1 + 0xAB), a3);
    sub_32800(a1, v15);
    if ( *(_DWORD *)(a1 + 0xB7) == 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0xB7) = 0;
    }
    return 0xFFFFFFFF;
  }
}
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;

//----- (00032414) --------------------------------------------------------
void __fastcall sub_32414(int a1)
{
  int v1; // eax
  __int16 i; // di
  int v3; // eax
  __int16 v4; // bx
  __int16 v5; // ax
  __int16 v6; // dx
  int v7; // esi
  void *v8; // eax
  int v9; // eax
  char *sub_1CEA8; // eax
  LONG v11; // [esp-1Ch] [ebp-50h]
  int v12; // [esp-8h] [ebp-3Ch]
  PANE pane; // [esp+0h] [ebp-34h] BYREF
  _DWORD *v14; // [esp+14h] [ebp-20h]
  int v15; // [esp+18h] [ebp-1Ch]
  int v16; // [esp+1Ch] [ebp-18h]

  v14 = (_DWORD *)a1;
  pane = V_Type6_stru_D8654.pane;
  if ( *(_WORD *)(a1 + 0xC1) )
  {
    pane.x0 = 0xAE;
    pane.y0 = 0x145;
    pane.x1 = 0x147;
    pane.y1 = 0x1D8;
    VFX_pane_wipe(&pane, 0xF2);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&pane);
    v1 = sub_56DA8((int)&V_Type3_stru_10AE70, "INTELSCREEN", 0);
    LOWORD(v1) = word_FFEF2;
    v16 = v1;
    for ( i = 0; i < *(__int16 *)((char *)v14 + 0xC1); ++i )
    {
      v4 = *((_WORD *)&dword_96840 + i + 1);
      v5 = word_9682E[i];
      v6 = word_96838[i];
      v7 = v5;
      v11 = v5;
      v15 = v6;
      v8 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[v4]);
      VFX_shape_transform(&V_Type6_stru_D8654.pane, v8, 0, v11, v6, buffer, 0, 0x8000, 0x8000, 0);
      v12 = v15;
      if ( i == *(_WORD *)((char *)v14 + 0xBF) )
      {
        v9 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v16);
        sub_53EB8((P_Type5)&V_Type6_stru_D8654.pane, v9, 4, v7, v12, v4);
      }
      else
      {
        v3 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v16);
        sub_53EB8((P_Type5)&V_Type6_stru_D8654.pane, v3, 3, v7, v12, v4);
      }
    }
  }
  pane.x0 = 7;
  pane.y0 = 0x145;
  pane.x1 = 0xA5;
  pane.y1 = 0x163;
  VFX_pane_wipe(&pane, 0xF2);
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&pane);
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1A);// 26: "Selected System"
  *(PANE *)&V_Type3_stru_10AE70.z1[0x302E] = pane;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 2, 2, sub_1CEA8, 0, 0xFFFFFFFF, 0xFF, 0);
  *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = pane;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0xD, (const char *)(dword_D3660 + 0x1C), 0, 0xFFFFFFFF, 0xFF, 0);
  if ( *(_WORD *)((char *)v14 + 0x6B) )
  {
    sub_2D218(v14);
  }
}
// 9682E: using guessed type __int16 word_9682E[5];
// 96838: using guessed type __int16 word_96838[4];
// 96840: using guessed type int dword_96840;
// D3660: using guessed type int dword_D3660;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEF2: using guessed type __int16 word_FFEF2;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00032658) --------------------------------------------------------
void *__fastcall sub_32658(int a1)
{
  void *result; // eax
  __int16 i; // dx
  int v4; // ebx

  *(_WORD *)(a1 + 0xC1) = 0;
  *(_WORD *)(a1 + 0xBF) = 0;
  result = memset((char *)&dword_96840 + 2, 0xFFFFFFFF, 0xAu);
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    result = (void *)i;
    if ( i != (unsigned __int8)byte_104BEA
      && i != (unsigned __int8)byte_968DD
      && *(int *)((char *)&dword_A2F75 + 0x1EE * i) != 0xFFFFFFFF
      && byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + i] )
    {
      if ( byte_A3132[0x1EE * (unsigned __int8)byte_968DD + i] )
      {
        LOWORD(result) = *(_WORD *)(a1 + 0xC1);
        v4 = (__int16)result;
        result = (char *)result + 1;
        *(_WORD *)(a1 + 0xC1) = (_WORD)result;
        *((_WORD *)&dword_96840 + v4 + 1) = i;
      }
    }
  }
  return result;
}
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00032714) --------------------------------------------------------
int __fastcall sub_32714(int a1, int a2, __int16 a3)
{
  __int16 v5; // dx
  int result; // eax
  __int16 v7; // cx
  __int16 v8; // bx
  int v9; // edx
  __int16 v10; // ax
  char v11[16]; // [esp+0h] [ebp-20h] BYREF
  int v12; // [esp+10h] [ebp-10h]

  v12 = a2;
  v5 = *(_WORD *)(a1 + 0xC1);
  result = 0;
  if ( v5 > 0 )
  {
    do
    {
      v7 = v12 - word_9682E[(__int16)result];
      v8 = a3 - word_96838[(__int16)result];
      if ( v7 < 0x16 && v7 > (int)0xFFFFFFEA && v8 < 0x16 && v8 > (int)0xFFFFFFEA )
      {
        break;
      }
      ++result;
    }
    while ( (__int16)result < *(__int16 *)(a1 + 0xC1) );
  }
  if ( (__int16)result < *(__int16 *)(a1 + 0xC1) && (_WORD)result != *(_WORD *)(a1 + 0xBF) )
  {
    v9 = *(_DWORD *)(a1 + 0xB7);
    *(_WORD *)(a1 + 0xBF) = result;
    if ( !v9 )
    {
      v10 = sub_44238(
              (int)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA],
              (unsigned __int8)byte_968DD,
              v11,
              HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * (*(int *)(a1 + 0xBD) >> 0x10))));
      sub_32A48(a1, (int)v11, v10, 0, 0xFFFFFFFF);
    }
    return (*(int (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
  }
  return result;
}
// 9682E: using guessed type __int16 word_9682E[5];
// 96838: using guessed type __int16 word_96838[4];
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;

//----- (00032800) --------------------------------------------------------
int __fastcall sub_32800(int a1, int a2)
{
  int v3; // ebx
  char *v4; // edi
  __int16 v6; // ax
  char v7; // bl
  char v8; // cl
  __int16 v9; // ax
  char v10[16]; // [esp+0h] [ebp-30h] BYREF
  char v11[16]; // [esp+10h] [ebp-20h] BYREF
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  unsigned __int8 *v15; // [esp+2Ch] [ebp-4h]

  v14 = (unsigned __int8)byte_104BEA;
  v3 = 0x1EE * (unsigned __int8)byte_968DD;
  v15 = (unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA];
  v4 = &byte_A2F72[v3];
  if ( *(_DWORD *)(a1 + 0xB7) != 0xFFFFFFFF )
  {
    v7 = a2;
    v12 = 0;
    if ( (_BYTE)a2 == 0xE )
    {
      return sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
    }
    byte_101DC4[a2] = 1;
    if ( (unsigned __int8)a2 < 9u )
    {
      if ( (_BYTE)a2 != 7 )
      {
        goto LABEL_14;
      }
    }
    else if ( (unsigned __int8)a2 > 0xBu )
    {
      if ( (_BYTE)a2 == 0xC )
      {
        v12 = dword_D3660;
      }
      goto LABEL_14;
    }
    v12 = *(int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF)) >> 0x10;
LABEL_14:
    v13 = (char)a2;
    v8 = sub_44BCC((int)v4, (__int16 *)(unsigned __int8)byte_104BEA, a2, v12, 0);
    sub_32C14(a1, v8);
    sub_450B0(v15, (unsigned __int8)byte_968DD, v7, v8, v12, 0);
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x41), 0xD, 0, 0);
    v9 = sub_44238(
           (int)v15,
           (unsigned __int8)byte_968DD,
           v11,
           HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF))));
    return sub_32A48(a1, (int)v11, v9, 0xFFFFFFFF, 0xFFFFFFFF);
  }
  if ( (_BYTE)a2 == 1 )
  {
    dword_D3660 = *(int *)((char *)&dword_A315C + 0x1EE * (unsigned __int8)byte_968DD);
    return sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 0);
  }
  else
  {
    sub_450B0((unsigned __int8 *)&byte_A2F72[v3], v14, v4[0x1E9], a2, *(_DWORD *)(v4 + 0x1EA), 0);
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(*(_DWORD *)(a1 + 0xB3) + 0x41), 0xD, 0, 0);
    v4[0x1E9] = 0xE;
    v6 = sub_44238(
           (int)v15,
           (unsigned __int8)byte_968DD,
           v10,
           HIWORD(*(unsigned int *)((char *)&dword_96840 + 2 * *(__int16 *)(a1 + 0xBF))));
    sub_32A48(a1, (int)v10, v6, 0xFFFFFFFF, 0xFFFFFFFF);
    return sub_32BDC(a1, 0xE);
  }
}
// 96840: using guessed type int dword_96840;
// 968DD: using guessed type char byte_968DD;
// A315C: using guessed type int dword_A315C;
// D3660: using guessed type int dword_D3660;

//----- (00032A1C) --------------------------------------------------------
int __fastcall sub_32A1C(int a1)
{
  if ( !*(_DWORD *)(a1 + 0xB7) )
  {
    sub_32A48(a1, 0, 0, 0, 0);
  }
  return (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
}

//----- (00032A48) --------------------------------------------------------
__int64 __fastcall sub_32A48(int a1, int a2, __int16 a3, int a4, int a5)
{
  int v6; // eax
  __int16 v7; // si
  unsigned __int16 v8; // dx
  const char *v9; // eax
  unsigned __int16 v10; // ax
  int v12; // [esp+0h] [ebp-18h]

  word_103F94 = 0;
  if ( a5 )
  {
    qmemcpy(&unk_100340, (const void *)a2, 0xCu);
    qmemcpy((char *)&unk_100340 + 0xC, (const void *)(a2 + 0xC), 3u);
    word_100350 = a3;
  }
  v6 = *(_DWORD *)(a1 + 0xAB);
  v7 = 0;
  v8 = *(_WORD *)(v6 + 0x8CD);
  sub_2ED4C(v6);
  if ( word_100350 > 0 )
  {
    do
    {
      if ( !byte_101DC4[*(int *)((char *)&dword_10033C + v7 + 1) >> 0x18] )
      {
        v9 = (const char *)((int (__fastcall *)(int))loc_32C48)(a1);
        v12 = *(_DWORD *)(a1 + 0xAB);
        v10 = sub_2EA8C(v12, v9, 0xFFFFFFFF, 0);
        sub_2EC50(*(_DWORD *)(a1 + 0xAB), v10, *(int *)((char *)&dword_10033C + v7 + 1) >> 0x18);
      }
      ++v7;
    }
    while ( v7 < word_100350 );
  }
  if ( !a4 )
  {
    sub_2ECDC(*(_DWORD *)(a1 + 0xAB), v8);
  }
  return (unsigned int)(*(int (__cdecl **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xA7) + 0xC))(v12);
}
// 32B38: variable 'v12' is possibly undefined
// 10033C: using guessed type int dword_10033C;
// 100350: using guessed type __int16 word_100350;
// 103F94: using guessed type __int16 word_103F94;

//----- (00032B44) --------------------------------------------------------
__int64 __fastcall sub_32B44(int a1, int a2, __int16 a3)
{
  int v4; // eax
  int v5; // edi
  const char *v6; // eax
  unsigned __int16 v7; // ax
  char *v9; // [esp+0h] [ebp-1Ch]

  v4 = *(_DWORD *)(a1 + 0xAB);
  v5 = 0;
  word_103F94 = 0;
  sub_2ED4C(v4);
  if ( a3 > 0 )
  {
    do
    {
      v9 = (char *)((__int16)v5 + a2);
      v6 = (const char *)((int (__fastcall *)(int, _DWORD, unsigned int, _DWORD))loc_32C48)(a1, *v9, 0xFFFFFFFF, 0);
      v7 = sub_2EA8C(*(_DWORD *)(a1 + 0xAB), v6, 0xFFFFFFFF, 0);
      ++v5;
      sub_2EC50(*(_DWORD *)(a1 + 0xAB), v7, *v9);
    }
    while ( (__int16)v5 < a3 );
  }
  return (unsigned int)(*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xA7) + 0xC))();
}
// 103F94: using guessed type __int16 word_103F94;

//----- (00032BDC) --------------------------------------------------------
__int64 __fastcall sub_32BDC(int a1, char a2)
{
  *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xAB) = ((int (__fastcall *)(int, _DWORD, _DWORD, unsigned int))loc_32C48)(
                                                 a1,
                                                 a2,
                                                 0,
                                                 0xFFFFFFFF);
  return (unsigned int)(*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xA7) + 0xC))();
}

//----- (00032C14) --------------------------------------------------------
__int64 __fastcall sub_32C14(int a1, char a2)
{
  *(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xAB) = ((int (__fastcall *)(int, _DWORD, _DWORD, _DWORD))loc_32C48)(
                                                 a1,
                                                 a2,
                                                 0,
                                                 0);
  return (unsigned int)(*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xAF) + 0xA7) + 0xC))();
}

//----- (00032E84) --------------------------------------------------------
int __fastcall __spoils<> sub_32E84(int a1, int a2, int a3, int a4)
{
  const char *v5; // esi
  int *v6; // edi
  char v7; // al
  char v8; // al
  FILE *v9; // eax
  FILE *v10; // esi
  int result; // eax
  FILE *v12; // eax
  FILE *v13; // esi
  char s[16]; // [esp+0h] [ebp-34h] BYREF
  int v15[9]; // [esp+10h] [ebp-24h] BYREF

  v15[7] = a4;
  if ( (unsigned __int8)byte_968DD >= 0x15u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2D6);
  }
  if ( (unsigned __int8)byte_104BEA >= 0x15u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2D7);
  }
  sprintf(s, "RACE%02d.DIP", *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_968DD));
  v5 = "PLAYER.DIP";
  v6 = v15;
  do
  {
    v7 = *v5;
    *(_BYTE *)v6 = *v5;
    if ( !v7 )
    {
      break;
    }
    v8 = v5[1];
    v5 += 2;
    *((_BYTE *)v6 + 1) = v8;
    v6 = (int *)((char *)v6 + 2);
  }
  while ( v8 );
  if ( *(_WORD *)(a1 + 0xBB) != (unsigned __int8)byte_968DD )
  {
    v9 = sub_1BB10(s, 0);
    v10 = v9;
    if ( !v9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2E4);
    }
    sub_32FD8(a1, v9, 0);
    fclose(v10);
    *(_WORD *)(a1 + 0xBB) = (unsigned __int8)byte_968DD;
  }
  result = *(__int16 *)(a1 + 0xBD);
  if ( result != (unsigned __int8)byte_104BEA )
  {
    v12 = sub_1BB10((const char *)v15, 0);
    v13 = v12;
    if ( !v12 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\negwnd.cpp", 0x2EF);
    }
    sub_32FD8(a1, v12, 0xFFFFFFFF);
    fclose(v13);
    result = (unsigned __int8)byte_104BEA;
    *(_WORD *)(a1 + 0xBD) = (unsigned __int8)byte_104BEA;
  }
  return result;
}
// 968DD: using guessed type char byte_968DD;

//----- (00032FD8) --------------------------------------------------------
int __fastcall sub_32FD8(int a1, FILE *a2, int a3)
{
  __int16 v3; // si
  char *v4; // eax
  __int16 i; // si
  int result; // eax
  char *v7; // eax
  char v8[220]; // [esp+0h] [ebp-DCh] BYREF

  while ( strncmp(v8, "ACTIONS", 7u) )
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  }
  Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  v3 = 0;
  while ( strncmp(v8, "RESPONSES", 9u) )
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
    if ( a3 )
    {
      v4 = (char *)&unk_100744 + 0x80 * v3;
    }
    else
    {
      v4 = (char *)&unk_101DD4 + 0x80 * v3;
    }
    ++v3;
    strncpy(v4, v8, 0x7Fu);
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  }
  Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  for ( i = 0; ; ++i )
  {
    result = strncmp(v8, "END DIPLO", 9u);
    if ( !result )
    {
      break;
    }
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
    if ( a3 )
    {
      v7 = (char *)&unk_100EC4 + 0x80 * i;
    }
    else
    {
      v7 = (char *)&unk_102554 + 0x80 * i;
    }
    strncpy(v7, v8, 0x7Fu);
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(a2, v8);
  }
  return result;
}

//----- (000330DC) --------------------------------------------------------
void __fastcall sub_330DC(T_Type5 *a1, unsigned __int8 *a2)
{
  int v3; // eax
  int v4; // esi
  const char *v5; // ecx
  void *v6; // eax
  int v7; // eax
  char *sub_1CEA8; // eax
  __int16 v9; // di
  int v10; // ecx
  int v11; // eax
  __int16 v12; // edx^2
  char *v13; // eax
  __int16 v14; // di
  int v15; // eax
  int v16; // eax
  char *v17; // eax
  __int16 v18; // di
  int v19; // ecx
  int v20; // eax
  int v21; // esi
  __int16 v22; // di
  LONG v23; // ebx
  void *v24; // eax
  unsigned __int8 v25; // cl
  __int16 v26; // [esp-Ch] [ebp-64h]
  int v27; // [esp-8h] [ebp-60h]
  int v28; // [esp-8h] [ebp-60h]
  int v29; // [esp-8h] [ebp-60h]
  __int16 v30; // [esp-4h] [ebp-5Ch]
  __int16 v31; // [esp-4h] [ebp-5Ch]
  __int16 v32; // [esp-4h] [ebp-5Ch]
  int v33[2]; // [esp+0h] [ebp-58h] BYREF
  int v34; // [esp+8h] [ebp-50h]
  int v35; // [esp+Ch] [ebp-4Ch]
  int v36; // [esp+10h] [ebp-48h]
  unsigned __int8 *v37; // [esp+14h] [ebp-44h]
  int v38; // [esp+18h] [ebp-40h]
  char *v39; // [esp+1Ch] [ebp-3Ch]
  int v40; // [esp+20h] [ebp-38h]
  unsigned __int8 *v41; // [esp+24h] [ebp-34h]
  int v42; // [esp+28h] [ebp-30h]
  int v43; // [esp+2Ch] [ebp-2Ch]
  int v44; // [esp+30h] [ebp-28h]
  int v45; // [esp+34h] [ebp-24h]
  int v46; // [esp+38h] [ebp-20h]
  LONG hotY; // [esp+3Ch] [ebp-1Ch]
  int v48; // [esp+40h] [ebp-18h]
  int v49; // [esp+44h] [ebp-14h]
  int v50; // [esp+48h] [ebp-10h]

  v37 = a2;
  v3 = sub_56DA8((int)&V_Type3_stru_10AE70, "INTELSCREEN", 0);
  LOWORD(v3) = word_FFEF2;
  v50 = v3;
  v41 = a2;
  v4 = 0x1EE * *a2;
  v43 = *a2;
  v36 = 4 * (unsigned __int8)byte_A2F74[v4] + 0x13;
  v33[1] = (__int16)v43;
  sub_53E38(a1, 3, 3, v43);
  v5 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + v4)];
  v35 = (__int16)v36;
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x14, 5, v5, 0, v36, 0xFF, 0);
  v6 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEA0[v43]);
  VFX_shape_transform((PANE *)a1, v6, 0, 0x96, 0x1E, buffer, 0, 0x8000, 0x8000, 0);
  v7 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v50);
  v46 = 0xC8;
  sub_53EB8(a1, v7, 3, 0x96, 0x1E, v43);
  v33[0] = 0;
  sub_40224(a2, 0, v33);
  v44 = 0x14;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x14);
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  v9 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0xC8, 5, sub_1CEA8, 0, v35, 0xFF, 0);
  while ( v9 < v33[0] )
  {
    v10 = v46;
    v30 = v43;
    v27 = v44;
    v11 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8(a1, v11, 5, v10, v27, v30);
    v46 += 8;
    if ( v9 % 9 == 8 )
    {
      v46 = 0xC8;
      v44 += 8;
    }
    ++v9;
  }
  v12 = v36;
  v38 = sub_402E0(v41);
  v49 = 0x118;
  v42 = 0x14;
  v13 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x15);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v14 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x118, 5, v13, 0, v12, 0xFF, 0);
  while ( v14 < v38 )
  {
    v31 = v43;
    v28 = v42;
    v15 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8(a1, v15, 6, v49, v28, v31);
    v49 += 8;
    if ( v14 % 9 == 8 )
    {
      v49 = 0x118;
      v42 += 8;
    }
    ++v14;
  }
  v16 = sub_40664(v41);
  v48 = 0x168;
  v40 = v16 >> 2;
  v45 = 0x14;
  v17 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x16);
  v26 = v36;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1->rect.x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1->rect.y1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1->rect.x2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1->rect.y2;
  v18 = 0;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x168, 5, v17, 0, v26, 0xFF, 0);
  while ( v18 < v40 )
  {
    v19 = v48;
    v32 = v43;
    v29 = v45;
    v20 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
    sub_53EB8(a1, v20, 7, v19, v29, v32);
    v48 += 8;
    if ( v18 % 9 == 8 )
    {
      v48 = 0x168;
      v45 += 8;
    }
    ++v18;
  }
  v21 = 0x1CC;
  v22 = 0;
  v39 = &byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA];
  for ( hotY = 5; v22 < SHIWORD(dword_A3CF2); ++v22 )
  {
    if ( v22 != v43
      && v41[v22 + 0x1C0]
      && !*(int *)((char *)&dword_A2F75 + 0x1EE * v22)
      && (v39[v22 + 0x1C0] || v22 == (unsigned __int8)byte_104BEA) )
    {
      v34 = v22;
      sub_53E38(a1, v21, hotY, v22);
      v25 = v41[v34 + 0x1C0];
      v23 = 0xFFFFFFFF;
      if ( v25 == 3 )
      {
        v23 = 9;
      }
      else if ( v25 == 2 )
      {
        v23 = 8;
      }
      if ( v23 != 0xFFFFFFFF )
      {
        v24 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
        VFX_shape_draw((PANE *)a1, v24, v23, v21, hotY);
      }
      v21 += 0x39;
      if ( v21 > 0x258 )
      {
        v21 = 0x1CC;
        hotY += 0x1B;
      }
    }
  }
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEA0: using guessed type __int16 word_FFEA0[7];
// FFEF2: using guessed type __int16 word_FFEF2;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00033598) --------------------------------------------------------
void __fastcall __spoils<> sub_33598(P_TypeA4 a1)
{
  sub_2C830(&a1->a);
  a1->a.b = (int)off_95F04;
  sub_335F8(a1);
}
// 95F04: using guessed type int (*off_95F04[5])();

//----- (000335B4) --------------------------------------------------------
void *__fastcall sub_335B4(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95EC4);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F04;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F04: using guessed type int (*off_95F04[5])();

//----- (000335F8) --------------------------------------------------------
void __fastcall __spoils<> sub_335F8(P_TypeA4 result)
{
  result->b = 0;
}

//----- (00033604) --------------------------------------------------------
unsigned int __fastcall sub_33604(int a1, __int16 a2, int a3, int a4)
{
  int v5; // eax

  if ( a2 != 1 )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( !*(_DWORD *)(a1 + 0xAB) )
  {
    v5 = sub_56DA8((int)&V_Type3_stru_10AE70, "INTELLIST", 0);
    *(_DWORD *)(a1 + 0xAB) = v5;
    *(_WORD *)(v5 + 0x8C9) = 0x3C;
    sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_330DC);
  }
  return sub_2F424(a1, 1, a3, a4);
}

//----- (00033674) --------------------------------------------------------
void __fastcall sub_33674(int a1)
{
  T_Type5 *v1; // esi
  char *sub_1CEA8; // eax
  const char *v3; // ebp
  unsigned __int8 *v4; // edi
  int v5; // esi
  unsigned __int16 v6; // ax
  __int16 v7; // [esp-Ch] [ebp-60h]
  char *v8; // [esp-4h] [ebp-58h]
  char s[52]; // [esp+0h] [ebp-54h] BYREF
  _DWORD *v10; // [esp+34h] [ebp-20h]
  int v11; // [esp+38h] [ebp-1Ch] BYREF
  int v12; // [esp+3Ch] [ebp-18h]

  v10 = (_DWORD *)a1;
  v1 = (T_Type5 *)(a1 + 4);
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
  sub_53E38(v1, 3, 3, (unsigned __int8)byte_104BEA);
  v8 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1B);// 27: "%s Intelligence"
  sprintf(s, sub_1CEA8, v8);
  v3 = byte_A2F72;
  v7 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v1->a;
  v1 = (T_Type5 *)((char *)v1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v1->a;
  v1 = (T_Type5 *)((char *)v1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v1->a;
  v1 = (T_Type5 *)((char *)v1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v1->a;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v1->rect.x1;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 9, s, 2, v7, 0xFF, 0);
  v4 = (unsigned __int8 *)byte_A2F72;
  v5 = 0;
  sub_2ED4C(*(_DWORD *)((char *)v10 + 0xAB));
  while ( v5 < SHIWORD(dword_A3CF2) )
  {
    if ( v5 == (unsigned __int8)byte_104BEA
      || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v5] && !*(int *)((char *)&dword_A2F75 + 0x1EE * v5) )
    {
      v11 = 0;
      sub_40224(v4, 0, &v11);
      v12 = sub_402E0(v4);
      v6 = sub_2EA8C(*(_DWORD *)((char *)v10 + 0xAB), v3, 0xFFFFFFFF, 0);
      sub_2EC50(*(_DWORD *)((char *)v10 + 0xAB), v6, -(v12 + v11));
    }
    v4 += 0x1EE;
    ++v5;
    v3 += 0x1EE;
  }
  sub_2F1D8(*(_DWORD *)((char *)v10 + 0xAB), (int)sub_10A14);
  sub_2F1E0(*(_DWORD *)((char *)v10 + 0xAB));
  sub_2D218(v10);
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00033830) --------------------------------------------------------
void __fastcall __spoils<> sub_33830(P_TypeA6 a1)
{
  sub_2FC50(&a1->a);
  a1->a.b = (int)off_95EEC;
}
// 95EEC: using guessed type int (*off_95EEC[5])();

//----- (00033840) --------------------------------------------------------
void *__fastcall sub_33840(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95EB0);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95EEC;
    v5 = sub_2FC68(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95EEC: using guessed type int (*off_95EEC[5])();

//----- (00033884) --------------------------------------------------------
int __fastcall sub_33884(_DWORD *a1, int a2, int a3, int a4)
{
  char s[24]; // [esp+0h] [ebp-20h] BYREF
  int v7; // [esp+18h] [ebp-8h]

  v7 = a4;
  sprintf(s, "abil%02d", byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA + 0x19D]);
  return sub_2FCB0(a1, "help.txt", s);
}

//----- (000338DC) --------------------------------------------------------
unsigned int __fastcall sub_338DC(int a1, __int16 a2, int a3, int a4)
{
  int v5; // eax
  char *v6; // esi
  int v7; // edx
  int v8; // eax
  char *sub_1CEA8; // eax
  char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  char *v14; // esi
  char *v15; // edi
  char v16; // al
  char v17; // al
  int v18; // ebx
  char s[100]; // [esp+0h] [ebp-84h] BYREF
  char v21[32]; // [esp+64h] [ebp-20h] BYREF

  v5 = 0x1EE * (unsigned __int8)byte_104BEA;
  v6 = &byte_A2F72[v5];
  if ( !a2 )
  {
    return sub_2FD68(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 1u )
  {
    if ( sub_434E4(&byte_A2F72[v5], 0) == 0xFFFFFFFF )
    {
      *(_BYTE *)(a1 + 0xCCB) = 2;
    }
    else
    {
      sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(**(_DWORD **)(a1 + 0x67) + 0x41), 2, 0, 0);
      v7 = (unsigned __int16)word_968E8[v6[0x19D]] - *(_DWORD *)(v6 + 0x19E);
      if ( v7 == 1 )
      {
        v8 = 0x1C;
      }
      else
      {
        v8 = 0x1D;
      }
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v8);
      sprintf(s, *(const char **)(a1 + 0xCD0), v7, sub_1CEA8);
      v10 = s;
      v11 = *(char **)(a1 + 0xCD0);
      do
      {
        v12 = *v10;
        *v11 = *v10;
        if ( !v12 )
        {
          break;
        }
        v13 = v10[1];
        v10 += 2;
        v11[1] = v13;
        v11 += 2;
      }
      while ( v13 );
      v14 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
      v15 = (char *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4) + 0x20);
      do
      {
        v16 = *v14;
        *v15 = *v14;
        if ( !v16 )
        {
          break;
        }
        v17 = v14[1];
        v14 += 2;
        v15[1] = v17;
        v15 += 2;
      }
      while ( v17 );
    }
    *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
    v18 = *(_DWORD *)(a1 + 0xA7);
    *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
    (*(void (__fastcall **)(int, _DWORD))(v18 + 0xC))(a1, 0);
    return 0;
  }
  else
  {
    if ( a2 != 0x32 || a3 != 1 )
    {
      return sub_2FD68(a1, a2, a3, a4);
    }
    sub_434E4(&byte_A2F72[v5], 1);
    sprintf(v21, "abres%02d", v6[0x19D]);
    sub_2FCB0((_DWORD *)a1, "help.txt", v21);
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    return 0;
  }
}
// 968E8: using guessed type __int16 word_968E8[21];

//----- (00033A68) --------------------------------------------------------
void __fastcall sub_33A68(int a1)
{
  void *v2; // eax
  void *v3; // eax
  LONG v4; // [esp-Ch] [ebp-18h]

  sub_30774(a1);
  v2 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int8)byte_104BEA);
  VFX_shape_draw((PANE *)(a1 + 4), v2, 0, 0xFA, 0x41);
  v4 = (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  v3 = (void *)sub_1B084((unsigned int)dword_12FC20, 0x21);
  VFX_shape_draw((PANE *)(a1 + 4), v3, v4, 0xFA, 0x41);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00033AF0) --------------------------------------------------------
__int16 __fastcall sub_33AF0(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4)
{
  int v5; // ebx
  int i; // eax
  unsigned __int16 v7; // bx
  unsigned __int8 *v8; // ebx
  signed int v9; // ebp
  unsigned int v10; // eax
  int v11; // ebx
  int v12; // ecx
  int v13; // edx
  char v14; // al
  int v15; // eax
  unsigned __int8 v16; // al
  unsigned __int16 v17; // bx
  int v18; // eax
  __int16 v19; // ax
  int v21; // [esp+0h] [ebp-1Ch]
  int v22; // [esp+4h] [ebp-18h]
  int v23; // [esp+8h] [ebp-14h]

  if ( *(_DWORD *)(a1 + 0x10) && a2 != *(_WORD *)(a1 + 0x14) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x41);
  }
  v5 = dword_1045B4;
  *(_DWORD *)(a1 + 0x10) = a4;
  if ( !v5 )
  {
    sub_33D30();
  }
  if ( a2 >= 5u )
  {
    *(_WORD *)(a1 + 0x14) = 4;
  }
  else
  {
    *(_WORD *)(a1 + 0x14) = a2;
  }
  *(_WORD *)(a1 + 0x18) = 0;
  for ( i = 0; i < 0xF; ++i )
  {
    v7 = (unsigned __int8)byte_104604[0xF * *(unsigned __int16 *)(a1 + 0x14) + i] + *(_WORD *)(a1 + 0x18);
    *(_WORD *)(a1 + 0x18) = v7;
  }
  if ( v7 > 0x64u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x52);
  }
  *(_WORD *)(a1 + 0x1A) = *(_WORD *)(a1 + 0x18) + 0xA;
  if ( a3 >= 0xBu )
  {
    *(_WORD *)(a1 + 0x16) = 2;
  }
  else
  {
    *(_WORD *)(a1 + 0x16) = a3;
  }
  v8 = (unsigned __int8 *)&unk_104650 + 4 * *(unsigned __int16 *)(a1 + 0x16);
  v9 = 0x7FFF * (unsigned int)*v8 / 0x64;
  v23 = 0x7FFF * (unsigned int)v8[1] / 0x64 + v9;
  v21 = 0x7FFF * (unsigned int)v8[2] / 0x64 + v23;
  v10 = 0x7FFF * (unsigned int)v8[3] / 0x64;
  v11 = 0;
  v12 = 0;
  v22 = v10 + v21;
  v13 = 0;
  while ( v11 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    *(_BYTE *)(v13 + *(_DWORD *)(a1 + 0x10) + 1) = 0xFF;
    *(_WORD *)(v13 + *(_DWORD *)(a1 + 0x10) + 2) = 0;
    v14 = 1;
    if ( v11 < *(unsigned __int16 *)(a1 + 0x18) )
    {
      v15 = rand();
      if ( v15 >= v9 )
      {
        ++v12;
        if ( v15 >= v23 )
        {
          if ( v15 >= v21 )
          {
            if ( v15 >= v22 )
            {
              v14 = 1;
            }
            else
            {
              v14 = 4;
            }
          }
          else
          {
            v14 = 3;
          }
        }
        else
        {
          v14 = 2;
        }
      }
      else
      {
        v14 = 0;
      }
    }
    v13 += 4;
    ++v11;
    *(_BYTE *)(v13 + *(_DWORD *)(a1 + 0x10) - 4) = v14;
  }
  *(_BYTE *)(a1 + 0x66) = 0;
  v16 = *(_BYTE *)(a1 + 0x66);
  *(_WORD *)(a1 + 0x50) = v16;
  *(_WORD *)(a1 + 0x4E) = v16;
  *(_WORD *)(a1 + 0x4C) = v16;
  *(_WORD *)(a1 + 0x48) = v16;
  *(_WORD *)(a1 + 0x46) = v16;
  *(_WORD *)(a1 + 0x44) = v16;
  *(_WORD *)(a1 + 0x42) = v16;
  if ( !(rand() % 7) )
  {
    v17 = *(_WORD *)(a1 + 0x18);
    v18 = rand();
    *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * (v18 % v17)) |= 8u;
    *(_BYTE *)(a1 + 0x66) |= 2u;
  }
  *(_WORD *)(a1 + 0x52) = 0xFFFF;
  *(_BYTE *)(a1 + 0x54) = 0xFF;
  v19 = v12 / 3 + 5;
  *(_WORD *)(a1 + 0x55) = v19;
  *(_WORD *)(a1 + 0x4A) = v19;
  *(_BYTE *)(a1 + 0x57) = 0xFF;
  sub_34E70(a1);
  *(_DWORD *)(a1 + 0x5E) = 0;
  return *(_WORD *)(a1 + 0x1A);
}
// 1045B4: using guessed type int dword_1045B4;

//----- (00033D30) --------------------------------------------------------
FILE *sub_33D30()
{
  FILE *result; // eax
  FILE *v1; // esi
  unsigned int v2; // edi
  int v3; // ebp
  int v4; // edi
  int v5; // edx
  int v6; // ebp
  int i; // edi
  int v8; // edx
  int v9; // ebp
  int j; // edi
  int v11; // edx
  unsigned int v12; // ebp
  signed int v13; // edx
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // edx
  const char *v17; // ebx
  unsigned int v18; // kr04_4
  char v19[200]; // [esp+0h] [ebp-104h] BYREF
  int v20; // [esp+C8h] [ebp-3Ch] BYREF
  int v21; // [esp+CCh] [ebp-38h] BYREF
  int v22; // [esp+D0h] [ebp-34h] BYREF
  char v23; // [esp+D4h] [ebp-30h] BYREF
  char v24; // [esp+D8h] [ebp-2Ch] BYREF
  int v25; // [esp+DCh] [ebp-28h] BYREF
  char v26; // [esp+E0h] [ebp-24h] BYREF
  int *v27; // [esp+E8h] [ebp-1Ch]

  result = sub_1BB10("planitem.txt", 0);
  v1 = result;
  if ( result )
  {
    v2 = 0;
    do
    {
      fgets(v19, 0xC3, v1);
      if ( v19[0] == 0x23 )
      {
        v2 = 0xFFFFFFFF;
      }
    }
    while ( !v2 );
    v3 = 4;
    fscanf(v1, "%d", &v20);
    v4 = 0;
    dword_9684C = v20;
    do
    {
      v5 = 4 * v4;
      do
      {
        fscanf(v1, "%d", &v20);
        byte_10464F[++v5] = v20;
      }
      while ( v5 != v3 );
      ++v4;
      v3 += 4;
    }
    while ( v4 < 0xB );
    v6 = 0xF;
    for ( i = 0; i < 5; ++i )
    {
      v8 = 0xF * i;
      do
      {
        fscanf(v1, "%d", &v20);
        *((_BYTE *)&dword_1045B4 + ++v8 + 3) = v20;
      }
      while ( v8 != v6 );
      v6 += 0xF;
    }
    v9 = 0xF;
    for ( j = 0; j < 5; ++j )
    {
      v11 = 0xF * j;
      do
      {
        fscanf(v1, "%d", &v20);
        byte_104603[++v11] = v20;
      }
      while ( v11 != v9 );
      v9 += 0xF;
    }
    fscanf(v1, "%d %d %d", &v20, &v21, &v22);
    if ( v20 != 0x27 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0xE1);
    }
    word_103F98[0] = v21;
    LOWORD(dword_103F9A[0]) = v22;
    if ( (unsigned __int16)v21 + (unsigned __int16)v22 > 0x27 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0xE6);
    }
    v12 = 0;
    v27 = &dword_103F9A[3];
    do
    {
      v17 = (const char *)v27;
      fscanf(v1, "%s %d %d %d %d %d %d %d", v27, &v20, &v21, &v22, &v23, &v24, &v25, &v26);
      v13 = 0;
      v18 = strlen(v17) + 1;
      v15 = v18 - 1;
      v14 = v12;
      if ( (int)(v18 - 1) > 0 )
      {
        do
        {
          if ( byte_103FA6[v14] == 0x5E )
          {
            byte_103FA6[v14] = 0x20;
          }
          ++v13;
          ++v14;
        }
        while ( v13 < (int)(v18 - 1) );
      }
      BYTE2(dword_103F9A[v12 / 4]) = v20;
      word_103FA2[v12 / 2] = 0;
      HIBYTE(dword_103F9A[v12 / 4]) = v21;
      byte_103F9E[v12] = v22;
      byte_103F9F[v12] = v23;
      byte_103FA0[v12] = v24;
      word_103FA4[v12 / 2] = v25;
      v16 = 0;
      byte_103FA1[v12] = v26;
      do
      {
        fscanf(v1, "%d", &v20);
        if ( v20 == 0xFF )
        {
          break;
        }
        LOWORD(v15) = word_103FA2[v12 / 2];
        v15 |= 1 << v20;
        ++v16;
        word_103FA2[v12 / 2] = v15;
      }
      while ( v16 < 8 );
      v12 += 0x28;
      v27 += 0xA;
    }
    while ( v12 != 0x618 );
    result = (FILE *)fclose(v1);
  }
  dword_1045B4 = 0xFFFFFFFF;
  return result;
}
// 9684C: using guessed type int dword_9684C;
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 103FA4: using guessed type __int16 word_103FA4[];
// 1045B4: using guessed type int dword_1045B4;
// 33D30: using guessed type char var_104[200];

//----- (0003407C) --------------------------------------------------------
int __fastcall sub_3407C(int a1)
{
  int v2; // ebp
  _BYTE *v3; // eax
  unsigned int v4; // kr00_4
  unsigned __int16 v5; // bx
  int v7; // [esp+0h] [ebp-2Ch]
  int v8; // [esp+4h] [ebp-28h]
  unsigned __int16 v9; // [esp+8h] [ebp-24h]
  unsigned __int16 v10; // [esp+Ch] [ebp-20h]
  unsigned __int16 v11; // [esp+10h] [ebp-1Ch]

  v2 = 0;
  v8 = 0;
  v7 = 0;
  while ( *(unsigned __int16 *)(a1 + 0x1A) > v8 && v2 < 0x64 )
  {
    v3 = (_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10));
    if ( (*v3 & 8) == 0
      && (*v3 || byte_A310F[0x1EE * *(unsigned __int8 *)(a1 + 0x57)] == 2)
      && *(_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10) + 1) == 0xFF )
    {
      v4 = sub_35A00(a1, v8);
      v11 = sub_35968(a1, HIWORD(v4) - 1, (unsigned __int16)v4);
      v9 = sub_35968(a1, HIWORD(v4) + 1, (unsigned __int16)v4);
      v10 = sub_35968(a1, HIWORD(v4), (unsigned __int16)v4 - 1);
      v5 = sub_35968(a1, HIWORD(v4), (unsigned __int16)v4 + 1);
      ++v2;
      if ( (v11 == 0xFFFF || (*(_WORD *)(4 * v11 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
        && (v9 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v9 + 2) & 1) == 0)
        && (v10 == 0xFFFF || (*(_WORD *)(4 * v10 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
        && (v5 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v5 + 2) & 1) == 0) )
      {
        --v2;
      }
    }
    v7 += 4;
    ++v8;
  }
  return v2;
}

//----- (0003420C) --------------------------------------------------------
void __fastcall sub_3420C(int a1)
{
  int v2; // ebp
  _BYTE *v3; // esi
  int v4; // eax
  unsigned int v5; // kr00_4
  unsigned __int16 v6; // bx
  int v7; // [esp+0h] [ebp-2Ch]
  int v8; // [esp+4h] [ebp-28h]
  unsigned __int16 v9; // [esp+8h] [ebp-24h]
  unsigned __int16 v10; // [esp+Ch] [ebp-20h]
  unsigned __int16 v11; // [esp+10h] [ebp-1Ch]

  v2 = 0;
  v7 = 0;
  v8 = 0;
  while ( *(unsigned __int16 *)(a1 + 0x1A) > v7 && v2 < 0x64 )
  {
    v3 = (_BYTE *)(v8 + *(_DWORD *)(a1 + 0x10));
    v4 = *v3 & 8;
    if ( (*v3 & 8) == 0 )
    {
      LOBYTE(v4) = *v3;
      if ( !v4 && v3[1] == 0xFF )
      {
        v5 = sub_35A00(a1, v7);
        v10 = sub_35968(a1, HIWORD(v5) - 1, (unsigned __int16)v5);
        v11 = sub_35968(a1, HIWORD(v5) + 1, (unsigned __int16)v5);
        v9 = sub_35968(a1, HIWORD(v5), (unsigned __int16)v5 - 1);
        v6 = sub_35968(a1, HIWORD(v5), (unsigned __int16)v5 + 1);
        ++v2;
        if ( (v10 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v10 + 2) & 1) == 0)
          && (v11 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v11 + 2) & 1) == 0)
          && (v9 == 0xFFFF || (*(_WORD *)(4 * v9 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
          && (v6 == 0xFFFF || (*(_WORD *)(4 * v6 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0) )
        {
          --v2;
        }
      }
    }
    v8 += 4;
    ++v7;
  }
  JUMPOUT(0x341FF);
}
// 3423F: control flows out of bounds to 341FF

//----- (00034368) --------------------------------------------------------
unsigned int __fastcall sub_34368(int a1, unsigned __int8 a2, unsigned __int16 a3)
{
  unsigned int v4; // ebp
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  _BYTE *v8; // eax
  int v9; // eax
  unsigned int v10; // eax
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // bx
  int v14; // [esp+0h] [ebp-30h]
  int v15; // [esp+8h] [ebp-28h]
  unsigned __int16 v16; // [esp+Ch] [ebp-24h]
  unsigned __int16 v17; // [esp+14h] [ebp-1Ch]
  unsigned __int16 v18; // [esp+18h] [ebp-18h]
  unsigned __int16 v19; // [esp+1Ch] [ebp-14h]

  v4 = 0xFFFFFFFF;
  v5 = 0xFFFFFFFF;
  if ( *(unsigned __int8 *)(a1 + 0x57) == 0xFF && a2 != 5 )
  {
    return 0;
  }
  if ( a2 < 0x27u )
  {
    v4 = 0;
    v6 = (unsigned __int8)byte_103FA1[0x28 * a2];
    if ( v6 == 0xFF
      || (unsigned __int16)word_105258 > v6
      && ((1 << *(_BYTE *)(a1 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * v6) >> 0x18)) != 0 )
    {
      v19 = *(_WORD *)(a1 + 0x42) - *(_WORD *)(a1 + 0x4C);
      if ( *(_BYTE *)(a1 + 0x54) != 0xFF )
      {
        v19 += byte_103FA0[0x28 * *(unsigned __int8 *)(a1 + 0x54)];
      }
      if ( v19 >= *(int *)((char *)&dword_103F9A[0xA * a2] + 3) >> 0x18 )
      {
        v4 = 0xFFFFFFFF;
      }
      if ( v4 == 0xFFFFFFFF && a2 == 0x17 )
      {
        v4 = sub_362E0(a1);
      }
    }
    if ( a2 == 5 )
    {
      v4 = 0xFFFFFFFF;
    }
  }
  if ( a3 < *(_WORD *)(a1 + 0x1A) )
  {
    v5 = 0;
    if ( a2 < 0x27u && ((word_103FA2[0x14 * a2] & 1) != 0 || byte_A310F[0x1EE * *(unsigned __int8 *)(a1 + 0x57)] == 2) )
    {
      v5 = 0xFFFFFFFF;
    }
    v14 = 4 * a3;
    v7 = *(unsigned __int8 *)(v14 + *(_DWORD *)(a1 + 0x10));
    if ( *(_BYTE *)(v14 + *(_DWORD *)(a1 + 0x10)) || a2 == 0xFF || (LOBYTE(v7) = a2, (word_103FA2[0x14 * v7] & 2) != 0) )
    {
      v5 = 0xFFFFFFFF;
    }
    if ( a2 != 0xFF && a2 <= 0x1Eu && a3 < *(_WORD *)(a1 + 0x18) != a2 < (int)(unsigned __int16)word_103F98[0] )
    {
      v5 = 0;
    }
    if ( a2 != 0xFF && ((*(_BYTE *)(4 * a3 + *(_DWORD *)(a1 + 0x10)) & 8) != 0) != (a2 == 0x26) )
    {
      v5 = 0;
    }
    if ( a2 == 0x24 )
    {
      v8 = (_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * a3);
      if ( *v8 || v8[1] != 0xFF )
      {
        v5 = 0;
      }
    }
    if ( a2 == 0x23 )
    {
      v9 = *(_DWORD *)(a1 + 0x10) + 4 * a3;
      if ( (*(_WORD *)(v9 + 2) & 1) == 0 || *(_BYTE *)(v9 + 1) == 0x17 || (*(_WORD *)(v9 + 2) & 2) != 0 )
      {
        v5 = 0;
      }
    }
    if ( a3 < *(_WORD *)(a1 + 0x18)
      && (*(_WORD *)(4 * a3 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0
      && a2 != 5
      && a2 != 0x23 )
    {
      v10 = sub_35A00(a1, a3);
      v11 = v10;
      v15 = HIWORD(v10);
      v16 = sub_35968(a1, HIWORD(v10) - 1, (unsigned __int16)v10);
      v18 = sub_35968(a1, v15 + 1, v11);
      v17 = sub_35968(a1, v15, v11 - 1);
      v12 = sub_35968(a1, v15, v11 + 1);
      if ( (v16 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v16 + 2) & 1) == 0)
        && (v18 == 0xFFFF || (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v18 + 2) & 1) == 0)
        && (v17 == 0xFFFF || (*(_WORD *)(4 * v17 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0)
        && (v12 == 0xFFFF || (*(_WORD *)(4 * v12 + *(_DWORD *)(a1 + 0x10) + 2) & 1) == 0) )
      {
        v5 = 0;
      }
    }
  }
  if ( v4 && v5 )
  {
    return 0xFFFFFFFF;
  }
  else
  {
    return 0;
  }
}
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 10529F: using guessed type int dword_10529F;

//----- (00034774) --------------------------------------------------------
#error "347AF: call analysis failed (funcsize=25)"

//----- (000347CC) --------------------------------------------------------
int __fastcall sub_347CC(int a1, unsigned __int8 a2)
{
  unsigned __int8 v3; // cl
  int v4; // ebp
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  signed int v8; // edi
  int v9; // ecx
  int v10; // esi
  int v11; // eax
  char v12; // bl
  char v13; // bl
  char v14; // bl
  __int16 v16[101]; // [esp+0h] [ebp-F6h]
  int v17; // [esp+CAh] [ebp-2Ch]
  int v18; // [esp+CEh] [ebp-28h]
  int v19; // [esp+D2h] [ebp-24h]
  int v20; // [esp+D6h] [ebp-20h]
  int v21; // [esp+DAh] [ebp-1Ch]
  unsigned __int8 v22; // [esp+DEh] [ebp-18h]

  v22 = a2;
  v19 = 0xFFFF;
  v3 = *(_BYTE *)(a1 + 0x57);
  v4 = 0;
  v5 = *(int *)((char *)&dword_10529F + 0x4B * (unsigned __int16)word_105258 - 0x4B) >> 0x18;
  v18 = 0;
  if ( ((1 << v3) & v5) != 0 && sub_40664(&byte_A2F72[0x1EE * v3]) == (unsigned __int16)word_105258 )
  {
    v18 = 0xFFFFFFFF;
  }
  v6 = 0;
  v7 = 0;
  v21 = 0;
  while ( v6 < *(unsigned __int16 *)(a1 + 0x1A) && v7 < 0x64 )
  {
    if ( *(_BYTE *)(v21 + *(_DWORD *)(a1 + 0x10) + 1) == 0xFF )
    {
      if ( sub_34368(a1, v22, v6) )
      {
        ++v7;
        ++v4;
        v16[v7] = v6;
      }
    }
    ++v6;
    v21 += 4;
  }
  if ( v4 )
  {
    v8 = 0xFFFFFFFF;
    v9 = 0;
    v20 = 0xFFFFFFFF;
    if ( v4 > 0 )
    {
      v17 = *(_DWORD *)(a1 + 0x10);
      v10 = 0;
      do
      {
        switch ( *(_BYTE *)(v17 + 4 * (unsigned __int16)v16[v10 + 1]) )
        {
          case 2:
            v11 = 0;
            if ( *(int *)((char *)&word_103F98[0x14 * v22] + 1) >> 0x18 > 0 )
            {
              v12 = BYTE2(dword_103F9A[0xA * v22]);
              v11 = 3;
              if ( v12 < SHIBYTE(dword_103F9A[0xA * v22]) || v12 < byte_103F9E[0x28 * v22] )
              {
                v11 = 2;
              }
            }
            break;
          case 3:
            v11 = 0;
            if ( *(int *)((char *)&dword_103F9A[0xA * v22] + 1) >> 0x18 > 0 )
            {
              v13 = byte_103F9E[0x28 * v22];
              v11 = 3;
              if ( v13 < SBYTE2(dword_103F9A[0xA * v22]) || v13 < SHIBYTE(dword_103F9A[0xA * v22]) )
              {
                v11 = 2;
              }
            }
            break;
          case 4:
            if ( v18 )
            {
              goto LABEL_24;
            }
            v11 = 0;
            if ( dword_103F9A[0xA * v22] >> 0x18 > 0 )
            {
              v14 = HIBYTE(dword_103F9A[0xA * v22]);
              v11 = 3;
              if ( v14 < SBYTE2(dword_103F9A[0xA * v22]) || v14 < byte_103F9E[0x28 * v22] )
              {
                v11 = 2;
              }
            }
            break;
          default:
LABEL_24:
            v11 = 1;
            break;
        }
        if ( v11 > v8 )
        {
          v20 = v9;
          v8 = v11;
        }
        ++v9;
        ++v10;
      }
      while ( v9 < v4 );
    }
    if ( v20 >= 0 )
    {
      return (unsigned __int16)v16[v20 + 1];
    }
  }
  return v19;
}
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 10529F: using guessed type int dword_10529F;

//----- (00034A44) --------------------------------------------------------
unsigned __int16 __fastcall sub_34A44(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  unsigned __int16 result; // ax
  int v6; // [esp+0h] [ebp-14h]
  int v7; // [esp+4h] [ebp-10h]

  *a2 = 0;
  *a3 = 0;
  v6 = 0;
  v7 = 0;
  *a4 = 0;
  while ( 1 )
  {
    result = *(_WORD *)(a1 + 0x1A);
    if ( result <= v6 )
    {
      return result;
    }
    if ( *(_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10) + 1) == 0xFF && sub_34368(a1, 0, v6) )
    {
      switch ( *(_BYTE *)(v7 + *(_DWORD *)(a1 + 0x10)) )
      {
        case 2:
          ++*a3;
          break;
        case 3:
          goto LABEL_3;
        case 4:
          ++*a2;
          break;
        default:
          ++*a2;
          ++*a3;
LABEL_3:
          ++*a4;
          break;
      }
    }
    v7 += 4;
    ++v6;
  }
}

//----- (00034AE4) --------------------------------------------------------
int __fastcall sub_34AE4(int a1, unsigned __int8 a2, int a3)
{
  int v5; // ebx

  v5 = sub_347CC(a1, a2);
  sub_34774(a1, a2, v5, a3);
  return v5;
}

//----- (00034B0C) --------------------------------------------------------
unsigned int __fastcall sub_34B0C(__int64 a1, unsigned __int8 a2, unsigned __int8 a3)
{
  int v3; // esi
  unsigned int v4; // ebp
  int v5; // edi
  unsigned __int8 v7; // al
  int v8; // edx
  char *v9; // eax
  int v10; // eax
  unsigned __int8 v11; // dl
  int v12; // eax
  __int64 v13; // rax
  __int64 v14; // [esp-4h] [ebp-34h] BYREF
  _DWORD *v15; // [esp+4h] [ebp-2Ch] BYREF
  _DWORD *v16; // [esp+8h] [ebp-28h] BYREF
  _DWORD *v17; // [esp+Ch] [ebp-24h] BYREF
  int v18; // [esp+10h] [ebp-20h] BYREF
  int v19; // [esp+14h] [ebp-1Ch] BYREF
  int v20; // [esp+18h] [ebp-18h]
  int v21; // [esp+1Ch] [ebp-14h]
  unsigned __int8 v22; // [esp+20h] [ebp-10h]

  v21 = HIDWORD(a1);
  v3 = a1;
  v22 = a2;
  v4 = 0;
  if ( WORD2(a1) == 0xFFFF && ((word_103FA2[0x14 * a2] & 2) == 0 || a3 != 2) )
  {
    goto LABEL_42;
  }
  v20 = ((unsigned __int16)v21 < *(_WORD *)(a1 + 0x18)) - 1;
  v5 = *(_DWORD *)(a1 + 0x10);
  if ( (unsigned __int16)v21 != 0xFFFF )
  {
    v5 += 4 * (unsigned __int16)v21;
  }
  if ( !a3 )
  {
    if ( *(_BYTE *)(v5 + 1) == 0xFF && v22 < 0x27u )
    {
      BYTE4(a1) = v22;
      if ( *(unsigned __int16 *)(a1 + 0x42) - *(unsigned __int16 *)(a1 + 0x4C) >= *(int *)((char *)&dword_103F9A[0xA * v22]
                                                                                         + 3) >> 0x18
        && v22 >= (int)(unsigned __int16)word_103F98[0] == v20 )
      {
        *(_BYTE *)(v5 + 1) = v22;
        HIDWORD(a1) = BYTE4(a1);
        *(_WORD *)(v5 + 2) = 1;
        v4 = 0xFFFFFFFF;
        if ( (word_103FA2[0x14 * BYTE4(a1)] & 4) != 0 )
        {
          LODWORD(v14) = &v16;
          sub_366C8(a1, &v15, (_DWORD *)&v14 + 1, v14, v15, v16, v17);
          if ( v16 )
          {
            *(_BYTE *)(v5 + 3) = 0;
            *(_WORD *)(v5 + 2) |= (_WORD)v16 << 8;
            sub_34E70(v3);
            return 0xFFFFFFFF;
          }
        }
      }
    }
    goto LABEL_42;
  }
  if ( a3 > 1u )
  {
    if ( a3 > 3u )
    {
      sub_34E70(a1);
      return 0;
    }
    if ( a3 == 3
      || (word_103FA2[0x14 * v22] & 2) != 0
      || sub_34368(a1, v22, v21) && ((*(_WORD *)(v5 + 2) & 1) == 0 || v22 == 0x23 && (*(_WORD *)(v5 + 2) & 2) == 0) )
    {
      v8 = *(unsigned __int16 *)(v3 + 0x52);
      if ( (unsigned __int16)v8 != 0xFFFF )
      {
        if ( *(_BYTE *)(*(_DWORD *)(v3 + 0x10) + 4 * v8 + 1) == 0x17 )
        {
          v9 = sub_35A70(v3, v8);
          sub_49940((int)v9);
        }
        v10 = *(_DWORD *)(v3 + 0x10) + 4 * *(unsigned __int16 *)(v3 + 0x52);
        if ( (*(_WORD *)(v10 + 2) & 1) == 0 )
        {
          *(_BYTE *)(v10 + 1) = 0xFF;
        }
      }
      v11 = v22;
      v12 = 5 * v22;
      *(_WORD *)(v3 + 0x52) = 0xFFFF;
      if ( (word_103FA2[4 * v12] & 2) == 0 )
      {
        *(_WORD *)(v3 + 0x52) = v21;
        if ( v11 != 0x23 )
        {
          *(_BYTE *)(v5 + 1) = v11;
        }
      }
      HIDWORD(v13) = v22;
      *(_BYTE *)(v3 + 0x54) = v22;
      if ( (word_103FA2[0x14 * HIDWORD(v13)] & 4) != 0 )
      {
        LODWORD(v14) = &v19;
        LODWORD(v13) = v3;
        sub_366C8(v13, &v18, &v17, v14, v15, v16, v17);
        if ( v19 )
        {
          *(_BYTE *)(v5 + 3) = 0;
          *(_WORD *)(v5 + 2) |= (_WORD)v19 << 8;
        }
      }
      sub_34E70(v3);
      return 0xFFFFFFFF;
    }
LABEL_42:
    sub_34E70(v3);
    return v4;
  }
  v7 = *(_BYTE *)(v5 + 1);
  if ( v7 == 0xFF
    || *(int *)((char *)&dword_103F9A[0xA * v7] + 2) >> 0x18 > *(unsigned __int16 *)(v3 + 0x4A)
                                                             - *(unsigned __int16 *)(v3 + 0x42)
    && (*(_WORD *)(v5 + 2) & 1) != 0 )
  {
    goto LABEL_42;
  }
  *(_BYTE *)(v5 + 1) = 0xFF;
  *(_WORD *)(v5 + 2) = 0;
  if ( (_WORD)v21 == *(_WORD *)(v3 + 0x52) )
  {
    *(_WORD *)(v3 + 0x52) = 0xFFFF;
    *(_BYTE *)(v3 + 0x54) = 0xFF;
  }
  sub_34E70(v3);
  return 0xFFFFFFFF;
}
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];

//----- (00034E70) --------------------------------------------------------
unsigned __int16 __fastcall sub_34E70(int a1)
{
  int v2; // ecx
  int v3; // ebp
  int v4; // esi
  unsigned __int8 v5; // dl
  char *v6; // eax
  char v7; // dh
  int v8; // edi
  char v9; // dh
  int v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // eax
  char v14; // dl
  int v15; // eax
  double v16; // st7
  unsigned __int16 v17; // dx
  unsigned __int16 result; // ax
  unsigned __int16 v19; // cx
  char v20; // [esp+10h] [ebp-48h]
  __int16 v21; // [esp+14h] [ebp-44h]
  char v22; // [esp+18h] [ebp-40h]
  __int16 v23; // [esp+1Ch] [ebp-3Ch]
  __int16 v24; // [esp+20h] [ebp-38h]
  __int16 v25; // [esp+24h] [ebp-34h]
  int v26; // [esp+28h] [ebp-30h]
  int v27; // [esp+2Ch] [ebp-2Ch]
  int v28; // [esp+30h] [ebp-28h]
  int v29; // [esp+30h] [ebp-28h]
  int v30; // [esp+34h] [ebp-24h]

  v2 = 0;
  v3 = 0;
  v27 = 0;
  v26 = 0;
  v28 = 0;
  v21 = 0;
  v25 = 0;
  v23 = 0;
  v24 = 0;
  v20 = 0;
  v22 = 0;
  v30 = *(unsigned __int16 *)(a1 + 0x55);
  while ( v3 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v4 = v2 + *(_DWORD *)(a1 + 0x10);
    v5 = *(_BYTE *)(v4 + 1);
    v6 = (char *)&dword_103F9A[0xA * v5] + 2;
    if ( v5 == 0xFF )
    {
      if ( v3 < *(unsigned __int16 *)(a1 + 0x18) )
      {
        if ( (*(_BYTE *)v4 & 8) == 0 )
        {
          ++v25;
          if ( !*(_BYTE *)v4 )
          {
            ++v23;
          }
        }
      }
      else
      {
        ++v24;
      }
    }
    else
    {
      if ( (*(_WORD *)(v4 + 2) & 1) != 0 )
      {
        if ( *v6 )
        {
          v27 += *v6;
          if ( *(_BYTE *)v4 == 2 )
          {
            ++v27;
          }
        }
        v7 = v6[2];
        if ( v7 )
        {
          v8 = v7 + v28;
          v28 = v8;
          if ( *(_BYTE *)(v2 + *(_DWORD *)(a1 + 0x10)) == 3 )
          {
            v28 = v8 + 1;
          }
        }
        v9 = v6[1];
        if ( v9 )
        {
          v10 = v9 + v26;
          v26 = v10;
          if ( *(_BYTE *)(v2 + *(_DWORD *)(a1 + 0x10)) == 4 )
          {
            v26 = v10 + 1;
          }
        }
        if ( (*((_WORD *)v6 + 3) & 4) == 0 || v5 == 0x11 )
        {
          if ( (*((_WORD *)v6 + 3) & 8) != 0 || v5 == 0x11 )
          {
            ++v22;
          }
        }
        else
        {
          ++v20;
        }
        v30 += *(int *)v6 >> 0x18;
      }
      if ( v5 != 0x17 && (*(_WORD *)(v2 + *(_DWORD *)(a1 + 0x10) + 2) & 2) == 0 && (word_103FA2[0x14 * v5] & 0x40) == 0 )
      {
        v21 += v6[4];
      }
    }
    v2 += 4;
    ++v3;
  }
  v11 = (unsigned __int16)sub_35930(a1, 0xC);
  if ( v11 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v11 + 2) & 1) != 0 )
  {
    v27 += v27 >> 1;
  }
  v12 = (unsigned __int16)sub_35930(a1, 0xD);
  if ( v12 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v12 + 2) & 1) != 0 )
  {
    v28 += v28 >> 1;
  }
  v13 = (unsigned __int16)sub_35930(a1, 0xE);
  if ( v13 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v13 + 2) & 1) != 0 )
  {
    v26 += v26 >> 1;
  }
  if ( *(_BYTE *)(a1 + 0x54) != 0xFF )
  {
    v14 = *(_BYTE *)(a1 + 0x54);
    v15 = v27 >> 2;
    switch ( v14 )
    {
      case '!':
        v28 += v15;
        break;
      case '"':
        LOWORD(v26) = v15 + v26;
        break;
      case '#':
        v21 += SHIBYTE(dword_104515);
        break;
    }
  }
  if ( v27 )
  {
    v27 = (int)pow((double)(v27 + 1), 0.85);
  }
  if ( v28 )
  {
    v28 = (int)pow((double)(v28 + 1), 0.85);
  }
  v29 = v28 - ((int)*(unsigned __int16 *)(a1 + 0x42) >> 2);
  if ( v29 < 0 )
  {
    LOWORD(v29) = 0;
  }
  *(_WORD *)(a1 + 0x1C) = v25;
  *(_WORD *)(a1 + 0x20) = v23;
  *(_WORD *)(a1 + 0x1E) = v24;
  *(_WORD *)(a1 + 0x44) = v27;
  *(_WORD *)(a1 + 0x46) = v26;
  if ( (_BYTE)byte_104BEA != *(_BYTE *)(a1 + 0x57) && !dword_A0D00 && byte_A3D20 )
  {
    if ( (unsigned __int8)byte_A3D20 <= 1u )
    {
      *(_WORD *)(a1 + 0x44) = (int)((double)*(unsigned __int16 *)(a1 + 0x44) * dbl_91DB5);
    }
    else if ( byte_A3D20 == 2 )
    {
      v16 = dbl_91DB5;
      *(_WORD *)(a1 + 0x44) = (int)((double)*(unsigned __int16 *)(a1 + 0x44) * dbl_91DB5);
      *(_WORD *)(a1 + 0x46) = (int)(v16 * (double)*(unsigned __int16 *)(a1 + 0x46));
    }
  }
  *(_WORD *)(a1 + 0x48) = v29;
  *(_WORD *)(a1 + 0x4A) = v30;
  *(_WORD *)(a1 + 0x4C) = v21;
  *(_BYTE *)(a1 + 0x58) = v20;
  *(_BYTE *)(a1 + 0x59) = v22;
  if ( *(unsigned __int16 *)(a1 + 0x4A) > 0x64u )
  {
    *(_WORD *)(a1 + 0x4A) = 0x64;
  }
  v17 = *(_WORD *)(a1 + 0x4A);
  if ( *(_WORD *)(a1 + 0x42) > v17 )
  {
    *(_WORD *)(a1 + 0x42) = v17;
  }
  result = *(_WORD *)(a1 + 0x4C);
  v19 = *(_WORD *)(a1 + 0x42);
  if ( result > v19 )
  {
    *(_WORD *)(a1 + 0x4C) = v19;
  }
  return result;
}
// 91DB5: using guessed type double dbl_91DB5;
// A0D00: using guessed type int dword_A0D00;
// A3D20: using guessed type char byte_A3D20;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 104515: using guessed type int dword_104515;

//----- (000352E0) --------------------------------------------------------
int __fastcall sub_352E0(int a1)
{
  int v2; // edi
  __int64 v3; // rax
  unsigned __int8 v4; // ah
  unsigned int v5; // ebp
  int v6; // eax
  unsigned __int16 v7; // dx
  unsigned __int8 v8; // al
  _BYTE *v9; // eax
  char *v10; // eax
  __int16 v11; // ax
  int v12; // edi
  int v13; // ecx
  int v14; // edx
  int i; // eax
  __int16 v16; // bx
  char v17; // bl
  __int16 v18; // di
  char v19; // al
  int v20; // eax
  unsigned __int16 v21; // di
  int result; // eax
  __int64 x_4; // [esp+4h] [ebp-58h] BYREF
  float v24; // [esp+Ch] [ebp-50h]
  float v25; // [esp+10h] [ebp-4Ch]
  float v26; // [esp+14h] [ebp-48h]
  float v27; // [esp+18h] [ebp-44h]
  float v28; // [esp+1Ch] [ebp-40h]
  int v29; // [esp+2Ch] [ebp-30h] BYREF
  int v30; // [esp+30h] [ebp-2Ch] BYREF
  int v31; // [esp+38h] [ebp-24h] BYREF
  float v32; // [esp+3Ch] [ebp-20h]
  int v33; // [esp+40h] [ebp-1Ch]

  *(_DWORD *)(a1 + 0x62) = 0;
  if ( *(unsigned __int8 *)(a1 + 0x57) != 0xFF )
  {
    v2 = *(_DWORD *)(a1 + 0x10);
    LOWORD(v33) = 0;
    while ( (__int16)v33 < (int)*(unsigned __int16 *)(a1 + 0x1A) )
    {
      if ( *(_BYTE *)(v2 + 1) != 0xFF )
      {
        HIDWORD(v3) = *(unsigned __int8 *)(v2 + 1);
        if ( (word_103FA2[0x14 * HIDWORD(v3)] & 4) != 0 )
        {
          LODWORD(x_4) = &v31;
          LODWORD(v3) = a1;
          sub_366C8(v3, &v30, &v29, x_4, (_DWORD *)LODWORD(v24), (_DWORD *)LODWORD(v25), (_DWORD *)LODWORD(v26));
          if ( v31 )
          {
            *(_BYTE *)(v2 + 3) = 0;
            *(_WORD *)(v2 + 2) |= (_WORD)v31 << 8;
          }
        }
      }
      v2 += 4;
      LOWORD(v33) = v33 + 1;
    }
    v4 = *(_BYTE *)(a1 + 0x54);
    v5 = 0;
    if ( v4 != 0xFF )
    {
      v6 = 0x14 * v4;
      if ( (word_103FA2[v6] & 0x20) == 0 )
      {
        if ( *(unsigned __int16 *)(a1 + 0x52) == 0xFFFF && (word_103FA2[v6] & 2) == 0 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x3E9);
        }
        v7 = *(_WORD *)(a1 + 0x52);
        *(_WORD *)(a1 + 0x50) += *(_WORD *)(a1 + 0x44);
        if ( (unsigned __int16)sub_3583C(a1, v7, *(_BYTE *)(a1 + 0x54)) > *(_WORD *)(a1 + 0x50) )
        {
          if ( *(_BYTE *)(a1 + 0x54) == 0x1F && !(dword_A2F6C[0] % 0xA) )
          {
            v12 = (unsigned __int8)byte_104BEA;
            v13 = *(unsigned __int16 *)(a1 + 0x44) / 0xA + 1;
            v14 = 0;
            for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
            {
              v16 = word_A3124[v12 + v14];
              v14 += 0xF7;
              *(_WORD *)&V_StaticStrings_dword_A0D04.buffer[2 * v12 + 0x1F12 + v14 * 2] = v13 + v16;
            }
          }
        }
        else
        {
          v8 = *(_BYTE *)(a1 + 0x57);
          if ( v8 == (_BYTE)byte_104BEA
            && *(_BYTE *)(a1 + 0x54) == 2
            && (unsigned __int16)word_106FA6[v8] == 0xFFFF
            && !sub_469F0((int)&word_105258, v8) )
          {
            sub_55AEC((int)&V_Type3_stru_10AE70, 0x19, 0, 0);
          }
          if ( (_BYTE)byte_104BEA == *(_BYTE *)(a1 + 0x57)
            && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11
            && *(_BYTE *)(a1 + 0x54) != 0x17
            && !*(_DWORD *)(a1 + 0x5A) )
          {
            v5 = 0xFFFFFFFF;
            sub_55AEC((int)&V_Type3_stru_10AE70, 1, a1, *(unsigned __int8 *)(a1 + 0x54));
          }
          v9 = (_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52));
          if ( (*v9 & 8) != 0 )
          {
            *v9 &= ~8u;
            *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 1) = 0xFF;
            sub_46A94((unsigned __int16 *)&word_105258, *(unsigned __int8 *)(a1 + 0x57), a1);
          }
          else
          {
            v9[2] |= 1u;
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x17 )
          {
            v10 = sub_35A70(a1, *(_WORD *)(a1 + 0x52));
            if ( !v10 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x415);
            }
            if ( v10[0x58] == 1 )
            {
              *(_WORD *)(a1 + 0x42) -= byte_104338;
            }
            sub_49828((int)v10);
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x24 )
          {
            *(_WORD *)(4 * *(unsigned __int16 *)(a1 + 0x52) + *(_DWORD *)(a1 + 0x10) + 2) = 0;
            *(_BYTE *)(4 * *(unsigned __int16 *)(a1 + 0x52) + *(_DWORD *)(a1 + 0x10) + 1) = 0xFF;
            *(_BYTE *)(4 * *(unsigned __int16 *)(a1 + 0x52) + *(_DWORD *)(a1 + 0x10)) = 1;
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x23 )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 2) |= 2u;
          }
          if ( *(_BYTE *)(a1 + 0x54) == 0x25 && (*(_BYTE *)(a1 + 0x66) & 1) == 0 )
          {
            *(_WORD *)(a1 + 0x55) += 0xA;
            *(_BYTE *)(a1 + 0x66) |= 1u;
          }
          if ( (word_103FA2[0x14 * *(unsigned __int8 *)(a1 + 0x54)] & 8) != 0
            && *(_WORD *)(a1 + 0x52) >= *(_WORD *)(a1 + 0x18) )
          {
            v11 = 0xF;
            if ( *(_BYTE *)(a1 + 0x54) == 0x1B )
            {
              v11 = 0x23;
            }
            *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 3) = 0;
            *(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0x52) + 2) |= v11 << 8;
          }
          *(_WORD *)(a1 + 0x52) = 0xFFFF;
          *(_BYTE *)(a1 + 0x54) = 0xFF;
          *(_WORD *)(a1 + 0x50) = 0;
        }
      }
    }
    if ( *(_WORD *)(a1 + 0x42) < *(_WORD *)(a1 + 0x4A) )
    {
      v17 = byte_104BEA;
      v18 = *(_WORD *)(a1 + 0x48) + *(_WORD *)(a1 + 0x4E);
      v19 = *(_BYTE *)(a1 + 0x57);
      *(_WORD *)(a1 + 0x4E) = v18;
      if ( v19 != v17 && *(unsigned __int16 *)(a1 + 0x48) < 4u )
      {
        *(_WORD *)(a1 + 0x4E) = v18 + 1;
      }
      if ( *(unsigned __int16 *)(a1 + 0x4E) < dword_9684C )
      {
        goto LABEL_71;
      }
      if ( (_BYTE)byte_104BEA == *(_BYTE *)(a1 + 0x57)
        && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11
        && *(_WORD *)(a1 + 0x42) == *(_WORD *)(a1 + 0x4C)
        && !v5
        && !*(_DWORD *)(a1 + 0x5A)
        && (*(_BYTE *)(a1 + 0x54) == 0xFF || (word_103FA2[0x14 * *(unsigned __int8 *)(a1 + 0x54)] & 0x20) != 0) )
      {
        sub_55AEC((int)&V_Type3_stru_10AE70, 0xF, a1, 0);
      }
      ++*(_WORD *)(a1 + 0x42);
      v20 = (unsigned __int16)sub_35930(a1, 0xF);
      if ( v20 != 0xFFFF && (*(_WORD *)(4 * v20 + *(_DWORD *)(a1 + 0x10) + 2) & 1) != 0 )
      {
        ++*(_WORD *)(a1 + 0x42);
      }
      v21 = *(_WORD *)(a1 + 0x4A);
      if ( *(_WORD *)(a1 + 0x42) > v21 )
      {
        *(_WORD *)(a1 + 0x42) = v21;
      }
    }
    *(_WORD *)(a1 + 0x4E) = 0;
LABEL_71:
    sub_34E70(a1);
  }
  HIDWORD(x_4) = *(_DWORD *)a1;
  v24 = *(float *)(a1 + 4);
  v25 = *(float *)(a1 + 8);
  v32 = sqrt(v24 * v24 + *((float *)&x_4 + 1) * *((float *)&x_4 + 1) + v25 * v25);
  sub_53000((float *)&x_4 + 1);
  *(float *)&x_4 = dbl_91DD9 / (v32 * v32);
  sub_532AC((float *)&x_4 + 1, *(float *)&x_4);
  v26 = *((float *)&x_4 + 1) * v32;
  v27 = v24 * v32;
  v28 = v25 * v32;
  v24 = v27;
  v25 = v28;
  *(float *)a1 = v26;
  *(float *)(a1 + 4) = v24;
  result = LODWORD(v25);
  *(float *)(a1 + 8) = v25;
  return result;
}
// 91DD9: using guessed type double dbl_91DD9;
// 9684C: using guessed type int dword_9684C;
// A2F6C: using guessed type int dword_A2F6C[];
// A3124: using guessed type __int16 word_A3124[5];
// A3CF2: using guessed type int dword_A3CF2;
// 103FA2: using guessed type __int16 word_103FA2[];
// 104338: using guessed type char byte_104338;
// 106FA6: using guessed type __int16 word_106FA6[7];

//----- (0003583C) --------------------------------------------------------
__int16 __fastcall sub_3583C(int a1, unsigned __int16 a2, unsigned __int8 a3)
{
  __int16 result; // ax
  char *v5; // eax

  result = 0xFFFF;
  if ( a2 != 0xFFFF )
  {
    a3 = *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 1);
  }
  if ( a3 != 0xFF )
  {
    if ( a3 == 0x17 )
    {
      if ( sub_35A70(a1, a2)[0x58] == 2 )
      {
        result = *(_WORD *)(a1 + 0x77);
      }
      else
      {
        v5 = sub_35A70(a1, a2);
        result = sub_4A18C((int)v5);
      }
    }
    else
    {
      result = word_103FA4[0x14 * a3];
    }
    if ( a3 == 0x23 && a2 == *(_WORD *)(a1 + 0x52) )
    {
      result *= 3;
    }
  }
  return result;
}
// 35893: conditional instruction was optimized away because bl.1 is in (<17u|18..FE)
// 103FA4: using guessed type __int16 word_103FA4[];

//----- (000358BC) --------------------------------------------------------
int __fastcall sub_358BC(int a1)
{
  unsigned __int16 v1; // si
  unsigned __int16 v2; // cx
  unsigned __int16 v3; // ax

  v1 = *(_WORD *)(a1 + 0x44);
  v2 = *(_WORD *)(a1 + 0x50);
  v3 = sub_3583C(a1, *(_WORD *)(a1 + 0x52), *(_BYTE *)(a1 + 0x54));
  return sub_46C20(v3, v2, v1);
}

//----- (000358F0) --------------------------------------------------------
int __fastcall sub_358F0(int a1)
{
  __int16 v2; // dx
  int v3; // ebx
  unsigned __int16 v4; // ax
  char v5; // cl

  v2 = *(_WORD *)(a1 + 0x18);
  v3 = 0;
  v4 = 0;
  if ( v2 )
  {
    do
    {
      v5 = *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * v4 + 1);
      if ( v5 != (char)0xFF && v5 != 5 )
      {
        ++v3;
      }
      ++v4;
    }
    while ( v4 < *(_WORD *)(a1 + 0x18) );
  }
  return v3;
}

//----- (00035930) --------------------------------------------------------
int __fastcall sub_35930(int a1, char a2)
{
  __int16 v4; // dx
  int result; // eax

  v4 = *(_WORD *)(a1 + 0x1A);
  result = 0;
  if ( !v4 )
  {
    return 0xFFFF;
  }
  while ( a2 != *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * (unsigned __int16)result + 1) )
  {
    if ( (unsigned __int16)++result >= *(_WORD *)(a1 + 0x1A) )
    {
      return 0xFFFF;
    }
  }
  return result;
}

//----- (00035968) --------------------------------------------------------
int __fastcall sub_35968(int a1, int a2, int a3)
{
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // esi
  int v11; // eax
  int v12; // eax
  int v14; // [esp+4h] [ebp-14h]

  v6 = 0;
  v14 = 0xFFFF;
  if ( a2 >= 0 && a2 < 0xF && a3 >= 0 )
  {
    v7 = 0;
    if ( a2 > 0 )
    {
      v8 = *(unsigned __int16 *)(a1 + 0x14);
      v9 = 0xF * v8;
      do
      {
        LOWORD(v8) = (unsigned __int8)byte_104603[++v9];
        ++v7;
        v6 += v8;
      }
      while ( v7 < a2 );
    }
    v10 = 0xF * *(unsigned __int16 *)(a1 + 0x14) + a2;
    v11 = (unsigned __int8)byte_1045B8[v10];
    if ( a3 >= v11 )
    {
      v12 = (unsigned __int8)byte_104604[v10] + v11;
      if ( a3 < v12 )
      {
        LOWORD(v12) = (unsigned __int8)byte_1045B8[v10];
        return a3 + v6 - v12;
      }
    }
  }
  return v14;
}

//----- (00035A00) --------------------------------------------------------
unsigned int __fastcall sub_35A00(int a1, unsigned __int16 a2)
{
  unsigned int v4; // edi
  int v5; // edi
  int v6; // ecx
  __int16 v7; // si
  unsigned __int16 v8; // ax
  int v9; // edx

  v4 = 0xFFFFFFFF;
  if ( a2 < *(_WORD *)(a1 + 0x18) )
  {
    v5 = 0;
    v6 = 0;
    v7 = *(_WORD *)(a1 + 0x18);
    v8 = 0;
    if ( v7 )
    {
      v9 = 0xF * *(unsigned __int16 *)(a1 + 0x14);
      do
      {
        v5 = (unsigned __int8)byte_1045B8[v9] + a2 - v8;
        v8 += (unsigned __int8)byte_104604[v9];
        if ( v8 > a2 )
        {
          break;
        }
        ++v9;
        ++v6;
      }
      while ( v8 < *(_WORD *)(a1 + 0x18) );
    }
    return (v6 << 0x10) + v5;
  }
  return v4;
}

//----- (00035A70) --------------------------------------------------------
char *__fastcall sub_35A70(int a1, unsigned __int16 a2)
{
  unsigned int v2; // ecx

  if ( a2 >= *(_WORD *)(a1 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x50B);
  }
  v2 = ((int)*(unsigned __int16 *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 2) >> 8) & 0x7F;
  if ( v2 >= 0x6B )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x50F);
  }
  if ( *(int *)((char *)&dword_CA245 + 0x162 * (unsigned __int16)v2) >> 0x10 == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x510);
  }
  return (char *)&unk_CA1F1 + 0x162 * (unsigned __int16)v2;
}
// CA245: using guessed type int dword_CA245;

//----- (00035B04) --------------------------------------------------------
unsigned __int16 __fastcall sub_35B04(int a1, unsigned __int16 a2, int a3)
{
  int v4; // edi
  unsigned __int16 result; // ax

  if ( a2 >= *(_WORD *)(a1 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x519);
  }
  if ( a2 < *(_WORD *)(a1 + 0x18) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x51A);
  }
  v4 = (a3 - (int)&unk_CA1F1) / 0x162;
  if ( (unsigned __int16)v4 >= 0x6Bu )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x51E);
  }
  if ( *(int *)((char *)&dword_CA245 + 0x162 * (unsigned __int16)v4) >> 0x10 == 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x51F);
  }
  result = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 2) = ((_WORD)v4 << 8) | (unsigned __int8)*(_WORD *)(*(_DWORD *)(a1 + 0x10)
                                                                                                 + 4 * a2
                                                                                                 + 2);
  return result;
}
// CA245: using guessed type int dword_CA245;

//----- (00035BB4) --------------------------------------------------------
unsigned int __fastcall sub_35BB4(int a1, int a2)
{
  int v4; // edx
  int v5; // eax

  if ( *(unsigned __int8 *)(a1 + 0x57) == *(__int16 *)(a2 + 0x56) || !sub_361B8(a1) )
  {
    v4 = *(unsigned __int16 *)(a1 + 0x18);
    v5 = 4 * (unsigned __int16)v4;
    while ( v4 < *(unsigned __int16 *)(a1 + 0x1A) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + v5 + 1) == 0xFF )
      {
        *(_BYTE *)(a2 + 0x58) = 3;
        *(_DWORD *)(a2 + 0x59) = a1;
        *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + v5 + 1) = 0x17;
        *(_WORD *)(*(_DWORD *)(a1 + 0x10) + v5 + 2) = 1;
        sub_35B04(a1, v4, a2);
        return 0xFFFFFFFF;
      }
      v5 += 4;
      ++v4;
    }
  }
  return 0;
}

//----- (00035C38) --------------------------------------------------------
unsigned int __fastcall sub_35C38(int a1, int a2)
{
  int v3; // ecx
  int v4; // esi
  int v5; // eax
  double v6; // st7
  float v8; // [esp+0h] [ebp-40h] BYREF
  float v9; // [esp+4h] [ebp-3Ch]
  float v10; // [esp+8h] [ebp-38h]
  int v11[3]; // [esp+Ch] [ebp-34h] BYREF
  float v12; // [esp+18h] [ebp-28h]
  float v13; // [esp+1Ch] [ebp-24h]
  float v14; // [esp+20h] [ebp-20h]
  int v15; // [esp+24h] [ebp-1Ch]
  int *v16; // [esp+28h] [ebp-18h]

  v3 = *(unsigned __int16 *)(a1 + 0x18);
  v4 = 4 * v3;
  while ( v3 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v5 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_WORD *)(v5 + 2) && *(_BYTE *)(v5 + 1) == 0x17 && sub_35A70(a1, v3) == (char *)a2 )
    {
      *(_BYTE *)(v4 + *(_DWORD *)(a1 + 0x10) + 1) = 0xFF;
      *(_WORD *)(v4 + *(_DWORD *)(a1 + 0x10) + 2) = 0;
      *(_BYTE *)(a2 + 0x58) = 4;
      *(_DWORD *)(a2 + 0x59) = &word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)];
      v8 = (float)(rand() % 0x3E8 - 0x1F4);
      v9 = (float)(rand() % 0x3E8 - 0x1F4);
      v15 = rand() % 0x3E8 - 0x1F4;
      v10 = (float)v15;
      sub_53054(&v8, 250.0);
      v12 = 0.0;
      v13 = 0.0;
      v14 = 0.0;
      v16 = v11;
      v12 = *(float *)a1 + v8;
      v13 = *(float *)(a1 + 4) + v9;
      v6 = *(float *)(a1 + 8);
      *(float *)v11 = v12;
      v14 = v6 + v10;
      *(float *)&v11[1] = v13;
      *(float *)&v11[2] = v14;
      sub_496BC(a2, v11);
      return 0xFFFFFFFF;
    }
    v4 += 4;
    ++v3;
  }
  return 0;
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00035DA4) --------------------------------------------------------
char __fastcall sub_35DA4(int a1)
{
  char v1; // bl
  int v2; // ecx

  v1 = 0xFF;
  if ( (unsigned __int8)byte_1043D9 == 0xFF )
  {
    return 0x1B;
  }
  v2 = 1 << *(_BYTE *)(a1 + 0x57);
  if ( (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_1043D9) >> 0x18)) != 0 )
  {
    return 0x1B;
  }
  if ( (unsigned __int8)byte_1043B1 == 0xFF
    || (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_1043B1) >> 0x18)) != 0 )
  {
    return 0x1A;
  }
  return v1;
}
// 1043B1: using guessed type char byte_1043B1;
// 1043D9: using guessed type char byte_1043D9;
// 10529F: using guessed type int dword_10529F;

//----- (00035E24) --------------------------------------------------------
char __fastcall __spoils<ah> sub_35E24(int a1)
{
  char v1; // dl
  int v2; // ecx

  v1 = 0xFF;
  if ( (unsigned __int8)byte_104451 == 0xFF )
  {
    return 0x1E;
  }
  v2 = 1 << *(_BYTE *)(a1 + 0x57);
  if ( (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104451) >> 0x18)) != 0 )
  {
    return 0x1E;
  }
  if ( (unsigned __int8)byte_104429 == 0xFF
    || (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104429) >> 0x18)) != 0 )
  {
    return 0x1D;
  }
  if ( (unsigned __int8)byte_104401 == 0xFF
    || (v2 & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104401) >> 0x18)) != 0 )
  {
    return 0x1C;
  }
  return v1;
}
// 104401: using guessed type char byte_104401;
// 104429: using guessed type char byte_104429;
// 104451: using guessed type char byte_104451;
// 10529F: using guessed type int dword_10529F;

//----- (00035ED8) --------------------------------------------------------
int __fastcall sub_35ED8(int a1)
{
  int v2; // ebp
  int v3; // edi
  __int64 v4; // rax
  unsigned __int8 v5; // al
  int v6; // eax
  char v7; // dl
  __int64 v9; // [esp-4h] [ebp-44h]
  _DWORD *v10; // [esp+4h] [ebp-3Ch]
  _DWORD *v11; // [esp+8h] [ebp-38h]
  int v12; // [esp+Ch] [ebp-34h] BYREF
  int v13; // [esp+10h] [ebp-30h] BYREF
  int v14; // [esp+14h] [ebp-2Ch] BYREF
  float v15; // [esp+18h] [ebp-28h]
  int v16; // [esp+1Ch] [ebp-24h]
  int v17; // [esp+20h] [ebp-20h]
  float v18; // [esp+24h] [ebp-1Ch]

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v18 = -1.0;
  v3 = 4 * v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v6 = v3 + *(_DWORD *)(a1 + 0x10);
    v7 = *(_BYTE *)(v6 + 1);
    v15 = -1.0;
    if ( v7 != (char)0xFF && (*(_WORD *)(v6 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v6 + 1);
      if ( v5 >= 0x1Cu && v5 <= 0x1Eu )
      {
        v12 = 0;
        v13 = 0;
        v14 = 1;
        LODWORD(v9) = &v14;
        HIDWORD(v4) = *(unsigned __int8 *)(v3 + *(_DWORD *)(a1 + 0x10) + 1);
        LODWORD(v4) = a1;
        sub_366C8(v4, &v13, &v12, v9, v10, v11, 0);
        if ( v14 )
        {
          v17 = (int)*(unsigned __int16 *)(v3 + *(_DWORD *)(a1 + 0x10) + 2) >> 8;
        }
        if ( v17 > 0 )
        {
          v16 = 0x20 * v12;
          v15 = (double)(0x20 * v12) * dbl_91E43;
        }
      }
    }
    if ( v15 > (double)v18 )
    {
      v18 = v15;
    }
    v3 += 4;
    ++v2;
  }
  return (int)v18;
}
// 35F27: variable 'v9' is possibly undefined
// 35F27: variable 'v10' is possibly undefined
// 35F27: variable 'v11' is possibly undefined
// 91E43: using guessed type double dbl_91E43;

//----- (00035FE0) --------------------------------------------------------
int __fastcall sub_35FE0(int a1)
{
  int v2; // ebx
  int result; // eax
  int v4; // esi
  unsigned __int8 v5; // dl
  int v6; // edx

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  result = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v6 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v6 + 1) != 0xFF && (*(_WORD *)(v6 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v6 + 1);
      if ( v5 >= 0x1Au )
      {
        if ( v5 <= 0x1Au )
        {
          result += 3;
        }
        else if ( v5 == 0x1B )
        {
          result += 6;
        }
      }
    }
    v4 += 4;
    ++v2;
  }
  return result;
}

//----- (00036050) --------------------------------------------------------
void __fastcall sub_36050(int a1)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  unsigned __int8 v5; // dl
  int v6; // edx

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v3 = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v6 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v6 + 1) != 0xFF && (*(_WORD *)(v6 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v6 + 1);
      if ( v5 < 0x1Du )
      {
        if ( v5 == 0x1C )
        {
          v3 += 2;
        }
      }
      else if ( v5 <= 0x1Du )
      {
        v3 += 4;
      }
      else if ( v5 == 0x1E )
      {
        v3 += 6;
      }
    }
    v4 += 4;
    ++v2;
  }
  JUMPOUT(0x36045);
}
// 3609C: control flows out of bounds to 36045

//----- (000360D8) --------------------------------------------------------
void __fastcall sub_360D8(int a1)
{
  int v2; // ebx
  int v3; // eax
  int v4; // esi
  int v5; // edx

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v3 = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v5 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v5 + 1) != 0xFF && (*(_WORD *)(v5 + 2) & 1) != 0 )
    {
      switch ( *(_BYTE *)(v5 + 1) )
      {
        case 0x1A:
          ++v3;
          break;
        case 0x1B:
        case 0x1C:
          v3 += 2;
          break;
        case 0x1D:
          v3 += 4;
          break;
        case 0x1E:
          v3 += 6;
          break;
        default:
          break;
      }
    }
    v4 += 4;
    ++v2;
  }
  JUMPOUT(0x36045);
}
// 3610E: control flows out of bounds to 36045

//----- (00036158) --------------------------------------------------------
void __fastcall sub_36158(int a1)
{
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  unsigned __int8 v5; // dl
  int v6; // edx

  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( v3 < *(unsigned __int16 *)(a1 + 0x18) )
  {
    v6 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v6 + 1) != 0xFF && (*(_WORD *)(v6 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v6 + 1);
      if ( v5 >= 0x12u )
      {
        if ( v5 <= 0x12u )
        {
          v2 += 2;
        }
        else if ( v5 == 0x13 )
        {
          v2 += 4;
        }
      }
    }
    v4 += 4;
    ++v3;
  }
  JUMPOUT(0x36045);
}
// 3618F: control flows out of bounds to 36045

//----- (000361B8) --------------------------------------------------------
int __fastcall sub_361B8(int a1)
{
  int v2; // ecx
  int v3; // edi
  int v4; // esi
  int v5; // eax
  char v6; // dl

  v2 = *(unsigned __int16 *)(a1 + 0x18);
  v3 = 0;
  v4 = 4 * (unsigned __int16)v2;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v5 = v4 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v5 + 1) != 0xFF && (*(_WORD *)(v5 + 2) & 1) != 0 )
    {
      if ( *(_BYTE *)(v5 + 1) == 0x17 && *((_WORD *)sub_35A70(a1, v2) + 0x2B) == *(unsigned __int8 *)(a1 + 0x57) )
      {
        return 0xFFFFFFFF;
      }
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 0x10) + 1);
      if ( v6 == 0x1A || v6 == 0x1B )
      {
        return 0xFFFFFFFF;
      }
    }
    v4 += 4;
    ++v2;
  }
  return v3;
}

//----- (0003623C) --------------------------------------------------------
unsigned int __fastcall sub_3623C(int a1)
{
  unsigned int v2; // ebp
  int v3; // edi
  int v4; // eax
  char v5; // dh
  __int64 v7; // [esp+0h] [ebp-1Ch]
  unsigned __int8 v8; // [esp+8h] [ebp-14h]
  unsigned __int8 v9; // [esp+Ch] [ebp-10h]

  v2 = 0;
  v3 = 0;
  LODWORD(v7) = 0;
  while ( *(unsigned __int16 *)(a1 + 0x18) > (int)v7 )
  {
    v4 = v3 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v4 + 1) != 0xFF && (*(_WORD *)(v4 + 2) & 1) != 0 )
    {
      v5 = *(_BYTE *)(v4 + 1);
      if ( v5 == 2 || v5 == 8 )
      {
        if ( sub_34B0C(v7, v8, v9) )
        {
          v2 = 0xFFFFFFFF;
        }
      }
    }
    v3 += 4;
    LODWORD(v7) = v7 + 1;
  }
  return v2;
}
// 36257: variable 'v7' is possibly undefined
// 362AA: variable 'v8' is possibly undefined
// 362AA: variable 'v9' is possibly undefined

//----- (000362C8) --------------------------------------------------------
int __fastcall sub_362C8(int a1, _DWORD *a2)
{
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = a2[1];
  *(_DWORD *)(a1 + 8) = a2[2];
  return sub_53440((float *)a1);
}

//----- (000362E0) --------------------------------------------------------
unsigned int __fastcall sub_362E0(int a1)
{
  int v2; // ebx
  int v3; // eax

  if ( *(unsigned __int8 *)(a1 + 0x57) >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x688);
  }
  v2 = 0;
  v3 = (unsigned __int16)sub_35930(a1, 0x16);
  if ( v3 != 0xFFFF
    && (*(_WORD *)(*(_DWORD *)(a1 + 0x10) + 4 * v3 + 2) & 1) != 0
    && (int)sub_3EFE0((int)&byte_A2F72[0x1EE * *(unsigned __int8 *)(a1 + 0x57)]) > 0 )
  {
    return 0xFFFFFFFF;
  }
  return v2;
}
// A3CF2: using guessed type int dword_A3CF2;

//----- (0003636C) --------------------------------------------------------
void __fastcall sub_3636C(int a1, int a2)
{
  _BYTE *v4; // edx
  __int16 v5; // bx
  int v6; // eax

  v4 = *(_BYTE **)(a1 + 0x10);
  v5 = 0;
  v6 = 0;
  while ( v5 < (int)*(unsigned __int16 *)(a1 + 0x18) )
  {
    if ( (unsigned __int8)*v4 < 2u )
    {
      if ( *v4 )
      {
        ++v6;
      }
      else if ( a2 )
      {
        ++v6;
      }
    }
    else
    {
      v6 += 2;
    }
    ++v5;
    v4 += 4;
  }
  JUMPOUT(0x35D9B);
}
// 36399: control flows out of bounds to 35D9B

//----- (000363B0) --------------------------------------------------------
int __fastcall sub_363B0(int a1)
{
  unsigned __int16 v2; // ax
  int v3; // edi
  int v4; // edx
  int v5; // ebx
  int i; // eax
  int v7; // ecx
  int v8; // edi

  if ( *(unsigned __int8 *)(a1 + 0x57) > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x6CD);
  }
  sub_3636C(a1, (byte_A310F[0x1EE * *(unsigned __int8 *)(a1 + 0x57)] != 2) - 1);
  v3 = (*(unsigned __int16 *)(a1 + 0x4A) - *(unsigned __int16 *)(a1 + 0x42)) / 2
     + *(unsigned __int16 *)(a1 + 0x42)
     + *(unsigned __int16 *)(a1 + 0x46)
     + *(unsigned __int16 *)(a1 + 0x48)
     + *(unsigned __int16 *)(a1 + 0x44)
     + v2;
  if ( (*(_BYTE *)(a1 + 0x66) & 2) != 0 )
  {
    v3 += 0x64;
  }
  v4 = *(_DWORD *)(a1 + 0x10);
  v5 = 0;
  for ( i = 0; i < *(unsigned __int16 *)(a1 + 0x1A); ++i )
  {
    v7 = (unsigned __int16)word_103FA4[0x14 * *(unsigned __int8 *)(v4 + 1)];
    v4 += 4;
    v5 += v7;
  }
  v8 = v5 + v3;
  if ( (unsigned __int16)sub_35930(a1, 0x16) )
  {
    v8 += 0x32;
  }
  if ( (unsigned __int16)sub_35930(a1, 0x18) )
  {
    v8 += 0x32;
  }
  if ( v8 < 0 )
  {
    return 0;
  }
  return v8;
}
// 36405: variable 'v2' is possibly undefined
// A3CF2: using guessed type int dword_A3CF2;
// 103FA4: using guessed type __int16 word_103FA4[];

//----- (000364B4) --------------------------------------------------------
int __fastcall sub_364B4(int a1, __int16 a2)
{
  char *v3; // ebx
  int v4; // eax
  unsigned __int16 v5; // ax
  unsigned int v6; // esi
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  int i; // edx
  int v11; // esi
  int v12; // ebx
  int j; // edx
  int v14; // esi
  int v15; // edi
  int v16; // eax
  int v18; // [esp+0h] [ebp-1Ch]
  unsigned int v19; // [esp+4h] [ebp-18h]

  if ( a2 > SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x71A);
  }
  v3 = &byte_A2F72[0x1EE * a2];
  v4 = *(unsigned __int8 *)(a1 + 0x57);
  v18 = 0;
  if ( v4 == 0xFF || a2 != v4 && v3[v4 + 0x1C0] == 2 )
  {
    sub_3636C(a1, (byte_A310F[0x1EE * a2] != 2) - 1);
    v18 = v5;
    if ( (*(_BYTE *)(a1 + 0x66) & 2) != 0 )
    {
      v18 = v5 + 0x28;
    }
    if ( v18 > 0x46 || v3[*(unsigned __int8 *)(a1 + 0x57) + 0x1C0] == 2 )
    {
      if ( v3[*(unsigned __int8 *)(a1 + 0x57) + 0x1C0] != 2 )
      {
        goto LABEL_30;
      }
      v6 = 0;
      v7 = (*(unsigned __int16 *)(a1 + 0x4A) - *(unsigned __int16 *)(a1 + 0x42)) / 2
         + *(unsigned __int16 *)(a1 + 0x42)
         + *(unsigned __int16 *)(a1 + 0x46)
         + *(unsigned __int16 *)(a1 + 0x48)
         + *(unsigned __int16 *)(a1 + 0x44);
      v19 = 0;
      if ( (unsigned __int16)sub_35930(a1, 0xB) != 0xFFFF )
      {
        v6 = 0xFFFFFFFF;
      }
      if ( (unsigned __int16)sub_35930(a1, 0x19) != 0xFFFF )
      {
        v19 = 0xFFFFFFFF;
      }
      v8 = *(_DWORD *)(a1 + 0x10);
      v9 = 0;
      if ( !v6 )
      {
        for ( i = 0; i < *(unsigned __int16 *)(a1 + 0x18); ++i )
        {
          v11 = (unsigned __int16)word_103FA4[0x14 * *(unsigned __int8 *)(v8 + 1)];
          v8 += 4;
          v9 += v11;
        }
      }
      if ( !v19 )
      {
        v12 = *(_DWORD *)(a1 + 0x10);
        for ( j = *(unsigned __int16 *)(a1 + 0x18); j < *(unsigned __int16 *)(a1 + 0x1A); ++j )
        {
          v14 = (unsigned __int16)word_103FA4[0x14 * *(unsigned __int8 *)(v12 + 1)];
          v12 += 4;
          v9 += v14;
        }
      }
      v15 = v9 + v7;
      if ( (unsigned __int16)sub_35930(a1, 0x16) )
      {
        v15 += 0x32;
      }
      if ( (unsigned __int16)sub_35930(a1, 0x18) )
      {
        v15 += 0x32;
      }
      v16 = 2 * (v15 / 0xA + v18);
    }
    else
    {
      v16 = 0;
    }
    v18 = v16;
  }
LABEL_30:
  if ( v18 < 0 )
  {
    return 0;
  }
  return v18;
}
// 3654C: variable 'v5' is possibly undefined
// A3CF2: using guessed type int dword_A3CF2;
// 103FA4: using guessed type __int16 word_103FA4[];

//----- (000366C8) --------------------------------------------------------
__int64 __userpurge sub_366C8@<edx:eax>(
        __int64 a1@<edx:eax>,
        _DWORD *a2@<ecx>,
        _DWORD *a3@<ebx>,
        __int64 result,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7)
{
  if ( !a3 || !a2 || !(_DWORD)result )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x785);
  }
  BYTE1(a1) = BYTE4(a1);
  switch ( BYTE4(a1) )
  {
    case 0x1C:
      *a3 = 0x2D;
      *a2 = 7;
      *(_DWORD *)result = 1;
      break;
    case 0x1D:
      *a3 = 0x2D;
      *a2 = 7;
      *(_DWORD *)result = 3;
      break;
    case 0x1E:
      *a3 = 0x5A;
      *a2 = 8;
      *(_DWORD *)result = 3;
      break;
    case 0x11:
      *a3 = 0xC8;
      *a2 = 0;
      *(_DWORD *)result = 2;
      break;
  }
  return a1;
}

//----- (0003676C) --------------------------------------------------------
int __fastcall sub_3676C(int a1, int a2)
{
  int v4; // eax
  int v5; // edi
  __int64 v6; // rax
  double v7; // st7
  BOOL v8; // eax
  int v9; // eax
  double v10; // st7
  double v11; // st7
  int v12; // eax
  int result; // eax
  __int64 x_4; // [esp+4h] [ebp-90h]
  float v15; // [esp+8h] [ebp-8Ch]
  _DWORD *v16; // [esp+Ch] [ebp-88h]
  float v17; // [esp+Ch] [ebp-88h]
  _DWORD *v18; // [esp+10h] [ebp-84h]
  float v19; // [esp+10h] [ebp-84h]
  float v20; // [esp+14h] [ebp-80h] BYREF
  float v21; // [esp+18h] [ebp-7Ch]
  float v22; // [esp+1Ch] [ebp-78h]
  float v23; // [esp+20h] [ebp-74h] BYREF
  float v24; // [esp+24h] [ebp-70h]
  float v25; // [esp+28h] [ebp-6Ch]
  int v26[3]; // [esp+2Ch] [ebp-68h] BYREF
  float v27; // [esp+38h] [ebp-5Ch]
  float v28; // [esp+3Ch] [ebp-58h]
  float v29; // [esp+40h] [ebp-54h]
  float v30; // [esp+44h] [ebp-50h]
  float v31; // [esp+48h] [ebp-4Ch]
  float v32; // [esp+4Ch] [ebp-48h]
  int *v33; // [esp+50h] [ebp-44h]
  int v34; // [esp+54h] [ebp-40h]
  int v35[3]; // [esp+58h] [ebp-3Ch] BYREF
  int v36; // [esp+64h] [ebp-30h] BYREF
  int v37[2]; // [esp+68h] [ebp-2Ch] BYREF
  int v38; // [esp+70h] [ebp-24h]
  float v39; // [esp+74h] [ebp-20h]
  int v40; // [esp+78h] [ebp-1Ch]
  int v41; // [esp+7Ch] [ebp-18h]

  v4 = *(_DWORD *)(a1 + 0x6B);
  v41 = 0;
  LOBYTE(v4) = *(_BYTE *)(v4 + 1);
  v38 = 0xFFFFFFFF;
  if ( (_BYTE)v4 == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x7AB);
  }
  v5 = *(_DWORD *)(a1 + 0x6F);
  v36 = 0;
  v37[0] = 0;
  v35[0] = 1;
  LODWORD(x_4) = v35;
  HIDWORD(v6) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 0x6B) + 1);
  LODWORD(v6) = a1;
  sub_366C8(v6, v37, &v36, x_4, v16, v18, (_DWORD *)LODWORD(v20));
  if ( v5 )
  {
    if ( *(_BYTE *)(v5 + 0x58) != 4 || &word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)] != *(__int16 **)(v5 + 0x59) )
    {
      v38 = 0;
    }
    if ( v36 > 0 )
    {
      v33 = v26;
      v30 = 0.0;
      v31 = 0.0;
      v32 = 0.0;
      v30 = *(float *)(v5 + 0x9E) - *(float *)a1;
      v31 = *(float *)(v5 + 0xA2) - *(float *)(a1 + 4);
      v32 = *(float *)(v5 + 0xA6) - *(float *)(a1 + 8);
      *(float *)v26 = v30;
      *(float *)&v26[1] = v31;
      *(float *)&v26[2] = v32;
      v7 = sqrt(v31 * v31 + v30 * v30 + v32 * v32);
      v34 = 0x20 * v36;
      if ( (double)(0x20 * v36) < v7 )
      {
        v38 = 0;
      }
    }
  }
  v40 = 1;
  if ( v35[0] )
  {
    v40 = (int)*(unsigned __int16 *)(*(_DWORD *)(a1 + 0x6B) + 2) >> 8;
  }
  v8 = v38 && v40;
  v41 |= v8;
  if ( (v41 & 1) != 0 )
  {
    if ( v37[0] )
    {
      v9 = sub_4B7A0(v5, a2, v37[0], *(unsigned __int8 *)(a1 + 0x57));
      v41 |= v9;
    }
    if ( a2 == 1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 0x6B) + 1) == 0x11 )
      {
        v35[2] = (int)&v23;
        v15 = *(float *)(v5 + 0x9E) - *(float *)a1;
        v17 = *(float *)(v5 + 0xA2) - *(float *)(a1 + 4);
        v19 = *(float *)(v5 + 0xA6) - *(float *)(a1 + 8);
        v23 = v15;
        v24 = v17;
        v25 = v19;
        v10 = sqrt(v17 * v17 + v15 * v15 + v19 * v19) + flt_91E91;
        v39 = v10;
        if ( v10 < flt_91E95 )
        {
          v39 = 1280.0;
        }
        sub_53054(&v23, v39);
        v27 = 0.0;
        v28 = 0.0;
        v29 = 0.0;
        v37[1] = (int)&v20;
        v27 = *(float *)a1 + v23;
        v28 = *(float *)(a1 + 4) + v24;
        v11 = *(float *)(a1 + 8);
        v20 = v27;
        v29 = v11 + v25;
        v21 = v28;
        v22 = v29;
        *(float *)(v5 + 0x9E) = v27;
        *(float *)(v5 + 0xA2) = v21;
        *(float *)(v5 + 0xA6) = v22;
      }
      if ( v35[0] && v40 > 0 )
      {
        v12 = *(_DWORD *)(a1 + 0x6B);
        --v40;
        *(_BYTE *)(v12 + 3) = 0;
        *(_WORD *)(*(_DWORD *)(a1 + 0x6B) + 2) |= (_WORD)v40 << 8;
      }
    }
  }
  result = v41;
  *(_DWORD *)(a1 + 0x73) = v41;
  return result;
}
// 367D3: variable 'x_4' is possibly undefined
// 367D3: variable 'v16' is possibly undefined
// 367D3: variable 'v18' is possibly undefined
// 91E91: using guessed type float flt_91E91;
// 91E95: using guessed type float flt_91E95;
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00036A5C) --------------------------------------------------------
__int16 __fastcall sub_36A5C(int a1, int a2, __int16 a3)
{
  int v3; // esi
  int v4; // edx
  int v5; // eax
  unsigned __int16 v6; // cx
  int v7; // edi
  int v8; // ebx
  int v9; // ecx
  unsigned __int16 v10; // di
  int v11; // ebp
  int v12; // edx
  int v13; // eax
  __int16 v14; // ecx^2
  int v15; // ebx
  char *v16; // eax
  __int16 v18[10]; // [esp+0h] [ebp-30h]
  int v19; // [esp+14h] [ebp-1Ch]
  int v20; // [esp+18h] [ebp-18h]
  int v21; // [esp+1Ch] [ebp-14h]

  v3 = a1;
  v19 = a2;
  LOWORD(v21) = a3;
  if ( *(_DWORD *)(a1 + 0x62) != 0xFFFFFFFF )
  {
    if ( *(unsigned __int8 *)(a1 + 0x57) >= SHIWORD(dword_A3CF2) && *(unsigned __int8 *)(a1 + 0x57) != 0xFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x7FE);
    }
    if ( (v21 & 0x8000u) != 0 || (LOWORD(a1) = v21, (__int16)v21 >= SHIWORD(dword_A3CF2)) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x7FF);
    }
    v4 = *(unsigned __int8 *)(v3 + 0x57);
    if ( v4 != 0xFF )
    {
      v5 = 0x1EE * v4;
      v4 = (__int16)v21;
      LOWORD(a1) = sub_433E0((int)&byte_A2F72[v5], v21, (int)&word_A3D21[0x30 * *(__int16 *)(v3 + 0xC)]);
    }
    LOWORD(v4) = *(_WORD *)(v3 + 0x18);
    v6 = *(_WORD *)(v3 + 0x1A);
    v7 = 0;
    v20 = 0xFFFF;
    if ( (unsigned __int16)v4 < v6 )
    {
      a1 = 0;
      do
      {
        v8 = 4 * (unsigned __int16)v4;
        if ( *(_BYTE *)(v8 + *(_DWORD *)(v3 + 0x10) + 1) != 0xFF )
        {
          *(__int16 *)((char *)v18 + a1) = v4;
          if ( (word_103FA2[0x14 * *(unsigned __int8 *)(*(_DWORD *)(v3 + 0x10) + v8 + 1)] & 8) != 0
            && (_WORD)v4 != *(_WORD *)(v3 + 0x52) )
          {
            v20 = v4;
          }
          a1 += 2;
          ++v7;
        }
        ++v4;
      }
      while ( (unsigned __int16)v4 < *(_WORD *)(v3 + 0x1A) );
    }
    if ( v7 )
    {
      v9 = 0xFFFFFFFF;
      if ( (unsigned __int16)v20 == 0xFFFF )
      {
        v10 = v18[rand() % v7];
      }
      else
      {
        v10 = v20;
        v11 = 4 * (unsigned __int16)v20;
        v12 = v11 + *(_DWORD *)(v3 + 0x10);
        v13 = ((int)*(unsigned __int16 *)(v12 + 2) >> 8) - v19;
        if ( v13 > 0 && (_WORD)v20 != *(_WORD *)(v3 + 0x52) )
        {
          *(_BYTE *)(v12 + 3) = 0;
          *(_WORD *)(*(_DWORD *)(v3 + 0x10) + v11 + 2) |= (_WORD)v13 << 8;
          v9 = 0;
        }
      }
      if ( *(_BYTE *)(*(_DWORD *)(v3 + 0x10) + 4 * v10 + 1) == 0x17 )
      {
        v14 = v21;
        v15 = v19;
        v16 = sub_35A70(v3, v10);
        v9 = ((sub_4B7A0((int)v16, 1, 2 * v15, v14) & 4) == 0) - 1;
      }
      if ( *(_WORD *)(v3 + 0x4A) < *(_WORD *)(v3 + 0x42) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x837);
      }
      if ( *(int *)((char *)&dword_103F9A[0xA * *(unsigned __int8 *)(*(_DWORD *)(v3 + 0x10) + 4 * v10 + 1)] + 2) >> 0x18 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x838);
      }
      if ( v9 == 0xFFFFFFFF )
      {
        sub_34B0C(*(__int64 *)v18, v18[4], v18[6]);
        if ( *(_BYTE *)(*(_DWORD *)(v3 + 0x10) + 4 * v10 + 1) != 0xFF )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x83D);
        }
        if ( v10 == *(_WORD *)(v3 + 0x52) )
        {
          *(_WORD *)(v3 + 0x52) = 0xFFFF;
          *(_BYTE *)(v3 + 0x54) = 0xFF;
          *(_WORD *)(v3 + 0x50) = 0;
        }
      }
      LOWORD(a1) = sub_34E70(v3);
    }
  }
  return a1;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 36A5C: using guessed type __int16 var_30[10];

//----- (00036CD4) --------------------------------------------------------
unsigned int __fastcall sub_36CD4(int a1, unsigned __int16 a2, int *a3)
{
  char *v5; // eax
  int v6; // edx
  char *v7; // ebp
  int v8; // eax
  int v9; // edx
  __int16 v10; // di
  __int16 i; // ax
  __int16 j; // ax
  int v13; // edx
  int v14; // edx
  int v15; // edi
  __int16 v16; // bx
  int v17; // edi
  int v18; // eax
  int v19; // eax
  __int64 v21; // [esp+0h] [ebp-30h]
  int v22; // [esp+8h] [ebp-28h]
  unsigned int v23; // [esp+Ch] [ebp-24h]
  int v24; // [esp+10h] [ebp-20h]
  int v25; // [esp+14h] [ebp-1Ch]
  __int16 m; // [esp+18h] [ebp-18h]
  __int16 k; // [esp+1Ch] [ebp-14h]

  v23 = 0;
  if ( a2 >= *(_WORD *)(a1 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x851);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 0x10) + 4 * a2 + 1) != 0x17 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x852);
  }
  v5 = sub_35A70(a1, a2);
  v6 = *(unsigned __int8 *)(a1 + 0x57);
  v7 = v5;
  if ( v6 == 0xFF || v6 == *((__int16 *)v5 + 0x2B) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x856);
  }
  LODWORD(v21) = 0;
  if ( !byte_A310F[0x1EE * *((__int16 *)v5 + 0x2B)] )
  {
    LODWORD(v21) = 0xFFFFFFFF;
  }
  if ( sub_433E0(
         (int)&byte_A2F72[0x1EE * *(unsigned __int8 *)(a1 + 0x57)],
         *((_WORD *)v5 + 0x2B),
         (int)&word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)]) == 0xFFFFFFFF )
  {
    v8 = 0x1EE * *(unsigned __int8 *)(a1 + 0x57);
    v9 = v8 + 2 * *((__int16 *)v7 + 0x2B);
    v10 = *(_WORD *)((char *)&dword_A313B + v8);
    if ( v10 < *(__int16 *)((char *)word_A3124 + v9) )
    {
      *(__int16 *)((char *)word_A3124 + v9) = v10 - 0xA;
    }
  }
  v24 = 0;
  HIDWORD(v21) = 0;
  for ( i = 0; i < *(_DWORD *)(v7 + 0x15A); ++i )
  {
    if ( v7[7 * i + 0xAB] == 0x49 )
    {
      ++v24;
    }
  }
  for ( j = 0; j < (int)*(unsigned __int16 *)(a1 + 0x18); ++j )
  {
    v14 = *(_DWORD *)(a1 + 0x10) + 4 * j;
    if ( *(_BYTE *)(v14 + 1) == 0x12 && (*(_WORD *)(v14 + 2) & 1) != 0 )
    {
      ++HIDWORD(v21);
    }
    else
    {
      v13 = *(_DWORD *)(a1 + 0x10) + 4 * j;
      if ( *(_BYTE *)(v13 + 1) == 0x13 && (*(_WORD *)(v13 + 2) & 1) != 0 )
      {
        HIDWORD(v21) += 2;
      }
    }
  }
  v25 = v24;
  if ( v24 > SHIDWORD(v21) )
  {
    v25 = HIDWORD(v21) + 1;
  }
  v22 = v25;
  if ( (_DWORD)v21 == 0xFFFFFFFF )
  {
    v22 = 1;
  }
  v15 = 0;
  v16 = 0;
  *a3 = v22;
  while ( v16 < *(_DWORD *)(v7 + 0x15A) && v15 < v22 )
  {
    if ( v7[7 * v16 + 0xAB] == 0x49 )
    {
      ++v15;
      sub_492F8(v7, v16);
    }
    ++v16;
  }
  sub_496E0(v7);
  v17 = 0;
  for ( k = 0; k < (int)*(unsigned __int16 *)(a1 + 0x18) && v17 < v25; ++k )
  {
    v18 = 4 * k + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v18 + 1) == 0x12 && (*(_WORD *)(v18 + 2) & 1) != 0 )
    {
      ++v17;
      sub_34B0C(v21, v22, v23);
    }
  }
  for ( m = 0; m < (int)*(unsigned __int16 *)(a1 + 0x18) && v17 < v25; ++m )
  {
    v19 = *(_DWORD *)(a1 + 0x10) + 4 * m;
    if ( *(_BYTE *)(v19 + 1) == 0x13 && (*(_WORD *)(v19 + 2) & 1) != 0 )
    {
      v17 += 2;
      if ( v17 <= v25 )
      {
        sub_34B0C(v21, v22, v23);
      }
    }
  }
  if ( v24 > SHIDWORD(v21) || (_DWORD)v21 == 0xFFFFFFFF )
  {
    if ( *(_BYTE *)(a1 + 0x57) == (_BYTE)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10 )
    {
      sub_55AEC((int)&V_Type3_stru_10AE70, 0xD, a1, 0);
    }
    sub_1D234((int)&word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)], a1, *((_WORD *)v7 + 0x2B));
    v23 = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x67) = dword_A2F6C[0];
  }
  sub_34E70(a1);
  return v23;
}
// 36F50: variable 'v21' is possibly undefined
// 36F50: variable 'v22' is possibly undefined
// 36F50: variable 'v23' is possibly undefined
// A2F6C: using guessed type int dword_A2F6C[];
// A3124: using guessed type __int16 word_A3124[5];
// A313B: using guessed type int dword_A313B;
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00037040) --------------------------------------------------------
unsigned __int16 __fastcall sub_37040(int a1)
{
  int v2; // edx
  int v3; // eax
  int v4; // esi

  sub_1D234((int)&word_A3D21[0x30 * *(__int16 *)(a1 + 0xC)], a1, 0xFFFFFFFF);
  v2 = 0;
  v3 = 0;
  while ( v2 < *(unsigned __int16 *)(a1 + 0x1A) )
  {
    v4 = v3 + *(_DWORD *)(a1 + 0x10);
    if ( *(_BYTE *)(v4 + 1) != 0x17 )
    {
      *(_BYTE *)(v4 + 1) = 0xFF;
      *(_WORD *)(*(_DWORD *)(a1 + 0x10) + v3 + 2) = 0;
    }
    v3 += 4;
    ++v2;
  }
  *(_WORD *)(a1 + 0x4C) = 0;
  *(_WORD *)(a1 + 0x42) = *(_WORD *)(a1 + 0x4C);
  *(_BYTE *)(a1 + 0x57) = 0xFF;
  return sub_34E70(a1);
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (000370B8) --------------------------------------------------------
unsigned int __fastcall sub_370B8(int a1, unsigned int count, int a3)
{
  unsigned int result; // eax
  int v5; // [esp+0h] [ebp-8Ch] BYREF
  int v6; // [esp+4h] [ebp-88h]
  int v7; // [esp+8h] [ebp-84h]
  int v8; // [esp+Ch] [ebp-80h]
  int v9; // [esp+10h] [ebp-7Ch]
  int v10; // [esp+14h] [ebp-78h]
  __int16 v11; // [esp+18h] [ebp-74h]
  int v12; // [esp+1Ah] [ebp-72h]
  int v13; // [esp+1Eh] [ebp-6Eh]
  __int16 v14; // [esp+22h] [ebp-6Ah]
  char v15[28]; // [esp+24h] [ebp-68h] BYREF
  __int16 v16; // [esp+40h] [ebp-4Ch]
  int v17; // [esp+42h] [ebp-4Ah]
  int v18; // [esp+46h] [ebp-46h]
  int v19; // [esp+4Ah] [ebp-42h]
  int v20; // [esp+4Eh] [ebp-3Eh]
  char v21[5]; // [esp+52h] [ebp-3Ah]
  char v22; // [esp+57h] [ebp-35h]
  char v23; // [esp+58h] [ebp-34h]
  char v24; // [esp+59h] [ebp-33h]
  int v25; // [esp+5Ah] [ebp-32h]
  int v26; // [esp+5Eh] [ebp-2Eh]
  int v27; // [esp+62h] [ebp-2Ah]
  char v28; // [esp+66h] [ebp-26h]
  int v29; // [esp+67h] [ebp-25h]
  int v30; // [esp+6Bh] [ebp-21h]
  int v31; // [esp+6Fh] [ebp-1Dh]
  int v32; // [esp+73h] [ebp-19h]
  int v33; // [esp+77h] [ebp-15h]

  if ( a3 != 0xFFFFFFFF )
  {
    return sub_1C098(count, a1, 0x7Bu);
  }
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v9 = 0;
  v25 = 0;
  LOWORD(v12) = 0;
  sub_1BF94((P_Type1)count, &v5, 0x7Bu);
  *(_DWORD *)a1 = v5;
  *(_DWORD *)(a1 + 4) = v6;
  *(_DWORD *)(a1 + 8) = v7;
  *(_DWORD *)(a1 + 0xC) = v8;
  *(_DWORD *)(a1 + 0x10) = v9;
  *(_DWORD *)(a1 + 0x14) = v10;
  *(_WORD *)(a1 + 0x18) = v11;
  *(_DWORD *)(a1 + 0x1A) = v12;
  *(_DWORD *)(a1 + 0x1E) = v13;
  *(_WORD *)(a1 + 0x22) = v14;
  qmemcpy((void *)(a1 + 0x24), v15, 0x1Cu);
  *(_WORD *)(a1 + 0x40) = v16;
  *(_DWORD *)(a1 + 0x42) = v17;
  *(_DWORD *)(a1 + 0x46) = v18;
  *(_DWORD *)(a1 + 0x4A) = v19;
  *(_DWORD *)(a1 + 0x4E) = v20;
  *(_WORD *)(a1 + 0x52) = *(_WORD *)v21;
  *(_BYTE *)(a1 + 0x54) = v21[2];
  *(_WORD *)(a1 + 0x55) = *(_WORD *)&v21[3];
  *(_BYTE *)(a1 + 0x57) = v22;
  *(_BYTE *)(a1 + 0x58) = v23;
  *(_BYTE *)(a1 + 0x59) = v24;
  *(_DWORD *)(a1 + 0x5A) = v25;
  *(_DWORD *)(a1 + 0x5E) = v26;
  *(_DWORD *)(a1 + 0x62) = v27;
  *(_BYTE *)(a1 + 0x66) = v28;
  *(_DWORD *)(a1 + 0x67) = v29;
  *(_DWORD *)(a1 + 0x6B) = v30;
  *(_DWORD *)(a1 + 0x6F) = v31;
  *(_DWORD *)(a1 + 0x73) = v32;
  *(_DWORD *)(a1 + 0x77) = v33;
  if ( word_A62A1 <= *(__int16 *)(a1 + 0xC) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x8E4);
  }
  if ( *(__int16 *)(a1 + 0xE) >= 5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planet.cpp", 0x8E5);
  }
  dword_A3D67[0x18 * *(__int16 *)(a1 + 0xC) + *(__int16 *)(a1 + 0xE)] = a1;
  result = 0x30 * *(__int16 *)(a1 + 0xC);
  ++word_A3D7B[result];
  return result * 2;
}
// A3D67: using guessed type int dword_A3D67[];
// A3D7B: using guessed type __int16 word_A3D7B[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (000372B0) --------------------------------------------------------
T_TypeA2 *__fastcall sub_372B0(T_TypeA2 *a1, int a2, int a3, int a4)
{
  sub_2C830(a1);
  a1->b = (int)off_95F84;
  sub_37310((int)a1, (int)a1, a3, a4);
  return a1;
}
// 95F84: using guessed type int (*off_95F84[5])();

//----- (000372CC) --------------------------------------------------------
void *__fastcall sub_372CC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95F58);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F84;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F84: using guessed type int (*off_95F84[5])();

//----- (00037310) --------------------------------------------------------
int __fastcall sub_37310(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  __int16 v5; // ax
  int v6; // ebx
  int result; // eax
  char s[56]; // [esp+0h] [ebp-40h] BYREF
  int v9; // [esp+38h] [ebp-8h]

  v9 = a4;
  v4 = a1;
  *(_BYTE *)(a1 + 0xAB) = 0xFF;
  *(_WORD *)(a1 + 0xAE) = 0xFFFF;
  v5 = *(_WORD *)(a1 + 0xAE);
  *(_BYTE *)(v4 + 0x18B) = 5;
  *(_WORD *)(v4 + 0xB0) = v5;
  v6 = 0;
  *(_WORD *)(v4 + 0xAC) = v5;
  do
  {
    v4 += 2;
    sprintf(s, "data\\planal%02d.shp", v6++);
    result = sub_1ADAC((int)dword_12FC20, s);
    *(_WORD *)(v4 + 0x173) = result;
  }
  while ( v6 < 0xB );
  return result;
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00037380) --------------------------------------------------------
int __fastcall sub_37380(int a1, int a2)
{
  return (__int16)((0x11 * a1 + 0x22 * a2 - 0x29D6) / 0x484) | (((0x11 * a1 - 0x22 * a2 - 0xC9E) / (int)0xFFFFFB7C) << 0x10);
}

//----- (000373E0) --------------------------------------------------------
int __fastcall sub_373E0(int a1, int a2)
{
  int v3; // eax

  if ( a1 > 0xD && a1 < 0x99 && a2 > 0x77 && a2 < 0x1D5 )
  {
    return (a2 - 0x77) / 0x46 + *(unsigned __int16 *)(dword_D3664 + 0x18) + 5 * ((a1 - 0xD) / 0x46);
  }
  v3 = sub_37380(a1, a2);
  return (unsigned __int16)sub_35968(dword_D3664, v3 >> 0x10, (__int16)v3);
}

//----- (0003745C) --------------------------------------------------------
int __fastcall sub_3745C(T_Type5 *a1, unsigned __int8 *a2, int a3, int a4)
{
  LONG v5; // eax
  int v6; // eax
  LONG v7; // ebp
  unsigned __int16 v8; // bx
  void *v9; // eax
  void *v10; // eax
  const char *v11; // ecx
  T_Rect *p_rect; // esi
  LONG v14; // [esp-20h] [ebp-40h]
  LONG v15; // [esp-18h] [ebp-38h]
  int v16; // [esp+0h] [ebp-20h] BYREF
  LONG hotY; // [esp+4h] [ebp-1Ch] BYREF
  LONG shape_number; // [esp+8h] [ebp-18h] BYREF
  unsigned __int16 v19; // [esp+Ch] [ebp-14h] BYREF
  unsigned __int8 v20; // [esp+10h] [ebp-10h]

  v5 = 0xF2;
  if ( a4 )
  {
    v5 = 0x96;
  }
  VFX_pane_wipe((PANE *)a1, v5);
  v20 = *a2;
  if ( v20 != 0xFF )
  {
    v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANETALLOC", 0);
    sub_39390(v6, v20, (__int16 *)&v19, &shape_number);
    v7 = (LONG)sub_10000;
    if ( v20 == 0x17 )
    {
      v7 = 0x8000;
    }
    v8 = shape_number;
    v9 = (void *)sub_1B084((unsigned int)dword_12FC20, v19);
    sub_2BC40(a1, v9, v8, &v16, &hotY);
    v15 = hotY;
    v14 = (unsigned __int16)shape_number;
    v10 = (void *)sub_1B084((unsigned int)dword_12FC20, v19);
    VFX_shape_transform((PANE *)a1, v10, v14, 0x28, v15, buffer, 0, v7, v7, 0);
  }
  v11 = (const char *)&dword_103F9A[0xA * *a2 + 3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  p_rect = &a1->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = p_rect->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = p_rect->y1;
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x50, 0, v11, 1, 0xFFFFFFFF, 0xFF, 0);
}
// 10000: using guessed type void __noreturn sub_10000();
// D8DA0: using guessed type UBYTE buffer[94816];
// 103F9A: using guessed type int dword_103F9A[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00037568) --------------------------------------------------------
int __fastcall sub_37568(int a1, unsigned __int16 a2, int a3, unsigned int a4)
{
  int v4; // ecx
  int v5; // eax
  int v6; // edi
  int v7; // ebx
  int v9; // eax
  int v10; // ebx
  int i; // esi
  char *v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // edx
  unsigned __int8 v22; // ch
  char *v23; // esi
  int v24; // eax
  __int16 *v25; // edi
  int v26; // ebx
  char *sub_1CEA8; // eax
  int v28; // edx
  char v29; // cl
  int v30; // edi
  int v31; // ecx
  __int16 j; // dx
  int v33; // esi
  int v34; // eax
  char *v35; // ebx
  int v36; // eax
  char *v37; // eax
  _DWORD *v38; // edi
  __int64 *v39; // esi
  _BYTE *v40; // edi
  char v41; // al
  char v42; // al
  __int64 *v43; // esi
  _DWORD *v44; // edi
  _BYTE *v45; // edi
  char v46; // al
  char v47; // al
  unsigned int v48; // eax
  unsigned __int8 v49; // al
  unsigned __int16 v50; // bx
  int v51; // eax
  int v52; // eax
  int v53; // ebx
  int v54; // esi
  int v55; // eax
  int v56; // edi
  int v57; // esi
  const char *v58; // edi
  int v59; // eax
  int v60; // esi
  char *v61; // ecx
  int v62; // edi
  char *v63; // eax
  char *v64; // [esp-8h] [ebp-120h]
  int v65; // [esp-4h] [ebp-11Ch]
  __int64 v66; // [esp+0h] [ebp-118h] BYREF
  unsigned __int8 v67; // [esp+8h] [ebp-110h]
  unsigned __int8 v68; // [esp+Ch] [ebp-10Ch]
  int s[7]; // [esp+C8h] [ebp-50h] BYREF
  _DWORD v70[5]; // [esp+E4h] [ebp-34h]
  int v71; // [esp+F8h] [ebp-20h]
  _DWORD *v72; // [esp+FCh] [ebp-1Ch]
  unsigned int v73; // [esp+100h] [ebp-18h]
  int v74; // [esp+104h] [ebp-14h]
  int v75; // [esp+108h] [ebp-10h]
  int v76; // [esp+10Ch] [ebp-Ch]
  int v77; // [esp+110h] [ebp-8h]
  int v78; // [esp+114h] [ebp-4h]
  _BYTE savedregs[12]; // [esp+118h] [ebp+0h]

  v77 = a1;
  LOWORD(v78) = a2;
  v75 = a3;
  v73 = a4;
  v4 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0);
  v74 = v4;
  v5 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLSQUARE", 0);
  v6 = v5;
  if ( a2 >= 7u )
  {
    if ( (unsigned __int16)v78 <= 7u )
    {
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(v77 + 0x41), 4, 8, 0, 0);
      if ( (*(_DWORD *)(v77 + 0x3D) & *(_DWORD *)(v77 + 0x35) & *(_DWORD *)(v77 + 0x39)) == 0xFFFFFFFF )
      {
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v77 + 0xA7) + 0x10))(v77, 0);
      }
      return 0xFFFFFFFF;
    }
    if ( (unsigned __int16)v78 >= 0x33u )
    {
      if ( a2 > 0x33u )
      {
        if ( (unsigned __int16)v78 < 0x1C01u )
        {
          if ( (_WORD)v78 != 0x34 )
          {
            return sub_2F424(v77, *(__int16 *)&savedregs[4], v75, v73);
          }
          v60 = 0xFFFFFFFF;
          if ( v73 )
          {
            *(_WORD *)(v77 + 0xB0) = *(_WORD *)(v5 + 0xAB);
          }
          else
          {
            v61 = sub_40144(
                    (unsigned __int8 *)&byte_A2F72[0x1EE * *(unsigned __int8 *)(dword_D3664 + 0x57)],
                    dword_D3664);
            if ( !v61 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x2AD);
            }
            v60 = 0;
            sub_35B04(dword_D3664, v75, (int)v61);
          }
          v62 = sub_56DA8((int)&V_Type3_stru_10AE70, "SHIPDESSCREEN", 0);
          v63 = sub_35A70(dword_D3664, v75);
          sub_4DA7C(v62, (int)v63, v60, 0);
          sub_56B60((int)&V_Type3_stru_10AE70, 1, 8, 1);
          return 0;
        }
        else
        {
          v7 = 5 * v75 + v77;
          if ( (unsigned __int16)v78 <= 0x1C01u )
          {
            v49 = *(_BYTE *)(v7 + 0xB2);
            v50 = *(_WORD *)(v77 + 0xAE);
            *(_BYTE *)(v77 + 0xAB) = v49;
            if ( v50 == 0xFFFF )
            {
              if ( v49 != 0xFF && (word_103FA2[0x14 * v49] & 2) != 0 )
              {
                sub_34B0C(v66, v67, v68);
                *(_BYTE *)(v77 + 0xAB) = 0xFF;
              }
            }
            else if ( v49 != 0xFF )
            {
              if ( sub_34368(dword_D3664, *(_BYTE *)(v77 + 0xAB), v50) == 0xFFFFFFFF )
              {
                if ( *(_BYTE *)(v77 + 0xAB) == 0x17 )
                {
                  *(_WORD *)(v77 + 0xB0) = *(_WORD *)(v77 + 0xAE);
                }
                sub_34B0C(v66, v67, v68);
              }
              v51 = v77;
              *(_BYTE *)(v77 + 0xAB) = 0xFF;
              *(_WORD *)(v51 + 0xAC) = 0xFFFF;
              *(_WORD *)(v77 + 0xAE) = *(_WORD *)(v51 + 0xAC);
            }
            sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v74 + 0x41), 2, 0, 0);
            v52 = *(unsigned __int16 *)(v77 + 0xB0);
            if ( (unsigned __int16)v52 == 0xFFFF )
            {
              (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v77 + 0xA7) + 0xC))(v77, 0);
            }
            else
            {
              (*(void (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)(v77 + 0xA7) + 8))(v77, 0x34, v52, 0);
            }
            return 0;
          }
          else
          {
            if ( (_WORD)v78 != 0x1C02 )
            {
              return sub_2F424(v77, *(__int16 *)&savedregs[4], v75, v73);
            }
            v53 = *(unsigned __int8 *)(v7 + 0xB2);
            if ( v53 != 0xFF )
            {
              sub_56B60((int)&V_Type3_stru_10AE70, 5, v53, 5);
            }
            return 0xFFFFFFFF;
          }
        }
      }
      if ( (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
      {
        if ( v75 == 1 )
        {
          *(_WORD *)(v77 + 0xAE) = 0xFFFF;
        }
        v55 = v74;
        v56 = v77;
        *(_DWORD *)(v74 + 0xAB) = 0;
        v57 = v77;
        *(_WORD *)(v55 + 0x8C9) = 0x4B;
        *(_BYTE *)(v55 + 0xC6) = 0xF2;
        sub_2F1C8(v55, (int)sub_3745C);
        v71 = 0;
        v76 = 0;
        v58 = (const char *)(v56 + 0xB2);
        sub_2ED4C(v74);
        do
        {
          if ( (_BYTE)v76 != 5 && sub_34368(dword_D3664, v76, *(_WORD *)(v77 + 0xAE)) )
          {
            v59 = v74;
            *(_BYTE *)(v57 + 0xB2) = v76;
            *(_DWORD *)(v57 + 0xB3) = 0;
            sub_2EA8C(v59, v58, 0xFFFFFFFF, 0);
            v57 += 5;
            v58 += 5;
            ++v71;
          }
          ++v76;
        }
        while ( v76 < 0x27 );
        if ( v71 )
        {
          sub_2D258(v77, 6);
          sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v74 + 0x41), 1, 0, 0);
        }
      }
LABEL_153:
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v77 + 0xA7) + 0xC))(v77, 0);
      return 0;
    }
    if ( (unsigned __int16)v78 <= 8u )
    {
      if ( !*(_DWORD *)(v4 + 0x35) && !*(_DWORD *)(v5 + 0x35) )
      {
        v16 = v77;
        *(_WORD *)(v77 + 0xAC) = sub_373E0(v75, v73);
        if ( *(_BYTE *)(dword_D3664 + 0x57) != (_BYTE)byte_104BEA
          && *(_BYTE *)(v16 + 0xAB) != 5
          && *(unsigned __int16 *)(v77 + 0xAC) != 0xFFFF
          && (*(_BYTE *)(4 * *(unsigned __int16 *)(v77 + 0xAC) + *(_DWORD *)(dword_D3664 + 0x10) + 1) != 0x17
           || *((_WORD *)sub_35A70(dword_D3664, *(_WORD *)(v77 + 0xAC)) + 0x2B) != (unsigned __int8)byte_104BEA) )
        {
          *(_WORD *)(v77 + 0xAC) = 0xFFFF;
        }
        v17 = *(unsigned __int16 *)(v77 + 0xAC);
        if ( (unsigned __int16)v17 != 0xFFFF
          && *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v17 + 1) == 0x17
          && *((_WORD *)sub_35A70(dword_D3664, v17) + 0x2B) != (unsigned __int8)byte_104BEA )
        {
          *(_WORD *)(v77 + 0xAC) = 0xFFFF;
        }
        goto LABEL_153;
      }
    }
    else
    {
      if ( (_WORD)v78 != 0x32 )
      {
        return sub_2F424(v77, *(__int16 *)&savedregs[4], v75, v73);
      }
      *(_WORD *)(v77 + 0xAC) = 0xFFFF;
      if ( v75 == 0xA || v75 == 0xB )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, 0);
        (*(void (**)(void))(*(_DWORD *)(v77 + 0xA7) + 8))();
        return 0;
      }
      if ( v75 == 0xC )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, 0);
        v54 = *(_DWORD *)(v77 + 0xA7);
        *(_BYTE *)(v77 + 0xAB) = 5;
        (*(void (**)(void))(v54 + 8))();
        return 0;
      }
      if ( v75 == 4
        || (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57)
        || *(unsigned __int16 *)(v77 + 0xAE) != 0xFFFF
        && *(_BYTE *)(4 * *(unsigned __int16 *)(v77 + 0xAE) + *(_DWORD *)(dword_D3664 + 0x10) + 1) == 0x17
        && *((_WORD *)sub_35A70(dword_D3664, *(_WORD *)(v77 + 0xAE)) + 0x2B) == (unsigned __int8)byte_104BEA )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v6 + 0x41), 0x32, v75, *(unsigned __int16 *)(v77 + 0xAE));
        sub_2D258(v77, 6);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v6 + 0x41), 1, 0, 0);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v77 + 0xA7) + 0xC))(v77, 0);
        return 0;
      }
    }
    return 0;
  }
  if ( (unsigned __int16)v78 < 4u )
  {
    if ( !(_WORD)v78 )
    {
      return sub_2F424(v77, *(__int16 *)&savedregs[4], v75, v73);
    }
    if ( a2 > 1u )
    {
      if ( (_WORD)v78 != 3 )
      {
        return sub_2F424(v77, *(__int16 *)&savedregs[4], v75, v73);
      }
      if ( v73 < 0x17 )
      {
        if ( v73 < 0x13 )
        {
          if ( v73 == 1 )
          {
            if ( *(_DWORD *)(v4 + 0x35) )
            {
              sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v4 + 0x41), 2, 0, 0);
            }
            else if ( *(_DWORD *)(v5 + 0x35) )
            {
              sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, *(_DWORD *)(v4 + 0x35));
            }
            else
            {
              sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
            }
          }
        }
        else if ( v73 <= 0x13 )
        {
          if ( dword_A0CFC )
          {
            if ( *(unsigned __int8 *)(dword_D3664 + 0x57) == 0xFF )
            {
              *(_BYTE *)(dword_D3664 + 0x57) = byte_104BEA;
            }
            else
            {
              sub_1D234(
                (int)&word_A3D21[0x30 * *(__int16 *)(dword_D3664 + 0xC)],
                dword_D3664,
                (unsigned __int8)byte_104BEA);
            }
          }
        }
        else if ( v73 == 0x14 && dword_A0CFC )
        {
          v20 = dword_D3664;
          *(_WORD *)(dword_D3664 + 0x42) += 2;
          sub_34AE4(v20, 5u, 0xFFFFFFFF);
        }
      }
      else if ( v73 <= 0x17 )
      {
        if ( dword_A0CFC )
        {
          v18 = dword_D3664;
          *(_WORD *)(dword_D3664 + 0x50) += 0xC8;
          sub_352E0(v18);
        }
      }
      else if ( v73 < 0x1F )
      {
        if ( v73 == 0x18 && dword_A0CFC )
        {
          *(_WORD *)(dword_D3664 + 0x42) = *(_WORD *)(dword_D3664 + 0x4A);
        }
      }
      else if ( v73 <= 0x1F )
      {
        *(_BYTE *)(v77 + 0x18B) ^= 1u;
      }
      else if ( v73 >= 0x31 )
      {
        if ( v73 <= 0x31 )
        {
          if ( dword_A0CFC )
          {
            sub_352E0(dword_D3664);
          }
        }
        else if ( v73 == 0x32 )
        {
          if ( ::a3 )
          {
            if ( dword_A0CFC )
            {
              v19 = dword_D3664;
              ++*(_WORD *)(dword_D3664 + 0x55);
              sub_34E70(v19);
            }
          }
          else
          {
            *(_DWORD *)(dword_D3664 + 0x5A) = ~*(_DWORD *)(dword_D3664 + 0x5A);
          }
        }
      }
      goto LABEL_153;
    }
    v70[0] = off_96850[0];
    v70[1] = off_96850[1];
    v70[2] = off_96850[2];
    v70[3] = off_96850[3];
    v70[4] = off_96850[4];
    for ( i = 0; i != 5; ++i )
    {
      v12 = (char *)v70[i];
      sub_56D70((int)&V_Type3_stru_10AE70, v12, *(__int16 *)&savedregs[4], v75, v73);
    }
    v13 = v77;
    *(_DWORD *)(v77 + 0x35) = 0xFFFFFFFF;
    *(_DWORD *)(v13 + 0x39) = 0xFFFFFFFF;
    *(_BYTE *)(v13 + 0xAB) = 0xFF;
    *(_WORD *)(v13 + 0xAC) = 0xFFFF;
    v14 = v77;
    *(_WORD *)(v77 + 0xAE) = *(_WORD *)(v13 + 0xAC);
    if ( *(unsigned __int16 *)(v14 + 0xB0) != 0xFFFF )
    {
      sub_394BC(v14);
    }
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v77 + 0xA7) + 0xC))(v77, 0);
    if ( dword_10467C )
    {
      sub_557D4(&V_Type3_stru_10AE70, dword_104680, (const char *)dword_10467C, 0x14);
      dword_10467C = 0;
    }
    return 0;
  }
  if ( a2 > 4u )
  {
    if ( (unsigned __int16)v78 <= 5u )
    {
      v9 = v77;
      *(_BYTE *)(v77 + 0xAB) = 0xFF;
      v10 = *(_DWORD *)(v9 + 0xA7);
      *(_WORD *)(v9 + 0xAE) = 0xFFFF;
      (*(void (**)(void))(v10 + 0xC))();
      return 0xFFFFFFFF;
    }
    else
    {
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(v77 + 0x41), 8);
      if ( (*(_DWORD *)(v77 + 0x3D) & *(_DWORD *)(v77 + 0x35) & *(_DWORD *)(v77 + 0x39)) == 0xFFFFFFFF )
      {
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v77 + 0xA7) + 0xC))(v77, 0);
      }
      return 0xFFFFFFFF;
    }
  }
  v15 = *(_DWORD *)(v77 + 0x35);
  if ( !v15 )
  {
    return v15;
  }
  if ( *(_DWORD *)(v4 + 0x35) )
  {
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v4 + 0x41), 2, 0, 0);
  }
  else if ( *(_DWORD *)(v5 + 0x35) )
  {
    sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v5 + 0x41), 2, 0, *(_DWORD *)(v4 + 0x35));
  }
  else
  {
    v21 = v77;
    *(_WORD *)(v77 + 0xAE) = *(_WORD *)(v77 + 0xAC);
    if ( *(unsigned __int16 *)(v21 + 0xAE) == 0xFFFF )
    {
      if ( *(_BYTE *)(v21 + 0xAB) != 0xFF )
      {
        *(_BYTE *)(v21 + 0xAB) = 0xFF;
      }
    }
    else
    {
      if ( *(__int16 *)(v21 + 0x59) != 0xFFFFFFFF )
      {
        sub_4FB90((int)&unk_10914C, *(_WORD *)(v21 + 0x59));
      }
      v22 = *(_BYTE *)(v77 + 0xAB);
      if ( v22 == 0xFF )
      {
        (*(void (**)(void))(*(_DWORD *)(v77 + 0xA7) + 8))();
        return 0;
      }
      if ( sub_34368(dword_D3664, v22, *(_WORD *)(v77 + 0xAE)) )
      {
        if ( *(_BYTE *)(v77 + 0xAB) == 5 )
        {
          v23 = sub_35A70(dword_D3664, *(_WORD *)(v6 + 0xAB));
          v24 = sub_4937C((int)v23, 0x47);
          sub_492F8(v23, v24);
          v25 = &word_A3D21[0x30 * *(__int16 *)(dword_D3664 + 0xC)];
          if ( *(unsigned __int8 *)(dword_D3664 + 0x57) != 0xFF )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x1C6);
          }
          v26 = dword_D3664;
          sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1F);
          sub_557D4(&V_Type3_stru_10AE70, sub_1CEA8, (const char *)(v26 + 0x24), 0x14);
          v28 = dword_D3664;
          v29 = v23[0x56];
          *(_BYTE *)(dword_D3664 + 0x57) = v29;
          *((_BYTE *)v25 + 0x14) |= 1 << v29;
          *(_WORD *)(v28 + 0x42) = 2;
          *(_DWORD *)(v28 + 0x67) = dword_A2F6C[0];
          v30 = 0;
          sub_34B0C(v66, v67, v68);
          v31 = 0xFFFFFFFF;
          memset(s, 0, sizeof(s));
          for ( j = 0; j < SHIWORD(dword_A3CF2); ++j )
          {
            v33 = 0x1EE * j;
            if ( !*(int *)((char *)&dword_A2F75 + v33) )
            {
              v34 = sub_402E0(&byte_A2F72[v33]);
              s[j] = v34;
              if ( v30 < v34
                && (j == (unsigned __int8)byte_104BEA || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + j]) )
              {
                v31 = j;
                v30 = s[j];
              }
            }
          }
          if ( v31 < 0 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x1E9);
          }
          v72 = (_DWORD *)sub_56DA8((int)&V_Type3_stru_10AE70, "HELPWINDOW", 0);
          v35 = "colonize";
          if ( v31 == (unsigned __int8)byte_104BEA )
          {
            v35 = "maxcolonize";
          }
          sub_2FCB0(v72, "help.txt", v35);
          v65 = s[v31];
          v64 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * v31)];
          if ( s[(unsigned __int8)byte_104BEA] == 1 )
          {
            v36 = 0x20;
          }
          else
          {
            v36 = 0x21;
          }
          v37 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v36);
          v38 = v72;
          sprintf(
            (char *)&v66,
            *(const char **)((char *)v72 + 0xC9A),
            &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
            s[(unsigned __int8)byte_104BEA],
            v37,
            v64,
            v65);
          v39 = &v66;
          v40 = *(_BYTE **)((char *)v38 + 0xC9A);
          do
          {
            v41 = *(_BYTE *)v39;
            *v40 = *(_BYTE *)v39;
            if ( !v41 )
            {
              break;
            }
            v42 = *((_BYTE *)v39 + 1);
            v39 = (__int64 *)((char *)v39 + 2);
            v40[1] = v42;
            v40 += 2;
          }
          while ( v42 );
          *(_WORD *)((char *)v72 + 0xCB1) = 0x1D;
          *(_WORD *)((char *)v72 + 0xCB3) = *(_WORD *)(dword_D3664 + 0x14) + 5 * *(_WORD *)(dword_D3664 + 0x16);
          v43 = &v66;
          v44 = v72;
          sprintf((char *)&v66, (const char *)v72[0x334], dword_D3664 + 0x24);
          v45 = (_BYTE *)v44[0x334];
          do
          {
            v46 = *(_BYTE *)v43;
            *v45 = *(_BYTE *)v43;
            if ( !v46 )
            {
              break;
            }
            v47 = *((_BYTE *)v43 + 1);
            v43 = (__int64 *)((char *)v43 + 2);
            v45[1] = v47;
            v45 += 2;
          }
          while ( v47 );
          sub_56B60((int)&V_Type3_stru_10AE70, 5, 0, 0);
          *(_BYTE *)(v77 + 0xAB) = 0xFF;
        }
        else
        {
          v48 = sub_34B0C(v66, v67, v68);
          if ( *(_BYTE *)(v77 + 0xAB) == 0x17 && v48 == 0xFFFFFFFF )
          {
            *(_WORD *)(v77 + 0xB0) = *(_WORD *)(v77 + 0xAE);
          }
          *(_BYTE *)(v77 + 0xAB) = 0xFF;
        }
      }
    }
  }
  (*(void (**)(void))(*(_DWORD *)(v77 + 0xA7) + 8))();
  return 0;
}
// 37B38: conditional instruction was optimized away because ch.1!=FF
// 96850: using guessed type char *off_96850[5];
// A0CFC: using guessed type int dword_A0CFC;
// A2F6C: using guessed type int dword_A2F6C[];
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 10467C: using guessed type int dword_10467C;
// 37568: using guessed type int s[7];

//----- (000384B0) --------------------------------------------------------
void __fastcall sub_384B0(int a1)
{
  int v2; // eax
  void *v3; // eax
  void *v4; // eax
  void *v5; // eax
  char v6; // ah
  int v7; // ebx
  unsigned int v8; // eax
  unsigned __int8 *v9; // edx
  unsigned __int16 v10; // di
  int v11; // esi
  int v12; // eax
  LONG v13; // ebx
  LONG v14; // ecx
  int v15; // eax
  int v16; // edx
  int v17; // eax
  int v18; // esi
  int v19; // eax
  LONG v20; // edx
  LONG v21; // ebx
  int v22; // eax
  int i; // esi
  int v24; // eax
  LONG v25; // edi
  LONG v26; // edx
  int v27; // eax
  unsigned __int16 v28; // di
  void *v29; // esi
  int v30; // esi
  unsigned __int8 v31; // al
  void *v32; // eax
  int v33; // eax
  unsigned int v34; // eax
  char v35; // dl
  LONG v36; // esi
  int v37; // edx
  int v38; // edx
  unsigned __int16 v39; // si
  int v40; // eax
  LONG v41; // esi
  int v42; // ecx
  int v43; // edi
  unsigned __int8 v44; // al
  void *v45; // eax
  BOOL v46; // edi
  void *v47; // eax
  void *v48; // [esp-24h] [ebp-3B8h]
  void *v49; // [esp-24h] [ebp-3B8h]
  LONG v50; // [esp-20h] [ebp-3B4h]
  LONG v51; // [esp-20h] [ebp-3B4h]
  LONG v52; // [esp-20h] [ebp-3B4h]
  LONG v53; // [esp-1Ch] [ebp-3B0h]
  LONG v54; // [esp-1Ch] [ebp-3B0h]
  LONG v55; // [esp-1Ch] [ebp-3B0h]
  LONG v56; // [esp-18h] [ebp-3ACh]
  LONG v57; // [esp-18h] [ebp-3ACh]
  LONG v58; // [esp-18h] [ebp-3ACh]
  LONG v59; // [esp-Ch] [ebp-3A0h]
  LONG v60; // [esp-Ch] [ebp-3A0h]
  LONG v61; // [esp-8h] [ebp-39Ch]
  LONG v62; // [esp-4h] [ebp-398h]
  UBYTE v63[256]; // [esp+0h] [ebp-394h] BYREF
  UBYTE s[256]; // [esp+100h] [ebp-294h] BYREF
  LONG x0; // [esp+200h] [ebp-194h] BYREF
  LONG y0[5]; // [esp+204h] [ebp-190h]
  int v67; // [esp+218h] [ebp-17Ch]
  int v68; // [esp+21Ch] [ebp-178h]
  LONG v69; // [esp+230h] [ebp-164h]
  int v70; // [esp+234h] [ebp-160h]
  int v71; // [esp+248h] [ebp-14Ch]
  int v72; // [esp+24Ch] [ebp-148h]
  LONG x1; // [esp+260h] [ebp-134h] BYREF
  LONG y1[5]; // [esp+264h] [ebp-130h]
  int v75; // [esp+278h] [ebp-11Ch]
  int v76; // [esp+27Ch] [ebp-118h]
  int v77; // [esp+280h] [ebp-114h]
  LONG v78; // [esp+290h] [ebp-104h]
  int v79; // [esp+294h] [ebp-100h]
  int v80; // [esp+298h] [ebp-FCh]
  int v81; // [esp+2A8h] [ebp-ECh]
  int v82; // [esp+2ACh] [ebp-E8h]
  int v83; // [esp+2B0h] [ebp-E4h]
  PANE v84; // [esp+2C0h] [ebp-D4h] BYREF
  PANE pane; // [esp+2D4h] [ebp-C0h] BYREF
  PANE v86; // [esp+2E8h] [ebp-ACh] BYREF
  int *v87; // [esp+2FCh] [ebp-98h] BYREF
  int v88; // [esp+300h] [ebp-94h]
  int v89; // [esp+304h] [ebp-90h]
  int v90; // [esp+308h] [ebp-8Ch]
  int v91; // [esp+30Ch] [ebp-88h]
  int v92; // [esp+310h] [ebp-84h]
  int v93; // [esp+314h] [ebp-80h]
  int v94; // [esp+318h] [ebp-7Ch]
  int v95; // [esp+31Ch] [ebp-78h]
  int v96; // [esp+320h] [ebp-74h]
  int v97; // [esp+324h] [ebp-70h]
  int v98; // [esp+328h] [ebp-6Ch]
  void *shape_table; // [esp+32Ch] [ebp-68h]
  int v100; // [esp+330h] [ebp-64h]
  int v101; // [esp+334h] [ebp-60h]
  int v102; // [esp+338h] [ebp-5Ch]
  int v103; // [esp+33Ch] [ebp-58h]
  LONG shape_number; // [esp+340h] [ebp-54h]
  int v105; // [esp+344h] [ebp-50h]
  int v106; // [esp+348h] [ebp-4Ch]
  unsigned __int8 *v107; // [esp+34Ch] [ebp-48h]
  int v108; // [esp+350h] [ebp-44h]
  int v109; // [esp+354h] [ebp-40h]
  int v110; // [esp+358h] [ebp-3Ch]
  LONG hotX; // [esp+35Ch] [ebp-38h]
  int v112; // [esp+360h] [ebp-34h]
  int v113; // [esp+364h] [ebp-30h]
  int v114; // [esp+368h] [ebp-2Ch] BYREF
  unsigned int v115; // [esp+36Ch] [ebp-28h]
  int v116; // [esp+370h] [ebp-24h]
  int v117; // [esp+374h] [ebp-20h]
  LONG v118; // [esp+378h] [ebp-1Ch] BYREF
  unsigned __int8 v119; // [esp+37Ch] [ebp-18h]

  shape_number = *(unsigned __int16 *)(dword_D3664 + 0x14);
  LOWORD(v2) = *(_WORD *)(dword_D3664 + 0x16);
  v116 = (unsigned __int16)word_FFEF8;
  v2 = (unsigned __int16)v2;
  LOWORD(v2) = *(_WORD *)(a1 + 2 * (unsigned __int16)v2 + 0x175);
  v114 = v2;
  if ( *(__int16 *)(a1 + 0x1E) != 0xFFFFFFFF )
  {
    v3 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v116);
    VFX_shape_draw((PANE *)(a1 + 4), v3, 4, 7, 0x73);
    if ( (*(_BYTE *)(a1 + 0x18B) & 4) != 0 )
    {
      v4 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
      VFX_shape_draw((PANE *)(a1 + 4), v4, shape_number, 0x198, 0x128);
    }
    v59 = *(__int16 *)(a1 + 0x1E);
    v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v116);
    VFX_shape_draw((PANE *)(a1 + 4), v5, v59, 0, 0);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
  }
  v87 = *(int **)(a1 + 4);
  v88 = *(_DWORD *)(a1 + 8);
  v89 = *(_DWORD *)(a1 + 0xC);
  v90 = *(_DWORD *)(a1 + 0x10);
  v91 = *(_DWORD *)(a1 + 0x14);
  v6 = *(_BYTE *)(a1 + 0xAB);
  v115 = 0xFFFF;
  if ( v6 != (char)0xFF )
  {
    v115 = 0xFFFE;
    v7 = *(unsigned __int16 *)(a1 + 0xAC);
    if ( (unsigned __int16)v7 != 0xFFFF && *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v7 + 1) == 0xFF )
    {
      v8 = sub_34368(dword_D3664, *(_BYTE *)(a1 + 0xAB), v7);
      if ( v8 )
      {
        LOWORD(v8) = *(_WORD *)(a1 + 0xAC);
        v115 = v8;
      }
    }
  }
  v9 = *(unsigned __int8 **)(dword_D3664 + 0x10);
  v118 = 0xFFFF;
  v107 = v9;
  LOBYTE(v9) = *(_BYTE *)(dword_D3664 + 0x57);
  v100 = 0;
  if ( (_BYTE)v9 == (_BYTE)byte_104BEA || (unsigned __int16)sub_35930(dword_D3664, 0xB) == 0xFFFF )
  {
    v109 = 0x6E;
    v96 = 0x19A;
    v110 = 0xF * shape_number;
    do
    {
      v94 = (unsigned __int8)byte_1045B8[v110];
      v103 = v96;
      v98 = v110;
      v108 = v109;
      while ( (unsigned __int8)byte_1045B8[v98] + (unsigned __int8)byte_104604[v98] > v94 )
      {
        x1 = 0x22 * v94 + v103;
        v75 = x1 + 0x22;
        v78 = x1;
        v81 = x1 - 0x22;
        y1[0] = 0x11 * v94 + v108;
        v76 = y1[0] + 0x11;
        v79 = y1[0] + 0x22;
        v82 = y1[0] + 0x11;
        v83 = 0x960000;
        v80 = 0x960000;
        v77 = 0x960000;
        y1[1] = 0x960000;
        HIWORD(v33) = HIWORD(v107);
        v119 = v107[1];
        LOWORD(v33) = *v107;
        v117 = v33;
        v92 = dword_96864[0];
        v93 = dword_96864[1];
        v34 = sub_34368(dword_D3664, 0xFFu, v100);
        if ( *(unsigned __int16 *)(a1 + 0xAC) == v100
          && *(_BYTE *)(a1 + 0xAB) == 0xFF
          && v119 == 0xFF
          && v34 == 0xFFFFFFFF )
        {
          sub_61800(&V_Type6_stru_D8654.pane.window, 4, (int)&x1);
          goto LABEL_34;
        }
        if ( (*(_BYTE *)(a1 + 0x18B) & 1) != 0 )
        {
          v10 = 0xC;
          v113 = 0xD;
          if ( !(_WORD)v117 )
          {
            v113 = 7;
            v10 = 0;
          }
          switch ( (unsigned __int16)v117 )
          {
            case 2u:
              v10 = 0x75;
              v113 = 8;
              break;
            case 3u:
              v10 = 0x92;
              v113 = 9;
              break;
            case 4u:
              v10 = 0xFF;
              v113 = 0xA;
              break;
          }
          if ( v34 == 0xFFFFFFFF )
          {
            x0 = x1;
            y0[0] = y1[0] + 1;
            v67 = v75 - 2;
            v68 = v76;
            v69 = v78;
            v70 = v79 - 1;
            v71 = v81 + 2;
            v11 = 0;
            v72 = v82;
            do
            {
              v12 = 6 * *((char *)&v93 + v11);
              v13 = y0[v12];
              v14 = y0[v12 - 1];
              v15 = 6 * *((char *)&v92 + v11++);
              VFX_line_draw(&V_Type6_stru_D8654.pane, y0[v15 - 1], y0[v15], v14, v13, 0, v10);
            }
            while ( v11 < 4 );
            if ( (_WORD)v113 )
            {
              v16 = dword_D8D8F;
              v17 = (unsigned __int16)v113 << 8;
LABEL_33:
              sub_62DA5(&V_Type6_stru_D8654.pane.window, 4, (int)&x0, v16 + v17);
            }
          }
          else
          {
            x0 = x1;
            y0[0] = y1[0] + 0xE;
            v67 = v75 - 0x1C;
            v68 = v76;
            v69 = v78;
            v70 = v79 - 0xE;
            v71 = v81 + 0x1C;
            v18 = 0;
            v72 = v82;
            do
            {
              v19 = 6 * *((char *)&v93 + v18);
              v20 = y0[v19];
              v21 = y0[v19 - 1];
              v22 = 6 * *((char *)&v92 + v18++);
              VFX_line_draw(&V_Type6_stru_D8654.pane, y0[v22 - 1], y0[v22], v21, v20, 0, v10);
            }
            while ( v18 < 4 );
            if ( (_WORD)v113 )
            {
              v17 = dword_D8D8F;
              v16 = (unsigned __int16)v113 << 8;
              goto LABEL_33;
            }
          }
        }
LABEL_34:
        if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 && *(_BYTE *)(a1 + 0xAB) == 0xFF && v119 == 0xFF )
        {
          for ( i = 0; i < 4; ++i )
          {
            v24 = 6 * *((char *)&v93 + i);
            v25 = y1[v24];
            v26 = y1[v24 - 1];
            v27 = 6 * *((char *)&v92 + i);
            VFX_line_draw(&V_Type6_stru_D8654.pane, y1[v27 - 1], y1[v27], v26, v25, 0, 0x96);
          }
        }
        if ( v119 == 0xFF && (v117 & 8) == 0 )
        {
          if ( (unsigned __int16)v115 == v100 )
          {
            sub_39390(a1, *(_BYTE *)(a1 + 0xAB), (__int16 *)&v114, &v118);
            v62 = y1[0];
            v61 = x1;
            v60 = (unsigned __int16)v118;
            v32 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
            VFX_shape_draw(&V_Type6_stru_D8654.pane, v32, v60, v61, v62);
          }
        }
        else
        {
          v28 = v100;
          sub_393F4(a1, v100, &v114, &v118);
          v29 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
          shape_table = v29;
          if ( *(unsigned __int16 *)(dword_D3664 + 0x52) == v100 )
          {
            sub_61800(&V_Type6_stru_D8654.pane.window, 4, (int)&x1);
            v30 = 0x22 * *(unsigned __int16 *)(dword_D3664 + 0x50);
            v112 = v30 / (unsigned __int16)sub_3583C(dword_D3664, v28, 0xFFu);
            v31 = 0xF2;
            if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
            {
              v31 = 0x96;
            }
            memset(s, v31, sizeof(s));
            VFX_shape_lookaside(s);
            VFX_shape_translate_draw(&V_Type6_stru_D8654.pane, shape_table, (unsigned __int16)v118, x1, y1[0]);
            pane = V_Type6_stru_D8654.pane;
            pane.y0 = y1[0] + 0x22 - v112;
            if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
            {
              VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x1500));
              VFX_shape_translate_draw(&pane, shape_table, (unsigned __int16)v118, x1, y1[0] - pane.y0);
            }
            else
            {
              VFX_shape_draw(&pane, shape_table, (unsigned __int16)v118, x1, y1[0] - pane.y0);
            }
          }
          else if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
          {
            VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x1500));
            VFX_shape_translate_draw(&V_Type6_stru_D8654.pane, v29, (unsigned __int16)v118, x1, y1[0]);
          }
          else
          {
            VFX_shape_draw(&V_Type6_stru_D8654.pane, v29, (unsigned __int16)v118, x1, y1[0]);
          }
        }
        ++v94;
        ++v100;
        v107 += 4;
      }
      v109 += 0x11;
      v96 -= 0x22;
      ++v110;
    }
    while ( v109 != 0x16D );
  }
  v97 = 0xD;
  v35 = *(_BYTE *)(dword_D3664 + 0x57);
  v106 = 0x77;
  v101 = 0;
  if ( v35 != (_BYTE)byte_104BEA && (unsigned __int16)sub_35930(dword_D3664, 0x19) != 0xFFFF )
  {
    v101 = 0xFFFFFFFF;
  }
  v100 = *(unsigned __int16 *)(dword_D3664 + 0x18);
  v95 = 4 * v100;
  hotX = v97 + 0x23;
  while ( *(unsigned __int16 *)(dword_D3664 + 0x1A) > v100 )
  {
    v38 = v95 + *(_DWORD *)(dword_D3664 + 0x10);
    v102 = 0;
    v39 = *(unsigned __int8 *)(v38 + 1);
    if ( *(_BYTE *)(v38 + 1) == 0x17 && *((_WORD *)sub_35A70(dword_D3664, v100) + 0x2B) == (unsigned __int8)byte_104BEA )
    {
      v102 = 0xFFFFFFFF;
    }
    if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
    {
      HIWORD(v40) = HIWORD(v100);
      LOWORD(v40) = v39;
      if ( v40 == 0xFF && !v101 && *(_BYTE *)(a1 + 0xAB) == 0xFF )
      {
        v88 = v97;
        v89 = v106;
        v90 = v97 + 0x46;
        v91 = v106 + 0x46;
        sub_2BB74(&v87, (int *)1, (int *)1, (int *)0x45, (int *)0x45, 0x96u, 0);
      }
    }
    v105 = v39;
    if ( v39 == 0xFF )
    {
      if ( (unsigned __int16)v115 == v100 )
      {
        v36 = (LONG)sub_10000;
        if ( *(_BYTE *)(a1 + 0xAB) == 0x17 )
        {
          v36 = 0x8000;
        }
        sub_39390(a1, *(_BYTE *)(a1 + 0xAB), (__int16 *)&v114, &v118);
        v56 = v106 + 0x23;
        v53 = hotX;
        v50 = (unsigned __int16)v118;
        v48 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
        VFX_shape_transform(&V_Type6_stru_D8654.pane, v48, v50, v53, v56, buffer, 0, v36, v36, 0);
      }
    }
    else
    {
      sub_393F4(a1, v100, &v114, &v118);
      v84 = *(PANE *)(a1 + 4);
      v41 = (LONG)sub_10000;
      if ( v105 == 0x17 )
      {
        v41 = 0x8000;
      }
      if ( *(unsigned __int16 *)(dword_D3664 + 0x52) == v100 )
      {
        v42 = 0x46 * *(unsigned __int16 *)(dword_D3664 + 0x50);
        v43 = v42 / (unsigned __int16)sub_3583C(dword_D3664, v100, 0xFFu);
        v44 = 0xF2;
        if ( *(unsigned __int16 *)(a1 + 0xAC) == v100 )
        {
          v44 = 0x96;
        }
        memset(v63, v44, sizeof(v63));
        if ( !v101 || v102 == 0xFFFFFFFF )
        {
          VFX_shape_lookaside(v63);
          v57 = v106 + 0x23;
          v54 = hotX;
          v51 = (unsigned __int16)v118;
          v45 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
          VFX_shape_transform(&V_Type6_stru_D8654.pane, v45, v51, v54, v57, buffer, 0, v41, v41, 1);
        }
        v84.y0 = v106 + 0x46 - v43;
      }
      if ( !v101 || v102 == 0xFFFFFFFF )
      {
        v46 = *(unsigned __int16 *)(a1 + 0xAC) == v100;
        VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x1500));
        v58 = v106 + 0x23 - v84.y0;
        v55 = hotX;
        v52 = (unsigned __int16)v118;
        v49 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v114);
        VFX_shape_transform(&v84, v49, v52, v55, v58, buffer, 0, v41, v41, v46);
      }
    }
    v37 = (v100 - *(unsigned __int16 *)(dword_D3664 + 0x18)) % 5;
    v106 += 0x46;
    if ( v37 == 4 )
    {
      v106 = 0x77;
      hotX += 0x46;
      v97 += 0x46;
    }
    v95 += 4;
    ++v100;
  }
  if ( *(_DWORD *)(sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0) + 0x35) == 0xFFFFFFFF )
  {
    v86.window = (WINDOW *)&V_Type6_stru_D8654;
    v86.x0 = 0x70;
    v86.y0 = 0x70;
    v86.y1 = 0x1AC;
    v86.x1 = 0x210;
    v47 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v116);
    VFX_shape_draw(&v86, v47, 5, 0, 0);
  }
  sub_2D218((_DWORD *)a1);
}
// 10000: using guessed type void __noreturn sub_10000();
// 96864: using guessed type _DWORD dword_96864[2];
// D8D8F: using guessed type int dword_D8D8F;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEF8: using guessed type __int16 word_FFEF8;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 384B0: using guessed type _DWORD var_D4[2];

//----- (00039390) --------------------------------------------------------
char __fastcall sub_39390(int a1, unsigned __int8 a2, __int16 *a3, _WORD *a4)
{
  __int16 v4; // ax

  if ( a2 >= 0x27u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x461);
  }
  *a3 = word_FFEDC;
  *a4 = 0;
  LOBYTE(v4) = a2;
  *a4 = a2;
  if ( a2 == 0x17 )
  {
    v4 = word_FFEBC[*(unsigned __int8 *)(dword_D3664 + 0x57)];
    *a3 = v4;
    *a4 = 0;
  }
  return v4;
}
// 393C3: conditional instruction was optimized away because dl.1<27u
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDC: using guessed type __int16 word_FFEDC;

//----- (000393F4) --------------------------------------------------------
__int16 __fastcall sub_393F4(int a1, unsigned __int16 a2, _WORD *a3, _WORD *a4)
{
  int v5; // eax
  _BYTE *v6; // eax
  __int16 v7; // dx
  __int16 result; // ax
  char *v9; // esi

  if ( a2 >= *(_WORD *)(dword_D3664 + 0x1A) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x476);
  }
  *a3 = word_FFEDC;
  v5 = dword_D3664;
  *a4 = 0;
  v6 = (_BYTE *)(4 * a2 + *(_DWORD *)(v5 + 0x10));
  v7 = (unsigned __int8)v6[1];
  if ( (unsigned __int8)v7 == 0xFF )
  {
    if ( (*v6 & 8) != 0 )
    {
      *a4 = 0x27;
    }
  }
  else
  {
    *a4 = v7;
  }
  result = v7;
  if ( v7 == 0x17 )
  {
    v9 = sub_35A70(dword_D3664, a2);
    *a3 = word_FFEBC[*((__int16 *)v9 + 0x2B)];
    if ( v9[0xAA] < 0 || v9[0xAA] >= 4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\planwin.cpp", 0x48A);
    }
    result = v9[0xAA];
    *a4 = result;
  }
  return result;
}
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFEDC: using guessed type __int16 word_FFEDC;

//----- (000394BC) --------------------------------------------------------
char *__fastcall sub_394BC(int a1)
{
  int v2; // esi
  char *result; // eax
  int v4; // edx
  int v5; // ebp
  char *v6; // eax
  int v7; // edx
  __int64 v8; // [esp+0h] [ebp-18h]
  unsigned __int8 v9; // [esp+8h] [ebp-10h]
  unsigned __int8 v10; // [esp+Ch] [ebp-Ch]

  v2 = sub_56DA8((int)&V_Type3_stru_10AE70, "SHIPDESSCREEN", 0);
  dword_10467C = *(_DWORD *)(v2 + 0xAB) + 0x34;
  result = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x22);
  v4 = *(_DWORD *)(v2 + 0xAB);
  dword_104680 = result;
  if ( v4 )
  {
    if ( *(_DWORD *)(v2 + 0xC9) == 0xFFFFFFFF )
    {
      dword_104680 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x23);
      *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * *(unsigned __int16 *)(a1 + 0xB0) + 2) &= ~1u;
      sub_34B0C(v8, v9, v10);
      v7 = sub_4EE00(v2);
      result = (char *)dword_D3664;
      *(_DWORD *)(dword_D3664 + 0x77) = v7;
      *(_BYTE *)(*(_DWORD *)(v2 + 0xAB) + 0x58) = 2;
      *(_DWORD *)(*(_DWORD *)(v2 + 0xAB) + 0x59) = result;
    }
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 0xC9);
    dword_10467C = 0;
    if ( !v5 )
    {
      v6 = sub_35A70(dword_D3664, *(_WORD *)(a1 + 0xB0));
      sub_49940((int)v6);
      result = (char *)sub_34B0C(v8, v9, v10);
    }
  }
  *(_WORD *)(a1 + 0xB0) = 0xFFFF;
  return result;
}
// 39540: variable 'v8' is possibly undefined
// 39540: variable 'v9' is possibly undefined
// 39540: variable 'v10' is possibly undefined
// 10467C: using guessed type int dword_10467C;

//----- (000395C4) --------------------------------------------------------
int __fastcall sub_395C4(int a1, unsigned int count, int a3)
{
  void *v5; // edx

  v5 = (void *)(a1 + 0x18B);
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, v5, 1u);
  }
  else
  {
    return sub_1C098(count, (int)v5, 1u);
  }
}

//----- (000395EC) --------------------------------------------------------
void __fastcall __spoils<> sub_395EC(P_TypeA2 result)
{
  sub_2C830(result);
  result->b = (int)off_95F6C;
}
// 95F6C: using guessed type int (*off_95F6C[5])();

//----- (000395FC) --------------------------------------------------------
void *__fastcall sub_395FC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95F44);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95F6C;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95F6C: using guessed type int (*off_95F6C[5])();

//----- (00039644) --------------------------------------------------------
unsigned int __fastcall sub_39644(int a1, __int16 a2, int a3, int a4)
{
  int v5; // eax
  int v7; // [esp+0h] [ebp-10h]

  v7 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0);
  v5 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLSQUARE", 0);
  if ( (*(_DWORD *)(v7 + 0x35) || *(_DWORD *)(v5 + 0x35)) && a2 != 0xF && a2 != 0xE )
  {
    return 0;
  }
  if ( (unsigned __int16)a2 < 6u )
  {
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 6u )
  {
    (*(void (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 2);
  }
  else
  {
    if ( a2 != 7 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    (*(void (__fastcall **)(int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 1);
  }
  return 0;
}

//----- (000396F0) --------------------------------------------------------
void __fastcall sub_396F0(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // ebp
  int v5; // eax
  LONG v6; // eax
  void *v7; // eax
  LONG v8; // eax
  LONG v9; // ebp
  LONG v10; // edi
  int i; // esi
  void *v12; // eax
  LONG v13; // eax
  char *sub_1CEA8; // eax
  unsigned __int16 v15; // bx
  unsigned __int8 v16; // cl
  char *v17; // edi
  char *v18; // esi
  char v19; // al
  char v20; // al
  unsigned __int8 v21; // ch
  int v22; // esi
  __int16 v23; // ax
  int v24; // eax
  char *v25; // eax
  char *v26; // edi
  char *v27; // esi
  char v28; // al
  char v29; // al
  LONG v30; // edi
  unsigned __int16 v31; // bx
  PANE *v32; // esi
  void *v33; // eax
  void *v34; // eax
  char *v35; // ecx
  int v36; // ebx
  LONG *p_x0; // esi
  const char *v38; // ecx
  _DWORD *v39; // esi
  int v40; // edi
  int v41; // ecx
  int v42; // ebp
  int v43; // esi
  int *v44; // edi
  int *v45; // ebp
  int j; // esi
  int *v47; // ecx
  int *v48; // ebx
  int *v49; // edx
  LONG v50; // [esp-10h] [ebp-A0h]
  LONG v51; // [esp-Ch] [ebp-9Ch]
  LONG v52; // [esp-8h] [ebp-98h]
  char *v53; // [esp+Ch] [ebp-84h]
  char s[60]; // [esp+10h] [ebp-80h] BYREF
  LONG hotX; // [esp+4Ch] [ebp-44h] BYREF
  LONG hotY; // [esp+50h] [ebp-40h] BYREF
  int *v57; // [esp+54h] [ebp-3Ch]
  int v58; // [esp+58h] [ebp-38h]
  int v59; // [esp+5Ch] [ebp-34h]
  int v60; // [esp+60h] [ebp-30h]
  PANE *pane; // [esp+64h] [ebp-2Ch]
  int **v62; // [esp+68h] [ebp-28h]
  LONG v63; // [esp+6Ch] [ebp-24h]
  int v64; // [esp+70h] [ebp-20h] BYREF
  LONG shape_number; // [esp+74h] [ebp-1Ch] BYREF
  unsigned __int8 v66; // [esp+78h] [ebp-18h]

  v60 = a1;
  v58 = 0;
  if ( a2 != 2 && (*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(a1 + 0x41) || a2 == 1) )
  {
    v58 = 0xFFFFFFFF;
  }
  v2 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANLIST", 0);
  v3 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLSQUARE", 0);
  if ( *(_DWORD *)(v2 + 0x35) || *(_DWORD *)(v3 + 0x35) )
  {
    v58 = 0;
  }
  v59 = *(_DWORD *)(v60 + 0x47);
  if ( v59 == 4 )
  {
    v59 = 3;
  }
  if ( *(_WORD *)(v60 + 0x45) == 0x33 )
  {
    v59 = 4;
  }
  v4 = sub_56DA8((int)&V_Type3_stru_10AE70, "PLANETALLOC", 0);
  v64 = 0xFFFF;
  shape_number = 0xFFFF;
  VFX_shape_lookaside((UBYTE *)(dword_D8D8F + 0x1500));
  if ( v59 <= 2 )
  {
    VFX_pane_wipe((PANE *)(v60 + 4), 0);
  }
  HIWORD(v5) = HIWORD(v59);
  switch ( v59 )
  {
    case 0:
      LOWORD(v5) = word_FFEEC;
      v64 = v5;
      v63 = (int)pow((double)*(unsigned __int16 *)(dword_D3664 + 0x46), 0.75);
      shape_number = v63;
      if ( (unsigned __int16)v63 > 0x14u )
      {
        shape_number = 0x14;
      }
      goto LABEL_23;
    case 1:
      LOWORD(v5) = word_FFEEE;
      v64 = v5;
      v63 = (int)pow((double)*(unsigned __int16 *)(dword_D3664 + 0x44), 0.75);
      shape_number = v63;
      if ( (unsigned __int16)v63 > 0x14u )
      {
        shape_number = 0x14;
      }
      goto LABEL_23;
    case 2:
      LOWORD(v5) = word_FFEF0;
      v64 = v5;
      HIWORD(v6) = HIWORD(dword_D3664);
      LOWORD(v6) = *(_WORD *)(dword_D3664 + 0x48);
      shape_number = v6;
      if ( (unsigned __int16)v6 > 0x14u )
      {
        shape_number = 0x14;
      }
LABEL_23:
      v7 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v64);
      VFX_shape_draw((PANE *)(v60 + 4), v7, (unsigned __int16)shape_number, 0, 0);
      goto LABEL_66;
    case 3:
      v8 = 0xF2;
      if ( v58 )
      {
        v8 = 0x96;
      }
      v9 = 0;
      v63 = v60 + 4;
      VFX_pane_wipe((PANE *)(v60 + 4), v8);
      v10 = 0;
      shape_number = 1;
      pane = (PANE *)(v60 + 4);
      for ( i = 0; i < *(unsigned __int16 *)(dword_D3664 + 0x4A); ++i )
      {
        if ( i == *(unsigned __int16 *)(dword_D3664 + 0x4C) )
        {
          ++shape_number;
        }
        if ( i == *(unsigned __int16 *)(dword_D3664 + 0x42) )
        {
          ++shape_number;
        }
        v12 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF8);
        VFX_shape_draw(pane, v12, (unsigned __int16)shape_number, v10, v9);
        v10 += 0xA;
        if ( i % 0xA == 9 )
        {
          v10 = 0;
          v9 += 0xA;
        }
      }
      goto LABEL_66;
    case 4:
      v13 = 0xF2;
      if ( v58 && *(_BYTE *)(dword_D3664 + 0x57) == (_BYTE)byte_104BEA )
      {
        v13 = 0x96;
      }
      VFX_pane_wipe((PANE *)(v60 + 4), v13);
      v66 = 0xFF;
      qmemcpy(s, &unk_9686C, sizeof(s));
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x24);// 36: "No Project"
      v15 = 0xFFFF;
      v16 = *(_BYTE *)(v4 + 0xAB);
      v57 = (int *)sub_1CEA8;
      if ( v16 == 0xFF )
      {
        v21 = *(_BYTE *)(dword_D3664 + 0x54);
        if ( v21 != 0xFF )
        {
          v22 = (unsigned __int16)sub_358BC(dword_D3664);
          v23 = word_103FA2[0x14 * v21];
          v66 = v21;
          if ( (v23 & 0x20) == 0 )
          {
            if ( v22 == 0xFFFF )
            {
              v26 = s;
              v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x27);// 39: "No Progress"
              do
              {
                v28 = *v27;
                *v26 = *v27;
                if ( !v28 )
                {
                  break;
                }
                v29 = v27[1];
                v27 += 2;
                v26[1] = v29;
                v26 += 2;
              }
              while ( v29 );
            }
            else
            {
              if ( v22 == 1 )
              {
                v24 = 0x1C;                            // 28: ""
              }
              else
              {
                v24 = 0x1D;                            // 29: "s"
              }
              v53 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v24);
              v25 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x26);// 38: "%d day%s until completion"
              sprintf(s, v25, v22, v53);
            }
          }
          if ( *(_BYTE *)(dword_D3664 + 0x54) != 0x23 )
          {
            v15 = *(_WORD *)(dword_D3664 + 0x52);
          }
        }
      }
      else
      {
        v17 = s;
        v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x25);// 37: "Pick a Location"
        v66 = v16;
        do
        {
          v19 = *v18;
          *v17 = *v18;
          if ( !v19 )
          {
            break;
          }
          v20 = v18[1];
          v18 += 2;
          v17[1] = v20;
          v17 += 2;
        }
        while ( v20 );
      }
      if ( v66 == 0xFF )
      {
        if ( *(_WORD *)(dword_D3664 + 0x42) != *(_WORD *)(dword_D3664 + 0x4C) )
        {
          goto LABEL_65;
        }
        v36 = 0x19;
        v32 = (PANE *)(v60 + 4);
        v35 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x28);// 40: "(No Free Population)"
      }
      else
      {
        if ( v15 == 0xFFFF )
        {
          sub_39390(v4, v66, (__int16 *)&v64, &shape_number);
        }
        else
        {
          sub_393F4(v4, v15, &v64, &shape_number);
        }
        v30 = (LONG)sub_10000;
        if ( v66 == 0x17 )
        {
          v30 = 0x8000;
        }
        v31 = shape_number;
        v57 = &dword_103F9A[0xA * v66 + 3];
        v32 = (PANE *)(v60 + 4);
        v33 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v64);
        sub_2BC40(v32, v33, v31, &hotX, &hotY);
        v52 = hotY;
        v51 = hotX;
        v50 = (unsigned __int16)shape_number;
        v34 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v64);
        VFX_shape_transform(v32, v34, v50, v51, v52, buffer, 0, v30, v30, 0);
        v35 = s;
        v36 = 0x50;
      }
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v32->window;
      p_x0 = &v32->x0;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *p_x0++;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *p_x0++;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *p_x0;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = p_x0[1];
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v36, v35, 2, 0xFFFFFFFF, 0xFF, 0);
LABEL_65:
      v38 = (const char *)v57;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(v60 + 4);
      v39 = (_DWORD *)(v60 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(v60 + 8);
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *++v39;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *++v39;
      *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v39[1];
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xA, v38, 2, 0xFFFFFFFF, 0xFF, 0);
LABEL_66:
      if ( v59 <= 2 && v58 && (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
      {
        v40 = *(_DWORD *)(v60 + 0x10);
        v41 = *(_DWORD *)(v60 + 8);
        v42 = *(_DWORD *)(v60 + 0x14);
        v43 = *(_DWORD *)(v60 + 0xC);
        v62 = (int **)(v60 + 4);
        v44 = (int *)(v40 - v41);
        v45 = (int *)(v42 - v43);
        for ( j = 0; j < 3; ++j )
        {
          v47 = v44;
          v48 = (int *)j;
          v49 = (int *)j;
          v44 = (int *)((char *)v44 + 0xFFFFFFFF);
          sub_2BB74(v62, v49, v48, v47, v45, 0x96u, 0);
          v45 = (int *)((char *)v45 + 0xFFFFFFFF);
        }
      }
      sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(v60 + 4));
      return;
    default:
      goto LABEL_66;
  }
}
// 10000: using guessed type void __noreturn sub_10000();
// D8D8F: using guessed type int dword_D8D8F;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEEC: using guessed type __int16 word_FFEEC;
// FFEEE: using guessed type __int16 word_FFEEE;
// FFEF0: using guessed type __int16 word_FFEF0;
// FFEF8: using guessed type __int16 word_FFEF8;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00039D80) --------------------------------------------------------
T_TypeA2 *__fastcall sub_39D80(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_95FB8;
  sub_39DE0();
  return a1;
}
// 95FB8: using guessed type int (*off_95FB8[5])();

//----- (00039D9C) --------------------------------------------------------
void *__fastcall sub_39D9C(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_95FA4);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_95FB8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 95FB8: using guessed type int (*off_95FB8[5])();

//----- (00039DE0) --------------------------------------------------------
char *sub_39DE0()
{
  int v0; // ebx
  int i; // edx
  char *sub_1CEA8; // eax
  int v3; // edx
  int j; // ebx
  char *v5; // eax
  int v6; // ebx
  int k; // edx
  char *result; // eax

  v0 = 0x29;
  for ( i = 0; i != 5; dword_104684[i] = (int)sub_1CEA8 )
  {
    ++i;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v0++);
  }
  v3 = 0x2E;
  for ( j = 0; j != 0xB; dword_104698[j] = (int)v5 )
  {
    ++j;
    v5 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3++);
  }
  v6 = 0x39;
  for ( k = 0; k != 8; dword_1046C4[k] = (int)result )
  {
    ++k;
    result = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v6++);
  }
  return result;
}
// 104684: using guessed type int dword_104684[];
// 104698: using guessed type int dword_104698[];
// 1046C4: using guessed type int dword_1046C4[];

//----- (00039E3C) --------------------------------------------------------
unsigned int __fastcall sub_39E3C(int a1, __int16 dx0, int a3, int a4)
{
  int v4; // eax
  char v5; // cl
  int v7; // eax
  int v8; // esi
  int v9; // eax
  char *v10; // eax
  int v11; // esi
  int v12; // ebx
  int v13; // edx
  int v14; // edi
  int v15; // ebx
  int v16; // edx
  int v17; // edi
  int v18; // ebx
  int v19; // esi
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  char *v25; // esi
  char *v26; // edi
  char v27; // al
  char v28; // al
  int v29; // edi
  int v30; // ebx
  int v31; // edx
  int v32; // eax
  int v33; // ebx
  int v34; // edx
  int v35; // edi
  char *sub_1CEA8; // esi
  char *v37; // edi
  char v38; // al
  char v39; // al
  int v40; // edx
  int v41; // ecx
  int v42; // ebx
  char *v43; // edi
  char *v44; // esi
  int v45; // ebx
  char v46; // al
  char v47; // al
  int v48; // edi
  int v49; // eax
  char *v50; // eax
  char *v51; // eax
  unsigned int v52; // esi
  char *v53; // ebx
  int v54; // ecx
  int v55; // edi
  int v56; // eax
  int v57; // eax
  char *v58; // eax
  __int64 *p_s; // esi
  _BYTE *v60; // edi
  char v61; // al
  char v62; // al
  int v63; // [esp-4h] [ebp-144h]
  char *v64; // [esp-4h] [ebp-144h]
  __int64 s; // [esp+0h] [ebp-140h] BYREF
  unsigned __int8 v66; // [esp+8h] [ebp-138h]
  unsigned __int8 v67; // [esp+Ch] [ebp-134h]
  int v68[21]; // [esp+C4h] [ebp-7Ch]
  int v69; // [esp+118h] [ebp-28h]
  int a2; // [esp+11Ch] [ebp-24h] BYREF
  int v71; // [esp+120h] [ebp-20h]
  int v72; // [esp+124h] [ebp-1Ch]
  int v73; // [esp+128h] [ebp-18h]
  int v74; // [esp+12Ch] [ebp-14h]
  int v75; // [esp+130h] [ebp-10h]
  int v76; // [esp+134h] [ebp-Ch]
  _BYTE v77[6]; // [esp+138h] [ebp-8h]
  _BYTE savedregs[12]; // [esp+140h] [ebp+0h]

  v75 = a1;
  *(_WORD *)&v77[4] = dx0;
  v69 = a3;
  v72 = a4;
  v4 = *(unsigned __int16 *)(a1 + 0xAB);
  v5 = 0xFF;
  if ( (unsigned __int16)v4 != 0xFFFF )
  {
    v5 = *(_BYTE *)(4 * v4 + *(_DWORD *)(dword_D3664 + 0x10) + 1);
  }
  if ( *(_WORD *)&v77[4] < 0x33u )
  {
    if ( *(_WORD *)&v77[4] >= 4u )
    {
      if ( *(_WORD *)&v77[4] > 5u )
      {
        if ( *(_WORD *)&v77[4] >= 7u )
        {
          if ( *(_WORD *)&v77[4] <= 7u )
          {
            if ( *(_DWORD *)(v75 + 0x39) && *(_DWORD *)(v75 + 0x35) && *(_DWORD *)(v75 + 0x3D) )
            {
              (*(void (**)(void))(*(_DWORD *)(v75 + 0xA7) + 0x10))();
            }
            return 0xFFFFFFFF;
          }
          else
          {
            if ( *(_WORD *)&v77[4] != 0x32 )
            {
              return sub_2F424(v75, *(__int16 *)&savedregs[4], v69, v72);
            }
            dword_104684[0] = v69;
            *(_WORD *)(v75 + 0xAB) = v72;
            return 0;
          }
        }
        if ( *(_DWORD *)(v75 + 0x39) && *(_DWORD *)(v75 + 0x35) && *(_DWORD *)(v75 + 0x3D) )
        {
          (*(void (**)(void))(*(_DWORD *)(v75 + 0xA7) + 0xC))();
        }
      }
      return 0xFFFFFFFF;
    }
    if ( !*(_WORD *)&v77[4] )
    {
      return sub_2F424(v75, *(__int16 *)&savedregs[4], v69, v72);
    }
    if ( *(_WORD *)&v77[4] <= 1u )
    {
      v7 = v75;
      *(_DWORD *)(v75 + 0x39) = 0xFFFFFFFF;
      v8 = dword_104684[0];
      *(_DWORD *)(v7 + 0x35) = 0xFFFFFFFF;
      if ( v8 == 3 )
      {
        HIWORD(v9) = 0;
        v73 = 0;
        if ( v5 == (char)0xFF )
        {
          v20 = 0;
          while ( (_BYTE)v20 == 5 || !sub_34368(dword_D3664, v20, *(_WORD *)(v75 + 0xAB)) )
          {
            if ( ++v20 >= 0x27 )
            {
              goto LABEL_37;
            }
          }
          v21 = v73 + 1;
          v68[v21] = 0x36;
          v73 = v21;
        }
        else
        {
          if ( v5 == 0x17 )
          {
            LOWORD(v9) = *(_WORD *)(v75 + 0xAB);
            if ( (*(_WORD *)(4 * v9 + *(_DWORD *)(dword_D3664 + 0x10) + 2) & 1) != 0 )
            {
              v10 = sub_35A70(dword_D3664, *(_WORD *)(v75 + 0xAB));
              v11 = (int)v10;
              if ( !v10 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\psqwin.cpp", 0x79);
              }
              if ( sub_4937C((int)v10, 0x47) != 0xFFFFFFFF && *(unsigned __int8 *)(dword_D3664 + 0x57) == 0xFF )
              {
                v12 = v73 + 1;
                v68[v73 + 1] = 0x34;
                v73 = v12;
              }
              if ( sub_4937C(v11, 0x49) != 0xFFFFFFFF )
              {
                v13 = *(unsigned __int8 *)(dword_D3664 + 0x57);
                if ( v13 != 0xFF && (_BYTE)v13 != (_BYTE)byte_104BEA )
                {
                  v14 = v73 + 1;
                  v68[v73 + 1] = 0x39;
                  v73 = v14;
                }
              }
              v68[v73 + 1] = 0x37;
              v15 = v73;
              v16 = (unsigned __int16)sub_35930(dword_D3664, 0x18);
              v73 = v15 + 1;
              if ( (unsigned __int16)v16 != 0xFFFF
                && (*(_WORD *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v16 + 2) & 1) != 0
                && (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
              {
                v17 = v73 + 1;
                v68[v73 + 1] = 0x38;
                v73 = v17;
              }
            }
          }
          if ( v5 != 5 )
          {
            v18 = v73 + 1;
            v68[v73 + 1] = 0x35;
            v73 = v18;
          }
          if ( sub_34368(dword_D3664, 0x23u, *(_WORD *)(v75 + 0xAB)) )
          {
            v19 = v73 + 1;
            v68[v73 + 1] = 0x3A;
            v73 = v19;
          }
        }
LABEL_37:
        *(_DWORD *)v77 = 0xA0;
        v22 = v73 + 1;
        v68[v73 + 1] = 0x33;
        v73 = v22;
        if ( v22 > 0 )
        {
          v74 = v22;
          v76 = 0;
          v71 = 4 * v22;
          do
          {
            v23 = v76;
            v24 = *(_DWORD *)(v76 + *(_DWORD *)(v75 + 0x67));
            v25 = (char *)dword_1045FC[v68[v76 / 4u + 1]];
            v26 = (char *)(v24 + 0x20);
            do
            {
              v27 = *v25;
              *v26 = *v25;
              if ( !v27 )
              {
                break;
              }
              v28 = v25[1];
              v25 += 2;
              v26[1] = v28;
              v26 += 2;
            }
            while ( v28 );
            v29 = v74;
            *(_WORD *)(v24 + 0x45) = *(_WORD *)((char *)&v68[1] + v23);
            v30 = *(_DWORD *)v77;
            v31 = 0x1DF - *(_DWORD *)v77;
            *(_DWORD *)(v24 + 8) = *(_DWORD *)v77;
            *(_DWORD *)(v24 + 0xC) = 0x151;
            *(_DWORD *)(v24 + 0x14) = 0x16F;
            *(_DWORD *)v77 = v31 / v29 + v30;
            if ( *(int *)v77 > 0x1DF )
            {
              *(_DWORD *)v77 = 0x1DF;
            }
            v32 = *(_DWORD *)v77;
            v33 = *(__int16 *)&savedregs[4];
            v63 = v72;
            *(_DWORD *)(v24 + 0x10) = *(_DWORD *)v77;
            v34 = *(_DWORD *)(v24 + 0x41);
            *(_DWORD *)v77 = v32 + 1;
            sub_56D30((int)&V_Type3_stru_10AE70, v34, v33, v69, v63);
            --v74;
            v76 += 4;
          }
          while ( v76 < v71 );
        }
        if ( v73 == 1 )
        {
          v35 = v75;
          sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
          v37 = (char *)(**(_DWORD **)(v35 + 0x67) + 0x20);
          do
          {
            v38 = *sub_1CEA8;
            *v37 = *sub_1CEA8;
            if ( !v38 )
            {
              break;
            }
            v39 = sub_1CEA8[1];
            sub_1CEA8 += 2;
            v37[1] = v39;
            v37 += 2;
          }
          while ( v39 );
        }
      }
      else
      {
        v40 = **(_DWORD **)(v7 + 0x67);
        *(_DWORD *)(v40 + 8) = 0xA0;
        *(_DWORD *)(v40 + 0xC) = 0x151;
        v41 = v69;
        *(_DWORD *)(v40 + 0x10) = 0x1DF;
        v42 = *(_DWORD *)&v77[2];
        *(_DWORD *)(v40 + 0x14) = 0x16F;
        v43 = (char *)(v40 + 0x20);
        v44 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
        v45 = v42 >> 0x10;
        do
        {
          v46 = *v44;
          *v43 = *v44;
          if ( !v46 )
          {
            break;
          }
          v47 = v44[1];
          v44 += 2;
          v43[1] = v47;
          v43 += 2;
        }
        while ( v47 );
        v48 = v72;
        *(_WORD *)(v40 + 0x45) = 0x33;
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v40 + 0x41), v45, v41, v48);
      }
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(v75 + 0xA7) + 0xC))(v75, 0);
      return 0;
    }
    else
    {
      if ( *(_WORD *)&v77[4] != 2 )
      {
        return sub_2F424(v75, *(__int16 *)&savedregs[4], v69, v72);
      }
      sub_2D258(v75, *(__int16 *)&savedregs[4]);
      v49 = v75;
      *(_DWORD *)(v75 + 0x39) = 0;
      *(_DWORD *)(v49 + 0x35) = 0;
      if ( *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] == *(_DWORD *)(v75 + 0x41) )
      {
        *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3002] = 0xFFFFFFFF;
      }
      sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x41), 0xFFFFFFFF);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x41), 0xFFFFFFFF);
      return 0;
    }
  }
  else
  {
    if ( *(_WORD *)&v77[4] <= 0x33u )
    {
LABEL_88:
      sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x32, 0xA, 0);
      return 0;
    }
    if ( *(_WORD *)&v77[4] < 0x37u )
    {
      if ( *(_WORD *)&v77[4] < 0x35u )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x32, 0xC, 0);
        return 0;
      }
      else if ( *(_WORD *)&v77[4] <= 0x35u )
      {
        if ( v5 == 0x17 )
        {
          v50 = sub_35A70(dword_D3664, *(_WORD *)(v75 + 0xAB));
          sub_49940((int)v50);
        }
        sub_34B0C(s, v66, v67);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x32, 0xA, 0);
        return 0;
      }
      else
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x32, 0xB, 0);
        return 0;
      }
    }
    else
    {
      if ( *(_WORD *)&v77[4] <= 0x37u )
      {
        v51 = sub_35A70(dword_D3664, *(_WORD *)(v75 + 0xAB));
        sub_35C38(dword_D3664, (int)v51);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x32, 0xA, 0);
        return 0;
      }
      if ( *(_WORD *)&v77[4] < 0x39u )
      {
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x32, 0xA, 0);
        sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x34, *(unsigned __int16 *)(v75 + 0xAB), 1);
        return 0;
      }
      if ( *(_WORD *)&v77[4] > 0x39u )
      {
        if ( *(_WORD *)&v77[4] != 0x3A )
        {
          return sub_2F424(v75, *(__int16 *)&savedregs[4], v69, v72);
        }
        sub_34B0C(s, v66, v67);
        goto LABEL_88;
      }
      v52 = sub_36CD4(dword_D3664, *(_WORD *)(v75 + 0xAB), &a2);
      v53 = "invadefailure";
      v54 = sub_56DA8((int)&V_Type3_stru_10AE70, "HELPWINDOW", 0);
      if ( v52 == 0xFFFFFFFF )
      {
        v53 = "invadesuccess";
      }
      v55 = sub_402E0(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
      sub_2FCB0((_DWORD *)v54, "help.txt", v53);
      if ( v55 == 1 )
      {
        v56 = 0x20;
      }
      else
      {
        v56 = 0x21;
      }
      v64 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v56);
      if ( a2 == 1 )
      {
        v57 = 0x1C;
      }
      else
      {
        v57 = 0x1D;
      }
      v58 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v57);
      sprintf((char *)&s, *(const char **)(v54 + 0xC9A), dword_D3664 + 0x24, a2, v58, v55, v64);
      p_s = &s;
      v60 = *(_BYTE **)(v54 + 0xC9A);
      do
      {
        v61 = *(_BYTE *)p_s;
        *v60 = *(_BYTE *)p_s;
        if ( !v61 )
        {
          break;
        }
        v62 = *((_BYTE *)p_s + 1);
        p_s = (__int64 *)((char *)p_s + 2);
        v60[1] = v62;
        v60 += 2;
      }
      while ( v62 );
      *(_WORD *)(v54 + 0xCB1) = 0x1C;
      *(_WORD *)(v54 + 0xCB3) = 0x49;
      *(_WORD *)(v54 + 0xCCC) = 0x1D;
      *(_WORD *)(v54 + 0xCCE) = *(_WORD *)(dword_D3664 + 0x14) + 5 * *(_WORD *)(dword_D3664 + 0x16);
      sub_56D30((int)&V_Type3_stru_10AE70, *(_DWORD *)(v75 + 0x63), 0x32, 0xA, 0);
      sub_56B60((int)&V_Type3_stru_10AE70, 5, 0, 0);
      return 0;
    }
  }
}
// 1045FC: using guessed type int dword_1045FC[];
// 104684: using guessed type int dword_104684[];

//----- (0003A6BC) --------------------------------------------------------
void __fastcall sub_3A6BC(int a1)
{
  PANE *v1; // esi
  void *v2; // eax
  int v3; // eax
  char *sub_1CEA8; // eax
  int v5; // esi
  int v6; // edx
  int v7; // ebx
  char *v8; // eax
  int v9; // edx
  unsigned __int8 v10; // al
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // si
  unsigned __int16 v13; // ax
  int v14; // eax
  unsigned __int16 v15; // dx
  unsigned __int16 v16; // bx
  int v17; // eax
  unsigned __int16 v18; // bx
  char v19; // al
  char *v20; // edi
  int *v21; // esi
  char v22; // al
  char v23; // al
  char *v24; // eax
  char *v25; // eax
  const char *v26; // ebx
  char *v27; // eax
  unsigned __int16 v28; // dx
  unsigned __int16 v29; // cx
  unsigned __int16 v30; // si
  unsigned __int16 v31; // ax
  int v32; // eax
  int v33; // edx
  char *v34; // edi
  char *v35; // esi
  char v36; // al
  char v37; // al
  int v38; // eax
  char *v39; // eax
  char *v40; // edi
  char *v41; // esi
  char v42; // al
  char v43; // al
  char *v44; // eax
  char *v45; // edi
  char *v46; // esi
  char v47; // al
  char v48; // al
  char *v49; // edi
  char *v50; // esi
  char v51; // al
  char v52; // al
  char *v53; // edi
  char *v54; // esi
  char v55; // al
  char v56; // al
  char *v57; // eax
  char *v58; // eax
  char *v59; // edi
  char *v60; // esi
  char v61; // al
  char v62; // al
  char *v63; // edi
  char *v64; // esi
  char v65; // al
  char v66; // al
  char *v67; // eax
  char *v68; // eax
  char *v69; // ecx
  char *v70; // eax
  int v71; // eax
  char *v72; // eax
  char *v73; // [esp-10h] [ebp-1AAh]
  __int16 v74; // [esp-Ch] [ebp-1A6h]
  int v75; // [esp-Ch] [ebp-1A6h]
  char *v76; // [esp-Ch] [ebp-1A6h]
  char *v77; // [esp-8h] [ebp-1A2h]
  int v78; // [esp-8h] [ebp-1A2h]
  int v79; // [esp-8h] [ebp-1A2h]
  int v80; // [esp-8h] [ebp-1A2h]
  int v81; // [esp-8h] [ebp-1A2h]
  char *v82; // [esp-4h] [ebp-19Eh]
  char *v83; // [esp-4h] [ebp-19Eh]
  char *v84; // [esp-4h] [ebp-19Eh]
  int v85; // [esp-4h] [ebp-19Eh]
  int v86; // [esp-4h] [ebp-19Eh]
  int v87; // [esp-4h] [ebp-19Eh]
  int v88; // [esp-4h] [ebp-19Eh]
  char *v89; // [esp-4h] [ebp-19Eh]
  char v90[152]; // [esp+0h] [ebp-19Ah] BYREF
  char v91[100]; // [esp+98h] [ebp-102h] BYREF
  char v92[100]; // [esp+FCh] [ebp-9Eh] BYREF
  char s[52]; // [esp+160h] [ebp-3Ah] BYREF
  char v94[52]; // [esp+194h] [ebp-6h] BYREF
  int v95; // [esp+1C8h] [ebp+2Eh]
  int v96; // [esp+1CCh] [ebp+32h]
  int v97; // [esp+1D0h] [ebp+36h]
  int v98; // [esp+1D4h] [ebp+3Ah]
  int v99; // [esp+1D8h] [ebp+3Eh]
  char v100[20]; // [esp+1DCh] [ebp+42h] BYREF
  int a2; // [esp+1F0h] [ebp+56h]
  char *v102; // [esp+1F4h] [ebp+5Ah]
  char *v103; // [esp+1F8h] [ebp+5Eh]
  char *format; // [esp+1FCh] [ebp+62h]
  char *v105; // [esp+200h] [ebp+66h]
  char *v106; // [esp+204h] [ebp+6Ah]
  int v107; // [esp+208h] [ebp+6Eh]
  int v108; // [esp+20Ch] [ebp+72h]
  _DWORD *v109; // [esp+210h] [ebp+76h]
  int v110; // [esp+214h] [ebp+7Ah]
  char *v111; // [esp+218h] [ebp+7Eh]

  v109 = (_DWORD *)a1;
  v1 = (PANE *)(a1 + 4);
  sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
  VFX_pane_wipe(v1, 0xF2);
  v2 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEEA);
  v107 = 0;
  VFX_shape_draw(v1, v2, 0, 0, 0);
  v95 = v109[1];
  v96 = v109[2];
  v97 = v109[3];
  v98 = v109[4];
  v99 = v109[5];
  v96 = v109[2] + 0xA;
  v97 = v109[3] + 0xA;
  v108 = 0;
  v3 = v109[2];
  v102 = 0;
  v106 = 0;
  v98 = v3 + 0x145;
  format = 0;
  v110 = 0xFFFF;
  v99 = v109[3] + 0xCF;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v95;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v96;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = v97;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = v98;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v99;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3062] = 0xFF;
  v111 = 0;
  switch ( dword_104684[0] )
  {
    case 0:
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x41);// 65: "Research"
      v108 = (int)sub_1CEA8;
      LOWORD(sub_1CEA8) = *(_WORD *)(dword_D3664 + 0x46);
      v5 = *(unsigned __int8 *)(dword_D3664 + 0x57);
      v111 = sub_1CEA8;
      v6 = (unsigned __int16)word_106FA6[v5];
      if ( v6 != 0xFFFF )
      {
        v107 = 0xFFFFFFFF;
        v102 = &byte_10525A[0x4B * v6];
        v7 = sub_469F0((int)&word_105258, v5);
        v110 = sub_46C20(
                 *(unsigned __int16 *)((char *)&word_105296 + 0x4B * v6),
                 (unsigned __int16)word_106FB4[*(unsigned __int8 *)(dword_D3664 + 0x57)],
                 v7);
      }
      v106 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x42); // 66: "be discovered"
      format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x43);// 67: "No progress is being made on %s."
      break;
    case 1:
      v8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x44);   // 68: "Industry"
      HIWORD(v9) = 0;
      v108 = (int)v8;
      LOWORD(v8) = *(_WORD *)(dword_D3664 + 0x44);
      LOWORD(v9) = *(_WORD *)(dword_D3664 + 0x52);
      v111 = v8;
      v10 = 0xFF;
      if ( (unsigned __int16)v9 != 0xFFFF )
      {
        v10 = *(_BYTE *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v9 + 1);
      }
      if ( v10 != 0xFF )
      {
        v102 = (char *)&dword_103F9A[0xA * v10 + 3];
        v107 = 0xFFFFFFFF;
        v11 = *(_WORD *)(dword_D3664 + 0x44);
        v12 = *(_WORD *)(dword_D3664 + 0x50);
        v13 = sub_3583C(dword_D3664, v9, 0xFFu);
        v110 = sub_46C20(v13, v12, v11);
      }
      v106 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x45); // 69: "be completed"
      format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x43);// 67: "No progress is being made on %s."
      break;
    case 2:
      v108 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x46);// 70: "Prosperity"
      HIWORD(v14) = HIWORD(dword_D3664);
      LOWORD(v14) = *(_WORD *)(dword_D3664 + 0x48);
      v111 = (char *)v14;
      v102 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x47); // 71: "Population"
      v106 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x48); // 72: "grow"
      v15 = *(_WORD *)(dword_D3664 + 0x42);
      v16 = *(_WORD *)(dword_D3664 + 0x4A);
      v107 = 0xFFFFFFFF;
      if ( v15 >= v16 )
      {
        format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4A);// 74: "%s has no more room to grow."
      }
      else
      {
        v110 = sub_46C20(
                 dword_9684C,
                 *(unsigned __int16 *)(dword_D3664 + 0x4E),
                 *(unsigned __int16 *)(dword_D3664 + 0x48));
        if ( (unsigned __int16)v110 == 0xFFFF )
        {
          format = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x49);// 73: "%s is not growing."
        }
      }
      break;
    case 3:
      v17 = *(unsigned __int16 *)((char *)v109 + 0xAB);
      if ( (unsigned __int16)v17 != 0xFFFF )
      {
        HIBYTE(v18) = 0;
        v103 = (char *)(4 * v17 + *(_DWORD *)(dword_D3664 + 0x10));
        LOBYTE(v18) = v103[1];
        v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4B);// 75: "White"
        v19 = *v103;
        a2 = 0;
        switch ( v19 & 7 )
        {
          case 0:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4C);// 76: "Black"
            break;
          case 2:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4D);// 77: "Red"
            a2 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4E);// 78: "industry"
            break;
          case 3:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x4F);// 79: "Green"
            a2 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x50);// 80: "prosperity"
            break;
          case 4:
            v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x51);// 81: "Blue"
            a2 = (int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x52);// 82: "research"
            break;
          default:
            break;
        }
        if ( *(_WORD *)((char *)v109 + 0xAB) >= *(_WORD *)(dword_D3664 + 0x18) )
        {
          v105 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x53);// 83: "Orbital"
        }
        if ( v18 == 0xFF )
        {
          if ( (*v103 & 8) != 0 && (_BYTE)byte_104BEA == *(_BYTE *)(dword_D3664 + 0x57) )
          {
            v40 = v92;
            v41 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x58);// 88: "Xenoarcheological Ruins"
            do
            {
              v42 = *v41;
              *v40 = *v41;
              if ( !v42 )
              {
                break;
              }
              v43 = v41[1];
              v41 += 2;
              v40[1] = v43;
              v40 += 2;
            }
            while ( v43 );
          }
          else
          {
            v84 = v105;
            v44 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x59);// 89: "%s Square"
            sprintf(v92, v44, v84);
          }
          sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x14, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          if ( (*v103 & 8) == 0 )
          {
            if ( *(_WORD *)((char *)v109 + 0xAB) < *(_WORD *)(dword_D3664 + 0x18) )
            {
              if ( (*v103 & 7) == 1 )
              {
                v49 = v90;
                v50 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5B);// 91: "White squares are ordinary habitable surface squares."
                do
                {
                  v51 = *v50;
                  *v49 = *v50;
                  if ( !v51 )
                  {
                    break;
                  }
                  v52 = v50[1];
                  v50 += 2;
                  v49[1] = v52;
                  v49 += 2;
                }
                while ( v52 );
              }
              else if ( (*v103 & 7) != 0 )
              {
                v85 = a2;
                v77 = v105;
                v57 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5D);// 93: "%s squares increase the effectiveness of %s-producing structures."
                sprintf(v90, v57, v77, v85);
              }
              else
              {
                v53 = v90;
                v54 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5C);// 92: "Black squares are uninhabitable.  Most structures cannot be built on them."
                do
                {
                  v55 = *v54;
                  *v53 = *v54;
                  if ( !v55 )
                  {
                    break;
                  }
                  v56 = v54[1];
                  v54 += 2;
                  v53[1] = v56;
                  v53 += 2;
                }
                while ( v56 );
              }
            }
            else
            {
              v45 = v90;
              v46 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5A);// 90: "Orbital squares are used for building orbital structures such as 
                                                       // Shipyards and Ships."
              do
              {
                v47 = *v46;
                *v45 = *v46;
                if ( !v47 )
                {
                  break;
                }
                v48 = v46[1];
                v46 += 2;
                v45[1] = v48;
                v45 += 2;
              }
              while ( v48 );
            }
            sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0xA, 0x50, v90, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          }
        }
        else
        {
          v20 = s;
          v21 = &dword_103F9A[0xA * v18 + 3];
          do
          {
            v22 = *(_BYTE *)v21;
            *v20 = *(_BYTE *)v21;
            if ( !v22 )
            {
              break;
            }
            v23 = *((_BYTE *)v21 + 1);
            v21 = (int *)((char *)v21 + 2);
            v20[1] = v23;
            v20 += 2;
          }
          while ( v23 );
          if ( v18 == 0x17 )
          {
            v24 = sub_35A70(dword_D3664, *(_WORD *)((char *)v109 + 0xAB));
            sprintf(s, "%s \"%s\"", (const char *)&dword_103F9A[0xE9], v24 + 0x34);
          }
          if ( (*((_WORD *)v103 + 1) & 2) != 0 )
          {
            v25 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x54);// 84: "Automated "
          }
          else
          {
            v25 = (char *)&unk_920AA;
          }
          v26 = v25;
          qmemcpy(v94, &unk_968A8, 0x32u);
          if ( *(_WORD *)((char *)v109 + 0xAB) < *(_WORD *)(dword_D3664 + 0x18) )
          {
            v82 = v105;
            v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x55);// 85: " on %s Square"
            sprintf(v94, v27, v82);
          }
          sprintf(v91, "%s%s%s", v26, s, v94);
          sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xF, v91, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          v28 = *(_WORD *)((char *)v109 + 0xAB);
          if ( !*(_WORD *)(*(_DWORD *)(dword_D3664 + 0x10) + 4 * v28 + 2) )
          {
            v29 = *(_WORD *)(dword_D3664 + 0x44);
            v30 = *(_WORD *)(dword_D3664 + 0x50);
            v31 = sub_3583C(dword_D3664, v28, 0xFFu);
            v32 = sub_46C20(v31, v30, v29);
            v33 = v32;
            if ( v32 == 0xFFFF )
            {
              v34 = v91;
              v35 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x56);// 86: "No progress"
              do
              {
                v36 = *v35;
                *v34 = *v35;
                if ( !v36 )
                {
                  break;
                }
                v37 = v35[1];
                v35 += 2;
                v34[1] = v37;
                v34 += 2;
              }
              while ( v37 );
            }
            else
            {
              if ( v32 == 1 )
              {
                v38 = 0x1C;                            // 28: ""
              }
              else
              {
                v38 = 0x1D;                            // 29: "s"
              }
              v83 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v38);
              v39 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x57);// 87: "%d day%s until completion"
              sprintf(v91, v39, v33, v83);
            }
            sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x32, v91, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
          }
        }
      }
      break;
    case 4:
      sub_2B8A8(
        (int)&V_Type3_stru_10AE70.z1[0x3046],
        0,
        0xF,
        (const char *)(dword_D3664 + 0x24),
        2,
        0xFFFFFFFF,
        0xFFFFFFFF,
        0);
      v86 = dword_10469C[*(unsigned __int16 *)(dword_D3664 + 0x16)];
      v78 = dword_104688[*(unsigned __int16 *)(dword_D3664 + 0x14)];
      v58 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5E);  // 94: "%s %s Planet"
      sprintf(v92, v58, v78, v86);
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x3C, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v59 = v100;
      v60 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x5F);  // 95: "No One"
      do
      {
        v61 = *v60;
        *v59 = *v60;
        if ( !v61 )
        {
          break;
        }
        v62 = v60[1];
        v60 += 2;
        v59[1] = v62;
        v59 += 2;
      }
      while ( v62 );
      if ( *(unsigned __int8 *)(dword_D3664 + 0x57) != 0xFF )
      {
        v63 = v100;
        v64 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * *(unsigned __int8 *)(dword_D3664 + 0x57))];
        do
        {
          v65 = *v64;
          *v63 = *v64;
          if ( !v65 )
          {
            break;
          }
          v66 = v64[1];
          v64 += 2;
          v63[1] = v66;
          v63 += 2;
        }
        while ( v66 );
      }
      v79 = 4 * (unsigned __int8)byte_A2F74[0x1EE * *(unsigned __int8 *)(dword_D3664 + 0x57)] + 0x13;
      v67 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x60);  // 96: "Owned by |%d|%s"
      sprintf(v92, v67, v79, v100);
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x5A, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      v87 = *(unsigned __int16 *)(dword_D3664 + 0x4A);
      v68 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x61);  // 97: "Maximum Population  %d"
      sprintf(v92, v68, v87);
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x78, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
      if ( *(_BYTE *)(dword_D3664 + 0x57) == (_BYTE)byte_104BEA && *(_DWORD *)(dword_D3664 + 0x5A) == 0xFFFFFFFF )
      {
        v74 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
        v69 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x62);// 98: "Self Managed"
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x96, v69, 2, v74, 0xFFFFFFFF, 0);
      }
      break;
    default:
      break;
  }
  if ( v108 )
  {
    v88 = (unsigned __int16)v111;
    v80 = v108;
    v75 = dword_D3664 + 0x24;
    v70 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x63);    // 99: "%s %s: %d per day"
    sprintf(v92, v70, v75, v80, v88);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xF, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
    if ( v107 )
    {
      if ( (unsigned __int16)v110 == 0xFFFF )
      {
        sprintf(v92, format, v102);
      }
      else
      {
        if ( (unsigned __int16)v110 == 1 )
        {
          v71 = 0x1C;                                  // 28: ""
        }
        else
        {
          v71 = 0x1D;                                  // 29: "s"
        }
        v89 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v71);
        v81 = (unsigned __int16)v110;
        v76 = v106;
        v73 = v102;
        v72 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x64);// 100: "%s will %s in %d day%s."
        sprintf(v92, v72, v73, v76, v81, v89);
      }
      sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x50, v92, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0);
    }
  }
  if ( *(_WORD *)((char *)v109 + 0x6B) )
  {
    sub_2D218(v109);
  }
}
// 9684C: using guessed type int dword_9684C;
// FFEEA: using guessed type __int16 word_FFEEA;
// 103F9A: using guessed type int dword_103F9A[];
// 104684: using guessed type int dword_104684[];
// 104688: using guessed type int dword_104688[4];
// 10469C: using guessed type int dword_10469C[10];
// 105296: using guessed type __int16 word_105296;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0003B120) --------------------------------------------------------
int __fastcall sub_3B120(int a1)
{
  char *v2; // edx
  int v3; // ebx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char v6; // al
  char v7; // al

  v2 = byte_1050A4;
  v3 = 0x65;
  do
  {
    v4 = v2;
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3);
    do
    {
      v6 = *sub_1CEA8;
      *v4 = *sub_1CEA8;
      if ( !v6 )
      {
        break;
      }
      v7 = sub_1CEA8[1];
      sub_1CEA8 += 2;
      v4[1] = v7;
      v4 += 2;
    }
    while ( v7 );
    v2 += 0x14;
    ++v3;
  }
  while ( v2 != &byte_1050A4[0x1A4] );
  *(_BYTE *)(a1 + 1) = 0xFF;
  *(_BYTE *)a1 = 0xFF;
  *(_DWORD *)(a1 + 7) = 0;
  sub_3B188(a1);
  return a1;
}

//----- (0003B188) --------------------------------------------------------
int __fastcall sub_3B188(int result)
{
  int v1; // esi
  int v2; // edx
  int v3; // ebx

  v1 = result;
  *(_WORD *)(result + 0x1AA) = 0x12;
  *(_WORD *)(result + 0x1AC) = 0x16;
  *(_WORD *)(result + 0x1AE) = 0;
  *(_WORD *)(result + 0x19B) = 0;
  *(_WORD *)(result + 0x1D9) = 0;
  *(_WORD *)(result + 0x1DB) = 0;
  *(_BYTE *)(result + 0x1E9) = 0xE;
  v2 = result;
  *(_DWORD *)(result + 0x1EA) = 0;
  v3 = result + 0xE;
  do
  {
    result += 2;
    *(_BYTE *)(v2 + 0x1C0) = 0;
    ++v2;
    *(_WORD *)(result + 0x1B0) = 0;
  }
  while ( result != v3 );
  *(_DWORD *)(v1 + 3) = 0;
  return result;
}

//----- (0003B1FC) --------------------------------------------------------
int __fastcall sub_3B1FC(_BYTE *a1, char a2, __int16 a3)
{
  int result; // eax

  sub_3B188((int)a1);
  *a1 = a2;
  result = (unsigned __int8)a1[1];
  if ( result != a3 )
  {
    a1[1] = a3;
    return sub_43C80((int)a1, a3, a3, (int)a1);
  }
  return result;
}

//----- (0003B220) --------------------------------------------------------
char __fastcall sub_3B220(int a1, int a2, int a3, int a4)
{
  int v4; // ebp
  __int16 v5; // di
  int v6; // esi
  int v7; // eax
  int v8; // ebx
  __int16 v9; // dx
  int v10; // ebx
  int v11; // edx
  int v12; // eax
  char v13; // dl
  int v14; // ecx
  int v16[107]; // [esp+0h] [ebp-1CCh] BYREF
  size_t v17; // [esp+1ACh] [ebp-20h]
  int v18; // [esp+1B0h] [ebp-1Ch]

  v4 = a1;
  if ( *(_DWORD *)(a1 + 3) != 0xFFFFFFFF )
  {
    v18 = sub_3EFE0(a1);
    if ( v18 < 0 )
    {
      v5 = 0;
      v17 = sub_40224((unsigned __int8 *)v4, v16, 0) - 1;
      while ( v5 < -v18 )
      {
        v6 = v16[v17 - v5];
        if ( *(_BYTE *)v4 == (_BYTE)byte_104BEA )
        {
          a4 = 0;
          sub_55AEC((int)&V_Type3_stru_10AE70, 0xB, *(char *)(v6 + 0xAA), 0);
        }
        sub_49940(v6);
        ++v5;
      }
    }
    v7 = sub_40224((unsigned __int8 *)v4, v16, 0);
    sub_3C1C0((unsigned __int8 *)v4, v16, v7);
    v8 = sub_40224((unsigned __int8 *)v4, v16, 0);
    if ( !v8 && !sub_402E0((_BYTE *)v4) )
    {
      v9 = 0xA;
      LOBYTE(v8) = *(_BYTE *)v4;
      *(_DWORD *)(v4 + 3) = 0xFFFFFFFF;
LABEL_19:
      LOBYTE(a1) = sub_55AEC((int)&V_Type3_stru_10AE70, v9, v8, 0);
      return a1;
    }
    if ( v8 > 0 )
    {
      v10 = 4 * v8;
      v11 = 0;
      do
      {
        v12 = v16[v11 / 4u];
        v11 += 4;
        sub_4A6AC(v12, v11, v10, a4);
      }
      while ( v11 < v10 );
    }
    v8 = 0;
    dword_10509C = 0;
    sub_3B5B8((unsigned __int8 *)v4);
    sub_405F4((_BYTE *)v4);
    LOBYTE(a1) = *(_BYTE *)(*(_DWORD *)(v4 + 7) + 0x14) & 0x80;
    if ( (_BYTE)a1 )
    {
      v13 = byte_104BEA;
      v14 = *(_DWORD *)(v4 + 0x19E) + 1;
      LOBYTE(a1) = *(_BYTE *)v4;
      *(_DWORD *)(v4 + 0x19E) = v14;
      if ( (_BYTE)a1 == v13 )
      {
        if ( v14 )
        {
          a1 = (unsigned __int16)word_968E8[*(char *)(v4 + 0x19D)];
          if ( a1 == v14 )
          {
            v9 = 0x18;
            goto LABEL_19;
          }
        }
      }
    }
  }
  return a1;
}
// 968E8: using guessed type __int16 word_968E8[21];
// 10509C: using guessed type int dword_10509C;
// 3B220: using guessed type int var_1CC[107];

//----- (0003B56C) --------------------------------------------------------
int __fastcall sub_3B56C(unsigned __int8 *a1, __int16 *a2)
{
  int v3; // edi
  __int16 i; // dx
  int result; // eax
  int v6; // eax
  int v7[111]; // [esp+0h] [ebp-1BCh] BYREF

  v3 = sub_1D794(a2, v7);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
    {
      break;
    }
    v6 = v7[i];
    if ( v6 )
    {
      if ( *(_WORD *)(v6 + 0x56) == *a1 )
      {
        sub_4A5B8(v6);
      }
    }
  }
  return result;
}
// 3B56C: using guessed type int var_1BC[111];

//----- (0003B5B8) --------------------------------------------------------
void __fastcall sub_3B5B8(unsigned __int8 *a1)
{
  int v1; // ebx
  int v2; // edi
  __int16 i; // bx
  __int16 *v4; // edi
  __int16 j; // dx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // ebp
  int v13; // ecx
  int v14; // eax
  int v15; // ebx
  int v16; // eax
  int v17; // ecx
  double v18; // st7
  double v19; // st7
  double v20; // st7
  __int16 k; // si
  int v22; // ecx
  __int16 v23; // dx
  int v24; // eax
  int v25; // eax
  __int16 v26; // di
  int v27; // edx
  __int16 *v28; // ebp
  __int16 m; // si
  __int16 *v30; // edi
  __int16 n; // bx
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // ebp
  int v36; // ecx
  __int16 v37; // si
  int v38; // ecx
  __int16 v39; // si
  signed int v40; // ebp
  char *v41; // ecx
  int v42; // edi
  int v43; // edx
  __int16 ii; // bx
  char *v45; // edx
  int v46[107]; // [esp+0h] [ebp-214h] BYREF
  int v47; // [esp+1ACh] [ebp-68h]
  int v48; // [esp+1B0h] [ebp-64h]
  float v49; // [esp+1B4h] [ebp-60h]
  int v50; // [esp+1B8h] [ebp-5Ch]
  int v51; // [esp+1BCh] [ebp-58h]
  int v52; // [esp+1C0h] [ebp-54h]
  int v53; // [esp+1C4h] [ebp-50h]
  unsigned __int8 *v54; // [esp+1C8h] [ebp-4Ch]
  float v55; // [esp+1CCh] [ebp-48h]
  int v56; // [esp+1D0h] [ebp-44h]
  int v57; // [esp+1D4h] [ebp-40h]
  _BYTE *v58; // [esp+1D8h] [ebp-3Ch]
  int v59; // [esp+1DCh] [ebp-38h]
  float v60; // [esp+1E0h] [ebp-34h]
  float v61; // [esp+1E4h] [ebp-30h]
  float v62; // [esp+1E8h] [ebp-2Ch]
  float v63; // [esp+1ECh] [ebp-28h]
  int v64; // [esp+1F0h] [ebp-24h]
  int v65; // [esp+1F4h] [ebp-20h]
  unsigned __int8 v66; // [esp+1F8h] [ebp-1Ch]

  v54 = a1;
  v50 = sub_40224(a1, v46, 0);
  if ( *v54 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF )
  {
    sub_3C670(v54);
    v1 = v50;
    sub_3C968((int)v54);
    sub_44080(v54);
    sub_3C2E8(v54, v46, v1);
  }
  if ( sub_40590(v54) != 0xFFFFFFFF
    && ((_BYTE)byte_104BEA != *v54 || dword_A0D00 || dword_106FC2 == 0xFFFFFFFF)
    && (unsigned __int16)word_106FA6[*v54] == 0xFFFF )
  {
    sub_3EA7C(v54);
  }
  if ( (_BYTE)byte_104BEA != *v54 || dword_A0D00 == 0xFFFFFFFF )
  {
    sub_434E4((char *)v54, 1);
  }
  v2 = v50;
  for ( i = 0; i < v2; ++i )
  {
    if ( (_BYTE)byte_104BEA != *v54 || dword_A0D00 == 0xFFFFFFFF )
    {
      sub_3EBDC(v54, v46[i]);
    }
  }
  if ( (_BYTE)byte_104BEA != *v54 || dword_A0D00 == 0xFFFFFFFF )
  {
    LOWORD(v65) = sub_3EFE0((int)v54);
    if ( (__int16)v65 > 0xA )
    {
      LOWORD(v65) = 0xA;
    }
    if ( (__int16)v65 > 0 )
    {
      v62 = 0.0;
      v60 = 0.0;
      v61 = 0.0;
      v4 = word_A3D21;
      v66 = sub_43374(v54, 0xFFFFFFFF);
      for ( j = 0; j < word_A62A1; v4 += 0x30 )
      {
        if ( ((_BYTE)v4[0xA] & v66) != 0 )
        {
          v10 = dword_104BEC[j];
          v11 = *(int *)((char *)&dword_104F6D + j) >> 0x18;
          v59 = v10;
          if ( v11 > 1 )
          {
            v59 = v10 >> (v11 - 1);
          }
          v12 = j;
          v13 = *(int *)((char *)&dword_104F09 + j);
          v14 = dword_104D7C[v12];
          v15 = dword_104BEC[v12];
          v60 = (double)v59 + v60;
          v16 = v15 + v14;
          v17 = v13 >> 0x18;
          v59 = v16;
          if ( v17 > 0 )
          {
            v59 = v16 >> v17;
          }
          v62 = (double)v59 + v62;
        }
        else if ( (*((_BYTE *)v4 + 0x15) & v66) != 0 )
        {
          v6 = dword_104D7C[j];
          v7 = *(int *)((char *)&dword_104F09 + j) >> 0x18;
          v53 = v6;
          if ( v7 > 0 )
          {
            v53 = v6 >> v7;
          }
          v62 = (double)v53 + v62;
        }
        else
        {
          if ( *(int *)((char *)&dword_104FD1 + j) >> 0x18 <= 0 )
          {
            v61 = (double)dword_104BEC[j] + v61;
          }
          v8 = dword_104D7C[j];
          v9 = *(int *)((char *)&dword_104F09 + j) >> 0x18;
          v52 = v8;
          if ( v9 > 0 )
          {
            v52 = v8 >> v9;
          }
          v62 = (double)v52 + v62;
        }
        ++j;
      }
      v61 = v61 * flt_920F0;
      v18 = v60 * dbl_920F4;
      v60 = v18;
      v49 = v18 + v62 + v61;
      if ( v49 <= 0.0 )
      {
        v48 = (__int16)v65 / 3;
        v61 = (float)v48;
        v62 = v61;
        v60 = (double)(__int16)v65 - v61 - v61;
      }
      else
      {
        v19 = (double)(__int16)v65;
        v60 = v60 * v19;
        v62 = v62 * v19;
        v61 = v19 * v61;
        v20 = 1.0 / v49;
        v60 = v60 * v20;
        v62 = v62 * v20;
        v61 = v20 * v61;
      }
      for ( k = 0; k < v50; ++k )
      {
        v22 = v46[k];
        if ( !v22 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x22A);
        }
        if ( *(_BYTE *)(v22 + 0x58) == 1 )
        {
          if ( *(_DWORD *)(v22 + 0x28) && v61 > 0.0 )
          {
            v61 = v61 - 1.0;
          }
          else if ( sub_4A534(v46[k], 0x49) && v60 > 0.0 )
          {
            v60 = v60 - 1.0;
          }
          else if ( v62 > 0.0 )
          {
            v62 = v62 - 1.0;
          }
        }
      }
      v23 = 0;
      while ( 1 )
      {
        v24 = v23;
        if ( v23 >= 0x64 )
        {
          break;
        }
        ++v23;
        dword_1046E8[v24] = 0;
        dword_104878[v24] = 0;
        dword_104A08[v24] = 0;
      }
      v25 = 0;
      if ( (__int16)v65 > 0 )
      {
        v26 = v65;
        do
        {
          v27 = (__int16)v25++;
          dword_104B98[v27] = 0xFFFFFFFF;
        }
        while ( (__int16)v25 < v26 );
      }
      v28 = word_A3D21;
      for ( m = 0; m < word_A62A1; v28 += 0x30 )
      {
        if ( ((1 << *v54) & (unsigned __int8)v28[0xA]) != 0 )
        {
          v30 = word_A3D21;
          for ( n = 0; n < word_A62A1; v30 += 0x30 )
          {
            if ( ((1 << *v54) & (unsigned __int8)v30[0xB]) != 0 )
            {
              v48 = 1 / ((__int16)sub_1DA04((int)v30, (int)v28) / 0x19 + 1);
              v63 = (float)v48;
              v55 = v63;
              if ( ((_BYTE)v28[0xA] & v66) != 0 )
              {
                v34 = *(int *)((char *)&dword_104F6D + n) >> 0x18;
                v51 = (int)((double)dword_104BEC[n] * v63);
                if ( v34 >= 1 )
                {
                  if ( v34 < 2 )
                  {
                    dword_104A08[m] += v51 / 2;
                  }
                }
                else
                {
                  dword_104A08[m] += v51;
                }
                if ( *(int *)((char *)&dword_104F09 + n) >> 0x18 < 1 )
                {
                  dword_104878[m] += v51;
                }
              }
              else if ( (*((_BYTE *)v28 + 0x15) & v66) != 0 )
              {
                v48 = dword_104BEC[n] + dword_104D7C[n];
                v32 = *(int *)((char *)&dword_104F09 + n) >> 0x18;
                v56 = (int)((double)v48 * v63);
                if ( v32 < 1 )
                {
                  dword_104878[m] += v56;
                }
              }
              else
              {
                if ( *(int *)((char *)&dword_104FD1 + n) >> 0x18 < 1 )
                {
                  dword_1046E8[m] = (int)((double)dword_104BEC[n] * v63 * flt_920F0 + (double)dword_1046E8[m]);
                }
                v33 = *(int *)((char *)&dword_104F09 + n) >> 0x18;
                v47 = (int)((double)dword_104D7C[n] * v55);
                if ( v33 < 1 )
                {
                  dword_104878[m] += v47;
                }
              }
            }
            ++n;
          }
        }
        ++m;
      }
      v58 = &unk_BB1B3;
      LOWORD(v64) = 0;
      if ( SHIWORD(dword_CA1ED) > 0 )
      {
        do
        {
          if ( v58[0x54] == 0xFF && (unsigned __int16)sub_35930((int)v58, 0x16) != 0xFFFF && v58[0x57] == *v54 )
          {
            v38 = *((__int16 *)v58 + 6);
            if ( v38 >= 0x64 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2A1);
            }
            v57 = (dword_104878[v38] + dword_1046E8[v38] + dword_104A08[v38]) / 0xA;
            v35 = 0;
            v37 = 0;
            v36 = dword_104BC0[0];
            v57 *= *((unsigned __int16 *)v58 + 0x22);
            if ( (__int16)v65 > 0 )
            {
              while ( 1 )
              {
                if ( v37 >= 0xA )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2B1);
                }
                if ( dword_104B98[v37] == 0xFFFFFFFF )
                {
                  break;
                }
                if ( v36 > dword_104BC0[v37] )
                {
                  v35 = v37;
                  v36 = dword_104BC0[v37];
                }
                if ( ++v37 >= (__int16)v65 )
                {
                  goto LABEL_96;
                }
              }
              v35 = v37;
            }
LABEL_96:
            if ( v57 > dword_104BC0[v35] || dword_104B98[v35] == 0xFFFFFFFF )
            {
              dword_104B98[v35] = (__int16)v64;
              dword_104BC0[v35] = v57;
            }
          }
          LOWORD(v64) = v64 + 1;
          v58 += 0x7B;
        }
        while ( (__int16)v64 < SHIWORD(dword_CA1ED) );
      }
      v39 = 0;
      if ( (__int16)v65 > 0 )
      {
        while ( 1 )
        {
          v40 = dword_104B98[v39];
          if ( v40 <= (int)0xFFFFFFFF || SHIWORD(dword_CA1ED) <= v40 )
          {
            goto LABEL_117;
          }
          v41 = (char *)&unk_BB1B3 + 0x7B * v40;
          if ( !v41 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2D9);
          }
          v42 = *((__int16 *)v41 + 6);
          if ( v42 >= 0x64 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x2DD);
          }
          if ( v61 > 0.0 )
          {
            v43 = dword_1046E8[v42];
            if ( v43 > dword_104878[v42] && v43 > dword_104A08[v42] )
            {
              break;
            }
          }
          if ( v62 > 0.0 && dword_104878[v42] > dword_104A08[v42] )
          {
LABEL_116:
            sub_3CB60(v54, (int)&unk_BB1B3 + 0x7B * v40, 1u);
            v62 = v62 - 1.0;
            goto LABEL_117;
          }
          if ( v60 <= 0.0 )
          {
            if ( v61 > 0.0 )
            {
              break;
            }
            if ( v62 > 0.0 )
            {
              goto LABEL_116;
            }
          }
          else
          {
            sub_3CB60(v54, (int)&unk_BB1B3 + 0x7B * v40, 2u);
            v60 = v60 - 1.0;
          }
LABEL_117:
          if ( ++v39 >= (__int16)v65 )
          {
            goto LABEL_128;
          }
        }
        sub_3CB60(v54, (int)&unk_BB1B3 + 0x7B * v40, 0);
        v61 = v61 - 1.0;
        goto LABEL_117;
      }
    }
  }
LABEL_128:
  for ( ii = 0; ii < SHIWORD(dword_CA1ED); ++ii )
  {
    v45 = (char *)&unk_BB1B3 + 0x7B * ii;
    if ( v45[0x57] == *v54
      && (*v54 != (_BYTE)byte_104BEA || *(_DWORD *)(v45 + 0x5A) || dword_A0D00)
      && v45[0x54] == (char)0xFF )
    {
      sub_3D8F0(v54, (int)v45);
    }
  }
}
// 920F0: using guessed type float flt_920F0;
// 920F4: using guessed type double dbl_920F4;
// A0D00: using guessed type int dword_A0D00;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// CA1ED: using guessed type int dword_CA1ED;
// 1046E8: using guessed type int dword_1046E8[100];
// 104878: using guessed type int dword_104878[100];
// 104A08: using guessed type int dword_104A08[100];
// 104B98: using guessed type int dword_104B98[];
// 104BC0: using guessed type int dword_104BC0[9];
// 104BEC: using guessed type int dword_104BEC[100];
// 104D7C: using guessed type int dword_104D7C[99];
// 104F09: using guessed type int dword_104F09;
// 104F6D: using guessed type int dword_104F6D;
// 104FD1: using guessed type int dword_104FD1;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FC2: using guessed type int dword_106FC2;
// 3B5B8: using guessed type int var_214[107];

//----- (0003C12C) --------------------------------------------------------
unsigned int __fastcall sub_3C12C(unsigned __int8 *a1, _DWORD *a2)
{
  int v3; // ebp
  int v4; // esi
  char v5; // al
  int v6; // ebx

  v3 = *(_DWORD *)((char *)a2 + 0x15A) - *(_DWORD *)((char *)a2 + 0x15E);
  v4 = 0;
  v5 = sub_4A36C((int)a2, 0, *a1);
  if ( v5 <= (char)0xFFFFFFFF || v5 >= 0x4C )
  {
    v6 = 0;
  }
  else
  {
    v6 = *(int *)((char *)&dword_107072 + 0x6A * v5);
  }
  if ( 3 * v3 > *(_DWORD *)((char *)a2 + 0x15A)
    || !a2[0xA] && !sub_4A534((int)a2, 0x49) && v6 > *a2
    || sub_4A8CC((int)a2) >= 1 && sub_4A1CC((int)a2, *a1) >= 0xF )
  {
    return 0xFFFFFFFF;
  }
  return v4;
}
// 107072: using guessed type int dword_107072;

//----- (0003C1C0) --------------------------------------------------------
char __fastcall sub_3C1C0(unsigned __int8 *a1, int *a2, int a3)
{
  int *v4; // esi
  signed int v5; // eax
  int v6; // ecx
  __int16 v7; // ax
  int i; // edi
  int v9; // ecx
  char v10; // dl
  char v11; // bl

  v4 = a2;
  v5 = sub_3EFE0((int)a1);
  if ( v5 < 2 )
  {
    if ( a2 )
    {
      if ( a3 > 0 )
      {
        LOBYTE(v5) = *a1;
        if ( *a1 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF )
        {
          v6 = 1 << *a1;
          v7 = 0;
          if ( (v6 & SHIBYTE(dword_1052EA)) != 0 )
          {
            v7 = 1;
            if ( (v6 & SHIBYTE(dword_105830)) != 0 )
            {
              v7 = 2;
              if ( (v6 & SHIBYTE(dword_105BB4)) != 0 )
              {
                v7 = 3;
              }
            }
          }
          if ( !v7 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x365);
          }
          for ( i = 0; i < a3; ++i )
          {
            if ( !v4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x36B);
            }
            v9 = *v4;
            if ( !*v4 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x36F);
            }
            v10 = *(_BYTE *)(v9 + 0x58);
            if ( v10 != 1 && v10 != 2 )
            {
              v11 = *(_BYTE *)(v9 + 0x5D);
              if ( v11 != 2 && v11 != 5 && v11 != 6 && sub_3C12C(a1, (_DWORD *)*v4) )
              {
                sub_49940(v9);
              }
            }
            LOBYTE(v5) = a3;
            ++v4;
          }
        }
      }
    }
  }
  return v5;
}
// 3C265: conditional instruction was optimized away because ebx.4>=1
// A0D00: using guessed type int dword_A0D00;
// 1052EA: using guessed type int dword_1052EA;
// 105830: using guessed type int dword_105830;
// 105BB4: using guessed type int dword_105BB4;

//----- (0003C2E8) --------------------------------------------------------
int __fastcall sub_3C2E8(unsigned __int8 *a1, int *a2, int a3)
{
  __int16 *v3; // edi
  __int16 v4; // si
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  __int16 i; // si
  int v9; // edi
  int v10; // ebx
  int v11; // edi
  int v12; // ebx
  int result; // eax
  int v14; // ecx
  char v15; // al
  _BYTE v17[6]; // [esp+8h] [ebp-1Ch]
  char v18; // [esp+10h] [ebp-14h]

  *(_DWORD *)v17 = a3;
  v18 = sub_43374(a1, 0xFFFFFFFF);
  v3 = word_A3D21;
  sub_1FD90((int)dword_A2F6C, (int)&dword_105035 + 3, *a1);
  *(_WORD *)&v17[4] = 0;
  if ( word_A62A1 > 0 )
  {
    do
    {
      v6 = *(__int16 *)&v17[4];
      dword_104BEC[v6] = sub_1DA4C((int)v3, *a1, (int)a2, *(int *)v17);
      dword_104D7C[v6] = sub_1DB70((int)v3, *a1, a2, *(int *)v17);
      v7 = *(int *)((char *)&dword_105035 + (char)((unsigned int)*(__int16 *)&v17[4] >> 0x18));
      if ( v7 > 0 && (*((_BYTE *)v3 + 0x15) & (unsigned __int8)v18) != 0 )
      {
        dword_104D7C[*(__int16 *)&v17[4]] = 2 * dword_104D7C[*(__int16 *)&v17[4]] + 0x12C + 0x96 * v7;
      }
      v4 = word_A62A1;
      v3 += 0x30;
      v5 = *(int *)&v17[2] >> 0x10;
      ++*(_WORD *)&v17[4];
      *((_BYTE *)&dword_104F09 + v5 + 3) = 0;
      *((_BYTE *)&dword_104F6D + v5 + 3) = 0;
      *((_BYTE *)&dword_104FD1 + v5 + 3) = 0;
    }
    while ( *(__int16 *)&v17[4] < v4 );
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(int *)v17 )
    {
      break;
    }
    v14 = a2[i];
    if ( !v14 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3B3);
    }
    v15 = *(_BYTE *)(v14 + 0x58);
    v12 = 0xFFFFFFFF;
    if ( v15 == 4 )
    {
      v11 = *(_DWORD *)(v14 + 0x59);
      if ( !v11 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3BB);
      }
      goto LABEL_16;
    }
    if ( v15 == 3 )
    {
      v9 = *(_DWORD *)(v14 + 0x59);
      if ( !v9 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3C3);
      }
      v10 = *(_DWORD *)(v9 + 0xA);
      goto LABEL_17;
    }
    if ( v15 == 5 && *(_BYTE *)(v14 + 0x5D) == 1 )
    {
      v11 = *(_DWORD *)(v14 + 0x5E);
      if ( !v11 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x3CC);
      }
LABEL_16:
      v10 = *(_DWORD *)(v11 + 2);
LABEL_17:
      v12 = v10 >> 0x10;
    }
    if ( v12 > (int)0xFFFFFFFF && v12 < word_A62A1 )
    {
      if ( *(_DWORD *)(v14 + 0x28) )
      {
        ++*((_BYTE *)&dword_104FD1 + v12 + 3);
      }
      else if ( sub_4A534(v14, 0x49) )
      {
        ++*((_BYTE *)&dword_104F6D + v12 + 3);
      }
      else
      {
        ++*((_BYTE *)&dword_104F09 + v12 + 3);
      }
    }
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// 104BEC: using guessed type int dword_104BEC[100];
// 104D7C: using guessed type int dword_104D7C[99];
// 104F09: using guessed type int dword_104F09;
// 104F6D: using guessed type int dword_104F6D;
// 104FD1: using guessed type int dword_104FD1;
// 105035: using guessed type int dword_105035;

//----- (0003C670) --------------------------------------------------------
char __fastcall sub_3C670(_BYTE *a1)
{
  _BYTE *v1; // ebp
  __int16 *v2; // eax
  int i; // edx
  __int16 v4; // bx
  unsigned __int8 *v5; // ecx
  __int16 v6; // si
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  bool v12; // zf
  int v13; // edx
  int v14; // ecx
  unsigned __int8 v15; // dl
  int v17; // [esp+0h] [ebp-34h]
  __int16 v18; // [esp+4h] [ebp-30h]
  int v19; // [esp+8h] [ebp-2Ch]
  int v20; // [esp+Ch] [ebp-28h]
  unsigned __int8 v21; // [esp+10h] [ebp-24h]
  unsigned __int8 v22; // [esp+14h] [ebp-20h]
  unsigned __int8 v23; // [esp+18h] [ebp-1Ch]

  v1 = a1;
  LOWORD(v20) = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( 1 )
    {
      LOBYTE(a1) = v20;
      v14 = (unsigned __int8)*v1;
      if ( (__int16)v20 != v14
        && v1[(__int16)v20 + 0x1C0]
        && *(int *)((char *)&dword_A2F75 + 0x1EE * (__int16)v20) != 0xFFFFFFFF )
      {
        break;
      }
LABEL_54:
      LOWORD(v20) = v20 + 1;
      if ( (__int16)v20 >= SHIWORD(dword_A3CF2) )
      {
        return (char)a1;
      }
    }
    v15 = v1[(__int16)v20 + 0x1C0];
    v4 = 0;
    if ( v15 < 2u )
    {
      v12 = v15 == 1;
    }
    else
    {
      if ( v15 <= 2u )
      {
        v4 = word_A3CF6[3 * (__int16)v20] - word_A3CF6[3 * v14];
        if ( v4 >= 0 )
        {
          if ( v4 > 3 )
          {
            v4 = 3;
          }
        }
        else
        {
          v4 = 0;
        }
        goto LABEL_34;
      }
      v12 = v15 == 3;
    }
    if ( v12 )
    {
      if ( v1[(__int16)v20 + 0x1C0] == 1 )
      {
        v2 = word_A3D21;
        for ( i = 0; i < word_A62A1; ++i )
        {
          if ( ((1 << *v1) & (unsigned __int8)v2[0xA]) != 0 && ((1 << v20) & *((unsigned __int8 *)v2 + 0x15)) != 0 )
          {
            v17 = unk_96912;
            v18 = *((_WORD *)&unk_96912 + 2);
            v4 += *((_WORD *)&v17 + byte_A3D20);
          }
          v2 += 0x30;
        }
      }
      v5 = (unsigned __int8 *)&byte_A2F72[0x1EE * (__int16)v20];
      v21 = sub_43374(v5, 0xFFFFFFFF);
      v22 = v21;
      v23 = sub_43374(v5, 0xFFFFFFFF);
      if ( v23 != v21 )
      {
        v6 = 0;
        v7 = 0;
        v8 = 0;
        v19 = 0;
        while ( v7 < SHIWORD(dword_A3CF2) )
        {
          if ( v7 != (__int16)v20 && v7 != (unsigned __int8)*v1 )
          {
            if ( ((1 << v7) & v22) != 0 )
            {
              v6 += *(_WORD *)((char *)&dword_A3CF8 + v8);
            }
            v9 = 1 << v7;
            if ( (v23 & (1 << v7)) != 0 )
            {
              LOWORD(v9) = *(_WORD *)((char *)&dword_A3CF8 + v8);
              v19 += v9;
            }
          }
          v8 += 6;
          ++v7;
        }
        if ( v6 <= (__int16)v19 )
        {
          v4 += 3;
        }
        else
        {
          --v4;
        }
        if ( v1[(__int16)v20 + 0x1C0] == 1 )
        {
          v10 = *(int *)((char *)&dword_A3CF2 + 6 * (__int16)v20 + 2) >> 0x10;
          v11 = *(int *)((char *)&dword_A3CF2 + 6 * (unsigned __int8)*v1 + 2) >> 0x10;
          if ( v10 - v11 <= 1 )
          {
            if ( v11 - v10 > 1 )
            {
              v4 += 4;
            }
          }
          else
          {
            v4 -= 2;
          }
        }
      }
    }
LABEL_34:
    LOBYTE(a1) = byte_104BEA;
    if ( (__int16)v20 == (unsigned __int8)byte_104BEA && !dword_A0D00 )
    {
      if ( v4 < 0 )
      {
        LOBYTE(a1) = byte_A3D20;
        if ( byte_A3D20 )
        {
          if ( (unsigned __int8)byte_A3D20 <= 1u )
          {
            v4 *= 2;
          }
          else if ( byte_A3D20 == 2 )
          {
            v4 *= 3;
          }
        }
      }
      else
      {
        LOBYTE(a1) = byte_A3D20;
        if ( byte_A3D20 )
        {
          if ( (unsigned __int8)byte_A3D20 <= 1u )
          {
            LOWORD(a1) = v4 / 2;
            v4 /= 2;
          }
          else if ( byte_A3D20 == 2 )
          {
            LOWORD(a1) = v4 / 3;
            v4 /= 3;
          }
        }
      }
    }
    if ( v4 )
    {
      a1 = &v1[2 * (__int16)v20];
      *((_WORD *)a1 + 0xD9) += v4;
      v13 = *((__int16 *)a1 + 0xD9);
      if ( v13 >= 0x32 )
      {
        if ( v13 > 0x3B6 )
        {
          *((_WORD *)a1 + 0xD9) = 0x3B6;
        }
      }
      else
      {
        *((_WORD *)a1 + 0xD9) = 0x32;
      }
    }
    goto LABEL_54;
  }
  return (char)a1;
}
// A0D00: using guessed type int dword_A0D00;
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3CF6: using guessed type __int16 word_A3CF6[];
// A3CF8: using guessed type int dword_A3CF8;
// A3D20: using guessed type char byte_A3D20;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (0003C968) --------------------------------------------------------
int __fastcall sub_3C968(int a1)
{
  int result; // eax
  double v3; // st7
  float v4; // edx
  double v5; // st7
  double v6; // [esp+8h] [ebp-34h]
  double v7; // [esp+8h] [ebp-34h]
  double v8; // [esp+8h] [ebp-34h]
  double v9; // [esp+10h] [ebp-2Ch]
  double v10; // [esp+10h] [ebp-2Ch]
  float v11; // [esp+18h] [ebp-24h]
  float v12; // [esp+1Ch] [ebp-20h]
  float v13; // [esp+20h] [ebp-1Ch]
  float v14; // [esp+24h] [ebp-18h]
  float v15; // [esp+24h] [ebp-18h]
  float v16; // [esp+24h] [ebp-18h]

  result = dword_A2F6C[0] / 0xA;
  if ( dword_A2F6C[0] % 0xA )
  {
    return result;
  }
  v13 = (double)(dword_A2F6C[0] % *(__int16 *)(a1 + 0x1D7)) / (double)*(__int16 *)(a1 + 0x1D7) * dbl_92150;
  if ( (LODWORD(v13) & 0x7FFFFFFF) == 0 )
  {
    v13 = 0.0099999998;
  }
  v6 = *(float *)(a1 + 0x1DD);
  v7 = sin(v13) * v6;
  v9 = *(float *)(a1 + 0x1E1);
  v10 = sin(v13 * flt_92158) * v9 + v7;
  v8 = *(float *)(a1 + 0x1E5);
  v14 = sin(v13 * flt_9215C) * v8 + v10;
  if ( v14 >= 0.0 )
  {
    v3 = v14 + flt_92158;
  }
  else
  {
    v3 = v14 + flt_92160;
  }
  v15 = v3;
  v11 = (float)*(__int16 *)(a1 + 0x1D9);
  if ( v15 > (double)v11 )
  {
    v4 = (float)*(__int16 *)(a1 + 0x1D9);
LABEL_11:
    v15 = v4;
    goto LABEL_12;
  }
  v12 = (float)*(__int16 *)(a1 + 0x1DB);
  if ( v15 < (double)v12 )
  {
    v4 = (float)*(__int16 *)(a1 + 0x1DB);
    goto LABEL_11;
  }
LABEL_12:
  if ( *(_BYTE *)a1 == (_BYTE)byte_104BEA )
  {
    word_104BE8 = (int)v15;
  }
  if ( byte_A3D20 == 2 )
  {
    v5 = v15 + flt_9216C;
  }
  else if ( byte_A3D20 )
  {
    v5 = v15 + flt_92164;
  }
  else
  {
    v5 = v15 + flt_92168;
  }
  for ( result = 0; (__int16)result < SHIWORD(dword_A3CF2); ++result )
  {
    if ( *(_BYTE *)((__int16)result + a1 + 0x1C0) )
    {
      if ( !*(int *)((char *)&dword_A2F75 + 0x1EE * (__int16)result) )
      {
        v16 = v5;
        *(_WORD *)(a1 + 2 * (__int16)result + 0x1B2) = (int)((double)*(__int16 *)(a1 + 2 * (__int16)result + 0x1B2) + v16);
      }
    }
  }
  return result;
}
// 92150: using guessed type double dbl_92150;
// 92158: using guessed type float flt_92158;
// 9215C: using guessed type float flt_9215C;
// 92160: using guessed type float flt_92160;
// 92164: using guessed type float flt_92164;
// 92168: using guessed type float flt_92168;
// 9216C: using guessed type float flt_9216C;
// A2F6C: using guessed type int dword_A2F6C[];
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;
// 104BE8: using guessed type __int16 word_104BE8;

//----- (0003CB60) --------------------------------------------------------
int __fastcall sub_3CB60(unsigned __int8 *a1, int a2, unsigned __int8 a3)
{
  char *v5; // eax
  int v6; // ebp
  int v7; // [esp+0h] [ebp-14h]

  if ( *(_WORD *)(a2 + 0x44) )
  {
    if ( (unsigned __int16)sub_35930(a2, 0x16) == 0xFFFF )
    {
      if ( (dword_A2F6C[0] > 0xAA || byte_A3D20 == 2)
        && ((1 << *a1) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104311) >> 0x18)) != 0 )
      {
        if ( !sub_34AE4(a2, 0x16u, 0) )
        {
          return 2;
        }
        return 1;
      }
    }
    else if ( sub_362E0(a2) && (*(_BYTE *)(a2 + 0x57) != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF) )
    {
      v7 = sub_34AE4(a2, 0x17u, 0);
      if ( v7 != 0xFFFF )
      {
        v5 = sub_40144(a1, a2);
        v6 = (int)v5;
        if ( !v5 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x537);
        }
        sub_3F060(a1, v5, a2, a3);
        sub_35B04(a2, v7, v6);
        return 1;
      }
    }
  }
  return 0;
}
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// A3D20: using guessed type char byte_A3D20;
// 104311: using guessed type char byte_104311;
// 10529F: using guessed type int dword_10529F;

//----- (0003CCE4) --------------------------------------------------------
unsigned int __fastcall sub_3CCE4(_BYTE *a1, int a2)
{
  unsigned int v4; // ebp
  int v5; // eax
  int v6; // edi
  int v7; // ebx
  int v8; // ebx
  int v9; // ecx
  int v10; // edx
  unsigned __int8 v11; // al
  __int16 v12; // ax
  int v13; // eax
  int *v14; // ebx
  unsigned __int8 *v15; // edi
  int v16; // eax
  int v17; // edi
  char v18; // al
  int v19; // edi
  int v20; // eax
  char v21; // ah
  int v22; // edi
  int v23; // eax
  int v24; // edi
  int v25; // eax
  int v26; // edx
  int v27; // ebx
  char v28; // bl
  char v29; // bh
  __int64 v31; // [esp+0h] [ebp-10Ch]
  int v32; // [esp+8h] [ebp-104h]
  int v33; // [esp+Ch] [ebp-100h]
  int v34; // [esp+10h] [ebp-FCh]
  int v35; // [esp+18h] [ebp-F4h]
  int v36; // [esp+1Ch] [ebp-F0h]
  int v37; // [esp+20h] [ebp-ECh]
  int v38; // [esp+24h] [ebp-E8h]
  int v39; // [esp+28h] [ebp-E4h]
  int v40; // [esp+2Ch] [ebp-E0h]
  int v41; // [esp+30h] [ebp-DCh]
  int v42; // [esp+34h] [ebp-D8h]
  int v43; // [esp+38h] [ebp-D4h]
  int v44; // [esp+3Ch] [ebp-D0h]
  int v45; // [esp+44h] [ebp-C8h]
  int v46; // [esp+48h] [ebp-C4h]
  int v47; // [esp+4Ch] [ebp-C0h]
  int v48; // [esp+50h] [ebp-BCh]
  int v49; // [esp+9Ch] [ebp-70h]
  int v50; // [esp+A0h] [ebp-6Ch]
  int v51; // [esp+A4h] [ebp-68h]
  int v52; // [esp+A8h] [ebp-64h]
  float v53; // [esp+ACh] [ebp-60h]
  float v54; // [esp+B0h] [ebp-5Ch]
  float v55; // [esp+B4h] [ebp-58h]
  float v56; // [esp+B8h] [ebp-54h]
  int v57; // [esp+BCh] [ebp-50h]
  float v58; // [esp+C0h] [ebp-4Ch]
  float v59; // [esp+C4h] [ebp-48h]
  int v60; // [esp+C8h] [ebp-44h]
  int v61; // [esp+CCh] [ebp-40h]
  int v62; // [esp+D0h] [ebp-3Ch]
  int v63; // [esp+D4h] [ebp-38h]
  int v64; // [esp+D8h] [ebp-34h]
  float v65; // [esp+DCh] [ebp-30h]
  int v66; // [esp+E0h] [ebp-2Ch]
  int v67; // [esp+E4h] [ebp-28h]
  int v68; // [esp+E8h] [ebp-24h]
  int v69; // [esp+ECh] [ebp-20h]
  int v70; // [esp+F0h] [ebp-1Ch]
  unsigned __int8 v71; // [esp+F4h] [ebp-18h]

  v4 = 0;
  v57 = 0;
  v60 = 0xFFFFFFFF;
  v58 = 0.0;
  v56 = 1.0;
  v53 = 1.0;
  v59 = 1.0;
  v55 = 1.0;
  v54 = 1.0;
  v49 = 0;
  v69 = 0;
  v52 = 0;
  v67 = 0;
  v66 = 0;
  sub_36158(a2);
  v6 = v5;
  if ( (unsigned __int8)byte_104299 == 0xFF
    || ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104299) >> 0x18)) != 0 )
  {
    v66 = 0xFFFFFFFF;
  }
  if ( (unsigned __int8)byte_104299 == 0xFF
    || ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104299) >> 0x18)) != 0 )
  {
    v67 = 0xFFFFFFFF;
  }
  if ( *(unsigned __int16 *)(a2 + 0x4A) - *(unsigned __int16 *)(a2 + 0x42) > 0 )
  {
    v49 = 0xFFFFFFFF;
  }
  if ( sub_40590(a1) )
  {
    v57 = 0xFFFFFFFF;
  }
  if ( *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    v69 = 0xFFFFFFFF;
    v59 = 2.0;
    v4 = 4;
  }
  if ( *(_WORD *)(a2 + 0x1C) || *(unsigned __int16 *)(a2 + 0x4A) - *(unsigned __int16 *)(a2 + 0x42) <= 3 || !v67 )
  {
    if ( *(unsigned __int16 *)(a2 + 0x1C) > 1u
      && *(unsigned __int16 *)(a2 + 0x4A) - *(unsigned __int16 *)(a2 + 0x42) < 2 )
    {
      v4 = 8;
      if ( v49 == 0xFFFFFFFF )
      {
        v55 = 0.0;
      }
    }
  }
  else
  {
    v55 = 0.5;
    v52 = 0xFFFFFFFF;
  }
  if ( v6 < 4 )
  {
    v54 = 2.0;
    if ( !v4 )
    {
      v4 = 0x10;
    }
  }
  if ( v57 )
  {
    v53 = 0.0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x42) - *(unsigned __int16 *)(a2 + 0x4C) <= *(unsigned __int16 *)(a2 + 0x48)
    || *(unsigned __int16 *)(a2 + 0x48) >= 3u )
  {
    if ( *(unsigned __int16 *)(a2 + 0x42) - *(unsigned __int16 *)(a2 + 0x4C) < *(unsigned __int16 *)(a2 + 0x48)
      || *(unsigned __int16 *)(a2 + 0x48) > 5u )
    {
      v59 = 0.5;
    }
  }
  else
  {
    v59 = 2.0;
    if ( !v4 )
    {
      v4 = 4;
    }
  }
  v7 = *(unsigned __int16 *)(a2 + 0x44);
  if ( (unsigned __int16)v7 < 0x19u )
  {
    if ( *(_WORD *)(a2 + 0x44) )
    {
      v50 = 0x19 / v7;
      v56 = (float)(0x19 / v7);
    }
    else
    {
      v56 = 25.0;
    }
    if ( !v4 )
    {
      v4 = 2;
    }
  }
  if ( !v57 )
  {
    v8 = *(unsigned __int16 *)(a2 + 0x46);
    if ( (unsigned __int16)v8 < 0x19u )
    {
      if ( *(_WORD *)(a2 + 0x46) )
      {
        v50 = 0x19 / v8;
        v56 = (float)(0x19 / v8);
      }
      else
      {
        v56 = 25.0;
      }
      if ( !v4 )
      {
        v4 = 1;
      }
    }
  }
  if ( 5 * v6 < 2 * *(unsigned __int16 *)(a2 + 0x18) )
  {
    v54 = 1.5;
    if ( !v4 )
    {
      v4 = 0x10;
    }
  }
  v9 = 0;
  v10 = 0;
  while ( v9 < *(unsigned __int16 *)(a2 + 0x18) )
  {
    v13 = *(_DWORD *)(a2 + 0x10);
    LOBYTE(v13) = *(_BYTE *)(v10 + v13 + 1);
    v63 = 0;
    v62 = 0;
    v64 = 0;
    v61 = 0;
    v51 = 0;
    v14 = (int *)((char *)&dword_103F9A[0xA * (unsigned __int8)v13] + 2);
    if ( (_BYTE)v13 != 0xFF
      && (_BYTE)v13 != 4
      && (_BYTE)v13 != 6
      && (_BYTE)v13 != 7
      && (_BYTE)v13 != 8
      && (_BYTE)v13 != 0x13
      && (_BYTE)v13 != 5
      && (_BYTE)v13 != 0xB
      && (_BYTE)v13 != 0xC
      && (_BYTE)v13 != 0xD
      && (_BYTE)v13 != 0xE
      && (_BYTE)v13 != 0xF
      && (_BYTE)v13 != 0x11
      && (_BYTE)v13 != 0x10
      && ((_BYTE)v13 != 0x12 || v66 && (v4 == 0x10 || !v4))
      && ((_BYTE)v13 != 3 || v52)
      && ((_BYTE)v13 != 0x14 || v49)
      && ((_BYTE)v13 != 9 && (_BYTE)v13 != 0xA || v57) )
    {
      v15 = (unsigned __int8 *)(v10 + *(_DWORD *)(a2 + 0x10));
      LOWORD(v13) = *((_WORD *)v15 + 1) & 1;
      v70 = v13;
      HIWORD(v16) = 0;
      if ( (_WORD)v70 )
      {
        if ( *(_BYTE *)v14 )
        {
          v16 = *(char *)v14;
          v17 = *v15;
          v63 += v16;
          if ( v17 == 2 )
          {
            ++v63;
          }
        }
        v18 = *((_BYTE *)v14 + 2);
        if ( v18 )
        {
          v19 = v18 + v64;
          v20 = *(_DWORD *)(a2 + 0x10);
          v64 = v19;
          v16 = *(unsigned __int8 *)(v10 + v20);
          if ( v16 == 3 )
          {
            v16 = v19 + 1;
            v64 = v19 + 1;
          }
        }
        v21 = *((_BYTE *)v14 + 1);
        if ( v21 )
        {
          v22 = v21 + v62;
          v23 = *(_DWORD *)(a2 + 0x10);
          v62 = v22;
          v16 = *(unsigned __int8 *)(v10 + v23);
          if ( v16 == 4 )
          {
            v62 = v22 + 1;
          }
        }
        v24 = v10 + *(_DWORD *)(a2 + 0x10);
        if ( *(_BYTE *)(v24 + 1) != 0xFF )
        {
          LOWORD(v16) = *(_WORD *)(v24 + 2) & 1;
          v70 = v16;
          if ( (_BYTE)v16 )
          {
            v11 = *(_BYTE *)(v24 + 1);
            if ( v11 >= 0x12u )
            {
              if ( v11 <= 0x12u )
              {
                v51 += 2;
              }
              else if ( v11 == 0x13 )
              {
                v51 += 4;
              }
            }
          }
        }
        v61 += *v14 >> 0x18;
      }
      v65 = (double)v63 * v56;
      v65 = (double)v62 * v53 + v65;
      v65 = (double)v64 * v59 + v65;
      v12 = *(_WORD *)(v10 + *(_DWORD *)(a2 + 0x10) + 2);
      v65 = (double)v61 * v55 + v65;
      v65 = (double)v51 * v54 + v65;
      if ( (v12 & 2) != 0 )
      {
        v65 = v65 + v59;
      }
      if ( v60 == 0xFFFFFFFF || v65 < (double)v58 )
      {
        v60 = v9;
        v58 = v65;
      }
    }
    v10 += 4;
    ++v9;
  }
  if ( v60 == 0xFFFFFFFF )
  {
    return 0;
  }
  v68 = rand() % 0x64;
  v25 = 0;
  v26 = 0;
  do
  {
    v27 = (unsigned __int8)byte_103FA1[v26];
    if ( v27 == 0xFF || ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * v27) >> 0x18)) != 0 )
    {
      *(_DWORD *)((char *)&v31 + v25) = 0xFFFFFFFF;
    }
    else
    {
      *(_DWORD *)((char *)&v31 + v25) = 0;
    }
    v25 += 4;
    v26 += 0x28;
  }
  while ( v25 != 0x9C );
  v71 = 0xFF;
  v28 = *(_BYTE *)(*(_DWORD *)(a2 + 0x10) + 4 * v60 + 1);
  v29 = v28;
  if ( (v28 == 2 || v28 == 9 || v28 == 0xA) && v57 == 0xFFFFFFFF )
  {
    if ( v69 == 0xFFFFFFFF )
    {
      v28 = 1;
    }
    else if ( v68 >= 0x19 )
    {
      v28 = 0;
    }
    else
    {
      v28 = 0x12;
    }
  }
  if ( v4 < 2 )
  {
    if ( !v4 )
    {
      goto LABEL_222;
    }
    if ( !v57 )
    {
      v28 = 2;
      goto LABEL_222;
    }
LABEL_123:
    v28 = 0;
    goto LABEL_222;
  }
  if ( v4 <= 2 )
  {
    goto LABEL_123;
  }
  if ( v4 < 8 )
  {
    v28 = 1;
  }
  else if ( v4 <= 8 )
  {
    v28 = 0x14;
  }
  else
  {
    v28 = 0x12;
  }
LABEL_222:
  if ( (unsigned __int8)v28 < 2u )
  {
    if ( v28 )
    {
      if ( (unsigned __int16)sub_35930(a2, 0xD) == 0xFFFF && v42 )
      {
        v71 = 0xD;
        goto LABEL_136;
      }
      if ( !v69 && (unsigned __int16)sub_35930(a2, 0xF) == 0xFFFF && v44 )
      {
        v71 = 0xF;
        goto LABEL_136;
      }
      if ( !v69 && (unsigned __int16)sub_35930(a2, 0x11) == 0xFFFF && v45 )
      {
        v71 = 0x11;
        goto LABEL_136;
      }
      if ( !v69 && (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF && v40 )
      {
        v71 = 0xB;
        goto LABEL_136;
      }
      if ( v34 && v36 )
      {
        if ( v68 < 0x32 && !v57 )
        {
          v71 = 4;
          goto LABEL_136;
        }
      }
      else
      {
        if ( v34 && !v57 )
        {
          v71 = 4;
          goto LABEL_136;
        }
        if ( !v36 )
        {
          if ( !v38 || v57 )
          {
            if ( v29 != v28 && HIDWORD(v31) )
            {
              v71 = 1;
            }
          }
          else
          {
            v71 = 9;
          }
          goto LABEL_136;
        }
      }
      v71 = 7;
      goto LABEL_136;
    }
    if ( (unsigned __int16)sub_35930(a2, 0xC) == 0xFFFF && v41 )
    {
      v71 = 0xC;
      goto LABEL_136;
    }
    if ( (unsigned __int16)sub_35930(a2, 0x11) == 0xFFFF && v45 )
    {
      v71 = 0x11;
      goto LABEL_136;
    }
    if ( (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF && v40 )
    {
      v71 = 0xB;
      goto LABEL_136;
    }
    if ( v34 && v35 )
    {
      if ( v68 < 0x32 && !v57 )
      {
        v71 = 4;
        goto LABEL_136;
      }
    }
    else
    {
      if ( v34 && !v57 )
      {
        v71 = 4;
        goto LABEL_136;
      }
      if ( !v35 )
      {
        if ( !v39 || v57 )
        {
          if ( v29 && (_DWORD)v31 )
          {
            v71 = 0;
          }
        }
        else
        {
          v71 = 0xA;
        }
        goto LABEL_136;
      }
    }
    v71 = 6;
    goto LABEL_136;
  }
  if ( (unsigned __int8)v28 <= 2u )
  {
    if ( (unsigned __int16)sub_35930(a2, 0xE) == 0xFFFF && v43 )
    {
      v71 = 0xE;
    }
    else if ( (unsigned __int16)sub_35930(a2, 0x11) == 0xFFFF && v45 )
    {
      v71 = 0x11;
    }
    else if ( (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF && v40 )
    {
      v71 = 0xB;
    }
    else if ( v37 )
    {
      v71 = 8;
    }
    else if ( v34 )
    {
      v71 = 4;
    }
    else if ( v39 )
    {
      v71 = 0xA;
    }
    else if ( v38 )
    {
      v71 = 9;
    }
    else if ( v29 != v28 && v32 )
    {
      v71 = 2;
    }
  }
  else if ( (unsigned __int8)v28 < 0x12u )
  {
    if ( v28 != 3 )
    {
      return 0;
    }
    if ( v34 )
    {
      v71 = 4;
    }
    else if ( v29 != 3 && v33 )
    {
      v71 = 3;
    }
  }
  else if ( (unsigned __int8)v28 <= 0x12u )
  {
    if ( v47 )
    {
      v71 = 0x13;
    }
    else if ( v29 != v28 && v46 )
    {
      v71 = 0x12;
    }
  }
  else
  {
    if ( v28 != 0x14 )
    {
      return 0;
    }
    if ( v34 )
    {
      v71 = 4;
    }
    else if ( v33 )
    {
      v71 = 3;
    }
    else if ( v29 != 0x14 && v48 )
    {
      v71 = 0x14;
    }
  }
LABEL_136:
  if ( v71 < 0x27u && sub_34B0C(v31, v32, v33) )
  {
    sub_34774(a2, v71, v60, 0);
    return 0xFFFFFFFF;
  }
  return 0;
}
// 3D3C4: conditional instruction was optimized away because ebp.4==10
// 3D3FB: conditional instruction was optimized away because ebp.4==4
// 3CD75: variable 'v5' is possibly undefined
// 103F9A: using guessed type int dword_103F9A[];
// 104299: using guessed type char byte_104299;
// 10529F: using guessed type int dword_10529F;

//----- (0003D8F0) --------------------------------------------------------
char __fastcall sub_3D8F0(_BYTE *a1, int a2)
{
  int v4; // eax
  int v5; // eax
  unsigned __int8 v6; // dl
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // ebp
  int v12; // ebp
  int v13; // eax
  int v14; // edx
  int v15; // edi
  char v16; // bl
  char *v17; // ebx
  int v18; // ebx
  int v19; // ebx
  int v20; // ebp
  int v21; // edi
  int v22; // edx
  int v23; // eax
  char v24; // cl
  int v25; // ecx
  int *v26; // eax
  int v27; // ecx
  __int16 v28; // ax
  int v29; // et2
  int v30; // edi
  int v31; // ebx
  __int64 *v32; // ecx
  char v33; // dl
  int v34; // eax
  unsigned __int16 v35; // di
  char v37[5]; // [esp+1h] [ebp-125h]
  __int64 v38; // [esp+6h] [ebp-120h] BYREF
  unsigned __int8 v39; // [esp+Eh] [ebp-118h]
  unsigned __int8 v40; // [esp+12h] [ebp-114h]
  int v41; // [esp+CAh] [ebp-5Ch] BYREF
  int v42; // [esp+CEh] [ebp-58h] BYREF
  int v43; // [esp+D2h] [ebp-54h] BYREF
  int v44; // [esp+D6h] [ebp-50h]
  int v45; // [esp+DAh] [ebp-4Ch]
  _BYTE *v46; // [esp+DEh] [ebp-48h]
  int v47; // [esp+E6h] [ebp-40h]
  int v48; // [esp+EAh] [ebp-3Ch]
  unsigned int v49; // [esp+EEh] [ebp-38h]
  int v50; // [esp+F2h] [ebp-34h]
  int v51; // [esp+F6h] [ebp-30h]
  int v52; // [esp+FAh] [ebp-2Ch]
  int v53; // [esp+FEh] [ebp-28h]
  unsigned __int8 *v54; // [esp+102h] [ebp-24h]
  int v55; // [esp+106h] [ebp-20h]
  int v56; // [esp+10Ah] [ebp-1Ch]
  unsigned __int8 v57; // [esp+10Eh] [ebp-18h]

  v46 = a1;
  v45 = 0;
  v53 = 0;
  sub_34A44(a2, &v42, &v41, &v43);
  if ( sub_40590(v46) == 0xFFFFFFFF )
  {
    v41 += v42;
    v43 += v42;
    v42 = 0;
  }
  v4 = sub_358F0(a2);
  if ( v4 < 1 )
  {
    if ( v41 > 0 )
    {
LABEL_5:
      v5 = a2;
      v6 = 0;
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  if ( v4 < 2 )
  {
    if ( v43 <= 0 || *(unsigned __int16 *)(a2 + 0x44) <= 1u )
    {
      goto LABEL_5;
    }
LABEL_18:
    v6 = 1;
    goto LABEL_19;
  }
  if ( v4 >= 3 )
  {
    goto LABEL_21;
  }
  if ( v42 <= 0 || *(unsigned __int16 *)(a2 + 0x48) <= 1u || *(unsigned __int16 *)(a2 + 0x44) <= 1u )
  {
    if ( v41 > 0 && *(unsigned __int16 *)(a2 + 0x48) > 1u )
    {
      v5 = a2;
      v6 = 0;
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  v6 = 2;
LABEL_19:
  v5 = a2;
LABEL_20:
  v7 = sub_34AE4(v5, v6, 0xFFFFFFFF);
  if ( v7 != 0xFFFF )
  {
    return v7;
  }
LABEL_21:
  LOWORD(v7) = *(_WORD *)(a2 + 0x44);
  if ( !(_WORD)v7 )
  {
    return v7;
  }
  if ( *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    v8 = *(unsigned __int16 *)(a2 + 0x42);
    if ( *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v8 < 1 && v8 - *(unsigned __int16 *)(a2 + 0x4C) < 1 )
    {
      v53 = 0xFFFFFFFF;
    }
  }
  v9 = *(unsigned __int16 *)(a2 + 0x42);
  if ( *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v9 < 1 && v9 - *(unsigned __int16 *)(a2 + 0x4C) < 2 )
  {
    v45 = 0xFFFFFFFF;
  }
  v7 = (__int16)sub_3E1CC((int)v46, a2);
  v48 = v7;
  if ( (__int16)v7 == 1 )
  {
    return v7;
  }
  v52 = (sub_3407C(a2) <= 0) - 1;
  sub_3420C(a2);
  v51 = (v10 <= 0) - 1;
  v11 = (sub_34AE4(a2, 0x26u, 0xFFFFFFFF) == 0xFFFF) - 1;
  sub_34B0C(v38, v39, v40);
  if ( !*(_WORD *)(a2 + 0x1C) || !v52 && !v51 && !v11 )
  {
LABEL_102:
    LOBYTE(v7) = sub_3CCE4(v46, a2);
    return v7;
  }
  if ( v11 == 0xFFFFFFFF )
  {
    LOBYTE(v7) = sub_3E520((int)v46, a2);
    return v7;
  }
  if ( v52 != 0xFFFFFFFF )
  {
    if ( ((1 << *(_BYTE *)(a2 + 0x57)) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104541) >> 0x18)) != 0 )
    {
      LOWORD(v47) = sub_35930(a2, 0x15);
      v47 = (unsigned __int16)v47;
      if ( (unsigned __int16)v47 == 0xFFFF )
      {
        v7 = sub_34AE4(a2, 0x24u, 0);
        if ( v7 != 0xFFFF )
        {
          return v7;
        }
      }
      else
      {
        v35 = v47;
        sub_34B0C(v38, v39, v40);
        if ( sub_34368(a2, 0x24u, v35) )
        {
          LOBYTE(v7) = sub_34774(a2, 0x24u, v47, 0);
          return v7;
        }
      }
    }
    else if ( *(_WORD *)(a2 + 0x1C) > *(_WORD *)(a2 + 0x20) && v45 != 0xFFFFFFFF )
    {
      v7 = sub_34AE4(a2, 0x15u, 0xFFFFFFFF);
      if ( v7 != 0xFFFF )
      {
        return v7;
      }
    }
    goto LABEL_102;
  }
  v47 = 0xFFFFFFFF;
  LOWORD(v7) = *(_WORD *)(a2 + 0x4C);
  v12 = 0;
  if ( (unsigned __int16)v7 < *(_WORD *)(a2 + 0x4A) )
  {
    if ( (unsigned __int16)v7 >= *(_WORD *)(a2 + 0x42) || v48 == 2 )
    {
      return v7;
    }
  }
  else
  {
    v13 = 0;
    v14 = 0;
    while ( v13 < *(unsigned __int16 *)(a2 + 0x18) )
    {
      v15 = v14 + *(_DWORD *)(a2 + 0x10);
      v16 = *(_BYTE *)(v15 + 1);
      if ( v16 != (char)0xFF && v16 != 5 )
      {
        v17 = (char *)&dword_103F9A[0xA * *(unsigned __int8 *)(v15 + 1)] + 2;
        if ( !v17[3] )
        {
          v18 = v17[4];
          if ( v18 > v12 )
          {
            v12 = v18;
            v47 = v13;
          }
        }
      }
      v14 += 4;
      ++v13;
    }
    if ( v47 == 0xFFFFFFFF )
    {
      Q_debugbreak_sub_26194();
      LOBYTE(v7) = sub_37040(a2);
      return v7;
    }
    sub_34B0C(v38, v39, v40);
    LOWORD(v7) = *(_WORD *)(a2 + 0x4C);
    if ( (unsigned __int16)v7 >= *(_WORD *)(a2 + 0x42) )
    {
      return v7;
    }
  }
  if ( *(unsigned __int16 *)(a2 + 0x42) - *(unsigned __int16 *)(a2 + 0x4C) <= 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x85A);
  }
  if ( v53 || (v7 = sub_3E520((int)v46, a2), v7 != 0xFFFFFFFF) )
  {
    v49 = (__int16)sub_3E800(v46, (unsigned __int16 *)a2);
    if ( v49 == 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x870);
    }
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    do
    {
      while ( 1 )
      {
        if ( (_BYTE)v19 != 5 && v19 < (unsigned __int16)word_103F98[0] )
        {
          v23 = (unsigned __int8)byte_103FA1[v21 * 4];
          if ( v23 == 0xFF
            || (v24 = *(_BYTE *)(a2 + 0x57),
                v44 = *(int *)((char *)&dword_10529F + 0x4B * v23) >> 0x18,
                ((1 << v24) & v44) != 0) )
          {
            v44 = *(unsigned __int16 *)(a2 + 0x4A);
            if ( *(int *)((char *)&dword_103F9A[v21] + 3) >> 0x18 <= v44 - *(unsigned __int16 *)(a2 + 0x4C) )
            {
              break;
            }
          }
        }
LABEL_64:
        ++v19;
        v21 += 0xA;
        if ( v19 >= 0x27 )
        {
          goto LABEL_77;
        }
      }
      HIWORD(v25) = HIWORD(v49);
      v26 = (int *)((char *)&dword_103F9A[v21] + 2);
      if ( v49 <= 3 )
      {
        switch ( (unsigned int)v26 )
        {
          case 0u:
            v25 = *(char *)v26;
            if ( !*(_BYTE *)v26 )
            {
              goto LABEL_64;
            }
            *(_WORD *)((char *)&v38 + v22 + 1) = *(char *)v26;
            break;
          case 1u:
            v25 = *((char *)v26 + 1);
            if ( !*((_BYTE *)v26 + 1) )
            {
              goto LABEL_64;
            }
            *(_WORD *)((char *)&v38 + v22 + 1) = *((char *)v26 + 1);
            break;
          case 2u:
            v25 = *((char *)v26 + 2);
            if ( !*((_BYTE *)v26 + 2) )
            {
              goto LABEL_64;
            }
            *(_WORD *)((char *)&v38 + v22 + 1) = *((char *)v26 + 2);
            break;
          case 3u:
            v25 = *v26 >> 0x18;
            if ( !v25 )
            {
              goto LABEL_64;
            }
            *(_WORD *)((char *)&v38 + v22 + 1) = *((char *)v26 + 3);
            break;
        }
      }
      LOWORD(v25) = *((char *)v26 + 3);
      v55 = v25;
      LOWORD(v25) = *((char *)v26 + 2);
      v27 = v25 + v55;
      v22 += 5;
      v56 = v27;
      LOWORD(v27) = *((char *)v26 + 1);
      ++v20;
      v55 = v27;
      v28 = *(char *)v26;
      LOWORD(v27) = v27 + v56;
      v37[v22] = v19;
      *(_WORD *)&v37[v22 + 3] = v27 + v28;
      ++v19;
      v21 += 0xA;
    }
    while ( v19 < 0x27 );
LABEL_77:
    if ( v20 || (v7 = sub_3CCE4(v46, a2), v7 != 0xFFFFFFFF) )
    {
      v29 = rand() % 0x64;
      v30 = 0;
      v57 = 0xFF;
      v50 = v29;
      v31 = 0;
      if ( v20 > 0 )
      {
        v32 = &v38;
        while ( 1 )
        {
          v33 = *(_BYTE *)v32;
          v54 = (unsigned __int8 *)v32;
          if ( (unsigned __int16)sub_35930(a2, v33) == 0xFFFF )
          {
            break;
          }
          if ( v50 <= 0x41 )
          {
            v34 = *(__int16 *)((char *)v32 + 1);
          }
          else
          {
            v34 = *(__int16 *)((char *)v32 + 3);
          }
          if ( v34 > v30 )
          {
            v30 = v34;
            v57 = *v54;
          }
          ++v31;
          v32 = (__int64 *)((char *)v32 + 5);
          if ( v31 >= v20 )
          {
            goto LABEL_90;
          }
        }
        if ( (unsigned __int16)word_103FA4[0x14 * *(unsigned __int8 *)v32] / (int)*(unsigned __int16 *)(a2 + 0x44) < 0x46 )
        {
          v57 = *(_BYTE *)v32;
        }
      }
LABEL_90:
      LOBYTE(v7) = v57;
      if ( v57 != 0xFF )
      {
        v7 = sub_34AE4(a2, v57, 0);
        if ( v7 == 0xFFFF )
        {
          goto LABEL_102;
        }
      }
    }
  }
  return v7;
}
// 3DAD9: variable 'v10' is possibly undefined
// 103F98: using guessed type __int16 word_103F98[];
// 103F9A: using guessed type int dword_103F9A[];
// 103FA4: using guessed type __int16 word_103FA4[];
// 104541: using guessed type char byte_104541;
// 10529F: using guessed type int dword_10529F;

//----- (0003E020) --------------------------------------------------------
unsigned int __fastcall sub_3E020(int a1, int a2, unsigned __int8 a3)
{
  unsigned int result; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // esi
  int v10; // edi
  signed int v11; // eax
  char v12; // cl
  __int64 v13; // [esp+0h] [ebp-30h]
  unsigned int v14; // [esp+8h] [ebp-28h]
  int v15; // [esp+Ch] [ebp-24h]
  signed int v16; // [esp+10h] [ebp-20h]
  unsigned int v17; // [esp+14h] [ebp-1Ch]
  int v18; // [esp+18h] [ebp-18h]

  if ( a3 > 0x1Eu || a3 < 0x16u || a3 == 0x17 )
  {
    return 0;
  }
  sub_36050(a2);
  v16 = 0;
  v18 = 0xFFFFFFFF;
  v14 = 0;
  v6 = v5;
  v17 = 0;
  v7 = sub_35FE0(a2);
  v8 = v7;
  if ( a3 == 0x1A || a3 == 0x1B )
  {
    v17 = 0xFFFFFFFF;
  }
  else if ( a3 == 0x1C || a3 == 0x1D || a3 == 0x1E )
  {
    v14 = 0xFFFFFFFF;
  }
  v15 = v7 - 3;
  v9 = *(unsigned __int16 *)(a2 + 0x18);
  LODWORD(v13) = v6 - 2;
  v10 = 4 * (unsigned __int16)v9;
  HIDWORD(v13) = v6 - 4;
  while ( v9 < *(unsigned __int16 *)(a2 + 0x1A) )
  {
    v12 = *(_BYTE *)(v10 + *(_DWORD *)(a2 + 0x10) + 1);
    v11 = 0xFFFFFFFF;
    if ( v12 != 0x1A || a3 == 0x1A )
    {
      if ( v12 != 0x1C || a3 == 0x1C )
      {
        if ( v12 == 0x1D && a3 != 0x1D && (!v17 || v8 < SHIDWORD(v13)) )
        {
          v11 = 4;
          if ( v8 > v6 )
          {
            v11 = 8;
          }
        }
      }
      else if ( !v17 || v8 < (int)v13 )
      {
        v11 = 2;
        if ( v8 > v6 )
        {
          v11 = 4;
        }
      }
    }
    else if ( !v14 || v6 < v15 )
    {
      v11 = 3;
      if ( v6 > v8 )
      {
        v11 = 6;
      }
    }
    if ( v11 != 0xFFFFFFFF && (v18 == 0xFFFFFFFF || v11 < v16) )
    {
      v18 = v9;
      v16 = v11;
    }
    v10 += 4;
    ++v9;
  }
  if ( v18 == 0xFFFFFFFF )
  {
    return 0;
  }
  result = sub_34B0C(v13, v14, v15);
  if ( result )
  {
    sub_34774(a2, a3, v18, 0);
    return 0xFFFFFFFF;
  }
  return result;
}
// 3E061: variable 'v5' is possibly undefined

//----- (0003E1CC) --------------------------------------------------------
int __fastcall sub_3E1CC(int a1, int a2)
{
  unsigned __int8 v4; // ch
  int v5; // ebx
  int v6; // eax
  int v7; // ebp
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // edx
  unsigned int v14; // [esp+0h] [ebp-28h]
  int v15; // [esp+8h] [ebp-20h]
  unsigned __int8 v16; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 v17; // [esp+10h] [ebp-18h]

  v4 = 0xFF;
  v14 = 0;
  v5 = *(unsigned __int16 *)(a2 + 0x46);
  if ( sub_40590((_BYTE *)a1) )
  {
    v5 = 0x3E8;
  }
  if ( sub_358F0(a2) < 5 )
  {
    return 0;
  }
  v15 = sub_35FE0(a2);
  sub_36050(a2);
  v7 = v6;
  v17 = sub_35DA4(a2);
  v16 = sub_35E24(a2);
  if ( *(unsigned __int16 *)(a2 + 0x1E) < 2u
    || (v8 = *(unsigned __int16 *)(a2 + 0x42), *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v8 < 1)
    && v8 - *(unsigned __int16 *)(a2 + 0x4C) < 2
    || *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    v14 = 0xFFFFFFFF;
  }
  if ( v15 < 1 && v17 != 0xFF )
  {
    v4 = v17;
  }
  if ( v4 == 0xFF && v7 < 1 && v16 != 0xFF )
  {
    v4 = v16;
  }
  if ( v4 == 0xFF
    && (unsigned __int16)sub_35930(a2, 0x16) == 0xFFFF
    && *(unsigned __int16 *)(a2 + 0x14) > 1u
    && (*(unsigned __int16 *)(a2 + 0x44) >= 4u || *(unsigned __int16 *)(a2 + 0x1C) - *(unsigned __int16 *)(a2 + 0x20) < 5) )
  {
    if ( ((*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_104311) >> 0x18) & (1 << *(_BYTE *)a1)) != 0 )
    {
      v4 = 0x16;
    }
  }
  else if ( *(unsigned __int16 *)(a2 + 0x44) < 4u && sub_3407C(a2) > 0 )
  {
    return 0;
  }
  if ( (*(unsigned __int16 *)(a2 + 0x44) < 0x14u || v5 < 0x14)
    && sub_3407C(a2) > 0
    && (v15 > 0 || v17 == 0xFF)
    && (v7 > 0 || v16 == 0xFF) )
  {
    v9 = *(unsigned __int16 *)(a2 + 0x44);
    v10 = v7 + v15;
    if ( (unsigned __int16)v9 <= v5 )
    {
      if ( v10 > v9 )
      {
        return 0;
      }
    }
    else if ( v10 > v5 )
    {
      return 0;
    }
  }
  v11 = 0;
  if ( &word_A3D21[0x30 * *(__int16 *)(a2 + 0xC)] == *(__int16 **)(a1 + 7) )
  {
    v11 = 6;
  }
  if ( v4 != 0xFF || v7 >= v15 || v16 == 0xFF || v7 >= v11 + 6 )
  {
    if ( v4 == 0xFF && v17 != 0xFF && v11 + 6 > v15 )
    {
      v4 = v17;
    }
  }
  else
  {
    v4 = v16;
  }
  v12 = rand() % 0x64;
  if ( v4 == 0xFF && v12 < 0x14 && sub_34368(a2, 0x19u, 0xFFFFu) && (unsigned __int16)sub_35930(a2, 0x19) == 0xFFFF )
  {
    v4 = 0x19;
  }
  if ( v4 != 0xFF || v7 >= v15 || v16 == 0xFF )
  {
    if ( v4 == 0xFF && v17 != 0xFF )
    {
      v4 = v17;
    }
  }
  else
  {
    v4 = v16;
  }
  if ( v4 != 0xFF )
  {
    if ( !v14 && sub_34AE4(a2, v4, 0) != 0xFFFF )
    {
      return 1;
    }
    if ( sub_3E020(a1, a2, v4) )
    {
      return 1;
    }
    if ( v4 != v17 || v16 == 0xFF )
    {
      if ( v4 == v16 && v17 != 0xFF && sub_3E020(a1, a2, v17) )
      {
        return 1;
      }
    }
    else if ( sub_3E020(a1, a2, v16) )
    {
      return 1;
    }
  }
  return 0;
}
// 3E215: variable 'v6' is possibly undefined
// A3D21: using guessed type __int16 word_A3D21[];
// 104311: using guessed type char byte_104311;
// 10529F: using guessed type int dword_10529F;

//----- (0003E520) --------------------------------------------------------
unsigned int __fastcall sub_3E520(int a1, int a2)
{
  unsigned int result; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // esi
  int v9; // edx
  int v10; // eax
  unsigned __int16 v11; // di
  int v12; // edx
  __int16 i; // di
  unsigned __int8 v14; // si
  int v15; // [esp+0h] [ebp-24h]
  char v16; // [esp+4h] [ebp-20h]
  unsigned __int8 v17; // [esp+8h] [ebp-1Ch]
  unsigned __int8 v18; // [esp+Ch] [ebp-18h]

  if ( (*(_BYTE *)(a2 + 0x66) & 2) != 0 && sub_34AE4(a2, 0x26u, 0) != 0xFFFF )
  {
    result = 0xFFFFFFFF;
    *(_BYTE *)(a2 + 0x66) &= ~2u;
    return result;
  }
  v5 = 3;
  if ( sub_40590((_BYTE *)a1) == 0xFFFFFFFF )
  {
    v5 = 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x44) < 3u )
  {
    return 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x46) < v5 )
  {
    return 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x48) < 2u )
  {
    return 0;
  }
  v6 = *(unsigned __int16 *)(a2 + 0x42);
  if ( *(unsigned __int16 *)(a2 + 0x4A) - (unsigned __int16)v6 < 1 && v6 - *(unsigned __int16 *)(a2 + 0x4C) < 2 )
  {
    return 0;
  }
  if ( *(unsigned __int16 *)(a2 + 0x1C) - *(unsigned __int16 *)(a2 + 0x20) < 3 )
  {
    return 0;
  }
  sub_36158(a2);
  v8 = v7;
  if ( &word_A3D21[0x30 * *(__int16 *)(a2 + 0xC)] == *(__int16 **)(a1 + 7) )
  {
    v9 = *(unsigned __int16 *)(a2 + 0x18);
  }
  else
  {
    v9 = 2 * *(unsigned __int16 *)(a2 + 0x18);
  }
  v10 = v9 / 5;
  if ( v9 / 5 < 4 )
  {
    v10 = 4;
  }
  if ( (*(unsigned __int16 *)(a2 + 0x44) < 0x14u || *(unsigned __int16 *)(a2 + 0x46) < 0x14u) && v8 > 0 )
  {
    v11 = *(_WORD *)(a2 + 0x46);
    v12 = 3 * v8;
    if ( *(_WORD *)(a2 + 0x44) <= v11 )
    {
      if ( v12 <= 2 * *(unsigned __int16 *)(a2 + 0x44) )
      {
        goto LABEL_25;
      }
    }
    else if ( v12 <= 2 * v11 )
    {
      goto LABEL_25;
    }
    v10 = v8;
  }
LABEL_25:
  if ( v8 < v10 )
  {
    v17 = 0xFF;
    if ( sub_34368(a2, 0x13u, 0xFFFFu) )
    {
      v17 = 0x13;
    }
    else if ( sub_34368(a2, 0x12u, 0xFFFFu) )
    {
      v17 = 0x12;
    }
    if ( v17 != 0xFF && sub_34AE4(a2, v17, 0) )
    {
      return 0xFFFFFFFF;
    }
  }
  if ( *(unsigned __int8 *)(a2 + 0x57) % 2
    && *(unsigned __int16 *)(a2 + 0x44) > 0x14u
    && rand() % 0x64 < 4
    && sub_34368(a2, 0xBu, 0xFFFFu)
    && (unsigned __int16)sub_35930(a2, 0xB) == 0xFFFF
    && sub_34AE4(a2, 0xBu, 0) )
  {
    return 0xFFFFFFFF;
  }
  v15 = unk_96918;
  v16 = *((_BYTE *)&unk_96918 + 4);
  for ( i = 0; i < 5; ++i )
  {
    v18 = *((_BYTE *)&v15 + i);
    if ( (v18 != 0x25 || (*(_BYTE *)(a2 + 0x66) & 1) == 0)
      && sub_34368(a2, v18, 0xFFFFu)
      && (sub_40590((_BYTE *)a1) == 0xFFFFFFFF || v18 != 0xE) )
    {
      v14 = v18;
      if ( (unsigned __int16)sub_35930(a2, v18) == 0xFFFF )
      {
        if ( sub_34AE4(a2, v14, 0) )
        {
          return 0xFFFFFFFF;
        }
      }
    }
  }
  return 0;
}
// 3E5E7: variable 'v7' is possibly undefined
// A3D21: using guessed type __int16 word_A3D21[];

//----- (0003E800) --------------------------------------------------------
int __fastcall sub_3E800(_BYTE *a1, unsigned __int16 *a2)
{
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // ecx
  int v11; // [esp+0h] [ebp-1Ch] BYREF
  int v12; // [esp+4h] [ebp-18h] BYREF
  int v13[5]; // [esp+8h] [ebp-14h] BYREF

  sub_34A44((int)a2, &v12, &v11, v13);
  v3 = sub_40590(a1);
  if ( v3 == 0xFFFFFFFF )
  {
    v4 = v12;
    v12 = 0;
    v11 += v4;
    v13[0] += v4;
  }
  v5 = a2[0x21];
  if ( a2[0x25] - (unsigned __int16)v5 >= 2 || v5 - a2[0x26] >= 2 )
  {
    if ( a2[0x22] < 3u && v11 > 0 )
    {
      return 0;
    }
    if ( a2[0x23] < 3u && v12 > 0 && !v3 )
    {
      return 1;
    }
    if ( a2[0x24] < 2u && v13[0] > 0 )
    {
      return 2;
    }
    if ( a2[0x22] < 4u && v11 > 0 )
    {
      return 0;
    }
    if ( a2[0x24] < 3u && v13[0] > 0 )
    {
      return 2;
    }
    if ( a2[0x23] < 5u && v12 > 0 && !v3 )
    {
      return 1;
    }
    if ( !a2[0x24] )
    {
      return 2;
    }
    if ( a2[0x24] < 2u )
    {
      v7 = a2[0x21];
      if ( a2[0x25] - (unsigned __int16)v7 < 1 && v7 - a2[0x26] < 1 )
      {
        return 2;
      }
    }
    if ( v13[0] > 0 && dword_9684C / a2[0x24] > 0xF )
    {
      v8 = a2[0x21];
      if ( a2[0x25] - (unsigned __int16)v8 > 3 && v8 - a2[0x26] != 1 )
      {
        return 2;
      }
    }
    if ( v3 == 0xFFFFFFFF )
    {
      if ( v11 > 0 )
      {
        return 0;
      }
      if ( v13[0] > 0 && a2[0x24] < 5u )
      {
        return 2;
      }
    }
    else
    {
      v9 = a2[0x22];
      v10 = a2[0x23];
      if ( (unsigned __int16)sub_35930((int)a2, 0xC) != 0xFFFF )
      {
        v10 += v9 >> 1;
      }
      if ( (unsigned __int16)sub_35930((int)a2, 0xE) != 0xFFF )
      {
        v9 += v10 >> 1;
      }
      if ( (v9 > v10 || v11 <= 0) && v12 > 0 )
      {
        return 1;
      }
      if ( v11 > 0 )
      {
        return 0;
      }
      if ( v13[0] > 0 )
      {
        return 2;
      }
    }
  }
  return 3;
}
// 9684C: using guessed type int dword_9684C;
// 3E800: using guessed type int var_14[5];

//----- (0003EA7C) --------------------------------------------------------
__int16 __fastcall sub_3EA7C(_BYTE *a1)
{
  signed __int16 v2; // si
  int v3; // eax
  int v4; // edi
  __int16 i; // si
  __int16 j; // ax
  __int16 v8[32]; // [esp+0h] [ebp-90h]
  __int16 v9[24]; // [esp+40h] [ebp-50h] BYREF
  int v10; // [esp+70h] [ebp-20h]
  int v11; // [esp+74h] [ebp-1Ch]

  v2 = 0;
  v10 = 0;
  while ( 1 )
  {
    LOWORD(v3) = word_105258;
    if ( v2 >= (int)(unsigned __int16)word_105258 )
    {
      break;
    }
    v4 = (unsigned __int16)v10;
    if ( (unsigned __int16)v10 >= 0x20u )
    {
      break;
    }
    if ( ((1 << *a1) & (*(int *)((char *)&dword_10529F + 0x4B * v2) >> 0x18)) == 0 )
    {
      if ( sub_4694C((int)&word_105258, v2, (unsigned __int8)*a1) )
      {
        v8[v4] = v2;
        v10 = v4 + 1;
      }
    }
    ++v2;
  }
  LOWORD(v11) = 0xFFFF;
  if ( (_WORD)v10 )
  {
    qmemcpy(v9, &unk_9691E, 0x2Eu);
    if ( ((1 << *a1) & SHIBYTE(dword_105416)) != 0 && rand() % 0x64 < 0x2D )
    {
      LOWORD(v11) = 0xFFFE;
    }
    for ( i = 0; i < (int)(unsigned __int16)v10 && (__int16)v11 == 0xFFFFFFFF; ++i )
    {
      for ( j = 0; j < 0x17 && (__int16)v11 == 0xFFFFFFFF; ++j )
      {
        if ( v9[j] == v8[i] )
        {
          LOWORD(v11) = v8[i];
        }
      }
    }
    if ( (v11 & 0x8000u) != 0 )
    {
      LOWORD(v11) = v8[rand() % (unsigned __int16)v10];
    }
    v3 = (unsigned __int8)*a1;
    word_106FA6[v3] = v11;
  }
  return v3;
}
// 10529F: using guessed type int dword_10529F;
// 105416: using guessed type int dword_105416;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 3EA7C: using guessed type __int16 var_90[32];
// 3EA7C: using guessed type __int16 var_50[24];

//----- (0003EBDC) --------------------------------------------------------
char __fastcall sub_3EBDC(unsigned __int8 *a1, int a2)
{
  unsigned __int8 *v2; // ecx
  char v3; // ah
  int v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // esi
  int v10; // eax
  int v11; // ecx
  double v12; // st7
  double v13; // st7
  double v14; // st7
  int v15; // eax
  int v17; // [esp+4h] [ebp-40h]
  int v18; // [esp+8h] [ebp-3Ch]
  float v19; // [esp+Ch] [ebp-38h]
  unsigned int v20; // [esp+10h] [ebp-34h]
  int v21; // [esp+14h] [ebp-30h]
  __int16 *v22; // [esp+1Ch] [ebp-28h]
  float v23; // [esp+20h] [ebp-24h]
  float v24; // [esp+20h] [ebp-24h]
  __int16 v25; // [esp+24h] [ebp-20h]
  __int16 v26; // [esp+28h] [ebp-1Ch]
  unsigned __int8 v27; // [esp+2Ch] [ebp-18h]

  v2 = a1;
  v3 = *(_BYTE *)(a2 + 0x58);
  if ( v3 != 1 && v3 != 2 && v3 != 5 )
  {
    LOBYTE(a1) = byte_104BEA;
    if ( *(_WORD *)(a2 + 0x56) == (unsigned __int8)byte_104BEA && !dword_A0D00 )
    {
      *(_BYTE *)(a2 + 0x5D) = 0;
      *(_DWORD *)(a2 + 0x5E) = 0;
      return (char)a1;
    }
    if ( *(_BYTE *)(a2 + 0x58) == 4 && *(_BYTE *)(a2 + 0x5D) == 1 )
    {
      v4 = *(_DWORD *)(a2 + 0x59);
      if ( !v4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBBC);
      }
      if ( *(_DWORD *)(a2 + 0x28) )
      {
        v5 = *(__int16 *)(v4 + 4);
        if ( *(int *)((char *)&dword_104FD1 + v5) >> 0x18 > 0 )
        {
          --*((_BYTE *)&dword_104FD1 + v5 + 3);
        }
      }
      else if ( sub_4A534(a2, 0x49) )
      {
        v6 = *(__int16 *)(v4 + 4);
        if ( *(int *)((char *)&dword_104F6D + v6) >> 0x18 > 0 )
        {
          --*((_BYTE *)&dword_104F6D + v6 + 3);
        }
      }
      else
      {
        v7 = *(__int16 *)(v4 + 4);
        if ( *(int *)((char *)&dword_104F09 + v7) >> 0x18 > 0 )
        {
          --*((_BYTE *)&dword_104F09 + v7 + 3);
        }
      }
      *(_BYTE *)(a2 + 0x5D) = 0;
      *(_DWORD *)(a2 + 0x5E) = 0;
    }
    LOBYTE(a1) = *(_BYTE *)(a2 + 0x5D);
    if ( !(_BYTE)a1 )
    {
      if ( *(_BYTE *)(a2 + 0x58) == 3 && sub_35C38(*(_DWORD *)(a2 + 0x59), a2) != 0xFFFFFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBE7);
      }
      if ( *(_BYTE *)(a2 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBEB);
      }
      a1 = *(unsigned __int8 **)(a2 + 0x59);
      v17 = (int)a1;
      if ( !a1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xBEF);
      }
      if ( *(_DWORD *)(a2 + 0x28) == 0xFFFFFFFF )
      {
        a1 = (unsigned __int8 *)sub_403C0(v2, *(_DWORD *)(a2 + 0x59));
        if ( a1 )
        {
          *(_BYTE *)(a2 + 0x5D) = 2;
          *(_DWORD *)(a2 + 0x5E) = a1;
          return (char)a1;
        }
      }
      if ( *(int *)(a2 + 8) > 0 || *(int *)(a2 + 0xC) > 0 )
      {
        v8 = 0;
        v9 = 0;
        v19 = 0.0;
        v25 = 0;
        v18 = 0;
        v20 = sub_4A534(a2, 0x49);
        v22 = word_A3D21;
        v27 = sub_43374(v2, 0xFFFFFFFF);
        while ( 1 )
        {
          if ( v9 >= word_A62A1 )
          {
            LOBYTE(a1) = v18;
            if ( v18 )
            {
              if ( v18 != v17 )
              {
                a1 = (unsigned __int8 *)sub_4AA78(a2, v18);
                if ( (int)a1 > 0 )
                {
                  LOBYTE(a1) = v25;
                  if ( v25 != *(_WORD *)(v17 + 4) )
                  {
                    if ( *(_DWORD *)(a2 + 0x28) )
                    {
                      LOBYTE(a1) = v25;
                      ++*((_BYTE *)&dword_104FD1 + v25 + 3);
                    }
                    else
                    {
                      LOBYTE(a1) = v25;
                      if ( v20 )
                      {
                        ++*((_BYTE *)&dword_104F6D + v25 + 3);
                      }
                      else
                      {
                        ++*((_BYTE *)&dword_104F09 + v25 + 3);
                      }
                    }
                  }
                }
              }
            }
            return (char)a1;
          }
          if ( dword_104BEC[v8] > 0 || dword_104D7C[v8] > 0 )
          {
            break;
          }
LABEL_56:
          ++v8;
          ++v9;
          v22 += 0x30;
        }
        v26 = sub_4AA78(a2, (int)v22);
        v15 = *((unsigned __int8 *)v22 + 0x14);
        v21 = *((unsigned __int8 *)v22 + 0x15);
        if ( ((v15 | v21) & v27) != 0 )
        {
          if ( *(_DWORD *)(a2 + 0x28) )
          {
            if ( ((unsigned __int8)v15 & v27) != 0 && (v27 & (unsigned __int8)v21) == 0 )
            {
              if ( *(int *)((char *)&dword_104FD1 + v9) >> 0x18 <= 0 )
              {
                v13 = (double)dword_104BEC[v8];
                goto LABEL_53;
              }
LABEL_35:
              v23 = 0.0;
              goto LABEL_54;
            }
LABEL_36:
            v23 = 0.0;
            goto LABEL_54;
          }
          if ( v20 )
          {
            if ( ((unsigned __int8)v15 & v27) == 0 )
            {
              goto LABEL_35;
            }
            v10 = *(int *)((char *)&dword_104F6D + v9) >> 0x18;
            v23 = (float)dword_104BEC[v8];
            if ( v10 <= 1 )
            {
              goto LABEL_54;
            }
            LOBYTE(v11) = v10 - 1;
          }
          else
          {
            if ( ((unsigned __int8)v15 & v27) != 0 )
            {
              v12 = (double)(dword_104D7C[v8] + dword_104BEC[v8]);
            }
            else
            {
              v12 = (double)dword_104D7C[v8];
            }
            v23 = v12;
            if ( *(int *)((char *)&dword_104F09 + v9) >> 0x18 <= 0 )
            {
              goto LABEL_54;
            }
            LOBYTE(v11) = HIBYTE(*(unsigned int *)((char *)&dword_104F09 + v9));
          }
        }
        else
        {
          if ( *(_DWORD *)(a2 + 0x28) )
          {
            if ( *(int *)((char *)&dword_104FD1 + v9) >> 0x18 > 0 )
            {
              goto LABEL_36;
            }
            v13 = (double)dword_104BEC[v8];
LABEL_53:
            v23 = v13;
            goto LABEL_54;
          }
          if ( v20 )
          {
            v23 = *(float *)(a2 + 0x28);
            goto LABEL_54;
          }
          v11 = *(int *)((char *)&dword_104F09 + v9) >> 0x18;
          v23 = (float)dword_104D7C[v8];
          if ( v11 <= 0 )
          {
LABEL_54:
            v14 = v23 / (double)(v26 / 0x19 + 1);
            if ( v14 > v19 )
            {
              v18 = (int)v22;
              v25 = v9;
              v24 = v14;
              v19 = v24;
            }
            goto LABEL_56;
          }
        }
        v13 = v23 / (double)(1 << v11);
        goto LABEL_53;
      }
    }
  }
  return (char)a1;
}
// A0D00: using guessed type int dword_A0D00;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// 104BEC: using guessed type int dword_104BEC[100];
// 104D7C: using guessed type int dword_104D7C[99];
// 104F09: using guessed type int dword_104F09;
// 104F6D: using guessed type int dword_104F6D;
// 104FD1: using guessed type int dword_104FD1;

//----- (0003EFE0) --------------------------------------------------------
size_t __fastcall sub_3EFE0(int a1)
{
  int v2; // ebx
  __int16 *v3; // edx
  size_t v4; // ebp
  int i; // eax
  size_t result; // eax

  v2 = 1;
  v3 = word_A3D21;
  v4 = sub_40224((unsigned __int8 *)a1, 0, 0);
  for ( i = 0; (__int16)i < word_A62A1; v3 += 0x30 )
  {
    if ( *((unsigned __int8 *)v3 + 0x14) == 1 << *(_BYTE *)a1 )
    {
      ++v2;
    }
    ++i;
  }
  result = v2 - v4;
  if ( ((1 << *(_BYTE *)a1) & *(unsigned __int8 *)(*(_DWORD *)(a1 + 7) + 0x14)) != 0 )
  {
    ++result;
  }
  return result;
}
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (0003F060) --------------------------------------------------------
__int16 __fastcall sub_3F060(unsigned __int8 *a1, _DWORD *a2, int a3, unsigned __int8 a4)
{
  int v6; // eax
  __int16 v7; // cx
  int v8; // edx
  char v9; // bl
  char v10; // bh
  __int16 result; // ax
  int v12; // [esp+0h] [ebp-26h]
  __int16 v13; // [esp+6h] [ebp-20h]
  char v14; // [esp+Ah] [ebp-1Ch]
  char v15; // [esp+Eh] [ebp-18h]
  char v16; // [esp+12h] [ebp-14h]

  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xCD0);
  }
  v13 = 0;
  v6 = 1 << *a1;
  if ( (v6 & SHIBYTE(dword_1052EA)) != 0 )
  {
    v13 = 1;
    if ( (v6 & SHIBYTE(dword_105830)) != 0 )
    {
      v13 = 2;
      if ( (v6 & SHIBYTE(dword_105BB4)) != 0 )
      {
        v13 = 3;
      }
    }
  }
  if ( !v13 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xCE2);
  }
  HIWORD(v12) = dword_A2F6C[0] / 0xFA;
  v7 = v13;
  if ( SHIWORD(v12) >= 1 )
  {
    if ( SHIWORD(v12) > 8 )
    {
      HIWORD(v12) = 8;
    }
  }
  else
  {
    HIWORD(v12) = 1;
  }
  while ( v7 >= 0 )
  {
    sub_49148((int)a2, v7);
    v8 = sub_4A18C((int)a2) + *(_DWORD *)((char *)a2 + 0x15A) * (v12 >> 0x10);
    if ( !*(_WORD *)(a3 + 0x44) )
    {
      *(_WORD *)(a3 + 0x44) = 1;
    }
    if ( v8 / *(unsigned __int16 *)(a3 + 0x44) + 1 < *((__int16 *)a1 + 0xD8) )
    {
      break;
    }
    --v7;
  }
  if ( v7 < 0 )
  {
    v7 = 0;
  }
  sub_49148((int)a2, v7);
  v15 = sub_4A36C((int)a2, 0, *a1);
  v14 = sub_4A36C((int)a2, 4, *a1);
  v16 = sub_4A36C((int)a2, 2, *a1);
  v9 = sub_4A36C((int)a2, 1, *a1);
  v10 = 0x2B;
  if ( sub_4A404((int)a2, 0x2C) )
  {
    v10 = 0x2C;
  }
  if ( v14 == (char)0xFF )
  {
    v14 = 0x1B;
  }
  if ( v16 == (char)0xFF )
  {
    v16 = 0x10;
  }
  if ( v15 == (char)0xFF )
  {
    v15 = 0;
  }
  if ( v9 == (char)0xFF )
  {
    v9 = 0xA;
  }
  result = v7;
  switch ( v7 )
  {
    case 0:
      result = sub_3F324((int)a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    case 1:
      result = sub_3F3F8(a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    case 2:
      result = sub_3F784((int)a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    case 3:
      result = sub_3FBAC((int)a1, v14, v16, v15, v9, v10, a2, a4);
      break;
    default:
      return result;
  }
  return result;
}
// 3F0F5: conditional instruction was optimized away because %var_20.2 is in (1..3)
// 3F15C: variable 'v12' is possibly undefined
// A2F6C: using guessed type int dword_A2F6C[];
// 1052EA: using guessed type int dword_1052EA;
// 105830: using guessed type int dword_105830;
// 105BB4: using guessed type int dword_105BB4;

//----- (0003F324) --------------------------------------------------------
unsigned int __fastcall sub_3F324(int a1, char a2, char a3, char a4, int a5, char a6, _DWORD *a7, unsigned __int8 a8)
{
  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a3, 1);
  sub_492AC(a7, a6, 2);
  if ( a8 )
  {
    if ( a8 > 1u && a8 == 2 )
    {
      sub_492AC(a7, 0x49, 3);
      return sub_492AC(a7, 0x49, 4);
    }
    else
    {
      sub_492AC(a7, a4, 3);
      return sub_492AC(a7, a4, 4);
    }
  }
  else
  {
    sub_492AC(a7, 0x47, 3);
    return sub_492AC(a7, 0x47, 4);
  }
}

//----- (0003F3F8) --------------------------------------------------------
unsigned int __fastcall sub_3F3F8(
        unsigned __int8 *a1,
        char a2,
        char a3,
        char a4,
        char a5,
        char a6,
        _DWORD *a7,
        unsigned __int8 a8)
{
  int v9; // ecx
  int v10; // edi
  int v11; // ecx
  int v12; // ecx
  unsigned int result; // eax
  int v14; // edx
  char v15; // edx^3
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx
  int v19; // ecx
  int v20; // ecx
  int v21; // ebx
  int v22; // ebx
  int v23; // ecx
  int v24; // edx
  char v25; // edx^3
  int v26; // ebx
  int v27; // ecx
  int v28; // ebx
  int v29; // ecx
  int v30; // ebx
  int v31; // ecx
  int v32; // edx
  char v33; // edx^3
  int v34; // ebx

  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a2, 1);
  sub_492AC(a7, a3, 2);
  sub_492AC(a7, a6, 3);
  v9 = 4;
  if ( (int)a7[6] < 8 )
  {
    v9 = 5;
    sub_492AC(a7, a2, 4);
  }
  v10 = v9 + 1;
  if ( !a8 )
  {
    sub_492AC(a7, 0x47, v9);
    sub_492AC(a7, 0x47, v10);
    sub_492AC(a7, 0x47, v9 + 2);
    sub_492AC(a7, 0x49, v9 + 3);
    v12 = v9 + 5;
    result = sub_492AC(a7, a6, v10 + 3);
    if ( v10 + 4 >= 0xA )
    {
      return result;
    }
    while ( 1 )
    {
      v14 = rand() % 0x64;
      if ( v14 > 0x4B )
      {
        break;
      }
      if ( v14 > 0x32 )
      {
        v15 = a5;
        goto LABEL_17;
      }
      if ( v14 <= 0x19 )
      {
        v15 = a6;
        goto LABEL_17;
      }
      result = sub_492AC(a7, 0x47, v12++);
LABEL_18:
      if ( v12 >= 0xA )
      {
        return result;
      }
    }
    v15 = a2;
LABEL_17:
    v16 = v12++;
    result = sub_492AC(a7, v15, v16);
    goto LABEL_18;
  }
  if ( a8 > 1u && a8 == 2 )
  {
    if ( a4 == 5 || !sub_4A404((int)a7, 5) )
    {
      v28 = v9;
      v27 = v9 + 1;
      sub_492AC(a7, a4, v28);
    }
    else
    {
      sub_492AC(a7, 5, v9);
      v27 = v9 + 1;
    }
    sub_492AC(a7, 0x49, v27);
    v29 = v27 + 1;
    sub_492AC(a7, 0x49, v29++);
    sub_492AC(a7, 0x49, v29);
    v30 = v29 + 1;
    v31 = v29 + 2;
    result = sub_492AC(a7, a5, v30);
    if ( v31 >= 0xA )
    {
      return result;
    }
    while ( 1 )
    {
      v32 = rand() % 0x64;
      if ( v32 > 0x4B )
      {
        break;
      }
      if ( v32 > 0x32 )
      {
        v33 = a5;
        goto LABEL_48;
      }
      if ( v32 <= 0x19 )
      {
        v33 = a6;
        goto LABEL_48;
      }
      result = sub_492AC(a7, 0x49, v31++);
LABEL_49:
      if ( v31 >= 0xA )
      {
        return result;
      }
    }
    v33 = a2;
LABEL_48:
    v34 = v31++;
    result = sub_492AC(a7, v33, v34);
    goto LABEL_49;
  }
  if ( a4 == 5 || !sub_4A404((int)a7, 5) )
  {
    v17 = v9;
    v11 = v9 + 1;
    sub_492AC(a7, a4, v17);
  }
  else
  {
    sub_492AC(a7, 5, v9);
    v11 = v9 + 1;
  }
  v18 = v11;
  v19 = v11 + 1;
  sub_492AC(a7, a4, v18);
  sub_492AC(a7, a4, v19++);
  sub_492AC(a7, a5, v19);
  v20 = v19 + 1;
  if ( sub_4A404((int)a7, 0x24) )
  {
    sub_492AC(a7, 0x24, v20++);
  }
  if ( a6 == 0x2B || dword_A2F6C[0] > 0x320 || *(int *)((char *)&dword_A3CF2 + 6 * *a1 + 2) >> 0x10 >= 3 )
  {
    v21 = v20++;
    sub_492AC(a7, a6, v21);
  }
  sub_492AC(a7, a5, v20);
  v22 = v20 + 1;
  v23 = v20 + 2;
  result = sub_492AC(a7, 0x49, v22);
  if ( v23 < 0xA )
  {
    while ( 1 )
    {
      v24 = rand() % 0x64;
      if ( v24 > 0x42 )
      {
        break;
      }
      if ( v24 <= 0x21 )
      {
        v25 = a5;
        goto LABEL_33;
      }
      result = sub_492AC(a7, 0x49, v23++);
LABEL_34:
      if ( v23 >= 0xA )
      {
        return result;
      }
    }
    v25 = a2;
LABEL_33:
    v26 = v23++;
    result = sub_492AC(a7, v25, v26);
    goto LABEL_34;
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3CF2: using guessed type int dword_A3CF2;

//----- (0003F784) --------------------------------------------------------
unsigned int __fastcall sub_3F784(int a1, char a2, char a3, char a4, char a5, char a6, _DWORD *a7, unsigned __int8 a8)
{
  int v8; // esi
  int v9; // ebp
  int v10; // esi
  int v11; // esi
  int v12; // esi
  unsigned int result; // eax
  int v14; // edx
  int v15; // ebx
  int v16; // ebx
  char v17; // dl
  int v18; // ebx
  int v19; // esi
  int v20; // ebx
  int v21; // esi
  int v22; // esi
  int v23; // ecx
  int v24; // esi
  char v25; // dl
  int v26; // esi
  int v27; // ebx
  int v28; // esi
  int v29; // ebx
  int v30; // esi
  int v31; // edx
  int v32; // ebx
  int v33; // ebx
  char v34; // dl

  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a2, 1);
  sub_492AC(a7, a2, 2);
  sub_492AC(a7, a3, 3);
  sub_492AC(a7, a6, 4);
  sub_492AC(a7, a6, 5);
  v8 = 6;
  if ( (int)a7[6] < 0x10 )
  {
    v8 = 7;
    sub_492AC(a7, a2, 6);
  }
  v9 = v8 + 1;
  if ( a8 )
  {
    if ( a8 <= 1u || a8 != 2 )
    {
      sub_492AC(a7, a4, v8);
      v10 = v8 + 1;
      if ( a4 == 7 || !sub_4A404((int)a7, 7) )
      {
        v18 = v10;
        v11 = v10 + 1;
        sub_492AC(a7, a4, v18);
      }
      else
      {
        sub_492AC(a7, 7, v10);
        v11 = v10 + 1;
      }
      if ( a4 == 5 || !sub_4A404((int)a7, 5) )
      {
        v20 = v11;
        v19 = v11 + 1;
        sub_492AC(a7, a4, v20);
      }
      else
      {
        sub_492AC(a7, 5, v11);
        v19 = v11 + 1;
      }
      sub_492AC(a7, a5, v19);
      v21 = v19 + 1;
      if ( a6 == 0x2B )
      {
        sub_492AC(a7, 0x2B, v21++);
      }
      sub_492AC(a7, 0x49, v21);
      v22 = v21 + 1;
      if ( sub_4A404((int)a7, 0x39) )
      {
        sub_492AC(a7, 0x39, v22++);
      }
      if ( sub_4A404((int)a7, 0x24) )
      {
        sub_492AC(a7, 0x24, v22++);
      }
      if ( sub_4A404((int)a7, 0x41) )
      {
        sub_492AC(a7, 0x41, v22++);
      }
      v23 = v22 + 2;
      sub_492AC(a7, 0x46, v22);
      v24 = v22 + 1;
      if ( sub_4A404((int)a7, 0x23) )
      {
        v25 = 0x23;
      }
      else
      {
        if ( !sub_4A404((int)a7, 0x21) )
        {
          return sub_40084(a1, a7, v24, a2);
        }
        v25 = 0x21;
      }
      sub_492AC(a7, v25, v24);
      v24 = v23;
      return sub_40084(a1, a7, v24, a2);
    }
    if ( a4 == 5 || !sub_4A404((int)a7, 5) )
    {
      v27 = v8;
      v26 = v8 + 1;
      sub_492AC(a7, a4, v27);
    }
    else
    {
      sub_492AC(a7, 5, v8);
      v26 = v8 + 1;
    }
    sub_492AC(a7, 0x49, v26);
    v28 = v26 + 1;
    sub_492AC(a7, 0x49, v28++);
    sub_492AC(a7, 0x49, v28++);
    sub_492AC(a7, 0x49, v28++);
    sub_492AC(a7, a5, v28);
    v29 = v28 + 1;
    v30 = v28 + 2;
    result = sub_492AC(a7, a6, v29);
    while ( v30 < 0xF )
    {
      v31 = rand() % 0x64;
      if ( v31 <= 0x4B )
      {
        if ( v31 <= 0x32 )
        {
          if ( v31 <= 0x19 )
          {
            v33 = v30;
            v34 = a6;
          }
          else
          {
            v34 = 0x49;
            v33 = v30;
          }
        }
        else
        {
          v33 = v30;
          v34 = a5;
        }
        result = sub_492AC(a7, v34, v33);
        ++v30;
      }
      else
      {
        v32 = v30++;
        result = sub_492AC(a7, a2, v32);
      }
    }
  }
  else
  {
    sub_492AC(a7, 0x47, v8);
    sub_492AC(a7, 0x47, v9);
    sub_492AC(a7, 0x47, v8 + 2);
    sub_492AC(a7, 0x47, v8 + 3);
    sub_492AC(a7, 0x49, v8 + 4);
    sub_492AC(a7, a5, v8 + 5);
    v12 = v8 + 7;
    result = sub_492AC(a7, a6, v9 + 5);
    if ( v9 + 6 < 0xF )
    {
      do
      {
        v14 = rand() % 0x64;
        if ( v14 <= 0x50 )
        {
          if ( v14 <= 0x3C )
          {
            if ( v14 <= 0x28 )
            {
              if ( v14 <= 0x14 )
              {
                v16 = v12;
                v17 = a6;
              }
              else
              {
                v17 = 0x47;
                v16 = v12;
              }
            }
            else
            {
              v17 = 0x49;
              v16 = v12;
            }
          }
          else
          {
            v16 = v12;
            v17 = a5;
          }
          result = sub_492AC(a7, v17, v16);
          ++v12;
        }
        else
        {
          v15 = v12++;
          result = sub_492AC(a7, a2, v15);
        }
      }
      while ( v12 < 0xF );
    }
  }
  return result;
}

//----- (0003FBAC) --------------------------------------------------------
unsigned int __fastcall sub_3FBAC(int a1, char a2, char a3, char a4, char a5, char a6, _DWORD *a7, unsigned __int8 a8)
{
  int v8; // esi
  int v9; // ebp
  int v10; // ebx
  int v11; // esi
  int v12; // esi
  int v13; // esi
  unsigned int result; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // ebx
  char v18; // dl
  int v19; // ebx
  int v20; // esi
  int v21; // ebx
  int v22; // esi
  int v23; // ebx
  int v24; // esi
  int v25; // esi
  int v26; // ebp
  int v27; // esi
  int v28; // esi
  char v29; // dl
  int v30; // esi
  int v31; // ebx
  int v32; // esi
  int v33; // ebx
  int v34; // esi
  int v35; // edx
  int v36; // ebx
  int v37; // ebx
  char v38; // dl

  sub_492AC(a7, a2, 0);
  sub_492AC(a7, a2, 1);
  sub_492AC(a7, a2, 2);
  sub_492AC(a7, a2, 3);
  sub_492AC(a7, a3, 4);
  sub_492AC(a7, a3, 5);
  sub_492AC(a7, a6, 6);
  sub_492AC(a7, a6, 7);
  sub_492AC(a7, a5, 8);
  v8 = 9;
  if ( (int)a7[6] < 0x18 )
  {
    v8 = 0xA;
    sub_492AC(a7, a2, 9);
  }
  if ( a6 == 0x2B )
  {
    sub_492AC(a7, 0x2B, v8++);
  }
  v9 = v8 + 1;
  if ( a8 )
  {
    if ( a8 <= 1u || a8 != 2 )
    {
      v10 = v8;
      v11 = v8 + 1;
      sub_492AC(a7, a4, v10);
      if ( a4 == 7 || !sub_4A404((int)a7, 7) )
      {
        v19 = v11;
        v12 = v11 + 1;
        sub_492AC(a7, a4, v19);
      }
      else
      {
        sub_492AC(a7, 7, v11);
        v12 = v11 + 1;
      }
      if ( a4 == 5 || !sub_4A404((int)a7, 5) )
      {
        v21 = v12;
        v20 = v12 + 1;
        sub_492AC(a7, a4, v21);
      }
      else
      {
        sub_492AC(a7, 5, v12);
        v20 = v12 + 1;
      }
      if ( a4 == 8 || !sub_4A404((int)a7, 8) )
      {
        v23 = v20;
        v22 = v20 + 1;
        sub_492AC(a7, a4, v23);
      }
      else
      {
        sub_492AC(a7, 8, v20);
        v22 = v20 + 1;
      }
      sub_492AC(a7, 0x49, v22);
      v24 = v22 + 1;
      sub_492AC(a7, 0x49, v24);
      v25 = v24 + 1;
      if ( sub_4A404((int)a7, 0x39) )
      {
        sub_492AC(a7, 0x39, v25++);
      }
      if ( sub_4A404((int)a7, 0x24) )
      {
        sub_492AC(a7, 0x24, v25++);
      }
      if ( sub_4A404((int)a7, 0x41) )
      {
        sub_492AC(a7, 0x41, v25++);
      }
      v26 = v25 + 4;
      sub_492AC(a7, 0x46, v25);
      v27 = v25 + 1;
      sub_492AC(a7, 0x46, v27++);
      sub_492AC(a7, a6, v27);
      v28 = v27 + 1;
      if ( sub_4A404((int)a7, 0x23) )
      {
        v29 = 0x23;
      }
      else
      {
        if ( !sub_4A404((int)a7, 0x21) )
        {
          return sub_40084(a1, a7, v28, a2);
        }
        v29 = 0x21;
      }
      sub_492AC(a7, v29, v28);
      v28 = v26;
      return sub_40084(a1, a7, v28, a2);
    }
    if ( a4 == 5 || !sub_4A404((int)a7, 5) )
    {
      v31 = v8;
      v30 = v8 + 1;
      sub_492AC(a7, a4, v31);
    }
    else
    {
      sub_492AC(a7, 5, v8);
      v30 = v8 + 1;
    }
    sub_492AC(a7, 0x49, v30);
    v32 = v30 + 1;
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, 0x49, v32++);
    sub_492AC(a7, a5, v32);
    v33 = v32 + 1;
    v34 = v32 + 2;
    result = sub_492AC(a7, a6, v33);
    while ( v34 < 0x19 )
    {
      v35 = rand() % 0x64;
      if ( v35 <= 0x4B )
      {
        if ( v35 <= 0x32 )
        {
          if ( v35 <= 0x19 )
          {
            v37 = v34;
            v38 = a6;
          }
          else
          {
            v38 = 0x49;
            v37 = v34;
          }
        }
        else
        {
          v37 = v34;
          v38 = a5;
        }
        result = sub_492AC(a7, v38, v37);
        ++v34;
      }
      else
      {
        v36 = v34++;
        result = sub_492AC(a7, a2, v36);
      }
    }
  }
  else
  {
    sub_492AC(a7, 0x47, v8);
    sub_492AC(a7, 0x47, v9);
    sub_492AC(a7, 0x47, v8 + 2);
    sub_492AC(a7, 0x47, v8 + 3);
    sub_492AC(a7, 0x47, v8 + 4);
    sub_492AC(a7, 0x49, v8 + 5);
    v13 = v8 + 7;
    result = sub_492AC(a7, a5, v9 + 5);
    if ( v9 + 6 < 0x19 )
    {
      do
      {
        v15 = rand() % 0x64;
        if ( v15 <= 0x50 )
        {
          if ( v15 <= 0x3C )
          {
            if ( v15 <= 0x28 )
            {
              if ( v15 <= 0x14 )
              {
                v17 = v13;
                v18 = a6;
              }
              else
              {
                v18 = 0x47;
                v17 = v13;
              }
            }
            else
            {
              v18 = 0x49;
              v17 = v13;
            }
          }
          else
          {
            v17 = v13;
            v18 = a5;
          }
          result = sub_492AC(a7, v18, v17);
          ++v13;
        }
        else
        {
          v16 = v13++;
          result = sub_492AC(a7, a2, v16);
        }
      }
      while ( v13 < 0x19 );
    }
  }
  return result;
}

//----- (00040084) --------------------------------------------------------
int __fastcall sub_40084(int a1, _DWORD *a2, int a3, char a4)
{
  __int16 v4; // cx
  __int16 v5; // bx
  int v6; // eax
  int v7; // esi
  int v8; // edi
  char v9; // al
  int result; // eax
  int v11; // ebx
  char v12[28]; // [esp+4h] [ebp-44h]
  char v13[20]; // [esp+20h] [ebp-28h] BYREF
  int v14; // [esp+34h] [ebp-14h]
  char v15; // [esp+38h] [ebp-10h]

  v14 = a3;
  v15 = a4;
  v4 = 0;
  v5 = 0;
  qmemcpy(v13, "E?2.-&%\"/74@62&%B=01", sizeof(v13));
  while ( v5 < 0x14 )
  {
    if ( sub_4A404((int)a2, v13[v5]) )
    {
      v6 = v4++;
      v12[v6] = v13[v5];
    }
    ++v5;
  }
  while ( v14 < *(_DWORD *)((char *)a2 + 0x15A) && v4 )
  {
    v7 = rand() % v4;
    v8 = v14 + 1;
    --v4;
    sub_492AC(a2, v12[v7], v14);
    v9 = v12[v4];
    v14 = v8;
    v12[v7] = v9;
  }
  while ( 1 )
  {
    result = v14;
    if ( v14 >= *(_DWORD *)((char *)a2 + 0x15A) )
    {
      break;
    }
    v11 = v14++;
    sub_492AC(a2, v15, v11);
  }
  return result;
}
// 40084: using guessed type char var_28[20];
// 40084: using guessed type char var_44[28];

//----- (00040144) --------------------------------------------------------
char *__fastcall sub_40144(unsigned __int8 *a1, int a2)
{
  char *v4; // eax
  char *v5; // ecx
  unsigned __int16 v6; // di
  int v7; // edx
  unsigned __int16 v9; // [esp+0h] [ebp-14h]

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF3C);
  }
  if ( (int)sub_3EFE0((int)a1) <= 0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\race.cpp", 0xF40);
  }
  v4 = sub_20684((int)dword_A2F6C, *a1);
  v5 = v4;
  if ( !v4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF45);
  }
  v9 = sub_4A18C((int)v4);
  if ( !v9 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF51);
  }
  v6 = *(_WORD *)(a2 + 0x44);
  if ( !v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0xF54);
  }
  v7 = dword_A2F6C[0];
  v5[0x58] = 1;
  *(_DWORD *)(v5 + 0x59) = a2;
  *(_DWORD *)(v5 + 0x52) = v7 + v9 / (int)v6 + 1;
  return v5;
}
// 401AC: conditional instruction was optimized away because eax.4!=0
// A2F6C: using guessed type int dword_A2F6C[];

//----- (00040218) --------------------------------------------------------
int __fastcall compar(const void *a1, const void *a2)
{
  return *(_DWORD *)(*(_DWORD *)a1 + 0x52) - *(_DWORD *)(*(_DWORD *)a2 + 0x52);
}

//----- (00040224) --------------------------------------------------------
size_t __fastcall sub_40224(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3)
{
  __int16 *v4; // eax
  int v5; // esi
  __int16 i; // cx
  _DWORD *base; // [esp+4h] [ebp-1Ch]
  size_t nmemb; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]

  base = a2;
  v4 = (__int16 *)&unk_CA1F1;
  v5 = 0;
  nmemb = 0;
  if ( a3 )
  {
    *a3 = 0;
  }
  for ( i = 0; i < 0x6B && v5 < SHIWORD(dword_D35E5); ++i )
  {
    v10 = v4[0x2B];
    if ( v10 != 0xFFFFFFFF )
    {
      ++v5;
      if ( v10 == *a1 )
      {
        if ( base )
        {
          *a2 = v4;
        }
        ++a2;
        ++nmemb;
        if ( a3 )
        {
          *a3 += *((char *)v4 + 0xAA) + 1;
        }
      }
    }
    v4 += 0xB1;
  }
  if ( base )
  {
    qsort(base, nmemb, 4u, compar);
  }
  return nmemb;
}
// D35E5: using guessed type int dword_D35E5;

//----- (000402E0) --------------------------------------------------------
int __fastcall sub_402E0(_BYTE *a1)
{
  int v2; // ebx
  int v3; // eax
  int v4; // edx

  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( v3 < SHIWORD(dword_CA1ED) )
  {
    if ( byte_BB20A[v4] == *a1 )
    {
      ++v2;
    }
    v4 += 0x7B;
    ++v3;
  }
  return v2;
}
// CA1ED: using guessed type int dword_CA1ED;

//----- (000403C0) --------------------------------------------------------
int __fastcall sub_403C0(unsigned __int8 *a1, int a2)
{
  __int16 v3; // bx
  __int16 v4; // cx
  int i; // ebp
  int v6; // ebx
  unsigned __int16 v7; // ax
  int *v8; // ecx
  int v9; // ebx
  __int16 v10; // ax
  int v11; // ebx
  int v14; // [esp+0h] [ebp-28h]
  unsigned __int16 v15; // [esp+4h] [ebp-24h]
  unsigned __int16 v16; // [esp+8h] [ebp-20h]
  __int16 v17; // [esp+Ch] [ebp-1Ch]

  v16 = 0;
  v3 = 0;
  v14 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( *(int *)((char *)&dword_A2F75 + 0x1EE * v3) == 0xFFFFFFFF
         || v3 == *a1
         || a1[v3 + 0x1C0] != 3
         || ((1 << v3) & *(unsigned __int8 *)(a2 + 0x14)) == 0 )
    {
      if ( ++v3 >= SHIWORD(dword_A3CF2) )
      {
        goto LABEL_9;
      }
    }
    return 0;
  }
LABEL_9:
  v4 = 0;
  for ( i = (a1[0x19D] != 2) - 1; v4 < *(__int16 *)(a2 + 0x5A); ++v4 )
  {
    v6 = *(_DWORD *)(a2 + 4 * v4 + 0x46);
    if ( *(unsigned __int8 *)(v6 + 0x57) == 0xFF )
    {
      sub_3636C(*(_DWORD *)(a2 + 4 * v4 + 0x46), i);
      if ( (*(_BYTE *)(v6 + 0x66) & 2) != 0 )
      {
        v7 += 0x28;
      }
      if ( v7 > v16 )
      {
        v16 = v7;
        v14 = v6;
      }
    }
  }
  v15 = 0x46;
  if ( *(_BYTE *)(a2 + 0x14) )
  {
    v10 = 0;
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      while ( 1 )
      {
        if ( a1[v10 + 0x1C0] == 2 )
        {
          v11 = *(unsigned __int8 *)(a2 + 0x14);
          if ( ((1 << v10) & v11) != 0 && ((1 << *a1) & v11) == 0 )
          {
            break;
          }
        }
        if ( ++v10 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_34;
        }
      }
      v15 = 0;
    }
  }
  else
  {
    v15 = 0x23;
    v17 = 0;
    if ( *(__int16 *)(a2 + 0x44) > 0 )
    {
      while ( 1 )
      {
        v8 = *(int **)(a2 + 4 * v17 + 0x2C);
        if ( !v8 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x100E);
        }
        v9 = *v8;
        if ( a2 == *v8 )
        {
          v9 = v8[1];
        }
        if ( ((1 << *a1) & *(unsigned __int8 *)(v9 + 0x14)) != 0 )
        {
          break;
        }
        if ( ++v17 >= *(__int16 *)(a2 + 0x44) )
        {
          goto LABEL_34;
        }
      }
      v15 = 0x11;
    }
  }
LABEL_34:
  if ( v16 <= v15 )
  {
    return 0;
  }
  return v14;
}
// 40480: variable 'v7' is possibly undefined
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (00040590) --------------------------------------------------------
int __fastcall sub_40590(_BYTE *a1)
{
  int v2; // edx
  int v3; // eax

  if ( !dword_10509C )
  {
    v2 = 0;
    v3 = 0;
    dword_1050A0 = 0xFFFFFFFF;
    while ( v2 < (unsigned __int16)word_105258 )
    {
      if ( ((1 << *a1) & (*(int *)((char *)&dword_10529F + v3) >> 0x18)) == 0 )
      {
        dword_1050A0 = 0;
        break;
      }
      v3 += 0x4B;
      ++v2;
    }
    dword_10509C = 0xFFFFFFFF;
  }
  return dword_1050A0;
}
// 10509C: using guessed type int dword_10509C;
// 1050A0: using guessed type int dword_1050A0;
// 10529F: using guessed type int dword_10529F;

//----- (000405F4) --------------------------------------------------------
unsigned int __fastcall sub_405F4(_BYTE *a1)
{
  unsigned int v2; // esi
  __int16 i; // dx
  char *v4; // eax
  char v5; // cl

  v2 = 0;
  if ( sub_40590(a1) )
  {
    for ( i = 0; i < SHIWORD(dword_CA1ED); ++i )
    {
      v4 = (char *)&unk_BB1B3 + 0x7B * i;
      v5 = v4[0x57];
      if ( v5 == *a1 && (v5 != (_BYTE)byte_104BEA || *(_DWORD *)(v4 + 0x5A) || dword_A0D00) )
      {
        if ( sub_3623C((int)v4) )
        {
          v2 = 0xFFFFFFFF;
        }
      }
    }
  }
  return v2;
}
// A0D00: using guessed type int dword_A0D00;
// CA1ED: using guessed type int dword_CA1ED;

//----- (00040664) --------------------------------------------------------
int __fastcall sub_40664(_BYTE *a1)
{
  int v2; // ebx
  int v3; // edx
  int v4; // eax

  v2 = 0;
  v3 = 0;
  v4 = 0;
  while ( v3 < (unsigned __int16)word_105258 )
  {
    if ( ((1 << *a1) & (*(int *)((char *)&dword_10529F + v4) >> 0x18)) != 0 )
    {
      ++v2;
    }
    v4 += 0x4B;
    ++v3;
  }
  return v2;
}
// 10529F: using guessed type int dword_10529F;

//----- (000406C4) --------------------------------------------------------
int __fastcall sub_406C4(unsigned __int8 *a1, __int16 *a2, int a3)
{
  unsigned __int8 v4; // cl
  __int16 v5; // cx
  int v6; // ebp
  int v7; // esi
  __int16 v8; // bx
  char v9; // dh
  __int16 v10; // ax
  __int16 *v11; // ecx
  int v12; // edx
  int v13; // ebx
  char v14; // cl
  int v15; // eax
  unsigned int v16; // ebx
  char v17; // ch
  __int16 v18; // si
  int v19; // ebx
  int v20; // eax
  int result; // eax
  __int16 v22; // dx
  unsigned __int8 v23; // al
  unsigned int v24; // ebp
  int v25; // ebx
  __int16 *v26; // esi
  __int16 i; // ax
  int v28; // ebx
  int v29; // esi
  __int16 v30; // cx
  __int16 j; // bx
  int v32; // edx
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  int v36; // ebx
  unsigned __int8 v37; // al
  __int16 v38; // dx
  __int16 v39; // di
  int v40; // ecx
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  char v45; // dl
  int v46; // eax
  int v47; // eax
  int v48; // eax
  int v49; // ecx
  char v50; // bl
  int v51; // eax
  int v52; // eax
  unsigned __int8 v53; // al
  __int16 v54; // cx
  int v55; // eax
  __int16 v56; // bx
  __int16 v57; // ax
  int v58[107]; // [esp+0h] [ebp-3CCh] BYREF
  int v59[107]; // [esp+1ACh] [ebp-220h] BYREF
  int v60[5]; // [esp+358h] [ebp-74h] BYREF
  __int16 v61[8]; // [esp+36Ch] [ebp-60h] BYREF
  int v62; // [esp+37Ch] [ebp-50h]
  int v63; // [esp+380h] [ebp-4Ch]
  int v64; // [esp+384h] [ebp-48h]
  int v65; // [esp+388h] [ebp-44h]
  int v66; // [esp+38Ch] [ebp-40h]
  int v67; // [esp+390h] [ebp-3Ch]
  __int16 *v68; // [esp+394h] [ebp-38h]
  int v69; // [esp+398h] [ebp-34h]
  int v70; // [esp+39Ch] [ebp-30h]
  __int16 v71; // [esp+3A0h] [ebp-2Ch]
  __int16 v72; // [esp+3A4h] [ebp-28h]
  int v73; // [esp+3A8h] [ebp-24h]
  int v74; // [esp+3ACh] [ebp-20h]
  __int16 v75; // [esp+3B0h] [ebp-1Ch]
  int v76; // [esp+3B2h] [ebp-1Ah]
  unsigned __int8 v77; // [esp+3B8h] [ebp-14h]

  v68 = a2;
  v64 = a3;
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1081);
  }
  v4 = *a1;
  v77 = *((_BYTE *)v68 + 0x14) | *((_BYTE *)v68 + 0x15);
  if ( ((1 << v4) & v77) == 0 )
  {
    return 0;
  }
  sub_3B56C(a1, v68);
  v5 = 0;
  HIWORD(v76) = 0;
  LOWORD(v73) = 0;
  LOWORD(v74) = 0;
  LOWORD(v70) = 0;
  v65 = 0;
  v6 = sub_1D794(v68, v58);
  while ( v5 < v6 )
  {
    v7 = v58[v5];
    if ( !v7 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x10AC);
    }
    if ( *(_WORD *)(v7 + 0x56) == *a1 && *(int *)(v7 + 0x88) > 0 && *(_BYTE *)(v7 + 0x58) != 1 )
    {
      v8 = *(_WORD *)(v7 + 0x94) + v70;
      LOWORD(v74) = *(_WORD *)(v7 + 0x88) + v74;
      v59[SHIWORD(v76)] = v7;
      LOWORD(v70) = v8;
      v9 = *(_BYTE *)(v7 + 0x5D);
      ++HIWORD(v76);
      if ( v9 )
      {
        v65 = 0xFFFFFFFF;
      }
    }
    ++v5;
  }
  v10 = 0;
  if ( v68[0x2D] > 0 )
  {
    v11 = v68;
    do
    {
      v12 = *(_DWORD *)&v11[2 * v10 + 0x23];
      if ( *(_BYTE *)(v12 + 0x57) == *a1 )
      {
        v13 = (__int16)v73;
        LOWORD(v73) = v73 + 1;
        v60[v13] = v12;
      }
      ++v10;
    }
    while ( v10 < v68[0x2D] );
  }
  if ( !HIWORD(v76) && !(_WORD)v73 )
  {
    return 0;
  }
  if ( v68 == *(__int16 **)(a1 + 7)
    || !HIWORD(v76)
    || (_BYTE)byte_104BEA == *a1
    || ((1 << *a1) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_107F3D) >> 0x18)) == 0 )
  {
    goto LABEL_39;
  }
  v14 = sub_43374(a1, 0xFFFFFFFF);
  v15 = *(_DWORD *)(a1 + 7);
  v16 = 0;
  v17 = *(_BYTE *)(v15 + 0x14);
  if ( (v17 & 0x7F) == 0 )
  {
    v16 = 0xFFFFFFFF;
  }
  if ( !v16 )
  {
    v16 = 0;
    if ( ((unsigned __int8)v14 & (unsigned __int8)(v17 | *(_BYTE *)(v15 + 0x15))) != 0 )
    {
      v16 = 0xFFFFFFFF;
    }
  }
  if ( v16 && (v18 = 0, SHIWORD(v76) > 0) )
  {
    while ( 1 )
    {
      v19 = v59[v18];
      if ( *(_BYTE *)(v19 + 0x58) == 4 )
      {
        if ( *(_DWORD *)(v19 + 0x88) )
        {
          v20 = sub_4937C(v59[v18], 0x24);
          if ( v20 != 0xFFFFFFFF )
          {
            *(_BYTE *)(v19 + 0x62) = 1;
            *(_DWORD *)(v19 + 0x63) = 7 * v20 + v19 + 0xAB;
            *(_BYTE *)(v19 + 0x67) = 5;
            if ( (sub_49B3C(v19, 0) & 1) != 0 )
            {
              break;
            }
          }
        }
      }
      if ( ++v18 >= SHIWORD(v76) )
      {
        goto LABEL_39;
      }
    }
    *(_BYTE *)v64 = 3;
    *(_DWORD *)(v64 + 1) = v59[v18];
    return 0xFFFFFFFF;
  }
  else
  {
LABEL_39:
    v22 = 0;
    v23 = 1;
    v24 = 0;
    v75 = 0;
    v62 = 0;
    while ( v22 < 7 )
    {
      v66 = v23;
      if ( (v23 & v77) != 0 )
      {
        v25 = v75;
        v26 = v68;
        v61[v25] = v22;
        if ( ((unsigned __int8)v66 & *((_BYTE *)v26 + 0x15)) != 0 )
        {
          LOBYTE(v61[v25]) |= 8u;
        }
        if ( (v23 & (_BYTE)v68[0xA]) != 0 )
        {
          LOBYTE(v61[v75]) |= 0x10u;
        }
        if ( a1[v22 + 0x1C0] == 2 )
        {
          if ( (_BYTE)byte_104BEA != *a1 || dword_A0D00 == 0xFFFFFFFF || (*((_BYTE *)v68 + 0x15) & v23) != 0 )
          {
            v24 = 0xFFFFFFFF;
            LOBYTE(v61[v75]) |= 0x20u;
          }
        }
        else if ( *a1 != (_BYTE)byte_104BEA
               && v22 == (unsigned __int8)byte_104BEA
               && ((1 << *a1) & (unsigned __int8)byte_D8460[v68[2]]) != 0 )
        {
          v24 = 0xFFFFFFFF;
          LOBYTE(v61[v75]) |= 0x20u;
        }
        ++v75;
      }
      ++v22;
      v23 *= 2;
    }
    if ( v75 <= 0 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1133);
    }
    if ( v75 == 1 )
    {
      v62 = 0xFFFFFFFF;
    }
    if ( !v62 && !v24 && (*a1 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF) )
    {
      LOWORD(v69) = 0;
      do
      {
        v71 = v61[(__int16)v69] & 7;
        if ( a1[(unsigned __int8)v71 + 0x1C0] == 3 )
        {
          for ( i = 0; i < v75; ++i )
          {
            v28 = v61[i] & 7;
            if ( byte_A3132[0x1EE * v71 + (unsigned __int8)v28] == 2 && a1[v28 + 0x1C0] != 3 )
            {
              v24 = 0xFFFFFFFF;
              LOBYTE(v61[i]) |= 0x20u;
            }
          }
        }
        LOWORD(v69) = v69 + 1;
      }
      while ( (__int16)v69 < v75 );
    }
    if ( v24 != 0xFFFFFFFF
      || (_BYTE)byte_104BEA == *a1 && dword_A0D00 != 0xFFFFFFFF && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10
      || (result = sub_41268(
                     a1,
                     v75,
                     v76 >> 0x10,
                     (int)v61,
                     (int)v68,
                     (int)v59,
                     v73,
                     (int)v60,
                     (__int16)v74,
                     (__int16)v70,
                     (int)v68,
                     v64),
          result != 0xFFFFFFFF) )
    {
      if ( (_BYTE)byte_104BEA == *a1 && !v65 && !dword_A0D00 )
      {
        return 0;
      }
      v29 = 0;
      v30 = 0;
      for ( j = 0; j < SHIWORD(v76); ++j )
      {
        if ( !*(_BYTE *)(v59[j] + 0x5D) && (*a1 != (_BYTE)byte_104BEA || dword_A0D00 == 0xFFFFFFFF) )
        {
          sub_3EBDC(a1, v59[j]);
        }
        v32 = v59[j];
        if ( v30 < *(_DWORD *)(v32 + 0x88) && *(_BYTE *)(v32 + 0x5D) )
        {
          v29 = v59[j];
          v30 = *(_WORD *)(v32 + 0x88);
        }
      }
      if ( !v29 )
      {
        return 0;
      }
      switch ( *(_BYTE *)(v29 + 0x5D) )
      {
        case 1:
          if ( *(_BYTE *)(v29 + 0x58) == 3 )
          {
            sub_35C38(*(_DWORD *)(v29 + 0x59), v29);
          }
          if ( *(_BYTE *)(v29 + 0x58) != 4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1188);
          }
          if ( *a1 != (_BYTE)byte_104BEA
            && sub_1D834((int)v68, *a1) == 0xFFFFFFFF
            && *(_DWORD *)(v29 + 0x28) != 0xFFFFFFFF
            && sub_4A534(v29, 0x49) == 0xFFFFFFFF )
          {
            return 0;
          }
          v33 = *(_DWORD *)(v29 + 0x5E);
          if ( (__int16 *)v33 != v68 )
          {
            v36 = *(_DWORD *)(v29 + 0x5E);
            v37 = byte_D5D47[0x64 * v68[2] + *(__int16 *)(v33 + 4)];
            v38 = 0;
            v63 = 0;
            v39 = v68[0x22];
            v72 = v37;
            if ( v39 > 0 )
            {
              while ( 1 )
              {
                v67 = *(_DWORD *)&v68[2 * v38 + 0x16];
                if ( v68 == *(__int16 **)v67 )
                {
                  v41 = 0x64 * *(__int16 *)(*(_DWORD *)(v67 + 4) + 4);
                  v40 = *(__int16 *)(v36 + 4);
                }
                else
                {
                  v40 = 0x64 * *(__int16 *)(*(_DWORD *)v67 + 4);
                  v41 = *(__int16 *)(v36 + 4);
                }
                if ( (unsigned __int8)byte_D5D47[v40 + v41] == v72 - 1 )
                {
                  break;
                }
                if ( ++v38 >= v68[0x22] )
                {
                  goto LABEL_115;
                }
              }
              v63 = 0xFFFFFFFF;
            }
LABEL_115:
            if ( v63 != 0xFFFFFFFF )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x11CC);
            }
            if ( (*(_BYTE *)(v67 + 0x23) & 2) != 0 && sub_4A480(v29, 0, v67) )
            {
              v42 = v64;
              *(_BYTE *)v64 = 3;
              *(_DWORD *)(v42 + 1) = v29;
            }
            else
            {
              *(_BYTE *)(v29 + 0x62) = 0;
              v43 = v67;
              *(_DWORD *)(v29 + 0x63) = 0;
              *(_DWORD *)(v29 + 0x68) = v43;
              v44 = v64;
              *(_BYTE *)(v29 + 0x67) = 2;
              *(_BYTE *)v44 = 3;
              *(_DWORD *)(v44 + 1) = v29;
            }
            goto LABEL_121;
          }
          v34 = (unsigned int)v68 ^ v33;
          v35 = *(__int16 *)(v29 + 0x56);
          LOBYTE(v34) = byte_104BEA;
          *(_BYTE *)(v29 + 0x5D) = 0;
          if ( v35 != v34 || dword_A0D00 == 0xFFFFFFFF )
          {
            sub_3EBDC(a1, v29);
          }
          result = 0xFFFFFFFF;
          break;
        case 2:
          v49 = *(_DWORD *)(v29 + 0x5E);
          if ( !*(_DWORD *)(v29 + 0x28) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x123F);
          }
          if ( *(unsigned __int8 *)(v49 + 0x57) == 0xFF )
          {
            v50 = *(_BYTE *)(v29 + 0x58);
            if ( v50 == 3 )
            {
              v51 = *(_DWORD *)(v29 + 0x59);
              if ( v49 == v51 )
              {
                v52 = sub_4937C(v29, 0x47);
                if ( v52 == 0xFFFFFFFF )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x125A);
                }
                sub_492F8((_DWORD *)v29, v52);
                v53 = *a1;
                *(_WORD *)(v49 + 0x42) = 2;
                *(_BYTE *)(v49 + 0x57) = v53;
                *(_DWORD *)(v49 + 0x67) = dword_A2F6C[0];
                sub_34AE4(v49, 5u, 0xFFFFFFFF);
                --*(_DWORD *)(v29 + 0x88);
                *((_BYTE *)v68 + 0x14) |= 1 << *a1;
                v54 = v74 - 1;
                *(_BYTE *)(v29 + 0x5D) = 0;
                LOWORD(v74) = v54;
              }
              else
              {
                sub_35C38(v51, v29);
                if ( *(_BYTE *)(v29 + 0x58) != 4 )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1252);
                }
              }
            }
            else
            {
              if ( v50 != 4 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x126C);
              }
              *(_BYTE *)(v29 + 0x62) = 0;
              *(_DWORD *)(v29 + 0x63) = 0;
              *(_BYTE *)(v29 + 0x67) = 1;
              v55 = v64;
              *(_DWORD *)(v29 + 0x68) = v49;
              *(_BYTE *)v55 = 3;
              *(_DWORD *)(v55 + 1) = v29;
            }
          }
          else
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          goto LABEL_121;
        case 3:
          if ( *(_WORD *)(v29 + 0x56) != (unsigned __int8)byte_104BEA )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x11F3);
          }
          v45 = *(_BYTE *)(v29 + 0x58);
          if ( v45 == 3 )
          {
            if ( *(_DWORD *)(v29 + 0x59) != *(_DWORD *)(v29 + 0x5E) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x11F7);
            }
            v46 = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
            *(_BYTE *)(v29 + 0x5D) = 0;
            if ( v46 != 0x10 )
            {
              sub_55AEC((int)&V_Type3_stru_10AE70, 0x10, v29, *(_DWORD *)(v29 + 0x5E));
            }
          }
          else if ( v45 == 4 )
          {
            *(_BYTE *)(v29 + 0x62) = 0;
            *(_DWORD *)(v29 + 0x63) = 0;
            *(_DWORD *)(v29 + 0x68) = *(_DWORD *)(v29 + 0x5E);
            v47 = v64;
            *(_BYTE *)(v29 + 0x67) = 1;
            *(_BYTE *)v47 = 3;
            *(_DWORD *)(v47 + 1) = v29;
          }
          else
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          goto LABEL_121;
        case 7:
          if ( *(_WORD *)(v29 + 0x56) != (unsigned __int8)byte_104BEA )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x121D);
          }
          if ( *(_BYTE *)(v29 + 0x58) != 4 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x121E);
          }
          if ( (*(_BYTE *)(v29 + 0x84) & 8) != 0 )
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          else if ( *(_BYTE *)(v29 + 0x62) )
          {
            *(_BYTE *)(v29 + 0x5D) = 0;
          }
          else
          {
            v48 = v64;
            *(_BYTE *)(v29 + 0x67) = 3;
            *(_BYTE *)v48 = 3;
            *(_DWORD *)(v48 + 1) = v29;
          }
          goto LABEL_121;
        default:
          v56 = v74;
          v57 = *(_WORD *)(v29 + 0x88);
          *(_DWORD *)(v29 + 0x94) = 0;
          *(_DWORD *)(v29 + 0x88) = 0;
          LOWORD(v74) = v56 - v57;
LABEL_121:
          if ( (__int16)v74 <= 0 )
          {
            return 0;
          }
          return 0xFFFFFFFF;
      }
    }
  }
  return result;
}
// 40BBE: conditional instruction was optimized away because %var_1C.2>=1
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// 10529F: using guessed type int dword_10529F;
// 107F3D: using guessed type char byte_107F3D;
// 406C4: using guessed type int var_3CC[107];
// 406C4: using guessed type int var_220[107];
// 406C4: using guessed type int var_74[5];

//----- (00041268) --------------------------------------------------------
int __userpurge sub_41268@<eax>(
        unsigned __int8 *a1@<eax>,
        __int16 a2@<dx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6,
        __int16 a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  __int16 v13; // ax
  _BYTE *v14; // edx
  int v15; // edi
  __int16 j; // ax
  int v17; // edx
  int v18; // esi
  char v19; // cl
  int v20; // edx
  int v21; // eax
  int v22; // edx
  int v23; // ebx
  int v24; // edx
  int v26; // ecx
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // edx
  int v31; // esi
  __int16 n; // cx
  int v33; // ebx
  int v34; // esi
  int v35; // eax
  char v36; // bh
  __int16 v37; // bx
  int v38; // edx
  int v39; // ebp
  float *v40; // ebx
  __int16 ii; // si
  int v42; // edx
  char v43; // cl
  int v44; // ecx
  double v45; // st7
  double v46; // st7
  int v47; // edx
  __int16 v48; // bx
  __int16 v49; // cx
  int v50; // eax
  int v51; // edx
  int v52; // edi
  unsigned __int8 *v53; // ebp
  signed __int16 kk; // cx
  char *v55; // esi
  int v56; // eax
  int v57; // ecx
  __int16 mm; // ax
  __int16 v59; // bx
  int *v60; // eax
  int v61; // ecx
  unsigned int v62; // eax
  unsigned int v63; // eax
  int v64; // ebp
  int v65; // ecx
  double v66; // st7
  char v67; // cl
  int v68; // ebp
  int v69; // edx
  int v70; // ebx
  int v71; // ebp
  int v72; // ebx
  int v73; // edi
  int v74; // eax
  int v75; // eax
  int v76; // edx
  int v77; // edx
  int *v78; // eax
  int v79; // eax
  int v80; // ecx
  __int16 v81; // ax
  char v82; // dl
  int v83; // esi
  int v84; // eax
  __int16 i2; // bx
  int v86; // edx
  char v87; // cl
  int v88; // eax
  int v89[107]; // [esp+8h] [ebp-40Ch] BYREF
  char v90; // [esp+1B4h] [ebp-260h]
  int v91; // [esp+1B5h] [ebp-25Fh]
  char v92; // [esp+1B9h] [ebp-25Bh]
  int v93; // [esp+1BAh] [ebp-25Ah]
  int v94; // [esp+1BEh] [ebp-256h]
  int v95; // [esp+1C2h] [ebp-252h]
  int v96; // [esp+1C6h] [ebp-24Eh]
  int v97; // [esp+1CAh] [ebp-24Ah]
  int v98; // [esp+1CEh] [ebp-246h]
  int v99; // [esp+1D2h] [ebp-242h]
  int v100; // [esp+1D6h] [ebp-23Eh]
  char v101; // [esp+1DCh] [ebp-238h]
  int v102; // [esp+1DDh] [ebp-237h]
  char v103; // [esp+1E1h] [ebp-233h]
  int v104; // [esp+1E2h] [ebp-232h]
  int v105; // [esp+1E6h] [ebp-22Eh]
  int v106; // [esp+1EAh] [ebp-22Ah]
  int v107; // [esp+1EEh] [ebp-226h]
  int v108; // [esp+1F2h] [ebp-222h]
  int v109; // [esp+1F6h] [ebp-21Eh]
  int v110; // [esp+1FAh] [ebp-21Ah]
  int v111; // [esp+1FEh] [ebp-216h]
  int v112[3]; // [esp+204h] [ebp-210h] BYREF
  float v113; // [esp+210h] [ebp-204h] BYREF
  float v114; // [esp+214h] [ebp-200h]
  float v115; // [esp+218h] [ebp-1FCh]
  float v116; // [esp+21Ch] [ebp-1F8h]
  int v117; // [esp+220h] [ebp-1F4h]
  int v118; // [esp+224h] [ebp-1F0h]
  float v119; // [esp+228h] [ebp-1ECh]
  int v120; // [esp+22Ch] [ebp-1E8h]
  int v121; // [esp+230h] [ebp-1E4h]
  int v122[3]; // [esp+234h] [ebp-1E0h] BYREF
  float v123; // [esp+240h] [ebp-1D4h]
  float v124; // [esp+244h] [ebp-1D0h]
  float v125; // [esp+248h] [ebp-1CCh]
  int v126[3]; // [esp+24Ch] [ebp-1C8h] BYREF
  int v127[3]; // [esp+258h] [ebp-1BCh] BYREF
  float v128; // [esp+264h] [ebp-1B0h]
  float v129; // [esp+268h] [ebp-1ACh]
  float v130; // [esp+26Ch] [ebp-1A8h]
  float v131; // [esp+270h] [ebp-1A4h]
  float v132; // [esp+274h] [ebp-1A0h]
  float v133; // [esp+278h] [ebp-19Ch]
  int v134[3]; // [esp+27Ch] [ebp-198h] BYREF
  int v135[3]; // [esp+288h] [ebp-18Ch] BYREF
  float v136; // [esp+294h] [ebp-180h]
  float v137; // [esp+298h] [ebp-17Ch]
  float v138; // [esp+29Ch] [ebp-178h]
  float v139; // [esp+2A0h] [ebp-174h]
  float v140; // [esp+2A4h] [ebp-170h]
  float v141; // [esp+2A8h] [ebp-16Ch]
  float v142; // [esp+2ACh] [ebp-168h]
  float v143; // [esp+2B0h] [ebp-164h]
  float v144; // [esp+2B4h] [ebp-160h]
  float v145; // [esp+2B8h] [ebp-15Ch] BYREF
  float v146; // [esp+2BCh] [ebp-158h]
  float v147; // [esp+2C0h] [ebp-154h]
  float v148; // [esp+2C4h] [ebp-150h]
  float v149; // [esp+2C8h] [ebp-14Ch]
  float v150; // [esp+2CCh] [ebp-148h]
  float v151; // [esp+2D0h] [ebp-144h]
  float v152; // [esp+2D4h] [ebp-140h]
  float v153; // [esp+2D8h] [ebp-13Ch]
  int v154[3]; // [esp+2DCh] [ebp-138h] BYREF
  float v155; // [esp+2E8h] [ebp-12Ch]
  float v156; // [esp+2ECh] [ebp-128h]
  float v157; // [esp+2F0h] [ebp-124h]
  float v158; // [esp+2F4h] [ebp-120h]
  float v159; // [esp+2F8h] [ebp-11Ch]
  float v160; // [esp+2FCh] [ebp-118h]
  float v161; // [esp+300h] [ebp-114h]
  float v162; // [esp+304h] [ebp-110h]
  float v163; // [esp+308h] [ebp-10Ch]
  int v164[5]; // [esp+30Ch] [ebp-108h] BYREF
  int v165; // [esp+320h] [ebp-F4h]
  int v166; // [esp+324h] [ebp-F0h]
  unsigned __int8 *v167; // [esp+328h] [ebp-ECh]
  float v168; // [esp+32Ch] [ebp-E8h]
  int v169; // [esp+330h] [ebp-E4h] BYREF
  int v170; // [esp+334h] [ebp-E0h]
  int v171; // [esp+338h] [ebp-DCh]
  int v172; // [esp+33Ch] [ebp-D8h]
  int v173; // [esp+340h] [ebp-D4h]
  int *v174; // [esp+344h] [ebp-D0h]
  float v175; // [esp+348h] [ebp-CCh]
  unsigned int v176; // [esp+34Ch] [ebp-C8h]
  int v177; // [esp+350h] [ebp-C4h]
  float v178; // [esp+354h] [ebp-C0h]
  float v179; // [esp+358h] [ebp-BCh]
  int *v180; // [esp+35Ch] [ebp-B8h]
  int v181; // [esp+360h] [ebp-B4h]
  float v182; // [esp+364h] [ebp-B0h]
  int *v183; // [esp+368h] [ebp-ACh]
  float v184; // [esp+36Ch] [ebp-A8h]
  int *v185; // [esp+370h] [ebp-A4h]
  int *v186; // [esp+374h] [ebp-A0h]
  int *v187; // [esp+378h] [ebp-9Ch]
  unsigned int v188; // [esp+37Ch] [ebp-98h] BYREF
  int v189; // [esp+380h] [ebp-94h]
  float v190; // [esp+384h] [ebp-90h]
  int v191; // [esp+388h] [ebp-8Ch]
  float v192; // [esp+38Ch] [ebp-88h]
  float *v193; // [esp+390h] [ebp-84h]
  int *v194; // [esp+394h] [ebp-80h]
  float v195; // [esp+398h] [ebp-7Ch]
  int v196; // [esp+39Ch] [ebp-78h]
  int *v197; // [esp+3A0h] [ebp-74h]
  int v198; // [esp+3A4h] [ebp-70h]
  unsigned int v199; // [esp+3A8h] [ebp-6Ch]
  float v200; // [esp+3ACh] [ebp-68h]
  float v201; // [esp+3B0h] [ebp-64h]
  int v202; // [esp+3B4h] [ebp-60h]
  int v203; // [esp+3B8h] [ebp-5Ch]
  int v204; // [esp+3BCh] [ebp-58h] BYREF
  int v205; // [esp+3C0h] [ebp-54h]
  __int16 i1; // [esp+3C4h] [ebp-50h]
  int v207; // [esp+3C8h] [ebp-4Ch]
  __int16 nn; // [esp+3CCh] [ebp-48h]
  int v209; // [esp+3D0h] [ebp-44h]
  int v210; // [esp+3D4h] [ebp-40h]
  int v211; // [esp+3D8h] [ebp-3Ch]
  int v212; // [esp+3DCh] [ebp-38h]
  __int16 m; // [esp+3E0h] [ebp-34h]
  int v214; // [esp+3E4h] [ebp-30h]
  int v215; // [esp+3E8h] [ebp-2Ch]
  __int16 v216; // [esp+3ECh] [ebp-28h]
  __int16 v217; // [esp+3F0h] [ebp-24h]
  __int16 jj; // [esp+3F4h] [ebp-20h]
  __int16 v219; // [esp+3F8h] [ebp-1Ch]
  __int16 k; // [esp+3FCh] [ebp-18h]
  int v221; // [esp+400h] [ebp-14h]
  unsigned __int8 i; // [esp+404h] [ebp-10h]

  v167 = a1;
  v207 = a3;
  sub_45958(a1, 2, (__int16 *)a11, &v169);
  sub_45958(v167, 3, (__int16 *)a11, &v204);
  sub_1DA4C(a11, *v167, 0, 0xFFFFFFFF);
  sub_1DB70(a11, *v167, 0, 0xFFFFFFFF);
  v219 = 1;
  if ( ((1 << byte_104BEA) & (*(unsigned __int8 *)(a11 + 0x14) | *(unsigned __int8 *)(a11 + 0x15))) == 0 )
  {
    v219 = 1;
  }
  if ( *v167 == (_BYTE)byte_104BEA && !dword_A0D00 )
  {
    v219 = 1;
  }
  v13 = 0;
  for ( i = 0; v13 < a2; ++v13 )
  {
    v14 = (_BYTE *)(a4 + 2 * v13);
    if ( (*(_WORD *)v14 & 0x20) != 0 )
    {
      i |= 1 << (*v14 & 7);
    }
  }
  v15 = sub_1D794((__int16 *)a11, v89);
  v170 = 0;
  for ( j = 0; j < v15; ++j )
  {
    v17 = v89[j];
    if ( *(_BYTE *)(v17 + 0x58) == 4 && ((1 << *(_WORD *)(v17 + 0x56)) & i) != 0 )
    {
      v170 = 0xFFFFFFFF;
      break;
    }
  }
  if ( !v170 && (_BYTE)byte_104BEA == *v167 && !dword_A0D00 )
  {
    return 2;
  }
  if ( (_WORD)v207 )
  {
    v18 = 0;
    v171 = 0;
    v181 = 0;
    if ( v219 == 1 )
    {
      if ( v170 )
      {
        v105 = 0;
        v106 = 0;
        v172 = 0;
        v107 = 0;
        v173 = 0;
        v108 = 0;
        v109 = 0;
        v110 = 0;
        LOWORD(v210) = 0;
        if ( (__int16)v207 > 0 )
        {
          do
          {
            v19 = *(_BYTE *)(*(_DWORD *)(a6 + 4 * (__int16)v210) + 0x58);
            v191 = *(_DWORD *)(a6 + 4 * (__int16)v210);
            if ( v19 == 4 )
            {
              for ( k = 0; k < v15; ++k )
              {
                v176 = 4 * k;
                v177 = v89[v176 / 4];
                if ( (i & (1 << *(_WORD *)(v177 + 0x56))) != 0 )
                {
                  v101 = *(_BYTE *)(v177 + 0x62);
                  v102 = *(_DWORD *)(v177 + 0x63);
                  v103 = *(_BYTE *)(v177 + 0x67);
                  v104 = *(_DWORD *)(v177 + 0x68);
                  v105 = *(_DWORD *)(v177 + 0x6C);
                  v106 = *(_DWORD *)(v177 + 0x70);
                  v107 = *(_DWORD *)(v177 + 0x74);
                  v108 = *(_DWORD *)(v177 + 0x78);
                  v109 = *(_DWORD *)(v177 + 0x7C);
                  v110 = *(_DWORD *)(v177 + 0x80);
                  v111 = *(_DWORD *)(v177 + 0x84);
                  if ( sub_4A480(v177, 3u, v191) )
                  {
                    sub_49A40(v191, 0xFFFFFFFF);
                    v173 = v191;
                    v172 = v89[v176 / 4];
                  }
                  v20 = v89[k];
                  *(_BYTE *)(v20 + 0x62) = v101;
                  *(_DWORD *)(v20 + 0x63) = v102;
                  *(_BYTE *)(v20 + 0x67) = v103;
                  v20 += 0x62;
                  *(_DWORD *)(v20 + 6) = v104;
                  *(_DWORD *)(v20 + 0xA) = v105;
                  *(_DWORD *)(v20 + 0xE) = v106;
                  *(_DWORD *)(v20 + 0x12) = v107;
                  *(_DWORD *)(v20 + 0x16) = v108;
                  *(_DWORD *)(v20 + 0x1A) = v109;
                  *(_DWORD *)(v20 + 0x1E) = v110;
                  *(_DWORD *)(v20 + 0x22) = v111;
                }
              }
              if ( v173 != v191 )
              {
                sub_49A40(v191, 0);
              }
            }
            LOWORD(v210) = v210 + 1;
          }
          while ( (__int16)v210 < (__int16)v207 );
        }
        LOWORD(v205) = 0;
        if ( (__int16)v207 > 0 )
        {
          do
          {
            v21 = *(_DWORD *)(a6 + 4 * (__int16)v205);
            v22 = *(_DWORD *)(v21 + 0x28);
            v203 = v21;
            if ( (!v22 || sub_4A534(v21, 0x49)) && *(_BYTE *)(v203 + 0x58) == 4 && *(_DWORD *)(v203 + 0x88) )
            {
              if ( sub_4A564(v203) )
              {
                for ( m = 0; m < v15; ++m )
                {
                  v23 = v89[m];
                  if ( (i & (1 << *(_WORD *)(v23 + 0x56))) != 0 )
                  {
                    if ( sub_4A480(v203, 3u, v23) )
                    {
                      v24 = v203;
                      *(_BYTE *)a12 = 3;
                      *(_DWORD *)(a12 + 1) = v24;
                      return 0xFFFFFFFF;
                    }
                    v181 = v203;
                  }
                }
              }
              else
              {
                v171 = v203;
              }
            }
            LOWORD(v205) = v205 + 1;
          }
          while ( (__int16)v205 < (__int16)v207 );
        }
        v26 = v181;
        if ( v181 )
        {
          v27 = sub_4937C(v181, 0x39);
          if ( v27 != 0xFFFFFFFF && (*(_WORD *)(v26 + 0x9C) & 4) == 0 && *(int *)(v26 + 0x88) > 0xC )
          {
            *(_BYTE *)(v26 + 0x62) = 1;
            *(_BYTE *)(v26 + 0x67) = 5;
            *(_DWORD *)(v26 + 0x63) = 7 * v27 + v26 + 0xAB;
            *(_BYTE *)a12 = 3;
            *(_DWORD *)(a12 + 1) = v26;
            sub_49B3C(v26, 0);
            if ( (*(_BYTE *)(v26 + 0x84) & 1) != 0 )
            {
              return 0xFFFFFFFF;
            }
          }
        }
        if ( v171 )
        {
          v28 = sub_4937C(v171, 0x41);
          if ( v28 != 0xFFFFFFFF )
          {
            v29 = v171;
            if ( *(int *)(v171 + 0x88) > 0xD )
            {
              *(_BYTE *)(v171 + 0x62) = 1;
              *(_BYTE *)(v29 + 0x67) = 5;
              v30 = v171;
              *(_DWORD *)(v171 + 0x63) = 7 * v28 + v171 + 0xAB;
              *(_BYTE *)a12 = 3;
              *(_DWORD *)(a12 + 1) = v30;
              sub_49B3C(v171, 0);
              if ( (*(_BYTE *)(v171 + 0x84) & 1) != 0 )
              {
                return 0xFFFFFFFF;
              }
            }
          }
        }
        v202 = v173;
        if ( v173 && sub_43184((int)v167, v173, v172) )
        {
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v173;
          return 0xFFFFFFFF;
        }
        v31 = 0;
        for ( n = 0; n < (__int16)v207; ++n )
        {
          v33 = *(_DWORD *)(a6 + 4 * n);
          if ( (!*(_DWORD *)(v33 + 0x28) || sub_4A534(*(_DWORD *)(a6 + 4 * n), 0x49))
            && *(_BYTE *)(v33 + 0x58) == 4
            && *(_DWORD *)(v33 + 0x88) * *(_DWORD *)v33 * *(_DWORD *)(v33 + 0x8C) > v31 )
          {
            v31 = *(_DWORD *)(v33 + 0x88) * *(_DWORD *)v33 * *(_DWORD *)(v33 + 0x8C);
            v202 = v33;
          }
        }
        if ( !v202 )
        {
          return 0;
        }
        if ( !a7 || (v148 = 0.0, v149 = 0.0, v150 = 0.0, LOWORD(v215) = 0, a7 <= 0) )
        {
LABEL_101:
          v39 = 0;
          v145 = 0.0;
          v146 = 0.0;
          v147 = 0.0;
          v175 = 99999.0;
          v40 = (float *)(v202 + 0x9E);
          for ( ii = 0; ii < v15; ++ii )
          {
            v42 = v89[ii];
            if ( (i & (1 << *(_WORD *)(v42 + 0x56))) != 0 )
            {
              v183 = v135;
              v151 = 0.0;
              v152 = 0.0;
              v153 = 0.0;
              v151 = *(float *)(v42 + 0x9E) - *v40;
              v152 = *(float *)(v42 + 0xA2) - v40[1];
              v153 = *(float *)(v42 + 0xA6) - v40[2];
              *(float *)v135 = v151;
              *(float *)&v135[1] = v152;
              *(float *)&v135[2] = v153;
              v145 = v151;
              v146 = v152;
              v147 = v153;
              v184 = sqrt(v152 * v152 + v151 * v151 + v153 * v153);
              v43 = *(_BYTE *)(v42 + 0x58);
              v192 = v184;
              if ( v43 != 4 )
              {
                v192 = v184 + flt_92338;
              }
              if ( v192 < (double)v175 && v192 > (double)flt_9233C )
              {
                v39 = v42;
                v175 = v192;
              }
            }
          }
          v44 = v202;
          if ( v202 && v39 )
          {
            v185 = v122;
            v155 = 0.0;
            v156 = 0.0;
            v157 = 0.0;
            v155 = *v40 - *(float *)(v39 + 0x9E);
            v156 = v40[1] - *(float *)(v39 + 0xA2);
            v45 = v40[2] - *(float *)(v39 + 0xA6);
            *(float *)v122 = v155;
            v157 = v45;
            *(float *)&v122[1] = v156;
            *(float *)&v122[2] = v157;
            v158 = 0.0;
            v145 = v155;
            v159 = 0.0;
            v146 = v156;
            v160 = 0.0;
            v147 = v157;
            v196 = rand() % 0xC8 + 0x64;
            v158 = (float)v196;
            v196 = rand() % 0xC8 + 0x64;
            v159 = (float)v196;
            v196 = rand() % 0xC8 + 0x64;
            v160 = (float)v196;
            v186 = v164;
            v116 = v145 + v158;
            *(float *)v164 = v116;
            *(float *)&v117 = v146 + v159;
            v164[1] = v117;
            *(float *)&v118 = v147 + v160;
            v164[2] = v118;
            v145 = v116;
            v146 = *(float *)&v117;
            v147 = *(float *)&v118;
            v196 = sub_49B68(v44, 1);
            v195 = (float)v196;
            if ( v195 < 0.0 )
            {
              v196 = sub_49B68(v39, 1);
              v195 = (double)v196 * dbl_9232C;
            }
            if ( v195 >= 0.0 )
            {
              sub_53054(&v145, v195);
            }
            v187 = v154;
            v128 = 0.0;
            v129 = 0.0;
            v130 = 0.0;
            v128 = v145 + *(float *)(v39 + 0x9E);
            v129 = v146 + *(float *)(v39 + 0xA2);
            v46 = v147 + *(float *)(v39 + 0xA6);
            *(float *)v154 = v128;
            v130 = v46;
            *(float *)&v154[1] = v129;
            *(float *)&v154[2] = v130;
            v145 = v128;
            v146 = v129;
            v147 = v130;
            v47 = v202;
            *(_BYTE *)a12 = 3;
            *(_DWORD *)(a12 + 1) = v47;
            *(_BYTE *)(v47 + 0x62) = 0;
            *(_BYTE *)(v47 + 0x67) = 3;
            *(_DWORD *)(v47 + 0x63) = 0;
            *(_DWORD *)(v47 + 0x68) = 0;
            *(float *)(v47 + 0x6C) = v145;
            *(float *)(v47 + 0x70) = v146;
            *(float *)(v47 + 0x74) = v147;
            return 0xFFFFFFFF;
          }
          return 0;
        }
LABEL_79:
        v34 = *(_DWORD *)(a8 + 4 * (__int16)v215);
        for ( jj = 0; ; ++jj )
        {
          if ( jj >= (int)*(unsigned __int16 *)(v34 + 0x1A) )
          {
            LOWORD(v215) = v215 + 1;
            if ( (__int16)v215 >= a7 )
            {
              goto LABEL_101;
            }
            goto LABEL_79;
          }
          v35 = 4 * jj + *(_DWORD *)(v34 + 0x10);
          v36 = *(_BYTE *)(v35 + 1);
          if ( v36 != (char)0xFF
            && (*(_WORD *)(v35 + 2) & 1) != 0
            && (word_103FA2[0x14 * *(unsigned __int8 *)(v35 + 1)] & 4) != 0
            && (v36 != 0x11 || *(_BYTE *)(v34 + 0x58)) )
          {
            v37 = 0;
            v178 = 99999.0;
            while ( v37 < v15 )
            {
              v38 = v89[v37];
              if ( (i & (1 << *(_WORD *)(v38 + 0x56))) != 0 )
              {
                v180 = v112;
                v131 = 0.0;
                v132 = 0.0;
                v133 = 0.0;
                v131 = *(float *)v34 - *(float *)(v38 + 0x9E);
                v132 = *(float *)(v34 + 4) - *(float *)(v38 + 0xA2);
                v133 = *(float *)(v34 + 8) - *(float *)(v38 + 0xA6);
                *(float *)v112 = v131;
                *(float *)&v112[1] = v132;
                *(float *)&v112[2] = v133;
                v148 = v131;
                v149 = v132;
                v150 = v133;
                v182 = sqrt(v132 * v132 + v131 * v131 + v133 * v133);
                v179 = v182;
                if ( *(_BYTE *)(v38 + 0x58) != 4 )
                {
                  v179 = v182 + flt_92338;
                }
                if ( v179 < (double)v178 )
                {
                  a5 = v38;
                  v178 = v179;
                }
              }
              ++v37;
            }
            if ( *(_BYTE *)(*(_DWORD *)(v34 + 0x10) + 4 * jj + 1) != 0x11 || v178 >= (double)flt_92334 )
            {
              if ( !a5 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x13E7);
              }
              *(_DWORD *)(v34 + 0x6B) = 4 * jj + *(_DWORD *)(v34 + 0x10);
              *(_DWORD *)(v34 + 0x6F) = a5;
              sub_3676C(v34, 0);
              if ( (*(_BYTE *)(v34 + 0x73) & 1) != 0 )
              {
                break;
              }
            }
          }
        }
        *(_BYTE *)a12 = 2;
        *(_DWORD *)(a12 + 1) = v34;
        return 0xFFFFFFFF;
      }
      else
      {
        v48 = *(_WORD *)(a11 + 0x5A);
        LOWORD(v212) = 0;
        if ( v48 <= 0 )
        {
          return 0;
        }
        while ( 1 )
        {
          v50 = *(_DWORD *)(a11 + 4 * (__int16)v212 + 0x46);
          v51 = *(unsigned __int8 *)(v50 + 0x57);
          if ( v51 != 0xFF
            && (_BYTE)v51 != *v167
            && (v167[v51 + 0x1C0] == 2
             || (_BYTE)byte_104BEA == *(_BYTE *)(v50 + 0x57)
             && ((1 << *v167) & (unsigned __int8)byte_D8460[*(__int16 *)(a11 + 4)]) != 0) )
          {
            v52 = *(_DWORD *)(a11 + 4 * (__int16)v212 + 0x46);
            if ( !v50 )
            {
              return 0;
            }
            v53 = v167;
            for ( kk = *(_WORD *)(v50 + 0x18); kk < (int)*(unsigned __int16 *)(v52 + 0x1A); ++kk )
            {
              if ( *(_BYTE *)(4 * kk + *(_DWORD *)(v52 + 0x10) + 1) == 0x17
                && *((_WORD *)sub_35A70(v52, kk) + 0x2B) == *v53 )
              {
                v55 = sub_35A70(v52, kk);
                if ( *((_WORD *)v55 + 0x2B) != *v53 )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1468);
                }
                sub_36CD4(v52, kk, (int *)&v188);
                if ( v55 != sub_35A70(v52, kk) )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x146C);
                }
                v188 = sub_35C38(v52, (int)v55);
                if ( v188 != 0xFFFFFFFF )
                {
                  Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x146E);
                }
                return 0xFFFFFFFF;
              }
            }
            v189 = sub_361B8(v52);
            if ( !v189 )
            {
              LOWORD(v211) = 0;
              if ( (__int16)v207 > 0 )
              {
                do
                {
                  if ( v18 )
                  {
                    break;
                  }
                  v56 = a6 + 4 * (__int16)v211;
                  v57 = *(_DWORD *)v56;
                  if ( *(_BYTE *)(*(_DWORD *)v56 + 0x58) == 4 )
                  {
                    for ( mm = 0; mm < *(_DWORD *)(v57 + 0x15A); ++mm )
                    {
                      if ( *(_BYTE *)(v57 + 7 * mm + 0xAB) == 0x49 )
                      {
                        v18 = v57;
                        break;
                      }
                    }
                  }
                  LOWORD(v211) = v211 + 1;
                }
                while ( (__int16)v211 < (__int16)v207 );
              }
              if ( v18 )
              {
                *(_BYTE *)a12 = 3;
                *(_DWORD *)(a12 + 1) = v18;
                *(_BYTE *)(v18 + 0x62) = 0;
                *(_DWORD *)(v18 + 0x63) = 0;
                *(_BYTE *)(v18 + 0x67) = 1;
                *(_DWORD *)(v18 + 0x68) = v52;
                return 0xFFFFFFFF;
              }
              v59 = 0;
              if ( (__int16)v207 > 0 )
              {
                while ( 1 )
                {
                  v60 = (int *)(a6 + 4 * v59);
                  v61 = *v60;
                  if ( !*(_DWORD *)(*v60 + 0x28) || sub_4A534(*v60, 0x49) )
                  {
                    v62 = 0;
                    if ( *(_BYTE *)(v61 + 0x5D) == 1 && *(_DWORD *)(v61 + 0x5E) == a11 )
                    {
                      v62 = 0xFFFFFFFF;
                    }
                    if ( *(_BYTE *)(v61 + 0x58) == 4 && !v62 && sub_4A534(v61, 0x46) )
                    {
                      break;
                    }
                  }
                  if ( ++v59 >= (__int16)v207 )
                  {
                    goto LABEL_162;
                  }
                }
                if ( sub_4A480(v61, 1u, v52) )
                {
                  v18 = v61;
                }
              }
LABEL_162:
              if ( v18 )
              {
                *(_BYTE *)a12 = 3;
                *(_DWORD *)(a12 + 1) = v18;
                return 0xFFFFFFFF;
              }
            }
            v63 = 0;
            if ( *(unsigned __int16 *)(v52 + 0x1A) - *(unsigned __int16 *)(v52 + 0x18) > *(unsigned __int16 *)(v52 + 0x1E) )
            {
              v63 = 0xFFFFFFFF;
            }
            if ( v189 == 0xFFFFFFFF || v63 == 0xFFFFFFFF )
            {
              break;
            }
          }
          v49 = *(_WORD *)(a11 + 0x5A);
          LOWORD(v212) = v212 + 1;
          if ( (__int16)v212 >= v49 )
          {
            return 0;
          }
        }
        v64 = 0;
        LOWORD(v214) = 0;
        if ( (__int16)v207 > 0 )
        {
          do
          {
            if ( v18 )
            {
              break;
            }
            v65 = *(_DWORD *)(a6 + 4 * (__int16)v214);
            if ( (!*(_DWORD *)(v65 + 0x28) || sub_4A534(*(_DWORD *)(a6 + 4 * (__int16)v214), 0x49))
              && *(_BYTE *)(v65 + 0x58) == 4
              && (sub_4A564(v65) || sub_4A534(v65, 0x46)) )
            {
              v64 = v65;
              if ( sub_4A480(v65, 1u, v52) )
              {
                v18 = v65;
              }
            }
            LOWORD(v214) = v214 + 1;
          }
          while ( (__int16)v214 < (__int16)v207 );
        }
        if ( v18 )
        {
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v18;
          return 0xFFFFFFFF;
        }
        if ( !v64 )
        {
          return v18;
        }
        v136 = 0.0;
        v137 = 0.0;
        v138 = 0.0;
        v193 = &v113;
        v136 = *(float *)(v64 + 0x9E) - *(float *)v52;
        v137 = *(float *)(v64 + 0xA2) - *(float *)(v52 + 4);
        v138 = *(float *)(v64 + 0xA6) - *(float *)(v52 + 8);
        v113 = v136;
        v123 = 0.0;
        v124 = 0.0;
        v114 = v137;
        v125 = 0.0;
        v115 = v138;
        v196 = rand() % 0x64 + 0x14;
        v123 = (float)v196;
        v196 = rand() % 0x64 + 0x14;
        v124 = (float)v196;
        v196 = rand() % 0x64 + 0x14;
        v125 = (float)v196;
        v194 = v126;
        v119 = v113 + v123;
        *(float *)v126 = v119;
        *(float *)&v120 = v114 + v124;
        v126[1] = v120;
        *(float *)&v121 = v115 + v125;
        v126[2] = v121;
        v113 = v119;
        v114 = *(float *)&v120;
        v115 = *(float *)&v121;
        v196 = sub_49B68(v64, 2);
        v190 = (float)v196;
        if ( v190 < 0.0 )
        {
          v196 = sub_35ED8(v52);
          v190 = (double)v196 * dbl_9232C;
        }
        if ( v190 >= 0.0 )
        {
          sub_53054(&v113, v190);
        }
        v197 = v134;
        v142 = 0.0;
        v143 = 0.0;
        v144 = 0.0;
        v142 = v113 + *(float *)v52;
        v143 = v114 + *(float *)(v52 + 4);
        v66 = v115 + *(float *)(v52 + 8);
        *(float *)v134 = v142;
        v144 = v66;
        *(float *)&v134[1] = v143;
        *(float *)&v134[2] = v144;
        v113 = v142;
        v114 = v143;
        v115 = v144;
        *(_BYTE *)a12 = 3;
        *(_DWORD *)(a12 + 1) = v64;
        *(_BYTE *)(v64 + 0x62) = 0;
        *(_BYTE *)(v64 + 0x67) = 3;
        *(_DWORD *)(v64 + 0x63) = 0;
        *(_DWORD *)(v64 + 0x68) = 0;
        *(float *)(v64 + 0x6C) = v113;
        *(float *)(v64 + 0x70) = v114;
        *(float *)(v64 + 0x74) = v115;
        return 0xFFFFFFFF;
      }
    }
    else
    {
      v94 = 0;
      v95 = 0;
      v96 = 0;
      v97 = 0;
      v98 = 0;
      v99 = 0;
      LOWORD(v221) = 0;
      if ( (__int16)v207 > 0 )
      {
        do
        {
          if ( v18 )
          {
            break;
          }
          v67 = *(_BYTE *)(*(_DWORD *)(a6 + 4 * (__int16)v221) + 0x58);
          v166 = *(_DWORD *)(a6 + 4 * (__int16)v221);
          if ( v67 == 4 )
          {
            for ( nn = 0; nn < v15 && !v18; ++nn )
            {
              v68 = v89[nn];
              v199 = 4 * nn;
              if ( (i & (1 << *(_WORD *)(v68 + 0x56))) != 0 )
              {
                v90 = *(_BYTE *)(v68 + 0x62);
                v91 = *(_DWORD *)(v68 + 0x63);
                v92 = *(_BYTE *)(v68 + 0x67);
                v93 = *(_DWORD *)(v68 + 0x68);
                v94 = *(_DWORD *)(v68 + 0x6C);
                v95 = *(_DWORD *)(v68 + 0x70);
                v96 = *(_DWORD *)(v68 + 0x74);
                v97 = *(_DWORD *)(v68 + 0x78);
                v98 = *(_DWORD *)(v68 + 0x7C);
                v99 = *(_DWORD *)(v68 + 0x80);
                v100 = *(_DWORD *)(v68 + 0x84);
                if ( sub_4A480(v68, 3u, v166) )
                {
                  v18 = v166;
                  v198 = v89[v199 / 4];
                }
                v69 = v89[nn];
                *(_BYTE *)(v69 + 0x62) = v90;
                *(_DWORD *)(v69 + 0x63) = v91;
                *(_BYTE *)(v69 + 0x67) = v92;
                v69 += 0x62;
                *(_DWORD *)(v69 + 6) = v93;
                *(_DWORD *)(v69 + 0xA) = v94;
                *(_DWORD *)(v69 + 0xE) = v95;
                *(_DWORD *)(v69 + 0x12) = v96;
                *(_DWORD *)(v69 + 0x16) = v97;
                *(_DWORD *)(v69 + 0x1A) = v98;
                *(_DWORD *)(v69 + 0x1E) = v99;
                *(_DWORD *)(v69 + 0x22) = v100;
              }
            }
          }
          LOWORD(v221) = v221 + 1;
        }
        while ( (__int16)v221 < (__int16)v207 );
      }
      if ( v18 )
      {
        v70 = v198;
        sub_49A40(v18, 0xFFFFFFFF);
        if ( sub_43184((int)v167, v18, v70) )
        {
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v18;
          return 0xFFFFFFFF;
        }
      }
      LOWORD(v209) = 0;
      if ( (__int16)v207 > 0 )
      {
        do
        {
          if ( v18 )
          {
            break;
          }
          v71 = *(_DWORD *)(a6 + 4 * (__int16)v209);
          if ( *(_BYTE *)(v71 + 0x58) == 4 && *(_DWORD *)(v71 + 0x88) )
          {
            if ( sub_4A564(*(_DWORD *)(a6 + 4 * (__int16)v209)) )
            {
              for ( i1 = 0; i1 < v15; ++i1 )
              {
                v72 = v89[i1];
                if ( (i & (1 << *(_WORD *)(v72 + 0x56))) != 0 )
                {
                  if ( sub_4A480(v71, 3u, v72) )
                  {
                    *(_BYTE *)a12 = 3;
                    *(_DWORD *)(a12 + 1) = v71;
                    return 0xFFFFFFFF;
                  }
                  v181 = v71;
                }
              }
            }
            else
            {
              v171 = v71;
            }
          }
          LOWORD(v209) = v209 + 1;
        }
        while ( (__int16)v209 < (__int16)v207 );
      }
      v73 = v181;
      if ( v181 )
      {
        v74 = sub_4937C(v181, 0x39);
        if ( v74 != 0xFFFFFFFF && (*(_WORD *)(v73 + 0x9C) & 4) == 0 && *(int *)(v73 + 0x88) > 0xC )
        {
          *(_BYTE *)(v73 + 0x62) = 1;
          *(_BYTE *)(v73 + 0x67) = 5;
          *(_DWORD *)(v73 + 0x63) = 7 * v74 + v73 + 0xAB;
          *(_BYTE *)a12 = 3;
          *(_DWORD *)(a12 + 1) = v73;
          sub_49B3C(v73, 0);
          if ( (*(_BYTE *)(v73 + 0x84) & 1) != 0 )
          {
            return 0xFFFFFFFF;
          }
        }
      }
      if ( v171 )
      {
        v75 = sub_4937C(v171, 0x41);
        if ( v75 != 0xFFFFFFFF )
        {
          v76 = v171;
          if ( *(int *)(v171 + 0x88) > 0xD )
          {
            *(_BYTE *)(v171 + 0x62) = 1;
            *(_BYTE *)(v76 + 0x67) = 5;
            *(_DWORD *)(v171 + 0x63) = 7 * v75 + v171 + 0xAB;
            v77 = v171;
            *(_BYTE *)a12 = 3;
            *(_DWORD *)(a12 + 1) = v77;
            sub_49B3C(v171, 0);
            if ( (*(_BYTE *)(v171 + 0x84) & 1) != 0 )
            {
              return 0xFFFFFFFF;
            }
          }
        }
      }
      v78 = *(int **)(a11 + 0x2C);
      if ( *v78 == a11 )
      {
        v79 = v78[1];
      }
      else
      {
        v79 = *v78;
      }
      v80 = v79;
      v81 = 0;
      if ( (__int16)v207 > 0 )
      {
        while ( 1 )
        {
          v18 = *(_DWORD *)(a6 + 4 * v81);
          v82 = *(_BYTE *)(v18 + 0x58);
          if ( v82 == 3 )
          {
            break;
          }
          if ( v82 != 4 )
          {
            ++v81;
            v18 = 0;
            if ( v81 < (__int16)v207 )
            {
              continue;
            }
          }
          goto LABEL_240;
        }
        sub_35C38(*(_DWORD *)(v18 + 0x59), *(_DWORD *)(a6 + 4 * v81));
        if ( *(_BYTE *)(v18 + 0x58) != 4 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x15E4);
        }
      }
LABEL_240:
      if ( !v18 )
      {
        return v18;
      }
      if ( *(_BYTE *)(v18 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x15EF);
      }
      *(_BYTE *)(v18 + 0x5D) = 1;
      *(_DWORD *)(v18 + 0x5E) = v80;
      return 2;
    }
  }
  else
  {
    if ( !a7 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x15FD);
    }
    if ( !v170 )
    {
      return 0;
    }
    v161 = 0.0;
    v162 = 0.0;
    v163 = 0.0;
    v217 = 0;
    if ( a7 > 0 )
    {
      while ( 2 )
      {
        v216 = 0;
        v83 = *(_DWORD *)(a8 + 4 * v217);
        while ( v216 < (int)*(unsigned __int16 *)(v83 + 0x1A) )
        {
          v84 = 4 * v216 + *(_DWORD *)(v83 + 0x10);
          if ( *(_BYTE *)(v84 + 1) != 0xFF
            && (*(_WORD *)(v84 + 2) & 1) != 0
            && (word_103FA2[0x14 * *(unsigned __int8 *)(v84 + 1)] & 4) != 0
            && (*(_BYTE *)(v84 + 1) != 0x11 || *(_BYTE *)(v83 + 0x58)) )
          {
            v200 = 99999.0;
            for ( i2 = 0; i2 < v15; ++i2 )
            {
              v86 = v89[i2];
              if ( (i & (1 << *(_WORD *)(v86 + 0x56))) != 0 )
              {
                v174 = v127;
                v139 = 0.0;
                v140 = 0.0;
                v141 = 0.0;
                v139 = *(float *)v83 - *(float *)(v86 + 0x9E);
                v140 = *(float *)(v83 + 4) - *(float *)(v86 + 0xA2);
                v141 = *(float *)(v83 + 8) - *(float *)(v86 + 0xA6);
                *(float *)v127 = v139;
                *(float *)&v127[1] = v140;
                *(float *)&v127[2] = v141;
                v161 = v139;
                v162 = v140;
                v163 = v141;
                v168 = sqrt(v140 * v140 + v139 * v139 + v141 * v141);
                v87 = *(_BYTE *)(v86 + 0x58);
                v201 = v168;
                if ( v87 != 4 )
                {
                  v201 = v168 + flt_92338;
                }
                if ( v201 < (double)v200 )
                {
                  v165 = v86;
                  v200 = v201;
                }
              }
            }
            if ( *(_BYTE *)(*(_DWORD *)(v83 + 0x10) + 4 * v216 + 1) != 0x11 || v200 >= (double)flt_92334 )
            {
              if ( !v165 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1633);
              }
              v88 = v165;
              *(_DWORD *)(v83 + 0x6B) = 4 * v216 + *(_DWORD *)(v83 + 0x10);
              *(_DWORD *)(v83 + 0x6F) = v88;
              sub_3676C(v83, 0);
              if ( (*(_BYTE *)(v83 + 0x73) & 1) != 0 )
              {
                *(_BYTE *)a12 = 2;
                *(_DWORD *)(a12 + 1) = v83;
                return 0xFFFFFFFF;
              }
            }
          }
          ++v216;
        }
        if ( ++v217 < a7 )
        {
          continue;
        }
        break;
      }
      return 0;
    }
    else
    {
      return 0;
    }
  }
}
// 42437: conditional instruction was optimized away because esi.4==0
// 9232C: using guessed type double dbl_9232C;
// 92334: using guessed type float flt_92334;
// 92338: using guessed type float flt_92338;
// 9233C: using guessed type float flt_9233C;
// A0D00: using guessed type int dword_A0D00;
// 103FA2: using guessed type __int16 word_103FA2[];
// 41268: using guessed type int var_40C[107];

//----- (00043184) --------------------------------------------------------
unsigned int __fastcall sub_43184(int a1, int a2, int a3)
{
  __int16 v4; // di
  __int16 i; // bx
  int v6; // esi
  char v8[12]; // [esp+0h] [ebp-2Ch] BYREF
  _DWORD v9[2]; // [esp+Ch] [ebp-20h]
  __int16 v10; // [esp+14h] [ebp-18h]
  int v11; // [esp+18h] [ebp-14h]

  strcpy(v8, "E?2.-&%#!");
  v9[0] = unk_9696C;
  v9[1] = *((_DWORD *)&unk_9696C + 1);
  v10 = *((_WORD *)&unk_9696C + 4);
  if ( sub_4A8FC(a2) / 2 < *(_DWORD *)(a2 + 0x88) )
  {
    *(_BYTE *)(a2 + 0x62) = 1;
    v4 = 0;
    v11 = a2 + 0xAB;
    while ( v4 < *(_DWORD *)(a2 + 0x15A) )
    {
      if ( byte_107052[0x6A * *(char *)(a2 + 7 * v4 + 0xAB)] == 5 )
      {
        for ( i = 0; i < 0xA; ++i )
        {
          v6 = 7 * v4;
          if ( *(_BYTE *)(a2 + v6 + 0xAB) == v8[i] )
          {
            *(_DWORD *)(a2 + 0x63) = v6 + v11;
            *(_BYTE *)(a2 + 0x67) = *((_BYTE *)v9 + i);
            *(_DWORD *)(a2 + 0x68) = a3;
            sub_49B3C(a2, 0);
            if ( (*(_BYTE *)(a2 + 0x84) & 1) != 0 )
            {
              return 0xFFFFFFFF;
            }
          }
        }
      }
      ++v4;
    }
  }
  return 0;
}

//----- (00043374) --------------------------------------------------------
char __fastcall sub_43374(unsigned __int8 *a1, int a2)
{
  char v3; // ch
  __int16 i; // bx

  v3 = 0;
  for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
  {
    if ( i != *a1
      && *(int *)((char *)&dword_A2F75 + 0x1EE * i) != 0xFFFFFFFF
      && a1[i + 0x1C0] == 2
      && (a2 == 0xFFFFFFFF || sub_43B7C((int)a1, i) > a2) )
    {
      v3 |= 1 << i;
    }
  }
  return v3;
}
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;

//----- (000433E0) --------------------------------------------------------
unsigned int __fastcall sub_433E0(int a1, __int16 a2, int a3)
{
  int v6; // eax
  __int16 v7; // dx
  int v8; // ebx
  int v9; // eax
  __int16 v10; // si
  __int16 v11; // bx

  if ( a2 < 0 || a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1705);
  }
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\race.cpp", 0x1706);
  }
  v6 = a1 + a2;
  if ( *(_BYTE *)(v6 + 0x1C0) == 2 )
  {
    return 0;
  }
  v7 = 0xA * (byte_A3D20 + 1);
  if ( *(_BYTE *)(v6 + 0x1C0) == 3 )
  {
    v7 = 0x14 * (byte_A3D20 + 1);
  }
  v8 = a2;
  v9 = a1 + 2 * a2;
  v10 = *(_WORD *)(v9 + 0x1B2) - v7;
  *(_WORD *)(v9 + 0x1B2) = v10;
  if ( *(_BYTE *)(a1 + v8 + 0x1C0) == 3 )
  {
    v11 = *(_WORD *)(a1 + 0x1CF);
    if ( v10 > v11 )
    {
      *(_WORD *)(v9 + 0x1B2) = v11 - 0xA;
    }
  }
  byte_D8460[*(__int16 *)(a3 + 4)] |= 1 << *(_BYTE *)a1;
  return 0xFFFFFFFF;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;

//----- (000434E4) --------------------------------------------------------
int __fastcall sub_434E4(char *a1, int a2)
{
  int v3; // eax
  int v4; // ebx
  signed int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  char *v10; // eax
  int i; // edx
  char *v12; // ecx
  int v13; // ebx
  signed int v14; // eax
  int v15; // ebx
  int v16; // eax
  int v17; // edx
  __int16 *v18; // edi
  int v19; // eax
  unsigned int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // esi
  int v24; // eax
  int v25; // edi
  int v26; // eax
  int v27; // edx
  _WORD *v28; // eax
  unsigned __int16 v29; // cx
  int k; // edx
  unsigned __int16 v31; // si
  _BYTE *v32; // ecx
  int m; // ebx
  char *v34; // edi
  int n; // esi
  int *v36; // edx
  int v37; // ecx
  int ii; // eax
  int v39; // edx
  __int16 v40; // bx
  unsigned __int16 v41; // dx
  char *v42; // eax
  int jj; // edx
  char *v44; // edx
  int kk; // edi
  __int16 *v46; // esi
  int mm; // edi
  __int16 *v48; // edx
  int nn; // eax
  int v50; // ecx
  int i1; // edi
  char *v52; // edx
  int v53; // eax
  char *v54; // ecx
  int v55; // ebx
  int v56; // edx
  _WORD *v57; // eax
  int i2; // edx
  char v59; // al
  int v60[107]; // [esp+0h] [ebp-6F8h] BYREF
  int v61[107]; // [esp+1ACh] [ebp-54Ch] BYREF
  int v62[107]; // [esp+358h] [ebp-3A0h] BYREF
  int v63[107]; // [esp+504h] [ebp-1F4h] BYREF
  _DWORD v64[3]; // [esp+6B0h] [ebp-48h]
  int j; // [esp+6BCh] [ebp-3Ch]
  char *v66; // [esp+6C0h] [ebp-38h]
  int v67; // [esp+6C4h] [ebp-34h]
  int v68; // [esp+6C8h] [ebp-30h]
  int v69; // [esp+6CCh] [ebp-2Ch]
  _WORD *v70; // [esp+6D0h] [ebp-28h]
  int v71; // [esp+6D4h] [ebp-24h]
  int v72; // [esp+6D8h] [ebp-20h]
  __int16 *v73; // [esp+6DCh] [ebp-1Ch]
  int v74; // [esp+6E0h] [ebp-18h]

  v3 = a1[0x19D];
  v4 = 0;
  v67 = 0;
  if ( (unsigned __int16)word_968E8[v3] <= *(int *)(a1 + 0x19E) )
  {
    v67 = 0xFFFFFFFF;
    if ( a2 != 1 )
    {
      return v67;
    }
    v59 = a1[0x19D] - 5;
    v68 = 0;
    switch ( v59 )
    {
      case 0:
        v6 = sub_40224((unsigned __int8 *)a1, v62, 0);
        if ( v6 > 0 )
        {
          v7 = 4 * v6;
          v8 = 0;
          do
          {
            v9 = v62[v8 / 4u];
            v8 += 4;
            *(_DWORD *)(v9 + 0x8C) = *(_DWORD *)(v9 + 0x98);
          }
          while ( v8 < v7 );
        }
        break;
      case 1:
        v10 = byte_A2F72;
        for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
        {
          if ( v10 != a1 )
          {
            v12 = &v10[2 * (unsigned __int8)*a1];
            v13 = *(__int16 *)(v10 + 0x1CD) + 0x14;
            if ( *((__int16 *)v12 + 0xD9) < v13 )
            {
              *((_WORD *)v12 + 0xD9) = v13;
            }
          }
          v10 += 0x1EE;
        }
        break;
      case 2:
        v14 = sub_40224((unsigned __int8 *)a1, v60, 0);
        if ( v14 > 0 )
        {
          v15 = 4 * v14;
          v16 = 0;
          do
          {
            v17 = v60[v16 / 4u];
            v16 += 4;
            *(_DWORD *)(v17 + 0x88) *= 2;
          }
          while ( v16 < v15 );
        }
        break;
      case 3:
        v18 = word_A3D21;
        for ( j = 0; word_A62A1 > j; ++j )
        {
          if ( ((1 << *a1) & (unsigned __int8)v18[0xA]) != 0 )
          {
            v19 = sub_1D794(v18, v61);
            if ( v19 > 0 )
            {
              v20 = 0;
              v74 = 4 * v19;
              do
              {
                v21 = v61[v20 / 4];
                v22 = *(__int16 *)(v21 + 0x56);
                if ( v22 != (unsigned __int8)*a1 && *(_BYTE *)(v21 + 0x58) == 4 )
                {
                  v23 = *(int *)((char *)&dword_A2F79 + 0x1EE * v22);
                  sub_1D538((int)v18, v21);
                  sub_1D3E8(v23, v61[v20 / 4], 0);
                }
                v20 += 4;
              }
              while ( (int)v20 < v74 );
            }
          }
          v18 += 0x30;
        }
        break;
      case 4:
        v72 = 0;
        v73 = word_A3D21;
        while ( word_A62A1 > v72 )
        {
          if ( ((1 << *a1) & *((unsigned __int8 *)v73 + 0x15)) != 0 )
          {
            v24 = sub_1D794(v73, v63);
            if ( v24 > 0 )
            {
              v25 = 4 * v24;
              v26 = 0;
              do
              {
                v27 = v63[v26 / 4u];
                if ( *(_WORD *)(v27 + 0x56) != (unsigned __int8)*a1 )
                {
                  *(_DWORD *)(v27 + 0x88) = 0;
                }
                v26 += 4;
              }
              while ( v26 < v25 );
            }
          }
          ++v72;
          v73 += 0x30;
        }
        break;
      case 5:
        v28 = &unk_BB1B3;
        v29 = 0xFFFF;
        v70 = 0;
        for ( k = 0; k < SHIWORD(dword_CA1ED); ++k )
        {
          if ( *((_BYTE *)v28 + 0x57) == *a1 && v28[0xB] != 0xA )
          {
            v31 = v28[0x21];
            if ( v29 > v31 )
            {
              v70 = v28;
              v29 = v31;
            }
          }
          v28 = (_WORD *)((char *)v28 + 0x7B);
        }
        if ( v70 )
        {
          v32 = (_BYTE *)*((_DWORD *)v70 + 4);
          for ( m = 0; m < (unsigned __int16)v70[0xC]; ++m )
          {
            if ( !*v32 || *v32 == 1 )
            {
              v64[0] = unk_96994;
              v64[1] = *((_DWORD *)&unk_96994 + 1);
              v64[2] = *((_DWORD *)&unk_96994 + 2);
              *v32 = v64[rand() % 3];
            }
            v32 += 4;
          }
        }
        break;
      case 6:
        v34 = (char *)&unk_CA1F1;
        for ( n = 0; n < SHIWORD(dword_D35E5); ++n )
        {
          if ( *((__int16 *)v34 + 0x2B) != 0xFFFFFFFF && v34[0x58] == 5 )
          {
            v36 = *(int **)(v34 + 0x59);
            v37 = *v36;
            if ( (*(_DWORD *)(v34 + 0xA2) & 0x7FFFFFFF) == 0 )
            {
              v37 = v36[1];
            }
            sub_1D3E8(v37, (int)v34, 0);
          }
          v34 += 0x162;
        }
        break;
      case 7:
        v69 = 0;
        v71 = 0;
        while ( (unsigned __int16)word_105258 > v69 )
        {
          v39 = 0;
          for ( ii = 0; ii < SHIWORD(dword_A3CF2); ++ii )
          {
            if ( ((1 << ii) & (*(int *)((char *)&dword_10529F + v71) >> 0x18)) != 0 )
            {
              ++v39;
            }
          }
          if ( v39 >= 2 )
          {
            *((_BYTE *)&dword_10529F + v71 + 3) |= 1 << *a1;
            v40 = v69;
            v41 = word_106FA6[(unsigned __int8)*a1];
            if ( v41 == v69 )
            {
              word_106FA6[(unsigned __int8)*a1] = 0xFFFF;
              word_106FB4[(unsigned __int8)*a1] = v40 ^ v41;
            }
          }
          v71 += 0x4B;
          ++v69;
        }
        break;
      case 8:
        v42 = (char *)&unk_BB1B3;
        for ( jj = 0; jj < SHIWORD(dword_CA1ED); ++jj )
        {
          if ( v42[0x57] == *a1 )
          {
            *(_DWORD *)(v42 + 0x62) = 0xFFFFFFFF;
          }
          v42 += 0x7B;
        }
        v68 = *(_DWORD *)(a1 + 0x19E) - (unsigned __int16)word_968E8[a1[0x19D]];
        break;
      case 9:
        v44 = (char *)&unk_BB1B3;
        for ( kk = 0; kk < SHIWORD(dword_CA1ED); ++kk )
        {
          if ( v44[0x57] == *a1 )
          {
            *(_WORD *)(v44 + 0x55) += 2;
            sub_34E70((int)v44);
          }
          v44 += 0x7B;
        }
        break;
      case 0xB:
        v46 = word_A3D21;
        for ( mm = 0; mm < word_A62A1; ++mm )
        {
          if ( ((1 << *a1) & (unsigned __int8)v46[0xA]) != 0 )
          {
            v48 = v46;
            for ( nn = 0; nn < v46[0x22]; *(_BYTE *)(v50 + 0x23) |= 2u )
            {
              v50 = *((_DWORD *)v48 + 0xB);
              v48 += 2;
              ++nn;
            }
          }
          v46 += 0x30;
        }
        break;
      case 0xC:
        v66 = a1;
        for ( i1 = 0; i1 < SHIWORD(dword_A3CF2); ++i1 )
        {
          if ( i1 != (unsigned __int8)*a1 && v66[0x1C0] == 2 )
          {
            v52 = byte_A2F72;
            v53 = 0;
            v54 = &byte_A2F72[v4];
            while ( v53 < SHIWORD(dword_A3CF2) )
            {
              if ( v53 != i1 && v53 != (unsigned __int8)*a1 && *((_WORD *)v54 + 0xD9) > *(_WORD *)(v52 + 0x1C9) )
              {
                *((_WORD *)v54 + 0xD9) = *(_WORD *)(v52 + 0x1C9);
              }
              ++v53;
              v54 += 0x1EE;
              v52 += 0x1EE;
            }
          }
          v4 += 2;
          ++v66;
        }
        break;
      case 0xE:
        LOBYTE(v4) = *a1;
        v55 = v4;
        v56 = (unsigned __int16)word_106FA6[v55];
        if ( (unsigned __int16)v56 != 0xFFFF )
        {
          word_106FB4[v55] = *(__int16 *)((char *)&word_105296 + 0x4B * v56);
        }
        break;
      case 0xF:
        v57 = &unk_BB1B3;
        for ( i2 = 0; i2 < SHIWORD(dword_CA1ED); ++i2 )
        {
          if ( *((_BYTE *)v57 + 0x57) == *a1 && *((_BYTE *)v57 + 0x54) != 0xFF )
          {
            v57[0x28] += 0x64;
          }
          v57 = (_WORD *)((char *)v57 + 0x7B);
        }
        break;
      default:
        break;
    }
    *(_DWORD *)(a1 + 0x19E) = v68;
  }
  return v67;
}
// 968E8: using guessed type __int16 word_968E8[21];
// A2F79: using guessed type int dword_A2F79;
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;
// CA1ED: using guessed type int dword_CA1ED;
// D35E5: using guessed type int dword_D35E5;
// 105296: using guessed type __int16 word_105296;
// 10529F: using guessed type int dword_10529F;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];

//----- (00043B7C) --------------------------------------------------------
int __fastcall sub_43B7C(int a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edx

  v2 = *(__int16 *)(a1 + 0x1D1) - *(__int16 *)(a1 + 2 * a2 + 0x1B2);
  if ( v2 <= 0 )
  {
    v3 = 0x64;
  }
  else
  {
    v3 = 0x64 * v2 / (*(__int16 *)(a1 + 0x1D1) - *(__int16 *)(a1 + 0x1C9));
  }
  if ( v3 > 0x64 )
  {
    return 0x64;
  }
  return v3;
}

//----- (00043BDC) --------------------------------------------------------
__int64 __fastcall sub_43BDC(int a1, unsigned int a2, int a3)
{
  int v4; // eax
  __int64 result; // rax
  _WORD v6[248]; // [esp+0h] [ebp-204h] BYREF
  unsigned int count; // [esp+1F0h] [ebp-14h]

  count = a2;
  sub_3B120((int)v6);
  if ( a3 == 0xFFFFFFFF )
  {
    sub_1BF94((P_Type1)count, v6, 0x1EEu);
    qmemcpy((void *)a1, v6, 0x1ECu);
    *(_WORD *)(a1 + 0x1EC) = v6[0xF6];
    v4 = 0x30 * *(_DWORD *)(a1 + 7);
    *(_WORD *)(a1 + 0x19B) = 0;
    *(_DWORD *)(a1 + 7) = &word_A3D21[v4];
  }
  else
  {
    qmemcpy(v6, (const void *)a1, 0x1EEu);
    *(_DWORD *)((char *)&v6[3] + 1) = *(__int16 *)(*(_DWORD *)((char *)&v6[3] + 1) + 4);
    sub_1C098(count, (int)v6, 0x1EEu);
  }
  LODWORD(result) = v6;
  HIDWORD(result) = 0;
  return result;
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00043C80) --------------------------------------------------------
int __fastcall sub_43C80(int a1, int a2, int a3, int a4)
{
  FILE *v5; // ecx
  __int16 v6; // ax
  __int16 v7; // dx
  __int16 v8; // ax
  __int16 v9; // bx
  __int16 v10; // ax
  __int16 v11; // di
  __int16 v12; // ax
  __int16 v13; // dx
  __int16 v14; // ax
  __int16 v15; // bx
  int v17; // [esp-4h] [ebp-11Ch]
  char v18[204]; // [esp+0h] [ebp-118h] BYREF
  char s[52]; // [esp+CCh] [ebp-4Ch] BYREF
  int v20; // [esp+100h] [ebp-18h] BYREF
  int v21; // [esp+110h] [ebp-8h]

  v21 = a4;
  v17 = *(unsigned __int8 *)(a1 + 1);
  dword_105248 = 0xFFFFFFF6;
  dword_10524C = 0xFFFFFFF6;
  dword_105250 = 0xFFFFFFF6;
  sprintf(s, "RACE%02d.DIP", v17);
  v5 = sub_1BB10(s, 0);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x55);
  }
  v18[0] = 0;
  while ( strncmp(v18, "DIPVALUES", 9u) )
  {
    Q_HELPWIN_CPP_FgetsLine_sub_2FE58(v5, v18);
  }
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1C9) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  v6 = v20;
  v7 = *(_WORD *)(a1 + 0x1C9);
  *(_WORD *)(a1 + 0x1CB) = v20;
  if ( v6 <= v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x64);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v8 = v20;
  v9 = *(_WORD *)(a1 + 0x1CB);
  *(_WORD *)(a1 + 0x1CD) = v20;
  if ( v8 <= v9 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x68);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v10 = v20;
  v11 = *(_WORD *)(a1 + 0x1CD);
  *(_WORD *)(a1 + 0x1CF) = v20;
  if ( v10 <= v11 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x6C);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v12 = v20;
  v13 = *(_WORD *)(a1 + 0x1CF);
  *(_WORD *)(a1 + 0x1D1) = v20;
  if ( v12 <= v13 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x70);
  }
  fscanf(v5, "%s %d", v18, &v20);
  v14 = v20;
  v15 = *(_WORD *)(a1 + 0x1D1);
  *(_WORD *)(a1 + 0x1D3) = v20;
  if ( v14 <= v15 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x74);
  }
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1D5) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1B0) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1D7) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1D9) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1DB) = v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(float *)(a1 + 0x1DD) = (float)(__int16)v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(float *)(a1 + 0x1E1) = (float)(__int16)v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(float *)(a1 + 0x1E5) = (float)(__int16)v20;
  fscanf(v5, "%s %d", v18, &v20);
  *(_WORD *)(a1 + 0x1C7) = v20;
  *(_BYTE *)(a1 + 0x19D) = *(_BYTE *)(a1 + 1);
  *(_DWORD *)(a1 + 0x19E) = 0;
  return fclose(v5);
}
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00044024) --------------------------------------------------------
unsigned int __fastcall sub_44024(_BYTE *a1, char a2)
{
  int v3; // eax
  int v4; // edi
  __int16 *v5; // edx
  int v6; // ebx
  int v8; // [esp+0h] [ebp-18h]

  v3 = 0;
  v8 = 0;
  v4 = 1 << a2;
  v5 = word_A3D21;
  while ( v3 < word_A62A1 )
  {
    v6 = *((unsigned __int8 *)v5 + 0x17);
    if ( ((1 << *a1) & v6) != 0 && (v4 & v6) != 0 )
    {
      return 0xFFFFFFFF;
    }
    ++v3;
    v5 += 0x30;
  }
  return v8;
}
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00044080) --------------------------------------------------------
char *__fastcall sub_44080(unsigned __int8 *a1)
{
  unsigned __int8 *v2; // ebp
  int v3; // edi
  char v4; // al
  char *result; // eax
  unsigned __int8 v6; // al
  int v7; // ecx
  int v8; // ebx
  char v9; // [esp+0h] [ebp-2Ch]
  int v10; // [esp+4h] [ebp-28h] BYREF
  int v11; // [esp+8h] [ebp-24h] BYREF
  char *v12; // [esp+Ch] [ebp-20h]
  unsigned __int8 *v13; // [esp+10h] [ebp-1Ch]

  if ( *a1 == (_BYTE)byte_104BEA && dword_A0D00 != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0xCD);
  }
  v13 = a1;
  v2 = a1;
  a1[0x1E9] = 0xE;
  v3 = 0;
  v12 = byte_A2F72;
  do
  {
    if ( v3 != *a1 && *(int *)((char *)&dword_A2F75 + 0x1EE * v3) != 0xFFFFFFFF )
    {
      if ( (v3 != (unsigned __int8)byte_104BEA || dword_A0D00 == 0xFFFFFFFF)
        && !v2[0x1C0]
        && sub_44024(a1, v3) == 0xFFFFFFFF )
      {
        *((_WORD *)v13 + 0xD9) = *(_WORD *)(a1 + 0x1D5);
        word_A3124[0xF7 * v3 + *a1] = word_A3147[0xF7 * v3];
        byte_A3132[0x1EE * v3 + *a1] = 1;
        v2[0x1C0] = 1;
      }
      if ( v2[0x1C0] )
      {
        v6 = sub_44434(a1, v3, &v10);
        if ( v6 != 0xE )
        {
          if ( v3 != (unsigned __int8)byte_104BEA || dword_A0D00 )
          {
            v9 = v6;
            v4 = sub_44BCC((int)v12, (__int16 *)*a1, v6, v10, &v11);
            sub_450B0(a1, v3, v9, v4, v10, v11);
          }
          else
          {
            a1[0x1E9] = v6;
            v7 = (char)a1[0x1E9];
            v8 = *a1;
            *(_DWORD *)(a1 + 0x1EA) = v10;
            sub_55AEC((int)&V_Type3_stru_10AE70, 2, v8, v7);
          }
        }
      }
    }
    ++v2;
    ++v3;
    result = v12 + 0x1EE;
    v13 += 2;
    v12 += 0x1EE;
  }
  while ( v3 < 7 );
  return result;
}
// A0D00: using guessed type int dword_A0D00;
// A2F75: using guessed type int dword_A2F75;
// A3124: using guessed type __int16 word_A3124[5];
// A3147: using guessed type __int16 word_A3147[];

//----- (00044238) --------------------------------------------------------
int __fastcall sub_44238(int a1, __int16 a2, _BYTE *a3, __int16 a4)
{
  char *v7; // edi
  char v8; // kr00_1
  _BYTE *v9; // eax
  int result; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  _BYTE *v21; // [esp+4h] [ebp-10h]

  *a3 = 0xE;
  v7 = &byte_A2F72[0x1EE * a2];
  v8 = *(_BYTE *)(a1 + a2 + 0x1C0);
  v21 = a3 + 2;
  v9 = a3 + 1;
  switch ( v8 )
  {
    case 0:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x126);
    case 1:
      *v9 = 2;
      *v21 = 3;
      v11 = 3;
      if ( dword_A2F6C[0] - dword_105248 >= 5 )
      {
        v11 = 4;
        a3[3] = 4;
      }
      if ( dword_A2F6C[0] - dword_10524C >= 5 )
      {
        v12 = (__int16)v11++;
        a3[v12] = 5;
      }
      if ( dword_A2F6C[0] - dword_105250 >= 5 )
      {
        v13 = (__int16)v11++;
        a3[v13] = 6;
      }
      if ( !*(_BYTE *)(a1 + a4 + 0x1C0) || v7[a4 + 0x1C0] != 2 )
      {
        goto LABEL_29;
      }
      a3[(__int16)v11] = 7;
      result = v11 + 1;
      break;
    case 2:
      *v9 = 0xD;
      return 2;
    case 3:
      *v9 = 8;
      v14 = 2;
      if ( dword_A2F6C[0] - dword_105248 >= 5 )
      {
        v14 = 3;
        *v21 = 4;
      }
      if ( dword_A2F6C[0] - dword_10524C >= 5 )
      {
        v15 = (__int16)v14++;
        a3[v15] = 5;
      }
      if ( dword_A2F6C[0] - dword_105250 >= 5 )
      {
        v16 = (__int16)v14++;
        a3[v16] = 6;
      }
      a3[(__int16)v14] = 0xC;
      v11 = v14 + 1;
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) && v7[a4 + 0x1C0] == 2 )
      {
        v17 = (__int16)v11++;
        a3[v17] = 7;
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) && v7[a4 + 0x1C0] == 1 )
      {
        v18 = (__int16)v11;
        v19 = v11 + 1;
        a3[v18] = 9;
        v20 = (__int16)v19;
        v11 = v19 + 1;
        a3[v20] = 0xB;
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) && v7[a4 + 0x1C0] == 3 )
      {
        a3[(__int16)v11] = 0xA;
        result = v11 + 1;
      }
      else
      {
LABEL_29:
        result = v11;
      }
      break;
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x17E);
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C[];
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00044434) --------------------------------------------------------
char __fastcall sub_44434(unsigned __int8 *a1, __int16 a2, _DWORD *a3)
{
  char v5; // bh
  unsigned __int8 v6; // bl
  unsigned __int8 *v7; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // edx
  unsigned __int8 *v12; // eax
  __int16 v13; // dx
  __int16 v14; // ax
  __int16 v15; // dx
  int v16; // [esp+0h] [ebp-18h]

  if ( *a1 == (_BYTE)byte_104BEA && dword_A0D00 != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x18D);
  }
  v5 = sub_43374(a1, 0xFFFFFFFF);
  v6 = a1[a2 + 0x1C0];
  v7 = &a1[2 * a2];
  if ( v6 < 2u )
  {
    if ( v6 == 1 )
    {
      if ( byte_A3D20 )
      {
        if ( (unsigned __int8)byte_A3D20 <= 1u )
        {
          if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1C9) && a2 == (unsigned __int8)byte_104BEA )
          {
            return 2;
          }
        }
        else if ( byte_A3D20 == 2 )
        {
          if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1CB) && a2 == (unsigned __int8)byte_104BEA )
          {
            *((_WORD *)v7 + 0xD9) = *(_WORD *)(a1 + 0x1C9) - 1;
            return 2;
          }
          v9 = &a1[2 * a2];
          if ( *(_WORD *)(a1 + 0x1CD) > *((_WORD *)v9 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
          {
            *((_WORD *)v9 + 0xD9) = *(_WORD *)(a1 + 0x1CB) - 1;
          }
          else
          {
            v10 = &a1[2 * a2];
            if ( *(_WORD *)(a1 + 0x1CF) > *((_WORD *)v10 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
            {
              *((_WORD *)v10 + 0xD9) = *(_WORD *)(a1 + 0x1CD) - 1;
            }
            else
            {
              v11 = &a1[2 * a2];
              if ( *(_WORD *)(a1 + 0x1D1) > *((_WORD *)v11 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
              {
                *((_WORD *)v11 + 0xD9) = *(_WORD *)(a1 + 0x1CF) - 1;
              }
              else
              {
                v12 = &a1[2 * a2];
                if ( *(_WORD *)(a1 + 0x1D3) > *((_WORD *)v12 + 0xD9) && a2 == (unsigned __int8)byte_104BEA )
                {
                  *((_WORD *)v12 + 0xD9) = *(_WORD *)(a1 + 0x1D1) - 1;
                }
                else if ( a2 == (unsigned __int8)byte_104BEA )
                {
                  *(_WORD *)&a1[2 * a2 + 0x1B2] = *(_WORD *)(a1 + 0x1D3) - 1;
                }
              }
            }
          }
        }
      }
      else if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1C9)
             && (!v5 || a2 == (unsigned __int8)byte_104BEA)
             && (a2 == (unsigned __int8)byte_104BEA || *(int *)((char *)&dword_A3CF8 + 6 * *a1) >> 0x10 > 2) )
      {
        return 2;
      }
      if ( *(_WORD *)(a1 + 0x1D3) < *(_WORD *)&a1[2 * a2 + 0x1B2] )
      {
        return 3;
      }
    }
  }
  else if ( v6 <= 2u )
  {
    if ( *((_WORD *)v7 + 0xD9) > *(_WORD *)(a1 + 0x1CD) )
    {
      return 0xD;
    }
  }
  else
  {
    if ( v6 != 3 )
    {
      goto LABEL_51;
    }
    if ( *((_WORD *)v7 + 0xD9) < *(_WORD *)(a1 + 0x1C9) && !v5 )
    {
      if ( a2 == (unsigned __int8)byte_104BEA || *(int *)((char *)&dword_A3CF8 + 6 * *a1) >> 0x10 > 2 )
      {
        return 2;
      }
      return 8;
    }
    if ( *(_WORD *)(a1 + 0x1CF) > *(_WORD *)&a1[2 * a2 + 0x1B2] )
    {
      return 8;
    }
  }
LABEL_51:
  if ( dword_A2F6C[0] % *(__int16 *)(a1 + 0x1C7) || a2 != (unsigned __int8)byte_104BEA || a1[a2 + 0x1C0] == 2 )
  {
    return 0xE;
  }
  v16 = rand() % 0x64;
  if ( a2 != (unsigned __int8)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x212);
  }
  if ( a1[a2 + 0x1C0] != 3 || v16 >= 0x50 )
  {
LABEL_85:
    if ( *(_WORD *)(a1 + 0x1C9) <= *(_WORD *)&a1[2 * a2 + 0x1B2] )
    {
      if ( a1[a2 + 0x1C0] == 3 )
      {
        v16 += 0xF;
      }
      if ( *(__int16 *)&a1[2 * a2 + 0x1B2] > *(__int16 *)(a1 + 0x1CF) + 0xA && v16 >= 0x5D && sub_46208(a1, a2) )
      {
        return 6;
      }
      if ( *(_WORD *)(a1 + 0x1CF) < *(_WORD *)&a1[2 * a2 + 0x1B2] && v16 >= 0x58 && sub_46034(a1, a2) )
      {
        return 5;
      }
      if ( *(__int16 *)&a1[2 * a2 + 0x1B2] > *(__int16 *)(a1 + 0x1D5) + 0x14 && v16 >= 0x50 && sub_45E64(a1, a2) )
      {
        return 4;
      }
    }
    return 0xE;
  }
  v13 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( v13 == *a1
         || v13 == a2
         || *(int *)((char *)&dword_A2F75 + 0x1EE * v13) == 0xFFFFFFFF
         || a1[v13 + 0x1C0] != 2
         || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v13] != 3 )
    {
      if ( ++v13 >= SHIWORD(dword_A3CF2) )
      {
        goto LABEL_67;
      }
    }
    *a3 = v13;
    return 0xA;
  }
  else
  {
LABEL_67:
    v14 = 0;
    if ( SHIWORD(dword_A3CF2) > 0 )
    {
      while ( v14 == *a1
           || v14 == a2
           || *(int *)((char *)&dword_A2F75 + 0x1EE * v14) == 0xFFFFFFFF
           || a1[v14 + 0x1C0] != 3
           || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v14] != 2 )
      {
        if ( ++v14 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_76;
        }
      }
      *a3 = v14;
      return 7;
    }
    else
    {
LABEL_76:
      v15 = 0;
      if ( SHIWORD(dword_A3CF2) <= 0 )
      {
        goto LABEL_85;
      }
      while ( v15 == *a1
           || v15 == a2
           || *(int *)((char *)&dword_A2F75 + 0x1EE * v15) == 0xFFFFFFFF
           || a1[v15 + 0x1C0] != 2
           || byte_A3132[0x1EE * (unsigned __int8)byte_104BEA + v15] != 1 )
      {
        if ( ++v15 >= SHIWORD(dword_A3CF2) )
        {
          goto LABEL_85;
        }
      }
      *a3 = v15;
      return 9;
    }
  }
}
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// A2F75: using guessed type int dword_A2F75;
// A3CF2: using guessed type int dword_A3CF2;
// A3CF8: using guessed type int dword_A3CF8;
// A3D20: using guessed type char byte_A3D20;

//----- (00044A2C) --------------------------------------------------------
int __fastcall sub_44A2C(_BYTE *a1, int a2, char a3, _BYTE *a4)
{
  _BYTE *v4; // eax
  int result; // eax

  if ( *a1 != (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x263);
  }
  v4 = a4 + 1;
  switch ( a3 )
  {
    case 0:
      *a4 = 0;
      result = 1;
      break;
    case 1:
      *a4 = 1;
      *v4 = 2;
      result = 2;
      break;
    case 2:
      *a4 = 3;
      result = 1;
      break;
    case 3:
      *a4 = 4;
      *v4 = 5;
      result = 2;
      break;
    case 4:
      *a4 = 6;
      *v4 = 7;
      result = 2;
      break;
    case 5:
      *a4 = 8;
      *v4 = 9;
      result = 2;
      break;
    case 6:
      *a4 = 0xA;
      *v4 = 0xB;
      result = 2;
      break;
    case 7:
      *a4 = 0xC;
      *v4 = 0xD;
      result = 2;
      break;
    case 8:
      *a4 = 0xE;
      result = 1;
      break;
    case 9:
      *a4 = 0xF;
      *v4 = 0x10;
      result = 2;
      break;
    case 0xA:
      *a4 = 0x11;
      *v4 = 0x12;
      result = 2;
      break;
    case 0xB:
      *a4 = 0x13;
      *v4 = 0x14;
      result = 2;
      break;
    case 0xC:
      *a4 = 0x15;
      *v4 = 0x16;
      result = 2;
      break;
    case 0xD:
      *a4 = 0x1B;
      *v4 = 0x1C;
      result = 2;
      break;
    case 0xE:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x2CF);
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x2D4);
  }
  return result;
}

//----- (00044BCC) --------------------------------------------------------
char __fastcall sub_44BCC(int a1, __int16 *a2, char a3, int a4, int *a5)
{
  int v7; // ebx
  __int16 v8; // di
  int v9; // ebx
  const char *v10; // edx
  int v11; // [esp+0h] [ebp-1B8h] BYREF

  *(_DWORD *)(a1 + 0x1EA) = a4;
  switch ( a3 )
  {
    case 2:
      return 3;
    case 3:
      if ( *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) <= *(_WORD *)(a1 + 0x1D1) )
      {
        return 5;
      }
      else
      {
        return 4;
      }
    case 4:
      if ( *(__int16 *)(a1 + 2 * (__int16)a2 + 0x1B2) > *(__int16 *)(a1 + 0x1D5) + 0x14
        && sub_45E64((_BYTE *)a1, (__int16)a2) )
      {
        return 6;
      }
      else
      {
        return 7;
      }
    case 5:
      if ( *(_WORD *)(a1 + 0x1CF) < *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) && sub_46034((_BYTE *)a1, (__int16)a2) )
      {
        return 8;
      }
      else
      {
        return 9;
      }
    case 6:
      if ( *(__int16 *)(a1 + 2 * (__int16)a2 + 0x1B2) > *(__int16 *)(a1 + 0x1CF) + 0xA
        && sub_46208((_BYTE *)a1, (__int16)a2) )
      {
        return 0xA;
      }
      else
      {
        return 0xB;
      }
    case 7:
      if ( *(_BYTE *)(a4 + a1 + 0x1C0) != 2 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x336);
      }
      if ( *(__int16 *)(a1 + 2 * a4 + 0x1B2)
         + (__int16)(*(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) - word_A3143[0xF7 * (__int16)a2]) <= *(__int16 *)(a1 + 0x1CD) )
      {
        return 0xD;
      }
      else
      {
        return 0xC;
      }
    case 8:
      return 0xE;
    case 9:
      if ( *(_BYTE *)(a1 + (__int16)a2 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x34A);
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) != 1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x34B);
      }
      if ( (__int16)(*(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) - *(_WORD *)(a1 + 2 * a4 + 0x1B2)) <= *(__int16 *)(a1 + 0x1D5) )
      {
        return 0x10;
      }
      else
      {
        return 0xF;
      }
    case 0xA:
      if ( *(_BYTE *)(a1 + (__int16)a2 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x361);
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x362);
      }
      v7 = a1 + 2 * (__int16)a2;
      v8 = *(_WORD *)(2 * a4 + a1 + 0x1B2);
      if ( (__int16)(*(_WORD *)(v7 + 0x1B2) - v8) <= 0
        || (__int16)(*(_WORD *)(v7 + 0x1B2) - word_A3143[0xF7 * (__int16)a2]) - (__int16)(v8 - word_A3143[0xF7 * a4]) <= 0 )
      {
        return 0x12;
      }
      else
      {
        return 0x11;
      }
    case 0xB:
      if ( *(_BYTE *)(a1 + (__int16)a2 + 0x1C0) != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x384);
      }
      if ( *(_BYTE *)(a1 + a4 + 0x1C0) != 1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x385);
      }
      if ( *(__int16 *)(a1 + 2 * a4 + 0x1B2)
         - (__int16)(*(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) - word_A3143[0xF7 * (__int16)a2]) >= *(__int16 *)(a1 + 0x1C9) )
      {
        return 0x14;
      }
      else
      {
        return 0x13;
      }
    case 0xC:
      if ( !a4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x39D);
      }
      if ( a5 )
      {
        *a5 = a4;
      }
      if ( !sub_45958((unsigned __int8 *)a1, 2, (__int16 *)a4, 0) )
      {
        return 0x18;
      }
      if ( (unsigned __int16)sub_45848((unsigned __int8 *)a1, a4, (int)&v11, a2) )
      {
        if ( ((1 << *(_BYTE *)a1) & *(unsigned __int8 *)(a4 + 0x15)) != 0 )
        {
          return 0x1A;
        }
        else if ( *(_WORD *)(a1 + 0x1D3) >= *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) )
        {
          return 0x16;
        }
        else
        {
          return 0x15;
        }
      }
      else if ( ((1 << *(_BYTE *)a1) & *(unsigned __int8 *)(a4 + 0x15)) != 0 )
      {
        return 0x19;
      }
      else
      {
        return 0x17;
      }
    case 0xD:
      if ( *(_WORD *)(a1 + 2 * (__int16)a2 + 0x1B2) < *(_WORD *)(a1 + 0x1CB) )
      {
        return 0x1C;
      }
      else
      {
        return 0x1B;
      }
    case 0xE:
      v9 = 0x3CE;
      v10 = "..\\raceneg.cpp";
      break;
    default:
      v9 = 0x3D3;
      v10 = "..\\raceneg.cpp";
      break;
  }
  Q_AssertLogBreakExit_sub_261A8(0, v10, v9);
}
// A3143: using guessed type __int16 word_A3143[];

//----- (000450B0) --------------------------------------------------------
char __fastcall sub_450B0(unsigned __int8 *a1, __int16 a2, char a3, char a4, int a5, int a6)
{
  char *v7; // edi
  char *v9; // ebx
  char *v10; // edx
  unsigned __int8 *v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // edx
  char *v17; // edi
  unsigned __int8 *v18; // esi
  int v19; // eax
  int v20; // edx
  __int16 v21; // cx
  int v22; // edx
  int v23; // edx
  __int16 v24; // ax
  _BYTE v26[428]; // [esp+0h] [ebp-1D4h] BYREF
  int v27; // [esp+1ACh] [ebp-28h]
  int v28; // [esp+1B0h] [ebp-24h]
  char *v29; // [esp+1B4h] [ebp-20h]
  int v30; // [esp+1B8h] [ebp-1Ch]
  char *v31; // [esp+1BCh] [ebp-18h]
  char *v32; // [esp+1C0h] [ebp-14h]
  __int16 v33; // [esp+1C4h] [ebp-10h]

  v33 = a2;
  v30 = a2;
  v7 = &byte_A2F72[0x1EE * a2];
  v29 = &v7[a5];
  v28 = 0x1EE * a5;
  v32 = &byte_A2F72[0x1EE * a5];
  v31 = &v32[a2];
  v9 = &v7[2 * a5];
  v10 = &v32[2 * a2];
  v11 = &a1[2 * v30];
  switch ( a3 )
  {
    case 0:
      v11 = (unsigned __int8 *)*a1;
      v12 = v33;
      v11[(_DWORD)v7 + 0x1C0] = 1;
      a1[v12 + 0x1C0] = v11[(_DWORD)v7 + 0x1C0];
      *(_WORD *)&a1[2 * v33 + 0x1B2] = *(_WORD *)(a1 + 0x1D5);
      LOWORD(v11) = *(_WORD *)(v7 + 0x1D5);
      *(_WORD *)&v7[2 * *a1 + 0x1B2] = (_WORD)v11;
      return (char)v11;
    case 1:
      if ( a4 == 1 )
      {
        LOBYTE(v11) = v33;
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0x28;
      }
      return (char)v11;
    case 2:
      v13 = *a1;
      v14 = v33;
      v7[v13 + 0x1C0] = 2;
      a1[v14 + 0x1C0] = v7[v13 + 0x1C0];
      v11 = (unsigned __int8 *)*a1;
      *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] -= 0x28;
      return (char)v11;
    case 3:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 3;
      }
      if ( a4 == 4 )
      {
        v15 = *a1;
        v16 = v33;
        v7[v15 + 0x1C0] = 3;
        a1[v16 + 0x1C0] = v7[v15 + 0x1C0];
        *(_WORD *)&a1[2 * v16 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 0xA;
      }
      else
      {
        LOBYTE(v11) = v33;
        *(_WORD *)&a1[2 * v33 + 0x1B2] = *(_WORD *)(a1 + 0x1D1);
      }
      return (char)v11;
    case 4:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 5;
        dword_105248 = dword_A2F6C[0];
      }
      if ( a4 == 6 )
      {
        sub_45F60(a1, v33, 0);
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 5;
      }
      else
      {
        v20 = v33;
        v11 = &a1[2 * v33];
        v21 = *((_WORD *)v11 + 0xD9) - 2;
        *((_WORD *)v11 + 0xD9) = v21;
        if ( a1[v20 + 0x1C0] == 3 )
        {
          *((_WORD *)v11 + 0xD9) = v21 - 2;
        }
      }
      return (char)v11;
    case 5:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 8;
        dword_10524C = dword_A2F6C[0];
      }
      if ( a4 == 8 )
      {
        sub_46130(a1, v33, 0);
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 5;
      }
      else
      {
        v22 = v33;
        v11 = &a1[2 * v33];
        *((_WORD *)v11 + 0xD9) -= 3;
        if ( a1[v22 + 0x1C0] == 3 )
        {
          *((_WORD *)v11 + 0xD9) -= 3;
        }
      }
      return (char)v11;
    case 6:
      if ( (_BYTE)byte_104BEA == *a1 )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 8;
        dword_105250 = dword_A2F6C[0];
      }
      if ( a4 == 0xA )
      {
        sub_46304(a1, v33, 0);
        *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        v11 = (unsigned __int8 *)*a1;
        *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] += 0xA;
      }
      else
      {
        v23 = v33;
        v11 = &a1[2 * v33];
        *((_WORD *)v11 + 0xD9) -= 2;
        if ( a1[v23 + 0x1C0] == 3 )
        {
          *((_WORD *)v11 + 0xD9) -= 2;
        }
      }
      return (char)v11;
    case 7:
      if ( a4 != 0xC )
      {
        goto LABEL_54;
      }
      *((_WORD *)v11 + 0xD9) += 5;
      if ( *((__int16 *)v10 + 0xD9) > *(int *)((char *)&dword_A313B + SHIWORD(v28)) - 0xA )
      {
        *((_WORD *)v11 + 0xD9) += 5;
        v29[0x1C0] = 1;
        v31[0x1C0] = 1;
        *((_WORD *)v9 + 0xD9) += 0xA;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] += 5;
        *((_WORD *)v10 + 0xD9) += 0xA;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
        *((_WORD *)v11 + 0xD9) += 0xF;
      }
      return (char)v11;
    case 8:
      v19 = *a1;
      v7[v19 + 0x1C0] = 1;
      a1[v30 + 0x1C0] = v7[v19 + 0x1C0];
      v11 = (unsigned __int8 *)*a1;
      *(_WORD *)&v7[2 * (_DWORD)v11 + 0x1B2] -= 0x1E;
      return (char)v11;
    case 9:
      if ( a4 == 0xF )
      {
        *((_WORD *)v11 + 0xD9) += 0xA;
        v29[0x1C0] = 2;
        v31[0x1C0] = 2;
        *((_WORD *)v9 + 0xD9) -= 0xF;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] += 0xA;
        *((_WORD *)v10 + 0xD9) -= 0x14;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
      }
      goto LABEL_38;
    case 0xA:
      if ( a4 == 0x11 )
      {
        *((_WORD *)v11 + 0xD9) += 0xF;
        v29[0x1C0] = 1;
        v31[0x1C0] = 1;
        *((_WORD *)v9 + 0xD9) -= 5;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] -= 5;
        *((_WORD *)v10 + 0xD9) -= 0xA;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
LABEL_41:
        *((_WORD *)v11 + 0xD9) -= 5;
      }
      else
      {
LABEL_38:
        *((_WORD *)v11 + 0xD9) -= 0xA;
      }
      break;
    case 0xB:
      if ( a4 != 0x13 )
      {
        goto LABEL_41;
      }
      *((_WORD *)v11 + 0xD9) += 5;
      v27 = *(_DWORD *)((char *)&unk_A3141 + SHIWORD(v28));
      if ( *((__int16 *)v10 + 0xD9) > v27 - 0xA )
      {
        *((_WORD *)v11 + 0xD9) += 5;
        v29[0x1C0] = 3;
        v31[0x1C0] = 3;
        *((_WORD *)v9 + 0xD9) += 0xA;
        *(_WORD *)&v7[2 * *a1 + 0x1B2] += 5;
        *((_WORD *)v10 + 0xD9) += 0xF;
        v11 = (unsigned __int8 *)&v32[2 * *a1];
        *((_WORD *)v11 + 0xD9) += 0xA;
      }
      break;
    case 0xC:
      if ( a4 == 0x15 || a4 == 0x1A )
      {
        LOBYTE(v11) = byte_104BEA;
        if ( v33 != (unsigned __int8)byte_104BEA )
        {
          if ( !a5 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x4FA);
          }
          v24 = sub_45848((unsigned __int8 *)v7, a5, (int)v26, (__int16 *)v7);
          if ( !v24 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x4FD);
          }
          sub_45A0C(v7, a5, (int)v26, v24);
          LOBYTE(v11) = v33;
          *(_WORD *)&a1[2 * v33 + 0x1B2] += 0xA;
        }
      }
      else if ( a4 == 0x16 )
      {
LABEL_54:
        *((_WORD *)v11 + 0xD9) -= 5;
      }
      return (char)v11;
    case 0xD:
      if ( *a1 == (_BYTE)byte_104BEA )
      {
        *(_WORD *)&v7[2 * (unsigned __int8)byte_104BEA + 0x1B2] += 3;
      }
      if ( a4 == 0x1B )
      {
        v17 = &v7[*a1];
        v11 = (unsigned __int8 *)v33;
        v17[0x1C0] = 1;
        v18 = &a1[(_DWORD)v11];
        LOBYTE(v11) = v17[0x1C0];
        v18[0x1C0] = (unsigned __int8)v11;
      }
      else
      {
        LOBYTE(v11) = v33;
        *(_WORD *)&a1[2 * v33 + 0x1B2] -= 0x19;
      }
      return (char)v11;
    case 0xE:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\raceneg.cpp", 0x515);
    default:
      return (char)v11;
  }
  return (char)v11;
}
// A2F6C: using guessed type int dword_A2F6C[];
// A313B: using guessed type int dword_A313B;
// 105248: using guessed type int dword_105248;
// 10524C: using guessed type int dword_10524C;
// 105250: using guessed type int dword_105250;

//----- (00045848) --------------------------------------------------------
int __usercall sub_45848@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>, int a3@<ebx>, __int16 *a4@<edi>)
{
  __int16 v5; // si
  int v6; // eax
  int v7; // ebx
  int v8; // ebx
  char v9; // al
  int v10; // ebx
  int v12[107]; // [esp+0h] [ebp-1CCh] BYREF
  int v13; // [esp+1ACh] [ebp-20h]
  int v14; // [esp+1B0h] [ebp-1Ch]
  int v15; // [esp+1B4h] [ebp-18h]
  size_t v16; // [esp+1B8h] [ebp-14h]

  v13 = a2;
  v14 = a3;
  LOWORD(v15) = 0;
  v5 = 0;
  v16 = sub_40224(a1, v12, 0);
  if ( (__int16)v16 > 0 )
  {
    do
    {
      v8 = v12[v5];
      v9 = *(_BYTE *)(v8 + 0x58);
      v10 = *(_DWORD *)(v8 + 0x59);
      if ( v9 != 1 && v9 != 2 )
      {
        if ( v9 == 3 )
        {
          a4 = &word_A3D21[0x30 * *(__int16 *)(v10 + 0xC)];
LABEL_8:
          if ( (unsigned __int8)byte_D5D47[0x64 * a4[2] + *(__int16 *)(v13 + 4)] < 3u )
          {
            v6 = 4 * (__int16)v15;
            v7 = v12[v5];
            LOWORD(v15) = v15 + 1;
            *(_DWORD *)(v14 + v6) = v7;
          }
          goto LABEL_10;
        }
        if ( v9 != 4 )
        {
          if ( v9 == 5 )
          {
            a4 = *(__int16 **)v10;
          }
          goto LABEL_8;
        }
        a4 = (__int16 *)v10;
        if ( !sub_45958(a1, 2, (__int16 *)v10, 0) )
        {
          goto LABEL_8;
        }
      }
LABEL_10:
      ++v5;
    }
    while ( v5 < (__int16)v16 );
  }
  return v15;
}
// A3D21: using guessed type __int16 word_A3D21[];
// 45848: using guessed type int var_1CC[107];

//----- (00045958) --------------------------------------------------------
int __fastcall sub_45958(unsigned __int8 *a1, char a2, __int16 *a3, _DWORD *a4)
{
  int v5; // eax
  __int16 v6; // di
  int v7; // ecx
  __int16 v8; // bx
  int v9; // eax
  int v11[107]; // [esp+0h] [ebp-1C4h] BYREF
  int v12; // [esp+1ACh] [ebp-18h]
  _DWORD *v13; // [esp+1B0h] [ebp-14h]
  char v14; // [esp+1B4h] [ebp-10h]

  v14 = a2;
  v13 = a4;
  if ( !a3 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x54E);
  }
  v5 = sub_1D794(a3, v11);
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v12 = v5;
  while ( v8 < v12 )
  {
    v9 = v11[v8];
    if ( v9 && (*(_WORD *)(v9 + 0x56) == *a1 && v14 == 3 || a1[*(__int16 *)(v9 + 0x56) + 0x1C0] == v14) )
    {
      ++v6;
      v7 += *(_DWORD *)v9 * *(_DWORD *)(v9 + 0x8C);
    }
    ++v8;
  }
  if ( v13 )
  {
    *v13 = v7;
  }
  return v6;
}
// 45958: using guessed type int var_1C4[107];

//----- (00045A0C) --------------------------------------------------------
int __fastcall sub_45A0C(_BYTE *a1, int a2, int a3, __int16 a4)
{
  int result; // eax
  int v6; // edx

  if ( *a1 == (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x574);
  }
  for ( result = 0; (__int16)result < a4; *(_DWORD *)(v6 + 0x5E) = a2 )
  {
    *(_BYTE *)(*(_DWORD *)(a3 + 4 * (__int16)result) + 0x5D) = 1;
    v6 = *(_DWORD *)(a3 + 4 * (__int16)result++);
  }
  return result;
}

//----- (00045A54) --------------------------------------------------------
unsigned int __fastcall sub_45A54(unsigned __int8 *a1, int a2, int a3)
{
  __int16 v5; // ax
  int v6; // edx
  __int16 i; // ax
  char *v8; // edi
  __int16 j; // si
  __int16 v10; // ax
  int v11; // edx
  __int16 v12; // dx
  char v13; // cl
  unsigned int v16; // [esp+0h] [ebp-2Ch]
  unsigned int v17; // [esp+4h] [ebp-28h]
  unsigned int v18; // [esp+8h] [ebp-24h]
  unsigned int v19; // [esp+14h] [ebp-18h]
  int v20; // [esp+18h] [ebp-14h]

  if ( *a1 != (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x58A);
  }
  v19 = 0;
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v20 = 0;
  if ( (byte_D8460[*(__int16 *)(a2 + 4)] & 1) != 0 )
  {
    return 0;
  }
  v5 = 0;
  if ( SHIWORD(dword_A3CF2) > 0 )
  {
    while ( v5 == (unsigned __int8)byte_104BEA
         || a1[v5 + 0x1C0]
         || ((1 << v5) & (*(unsigned __int8 *)(a2 + 0x14) | *(unsigned __int8 *)(a2 + 0x15))) == 0 )
    {
      if ( ++v5 >= SHIWORD(dword_A3CF2) )
      {
        goto LABEL_11;
      }
    }
    v20 = v5;
    a1[v5 + 0x1C0] = 1;
    v16 = 0xFFFFFFFF;
    *(_WORD *)&a1[2 * v5 + 0x1B2] = *(_WORD *)(a1 + 0x1D5);
    v6 = 0xF7 * v5;
    byte_A3132[2 * v6 + *a1] = 1;
    word_A3124[*a1 + v6] = word_A3147[0xF7 * v5];
  }
LABEL_11:
  if ( !v16 )
  {
    for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
    {
      if ( i != (unsigned __int8)byte_104BEA && a1[i + 0x1C0] == 2 )
      {
        if ( ((1 << i) & *(unsigned __int8 *)(a2 + 0x15)) != 0 )
        {
          v20 = i;
          v18 = 0xFFFFFFFF;
        }
        if ( !v18 && ((1 << i) & *(unsigned __int8 *)(a2 + 0x14)) != 0 )
        {
          v17 = 0xFFFFFFFF;
          v20 = i;
        }
      }
    }
  }
  if ( !v16 && !v18 && !v17 )
  {
    v8 = byte_A2F72;
    for ( j = 0; j < SHIWORD(dword_A3CF2); v8 += 0x1EE )
    {
      if ( j != (unsigned __int8)byte_104BEA )
      {
        v10 = 0;
        if ( SHIWORD(dword_A3CF2) > 0 )
        {
          v11 = *(unsigned __int8 *)(a2 + 0x15);
          while ( ((1 << j) & v11) == 0 || ((1 << v10) & v11) == 0 || v8[v10 + 0x1C0] != 2 )
          {
            if ( ++v10 >= SHIWORD(dword_A3CF2) )
            {
              goto LABEL_34;
            }
          }
          v19 = 0xFFFFFFFF;
        }
      }
LABEL_34:
      ++j;
    }
  }
  if ( v16 == 0xFFFFFFFF )
  {
    v12 = 4;
  }
  else if ( v18 == 0xFFFFFFFF )
  {
    v12 = 5;
  }
  else if ( v17 == 0xFFFFFFFF )
  {
    v12 = 6;
  }
  else if ( v19 == 0xFFFFFFFF )
  {
    v12 = 7;
  }
  else
  {
    v13 = byte_104BEA;
    *(_BYTE *)(a3 + 0x5D) = 0;
    *(_DWORD *)(a3 + 0x5E) = 0;
    if ( ((1 << v13) & *(unsigned __int8 *)(a2 + 0x17)) != 0 )
    {
      v12 = 3;
    }
    else
    {
      v12 = 0x14;
    }
  }
  byte_D8460[*(__int16 *)(a2 + 4)] |= 1u;
  sub_55AEC((int)&V_Type3_stru_10AE70, v12, a3, v20);
  return 0xFFFFFFFF;
}
// 45D0F: conditional instruction was optimized away because edx.4 is in (3..7|==14)
// A3124: using guessed type __int16 word_A3124[5];
// A3147: using guessed type __int16 word_A3147[];
// A3CF2: using guessed type int dword_A3CF2;

//----- (00045D50) --------------------------------------------------------
unsigned int __fastcall sub_45D50(unsigned __int8 *a1, int a2, int a3)
{
  int v6; // ebx
  unsigned int v7; // edx
  unsigned __int8 *v8; // eax
  unsigned __int8 v9; // cl
  __int16 v11; // [esp+2h] [ebp-14h]

  if ( *a1 != (_BYTE)byte_104BEA )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\raceneg.cpp", 0x61C);
  }
  v11 = *(_WORD *)(a3 + 0x56);
  v6 = *(unsigned __int8 *)(a2 + 0x15);
  v7 = 0xFFFFFFFF;
  if ( ((1 << v11) & v6) == 0 )
  {
    v8 = &a1[v11];
    v9 = v8[0x1C0];
    if ( v9 )
    {
      if ( v9 == 2 )
      {
        v7 = 9;
      }
    }
    else
    {
      v8[0x1C0] = 1;
      *(_WORD *)&a1[2 * v11 + 0x1B2] = *(_WORD *)(a1 + 0x1D5);
      byte_A3132[0x1EE * v11 + *a1] = 1;
      v7 = 8;
      word_A3124[0xF7 * v11 + *a1] = word_A3147[0xF7 * v11];
    }
  }
  if ( v7 == 0xFFFFFFFF || (byte_D8460[*(__int16 *)(a2 + 4)] & 1) != 0 )
  {
    return 0;
  }
  sub_55AEC((int)&V_Type3_stru_10AE70, v7, a3, v11);
  byte_D8460[*(__int16 *)(a2 + 4)] |= 1u;
  return 0xFFFFFFFF;
}
// A3124: using guessed type __int16 word_A3124[5];
// A3147: using guessed type __int16 word_A3147[];

//----- (00045E64) --------------------------------------------------------
unsigned int __fastcall sub_45E64(_BYTE *a1, __int16 a2)
{
  unsigned __int8 v2; // al
  int v3; // edx
  char *i; // eax
  float v7; // [esp+4h] [ebp-24h]
  __int16 v8; // [esp+8h] [ebp-20h]
  __int16 v9; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 v10; // [esp+10h] [ebp-18h]
  unsigned __int8 v11; // [esp+14h] [ebp-14h]

  if ( a1[a2 + 0x1C0] == 3 )
  {
    return 0xFFFFFFFF;
  }
  v9 = 0;
  v11 = 1 << *a1;
  v8 = 0;
  v2 = 1 << a2;
  v3 = 0;
  v10 = v2;
  for ( i = (char *)&unk_A62A3; (__int16)v3 < word_A792F; i += 0x27 )
  {
    if ( (v11 & (unsigned __int8)i[0x20]) != 0 )
    {
      ++v9;
    }
    if ( (v10 & (unsigned __int8)i[0x20]) != 0 )
    {
      ++v8;
    }
    ++v3;
  }
  if ( v9 >= 5 )
  {
    if ( !v8 )
    {
      v8 = 1;
    }
    v7 = (float)v9;
    if ( v7 / (double)word_A792F > dbl_9259A )
    {
      return 0;
    }
    if ( v7 / (double)v8 > dbl_925A2 )
    {
      return 0;
    }
    return 0xFFFFFFFF;
  }
  return 0;
}
// 9259A: using guessed type double dbl_9259A;
// 925A2: using guessed type double dbl_925A2;
// A792F: using guessed type __int16 word_A792F;

//----- (00045F60) --------------------------------------------------------
void __fastcall sub_45F60(_BYTE *a1, __int16 a2, int a3)
{
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // edx
  int v9; // ebp
  __int64 v10; // rtt
  unsigned __int8 v11; // dh
  char *v12; // eax
  unsigned __int8 v13; // dl
  int i; // ecx
  int v16; // [esp+4h] [ebp-14h]

  v5 = 0;
  v6 = 0;
  if ( a1[a2 + 0x1C0] == 3 )
  {
    v7 = rand();
    v8 = v7;
    v9 = 6;
  }
  else
  {
    v7 = rand();
    v8 = v7;
    v9 = 3;
  }
  LODWORD(v10) = v7;
  HIDWORD(v10) = v8 >> 0x1F;
  v16 = v10 % v9 + 1;
  v11 = 1 << *a1;
  v12 = (char *)&unk_A62A3;
  v13 = 1 << byte_A2F72[0x1EE * a2];
  for ( i = 0; (__int16)i < word_A792F; v12 += 0x27 )
  {
    if ( a3 || (v11 & (unsigned __int8)v12[0x20]) == 0 )
    {
      if ( (v13 & (unsigned __int8)v12[0x20]) != 0 && v5 < v16 && (v11 & (unsigned __int8)v12[0x20]) == 0 )
      {
        ++v5;
        v12[0x20] |= v11;
      }
    }
    else if ( v6 < v16 && (v13 & (unsigned __int8)v12[0x20]) == 0 )
    {
      ++v6;
      v12[0x20] |= v13;
    }
    ++i;
  }
  JUMPOUT(0x449E7);
}
// 45FD6: control flows out of bounds to 449E7
// A792F: using guessed type __int16 word_A792F;

//----- (00046034) --------------------------------------------------------
unsigned int __fastcall sub_46034(_BYTE *a1, __int16 a2)
{
  unsigned __int8 v2; // al
  int v3; // edx
  __int16 *i; // eax
  float v7; // [esp+4h] [ebp-24h]
  __int16 v8; // [esp+8h] [ebp-20h]
  __int16 v9; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 v10; // [esp+10h] [ebp-18h]
  unsigned __int8 v11; // [esp+14h] [ebp-14h]

  if ( a1[a2 + 0x1C0] == 3 )
  {
    return 0xFFFFFFFF;
  }
  v9 = 0;
  v11 = 1 << *a1;
  v8 = 0;
  v2 = 1 << a2;
  v3 = 0;
  v10 = v2;
  for ( i = word_A3D21; (__int16)v3 < word_A62A1; i += 0x30 )
  {
    if ( (v11 & *((_BYTE *)i + 0x17)) != 0 )
    {
      ++v9;
    }
    if ( (v10 & *((_BYTE *)i + 0x17)) != 0 )
    {
      ++v8;
    }
    ++v3;
  }
  if ( v9 >= 3 )
  {
    if ( !v8 )
    {
      v8 = 1;
    }
    v7 = (float)v9;
    if ( v7 / (double)word_A62A1 > dbl_925AA )
    {
      return 0;
    }
    if ( v7 / (double)v8 > dbl_925B2 )
    {
      return 0;
    }
    return 0xFFFFFFFF;
  }
  return 0;
}
// 925AA: using guessed type double dbl_925AA;
// 925B2: using guessed type double dbl_925B2;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00046130) --------------------------------------------------------
void __fastcall sub_46130(_BYTE *a1, __int16 a2, int a3)
{
  int v5; // esi
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // ebp
  __int64 v10; // rtt
  unsigned __int8 v11; // dh
  __int16 *v12; // eax
  unsigned __int8 v13; // dl
  int i; // ecx
  int v16; // [esp+4h] [ebp-14h]

  v5 = 0;
  v6 = 0;
  if ( a1[a2 + 0x1C0] == 3 )
  {
    v7 = rand();
    v8 = v7;
    v9 = 4;
  }
  else
  {
    v7 = rand();
    v8 = v7;
    v9 = 2;
  }
  LODWORD(v10) = v7;
  HIDWORD(v10) = v8 >> 0x1F;
  v16 = v10 % v9 + 1;
  v11 = 1 << *a1;
  v12 = word_A3D21;
  v13 = 1 << byte_A2F72[0x1EE * a2];
  for ( i = 0; (__int16)i < word_A62A1; v12 += 0x30 )
  {
    if ( a3 || (v11 & *((_BYTE *)v12 + 0x17)) == 0 )
    {
      if ( (v13 & *((_BYTE *)v12 + 0x17)) != 0 && v5 < v16 && (v11 & *((_BYTE *)v12 + 0x17)) == 0 )
      {
        *((_BYTE *)v12 + 0x16) |= v11;
        ++v5;
        *((_BYTE *)v12 + 0x17) |= v11;
      }
    }
    else if ( v6 < v16 && (v13 & *((_BYTE *)v12 + 0x17)) == 0 )
    {
      *((_BYTE *)v12 + 0x16) |= v13;
      ++v6;
      *((_BYTE *)v12 + 0x17) |= v13;
    }
    ++i;
  }
  JUMPOUT(0x449E7);
}
// 461A6: control flows out of bounds to 449E7
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00046208) --------------------------------------------------------
unsigned int __fastcall sub_46208(_BYTE *a1, __int16 a2)
{
  unsigned __int8 v2; // al
  __int16 v3; // dx
  char *v4; // eax
  float v7; // [esp+0h] [ebp-20h]
  __int16 v8; // [esp+8h] [ebp-18h]
  __int16 v9; // [esp+Ch] [ebp-14h]
  unsigned __int8 v10; // [esp+10h] [ebp-10h]
  unsigned __int8 v11; // [esp+14h] [ebp-Ch]

  if ( a1[a2 + 0x1C0] == 3 )
  {
    return 0xFFFFFFFF;
  }
  v8 = 0;
  v11 = 1 << *a1;
  v9 = 0;
  v2 = 1 << a2;
  v3 = 0;
  v10 = v2;
  v4 = byte_10525A;
  while ( v3 < (int)(unsigned __int16)word_105258 )
  {
    if ( (v11 & (unsigned __int8)v4[0x48]) != 0 )
    {
      ++v8;
    }
    if ( (v10 & (unsigned __int8)v4[0x48]) != 0 )
    {
      ++v9;
    }
    ++v3;
    v4 += 0x4B;
  }
  if ( v8 >= 5 )
  {
    if ( !v9 )
    {
      v9 = 1;
    }
    v7 = (float)v8;
    if ( v7 / (double)(unsigned __int16)word_105258 > dbl_925BA )
    {
      return 0;
    }
    if ( v7 / (double)v9 > dbl_925C2 )
    {
      return 0;
    }
    return 0xFFFFFFFF;
  }
  return 0;
}
// 925BA: using guessed type double dbl_925BA;
// 925C2: using guessed type double dbl_925C2;

//----- (00046304) --------------------------------------------------------
int __fastcall sub_46304(_BYTE *a1, __int16 a2, int a3)
{
  int v4; // ebx
  int v5; // esi
  unsigned __int8 v6; // cl
  __int64 i; // rax
  int v10; // [esp+Ch] [ebp-2Ch]
  __int16 v11; // [esp+18h] [ebp-20h]
  __int16 v12; // [esp+20h] [ebp-18h]
  unsigned __int8 v13; // [esp+24h] [ebp-14h]

  v4 = 0;
  v5 = 0;
  if ( a1[a2 + 0x1C0] == 3 )
  {
    v10 = rand() % 2 + 1;
  }
  else
  {
    v10 = 1;
  }
  v13 = 1 << *a1;
  v6 = 1 << byte_A2F72[0x1EE * a2];
  v11 = (unsigned __int8)*a1;
  v12 = (unsigned __int8)byte_A2F72[0x1EE * a2];
  for ( i = (unsigned int)byte_10525A; (unsigned __int16)word_105258 > SWORD2(i); LODWORD(i) = i + 0x4B )
  {
    if ( a3 || (*(_BYTE *)(i + 0x48) & v13) == 0 )
    {
      if ( (v6 & *(_BYTE *)(i + 0x48)) != 0 && v4 < v10 && (v13 & *(_BYTE *)(i + 0x48)) == 0 )
      {
        *(_BYTE *)(i + 0x48) |= v13;
        if ( (unsigned __int16)word_106FA6[v11] == SWORD2(i) )
        {
          word_106FA6[v11] = 0xFFFF;
        }
        ++v4;
      }
    }
    else if ( v5 < v10 && (*(_BYTE *)(i + 0x48) & v6) == 0 )
    {
      *(_BYTE *)(i + 0x48) |= v6;
      if ( (unsigned __int16)word_106FA6[v12] == SWORD2(i) )
      {
        word_106FA6[v12] = 0xFFFF;
      }
      ++v5;
    }
    ++WORD2(i);
  }
  return i;
}
// 106FA6: using guessed type __int16 word_106FA6[7];

//----- (00046470) --------------------------------------------------------
unsigned __int16 *sub_46470()
{
  return sub_46480((unsigned __int16 *)&word_105258, 0);
}

//----- (00046480) --------------------------------------------------------
unsigned __int16 *__fastcall sub_46480(unsigned __int16 *a1, const char *a2)
{
  unsigned __int16 *v2; // esi
  unsigned __int16 *v3; // ebx
  unsigned __int16 *v4; // eax
  const char *v5; // eax
  unsigned int v6; // ebp
  unsigned __int16 *v7; // edi
  FILE *v8; // edx
  unsigned __int16 *v9; // ebx
  int v10; // edx
  unsigned __int16 *v11; // ebx
  int i; // eax
  int v13; // eax
  int v14; // ecx
  char *v15; // edx
  char v16; // al
  int k; // edi
  int v18; // ebp
  int v19; // ecx
  unsigned __int16 *result; // eax
  unsigned __int16 *v21; // esi
  unsigned __int16 *v22; // [esp+0h] [ebp-34h]
  fpos_t v23; // [esp+4h] [ebp-30h] BYREF
  fpos_t pos; // [esp+8h] [ebp-2Ch] BYREF
  int v25; // [esp+Ch] [ebp-28h] BYREF
  int v26; // [esp+10h] [ebp-24h] BYREF
  unsigned __int16 *v27; // [esp+14h] [ebp-20h]
  int j; // [esp+18h] [ebp-1Ch]
  FILE *fp; // [esp+1Ch] [ebp-18h]

  v2 = a1;
  *(_DWORD *)(a1 + 0xEB5) = 0;
  v3 = a1 + 0xEA6;
  *(_DWORD *)(a1 + 0xEB7) = 0;
  do
  {
    a1 = (unsigned __int16 *)((char *)a1 + 0x4B);
    *(_BYTE *)a1 = 0;
    *((_BYTE *)a1 + 0xFFFFFFFF) = *(_BYTE *)a1;
  }
  while ( a1 != v3 );
  if ( !dword_105254 )
  {
    v4 = v2;
    do
    {
      v4 = (unsigned __int16 *)((char *)v4 + 0x4B);
      *((_BYTE *)v4 + 0xFFFFFFFA) = 0xFF;
    }
    while ( v4 != v2 + 0xEA6 );
    *v2 = 0;
    if ( a2 )
    {
      v5 = a2;
    }
    else
    {
      v5 = "restree.txt";
    }
    fp = sub_1BB10(v5, &v23);
    if ( fp )
    {
      fscanf(fp, "%d", &v25);
      *v2 = v25;
      if ( *v2 > 0x64u )
      {
        *v2 = 0x64;
      }
      v6 = 0xFFFFFFEC;
      j = 0;
      v22 = v2 + 1;
      v7 = v2;
      while ( *v2 > j )
      {
        v8 = fp;
        fscanf(fp, "%s", v22);
        fscanf(v8, "%d %d", &v25, &v26);
        *((_BYTE *)v7 + 0x4C) = v25;
        if ( j > 0xA )
        {
          v26 *= v6;
        }
        if ( v26 > 0xFDE8 )
        {
          v26 = 0xFDE8;
        }
        v9 = v7;
        v10 = 0;
        v7[0x1F] = v26;
        do
        {
          fscanf(fp, "%d", &v25);
          *((_BYTE *)v9 + 0x40) = v25;
          if ( v25 == 0xFF )
          {
            v11 = v7;
            i = 0;
            goto LABEL_25;
          }
          ++v10;
          v9 = (unsigned __int16 *)((char *)v9 + 1);
        }
        while ( v10 < 5 );
        v11 = v7;
        for ( i = 0; i < 0x3C; ++i )
        {
LABEL_25:
          if ( *((_BYTE *)v11 + i + 2) == 0x5E )
          {
            *((_BYTE *)v11 + i + 2) = 0x20;
          }
        }
        v6 += 2;
        v7 = (unsigned __int16 *)((char *)v7 + 0x4B);
        v22 = (unsigned __int16 *)((char *)v22 + 0x4B);
        ++j;
      }
      v27 = v2;
      for ( j = 0; *v2 > j; ++j )
      {
        v18 = (int)v27;
        for ( k = 0; k < 5; ++k )
        {
          v19 = *(unsigned __int8 *)(v18 + 0x40);
          if ( v19 == 0xFF )
          {
            break;
          }
          v13 = 0;
          v14 = 0x4B * v19;
          while ( 1 )
          {
            v15 = (char *)v2 + v14 + v13;
            if ( (unsigned __int8)v15[0x45] == 0xFF )
            {
              break;
            }
            if ( ++v13 >= 4 )
            {
              goto LABEL_31;
            }
          }
          v16 = j;
          v15[0x46] = 0xFF;
          v15[0x45] = v16;
LABEL_31:
          ++v18;
        }
        v27 = (unsigned __int16 *)((char *)v27 + 0x4B);
      }
      fgetpos(fp, &pos);
      if ( pos >= v23 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\research.cpp", 0x86);
      }
      fclose(fp);
    }
    dword_105254 = 0xFFFFFFFF;
  }
  result = v2;
  v21 = v2 + 7;
  do
  {
    ++result;
    result[0xEA6] = 0xFFFF;
    result[0xEAD] = 0;
  }
  while ( result != v21 );
  return result;
}
// 105254: using guessed type int dword_105254;

//----- (000466FC) --------------------------------------------------------
int __fastcall sub_466FC(unsigned int a1)
{
  int v2; // esi
  int v3; // ecx
  _WORD *i; // esi
  int v5; // eax
  int v6; // ebx
  unsigned int j; // esi
  int result; // eax
  int v9; // eax
  int v10; // eax
  int v11; // ebx
  char v12; // dl
  int v13; // edx
  int v14; // eax
  __int64 v15[3]; // [esp+8h] [ebp-3Ch]
  int v16; // [esp+20h] [ebp-24h]
  int v17; // [esp+24h] [ebp-20h]
  int v18; // [esp+28h] [ebp-1Ch]

  v2 = 0;
  v18 = 0;
  while ( SHIWORD(dword_A3CF2) > v18 )
  {
    v2 += 2;
    ++v18;
    *(_WORD *)((char *)v15 + v2 + 6) = 0;
  }
  v3 = 0;
  for ( i = &unk_BB1B3; ; i = (_WORD *)((char *)i + 0x7B) )
  {
    v18 = v3;
    if ( SHIWORD(dword_CA1ED) <= v3 )
    {
      break;
    }
    v5 = *((unsigned __int8 *)i + 0x57);
    if ( v5 < SHIWORD(dword_A3CF2) )
    {
      if ( (_BYTE)v5 != (_BYTE)byte_104BEA && byte_A3D20 == 2 && (unsigned __int16)i[0x23] < 0xFu )
      {
        ++*((_WORD *)&v15[1] + v5);
      }
      *((_WORD *)&v15[1] + *((unsigned __int8 *)i + 0x57)) += i[0x23];
    }
    v3 = v18 + 1;
  }
  v6 = 0;
  for ( j = a1; ; j += 2 )
  {
    v18 = v6;
    result = SHIWORD(dword_A3CF2);
    if ( SHIWORD(dword_A3CF2) <= v6 )
    {
      break;
    }
    if ( *(unsigned __int16 *)(j + 0x1D4E) == 0xFFFF )
    {
      *(_WORD *)(j + 0x1D5C) = 0;
    }
    else
    {
      v9 = *((unsigned __int16 *)&v15[1] + v6);
      v17 = (unsigned __int16)v9;
      if ( (_WORD)v9 )
      {
        v16 = v9 + 1;
        v17 = (int)pow((double)(v9 + 1), 0.85);
      }
      v10 = 0x4B * *(unsigned __int16 *)(j + 0x1D4E);
      *(_WORD *)(j + 0x1D5C) += v17;
      if ( *(_WORD *)(j + 0x1D5C) >= *(_WORD *)(a1 + v10 + 0x3E) )
      {
        v11 = *(unsigned __int16 *)(j + 0x1D4E);
        v12 = 1 << v18;
        *(_BYTE *)(a1 + 0x4B * (unsigned __int16)v11 + 0x4A) |= 1 << v18;
        *(_BYTE *)(a1 + 0x4B * *(unsigned __int16 *)(j + 0x1D4E) + 0x4B) |= v12;
        v13 = v18;
        *(_WORD *)(j + 0x1D4E) = 0xFFFF;
        v14 = (unsigned __int8)byte_104BEA;
        *(_WORD *)(j + 0x1D5C) = 0;
        if ( v14 == v13 )
        {
          sub_55AEC((int)&V_Type3_stru_10AE70, 0, v11, 0);
          sub_468BC(a1);
        }
      }
    }
    v6 = v18 + 1;
  }
  return result;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D20: using guessed type char byte_A3D20;
// CA1ED: using guessed type int dword_CA1ED;

//----- (000468BC) --------------------------------------------------------
unsigned int __fastcall sub_468BC(unsigned int result)
{
  unsigned int v1; // esi

  v1 = result;
  if ( !*(_DWORD *)(result + 0x1D6E) )
  {
    result = sub_46900((char *)result, byte_104BEA);
    if ( result == 0xFFFFFFFF )
    {
      result = sub_55AEC((int)&V_Type3_stru_10AE70, 0x15, 0, 0);
      *(_DWORD *)(v1 + 0x1D6E) = 0xFFFFFFFF;
    }
  }
  return result;
}

//----- (00046900) --------------------------------------------------------
unsigned int __fastcall sub_46900(char *a1, char a2)
{
  int v2; // edx

  v2 = 1 << a2;
  if ( (v2 & a1[0x4A]) != 0 && (v2 & a1[0x95]) != 0 && (v2 & a1[0xE0]) != 0 && (v2 & a1[0x12B]) != 0 )
  {
    return 0xFFFFFFFF;
  }
  else
  {
    return 0;
  }
}

//----- (0004694C) --------------------------------------------------------
unsigned int __fastcall sub_4694C(int a1, unsigned __int16 a2, __int16 a3)
{
  char v4; // di
  unsigned int v5; // ebp
  int i; // eax

  v4 = a3;
  if ( a3 == 0xFFFFFFFF )
  {
    v4 = byte_104BEA;
  }
  v5 = 0xFFFFFFFF;
  if ( ((1 << v4) & *(char *)(a1 + 0x4B * a2 + 0x4A)) == 0 )
  {
    for ( i = 0; i < 5; ++i )
    {
      if ( *(unsigned __int8 *)(a1 + 0x4B * a2 + i + 0x40) == 0xFF )
      {
        break;
      }
      if ( ((1 << v4) & *(char *)(a1 + 0x4B * *(unsigned __int8 *)(a1 + 0x4B * a2 + i + 0x40) + 0x4A)) == 0 )
      {
        v5 = 0;
      }
    }
  }
  return v5;
}

//----- (000469F0) --------------------------------------------------------
int __fastcall sub_469F0(int a1, unsigned __int16 a2)
{
  int v3; // edx
  _WORD *v4; // eax
  int v5; // ebx
  int v7; // [esp+14h] [ebp-10h]

  if ( a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\research.cpp", 0x116);
  }
  v3 = 0;
  v4 = &unk_BB1B3;
  v7 = 0;
  while ( v3 < SHIWORD(dword_CA1ED) )
  {
    v5 = *((unsigned __int8 *)v4 + 0x57);
    if ( v5 == a2 )
    {
      LOWORD(v5) = v4[0x23];
      v7 += v5;
    }
    v4 = (_WORD *)((char *)v4 + 0x7B);
    ++v3;
  }
  if ( v7 )
  {
    return (int)pow((double)(v7 + 1), 0.85);
  }
  return v7;
}
// A3CF2: using guessed type int dword_A3CF2;
// CA1ED: using guessed type int dword_CA1ED;

//----- (00046A94) --------------------------------------------------------
__int16 __fastcall sub_46A94(unsigned __int16 *a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 *v4; // ebx
  unsigned __int16 v5; // dx
  int i; // eax
  unsigned __int16 v7; // cx
  int v8; // edi
  char *v9; // esi
  char v10; // dl
  __int16 v12[100]; // [esp+0h] [ebp-E0h]
  int v13; // [esp+C8h] [ebp-18h]
  int v14; // [esp+CCh] [ebp-14h]

  LOWORD(v14) = a2;
  v13 = a3;
  if ( a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\research.cpp", 0x12D);
  }
  v4 = a1;
  v5 = 0;
  for ( i = 0; i < *a1; ++i )
  {
    if ( i != a1[(unsigned __int16)v14 + 0xEA7] && ((1 << v14) & (char)v4[0x25]) == 0 )
    {
      v7 = v5++;
      v12[v7] = i;
    }
    v4 = (unsigned __int16 *)((char *)v4 + 0x4B);
  }
  if ( v5 )
  {
    v8 = (unsigned __int16)v12[rand() % v5];
    v9 = (char *)a1 + 0x4B * (unsigned __int16)v8;
    v10 = (1 << v14) | v9[0x4B];
    v9[0x4A] |= 1 << v14;
    v9[0x4B] = v10;
    LOWORD(i) = v14;
    if ( (unsigned __int16)v14 == (unsigned __int8)byte_104BEA )
    {
      LOWORD(i) = sub_55AEC((int)&V_Type3_stru_10AE70, 0x16, v8, v13);
    }
  }
  return i;
}
// A3CF2: using guessed type int dword_A3CF2;
// 46A94: using guessed type __int16 var_E0[100];

//----- (00046BB0) --------------------------------------------------------
int __fastcall sub_46BB0(_WORD *a1, unsigned int count, int a3)
{
  int result; // eax
  unsigned __int16 v5[3776]; // [esp+0h] [ebp-1D80h] BYREF

  if ( a3 != 0xFFFFFFFF )
  {
    return sub_1C098(count, (int)a1, 0x1D72u);
  }
  sub_46480(v5, 0);
  result = sub_1BF94((P_Type1)count, v5, 0x1D72u);
  qmemcpy(a1, v5, 0x1D70u);
  a1[0xEB8] = v5[0xEB8];
  return result;
}

//----- (00046C10) --------------------------------------------------------
unsigned __int16 *__fastcall sub_46C10(unsigned __int16 *a1)
{
  sub_46480(a1, 0);
  return a1;
}

//----- (00046C20) --------------------------------------------------------
int __fastcall sub_46C20(int a1, int a2, int a3)
{
  int result; // eax

  result = 0xFFFF;
  if ( a3 > 0 )
  {
    result = (a1 - a2 - 1) / a3 + 1;
  }
  if ( result < 1 )
  {
    return 1;
  }
  return result;
}

//----- (00046C48) --------------------------------------------------------
int __fastcall sub_46C48(int a1, char a2)
{
  void *v3; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  void *v8; // eax
  void *v9; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96004);
    operator delete[](v3);
    return a1;
  }
  else
  {
    v5 = a1 + 0x143;
    *(_DWORD *)(v5 - 0x9C) = off_96018;
    v6 = sub_1A9E0(v5);
    v7 = ((int (__fastcall *)(int, _DWORD, int))locret_1B66C)(v6 - 0x98, 0, a1);
    v8 = (void *)sub_2C848(v7 - 0xAB, 1);
    v9 = v8;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v8);
    }
    return (int)v9;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 96018: using guessed type int (*off_96018[5])();

//----- (00046CAC) --------------------------------------------------------
int __fastcall sub_46CAC(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  double v6; // st7
  int v7; // ebx
  int v8; // ebx
  FILE *v9; // eax
  FILE *v10; // esi
  int v11; // edx
  int v12; // ebx
  int v13; // eax
  int result; // eax
  int v15; // esi
  int v16; // edi
  int v17; // ecx
  int v18; // eax
  int i; // ebx
  int v20; // edx
  int v21; // edx
  int v22; // edx
  int v23; // ebp
  float *v24; // ebx
  int v25; // edi
  int v26; // ecx
  float v27; // [esp-4h] [ebp-124h]
  char v28[100]; // [esp+0h] [ebp-120h] BYREF
  char s[100]; // [esp+64h] [ebp-BCh] BYREF
  int v30; // [esp+C8h] [ebp-58h] BYREF
  int v31; // [esp+CCh] [ebp-54h] BYREF
  int v32; // [esp+D0h] [ebp-50h] BYREF
  int v33; // [esp+D4h] [ebp-4Ch]
  int v34; // [esp+D8h] [ebp-48h]
  int v35; // [esp+DCh] [ebp-44h]
  float *v36; // [esp+E0h] [ebp-40h]
  int v37; // [esp+E4h] [ebp-3Ch]
  int v38; // [esp+E8h] [ebp-38h]
  int v39; // [esp+ECh] [ebp-34h]
  int v40; // [esp+F0h] [ebp-30h]
  int v41; // [esp+F4h] [ebp-2Ch]
  int v42; // [esp+F8h] [ebp-28h]
  int v43; // [esp+FCh] [ebp-24h]
  float v44; // [esp+100h] [ebp-20h]
  int v45; // [esp+104h] [ebp-1Ch]

  v5 = a1 + 0x143;
  *(_WORD *)(v5 + 0x898) = 0xFFFF;
  v39 = 0;
  do
  {
    *(_DWORD *)v5 = 0;
    v6 = (double)v39;
    *(_DWORD *)(v5 + 8) = 0;
    v7 = v39;
    *(float *)(v5 + 4) = v6;
    v8 = v7 + 1;
    v5 += 0xC;
    v39 = v8;
  }
  while ( v8 < 0x64 );
  sub_1B808((_DWORD *)(a1 + 0xAB), 0, v8, a4, 0x41F00000, 0x3F800000, 0x47C35000, 0x140);
  *(_DWORD *)(a1 + 0xDF) = 0;
  *(_DWORD *)(a1 + 0xE3) = 0;
  *(_DWORD *)(a1 + 0xE7) = 0xC3160000;
  v9 = sub_1BB10("reswin.txt", 0);
  v10 = v9;
  if ( v9 )
  {
    fscanf(v9, "%d", &v30);
    if ( (unsigned __int16)word_105258 == v30 )
    {
      v11 = a1 + 0x143;
      v12 = 0;
      while ( v12 < (unsigned __int16)word_105258 )
      {
        v11 += 0xC;
        fscanf(v10, "%d %d %d", &v30, &v31, &v32);
        ++v12;
        v33 = v31;
        v13 = v32;
        *(float *)(v11 - 0xC) = (float)v30;
        v34 = v13;
        *(float *)(v11 - 8) = (float)v33;
        *(float *)(v11 - 4) = (float)v34;
      }
    }
    return fclose(v10);
  }
  else
  {
    if ( dword_105254 != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\reswin.cpp", 0x76);
    }
    memset(s, 0xFF, sizeof(s));
    v15 = 0;
    do
    {
      v16 = 0;
      v41 = 0xFFFFFFFF;
      v45 = 0;
      while ( v16 < (unsigned __int16)word_105258 )
      {
        if ( (unsigned __int8)s[v16] == 0xFF )
        {
          v17 = v45;
          v18 = 0;
          for ( i = 0; i < 5; ++i )
          {
            v20 = (unsigned __int8)byte_105298[v17];
            if ( v20 == 0xFF )
            {
              break;
            }
            v21 = (unsigned __int8)s[v20];
            if ( v21 == 0xFF )
            {
              v41 = 0;
              LOBYTE(v18) = 0xFF;
              break;
            }
            if ( v21 >= v18 )
            {
              v18 = v21 + 1;
              if ( v21 + 1 >= v15 )
              {
                v15 = v21 + 2;
              }
            }
            ++v17;
          }
          s[v16] = v18;
        }
        ++v16;
        v45 += 0x4B;
      }
    }
    while ( !v41 );
    memset(v28, 0, sizeof(v28));
    for ( result = 0; result < (unsigned __int16)word_105258; ++result )
    {
      v22 = (unsigned __int8)s[result];
      ++v28[v22];
    }
    v42 = 0;
    if ( v15 > 0 )
    {
      v38 = 0;
      v36 = (float *)(a1 + 0x143);
      v37 = 0xF0;
      do
      {
        v43 = 4;
        v44 = (float)v37;
        v23 = (unsigned __int8)v28[v42];
        if ( v42 % 2 && (unsigned __int8)v28[v42] > 2u )
        {
          --v23;
        }
        else if ( (unsigned __int8)v28[v42] > 1u )
        {
          v43 = 0x17;
        }
        v24 = v36;
        v25 = 0;
        v26 = 0;
        v40 = v38;
        while ( v26 < (unsigned __int16)word_105258 )
        {
          if ( (unsigned __int8)s[v26] == v42 )
          {
            v35 = 0xF * (v25 & 1) + v40;
            v24[1] = (float)v35;
            v24[2] = (float)v43;
            v27 = v44;
            *v24 = 0.0;
            sub_532AC(v24, v27);
            v35 = 0x168 / v23;
            ++v25;
            v43 = 0x17;
            v44 = (double)(0x168 / v23) + v44;
          }
          v24 += 3;
          ++v26;
        }
        result = v42 + 1;
        v37 += 0x1E;
        v38 += 0x1E;
        v42 = result;
      }
      while ( v15 > result );
    }
  }
  return result;
}
// 105254: using guessed type int dword_105254;
// 46CAC: using guessed type char s[100];
// 46CAC: using guessed type char var_120[100];

//----- (00047088) --------------------------------------------------------
int __fastcall sub_47088(int a1)
{
  int v1; // ebp
  int v2; // ecx
  int v3; // edi
  int v4; // esi
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int result; // eax
  int v10; // [esp+4h] [ebp-20h]
  int v11; // [esp+8h] [ebp-1Ch]

  v11 = 0xFFFF;
  v1 = new_x - *(_DWORD *)(a1 + 8);
  v2 = (unsigned __int16)word_105258 - 1;
  v10 = dword_D864C - *(_DWORD *)(a1 + 0xC);
  if ( v2 >= 0 )
  {
    v3 = a1 + 2 * v2;
    while ( 1 )
    {
      v4 = *(unsigned __int16 *)(v3 + 0x913);
      if ( sub_4694C((int)&word_105258, v4, 0xFFFFFFFF) )
      {
        v5 = a1 + 2 * v4;
        v6 = *(__int16 *)(v5 + 0x5F3);
        if ( v1 > v6 - 0x19 && v1 < v6 + 0x19 )
        {
          v7 = *(__int16 *)(v5 + 0x6BB);
          if ( v7 - 0x19 < v10 && v7 + 0x19 > v10 )
          {
            break;
          }
        }
      }
      --v2;
      v3 -= 2;
      if ( v2 < 0 )
      {
        goto LABEL_12;
      }
    }
    v11 = v4;
  }
LABEL_12:
  result = v11;
  if ( (_WORD)v11 != *(_WORD *)(a1 + 0x9DB) )
  {
    *(_WORD *)(a1 + 0x9DB) = v11;
    dword_106FD0 = 0xFFFFFFFF;
    dword_106FD4 = 0xFFFFFFFF;
  }
  return result;
}
// 106FD0: using guessed type int dword_106FD0;
// 106FD4: using guessed type int dword_106FD4;

//----- (00047224) --------------------------------------------------------
unsigned int __fastcall sub_47224(int a1, unsigned __int16 a2, int a3, unsigned int a4)
{
  int v8; // edx
  char v9; // cl
  int v10; // eax
  char v11; // bh
  int v12; // edx
  char v13; // cl
  int v14; // eax
  char v15; // ch
  int v16; // eax
  unsigned __int8 v17; // cl
  int v18; // eax
  int v19; // edx
  char v20; // cl
  int v21; // eax
  char v22; // bh
  int v23; // ebx
  int v24; // ebx
  int v25; // eax
  double v26; // st7
  int v27; // edx
  int v28; // edx
  __int16 v29; // ax
  float v31; // [esp+10h] [ebp-14h]
  float v32; // [esp+10h] [ebp-14h]
  float v33; // [esp+14h] [ebp-10h]
  int v34; // [esp+14h] [ebp-10h]

  if ( a2 < 6u )
  {
    if ( a2 < 2u )
    {
      if ( a2 != 1 )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFED8);
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDC);
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEBC[(unsigned __int8)byte_104BEA]);
      sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
      dword_106FD8 = 0;
      dword_106FCC = 0xFFFFFFFF;
      dword_106FD0 = 0xFFFFFFFF;
      *(_WORD *)(a1 + 0x9DB) = 0xFFFF;
      sub_2F424(a1, 1, a3, a4);
      sub_56400(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0x3A, 0, 0, 0);
      return 0;
    }
    if ( a2 <= 2u )
    {
      v8 = 0;
      v9 = 1 << byte_104BEA;
      v10 = 0;
      while ( v8 < (unsigned __int16)word_105258 )
      {
        v11 = byte_1052A3[v10];
        v10 += 0x4B;
        ++v8;
        *((_BYTE *)&word_105258 + v10) = ~v9 & v11;
      }
      sub_2F424(a1, a2, a3, a4);
      sub_564C0(&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 0xFFFFFFFF);
      return 0;
    }
    if ( a2 > 3u )
    {
      if ( !*(_DWORD *)(a1 + 0x35) )
      {
        return 0;
      }
      HIWORD(v28) = 0;
      sub_47088(a1);
      LOWORD(v28) = *(_WORD *)(a1 + 0x9DB);
      if ( (unsigned __int16)v28 == 0xFFFF
        || ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v28) >> 0x18)) != 0
        || !sub_4694C((int)&word_105258, v28, 0xFFFFFFFF) )
      {
        return 0;
      }
      sub_4FB90((int)&unk_10914C, 0);
      dword_106FD4 = 0xFFFFFFFF;
      v29 = *(_WORD *)(a1 + 0x9DB);
      dword_106FD0 = 0xFFFFFFFF;
      word_106FA6[(unsigned __int8)byte_104BEA] = v29;
      return 0;
    }
    if ( a4 < 0x2E )
    {
      if ( a4 < 0xD )
      {
        if ( a4 == 0xC && flt_12FC1C > dbl_92664 )
        {
          flt_12FC1C = flt_12FC1C * dbl_9266C;
          sub_47088(a1);
          return 0;
        }
        goto LABEL_60;
      }
      if ( a4 <= 0xD )
      {
        if ( flt_12FC1C < (double)flt_92658 )
        {
          flt_12FC1C = flt_12FC1C * dbl_9265C;
          sub_47088(a1);
          return 0;
        }
        goto LABEL_60;
      }
      if ( a4 >= 0x20 )
      {
        if ( a4 <= 0x20 )
        {
          if ( !dword_A0CFC )
          {
            goto LABEL_60;
          }
          v12 = 0;
          v13 = 1 << byte_104BEA;
          v14 = 0;
          while ( v12 < (unsigned __int16)word_105258 )
          {
            v15 = *((_BYTE *)&dword_10529F + v14 + 3);
            v14 += 0x4B;
            ++v12;
            *((_BYTE *)&dword_105254 + v14 + 3) = v13 | v15;
          }
        }
        else
        {
          if ( a4 != 0x21 || !dword_A0CFC )
          {
            goto LABEL_60;
          }
          v19 = 0;
          v20 = 1 << byte_104BEA;
          v21 = 0;
          while ( v19 < (unsigned __int16)word_105258 )
          {
            v22 = *((_BYTE *)&dword_10529F + v21 + 3);
            v21 += 0x4B;
            ++v19;
            *((_BYTE *)&dword_105254 + v21 + 3) = ~v20 & v22;
          }
        }
        v16 = (unsigned __int8)byte_104BEA;
        word_106FA6[(unsigned __int8)byte_104BEA] = 0xFFFF;
        word_106FB4[v16] = 0;
        sub_47088(a1);
        return 0;
      }
    }
    else
    {
      if ( a4 > 0x2E )
      {
        if ( a4 < 0x49 )
        {
          if ( a4 < 0x32 )
          {
            goto LABEL_60;
          }
          if ( a4 <= 0x32 )
          {
            dword_106FC2 = ~dword_106FC2;
            sub_5A320(0x14);
            dword_106FCC = 0xFFFFFFFF;
            dword_106FD4 = 0xFFFFFFFF;
            sub_47088(a1);
            return 0;
          }
          if ( a4 != 0x47 )
          {
            goto LABEL_60;
          }
        }
        else if ( a4 > 0x49 )
        {
          if ( a4 >= 0x4F && (a4 <= 0x4F || a4 == 0x51) )
          {
            v24 = *(_DWORD *)(a1 + 0xA7);
            *(_DWORD *)(a1 + 0xE3) = 0x49742400;
            (*(void (__fastcall **)(int, _DWORD))(v24 + 0xC))(a1, 0);
            sub_47088(a1);
            return 0;
          }
          goto LABEL_60;
        }
        v23 = *(_DWORD *)(a1 + 0xA7);
        *(_DWORD *)(a1 + 0xE3) = 0xC2C80000;
        (*(void (__fastcall **)(int, _DWORD))(v23 + 0xC))(a1, 0);
        sub_47088(a1);
        return 0;
      }
      if ( dword_A0CFC && (unsigned __int16)word_106FA6[(unsigned __int8)byte_104BEA] != 0xFFFF )
      {
        v17 = byte_104BEA;
        v18 = 0x4B * (unsigned __int16)word_106FA6[(unsigned __int8)byte_104BEA];
        *((_BYTE *)&dword_10529F + v18 + 3) |= 1 << byte_104BEA;
        word_106FA6[v17] = 0xFFFF;
        word_106FB4[v17] = 0;
        sub_47088(a1);
        return 0;
      }
    }
LABEL_60:
    sub_47088(a1);
    return 0;
  }
  if ( a2 <= 6u )
  {
    sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 8);
    sub_47088(a1);
    if ( (*(_DWORD *)(a1 + 0x3D) & *(_DWORD *)(a1 + 0x35) & *(_DWORD *)(a1 + 0x39)) == 0xFFFFFFFF )
    {
      (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0xC))();
    }
    return 0xFFFFFFFF;
  }
  if ( a2 < 0x32u )
  {
    if ( a2 <= 7u )
    {
      sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
      sub_47088(a1);
      if ( (*(_DWORD *)(a1 + 0x3D) & *(_DWORD *)(a1 + 0x35) & *(_DWORD *)(a1 + 0x39)) == 0xFFFFFFFF )
      {
        (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0x10))();
      }
      return 0xFFFFFFFF;
    }
    if ( a2 != 8 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    goto LABEL_60;
  }
  if ( a2 <= 0x35u )
  {
    if ( a2 == 0x32 )
    {
      if ( (dword_106FD8 & 4) != 0 )
      {
        if ( (dword_106FD8 & 8) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xF7;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFB;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 & 0xF3 | 4;
      }
    }
    if ( a2 == 0x33 )
    {
      if ( (dword_106FD8 & 4) != 0 )
      {
        if ( (dword_106FD8 & 8) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFB;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 | 8;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 | 0xC;
      }
    }
    if ( a2 == 0x34 )
    {
      if ( (dword_106FD8 & 1) != 0 )
      {
        if ( (dword_106FD8 & 2) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFD;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFE;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 & 0xFC | 1;
      }
    }
    if ( a2 == 0x35 )
    {
      if ( (dword_106FD8 & 1) != 0 )
      {
        if ( (dword_106FD8 & 2) != 0 )
        {
          LOBYTE(dword_106FD8) = dword_106FD8 & 0xFE;
        }
        else
        {
          LOBYTE(dword_106FD8) = dword_106FD8 | 2;
        }
      }
      else
      {
        LOBYTE(dword_106FD8) = dword_106FD8 | 3;
      }
    }
    if ( a3 != 4 )
    {
      return 0;
    }
    v25 = 4;
    if ( a2 == 0x34 || a2 == 0x35 )
    {
      v25 = 1;
    }
    sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 1, 0x38, v25, 0);
    return 0;
  }
  else
  {
    if ( a2 < 0x38u )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( a2 > 0x38u )
    {
      if ( a2 != 0x3A )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      if ( (dword_106FD8 & 4) != 0 )
      {
        v33 = 3.0;
        if ( (dword_106FD8 & 8) != 0 )
        {
          v33 = -3.0;
        }
        *(float *)&v34 = v33 * flt_12FC1C;
        sub_53564((float *)(a1 + 0x11F), a2, a3, 0xFFFFFFFF, v34);
        dword_106FD4 = 0xFFFFFFFF;
      }
      if ( (dword_106FD8 & 1) != 0 )
      {
        v31 = -2.0;
        if ( (dword_106FD8 & 2) != 0 )
        {
          v31 = 2.0;
        }
        v32 = v31 * flt_12FC1C;
        v26 = *(float *)(a1 + 0xE3) + v32;
        dword_106FD4 = 0xFFFFFFFF;
        *(float *)(a1 + 0xE3) = v26;
      }
      if ( dword_106FD4 == 0xFFFFFFFF )
      {
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
        return 0;
      }
      return 0;
    }
    v27 = *(_DWORD *)(a1 + 0x41);
    dword_106FD8 &= ~a3;
    sub_567BC((int)&V_Type3_stru_10AE70, v27, 0xFFFFFFFF);
    return 0;
  }
}
// 92658: using guessed type float flt_92658;
// 9265C: using guessed type double dbl_9265C;
// 92664: using guessed type double dbl_92664;
// 9266C: using guessed type double dbl_9266C;
// A0CFC: using guessed type int dword_A0CFC;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFED8: using guessed type __int16 word_FFED8;
// FFEDC: using guessed type __int16 word_FFEDC;
// FFEDE: using guessed type __int16 word_FFEDE;
// 105254: using guessed type int dword_105254;
// 10529F: using guessed type int dword_10529F;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];
// 106FC2: using guessed type int dword_106FC2;
// 106FCC: using guessed type int dword_106FCC;
// 106FD0: using guessed type int dword_106FD0;
// 106FD4: using guessed type int dword_106FD4;
// 106FD8: using guessed type int dword_106FD8;
// 12FC1C: using guessed type float flt_12FC1C;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00047A64) --------------------------------------------------------
int __fastcall sub_47A64(const void *a1, const void *a2)
{
  unsigned __int16 v2; // si
  BOOL v3; // edx

  v2 = *(_WORD *)a2;
  v3 = *(float *)(dword_106FDC + 4 * *(unsigned __int16 *)a2) > (double)*(float *)(dword_106FDC
                                                                                 + 4 * *(unsigned __int16 *)a1);
  if ( *(float *)(dword_106FDC + 4 * v2) < (double)*(float *)(dword_106FDC + 4 * *(unsigned __int16 *)a1) )
  {
    return 0xFFFFFFFF;
  }
  return v3;
}
// 106FDC: using guessed type int dword_106FDC;

//----- (00047ABC) --------------------------------------------------------
void __fastcall sub_47ABC(int a1)
{
  T_Type5 *v2; // esi
  int v3; // ecx
  int v4; // edx
  int v5; // ebx
  float v6; // eax
  float *v7; // ecx
  int v8; // esi
  int v9; // edi
  int v10; // ebx
  int v11; // edx
  int v12; // eax
  char v13; // bl
  unsigned __int16 v14; // dx
  int v15; // edx
  int v16; // eax
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  __int16 v20; // ax
  void *v21; // eax
  LONG v22; // esi
  unsigned __int16 v23; // dx
  int v24; // eax
  void *v25; // eax
  int v26; // ebx
  char *sub_1CEA8; // eax
  int v28; // esi
  void *v29; // eax
  void *v30; // eax
  LONG v31; // ebx
  unsigned __int16 v32; // di
  void *v33; // eax
  int v34; // edi
  int v35; // esi
  int v36; // eax
  int v37; // edx
  int v38; // ebx
  int v39; // eax
  int v40; // edx
  char *v41; // edi
  char *v42; // esi
  char v43; // al
  char v44; // al
  int v45; // eax
  char *v46; // eax
  int v47; // esi
  char *v48; // eax
  char *v49; // eax
  int v50; // esi
  unsigned __int16 v51; // dx
  unsigned __int16 v52; // ax
  LONG v53; // ebp
  void *v54; // eax
  void *v55; // eax
  const char *v56; // edi
  char *v57; // eax
  int v58; // esi
  int v59; // ebp
  void *v60; // esi
  char *v61; // eax
  unsigned __int16 v62; // di
  __int16 v63; // dx
  char *v64; // eax
  int v65; // esi
  unsigned __int16 v66; // dx
  void *v67; // eax
  void *v68; // eax
  int v69; // esi
  char *v70; // eax
  char *v71; // eax
  LONG v72; // [esp-20h] [ebp-170h]
  LONG v73; // [esp-1Ch] [ebp-16Ch]
  LONG v74; // [esp-1Ch] [ebp-16Ch]
  LONG v75; // [esp-1Ch] [ebp-16Ch]
  LONG v76; // [esp-18h] [ebp-168h]
  LONG v77; // [esp-18h] [ebp-168h]
  LONG v78; // [esp-18h] [ebp-168h]
  LONG v79; // [esp-Ch] [ebp-15Ch]
  __int16 v80; // [esp-Ch] [ebp-15Ch]
  __int16 v81; // [esp-Ch] [ebp-15Ch]
  LONG v82; // [esp-Ch] [ebp-15Ch]
  __int16 v83; // [esp-Ch] [ebp-15Ch]
  __int16 v84; // [esp-Ch] [ebp-15Ch]
  __int16 v85; // [esp-Ch] [ebp-15Ch]
  LONG v86; // [esp-8h] [ebp-158h]
  LONG v87; // [esp-8h] [ebp-158h]
  LONG v88; // [esp-8h] [ebp-158h]
  LONG v89; // [esp-8h] [ebp-158h]
  LONG v90; // [esp-8h] [ebp-158h]
  char *v91; // [esp-8h] [ebp-158h]
  int v92; // [esp-4h] [ebp-154h]
  UBYTE *v93; // [esp-4h] [ebp-154h]
  LONG v94; // [esp-4h] [ebp-154h]
  LONG v95; // [esp-4h] [ebp-154h]
  LONG v96; // [esp-4h] [ebp-154h]
  char *v97; // [esp-4h] [ebp-154h]
  char *v98; // [esp-4h] [ebp-154h]
  char v99[100]; // [esp+0h] [ebp-150h]
  char s[80]; // [esp+64h] [ebp-ECh] BYREF
  PANE v101; // [esp+B4h] [ebp-9Ch] BYREF
  PANE v102; // [esp+C8h] [ebp-88h] BYREF
  int v103[2]; // [esp+DCh] [ebp-74h] BYREF
  int v104; // [esp+E4h] [ebp-6Ch]
  LONG hotX; // [esp+E8h] [ebp-68h] BYREF
  LONG hotY; // [esp+ECh] [ebp-64h] BYREF
  float v107; // [esp+F0h] [ebp-60h]
  int v108; // [esp+F4h] [ebp-5Ch]
  int a2; // [esp+F8h] [ebp-58h]
  int v110; // [esp+FCh] [ebp-54h]
  int v111; // [esp+100h] [ebp-50h]
  float *v112; // [esp+104h] [ebp-4Ch]
  float v113; // [esp+108h] [ebp-48h]
  LONG x_scale; // [esp+10Ch] [ebp-44h]
  int v115; // [esp+110h] [ebp-40h]
  int v116; // [esp+114h] [ebp-3Ch]
  int v117; // [esp+118h] [ebp-38h]
  int v118; // [esp+11Ch] [ebp-34h]
  int v119; // [esp+120h] [ebp-30h]
  int v120; // [esp+124h] [ebp-2Ch]
  LONG v121; // [esp+128h] [ebp-28h]
  int v122; // [esp+12Ch] [ebp-24h]
  PANE *pane; // [esp+130h] [ebp-20h]
  int v124; // [esp+134h] [ebp-1Ch]
  LONG shape_number; // [esp+138h] [ebp-18h]

  v101 = *(PANE *)(a1 + 4);
  v2 = (T_Type5 *)(a1 + 4);
  VFX_pane_wipe((PANE *)(a1 + 4), 0);
  sub_552CC(&V_Type3_stru_10AE70, v2);
  v3 = a1;
  v4 = 0;
  v113 = *(float *)(a1 + 0x147);
  v107 = v113;
  for ( a2 = 0; ; ++a2 )
  {
    v5 = a2;
    if ( (unsigned __int16)word_105258 <= a2 )
    {
      break;
    }
    v4 = (unsigned __int16)a2;
    if ( sub_4694C((int)&word_105258, a2, 0xFFFFFFFF) )
    {
      if ( *(float *)(v3 + 0x147) < (double)v107 )
      {
        v107 = *(float *)(v3 + 0x147);
      }
      if ( *(float *)(v3 + 0x147) > (double)v113 )
      {
        v113 = *(float *)(v3 + 0x147);
      }
    }
    v3 += 0xC;
  }
  if ( *(float *)(a1 + 0xE3) >= (double)v107 )
  {
    if ( *(float *)(a1 + 0xE3) <= (double)v113 )
    {
      goto LABEL_14;
    }
    v6 = v113;
  }
  else
  {
    v6 = v107;
  }
  *(float *)(a1 + 0xE3) = v6;
LABEL_14:
  sub_1B864(a1 + 0xAB, v4, v5, v3);
  a2 = 0;
  v7 = (float *)(a1 + 0x143);
  v8 = a1 + 0x6BB;
  v9 = a1 + 0x5F3;
  v112 = (float *)(a1 + 0xEB);
  v117 = a1;
  v115 = a1;
  while ( (unsigned __int16)word_105258 > a2 )
  {
    v103[0] = 0;
    v103[1] = 0;
    v104 = 0;
    sub_53384(v7, v112, (float *)v103);
    v92 = v8;
    v10 = a2;
    v7 += 3;
    v8 += 2;
    *(_DWORD *)(v115 + 0x783) = v104;
    v11 = v117;
    sub_533D4((float *)v103, *(float *)(a1 + 0xD3), 0xEB, 0xF0, v9, v92);
    *(_WORD *)(v11 + 0x913) = a2;
    v9 += 2;
    a2 = v10 + 1;
    v117 = v11 + 2;
    v115 += 4;
  }
  dword_106FDC = a1 + 0x783;
  qsort((void *)(a1 + 0x913), (unsigned __int16)word_105258, 2u, sub_47A64);
  v12 = a1;
  a2 = 0;
  while ( (unsigned __int16)word_105258 > a2 )
  {
    v13 = a2;
    v14 = *(_WORD *)(v12 + 0x913);
    v12 += 2;
    ++a2;
    v99[v14] = v13;
  }
  v124 = (unsigned __int16)word_106FA6[(unsigned __int8)byte_104BEA];
  a2 = 0;
  pane = (PANE *)(a1 + 4);
  v116 = a1;
  while ( (unsigned __int16)word_105258 > a2 )
  {
    v121 = *(unsigned __int16 *)(v116 + 0x913);
    if ( sub_4694C((int)&word_105258, v121, 0xFFFFFFFF) )
    {
      v118 = (int)((*(float *)(a1 + 4 * v121 + 0x783) + *(float *)(a1 + 0xE7)) * flt_92697);
      if ( v118 >= (int)0xFFFFFFFD )
      {
        if ( v118 > 3 )
        {
          v118 = 3;
        }
      }
      else
      {
        v118 = 0xFFFFFFFD;
      }
      v93 = (UBYTE *)(((v118 + 3) << 8) + 0x100 + dword_D8D8F);
      v118 += 3;
      VFX_shape_lookaside(v93);
      v119 = 0;
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v121) >> 0x18)) != 0 )
      {
        v119 = 0x14;
      }
      else if ( (unsigned __int16)v124 == v121 )
      {
        v15 = v121 ^ (unsigned __int16)v124;
        LOBYTE(v15) = byte_104BEA;
        v16 = 0x12 * (unsigned __int16)word_106FB4[v15] / *(unsigned __int16 *)((char *)&word_105296 + 0x4B * v121) + 2;
        v119 = v16;
        if ( v16 >= (int)0xFFFFFFEF )
        {
          if ( v16 > 0x11 )
          {
            v119 = 0x11;
          }
        }
        else
        {
          v119 = 0xFFFFFFEF;
        }
      }
      v17 = 0x4B * v121;
      v120 = 2 * v121 + a1;
      v18 = 0;
      v122 = 4 * v121 + a1;
      while ( 1 )
      {
        v19 = (unsigned __int8)byte_105298[v17];
        if ( v19 == 0xFF )
        {
          break;
        }
        if ( sub_4694C((int)&word_105258, (unsigned __int8)byte_105298[v17], 0xFFFFFFFF) )
        {
          v110 = (int)(((*(float *)(v122 + 0x783) + *(float *)(a1 + 4 * v19 + 0x783)) * flt_9269B + *(float *)(a1 + 0xE7))
                     * flt_92697);
          if ( v110 <= 3 )
          {
            if ( v110 < (int)0xFFFFFFFD )
            {
              v110 = 0xFFFFFFFD;
            }
          }
          else
          {
            v110 = 3;
          }
          v20 = 0x6B - v110;
          if ( v19 == *(unsigned __int16 *)(a1 + 0x9DB) )
          {
            v20 = 0xF3;
          }
          VFX_line_draw(
            pane,
            *(__int16 *)(v120 + 0x5F3),
            *(__int16 *)(v120 + 0x6BB) - 0x1B,
            *(__int16 *)(a1 + 2 * v19 + 0x5F3),
            *(__int16 *)(a1 + 2 * v19 + 0x6BB) + 0x1B,
            0,
            v20);
          ++v18;
          ++v17;
          if ( v18 >= 5 )
          {
            break;
          }
        }
        else
        {
          ++v18;
          ++v17;
          if ( v18 >= 5 )
          {
            break;
          }
        }
      }
      if ( v119 )
      {
        v119 = (v119 << 0x10) / 0x14;
        v86 = v119;
        v79 = v119;
        v76 = *(__int16 *)(a1 + 2 * v121 + 0x6BB);
        v73 = *(__int16 *)(a1 + 2 * v121 + 0x5F3);
        v72 = v121;
        v21 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
        VFX_shape_transform(pane, v21, v72, v73, v76, buffer, 0, v79, v86, 1);
      }
      v22 = 1;
      if ( (unsigned __int16)v124 == v121
        && ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v121) >> 0x18)) == 0 )
      {
        v22 = 0;
      }
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v121 + 1) >> 0x18)) != 0 )
      {
        v22 = 3;
      }
      if ( *(unsigned __int16 *)(a1 + 0x9DB) == v121 )
      {
        v22 = 2;
      }
      v23 = sub_1B270((int)dword_12FC20, "data\\resring.shp", 0xFFFFFFFF);
      v24 = a1 + 2 * v121;
      v94 = *(__int16 *)(v24 + 0x6BB);
      v87 = *(__int16 *)(v24 + 0x5F3);
      v25 = (void *)sub_1B084((unsigned int)dword_12FC20, v23);
      if ( v22 == 2 )
      {
        VFX_shape_draw(pane, v25, 2, v87, v94);
      }
      else
      {
        VFX_shape_translate_draw(pane, v25, v22, v87, v94);
      }
    }
    v116 += 2;
    ++a2;
  }
  v26 = dword_106FD0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *(_DWORD *)(a1 + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = *(_DWORD *)(a1 + 8);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *(_DWORD *)(a1 + 0xC);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *(_DWORD *)(a1 + 0x10);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = *(_DWORD *)(a1 + 0x14);
  if ( v26 == 0xFFFFFFFF )
  {
    v101.y1 = 0x1AA;
    v101.x0 = 0x1E5;
    v101.y0 = 7;
    v101.x1 = 0x278;
    VFX_pane_wipe(&v101, 0);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&v101);
    shape_number = 0xFFFF;
    if ( (unsigned __int16)v124 != 0xFFFF )
    {
      shape_number = (unsigned __int16)v124;
    }
    if ( *(unsigned __int16 *)(a1 + 0x9DB) != 0xFFFF )
    {
      shape_number = *(unsigned __int16 *)(a1 + 0x9DB);
    }
    if ( (unsigned __int16)shape_number != 0xFFFF )
    {
      *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = v101;
      v108 = 0xFFFFFFFF;
      v102 = v101;
      if ( (_WORD)shape_number == (_WORD)v124 )
      {
        if ( (_WORD)shape_number != *(_WORD *)(a1 + 0x9DB) )
        {
          v108 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
        }
        v80 = v108;
        sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7A);// 122: "Current Project:"
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0xA, sub_1CEA8, 2, v80, 0xFFFFFFFF, 0x82);
      }
      v28 = (unsigned __int16)shape_number;
      v111 = 0x46;
      v102.y1 = 0x78;
      v29 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
      sub_2BC40(&v102, v29, (unsigned __int16)v28, &hotX, &hotY);
      v95 = hotY;
      v88 = hotX;
      v30 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEDE);
      VFX_shape_draw(&v102, v30, (unsigned __int16)v28, v88, v95);
      v31 = 1;
      v32 = sub_1B270((int)dword_12FC20, "data\\resring.shp", 0xFFFFFFFF);
      if ( (_WORD)v28 == (_WORD)v124
        && ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * v28) >> 0x18)) == 0 )
      {
        v31 = 0;
      }
      if ( ((1 << byte_104BEA) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int16)shape_number + 1) >> 0x18)) != 0 )
      {
        v31 = 3;
      }
      if ( (_WORD)shape_number == *(_WORD *)(a1 + 0x9DB) )
      {
        v31 = 2;
      }
      v96 = hotY;
      v89 = hotX;
      v33 = (void *)sub_1B084((unsigned int)dword_12FC20, v32);
      VFX_shape_draw(&v102, v33, v31, v89, v96);
      v35 = 0x4B * (unsigned __int16)shape_number;
      v111 += 0x19;
      v34 = v111;
      v36 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v111, &byte_10525A[v35], 2, v108, 0xFFFFFFFF, 0x82);
      v37 = *(int *)((char *)&dword_10529F + v35) >> 0x18;
      v111 = v34 + v36;
      if ( ((1 << byte_104BEA) & v37) == 0 )
      {
        v38 = sub_469F0((int)&word_105258, (unsigned __int8)byte_104BEA);
        v39 = sub_46C20(
                *(unsigned __int16 *)((char *)&word_105296 + v35),
                (unsigned __int16)word_106FB4[(unsigned __int8)byte_104BEA],
                v38);
        v40 = v39;
        if ( v39 == 0xFFFF )
        {
          v41 = s;
          v42 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7B);// 123: "(No Progress)"
          do
          {
            v43 = *v42;
            *v41 = *v42;
            if ( !v43 )
            {
              break;
            }
            v44 = v42[1];
            v42 += 2;
            v41[1] = v44;
            v41 += 2;
          }
          while ( v44 );
        }
        else
        {
          if ( v39 == 1 )
          {
            v45 = 0x1C;                                // 28: ""
          }
          else
          {
            v45 = 0x1D;                                // 29: "s"
          }
          v97 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v45);
          v46 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7C);// 124: "(%d day%s)"
          sprintf(s, v46, v40, v97);
        }
        sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v111, s, 2, v108, 0xFFFFFFFF, 0x82);
      }
      v47 = 0x8E;
      for ( a2 = 0; a2 < 0x27; ++a2 )
      {
        if ( (unsigned __int8)byte_103FA1[0x28 * a2] == (unsigned __int16)shape_number )
        {
          if ( v47 == 0x8E )
          {
            v81 = v108;
            v48 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7D);// 125: "Allows"
            v47 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x8E, v48, 2, v81, 0xFFFFFFFF, 0x82) + 0x98;
          }
          v49 = (char *)&dword_103F9A[0xA * a2 + 3];
          if ( (_BYTE)a2 == 0x17 )
          {
            v49 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7E);// 126: "Ships: Small and Medium Hulls"
          }
          v50 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v47, v49, 2, v108, 0xFFFFFFFF, 0x82) + v47;
          x_scale = (LONG)sub_10000;
          v102.y0 = v50 + 1;
          v51 = word_FFEDC;
          v102.y1 = v50 + 0x48;
          v52 = a2;
          if ( (_BYTE)a2 == 0x17 )
          {
            x_scale = 0x8000;
            v51 = word_FFEBC[(unsigned __int8)byte_104BEA];
            v52 = 0;
          }
          v53 = v52;
          v54 = (void *)sub_1B084((unsigned int)dword_12FC20, v51);
          sub_2BC40(&v102, v54, v53, &hotX, &hotY);
          v90 = x_scale;
          v82 = x_scale;
          v77 = hotY;
          v74 = hotX;
          v55 = (void *)sub_1B084((unsigned int)dword_12FC20, v51);
          v47 = v50 + 0x48;
          VFX_shape_transform(&v102, v55, v53, v74, v77, buffer, 0, v82, v90, 0);
        }
      }
      v56 = (const char *)&unk_107020;
      for ( a2 = 0; a2 < 0x4C; ++a2 )
      {
        if ( (unsigned __int8)byte_107055[0x6A * a2] == (unsigned __int16)shape_number )
        {
          if ( v47 == 0x8E )
          {
            v83 = v108;
            v57 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7D);// 125: "Allows"
            v47 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x8E, v57, 2, v83, 0xFFFFFFFF, 0x82) + 0x98;
          }
          v58 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v47, v56, 2, v108, 0xFFFFFFFF, 0x82) + v47;
          v102.y0 = v58 + 1;
          v59 = v58 + 0x48;
          v102.y1 = v58 + 0x48;
          v60 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFED8);
          sub_2BC40(&v102, v60, a2, &hotX, &hotY);
          VFX_shape_draw(&v102, v60, a2, hotX, hotY);
          v47 = v59;
        }
        v56 += 0x6A;
      }
      if ( (unsigned __int16)shape_number == 0x13 || (unsigned __int16)shape_number == 0x1F )
      {
        if ( v47 == 0x8E )
        {
          v84 = v108;
          v61 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7D);// 125: "Allows"
          v47 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0x8E, v61, 2, v84, 0xFFFFFFFF, 0x82) + 0x98;
        }
        v62 = 2;
        v63 = shape_number;
        v64 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x7F);// 127: "Large Ship Hull"
        if ( v63 == 0x1F )
        {
          v62 = 3;
          v64 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x80);// 128: "Gigantic Ship Hull"
        }
        v65 = sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v47, v64, 2, v108, 0xFFFFFFFF, 0x82) + v47;
        v102.y0 = v65 + 1;
        v66 = word_FFEBC[(unsigned __int8)byte_104BEA];
        v102.y1 = v65 + 0x48;
        v67 = (void *)sub_1B084((unsigned int)dword_12FC20, v66);
        sub_2BC40(&v102, v67, v62, &hotX, &hotY);
        v78 = hotY;
        v75 = hotX;
        v68 = (void *)sub_1B084((unsigned int)dword_12FC20, v66);
        VFX_shape_transform(&v102, v68, v62, v75, v78, buffer, 0, 0x8000, 0x8000, 0);
      }
    }
    dword_106FD0 = 0;
  }
  v69 = dword_106FCC;
  if ( dword_106FCC == 0xFFFFFFFF )
  {
    v101.x0 = 7;
    v101.x1 = 0x1DC;
    v101.y1 = 0x25;
    v101.y0 = 7;
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&v101);
    sub_53E38((P_Type5)&v101, 3, 3, (unsigned __int8)byte_104BEA);
    v70 = (char *)&unk_92696;
    if ( dword_106FC2 == v69 )
    {
      v70 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x81);  // 129: "(Self Managed)"
    }
    v98 = v70;
    v91 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
    v71 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x82);    // 130: "%s Knowledge %s"
    sprintf(s, v71, v91, v98);
    v85 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = v101;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, s, 3, v85, 0xFF, 0);
    dword_106FCC = 0;
  }
  dword_106FD4 = 0;
}
// 10000: using guessed type void __noreturn sub_10000();
// 92697: using guessed type float flt_92697;
// 9269B: using guessed type float flt_9269B;
// D8D8F: using guessed type int dword_D8D8F;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEBC: using guessed type __int16 word_FFEBC[7];
// FFED8: using guessed type __int16 word_FFED8;
// FFEDC: using guessed type __int16 word_FFEDC;
// FFEDE: using guessed type __int16 word_FFEDE;
// 103F9A: using guessed type int dword_103F9A[];
// 105296: using guessed type __int16 word_105296;
// 10529F: using guessed type int dword_10529F;
// 106FA6: using guessed type __int16 word_106FA6[7];
// 106FB4: using guessed type __int16 word_106FB4[7];
// 106FC2: using guessed type int dword_106FC2;
// 106FCC: using guessed type int dword_106FCC;
// 106FD0: using guessed type int dword_106FD0;
// 106FD4: using guessed type int dword_106FD4;
// 106FDC: using guessed type int dword_106FDC;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 47ABC: using guessed type char var_150[100];

//----- (00048B14) --------------------------------------------------------
int __fastcall sub_48B14(int a1, unsigned int count, int a3)
{
  void *v5; // edx

  v5 = (void *)(a1 + 0xAB);
  if ( a3 == 0xFFFFFFFF )
  {
    return sub_1BF94((P_Type1)count, v5, 0x98u);
  }
  else
  {
    return sub_1C098(count, (int)v5, 0x98u);
  }
}

//----- (00048B40) --------------------------------------------------------
int __fastcall sub_48B40(T_TypeA2 *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // eax
  int v5; // edx

  sub_2C830(a1);
  v4 = sub_1B4F0(a1[1].a.a);
  v5 = _wcpp_2_ctor_array_(v4 + 0x26, 0x64, &unk_959D8) - 0x143;
  *(_DWORD *)(v5 + 0xA7) = off_96018;
  sub_46CAC(v5, v5, (int)&unk_959D8, a4);
  return v5;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 96018: using guessed type int (*off_96018[5])();

//----- (00048B90) --------------------------------------------------------
_DWORD *__fastcall sub_48B90(_DWORD *a1)
{
  a1[0x1B] = 0;
  a1[0x1C] = 0;
  a1[0x1D] = 0;
  a1[0x1E] = 0;
  a1[0x1F] = 0;
  a1[0x20] = 0;
  *(_DWORD *)((char *)a1 + 0x9E) = 0;
  *(_DWORD *)((char *)a1 + 0xA2) = 0;
  *(_DWORD *)((char *)a1 + 0xA6) = 0;
  sub_48C5C((int)a1, 0);
  return a1;
}

//----- (00048C5C) --------------------------------------------------------
int __fastcall sub_48C5C(int a1, char a2)
{
  sub_48EAC(a1);
  return sub_49148(a1, a2);
}

//----- (00048C84) --------------------------------------------------------
int sub_48C84()
{
  FILE *v0; // esi
  unsigned int v1; // ecx
  char *v2; // edx
  int i; // ebp
  signed int v4; // ebx
  unsigned int v5; // kr04_4
  char *v6; // eax
  int v7; // eax
  char v9[200]; // [esp+0h] [ebp-104h] BYREF
  char v10; // [esp+C8h] [ebp-3Ch] BYREF
  int v11; // [esp+CCh] [ebp-38h] BYREF
  int v12; // [esp+D0h] [ebp-34h] BYREF
  int v13; // [esp+D4h] [ebp-30h] BYREF
  int v14; // [esp+D8h] [ebp-2Ch] BYREF
  int v15; // [esp+DCh] [ebp-28h] BYREF
  int v16; // [esp+E0h] [ebp-24h] BYREF
  int v17; // [esp+E4h] [ebp-20h] BYREF
  int v18; // [esp+E8h] [ebp-1Ch] BYREF

  v0 = sub_1BB10("gizmos.txt", 0);
  if ( !v0 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0xBE);
  }
  v1 = 0;
  do
  {
    fgets(v9, 0xC8, v0);
    if ( v9[0] == 0x23 )
    {
      v1 = 0xFFFFFFFF;
    }
  }
  while ( !v1 );
  v2 = (char *)&unk_107020;
  for ( i = 0; i < 0x4C; ++i )
  {
    fscanf(v0, "%s", v2);
    v4 = 0;
    v5 = strlen(v2) + 1;
    if ( (int)(v5 - 1) > 0 )
    {
      v6 = v2;
      do
      {
        if ( *v6 == 0x5E )
        {
          *v6 = 0x20;
        }
        ++v4;
        ++v6;
      }
      while ( v4 < (int)(v5 - 1) );
    }
    fscanf(v0, "%d %d %d %d %d %d %d %d %d", &v10, &v11, &v12, &v13, &v14, &v15, &v16, &v17, &v18);
    v2[0x32] = v10;
    *(_DWORD *)(v2 + 0x36) = v11;
    *(_DWORD *)(v2 + 0x3A) = v12;
    *(_DWORD *)(v2 + 0x3E) = v13;
    *(_DWORD *)(v2 + 0x42) = v14;
    *(_DWORD *)(v2 + 0x46) = v15;
    *(_DWORD *)(v2 + 0x4A) = v16;
    *(_DWORD *)(v2 + 0x4E) = v17;
    v2[0x35] = v18;
    fscanf(v0, "%d", &v18);
    *(_WORD *)(v2 + 0x33) = 0;
    while ( v18 != 0xFF )
    {
      LOWORD(v4) = *(_WORD *)(v2 + 0x33);
      v4 |= 1 << v18;
      *(_WORD *)(v2 + 0x33) = v4;
      fscanf(v0, "%d", &v18);
    }
    *(_DWORD *)(v2 + 0x66) = 0;
    v7 = *(_DWORD *)(v2 + 0x66);
    *(_DWORD *)(v2 + 0x62) = v7;
    *(_DWORD *)(v2 + 0x5E) = v7;
    *(_DWORD *)(v2 + 0x5A) = v7;
    *(_DWORD *)(v2 + 0x56) = v7;
    *(_DWORD *)(v2 + 0x52) = v7;
    switch ( v2[0x32] )
    {
      case 0:
        *(_DWORD *)(v2 + 0x52) = *(_DWORD *)(v2 + 0x3E);
        break;
      case 1:
        *(_DWORD *)(v2 + 0x56) = *(_DWORD *)(v2 + 0x3E);
        break;
      case 2:
        *(_DWORD *)(v2 + 0x5E) = *(_DWORD *)(v2 + 0x3E);
        break;
      case 3:
        *(_DWORD *)(v2 + 0x62) = *(_DWORD *)(v2 + 0x3E);
        break;
      case 4:
        *(_DWORD *)(v2 + 0x66) = *(_DWORD *)(v2 + 0x36);
        break;
      default:
        break;
    }
    v2 += 0x6A;
  }
  return fclose(v0);
}
// 48C84: using guessed type char var_104[200];

//----- (00048EAC) --------------------------------------------------------
int __fastcall sub_48EAC(int result)
{
  int v1; // ebx
  char *v2; // ebx
  int v3; // ecx
  char *v4; // edi
  char *sub_1CEA8; // esi
  char v6; // al
  char v7; // al
  int v8; // ebp
  char v9; // dl
  int v10; // esi
  int v11; // ebx
  char v12; // di
  int v13; // ecx
  char v14; // dl
  int v15; // ebp
  int v16; // esi
  double v17; // st7
  int v18; // ebx
  int v19; // [esp+0h] [ebp-3Ch]
  int v20; // [esp+4h] [ebp-38h]
  int v21; // [esp+Ch] [ebp-30h]
  int v22; // [esp+10h] [ebp-2Ch]
  char v23; // [esp+14h] [ebp-28h]
  float v24; // [esp+1Ch] [ebp-20h]
  float v25; // [esp+1Ch] [ebp-20h]
  float v26; // [esp+20h] [ebp-1Ch]

  *(_DWORD *)(result + 0x15E) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 0x10) = 0;
  *(_DWORD *)(result + 0x20) = 0;
  *(_DWORD *)(result + 0x24) = 0;
  *(_DWORD *)(result + 0x18) = 0;
  *(_DWORD *)(result + 0x1C) = 0;
  *(_DWORD *)(result + 0x30) = 0;
  *(_DWORD *)(result + 0x28) = 0;
  *(_DWORD *)(result + 0x2C) = 0;
  *(_BYTE *)(result + 0x34) = 0;
  *(_WORD *)(result + 0x56) = 0xFFFF;
  *(_BYTE *)(result + 0x58) = 0;
  *(_DWORD *)(result + 0x90) = 0;
  *(_DWORD *)(result + 0x8C) = 1;
  *(_BYTE *)(result + 0x5D) = 0;
  *(_DWORD *)(result + 0x5E) = 0;
  *(_DWORD *)(result + 0x88) = *(_DWORD *)(result + 0x90);
  v1 = result;
  *(_DWORD *)(result + 0x98) = *(_DWORD *)(result + 0x8C);
  do
  {
    v1 += 7;
    *(_BYTE *)(v1 + 0xA4) = 0xFF;
    *(_WORD *)(v1 + 0xA5) = 0;
    *(_DWORD *)(v1 + 0xA7) = 0;
  }
  while ( v1 != result + 0xAF );
  if ( !dword_10701C )
  {
    v2 = (char *)&unk_108F98;
    v3 = 0x83;
    do
    {
      v4 = v2;
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v3);
      do
      {
        v6 = *sub_1CEA8;
        *v4 = *sub_1CEA8;
        if ( !v6 )
        {
          break;
        }
        v7 = sub_1CEA8[1];
        sub_1CEA8 += 2;
        v4[1] = v7;
        v4 += 2;
      }
      while ( v7 );
      v2 += 0x14;
      ++v3;
    }
    while ( v2 != (char *)&unk_108F98 + 0x50 );
    sub_48C84();
    word_107018 = 0;
    v8 = 0;
    result = 0;
    do
    {
      v9 = 1;
      v10 = (unsigned __int8)byte_969B8[v8];
      v11 = 0;
      if ( byte_969B8[v8] )
      {
        v12 = byte_969C8[v8];
        do
        {
          if ( ((unsigned __int8)v9 & (unsigned __int8)v12) != 0 )
          {
            ++word_107018;
          }
          ++v11;
          v9 *= 2;
        }
        while ( v11 < v10 );
      }
      ++v8;
    }
    while ( v8 < 0xE );
    v22 = 0;
    v21 = 0;
    do
    {
      v13 = *(int *)((char *)&off_9699E + SHIWORD(v21));
      v24 = (float)word_107018;
      v20 = 0;
      v25 = v24 / (double)(v13 - 1);
      v19 = 0;
      v26 = v25;
      do
      {
        if ( v13 <= 0 )
        {
          break;
        }
        v14 = 1;
        v15 = (unsigned __int8)byte_969B8[v20];
        v16 = 0;
        if ( byte_969B8[v20] )
        {
          v23 = byte_969C8[v20];
          do
          {
            if ( ((unsigned __int8)v23 & (unsigned __int8)v14) != 0 )
            {
              v17 = v26 + 1.0;
              v18 = v22 + v19;
              v26 = v17;
              if ( v17 < v25 )
              {
                if ( v13 == 1 && v25 + flt_926DB < v26 )
                {
                  v13 = 0;
                  byte_106FE0[v18] |= v14;
                }
              }
              else
              {
                --v13;
                v26 = v26 - v25;
                byte_106FE0[v18] |= v14;
              }
            }
            ++v16;
            v14 *= 2;
          }
          while ( v16 < v15 );
        }
        result = v20 + 1;
        v19 += 4;
        v20 = result;
      }
      while ( result < 0xE );
      v21 += 2;
      ++v22;
    }
    while ( v22 < 4 );
    dword_10701C = 0xFFFFFFFF;
  }
  return result;
}
// 926DB: using guessed type float flt_926DB;
// 9699E: using guessed type void *off_9699E;
// 107018: using guessed type __int16 word_107018;
// 10701C: using guessed type int dword_10701C;

//----- (00049148) --------------------------------------------------------
int __fastcall sub_49148(int a1, char a2)
{
  _BYTE *v3; // edi
  char *v4; // esi
  char v5; // al
  char v6; // al
  int v7; // edx
  int result; // eax

  *(_BYTE *)(a1 + 0xAA) = a2;
  if ( a2 >= 4 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x131);
  }
  *(_DWORD *)(a1 + 0x15A) = *(int *)((char *)&off_9699E + 2 * *(char *)(a1 + 0xAA)) >> 0x10;
  if ( !*(_BYTE *)(a1 + 0x34) || *(_WORD *)(a1 + 0x56) != (unsigned __int8)byte_104BEA )
  {
    v3 = (_BYTE *)(a1 + 0x34);
    v4 = (char *)&unk_108F98 + 0x14 * *(char *)(a1 + 0xAA);
    do
    {
      v5 = *v4;
      *v3 = *v4;
      if ( !v5 )
      {
        break;
      }
      v6 = v4[1];
      v4 += 2;
      v3[1] = v6;
      v3 += 2;
    }
    while ( v6 );
  }
  v7 = *(__int16 *)(a1 + 0x56);
  *(_DWORD *)(a1 + 0x8C) = 0xA * (*(char *)(a1 + 0xAA) + 1);
  *(_DWORD *)(a1 + 0x14) = 0;
  if ( byte_A310F[0x1EE * v7] == 1 )
  {
    *(_DWORD *)(a1 + 0x8C) *= 2;
  }
  result = *(_DWORD *)(a1 + 0x8C);
  *(_DWORD *)(a1 + 0x98) = result;
  return result;
}
// 9699E: using guessed type void *off_9699E;

//----- (000492AC) --------------------------------------------------------
unsigned int __fastcall sub_492AC(_DWORD *a1, char a2, int a3)
{
  char v3; // ch

  if ( a3 > *(_DWORD *)((char *)a1 + 0x15A) )
  {
    return 0;
  }
  v3 = *((_BYTE *)a1 + 7 * a3 + 0xAB);
  if ( a2 == v3 )
  {
    return 0;
  }
  if ( v3 == (char)0xFF )
  {
    ++*(_DWORD *)((char *)a1 + 0x15E);
  }
  *((_BYTE *)a1 + 7 * a3 + 0xAB) = a2;
  sub_496E0(a1);
  return 0xFFFFFFFF;
}

//----- (000492F8) --------------------------------------------------------
unsigned int __fastcall sub_492F8(_DWORD *a1, int a2)
{
  char *v2; // edx

  v2 = (char *)a1 + 7 * a2;
  if ( v2[0xAB] == (char)0xFF )
  {
    return 0;
  }
  --*(_DWORD *)((char *)a1 + 0x15E);
  v2[0xAB] = 0xFF;
  sub_496E0(a1);
  return 0xFFFFFFFF;
}

//----- (00049328) --------------------------------------------------------
int __fastcall sub_49328(int a1, char a2)
{
  int v2; // esi
  unsigned int v4; // edi
  int v5; // edx

  v2 = a1;
  v4 = 0xFFFFFFFF;
  v5 = 0;
  if ( *(int *)(a1 + 0x15A) > 0 )
  {
    while ( *(_BYTE *)(a1 + 0xAB) == 0xFF || a2 != byte_107052[0x6A * *(char *)(a1 + 0xAB)] )
    {
      ++v5;
      a1 += 7;
      if ( v5 >= *(_DWORD *)(v2 + 0x15A) )
      {
        return v4;
      }
    }
    return v5;
  }
  return v4;
}

//----- (0004937C) --------------------------------------------------------
int __fastcall sub_4937C(int a1, char a2)
{
  unsigned int v4; // esi
  int v5; // edx
  int v6; // eax
  int i; // edx

  v4 = 0xFFFFFFFF;
  v5 = *(_DWORD *)(a1 + 0x15A);
  v6 = 0;
  if ( v5 > 0 )
  {
    for ( i = a1; a2 != *(_BYTE *)(i + 0xAB); i += 7 )
    {
      if ( ++v6 >= *(_DWORD *)(a1 + 0x15A) )
      {
        return v4;
      }
    }
    return v6;
  }
  return v4;
}

//----- (000493BC) --------------------------------------------------------
void __fastcall sub_493BC(int a1, char a2)
{
  int v3; // edi
  int v4; // esi
  int v5; // ebp
  char v6; // bl
  _BYTE *v7; // edi
  char *v8; // esi
  char v9; // al
  char v10; // al

  if ( a2 != *(_BYTE *)(a1 + 0xAA) && *(int *)((char *)&off_9699E + 2 * a2) >> 0x10 >= *(_DWORD *)(a1 + 0x15E) )
  {
    v3 = 0;
    v4 = 0;
    if ( *(int *)(a1 + 0x15A) > 0 )
    {
      v5 = a1;
      do
      {
        v6 = *(_BYTE *)(v5 + 0xAB);
        if ( v6 != (char)0xFF )
        {
          sub_492F8((_DWORD *)a1, v4);
          sub_492AC((_DWORD *)a1, v6, v3++);
        }
        ++v4;
        v5 += 7;
      }
      while ( v4 < *(_DWORD *)(a1 + 0x15A) );
    }
    sub_49148(a1, a2);
    v7 = (_BYTE *)(a1 + 0x34);
    v8 = (char *)&unk_108F98 + 0x14 * *(char *)(a1 + 0xAA);
    do
    {
      v9 = *v8;
      *v7 = *v8;
      if ( !v9 )
      {
        break;
      }
      v10 = v8[1];
      v8 += 2;
      v7[1] = v10;
      v7 += 2;
    }
    while ( v10 );
    sub_496E0((_DWORD *)a1);
  }
  JUMPOUT(0x4948C);
}
// 4948B: control flows out of bounds to 4948C
// 9699E: using guessed type void *off_9699E;

//----- (00049494) --------------------------------------------------------
int __fastcall sub_49494(int a1, float *a2)
{
  double v3; // st7
  int result; // eax
  int v5; // eax
  int v6; // eax
  int v7[3]; // [esp+0h] [ebp-3Ch] BYREF
  float v8; // [esp+Ch] [ebp-30h]
  float v9; // [esp+10h] [ebp-2Ch]
  float v10; // [esp+14h] [ebp-28h]
  float v11; // [esp+18h] [ebp-24h] BYREF
  float v12; // [esp+1Ch] [ebp-20h]
  float v13; // [esp+20h] [ebp-1Ch]
  int v14; // [esp+24h] [ebp-18h]
  int *v15; // [esp+28h] [ebp-14h]

  if ( sub_35BB4((int)a2, a1) )
  {
    v5 = sub_4937C(a1, 0x43);
    if ( v5 != 0xFFFFFFFF )
    {
      v6 = a1 + 7 * v5;
      if ( *(_WORD *)(v6 + 0xAC) )
      {
        *(_DWORD *)(a1 + 0x88) += dword_108C28;
        --*(_WORD *)(v6 + 0xAC);
      }
    }
    result = *(__int16 *)(a1 + 0x56);
    if ( result == (unsigned __int8)byte_104BEA && *(_BYTE *)(a1 + 0x5D) == 3 )
    {
      result = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
      if ( *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10 )
      {
        result = sub_55AEC((int)&V_Type3_stru_10AE70, 0x10, a1, *(_DWORD *)(a1 + 0x5E));
      }
      *(_BYTE *)(a1 + 0x5D) = 0;
      *(_DWORD *)(a1 + 0x5E) = 0;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 0x58) = 4;
    v11 = (float)(rand() % 0x3E8 - 0x1F4);
    v12 = (float)(rand() % 0x3E8 - 0x1F4);
    v14 = rand() % 0x3E8 - 0x1F4;
    v13 = (float)v14;
    sub_53054(&v11, 250.0);
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    v15 = v7;
    v8 = *a2 + v11;
    v9 = a2[1] + v12;
    v3 = a2[2];
    *(float *)v7 = v8;
    v10 = v3 + v13;
    *(float *)&v7[1] = v9;
    *(float *)&v7[2] = v10;
    return sub_496BC(a1, v7);
  }
  return result;
}
// 108C28: using guessed type int dword_108C28;

//----- (0004960C) --------------------------------------------------------
unsigned int __fastcall sub_4960C(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 0xC) + *(_DWORD *)(a1 + 8) <= 0 && byte_A310F[0x1EE * *(__int16 *)(a1 + 0x56)] != 0x12
    || (*(_BYTE *)(a2 + 0x23) & 2) != 0 )
  {
    return 0;
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (00049648) --------------------------------------------------------
unsigned int __fastcall sub_49648(int a1, __int16 **a2)
{
  unsigned int result; // eax
  __int16 *v4; // esi

  result = sub_4960C(a1, (int)a2);
  if ( result )
  {
    if ( *(_BYTE *)(a1 + 0x58) == 3 )
    {
      v4 = &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(a1 + 0x59) + 0xC)];
    }
    else
    {
      v4 = *(__int16 **)(a1 + 0x59);
    }
    result = sub_1D538((int)v4, a1);
    *(_BYTE *)(a1 + 0x58) = 5;
    *(_DWORD *)(a1 + 0x9E) = 0;
    *(_DWORD *)(a1 + 0x59) = a2;
    if ( v4 == *a2 )
    {
      *(_DWORD *)(a1 + 0xA2) = 0x3F800000;
    }
    else
    {
      *(_DWORD *)(a1 + 0xA2) = 0;
    }
  }
  return result;
}
// A3D21: using guessed type __int16 word_A3D21[];

//----- (000496BC) --------------------------------------------------------
int __fastcall sub_496BC(int a1, _DWORD *a2)
{
  int v2; // eax

  *(_DWORD *)(a1 + 0x9E) = *a2;
  v2 = a1 + 0x9E;
  *(_DWORD *)(v2 + 4) = a2[1];
  *(_DWORD *)(v2 + 8) = a2[2];
  return sub_53440((float *)v2);
}

//----- (000496E0) --------------------------------------------------------
void __fastcall sub_496E0(_DWORD *a1)
{
  int v2; // eax
  int v3; // esi
  int v4; // edi
  _DWORD *v5; // ebx
  char *v6; // eax
  char v7; // al
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]

  *a1 = 0;
  a1[1] = 0;
  v2 = a1[5];
  a1[8] = 0;
  a1[9] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[0xA] = 0;
  v3 = 0;
  a1[0xB] = 0;
  v9 = 0;
  a1[0xC] = 0;
  v8 = 0;
  v4 = *(_DWORD *)((char *)a1 + 0x15A);
  a1[4] = v2;
  if ( v4 > 0 )
  {
    v5 = a1;
    do
    {
      if ( *((_BYTE *)v5 + 0xAB) != 0xFF )
      {
        v6 = (char *)&unk_107020 + 0x6A * *((char *)v5 + 0xAB);
        *a1 += *(_DWORD *)(v6 + 0x52);
        a1[1] += *(_DWORD *)(v6 + 0x56);
        a1[4] += *(_DWORD *)(v6 + 0x5E);
        a1[8] += *(_DWORD *)(v6 + 0x62);
        a1[6] += *(_DWORD *)(v6 + 0x66);
        if ( v6[0x32] == 2 )
        {
          a1[7] += *(_DWORD *)(v6 + 0x36);
        }
        v7 = *((_BYTE *)v5 + 0xAB);
        switch ( v7 )
        {
          case 'G':
            a1[0xA] = 0xFFFFFFFF;
            break;
          case '+':
            ++v9;
            break;
          case ',':
            ++v8;
            break;
          case '*':
            ++a1[9];
            break;
        }
      }
      ++v3;
      v5 = (_DWORD *)((char *)v5 + 7);
    }
    while ( v3 < *(_DWORD *)((char *)a1 + 0x15A) );
  }
  a1[2] = (int)(sqrt((double)v9) * dbl_926EB);
  a1[3] = (int)(sqrt((double)v8) * dbl_926F3);
}
// 926EB: using guessed type double dbl_926EB;
// 926F3: using guessed type double dbl_926F3;

//----- (00049828) --------------------------------------------------------
int __fastcall sub_49828(int a1)
{
  int v2; // ecx
  __int16 v3; // dx
  int v4; // eax
  int v5; // ecx
  int v6; // edx

  if ( *(_BYTE *)(a1 + 0x58) != 1 && *(_BYTE *)(a1 + 0x58) != 2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x260);
  }
  if ( !*(_DWORD *)(a1 + 0x59) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x261);
  }
  v2 = *(_DWORD *)(a1 + 0x59);
  if ( *(_WORD *)(a1 + 0x56) != *(unsigned __int8 *)(v2 + 0x57) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x265);
  }
  if ( *(_BYTE *)(a1 + 0x58) == 1 )
  {
    *(_DWORD *)(a1 + 0x52) = dword_A2F6C[0];
    if ( *(_WORD *)(a1 + 0x56) == (unsigned __int8)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11 )
    {
      v3 = 0x11;
LABEL_15:
      sub_55AEC((int)&V_Type3_stru_10AE70, v3, a1, v2);
    }
  }
  else if ( *(_WORD *)(a1 + 0x56) == (unsigned __int8)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x11 )
  {
    v3 = 0x12;
    goto LABEL_15;
  }
  v4 = *(_DWORD *)(a1 + 0x59);
  *(_BYTE *)(a1 + 0x58) = 3;
  v5 = *(__int16 *)(v4 + 0xC);
  sub_1D3E8((int)&word_A3D21[0x30 * v5], a1, 0);
  v6 = *(char *)(a1 + 0xAA);
  sub_49148(a1, v6);
  return sub_4A6AC(a1, v6, 0, v5);
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00049940) --------------------------------------------------------
__int16 __fastcall sub_49940(int a1)
{
  int v2; // esi
  int v3; // eax
  __int16 *v4; // eax
  int v5; // eax

  if ( !*(_BYTE *)(a1 + 0x58) )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x288);
  }
  switch ( *(_BYTE *)(a1 + 0x58) )
  {
    case 1:
    case 2:
      v2 = *(_DWORD *)(a1 + 0x59);
      if ( *(_WORD *)(v2 + 0x52) >= *(_WORD *)(v2 + 0x1A) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x297);
      }
      if ( sub_35A70(*(_DWORD *)(a1 + 0x59), *(_WORD *)(v2 + 0x52)) != (char *)a1 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x29A);
      }
      v3 = 0x30 * *(__int16 *)(v2 + 0xC);
      *(_BYTE *)(a1 + 0x58) = 4;
      v4 = &word_A3D21[v3];
      *(_DWORD *)(a1 + 0x59) = v4;
      sub_1D538((int)v4, a1);
      v5 = *(unsigned __int16 *)(v2 + 0x52);
      *(_BYTE *)(v2 + 0x54) = 0xFF;
      if ( (unsigned __int16)v5 != 0xFFFF )
      {
        *(_BYTE *)(*(_DWORD *)(v2 + 0x10) + 4 * v5 + 1) = 0xFF;
        *(_WORD *)(v2 + 0x52) = 0xFFFF;
      }
      break;
    case 3:
      sub_35C38(*(_DWORD *)(a1 + 0x59), a1);
      if ( *(_BYTE *)(a1 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x2B0);
      }
      goto LABEL_12;
    case 4:
LABEL_12:
      sub_1D538(*(_DWORD *)(a1 + 0x59), a1);
      break;
    default:
      return sub_20720((int)dword_A2F6C, a1);
  }
  return sub_20720((int)dword_A2F6C, a1);
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3D21: using guessed type __int16 word_A3D21[];

//----- (00049A40) --------------------------------------------------------
int __fastcall sub_49A40(int a1, int a2)
{
  char *v3; // ebx
  __int16 i; // si
  int result; // eax

  v3 = (char *)(a1 + 0xAB);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 0x15A) )
    {
      break;
    }
    if ( *v3 != (char)0xFF && byte_107052[0x6A * *v3] == 1 && a2 != *(_DWORD *)(v3 + 3) )
    {
      sub_49A8C(a1, v3);
    }
    v3 += 7;
  }
  return result;
}

//----- (00049A8C) --------------------------------------------------------
char *__fastcall sub_49A8C(int a1, char *a2)
{
  char *result; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ebx

  if ( *a2 == (char)0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x2D3);
  }
  result = (char *)&unk_107020 + 0x6A * *a2;
  if ( (*(_WORD *)(result + 0x33) & 0x20) != 0 )
  {
    if ( *(_DWORD *)(a2 + 3) == 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0x88) += *(_DWORD *)(result + 0x36);
      if ( result[0x32] == 1 )
      {
        result = *(char **)(result + 0x56);
        v5 = *(_DWORD *)(a1 + 0x90) - (_DWORD)result;
        *(_DWORD *)(a1 + 0x90) = v5;
        if ( v5 < 0 )
        {
          *(_DWORD *)(a1 + 0x90) = 0;
        }
      }
      *(_DWORD *)(a2 + 3) = 0;
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 0x88);
      v7 = *(_DWORD *)(result + 0x36);
      if ( v6 >= v7 )
      {
        *(_DWORD *)(a1 + 0x88) = v6 - v7;
        if ( result[0x32] == 1 )
        {
          result = *(char **)(result + 0x56);
          *(_DWORD *)(a1 + 0x90) += result;
        }
        *(_DWORD *)(a2 + 3) = 0xFFFFFFFF;
      }
    }
  }
  return result;
}

//----- (00049B3C) --------------------------------------------------------
int __fastcall sub_49B3C(int a1, int a2)
{
  char v3; // cl
  int result; // eax

  v3 = *(_BYTE *)(a1 + 0x62);
  result = 0;
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      result = sub_4A0D0(a1, a2);
    }
  }
  else
  {
    result = sub_49CC4(a1, a2);
  }
  *(_DWORD *)(a1 + 0x84) = result;
  return result;
}

//----- (00049B68) --------------------------------------------------------
int __fastcall sub_49B68(int a1, int a2)
{
  __int16 i; // dx
  bool v5; // zf
  int v6; // ebx
  char v7; // al
  float v9; // [esp+8h] [ebp-20h]
  float v10; // [esp+10h] [ebp-18h]

  v10 = -1.0;
  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    v6 = a1 + 7 * i;
    v7 = *(_BYTE *)(v6 + 0xAB);
    v9 = -1.0;
    if ( v7 != (char)0xFF && v7 < 0x4C && (!*(int *)((char *)&dword_107062 + 0x6A * v7) || *(_WORD *)(v6 + 0xAC)) )
    {
      if ( v7 > (char)0xFFFFFFFF && v7 < 9 )
      {
LABEL_35:
        v9 = (double)(0x20 * *(int *)((char *)&dword_10705A + 0x6A * v7)) * dbl_9275B;
        goto LABEL_25;
      }
      if ( a2 != 1 )
      {
        if ( a2 != 2 || (unsigned __int8)v7 < 0x2Fu )
        {
          goto LABEL_25;
        }
        if ( (unsigned __int8)v7 > 0x2Fu )
        {
          v5 = v7 == 0x46;
          goto LABEL_24;
        }
LABEL_4:
        v9 = (double)(0x20 * *(int *)((char *)&dword_10705A + 0x6A * v7)) * dbl_92763;
        goto LABEL_25;
      }
      if ( (unsigned __int8)v7 < 0x30u )
      {
        if ( (unsigned __int8)v7 < 0x25u )
        {
          if ( (unsigned __int8)v7 >= 0x21u && (unsigned __int8)v7 <= 0x23u )
          {
            goto LABEL_35;
          }
        }
        else
        {
          if ( (unsigned __int8)v7 <= 0x26u )
          {
            goto LABEL_35;
          }
          if ( v7 == 0x2F )
          {
            goto LABEL_4;
          }
        }
      }
      else
      {
        if ( (unsigned __int8)v7 <= 0x32u )
        {
          goto LABEL_35;
        }
        if ( (unsigned __int8)v7 < 0x3Du )
        {
          v5 = v7 == 0x36;
LABEL_24:
          if ( v5 )
          {
            goto LABEL_35;
          }
        }
        else
        {
          if ( (unsigned __int8)v7 <= 0x3Du )
          {
            goto LABEL_35;
          }
          if ( (unsigned __int8)v7 >= 0x40u )
          {
            if ( (unsigned __int8)v7 <= 0x40u )
            {
              goto LABEL_35;
            }
            v5 = v7 == 0x42;
            goto LABEL_24;
          }
        }
      }
LABEL_25:
      if ( v9 > (double)v10 )
      {
        v10 = v9;
      }
      continue;
    }
  }
  return (int)v10;
}
// 9275B: using guessed type double dbl_9275B;
// 92763: using guessed type double dbl_92763;
// 10705A: using guessed type int dword_10705A;
// 107062: using guessed type int dword_107062;

//----- (00049CC4) --------------------------------------------------------
int __fastcall sub_49CC4(int a1, int a2)
{
  char v4; // dh
  int v5; // ebx
  int *v6; // edx
  int *v7; // edx
  float *v8; // edx
  double v9; // st7
  double v10; // st7
  int v11; // eax
  double v12; // st6
  char v13; // dl
  int v15[3]; // [esp+8h] [ebp-C0h] BYREF
  float v16; // [esp+14h] [ebp-B4h]
  float v17; // [esp+18h] [ebp-B0h]
  float v18; // [esp+1Ch] [ebp-ACh]
  int v19[3]; // [esp+20h] [ebp-A8h] BYREF
  float v20; // [esp+2Ch] [ebp-9Ch]
  float v21; // [esp+30h] [ebp-98h]
  float v22; // [esp+34h] [ebp-94h]
  float v23; // [esp+38h] [ebp-90h]
  int v24; // [esp+3Ch] [ebp-8Ch]
  int v25; // [esp+40h] [ebp-88h]
  float v26; // [esp+44h] [ebp-84h] BYREF
  int v27; // [esp+48h] [ebp-80h]
  int v28; // [esp+4Ch] [ebp-7Ch]
  int v29[3]; // [esp+50h] [ebp-78h] BYREF
  float v30; // [esp+5Ch] [ebp-6Ch]
  float v31; // [esp+60h] [ebp-68h]
  float v32; // [esp+64h] [ebp-64h]
  float v33; // [esp+68h] [ebp-60h]
  int v34; // [esp+6Ch] [ebp-5Ch]
  int v35; // [esp+70h] [ebp-58h]
  float v36; // [esp+74h] [ebp-54h]
  int v37; // [esp+78h] [ebp-50h]
  int v38; // [esp+7Ch] [ebp-4Ch]
  float v39; // [esp+80h] [ebp-48h] BYREF
  float v40; // [esp+84h] [ebp-44h]
  float v41; // [esp+88h] [ebp-40h]
  int *v42; // [esp+8Ch] [ebp-3Ch]
  int *v43; // [esp+90h] [ebp-38h]
  int *v44; // [esp+94h] [ebp-34h]
  float *v45; // [esp+98h] [ebp-30h]
  float *v46; // [esp+9Ch] [ebp-2Ch]
  float v47; // [esp+A4h] [ebp-24h]
  float v48; // [esp+A8h] [ebp-20h]
  int v49; // [esp+ACh] [ebp-1Ch]
  float v50; // [esp+B0h] [ebp-18h]

  if ( *(_BYTE *)(a1 + 0x58) != 4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x370);
  }
  v20 = 0.0;
  v21 = 0.0;
  v22 = 0.0;
  v4 = *(_BYTE *)(a1 + 0x67);
  v5 = 1;
  switch ( v4 )
  {
    case 3:
      v20 = *(float *)(a1 + 0x6C);
      v21 = *(float *)(a1 + 0x70);
      v22 = *(float *)(a1 + 0x74);
      break;
    case 1:
      v6 = *(int **)(a1 + 0x68);
      v20 = *(float *)v6;
      v21 = *((float *)v6 + 1);
      v22 = *((float *)v6 + 2);
      break;
    case 2:
      v7 = *(int **)(a1 + 0x68);
      v20 = *((float *)v7 + 5);
      v21 = *((float *)v7 + 6);
      v22 = *((float *)v7 + 7);
      v8 = *(float **)(a1 + 0x68);
      if ( *(_DWORD *)(a1 + 0x59) == *(_DWORD *)v8 )
      {
        v20 = v8[2];
        v21 = v8[3];
        v22 = v8[4];
      }
      break;
    default:
      v5 = 0;
      break;
  }
  if ( (v5 & 1) != 0 )
  {
    v45 = &v26;
    v16 = 0.0;
    v17 = 0.0;
    v18 = 0.0;
    v16 = v20 - *(float *)(a1 + 0x9E);
    v17 = v21 - *(float *)(a1 + 0xA2);
    v18 = v22 - *(float *)(a1 + 0xA6);
    v26 = v16;
    *(float *)&v27 = v17;
    *(float *)&v28 = v18;
    v50 = sqrt(v17 * v17 + v16 * v16 + v18 * v18) * flt_92777;
    v48 = (float)*(int *)(a1 + 0x94);
    v47 = v50;
    if ( v50 > (double)v48 )
    {
      v50 = v48;
    }
    v49 = (int)((double)*(int *)(a1 + 0x1C) * (v50 + 1.0) / (double)*(int *)(a1 + 0x10));
    if ( v49 < 1 )
    {
      v49 = 1;
    }
    if ( v49 > *(_DWORD *)(a1 + 0x88) )
    {
      v9 = (double)*(int *)(a1 + 0x88) * v50 / (double)v49;
      v49 = *(_DWORD *)(a1 + 0x88);
      v50 = v9;
    }
    if ( v50 == v47 )
    {
      LOBYTE(v5) = v5 | 8;
    }
    sub_53000(&v26);
    v42 = v15;
    v36 = v26 * v50;
    *(float *)v15 = v36;
    *(float *)&v37 = *(float *)&v27 * v50;
    v15[1] = v37;
    *(float *)&v38 = v50 * *(float *)&v28;
    v15[2] = v38;
    v33 = v36 * flt_9277B;
    v43 = v19;
    *(float *)&v34 = *(float *)&v37 * flt_9277B;
    *(float *)v19 = v33;
    *(float *)&v35 = flt_9277B * *(float *)&v38;
    v19[1] = v34;
    v19[2] = v35;
    v23 = v33 * flt_9277F;
    v44 = v29;
    *(float *)&v24 = *(float *)&v34 * flt_9277F;
    *(float *)v29 = v23;
    *(float *)&v25 = flt_9277F * *(float *)&v35;
    v29[1] = v24;
    v29[2] = v25;
    v26 = v23;
    v30 = 0.0;
    v27 = v24;
    v31 = 0.0;
    v28 = v25;
    v32 = 0.0;
    v46 = &v39;
    v30 = *(float *)(a1 + 0x9E) + v23;
    v31 = *(float *)(a1 + 0xA2) + *(float *)&v24;
    v10 = *(float *)(a1 + 0xA6);
    v39 = v30;
    v32 = v10 + *(float *)&v25;
    v40 = v31;
    v41 = v32;
    *(float *)(a1 + 0x78) = v30;
    *(float *)(a1 + 0x7C) = v40;
    *(float *)(a1 + 0x80) = v41;
    sub_53440((float *)(a1 + 0x78));
    if ( a2 == 1 )
    {
      v11 = v49;
      *(float *)(a1 + 0x9E) = *(float *)(a1 + 0x78);
      *(_DWORD *)(a1 + 0xA2) = *(_DWORD *)(a1 + 0x7C);
      *(_DWORD *)(a1 + 0xA6) = *(_DWORD *)(a1 + 0x80);
      v12 = (double)*(int *)(a1 + 0x94) - v50;
      *(_DWORD *)(a1 + 0x88) -= v11;
      *(_DWORD *)(a1 + 0x94) = (int)v12;
      if ( (v5 & 8) != 0 )
      {
        v13 = *(_BYTE *)(a1 + 0x67);
        if ( v13 == 1 )
        {
          sub_49494(a1, *(float **)(a1 + 0x68));
        }
        else if ( v13 == 2 )
        {
          sub_49648(a1, *(__int16 ***)(a1 + 0x68));
        }
      }
    }
  }
  return v5;
}
// 92777: using guessed type float flt_92777;
// 9277B: using guessed type float flt_9277B;
// 9277F: using guessed type float flt_9277F;

//----- (0004A0D0) --------------------------------------------------------
int __fastcall sub_4A0D0(int a1, int a2)
{
  char *v2; // ecx
  unsigned int v3; // esi
  int v4; // ebx
  char v5; // cl

  v2 = *(char **)(a1 + 0x63);
  v3 = 0xFFFFFFFF;
  v4 = 0;
  if ( *(int *)((char *)&dword_107062 + 0x6A * *v2) )
  {
    if ( *(_WORD *)(v2 + 1) )
    {
      if ( a2 == 1 )
      {
        --*(_WORD *)(v2 + 1);
      }
    }
    else
    {
      v3 = 0;
    }
  }
  if ( v3 == 0xFFFFFFFF )
  {
    v5 = *(_BYTE *)(a1 + 0x67);
    switch ( v5 )
    {
      case 0:
        return sub_4B944(a1, a2);
      case 2:
        return sub_4CAB8(a1, a2);
      case 1:
        return sub_4C7FC(a1, a2);
      case 5:
        return sub_4CDF8(a1, a2);
    }
  }
  return v4;
}
// 107062: using guessed type int dword_107062;

//----- (0004A144) --------------------------------------------------------
int __fastcall sub_4A144(int a1)
{
  int v2; // ebx
  unsigned __int16 i; // ax
  int v4; // edx

  v2 = 0;
  for ( i = 0; i < *(int *)(a1 + 0x15A); ++i )
  {
    v4 = a1 + 7 * i;
    if ( *(_BYTE *)(v4 + 0xAB) != 0xFF )
    {
      v2 += *(int *)((char *)&dword_107066 + 0x6A * *(char *)(v4 + 0xAB));
    }
  }
  return v2;
}
// 107066: using guessed type int dword_107066;

//----- (0004A18C) --------------------------------------------------------
int __fastcall sub_4A18C(int a1)
{
  int v1; // edx
  int v3[7]; // [esp+0h] [ebp-1Ch]

  v3[0] = dword_969D8[0];
  v3[1] = dword_969D8[1];
  v3[2] = dword_969D8[2];
  v3[3] = dword_969D8[3];
  v1 = v3[*(char *)(a1 + 0xAA)];
  return v1 + sub_4A144(a1);
}
// 969D8: using guessed type _DWORD dword_969D8[4];
// 4A18C: using guessed type int var_1C[7];

//----- (0004A1CC) --------------------------------------------------------
int __fastcall sub_4A1CC(int a1, __int16 a2)
{
  int v3; // ecx
  int v4; // edi
  unsigned __int16 i; // dx
  signed int v6; // eax
  int v7; // ebp
  char v10; // [esp+6h] [ebp-28h]
  char v11; // [esp+Ah] [ebp-24h]
  char v12; // [esp+Eh] [ebp-20h]
  char v13; // [esp+12h] [ebp-1Ch]
  char v14; // [esp+16h] [ebp-18h]

  if ( a2 < 0 || a2 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x408);
  }
  v10 = sub_4A36C(a1, 0, a2);
  v11 = sub_4A36C(a1, 4, a2);
  v14 = sub_4A36C(a1, 2, a2);
  v3 = 0;
  v13 = sub_4A36C(a1, 1, a2);
  v12 = 0x2B;
  v4 = 0;
  if ( sub_4A404(a1, 0x2C) )
  {
    v12 = 0x2C;
  }
  for ( i = 0; i < *(int *)(a1 + 0x15A); ++i )
  {
    if ( *(_BYTE *)(a1 + 7 * i + 0xAB) != 0xFF )
    {
      v6 = 0xFFFFFFFF;
      switch ( byte_107052[0x6A * i] )
      {
        case 0:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v10);
          break;
        case 1:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v13);
          break;
        case 2:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v14);
          break;
        case 4:
          v6 = *(int *)((char *)&dword_10705E + 0x6A * v11);
          break;
        default:
          break;
      }
      if ( *(_BYTE *)(a1 + 7 * i + 0xAB) == 0x2B && v12 == 0x2C )
      {
        ++v4;
        ++v3;
      }
      else if ( v6 != 0xFFFFFFFF )
      {
        v7 = *(int *)((char *)&dword_10705E + 0x6A * *(char *)(a1 + 7 * i + 0xAB));
        ++v4;
        if ( v6 > v7 )
        {
          v3 += v6 - v7;
        }
      }
    }
  }
  if ( v4 <= 0 )
  {
    return 0;
  }
  else
  {
    return 0xA * v3 / v4;
  }
}
// A3CF2: using guessed type int dword_A3CF2;
// 10705E: using guessed type int dword_10705E;

//----- (0004A36C) --------------------------------------------------------
char __fastcall sub_4A36C(int a1, char a2, __int16 a3)
{
  char v3; // di
  __int16 v4; // bx
  __int16 i; // ax
  char v7; // [esp+4h] [ebp-14h]

  v3 = a3;
  if ( a3 < 0 || a3 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x45F);
  }
  v4 = 0;
  v7 = 0xFF;
  for ( i = 0; i < 0x4C; ++i )
  {
    if ( byte_107052[0x6A * i] == a2
      && ((1 << v3) & (*(int *)((char *)&dword_10529F + 0x4B * (unsigned __int8)byte_107055[0x6A * i]) >> 0x18)) != 0
      && v4 <= *(int *)((char *)&dword_10705E + 0x6A * i) )
    {
      v7 = i;
      v4 = *((_WORD *)&dword_10705E + 0x35 * i);
    }
  }
  return v7;
}
// A3CF2: using guessed type int dword_A3CF2;
// 10529F: using guessed type int dword_10529F;
// 10705E: using guessed type int dword_10705E;

//----- (0004A404) --------------------------------------------------------
int __fastcall sub_4A404(int a1, char a2)
{
  if ( SHIWORD(dword_A3CF2) <= *(__int16 *)(a1 + 0x56) || *(__int16 *)(a1 + 0x56) < 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x476);
  }
  return (((1 << *(_WORD *)(a1 + 0x56)) & (*(int *)((char *)&dword_10529F
                                                  + 0x4B * (unsigned __int8)byte_107055[0x6A * a2]) >> 0x18)) == 0)
       - 1;
}
// A3CF2: using guessed type int dword_A3CF2;
// 10529F: using guessed type int dword_10529F;

//----- (0004A480) --------------------------------------------------------
_BYTE *__fastcall sub_4A480(int a1, unsigned __int16 a2, int a3)
{
  _BYTE *v5; // ecx
  int v6; // edi
  __int16 i; // bx

  if ( !*(_DWORD *)(a1 + 0x88) )
  {
    return 0;
  }
  v5 = (_BYTE *)(a1 + 0xAB);
  *(_BYTE *)(a1 + 0x62) = 1;
  v6 = 0;
  if ( a2 )
  {
    if ( a2 <= 2u )
    {
      *(_BYTE *)(a1 + 0x67) = 1;
      *(_DWORD *)(a1 + 0x68) = a3;
    }
    else
    {
      if ( a2 != 3 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x4A3);
      }
      *(_BYTE *)(a1 + 0x67) = 0;
      *(_DWORD *)(a1 + 0x68) = a3;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 0x67) = 2;
    *(_DWORD *)(a1 + 0x68) = a3;
  }
  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    if ( *v5 != 0xFF && (!byte_107052[0x6A * (char)*v5] || *(_BYTE *)(a1 + 0x67) == 1 && *v5 == 0x46) )
    {
      *(_DWORD *)(a1 + 0x63) = v5;
      if ( (sub_49B3C(a1, 0) & 1) != 0 )
      {
        return v5;
      }
    }
    v5 += 7;
  }
  return (_BYTE *)v6;
}

//----- (0004A534) --------------------------------------------------------
unsigned int __fastcall sub_4A534(int a1, char a2)
{
  __int16 i; // ax

  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    if ( a2 == *(_BYTE *)(7 * i + a1 + 0xAB) )
    {
      return 0xFFFFFFFF;
    }
  }
  return 0;
}

//----- (0004A564) --------------------------------------------------------
unsigned int __fastcall sub_4A564(int a1)
{
  __int16 i; // ax
  int v3; // edx

  for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); ++i )
  {
    v3 = a1 + 7 * i;
    if ( !byte_107052[0x6A * *(char *)(v3 + 0xAB)]
      && (!*(int *)((char *)&dword_107062 + 0x6A * *(char *)(v3 + 0xAB)) || *(_WORD *)(v3 + 0xAC)) )
    {
      return 0xFFFFFFFF;
    }
  }
  return 0;
}
// 107062: using guessed type int dword_107062;

//----- (0004A5B8) --------------------------------------------------------
int __fastcall sub_4A5B8(int result)
{
  int v1; // edx
  char *v2; // ebx
  int i; // esi
  char *v4; // edx
  int v5; // ecx
  int v6; // edi

  if ( (*(_WORD *)(result + 0x9C) & 1) != 0 )
  {
    *(_DWORD *)(result + 0x94) = 0;
  }
  else
  {
    if ( (*(_WORD *)(result + 0x9C) & 2) != 0 )
    {
      v1 = dword_108A80 + *(_DWORD *)(result + 0x10);
    }
    else
    {
      v1 = *(_DWORD *)(result + 0x10);
    }
    *(_DWORD *)(result + 0x94) = v1;
  }
  *(_DWORD *)(result + 0x90) = 0;
  v2 = (char *)(result + 0xAB);
  for ( i = 0; i < *(_DWORD *)(result + 0x15A); v2 += 7 )
  {
    if ( *v2 != (char)0xFF )
    {
      v4 = (char *)&unk_107020 + 0x6A * *v2;
      if ( (*(_WORD *)(v4 + 0x33) & 0x20) != 0 && *(_DWORD *)(v2 + 3) == 0xFFFFFFFF )
      {
        v5 = *(_DWORD *)(result + 0x88);
        v6 = *(_DWORD *)(v4 + 0x36);
        if ( v5 >= v6 )
        {
          *(_DWORD *)(result + 0x88) = v5 - v6;
          if ( v4[0x32] == 1 )
          {
            *(_DWORD *)(result + 0x90) += *(_DWORD *)(v4 + 0x56);
          }
        }
      }
    }
    ++i;
  }
  if ( (*(_WORD *)(result + 0x9C) & 8) != 0 )
  {
    *(_DWORD *)(result + 0x90) = 0;
  }
  return result;
}
// 108A80: using guessed type int dword_108A80;

//----- (0004A6AC) --------------------------------------------------------
int __fastcall sub_4A6AC(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  int v6; // edx
  int v7; // ebx
  char *v8; // eax
  int v9; // edx
  float *v10; // eax
  float *v11; // ebx
  double v12; // st7
  int v13; // eax
  double v14; // st7
  int v15; // edi
  unsigned __int8 *v16; // eax
  float v18; // [esp+8h] [ebp-3Ch]
  int v19; // [esp+Ch] [ebp-38h]
  int v20; // [esp+10h] [ebp-34h]
  int v21[5]; // [esp+14h] [ebp-30h] BYREF
  float v22; // [esp+28h] [ebp-1Ch]
  float v23; // [esp+2Ch] [ebp-18h]
  int v24; // [esp+3Ch] [ebp-8h]

  v24 = a4;
  *(_WORD *)(a1 + 0x9C) = 0;
  v5 = sub_4A8FC(a1);
  v6 = 0;
  v7 = *(_DWORD *)(a1 + 0x15A);
  *(_DWORD *)(a1 + 0x88) = v5;
  v8 = (char *)(a1 + 0xAB);
  if ( v7 > 0 )
  {
    do
    {
      if ( *v8 != (char)0xFF )
      {
        *(_WORD *)(v8 + 1) = *((_WORD *)&dword_107062 + 0x35 * *v8);
      }
      ++v6;
      v8 += 7;
    }
    while ( v6 < *(_DWORD *)(a1 + 0x15A) );
  }
  if ( *(_BYTE *)(a1 + 0x58) == 5 )
  {
    v9 = *(_DWORD *)(a1 + 0x59);
    v10 = *(float **)(v9 + 4);
    v11 = *(float **)v9;
    v21[3] = (int)v21;
    v18 = v11[2] - v10[2];
    *(float *)&v19 = v11[3] - v10[3];
    *(float *)&v20 = v11[4] - v10[4];
    *(float *)v21 = v18;
    v21[1] = v19;
    v21[2] = v20;
    v12 = sqrt(*(float *)&v19 * *(float *)&v19 + v18 * v18 + *(float *)&v20 * *(float *)&v20);
    v13 = *(_DWORD *)(a1 + 0xC) + *(_DWORD *)(a1 + 8);
    v22 = v12;
    v21[4] = v13;
    LOBYTE(v11) = *(_BYTE *)(v9 + 0x23);
    v23 = (float)v13;
    if ( ((unsigned __int8)v11 & 1) != 0 )
    {
      v23 = v23 * flt_927BF;
    }
    if ( byte_A310F[0x1EE * *(__int16 *)(a1 + 0x56)] == 0x12 )
    {
      if ( v23 < 1.0 )
      {
        v23 = 1.0;
      }
      v23 = v23 * flt_927C3;
    }
    v14 = *(float *)(a1 + 0x9E) + v23;
    *(float *)(a1 + 0x9E) = v14;
    if ( v14 > v22 )
    {
      *(float *)(a1 + 0x9E) = v22;
    }
    if ( *(float *)(a1 + 0x9E) == v22 )
    {
      if ( (*(_DWORD *)(a1 + 0xA2) & 0x7FFFFFFF) != 0 )
      {
        v15 = *(_DWORD *)(*(_DWORD *)(a1 + 0x59) + 4);
      }
      else
      {
        v15 = **(_DWORD **)(a1 + 0x59);
      }
      v16 = (unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA];
      if ( *(_WORD *)(a1 + 0x56) == (unsigned __int8)byte_104BEA )
      {
        sub_45A54(v16, v15, a1);
      }
      else if ( ((1 << byte_104BEA) & (*(unsigned __int8 *)(v15 + 0x14) | *(unsigned __int8 *)(v15 + 0x15))) != 0 )
      {
        sub_45D50(v16, v15, a1);
      }
      sub_1D3E8(v15, a1, 0);
      if ( *(_BYTE *)(a1 + 0x58) != 4 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x55A);
      }
    }
  }
  return sub_4A5B8(a1);
}
// 927BF: using guessed type float flt_927BF;
// 927C3: using guessed type float flt_927C3;
// 107062: using guessed type int dword_107062;

//----- (0004A8CC) --------------------------------------------------------
int __fastcall __spoils<> sub_4A8CC(int a1)
{
  int result; // eax

  result = (dword_A2F6C[0] - *(_DWORD *)(a1 + 0x52)) / 0x64;
  if ( result < 0 )
  {
    return 0;
  }
  if ( result > 0xA )
  {
    return 0xA;
  }
  return result;
}
// A2F6C: using guessed type int dword_A2F6C[];

//----- (0004A8FC) --------------------------------------------------------
int __fastcall sub_4A8FC(int a1)
{
  int v2; // [esp+4h] [ebp-Ch]
  float v3; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 0x18);
  v3 = (double)sub_4A8CC(a1) * flt_927C7 + 1.0;
  if ( v3 >= 1.0 )
  {
    if ( v3 > (double)flt_927CB )
    {
      v3 = 2.0;
    }
  }
  else
  {
    v3 = 1.0;
  }
  return (int)((double)v2 * v3);
}
// 927C7: using guessed type float flt_927C7;
// 927CB: using guessed type float flt_927CB;

//----- (0004A988) --------------------------------------------------------
int __fastcall sub_4A988(int a1)
{
  int v1; // ebx
  int v2; // esi
  int v3; // ecx
  char *v4; // edx

  v1 = 0;
  v2 = 0;
  if ( *(int *)(a1 + 0x15A) > 0 )
  {
    v3 = a1;
    do
    {
      if ( *(_WORD *)(v3 + 0xAC) == 1 && *(_BYTE *)(v3 + 0xAB) != 0xFF )
      {
        v4 = (char *)&unk_107020 + 0x6A * *(char *)(v3 + 0xAB);
        v1 += *(_DWORD *)(v4 + 0x46);
        switch ( v4[0x32] )
        {
          case 0:
            v1 += *(_DWORD *)(v4 + 0x3A) / 5 + 0xA * *(_DWORD *)(v4 + 0x3E);
            break;
          case 1:
            v1 += 5 * *(_DWORD *)(v4 + 0x3E);
            break;
          case 2:
            v1 += 2 * *(_DWORD *)(v4 + 0x3E);
            break;
          case 3:
            v1 += *(_DWORD *)(v4 + 0x3E);
            break;
          case 5:
            v1 += *(_DWORD *)(v4 + 0x3A) / 5 + 5 * *(_DWORD *)(v4 + 0x3E);
            break;
          default:
            break;
        }
      }
      ++v2;
      v3 += 7;
    }
    while ( v2 < *(_DWORD *)(a1 + 0x15A) );
  }
  return (4 * *(_DWORD *)(a1 + 0x8C) + 0xA * sub_4A8FC(a1) + v1) / 0xA;
}

//----- (0004AA78) --------------------------------------------------------
int __fastcall sub_4AA78(int a1, int a2)
{
  int v3; // eax

  if ( !a2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x5B6);
  }
  if ( *(_BYTE *)(a1 + 0x58) != 4 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x5B7);
  }
  v3 = *(_DWORD *)(a1 + 0x59);
  if ( a2 == v3 )
  {
    return 0;
  }
  *(_BYTE *)(a1 + 0x5D) = 1;
  *(_DWORD *)(a1 + 0x5E) = a2;
  return (unsigned __int8)byte_D5D47[0x64 * *(__int16 *)(v3 + 4) + *(__int16 *)(a2 + 4)];
}

//----- (0004AAEC) --------------------------------------------------------
int __fastcall sub_4AAEC(int a1, int a2)
{
  int v2; // eax
  unsigned int v3; // ebp
  int v4; // eax
  int v5; // esi
  int v6; // ecx
  double v7; // st7
  int v8; // edx
  _BYTE *i; // edx
  int v10; // eax
  int v11; // ebx
  int v12; // eax
  int v13; // edi
  int v14; // ecx
  float *v15; // esi
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  int v20[107]; // [esp+8h] [ebp-218h] BYREF
  float v21; // [esp+1B4h] [ebp-6Ch]
  float v22; // [esp+1B8h] [ebp-68h]
  float v23; // [esp+1BCh] [ebp-64h]
  float v24; // [esp+1C0h] [ebp-60h]
  float v25; // [esp+1C4h] [ebp-5Ch]
  float v26; // [esp+1C8h] [ebp-58h]
  int v27[3]; // [esp+1CCh] [ebp-54h] BYREF
  int v28[3]; // [esp+1D8h] [ebp-48h] BYREF
  int v29; // [esp+1E4h] [ebp-3Ch]
  int v30; // [esp+1E8h] [ebp-38h]
  int *v31; // [esp+1ECh] [ebp-34h]
  int v32; // [esp+1F0h] [ebp-30h]
  int v33; // [esp+1F4h] [ebp-2Ch]
  int *v34; // [esp+1F8h] [ebp-28h]
  float v35; // [esp+1FCh] [ebp-24h]
  int v36; // [esp+200h] [ebp-20h]
  float *v37; // [esp+204h] [ebp-1Ch]
  float v38; // [esp+208h] [ebp-18h]

  v29 = a1;
  v36 = a2;
  v30 = 0;
  if ( *(_BYTE *)(a1 + 0x58) == 4 )
  {
    v2 = sub_1D794(*(__int16 **)(a1 + 0x59), v20);
    if ( v2 > 0 )
    {
      v3 = 0;
      v32 = 4 * v2;
      v37 = (float *)(v29 + 0x9E);
      while ( 1 )
      {
        v4 = v20[v3 / 4];
        if ( *(__int16 *)(v4 + 0x56) == v36 && *(_BYTE *)(v4 + 0x58) == 4 )
        {
          v5 = 0;
          v31 = v27;
          v21 = 0.0;
          v22 = 0.0;
          v23 = 0.0;
          v21 = *v37 - *(float *)(v4 + 0x9E);
          v22 = v37[1] - *(float *)(v4 + 0xA2);
          v23 = v37[2] - *(float *)(v4 + 0xA6);
          *(float *)v27 = v21;
          *(float *)&v27[1] = v22;
          *(float *)&v27[2] = v23;
          v6 = 0;
          v7 = sqrt(v22 * v22 + v21 * v21 + v23 * v23);
          v8 = v20[v3 / 4];
          v38 = v7;
          for ( i = (_BYTE *)(v8 + 0xAB); ; i += 7 )
          {
            v10 = v20[v3 / 4];
            if ( v6 >= *(_DWORD *)(v10 + 0x15A) )
            {
              break;
            }
            if ( *i != 0xFF )
            {
              v11 = 0x6A * (char)*i;
              if ( byte_107052[v11] == 3 )
              {
                v33 = 0x20 * *(int *)((char *)&dword_10705A + 0x6A * (char)*i);
                if ( (double)v33 >= v38 )
                {
                  v5 += *(int *)((char *)&dword_107082 + v11);
                }
              }
            }
            ++v6;
          }
          if ( v5 > 0 && v5 > 2 * *(_DWORD *)(v29 + 0x24) )
          {
            v12 = sub_4937C(v10, 0x29);
            v30 = 1;
            if ( v12 != 0xFFFFFFFF )
            {
              break;
            }
          }
        }
        v3 += 4;
        if ( (int)v3 >= v32 )
        {
          goto LABEL_20;
        }
      }
      v30 = 2;
    }
LABEL_20:
    if ( !v30 )
    {
      v13 = 0;
      v14 = 0;
      v15 = (float *)(v29 + 0x9E);
      while ( 1 )
      {
        v16 = *(_DWORD *)(v29 + 0x59);
        if ( v13 >= *(__int16 *)(v16 + 0x5A) )
        {
          break;
        }
        v17 = *(_DWORD *)(v14 + v16 + 0x46);
        if ( *(unsigned __int8 *)(v17 + 0x57) == v36 )
        {
          v34 = v28;
          v24 = 0.0;
          v25 = 0.0;
          v26 = 0.0;
          v24 = *v15 - *(float *)v17;
          v25 = v15[1] - *(float *)(v17 + 4);
          v26 = v15[2] - *(float *)(v17 + 8);
          *(float *)v28 = v24;
          *(float *)&v28[1] = v25;
          *(float *)&v28[2] = v26;
          v35 = sqrt(v25 * v25 + v24 * v24 + v26 * v26);
          v18 = (unsigned __int16)sub_35930(v17, 0x10);
          if ( v18 != 0xFFFF && (*(_WORD *)(*(_DWORD *)(v17 + 0x10) + 4 * v18 + 2) & 1) != 0 && v35 < (double)flt_927E7 )
          {
            return 1;
          }
        }
        v14 += 4;
        ++v13;
      }
    }
  }
  return v30;
}
// 927E7: using guessed type float flt_927E7;
// 10705A: using guessed type int dword_10705A;
// 107082: using guessed type int dword_107082;

//----- (0004AE8C) --------------------------------------------------------
__int64 __fastcall sub_4AE8C(int a1, unsigned int a2, int a3)
{
  _DWORD *v4; // edx
  unsigned __int8 v5; // al
  __int64 result; // rax
  int v7; // ebp
  int v8; // ebp
  int v9[13]; // [esp+0h] [ebp-3BCh] BYREF
  _WORD v10[59]; // [esp+34h] [ebp-388h] BYREF
  char v11; // [esp+AAh] [ebp-312h]
  char v12[175]; // [esp+ABh] [ebp-311h] BYREF
  int v13; // [esp+15Ah] [ebp-262h]
  int v14; // [esp+15Eh] [ebp-25Eh]
  int v15[13]; // [esp+164h] [ebp-258h] BYREF
  char v16[28]; // [esp+198h] [ebp-224h] BYREF
  __int16 v17; // [esp+1B4h] [ebp-208h]
  int v18; // [esp+1B6h] [ebp-206h]
  char v19[7]; // [esp+1BAh] [ebp-202h]
  char v20; // [esp+1C1h] [ebp-1FBh]
  int v21; // [esp+1C2h] [ebp-1FAh]
  char v22; // [esp+1C6h] [ebp-1F6h]
  int v23; // [esp+1C7h] [ebp-1F5h]
  char v24; // [esp+1CBh] [ebp-1F1h]
  int v25; // [esp+1CCh] [ebp-1F0h]
  int v26; // [esp+1D0h] [ebp-1ECh]
  int v27; // [esp+1D4h] [ebp-1E8h]
  int v28; // [esp+1D8h] [ebp-1E4h]
  int v29; // [esp+1DCh] [ebp-1E0h]
  int v30; // [esp+1E0h] [ebp-1DCh]
  int v31; // [esp+1E4h] [ebp-1D8h]
  int v32; // [esp+1E8h] [ebp-1D4h]
  int v33; // [esp+1ECh] [ebp-1D0h]
  int v34; // [esp+1F0h] [ebp-1CCh]
  int v35; // [esp+1F4h] [ebp-1C8h]
  int v36; // [esp+1F8h] [ebp-1C4h]
  int v37; // [esp+1FCh] [ebp-1C0h]
  _WORD v38[3]; // [esp+200h] [ebp-1BCh]
  int v39; // [esp+206h] [ebp-1B6h]
  int v40; // [esp+20Ah] [ebp-1B2h]
  char v41; // [esp+20Eh] [ebp-1AEh]
  int v42; // [esp+2BEh] [ebp-FEh]
  int v43; // [esp+2C2h] [ebp-FAh]
  char v44[105]; // [esp+2C8h] [ebp-F4h] BYREF
  char v45[105]; // [esp+334h] [ebp-88h] BYREF
  int v46; // [esp+3A0h] [ebp-1Ch]
  _DWORD *v47; // [esp+3A4h] [ebp-18h]
  unsigned int count; // [esp+3A8h] [ebp-14h]

  count = a2;
  v46 = a1 + 0xAB;
  v47 = (_DWORD *)(a1 + 0x9E);
  if ( a3 == 0xFFFFFFFF )
  {
    sub_48B90(v15);
    sub_1BF94((P_Type1)count, v15, 0x162u);
    *(_DWORD *)a1 = v15[0];
    *(_DWORD *)(a1 + 4) = v15[1];
    *(_DWORD *)(a1 + 8) = v15[2];
    *(_DWORD *)(a1 + 0xC) = v15[3];
    *(_DWORD *)(a1 + 0x10) = v15[4];
    *(_DWORD *)(a1 + 0x14) = v15[5];
    *(_DWORD *)(a1 + 0x18) = v15[6];
    *(_DWORD *)(a1 + 0x1C) = v15[7];
    *(_DWORD *)(a1 + 0x20) = v15[8];
    *(_DWORD *)(a1 + 0x24) = v15[9];
    *(_DWORD *)(a1 + 0x28) = v15[0xA];
    *(_DWORD *)(a1 + 0x2C) = v15[0xB];
    *(_DWORD *)(a1 + 0x30) = v15[0xC];
    qmemcpy((void *)(a1 + 0x34), v16, 0x1Cu);
    *(_WORD *)(a1 + 0x50) = v17;
    *(_DWORD *)(a1 + 0x52) = v18;
    *(_WORD *)(a1 + 0x56) = *(_WORD *)v19;
    *(_BYTE *)(a1 + 0x58) = v19[2];
    *(_DWORD *)(a1 + 0x59) = *(_DWORD *)&v19[3];
    *(_BYTE *)(a1 + 0x5D) = v20;
    *(_DWORD *)(a1 + 0x5E) = v21;
    *(_BYTE *)(a1 + 0x62) = v22;
    *(_DWORD *)(a1 + 0x63) = v23;
    *(_BYTE *)(a1 + 0x67) = v24;
    *(_DWORD *)(a1 + 0x68) = v25;
    *(_DWORD *)(a1 + 0x6C) = v26;
    *(_DWORD *)(a1 + 0x70) = v27;
    *(_DWORD *)(a1 + 0x74) = v28;
    *(_DWORD *)(a1 + 0x78) = v29;
    *(_DWORD *)(a1 + 0x7C) = v30;
    *(_DWORD *)(a1 + 0x80) = v31;
    *(_DWORD *)(a1 + 0x84) = v32;
    *(_DWORD *)(a1 + 0x88) = v33;
    *(_DWORD *)(a1 + 0x8C) = v34;
    *(_DWORD *)(a1 + 0x90) = v35;
    *(_DWORD *)(a1 + 0x94) = v36;
    *(_DWORD *)(a1 + 0x98) = v37;
    *(_WORD *)(a1 + 0x9C) = v38[0];
    v4 = v47;
    *v47 = *(_DWORD *)&v38[1];
    v4[1] = v39;
    v4[2] = v40;
    *(_BYTE *)(a1 + 0xAA) = v41;
    _wcpp_2_assign_array_(sub_4B780);
    *(_DWORD *)(a1 + 0x15A) = v42;
    *(_DWORD *)(a1 + 0x15E) = v43;
    switch ( *(_BYTE *)(a1 + 0x5D) )
    {
      case 0:
      case 7:
        *(_DWORD *)(a1 + 0x5E) = 0;
        break;
      case 1:
        *(_DWORD *)(a1 + 0x5E) = &word_A3D21[0x30 * *(_DWORD *)(a1 + 0x5E)];
        break;
      case 2:
      case 3:
        *(_DWORD *)(a1 + 0x5E) = (char *)&unk_BB1B3 + 0x7B * *(_DWORD *)(a1 + 0x5E);
        break;
      case 4:
      case 5:
      case 6:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x642);
      default:
        Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x647);
    }
    v5 = *(_BYTE *)(a1 + 0x58);
    if ( v5 < 3u )
    {
      if ( !v5 )
      {
LABEL_16:
        qmemcpy(v45, "InVoid", sizeof(v45));
        sub_2620C("Bad m_LocationType: %s", (char)&v45[0xF * *(_BYTE *)(a1 + 0x58)]);
        sub_261B8(0, "..\\ship.cpp", 0x67A);
        LODWORD(result) = v15;
        HIDWORD(result) = 0;
        return result;
      }
    }
    else
    {
      if ( v5 > 4u )
      {
        if ( v5 == 5 )
        {
          *(_DWORD *)(a1 + 0x59) = (char *)&unk_A62A3 + 0x27 * *(_DWORD *)(a1 + 0x59);
          LODWORD(result) = v15;
          HIDWORD(result) = 0;
          return result;
        }
        goto LABEL_16;
      }
      if ( v5 == 4 )
      {
        *(_DWORD *)(a1 + 0x59) = &word_A3D21[0x30 * *(_DWORD *)(a1 + 0x59)];
        LODWORD(result) = v15;
        HIDWORD(result) = 0;
        return result;
      }
    }
    *(_DWORD *)(a1 + 0x59) = (char *)&unk_BB1B3 + 0x7B * *(_DWORD *)(a1 + 0x59);
    LODWORD(result) = v15;
    HIDWORD(result) = 0;
    return result;
  }
  v9[0] = *(_DWORD *)a1;
  v9[1] = *(_DWORD *)(a1 + 4);
  v9[2] = *(_DWORD *)(a1 + 8);
  v9[3] = *(_DWORD *)(a1 + 0xC);
  v9[4] = *(_DWORD *)(a1 + 0x10);
  v9[5] = *(_DWORD *)(a1 + 0x14);
  v9[6] = *(_DWORD *)(a1 + 0x18);
  v9[7] = *(_DWORD *)(a1 + 0x1C);
  v9[8] = *(_DWORD *)(a1 + 0x20);
  v9[9] = *(_DWORD *)(a1 + 0x24);
  v9[0xA] = *(_DWORD *)(a1 + 0x28);
  v9[0xB] = *(_DWORD *)(a1 + 0x2C);
  v9[0xC] = *(_DWORD *)(a1 + 0x30);
  qmemcpy(v10, (const void *)(a1 + 0x34), 0x6Au);
  *(_DWORD *)&v10[0x35] = *v47;
  *(_DWORD *)&v10[0x37] = v47[1];
  *(_DWORD *)&v10[0x39] = v47[2];
  v11 = *(_BYTE *)(a1 + 0xAA);
  _wcpp_2_copy_array_(v12, v46, 0x19, &unk_96038);
  v13 = *(_DWORD *)(a1 + 0x15A);
  v14 = *(_DWORD *)(a1 + 0x15E);
  switch ( *(_BYTE *)(a1 + 0x5D) )
  {
    case 0:
    case 7:
      break;
    case 1:
      *(_DWORD *)&v10[0x15] = *(__int16 *)(*(_DWORD *)(a1 + 0x5E) + 4);
      break;
    case 2:
    case 3:
      *(_DWORD *)&v10[0x15] = (*(_DWORD *)(a1 + 0x5E) - (int)&unk_BB1B3) / 0x7B;
      break;
    case 4:
    case 5:
    case 6:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x6A7);
    default:
      Q_AssertLogBreakExit_sub_261A8(0, "..\\ship.cpp", 0x6AC);
  }
  switch ( *(_BYTE *)(a1 + 0x58) )
  {
    case 1:
    case 2:
      *(_DWORD *)((char *)&v10[0x12] + 1) = (*(_DWORD *)(a1 + 0x59) - (int)&unk_BB1B3) / 0x7B;
      break;
    case 3:
      v7 = *(_DWORD *)(a1 + 0x59);
      if ( !v7 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x6C0);
      }
      *(_DWORD *)((char *)&v10[0x12] + 1) = (v7 - (int)&unk_BB1B3) / 0x7B;
      break;
    case 4:
      *(_DWORD *)((char *)&v10[0x12] + 1) = *(__int16 *)(*(_DWORD *)(a1 + 0x59) + 4);
      break;
    case 5:
      v8 = *(_DWORD *)(a1 + 0x59);
      if ( !v8 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ship.cpp", 0x6CF);
      }
      *(_DWORD *)((char *)&v10[0x12] + 1) = (v8 - (int)&unk_A62A3) / 0x27;
      break;
    default:
      qmemcpy(v44, "InVoid", sizeof(v44));
      sub_2620C("Bad m_LocationType: %s", (char)&v44[0xF * *(_BYTE *)(a1 + 0x58)]);
      sub_261B8(0, "..\\ship.cpp", 0x6EE);
      break;
  }
  sub_1C098(count, (int)v9, 0x162u);
  LODWORD(result) = v9;
  HIDWORD(result) = 0;
  return result;
}
// 78B30: using guessed type _DWORD __stdcall _wcpp_2_assign_array_(_DWORD);
// 78B54: using guessed type int __fastcall _wcpp_2_copy_array_(_DWORD, _DWORD, _DWORD, _DWORD);
// A3D21: using guessed type __int16 word_A3D21[];
// 4AE8C: using guessed type char var_311[175];

//----- (0004B5C0) --------------------------------------------------------
int __fastcall sub_4B5C0(int result, int a2)
{
  *(_BYTE *)result = *(_BYTE *)a2;
  *(_WORD *)(result + 1) = *(_WORD *)(a2 + 1);
  *(_DWORD *)(result + 3) = *(_DWORD *)(a2 + 3);
  return result;
}

//----- (0004B5E0) --------------------------------------------------------
int __fastcall sub_4B5E0(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // eax
  int result; // eax

  *a1 = *(_DWORD *)a2;
  a1[1] = *(_DWORD *)(a2 + 4);
  a1[2] = *(_DWORD *)(a2 + 8);
  a1[3] = *(_DWORD *)(a2 + 0xC);
  a1[4] = *(_DWORD *)(a2 + 0x10);
  a1[5] = *(_DWORD *)(a2 + 0x14);
  a1[6] = *(_DWORD *)(a2 + 0x18);
  a1[7] = *(_DWORD *)(a2 + 0x1C);
  a1[8] = *(_DWORD *)(a2 + 0x20);
  a1[9] = *(_DWORD *)(a2 + 0x24);
  a1[0xA] = *(_DWORD *)(a2 + 0x28);
  a1[0xB] = *(_DWORD *)(a2 + 0x2C);
  a1[0xC] = *(_DWORD *)(a2 + 0x30);
  qmemcpy(a1 + 0xD, (const void *)(a2 + 0x34), 0x29u);
  v2 = (char *)a1 + 0x59;
  v2[4] = *(_BYTE *)(a2 + 0x5D);
  v2 += 4;
  *(_DWORD *)(v2 + 1) = *(_DWORD *)(a2 + 0x5E);
  v2[5] = *(_BYTE *)(a2 + 0x62);
  *(_DWORD *)(v2 + 6) = *(_DWORD *)(a2 + 0x63);
  v2[0xA] = *(_BYTE *)(a2 + 0x67);
  *(_DWORD *)(v2 + 0xB) = *(_DWORD *)(a2 + 0x68);
  *(_DWORD *)(v2 + 0xF) = *(_DWORD *)(a2 + 0x6C);
  *(_DWORD *)(v2 + 0x13) = *(_DWORD *)(a2 + 0x70);
  *(float *)(v2 + 0x17) = *(float *)(a2 + 0x74);
  *(_DWORD *)(v2 + 0x1B) = *(_DWORD *)(a2 + 0x78);
  *(_DWORD *)(v2 + 0x1F) = *(_DWORD *)(a2 + 0x7C);
  *(_DWORD *)(v2 + 0x23) = *(_DWORD *)(a2 + 0x80);
  *(_DWORD *)(v2 + 0x27) = *(_DWORD *)(a2 + 0x84);
  v2 += 0xFFFFFFA3;
  *((_DWORD *)v2 + 0x22) = *(_DWORD *)(a2 + 0x88);
  *((_DWORD *)v2 + 0x23) = *(_DWORD *)(a2 + 0x8C);
  *((_DWORD *)v2 + 0x24) = *(_DWORD *)(a2 + 0x90);
  *((_DWORD *)v2 + 0x25) = *(_DWORD *)(a2 + 0x94);
  *((_DWORD *)v2 + 0x26) = *(_DWORD *)(a2 + 0x98);
  *((_WORD *)v2 + 0x4E) = *(_WORD *)(a2 + 0x9C);
  v2 += 0x9E;
  *(_DWORD *)v2 = *(_DWORD *)(a2 + 0x9E);
  *((_DWORD *)v2 + 1) = *(_DWORD *)(a2 + 0xA2);
  *((_DWORD *)v2 + 2) = *(_DWORD *)(a2 + 0xA6);
  v2 += 0xFFFFFF62;
  v2[0xAA] = *(_BYTE *)(a2 + 0xAA);
  v3 = _wcpp_2_copy_array_(v2 + 0xAB, a2 + 0xAB, 0x19, &unk_96038);
  *(_DWORD *)(v3 + 0xAF) = *(_DWORD *)(a2 + 0x15A);
  result = v3 - 0xAB;
  *(_DWORD *)(result + 0x15E) = *(_DWORD *)(a2 + 0x15E);
  return result;
}
// 78B54: using guessed type int __fastcall _wcpp_2_copy_array_(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004B780) --------------------------------------------------------
int __fastcall sub_4B780(int result, int a2)
{
  *(_BYTE *)result = *(_BYTE *)a2;
  *(_WORD *)(result + 1) = *(_WORD *)(a2 + 1);
  *(_DWORD *)(result + 3) = *(_DWORD *)(a2 + 3);
  return result;
}

//----- (0004B7A0) --------------------------------------------------------
int __fastcall sub_4B7A0(int a1, int a2, int a3, __int16 a4)
{
  int v5; // edi
  int v6; // ebp
  int v7; // ebx
  char v8; // dh
  __int16 *v9; // ecx
  int v10; // ebx
  int v11; // ebx
  int v12; // edx
  int v13; // ebx
  int v16; // [esp+Ch] [ebp-14h]

  v16 = 0;
  if ( a4 < 0 || a4 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x2F);
  }
  if ( *(__int16 *)(a1 + 0x56) < 0 || SHIWORD(dword_A3CF2) <= *(__int16 *)(a1 + 0x56) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x30);
  }
  v5 = a3;
  v6 = 0;
  if ( (*(_WORD *)(a1 + 0x9C) & 0x10) != 0 )
  {
    v5 = 0;
  }
  v7 = *(_DWORD *)(a1 + 0x90);
  if ( v5 > v7 )
  {
    v5 = *(_DWORD *)(a1 + 0x90);
    v6 = a3 - v7;
    LOBYTE(v16) = 2;
  }
  if ( v6 >= *(_DWORD *)(a1 + 0x8C) )
  {
    v6 = *(_DWORD *)(a1 + 0x8C);
    LOBYTE(v16) = v16 | 4;
  }
  if ( a2 == 1 )
  {
    v8 = *(_BYTE *)(a1 + 0x58);
    v9 = 0;
    if ( v8 == 4 )
    {
      v9 = *(__int16 **)(a1 + 0x59);
    }
    else if ( v8 == 3 || v8 == 1 || v8 == 2 )
    {
      v9 = &word_A3D21[0x30 * *(__int16 *)(*(_DWORD *)(a1 + 0x59) + 0xC)];
    }
    if ( !v9 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x53);
    }
    sub_433E0((int)&byte_A2F72[0x1EE * *(__int16 *)(a1 + 0x56)], a4, (int)v9);
    v10 = *(_DWORD *)(a1 + 0x8C) - v6;
    *(_DWORD *)(a1 + 0x90) -= v5;
    *(_DWORD *)(a1 + 0x8C) = v10;
    if ( v10 < 1 )
    {
      v11 = *(_DWORD *)(a1 + 0xA7);
      v12 = *(_DWORD *)(a1 + 0x54);
      sub_49940(a1);
      v13 = v11 >> 0x18;
      if ( v12 >> 0x10 == (unsigned __int8)byte_104BEA && *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] != 0x10 )
      {
        sub_55AEC((int)&V_Type3_stru_10AE70, 0xC, v13, (int)v9);
      }
    }
  }
  return v16;
}
// A3CF2: using guessed type int dword_A3CF2;
// A3D21: using guessed type __int16 word_A3D21[];

//----- (0004B944) --------------------------------------------------------
int __fastcall sub_4B944(int a1, int a2)
{
  _BYTE *v3; // eax
  unsigned int v4; // ecx
  char *v5; // edi
  int v6; // esi
  double v7; // st7
  __int16 v8; // ax
  BOOL v9; // eax
  int v10; // ebx
  int v11; // eax
  double v13; // st7
  double v14; // st7
  double v15; // st7
  double v16; // st7
  double v17; // st7
  int v18; // eax
  unsigned int v19; // edx
  int v20; // ebx
  double v21; // st7
  double v22; // st7
  double v23; // st7
  int v24; // ebx
  int v25; // eax
  int v26; // esi
  int v27; // eax
  int v28; // eax
  int v29; // ebp
  float *v30; // ebx
  unsigned int v31; // edx
  int v32; // ecx
  double v33; // st7
  double v34; // st7
  int v35; // ecx
  int v36; // ebx
  int v37; // ebp
  int v38; // eax
  int v39; // edx
  int v40; // ebx
  char v41; // cl
  _BYTE *v42; // eax
  int v43; // ebp
  int i; // edx
  int v45; // eax
  char v46; // ch
  _BYTE *v47; // edx
  int v48; // ebp
  int v49; // eax
  int v50; // ebx
  char v51; // bh
  int v52; // edi
  int v53; // ebx
  _BYTE *v54; // ecx
  char v55; // dh
  int v56; // edx
  char v57; // al
  float *v58; // ebx
  float *v59; // edx
  char v60; // ch
  float x_4; // [esp+4h] [ebp-524h]
  int v62[107]; // [esp+8h] [ebp-520h] BYREF
  int v63[132]; // [esp+1B4h] [ebp-374h] BYREF
  float v64; // [esp+3C4h] [ebp-164h] BYREF
  float v65; // [esp+3C8h] [ebp-160h]
  float v66; // [esp+3CCh] [ebp-15Ch]
  float v67; // [esp+3D0h] [ebp-158h] BYREF
  float v68; // [esp+3D4h] [ebp-154h]
  float v69; // [esp+3D8h] [ebp-150h]
  float v70; // [esp+3DCh] [ebp-14Ch] BYREF
  float v71; // [esp+3E0h] [ebp-148h]
  float v72; // [esp+3E4h] [ebp-144h]
  float v73; // [esp+3E8h] [ebp-140h]
  float v74; // [esp+3ECh] [ebp-13Ch]
  float v75; // [esp+3F0h] [ebp-138h]
  float v76; // [esp+3F4h] [ebp-134h] BYREF
  float v77; // [esp+3F8h] [ebp-130h]
  float v78; // [esp+3FCh] [ebp-12Ch]
  float v79; // [esp+400h] [ebp-128h]
  float v80; // [esp+404h] [ebp-124h]
  float v81; // [esp+408h] [ebp-120h]
  float v82; // [esp+40Ch] [ebp-11Ch] BYREF
  float v83; // [esp+410h] [ebp-118h]
  float v84; // [esp+414h] [ebp-114h]
  float v85; // [esp+418h] [ebp-110h]
  float v86; // [esp+41Ch] [ebp-10Ch]
  float v87; // [esp+420h] [ebp-108h]
  float v88; // [esp+424h] [ebp-104h] BYREF
  float v89; // [esp+428h] [ebp-100h]
  float v90; // [esp+42Ch] [ebp-FCh]
  float v91; // [esp+430h] [ebp-F8h]
  float v92; // [esp+434h] [ebp-F4h]
  float v93; // [esp+438h] [ebp-F0h]
  float v94; // [esp+43Ch] [ebp-ECh]
  float v95; // [esp+440h] [ebp-E8h]
  float v96; // [esp+444h] [ebp-E4h]
  int v97[3]; // [esp+448h] [ebp-E0h] BYREF
  float v98; // [esp+454h] [ebp-D4h]
  float v99; // [esp+458h] [ebp-D0h]
  float v100; // [esp+45Ch] [ebp-CCh]
  float v101; // [esp+460h] [ebp-C8h] BYREF
  float v102; // [esp+464h] [ebp-C4h]
  float v103; // [esp+468h] [ebp-C0h]
  float v104; // [esp+46Ch] [ebp-BCh]
  float v105; // [esp+470h] [ebp-B8h]
  float v106; // [esp+474h] [ebp-B4h]
  float v107; // [esp+478h] [ebp-B0h]
  float v108; // [esp+47Ch] [ebp-ACh]
  float v109; // [esp+480h] [ebp-A8h]
  float v110; // [esp+484h] [ebp-A4h]
  float v111; // [esp+488h] [ebp-A0h]
  float v112; // [esp+48Ch] [ebp-9Ch]
  float v113; // [esp+490h] [ebp-98h] BYREF
  float v114; // [esp+494h] [ebp-94h]
  float v115; // [esp+498h] [ebp-90h]
  float v116; // [esp+49Ch] [ebp-8Ch]
  int v117; // [esp+4A0h] [ebp-88h]
  int v118; // [esp+4A4h] [ebp-84h]
  int *v119; // [esp+4A8h] [ebp-80h]
  float *v120; // [esp+4ACh] [ebp-7Ch]
  float *v121; // [esp+4B0h] [ebp-78h]
  float *v122; // [esp+4B4h] [ebp-74h]
  float *v123; // [esp+4B8h] [ebp-70h]
  float *v124; // [esp+4BCh] [ebp-6Ch]
  float *v125; // [esp+4C0h] [ebp-68h]
  float *v126; // [esp+4C8h] [ebp-60h]
  float *v127; // [esp+4CCh] [ebp-5Ch]
  int v128; // [esp+4D0h] [ebp-58h]
  int v129; // [esp+4D4h] [ebp-54h]
  int v130; // [esp+4D8h] [ebp-50h]
  float v131; // [esp+4DCh] [ebp-4Ch]
  float v132; // [esp+4E0h] [ebp-48h]
  float v133; // [esp+4E4h] [ebp-44h]
  int v134; // [esp+4E8h] [ebp-40h]
  int v135; // [esp+4ECh] [ebp-3Ch]
  int v136; // [esp+4F0h] [ebp-38h]
  float v137; // [esp+4F4h] [ebp-34h]
  float v138; // [esp+4F8h] [ebp-30h]
  float v139; // [esp+4FCh] [ebp-2Ch]
  float v140; // [esp+500h] [ebp-28h]
  int v141; // [esp+508h] [ebp-20h]
  char v142; // [esp+50Ch] [ebp-1Ch]
  char v143; // [esp+510h] [ebp-18h]

  v129 = a2;
  v3 = *(_BYTE **)(a1 + 0x63);
  v134 = 0;
  v128 = 0xFFFFFFFF;
  v4 = 0xFFFFFFFF;
  LOBYTE(v3) = *v3;
  v130 = 0;
  v142 = (char)v3;
  if ( (_BYTE)v3 == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0xA2);
  }
  v5 = (char *)&unk_107020 + 0x6A * v142;
  if ( *(_DWORD *)(v5 + 0x36) > *(_DWORD *)(a1 + 0x88) )
  {
    v128 = 0;
  }
  else
  {
    v130 = *(_DWORD *)(v5 + 0x36);
  }
  v6 = *(_DWORD *)(a1 + 0x68);
  if ( !v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0xAD);
  }
  if ( *(_BYTE *)(a1 + 0x58) != 4 || *(_BYTE *)(v6 + 0x58) != 4 || *(_DWORD *)(a1 + 0x59) != *(_DWORD *)(v6 + 0x59) )
  {
    goto LABEL_18;
  }
  if ( *(_DWORD *)(v5 + 0x3A) )
  {
    v119 = v97;
    v104 = 0.0;
    v105 = 0.0;
    v106 = 0.0;
    v104 = *(float *)(v6 + 0x9E) - *(float *)(a1 + 0x9E);
    v105 = *(float *)(v6 + 0xA2) - *(float *)(a1 + 0xA2);
    v106 = *(float *)(v6 + 0xA6) - *(float *)(a1 + 0xA6);
    *(float *)v97 = v104;
    *(float *)&v97[1] = v105;
    *(float *)&v97[2] = v106;
    v7 = sqrt(v105 * v105 + v104 * v104 + v106 * v106);
    v141 = 0x20 * *(_DWORD *)(v5 + 0x3A);
    v8 = *(_WORD *)(a1 + 0x9C);
    v131 = v7;
    v133 = (float)v141;
    if ( (v8 & 4) != 0 )
    {
      v133 = v133 * flt_928C7;
    }
    if ( v131 > (double)v133 )
    {
      v4 = 0;
    }
    if ( v142 == 0x2F && v133 * dbl_928CB > v131 )
    {
LABEL_18:
      v4 = 0;
    }
  }
  v9 = v128 && v4 && v6 != a1 && (*(_WORD *)(v5 + 0x33) & 1) != 0;
  v134 |= v9;
  if ( (v134 & 1) == 0 )
  {
    return v134;
  }
  *(_DWORD *)(a1 + 0x78) = *(_DWORD *)(v6 + 0x9E);
  *(_DWORD *)(a1 + 0x7C) = *(_DWORD *)(v6 + 0xA2);
  *(_DWORD *)(a1 + 0x80) = *(_DWORD *)(v6 + 0xA6);
  v10 = 0;
  if ( !v5[0x32] )
  {
    v10 = *(_DWORD *)(v5 + 0x52);
  }
  if ( v142 == 0x2F )
  {
    v10 = *(_DWORD *)(v5 + 0x4A);
  }
  if ( v10 )
  {
    v11 = sub_4B7A0(v6, v129, v10, *(_WORD *)(a1 + 0x56));
    v134 |= v11;
  }
  else
  {
    LOBYTE(v134) = v134 | 0x10;
  }
  if ( v129 != 1 )
  {
    return v134;
  }
  v56 = *(_DWORD *)(a1 + 0x88) - v130;
  v57 = v142;
  *(_DWORD *)(a1 + 0x88) = v56;
  if ( (unsigned __int8)v57 < 0x32u )
  {
    if ( (unsigned __int8)v57 < 0x25u )
    {
      if ( (unsigned __int8)v57 >= 0x22u )
      {
        if ( (unsigned __int8)v57 <= 0x22u )
        {
          *(_DWORD *)(v6 + 0x52) = dword_A2F6C[0];
          return v134;
        }
        else
        {
          if ( v57 == 0x23 )
          {
            *(_DWORD *)(v6 + 0x88) = 0;
          }
          return v134;
        }
      }
      if ( v57 == 0x21 )
      {
        v55 = *(_BYTE *)(v6 + 0x9C);
        *(_DWORD *)(v6 + 0x94) = 0;
        *(_BYTE *)(v6 + 0x9C) = v55 | 1;
        return v134;
      }
      return v134;
    }
    if ( (unsigned __int8)v57 > 0x25u )
    {
      if ( (unsigned __int8)v57 < 0x2Du )
      {
        if ( v57 != 0x28 )
        {
          return v134;
        }
        v28 = sub_1D794(*(__int16 **)(a1 + 0x59), v62);
        v29 = 0;
        if ( v28 > 0 )
        {
          v30 = (float *)(v6 + 0x9E);
          v31 = 0;
          v135 = 4 * v28;
          do
          {
            v32 = v62[v31 / 4];
            if ( v6 != v32 )
            {
              v125 = &v82;
              v79 = 0.0;
              v80 = 0.0;
              v81 = 0.0;
              v79 = *(float *)(v32 + 0x9E) - *v30;
              v80 = *(float *)(v32 + 0xA2) - *(float *)(v6 + 0xA2);
              v81 = *(float *)(v32 + 0xA6) - *(float *)(v6 + 0xA6);
              v82 = v79;
              v83 = v80;
              v84 = v81;
              v33 = sqrt(v80 * v80 + v79 * v79 + v81 * v81);
              v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
              v137 = (float)v141;
              if ( v33 < v137 )
              {
                sub_53054(&v82, v137);
                v91 = 0.0;
                v92 = 0.0;
                v93 = 0.0;
                v123 = &v70;
                v91 = *v30 + v82;
                v92 = *(float *)(v6 + 0xA2) + v83;
                v34 = *(float *)(v6 + 0xA6);
                v70 = v91;
                v93 = v34 + v84;
                v71 = v92;
                v35 = v62[v31 / 4];
                v72 = v93;
                *(float *)(v35 + 0x9E) = v91;
                *(float *)(v35 + 0xA2) = v71;
                *(float *)(v35 + 0xA6) = v72;
              }
            }
            v31 += 4;
            ++v29;
          }
          while ( (int)v31 < v135 );
        }
      }
      else
      {
        if ( (unsigned __int8)v57 <= 0x2Du )
        {
          v121 = &v64;
          v94 = 0.0;
          v95 = 0.0;
          v96 = 0.0;
          v94 = *(float *)(v6 + 0x9E) - *(float *)(a1 + 0x9E);
          v95 = *(float *)(v6 + 0xA2) - *(float *)(a1 + 0xA2);
          v13 = *(float *)(v6 + 0xA6) - *(float *)(a1 + 0xA6);
          v64 = v94;
          v96 = v13;
          v65 = v95;
          v66 = v96;
          v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
          x_4 = (float)v141;
          sub_53054(&v64, x_4);
          v120 = &v76;
          v110 = 0.0;
          v111 = 0.0;
          v112 = 0.0;
          v110 = *(float *)(v6 + 0x9E) + v64;
          v111 = *(float *)(v6 + 0xA2) + v65;
          v14 = *(float *)(v6 + 0xA6) + v66;
          v76 = v110;
          v112 = v14;
          v77 = v111;
          v78 = v112;
          *(float *)(v6 + 0x9E) = v110;
          *(float *)(v6 + 0xA2) = v77;
          *(float *)(v6 + 0xA6) = v78;
          return v134;
        }
        if ( (unsigned __int8)v57 >= 0x30u )
        {
          if ( (unsigned __int8)v57 > 0x30u )
          {
            v60 = *(_BYTE *)(v6 + 0x9C);
            *(_DWORD *)(v6 + 0x90) = 0;
            *(_BYTE *)(v6 + 0x9C) = v60 | 8;
            return v134;
          }
          v52 = *(_DWORD *)(v6 + 0x15A);
          v53 = 0;
          v54 = (_BYTE *)(v6 + 0xAB);
          while ( v53 < v52 )
          {
            if ( *v54 == 0x47 || *v54 == 0x49 )
            {
              sub_492F8((_DWORD *)v6, v53);
            }
            ++v53;
            v52 = *(_DWORD *)(v6 + 0x15A);
            v54 += 7;
          }
        }
      }
      return v134;
    }
LABEL_84:
    v143 = 0;
    if ( v142 == 0x42 )
    {
      v143 = 5;
    }
    v47 = (_BYTE *)(v6 + 0xAB);
    v48 = 0;
    v49 = 0;
    if ( *(int *)(v6 + 0x15A) > 0 )
    {
      v50 = 0;
      do
      {
        if ( *v47 != 0xFF && byte_107052[0x6A * (char)*v47] == v143 )
        {
          ++v50;
          ++v48;
          v63[v50 + 0x6A] = v49;
        }
        ++v49;
        v47 += 7;
      }
      while ( v49 < *(_DWORD *)(v6 + 0x15A) );
    }
    if ( v48 )
    {
      sub_492F8((_DWORD *)v6, v63[dword_A2F6C[0] % v48 + 0x6B]);
      return v134;
    }
    return v134;
  }
  if ( (unsigned __int8)v57 <= 0x32u )
  {
LABEL_74:
    v41 = 5;
    if ( v142 == 0x32 )
    {
      v41 = 0;
    }
    v42 = (_BYTE *)(v6 + 0xAB);
    v43 = 0;
    for ( i = 0; i < *(_DWORD *)(v6 + 0x15A); v42 += 7 )
    {
      if ( *v42 != 0xFF && v41 == byte_107052[0x6A * (char)*v42] )
      {
        ++v43;
      }
      ++i;
    }
    v45 = *(_DWORD *)(v6 + 0x8C) - v43;
    *(_DWORD *)(v6 + 0x8C) = v45;
    if ( v45 < 1 )
    {
      v46 = v134 | 4;
      sub_49940(v6);
      LOBYTE(v134) = v46;
      return v134;
    }
    return v134;
  }
  v58 = (float *)(v6 + 0x9E);
  if ( (unsigned __int8)v57 < 0x3Du )
  {
    v59 = (float *)(a1 + 0x9E);
    if ( (unsigned __int8)v57 < 0x36u )
    {
      if ( v57 != 0x34 )
      {
        return v134;
      }
      v126 = &v113;
      v73 = 0.0;
      v74 = 0.0;
      v75 = 0.0;
      v73 = *v58 - *v59;
      v74 = *(float *)(v6 + 0xA2) - *(float *)(a1 + 0xA2);
      v75 = *(float *)(v6 + 0xA6) - *(float *)(a1 + 0xA6);
      v113 = v73;
      v114 = v74;
      v115 = v75;
      v15 = sqrt(v74 * v74 + v73 * v73 + v75 * v75);
      v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
      v16 = v15 - (double)v141;
      v132 = v16;
      if ( v16 < flt_928D3 )
      {
        v132 = 64.0;
      }
      sub_53054(&v113, v132);
      v98 = 0.0;
      v99 = 0.0;
      v100 = 0.0;
      v127 = &v101;
      v98 = *(float *)(a1 + 0x9E) + v113;
      v99 = *(float *)(a1 + 0xA2) + v114;
      v17 = *(float *)(a1 + 0xA6);
      v101 = v98;
      v100 = v17 + v115;
      v102 = v99;
      v103 = v100;
      *(float *)(v6 + 0x9E) = v98;
      *(float *)(v6 + 0xA2) = v102;
      *(float *)(v6 + 0xA6) = v103;
      return v134;
    }
    if ( (unsigned __int8)v57 > 0x36u )
    {
      if ( (unsigned __int8)v57 <= 0x37u )
      {
        v116 = *v59;
        v117 = *(_DWORD *)(a1 + 0xA2);
        v118 = *(_DWORD *)(a1 + 0xA6);
        *v59 = *v58;
        *(_DWORD *)(a1 + 0xA2) = *(_DWORD *)(v6 + 0xA2);
        *(_DWORD *)(a1 + 0xA6) = *(_DWORD *)(v6 + 0xA6);
        *v58 = v116;
        *(_DWORD *)(v6 + 0xA2) = v117;
        *(_DWORD *)(v6 + 0xA6) = v118;
        return v134;
      }
      if ( v57 != 0x3B )
      {
        return v134;
      }
      v25 = *(_DWORD *)(v6 + 0x98) - *(_DWORD *)(v6 + 0x8C);
      if ( v25 > *(_DWORD *)(v5 + 0x4A) )
      {
        v25 = *(_DWORD *)(v5 + 0x4A);
      }
      *(_DWORD *)(v6 + 0x8C) += v25;
      v26 = *(_DWORD *)(a1 + 0x8C) - v25;
      *(_DWORD *)(a1 + 0x8C) = v26;
      if ( v26 < 1 )
      {
        sub_49940(a1);
        return v134;
      }
      return v134;
    }
    goto LABEL_74;
  }
  if ( (unsigned __int8)v57 <= 0x3Du )
  {
    sub_49940(v6);
    v51 = v134 | 4;
    sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - (a1 + 0xAB)) / 7);
    LOBYTE(v134) = v51;
    return v134;
  }
  if ( (unsigned __int8)v57 < 0x42u )
  {
    if ( v57 != 0x40 )
    {
      return v134;
    }
    v36 = *(_DWORD *)(v6 + 0x15E);
    if ( !v36 )
    {
      return v134;
    }
    v37 = dword_A2F6C[0] % v36;
    v38 = 0;
    v39 = 0;
    if ( *(int *)(v6 + 0x15A) <= 0 )
    {
      return v134;
    }
    v40 = v6;
    do
    {
      if ( *(_BYTE *)(v40 + 0xAB) != 0xFF )
      {
        if ( v39 == v37 )
        {
          sub_492F8((_DWORD *)v6, v38);
          return v134;
        }
        ++v39;
      }
      ++v38;
      v40 += 7;
    }
    while ( v38 < *(_DWORD *)(v6 + 0x15A) );
    return v134;
  }
  if ( (unsigned __int8)v57 <= 0x42u )
  {
    goto LABEL_84;
  }
  if ( (unsigned __int8)v57 < 0x44u )
  {
    return v134;
  }
  if ( (unsigned __int8)v57 > 0x44u )
  {
    if ( v57 != 0x4A )
    {
      return v134;
    }
    v18 = sub_1D794(*(__int16 **)(a1 + 0x59), v63);
    if ( v18 > 0 )
    {
      v19 = 0;
      v136 = 4 * v18;
      do
      {
        v20 = v63[v19 / 4];
        if ( v6 != v20 )
        {
          v122 = &v88;
          v107 = 0.0;
          v108 = 0.0;
          v109 = 0.0;
          v107 = *(float *)(v20 + 0x9E) - *(float *)(v6 + 0x9E);
          v108 = *(float *)(v20 + 0xA2) - *(float *)(v6 + 0xA2);
          v109 = *(float *)(v20 + 0xA6) - *(float *)(v6 + 0xA6);
          v88 = v107;
          v89 = v108;
          v90 = v109;
          v21 = sqrt(v108 * v108 + v107 * v107 + v109 * v109);
          v141 = 0x20 * *(_DWORD *)(v5 + 0x4E);
          v138 = v21;
          v139 = (float)v141;
          if ( v138 > (double)v139 )
          {
            v141 = 0x20 * *(_DWORD *)(v5 + 0x4A);
            v22 = v138 - (double)v141;
            v140 = v22;
            if ( v22 < v139 )
            {
              v140 = v139;
            }
            sub_53054(&v88, v140);
            v124 = &v67;
            v85 = 0.0;
            v86 = 0.0;
            v87 = 0.0;
            v85 = *(float *)(v6 + 0x9E) + v88;
            v86 = *(float *)(v6 + 0xA2) + v89;
            v23 = *(float *)(v6 + 0xA6);
            v67 = v85;
            v87 = v23 + v90;
            v68 = v86;
            v24 = v63[v19 / 4];
            v69 = v87;
            *(float *)(v24 + 0x9E) = v85;
            *(float *)(v24 + 0xA2) = v68;
            *(float *)(v24 + 0xA6) = v69;
          }
        }
        v19 += 4;
      }
      while ( (int)v19 < v136 );
    }
    return v134;
  }
  v27 = *(_DWORD *)(v6 + 0x18) - *(_DWORD *)(v6 + 0x88);
  if ( v27 > v56 )
  {
    v27 = v56;
  }
  *(_DWORD *)(v6 + 0x88) += v27;
  *(_DWORD *)(a1 + 0x88) -= v27;
  return v134;
}
// 928C7: using guessed type float flt_928C7;
// 928CB: using guessed type double dbl_928CB;
// 928D3: using guessed type float flt_928D3;
// A2F6C: using guessed type int dword_A2F6C[];

//----- (0004C7FC) --------------------------------------------------------
int __fastcall sub_4C7FC(int a1, int a2)
{
  char v2; // cl
  char *v3; // esi
  unsigned int v4; // edi
  int v5; // ebp
  int v6; // eax
  int v7; // ebp
  float *v8; // edx
  double v9; // st7
  __int16 v10; // ax
  BOOL v11; // eax
  unsigned __int8 *v13; // esi
  int v14; // edi
  __int64 v15; // [esp+8h] [ebp-60h]
  float v16; // [esp+10h] [ebp-58h]
  int v17[3]; // [esp+14h] [ebp-54h] BYREF
  float v18; // [esp+20h] [ebp-48h]
  float v19; // [esp+24h] [ebp-44h]
  float v20; // [esp+28h] [ebp-40h]
  int *v21; // [esp+2Ch] [ebp-3Ch]
  int v22; // [esp+30h] [ebp-38h]
  int v23; // [esp+34h] [ebp-34h]
  float v24; // [esp+38h] [ebp-30h]
  int v25; // [esp+3Ch] [ebp-2Ch]
  int v26; // [esp+40h] [ebp-28h]
  float v27; // [esp+44h] [ebp-24h]
  int v28; // [esp+48h] [ebp-20h]
  _DWORD *v29; // [esp+4Ch] [ebp-1Ch]
  int v30; // [esp+50h] [ebp-18h]

  v29 = (_DWORD *)a1;
  v23 = a2;
  v2 = **(_BYTE **)(a1 + 0x63);
  v28 = 0;
  v25 = 0;
  v3 = (char *)&unk_107020 + 0x6A * v2;
  v4 = 0xFFFFFFFF;
  v5 = *(_DWORD *)(a1 + 0x88);
  v6 = *(_DWORD *)(v3 + 0x36);
  v26 = 0xFFFFFFFF;
  if ( v6 > v5 )
  {
    v26 = 0;
  }
  else
  {
    v25 = v6;
  }
  v7 = v29[0x1A];
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x217);
  }
  v15 = *(_QWORD *)v7;
  v8 = (float *)v29;
  v16 = *(float *)(v7 + 8);
  *((_QWORD *)v29 + 0xF) = *(_QWORD *)v7;
  v8[0x20] = v16;
  if ( *(_DWORD *)(v3 + 0x3A) )
  {
    v21 = v17;
    v18 = 0.0;
    v19 = 0.0;
    v20 = 0.0;
    v18 = *(float *)&v15 - *(float *)((char *)v29 + 0x9E);
    v19 = *((float *)&v15 + 1) - *(float *)((char *)v29 + 0xA2);
    v20 = v16 - *(float *)((char *)v29 + 0xA6);
    *(float *)v17 = v18;
    *(float *)&v17[1] = v19;
    *(float *)&v17[2] = v20;
    v9 = sqrt(v19 * v19 + v18 * v18 + v20 * v20);
    v22 = 0x20 * *(_DWORD *)(v3 + 0x3A);
    v10 = *((_WORD *)v29 + 0x4E);
    v24 = v9;
    v27 = (float)v22;
    if ( (v10 & 4) != 0 )
    {
      v27 = v27 * flt_928E6;
    }
    if ( v24 > (double)v27 )
    {
      v4 = 0;
    }
    if ( v2 == 0x2F && v27 * dbl_928EA > v24 )
    {
      v4 = 0;
    }
  }
  v11 = v26 && v4 && (*(_WORD *)(v3 + 0x33) & 0xC) != 0;
  v28 |= v11;
  if ( (v28 & 1) == 0 || v23 != 1 )
  {
    return v28;
  }
  v29[0x22] -= v25;
  if ( !v3[0x32] )
  {
    sub_36A5C(v7, *(_DWORD *)(v3 + 0x52), *((_WORD *)v29 + 0x2B));
    return v28;
  }
  if ( v2 != 0x46 )
  {
    return v28;
  }
  v13 = *(unsigned __int8 **)(v7 + 0x10);
  v14 = 0;
  v30 = 0;
  while ( v14 < *(unsigned __int16 *)(v7 + 0x18) && v30 < 5 )
  {
    if ( *v13 != 0xFF
      && (*((_WORD *)v13 + 1) & 1) != 0
      && !(*(int *)((char *)&dword_103F9A[0xA * v13[1]] + 2) >> 0x18)
      && sub_34B0C(v15, LOBYTE(v16), v17[0]) == 0xFFFFFFFF )
    {
      ++v30;
    }
    ++v14;
    v13 += 4;
  }
  sub_492F8(v29, (*(_DWORD *)((char *)v29 + 0x63) - ((int)v29 + 0xAB)) / 7);
  return v28;
}
// 4CA5B: variable 'v15' is possibly undefined
// 4CA5B: variable 'v16' is possibly undefined
// 928E6: using guessed type float flt_928E6;
// 928EA: using guessed type double dbl_928EA;
// 103F9A: using guessed type int dword_103F9A[];

//----- (0004CAB8) --------------------------------------------------------
int __fastcall sub_4CAB8(int a1, int a2)
{
  unsigned __int8 v3; // cl
  char *v4; // ebp
  int v5; // edx
  int v6; // eax
  int v7; // esi
  double v8; // st7
  int v9; // eax
  BOOL v10; // eax
  float *v12; // eax
  float *v13; // edx
  float *v14; // eax
  int v15; // ebx
  int v16; // edx
  char *v17; // eax
  int v18; // ecx
  int v19[3]; // [esp+8h] [ebp-78h] BYREF
  int v20[3]; // [esp+14h] [ebp-6Ch] BYREF
  float v21; // [esp+20h] [ebp-60h]
  float v22; // [esp+24h] [ebp-5Ch]
  float v23; // [esp+28h] [ebp-58h]
  float v24; // [esp+2Ch] [ebp-54h]
  float v25; // [esp+30h] [ebp-50h]
  float v26; // [esp+34h] [ebp-4Ch]
  float v27; // [esp+38h] [ebp-48h]
  float v28; // [esp+3Ch] [ebp-44h]
  float v29; // [esp+40h] [ebp-40h]
  int *v30; // [esp+44h] [ebp-3Ch]
  int v31; // [esp+48h] [ebp-38h]
  int *v32; // [esp+4Ch] [ebp-34h]
  float v33; // [esp+50h] [ebp-30h]
  int v34; // [esp+54h] [ebp-2Ch]
  int v35; // [esp+58h] [ebp-28h]
  int v36; // [esp+5Ch] [ebp-24h]
  int v37; // [esp+60h] [ebp-20h]
  int v38; // [esp+64h] [ebp-1Ch]
  float v39; // [esp+68h] [ebp-18h]

  v34 = a2;
  v3 = **(_BYTE **)(a1 + 0x63);
  v38 = 0;
  v37 = 0xFFFFFFFF;
  v4 = (char *)&unk_107020 + 0x6A * (char)v3;
  v35 = 0;
  v5 = *(_DWORD *)(a1 + 0x88);
  v6 = *(_DWORD *)(v4 + 0x36);
  v36 = 0xFFFFFFFF;
  if ( v6 > v5 )
  {
    v36 = 0;
  }
  else
  {
    v35 = v6;
  }
  v7 = *(_DWORD *)(a1 + 0x68);
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x275);
  }
  v27 = *(float *)(v7 + 0x14);
  v28 = *(float *)(v7 + 0x18);
  v29 = *(float *)(v7 + 0x1C);
  if ( *(_DWORD *)v7 == *(_DWORD *)(a1 + 0x59) )
  {
    v27 = *(float *)(v7 + 8);
    v28 = *(float *)(v7 + 0xC);
    v29 = *(float *)(v7 + 0x10);
  }
  *(float *)(a1 + 0x78) = v27;
  *(float *)(a1 + 0x7C) = v28;
  *(float *)(a1 + 0x80) = v29;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  v30 = v19;
  v24 = v27 - *(float *)(a1 + 0x9E);
  v25 = v28 - *(float *)(a1 + 0xA2);
  v26 = v29 - *(float *)(a1 + 0xA6);
  *(float *)v19 = v24;
  *(float *)&v19[1] = v25;
  *(float *)&v19[2] = v26;
  v8 = sqrt(v25 * v25 + v24 * v24 + v26 * v26);
  v9 = *(_DWORD *)(v4 + 0x3A);
  v33 = v8;
  if ( v9 )
  {
    v31 = 0x20 * v9;
    if ( (double)(0x20 * v9) < v33 )
    {
      v37 = 0;
    }
  }
  v10 = v36 && v37 && (*(_WORD *)(v4 + 0x33) & 2) != 0;
  v38 |= v10;
  if ( v34 != 1 || (v38 & 1) == 0 )
  {
    return v38;
  }
  *(_DWORD *)(a1 + 0x88) -= v35;
  if ( !v4[0x32] && *(int *)(v4 + 0x52) > 1 )
  {
    *(_BYTE *)(v7 + 0x23) &= ~2u;
    return v38;
  }
  if ( v3 < 0x33u )
  {
    if ( v3 == 0x20 )
    {
      *(_BYTE *)(v7 + 0x23) |= 2u;
      return v38;
    }
    return v38;
  }
  if ( v3 <= 0x33u )
  {
    v13 = *(float **)(v7 + 4);
    v14 = *(float **)v7;
    v32 = v20;
    v15 = 0;
    v21 = 0.0;
    v22 = 0.0;
    v23 = 0.0;
    v21 = v14[2] - v13[2];
    v22 = v14[3] - v13[3];
    v23 = v14[4] - v13[4];
    *(float *)v20 = v21;
    *(float *)&v20[1] = v22;
    *(float *)&v20[2] = v23;
    v16 = 0;
    v39 = sqrt(v22 * v22 + v21 * v21 + v23 * v23);
    v17 = (char *)&unk_CA1F1;
    do
    {
      if ( v16 >= SHIWORD(dword_D35E5) )
      {
        break;
      }
      if ( *((__int16 *)v17 + 0x2B) != 0xFFFFFFFF )
      {
        if ( v17[0x58] == 5 && v7 == *(_DWORD *)(v17 + 0x59) )
        {
          *(float *)(v17 + 0x9E) = v39;
        }
        ++v16;
      }
      ++v15;
      v17 += 0x162;
    }
    while ( v15 < 0x6B );
    goto LABEL_37;
  }
  if ( v3 < 0x3Cu )
  {
    return v38;
  }
  if ( v3 <= 0x3Cu )
  {
    v18 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 == *(_DWORD *)(a1 + 0x59) )
    {
      v18 = *(_DWORD *)(v7 + 4);
    }
    sub_1D538(*(_DWORD *)(a1 + 0x59), a1);
    *(_BYTE *)(a1 + 0x58) = 5;
    *(_DWORD *)(a1 + 0x59) = v7;
    sub_1D3E8(v18, a1, 0);
LABEL_37:
    sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - (a1 + 0xAB)) / 7);
    return v38;
  }
  if ( v3 != 0x3E )
  {
    return v38;
  }
  v12 = *(float **)v7;
  if ( *(_DWORD *)v7 == *(_DWORD *)(a1 + 0x59) )
  {
    v12 = *(float **)(v7 + 4);
  }
  *((_BYTE *)v12 + 0x17) |= 1 << *(_BYTE *)(a1 + 0x56);
  return v38;
}
// D35E5: using guessed type int dword_D35E5;

//----- (0004CDF8) --------------------------------------------------------
int __fastcall sub_4CDF8(int a1, int a2)
{
  unsigned __int8 *v3; // ecx
  int v4; // ebp
  unsigned __int8 v5; // cl
  char *v6; // edi
  double v8; // st7
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // edx
  int v12; // eax
  double v13; // st7
  double v14; // st7
  int v15; // edi
  int v16; // ebp
  int v17; // eax
  int v18; // eax
  unsigned int v19; // ebp
  int v20; // edx
  double v21; // st7
  int v22; // edx
  int v23; // ecx
  int i; // edx
  char *v25; // eax
  char v26; // bh
  int v27; // ebx
  int v28; // eax
  int v29; // ebp
  int v30; // eax
  int v31; // ecx
  int v32; // edx
  int v33; // ebp
  int v34; // eax
  float *v35; // edx
  unsigned int v36; // ebx
  int v37; // ecx
  double v38; // st7
  double v39; // st7
  int v40; // ecx
  int v41; // eax
  int v42[107]; // [esp+8h] [ebp-770h] BYREF
  int v43[107]; // [esp+1B4h] [ebp-5C4h] BYREF
  int v44[107]; // [esp+360h] [ebp-418h] BYREF
  int v45[107]; // [esp+50Ch] [ebp-26Ch] BYREF
  float v46; // [esp+6B8h] [ebp-C0h]
  float v47; // [esp+6BCh] [ebp-BCh]
  float v48; // [esp+6C0h] [ebp-B8h]
  float v49; // [esp+6C4h] [ebp-B4h] BYREF
  float v50; // [esp+6C8h] [ebp-B0h]
  float v51; // [esp+6CCh] [ebp-ACh]
  float v52; // [esp+6D0h] [ebp-A8h] BYREF
  float v53; // [esp+6D4h] [ebp-A4h]
  float v54; // [esp+6D8h] [ebp-A0h]
  float v55; // [esp+6DCh] [ebp-9Ch] BYREF
  float v56; // [esp+6E0h] [ebp-98h]
  float v57; // [esp+6E4h] [ebp-94h]
  float v58; // [esp+6E8h] [ebp-90h]
  float v59; // [esp+6ECh] [ebp-8Ch]
  float v60; // [esp+6F0h] [ebp-88h]
  float v61; // [esp+6F4h] [ebp-84h]
  float v62; // [esp+6F8h] [ebp-80h]
  float v63; // [esp+6FCh] [ebp-7Ch]
  int v64[3]; // [esp+700h] [ebp-78h] BYREF
  float v65; // [esp+70Ch] [ebp-6Ch]
  float v66; // [esp+710h] [ebp-68h]
  float v67; // [esp+714h] [ebp-64h]
  float *v68; // [esp+718h] [ebp-60h]
  float *v69; // [esp+71Ch] [ebp-5Ch]
  int *v70; // [esp+720h] [ebp-58h]
  float *v71; // [esp+728h] [ebp-50h]
  int v72; // [esp+730h] [ebp-48h]
  int v73; // [esp+734h] [ebp-44h]
  int v74; // [esp+738h] [ebp-40h]
  int v75; // [esp+73Ch] [ebp-3Ch]
  int v76; // [esp+740h] [ebp-38h]
  int v77; // [esp+744h] [ebp-34h]
  int v78; // [esp+748h] [ebp-30h]
  float v79; // [esp+74Ch] [ebp-2Ch]
  float v80; // [esp+750h] [ebp-28h]
  float *v81; // [esp+754h] [ebp-24h]
  float v82; // [esp+758h] [ebp-20h]
  float v83; // [esp+75Ch] [ebp-1Ch]
  int v84; // [esp+760h] [ebp-18h]

  v77 = a2;
  v3 = *(unsigned __int8 **)(a1 + 0x63);
  v4 = 0;
  v73 = 0;
  v5 = *v3;
  v72 = 0xFFFFFFFF;
  if ( v5 == 0xFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipgiz.cpp", 0x2EA);
  }
  v6 = (char *)&unk_107020 + 0x6A * (char)v5;
  if ( *(_DWORD *)(v6 + 0x36) > *(_DWORD *)(a1 + 0x88) )
  {
    v72 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(v6 + 0x36);
  }
  v73 |= v72 != 0;
  if ( (v73 & 1) == 0 )
  {
    return v73;
  }
  if ( v77 != 1 )
  {
    return v73;
  }
  *(_DWORD *)(a1 + 0x88) -= v4;
  if ( v5 < 0x39u )
  {
    if ( v5 < 0x27u )
    {
      if ( v5 >= 0x24u )
      {
        if ( v5 <= 0x24u )
        {
          sub_1D538(*(_DWORD *)(a1 + 0x59), a1);
          v17 = *(int *)((char *)&dword_A2F79 + 0x1EE * *(__int16 *)(a1 + 0x56));
          *(_DWORD *)(a1 + 0x59) = v17;
          sub_1D3E8(v17, a1, 0);
          return v73;
        }
        if ( v5 == 0x26 )
        {
          v28 = sub_1D794(*(__int16 **)(a1 + 0x59), v43);
          v78 = 0;
          if ( v28 > 0 )
          {
            v29 = 0;
            v75 = 4 * v28;
            do
            {
              v30 = v43[v29 / 4u];
              v31 = *(__int16 *)(a1 + 0x56);
              v32 = *(__int16 *)(v30 + 0x56);
              if ( v32 != v31 && byte_A3132[0x1EE * v31 + v32] == 2 )
              {
                sub_4B7A0(v30, v77, *(_DWORD *)(v6 + 0x4A), v31);
              }
              v29 += 4;
              ++v78;
            }
            while ( v29 < v75 );
          }
          sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - (a1 + 0xAB)) / 7);
          return v73;
        }
      }
    }
    else if ( v5 <= 0x27u )
    {
      v33 = 0;
      v34 = sub_1D794(*(__int16 **)(a1 + 0x59), v42);
      if ( v34 > 0 )
      {
        v35 = (float *)(a1 + 0x9E);
        v36 = 0;
        v76 = 4 * v34;
        do
        {
          v37 = v42[v36 / 4];
          if ( a1 != v37 )
          {
            v71 = &v55;
            v46 = 0.0;
            v47 = 0.0;
            v48 = 0.0;
            v46 = *(float *)(v37 + 0x9E) - *v35;
            v47 = *(float *)(v37 + 0xA2) - *(float *)(a1 + 0xA2);
            v48 = *(float *)(v37 + 0xA6) - *(float *)(a1 + 0xA6);
            v55 = v46;
            v56 = v47;
            v57 = v48;
            v38 = sqrt(v47 * v47 + v46 * v46 + v48 * v48);
            v84 = 0x20 * *(_DWORD *)(v6 + 0x4A);
            v79 = (float)v84;
            if ( v38 < v79 )
            {
              sub_53054(&v55, v79);
              v58 = 0.0;
              v59 = 0.0;
              v60 = 0.0;
              v68 = &v52;
              v58 = *v35 + v55;
              v59 = *(float *)(a1 + 0xA2) + v56;
              v39 = *(float *)(a1 + 0xA6);
              v52 = v58;
              v60 = v39 + v57;
              v53 = v59;
              v40 = v42[v36 / 4];
              v54 = v60;
              *(float *)(v40 + 0x9E) = v58;
              *(float *)(v40 + 0xA2) = v53;
              *(float *)(v40 + 0xA6) = v54;
            }
          }
          v36 += 4;
          ++v33;
        }
        while ( (int)v36 < v76 );
      }
    }
    else
    {
      if ( v5 < 0x35u )
      {
        if ( v5 == 0x2E )
        {
          v69 = &v49;
          v65 = 0.0;
          v66 = 0.0;
          v67 = 0.0;
          v65 = -*(float *)(a1 + 0x9E);
          v66 = -*(float *)(a1 + 0xA2);
          v8 = -*(float *)(a1 + 0xA6);
          v49 = v65;
          v67 = v8;
          v50 = v66;
          v51 = v67;
          *(float *)(a1 + 0x9E) = v65;
          *(float *)(a1 + 0xA2) = v50;
          *(float *)(a1 + 0xA6) = v51;
        }
        return v73;
      }
      if ( v5 <= 0x35u )
      {
        *(_DWORD *)(a1 + 0x8C) -= *(_DWORD *)(v6 + 0x4A);
        v23 = *(_DWORD *)(a1 + 0x8C);
        *(_DWORD *)(a1 + 0x88) += *(_DWORD *)(v6 + 0x4E);
        if ( v23 < 1 )
        {
          goto LABEL_29;
        }
      }
      else
      {
        if ( v5 != 0x38 )
        {
          return v73;
        }
        v9 = sub_1D794(*(__int16 **)(a1 + 0x59), v44);
        if ( v9 > 0 )
        {
          v10 = 4 * v9;
          v11 = 0;
          do
          {
            v12 = v44[v11 / 4];
            if ( *(_BYTE *)(v12 + 0x58) == 4 )
            {
              v13 = sqrt(
                      *(float *)(v12 + 0xA2) * *(float *)(v12 + 0xA2)
                    + *(float *)(v12 + 0x9E) * *(float *)(v12 + 0x9E)
                    + *(float *)(v12 + 0xA6) * *(float *)(v12 + 0xA6));
              v84 = 0x20 * *(_DWORD *)(v6 + 0x4E);
              v80 = v13;
              v82 = (float)v84;
              if ( v80 > (double)v82 )
              {
                v84 = 0x20 * *(_DWORD *)(v6 + 0x4A);
                v14 = v80 - (double)v84;
                v83 = v14;
                if ( v14 < v82 )
                {
                  v83 = v82;
                }
                sub_53054((float *)(v44[v11 / 4] + 0x9E), v83);
              }
            }
            v11 += 4;
          }
          while ( (int)v11 < v10 );
        }
      }
    }
    return v73;
  }
  if ( v5 <= 0x39u )
  {
    *(_BYTE *)(a1 + 0x9C) |= 4u;
    return v73;
  }
  if ( v5 < 0x41u )
  {
    if ( v5 <= 0x3Au )
    {
      v15 = *(_DWORD *)(v6 + 0x4A) + *(_DWORD *)(a1 + 0x8C);
      v16 = *(_DWORD *)(a1 + 0x98);
      *(_DWORD *)(a1 + 0x8C) = v15;
      if ( v15 > v16 )
      {
        *(_DWORD *)(a1 + 0x8C) = v16;
        return v73;
      }
    }
    else
    {
      if ( v5 != 0x3F )
      {
        return v73;
      }
      v41 = sub_49328(a1, 2);
      if ( v41 != 0xFFFFFFFF )
      {
        sub_492F8((_DWORD *)a1, v41);
        *(_BYTE *)(a1 + 0x9C) |= 2u;
        return v73;
      }
    }
    return v73;
  }
  v25 = (char *)(a1 + 0xAB);
  if ( v5 <= 0x41u )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 0x15A); v25 += 7 )
    {
      v26 = *v25;
      if ( *v25 != (char)0xFF && v26 != 0x41 )
      {
        v27 = 0x6A * v26;
        if ( *(int *)((char *)&dword_107062 + v27) )
        {
          *(_WORD *)(v25 + 1) = *(_WORD *)((char *)&dword_107062 + v27);
        }
      }
      ++i;
    }
    return v73;
  }
  if ( v5 >= 0x48u )
  {
    if ( v5 > 0x48u )
    {
      if ( v5 == 0x4B )
      {
        v22 = *(_DWORD *)(a1 + 0x63);
        *(_DWORD *)(a1 + 0x88) += *(_DWORD *)(v6 + 0x4A);
        sub_492F8((_DWORD *)a1, (v22 - (int)v25) / 7);
      }
      return v73;
    }
    v18 = sub_1D794(*(__int16 **)(a1 + 0x59), v45);
    if ( v18 > 0 )
    {
      v19 = 0;
      v81 = (float *)(a1 + 0x9E);
      v74 = 4 * v18;
      do
      {
        v20 = v45[v19 / 4];
        if ( a1 != v20 )
        {
          v61 = 0.0;
          v62 = 0.0;
          v63 = 0.0;
          v70 = v64;
          v61 = *(float *)(v20 + 0x9E) - *v81;
          v62 = *(float *)(v20 + 0xA2) - v81[1];
          v63 = *(float *)(v20 + 0xA6) - v81[2];
          *(float *)v64 = v61;
          *(float *)&v64[1] = v62;
          *(float *)&v64[2] = v63;
          v21 = sqrt(v62 * v62 + v61 * v61 + v63 * v63);
          v84 = 0x20 * *(_DWORD *)(v6 + 0x3A);
          if ( (double)v84 >= v21 )
          {
            sub_4B7A0(v45[v19 / 4], v77, *(_DWORD *)(v6 + 0x4A), *(_WORD *)(a1 + 0x56));
          }
        }
        v19 += 4;
      }
      while ( (int)v19 < v74 );
    }
LABEL_29:
    sub_49940(a1);
    return v73;
  }
  if ( v5 == 0x45 )
  {
    *(_BYTE *)(a1 + 0x9C) |= 0x10u;
    sub_492F8((_DWORD *)a1, (*(_DWORD *)(a1 + 0x63) - (int)v25) / 7);
  }
  return v73;
}
// A2F79: using guessed type int dword_A2F79;
// 107062: using guessed type int dword_107062;

//----- (0004D700) --------------------------------------------------------
_DWORD *sub_4D700()
{
  _DWORD *result; // eax

  _wcpp_2_mod_register_(&unk_96AC0);
  result = sub_48B90(&dword_108FE8);
  dword_96AC8 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96AC8: using guessed type int dword_96AC8;
// 108FE8: using guessed type int dword_108FE8;

//----- (0004D724) --------------------------------------------------------
int __fastcall sub_4D724(T_Type5 *a1, int a2, LONG a3, int a4)
{
  void *v5; // eax
  T_Rect *p_rect; // esi

  if ( a4 )
  {
    VFX_pane_wipe((PANE *)a1, 0x96);
  }
  v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFED8);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x34);
  }
  VFX_shape_draw((PANE *)a1, v5, a3, 0x3F, 0x2D);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = a1->a;
  p_rect = &a1->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = p_rect->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = p_rect->y1;
  return sub_2B8A8(
           (int)&V_Type3_stru_10AE70.z1[0x3026],
           0x3F,
           2,
           (const char *)&unk_107020 + 0x6A * a3,
           8,
           0xFFFFFFFF,
           0xFF,
           0x7A);
}
// FFED8: using guessed type __int16 word_FFED8;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0004D7A8) --------------------------------------------------------
unsigned int __fastcall sub_4D7A8(int a1, int a2, int a3)
{
  unsigned int v3; // ebx
  int v4; // esi
  int v5; // ecx
  int v6; // edi
  char v7; // al
  int i; // edx
  char v9; // al
  int j; // edx
  int v13; // [esp+4h] [ebp-20h]
  int v14; // [esp+8h] [ebp-1Ch]
  int v15; // [esp+Ch] [ebp-18h]
  int v16; // [esp+10h] [ebp-14h]

  v3 = 0xFFFFFFFF;
  v4 = a2 - 0x94;
  v5 = a1 - 0x16F;
  if ( a2 - 0x94 > 0 )
  {
    v15 = (v4 - v5 / 2 + 0x12) / 2 / 0x12;
    v14 = (v5 / 2 + v4 - 0x12) / 2 / 0x12;
    v13 = (unsigned __int8)byte_969A8[v15];
    if ( v15 < 0xE
      && v14 >= v13
      && v13 + (unsigned __int8)byte_969B8[v15] > v14
      && ((1 << (v14 - v13)) & (unsigned __int8)byte_106FE0[4 * v15 + a3]) != 0 )
    {
      v6 = 0;
      if ( v15 > 0 )
      {
        v16 = a3;
        do
        {
          v7 = 1;
          for ( i = 0; i < (unsigned __int8)byte_969B8[v6]; ++i )
          {
            if ( ((unsigned __int8)v7 & (unsigned __int8)byte_106FE0[v16]) != 0 )
            {
              ++v3;
            }
            v7 *= 2;
          }
          ++v6;
          v16 += 4;
        }
        while ( v6 < v15 );
      }
      v9 = 1;
      for ( j = 0; j <= v14 - v13; v9 *= 2 )
      {
        if ( ((unsigned __int8)v9 & (unsigned __int8)byte_106FE0[4 * v15 + a3]) != 0 )
        {
          ++v3;
        }
        ++j;
      }
    }
  }
  return v3;
}

//----- (0004D92C) --------------------------------------------------------
char *__fastcall sub_4D92C(int a1)
{
  char *v1; // edx

  sub_2C830((P_TypeA2)a1);
  v1 = (char *)sub_48B90((_DWORD *)(a1 + 0xCD)) + 0xFFFFFF33;
  *(_DWORD *)(v1 + 0xA7) = off_9607C;
  v1[0xBB] = 0xFF;
  v1[0xBC] = 0;
  *(_DWORD *)(v1 + 0xBD) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0xC1) = 0xFFFFFFFF;
  *(_DWORD *)(v1 + 0xC5) = 0;
  *(_DWORD *)(v1 + 0xAB) = 0;
  *(_DWORD *)(v1 + 0xC9) = 0;
  sub_4DA5C((int)v1);
  return v1;
}
// 9607C: using guessed type int (*off_9607C[5])();

//----- (0004DA08) --------------------------------------------------------
int __fastcall sub_4DA08(int a1, char a2, int a3, int a4)
{
  void *v5; // eax
  int v7; // eax
  void *v8; // eax
  void *v9; // ebx

  if ( (a2 & 4) != 0 )
  {
    v5 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96068);
    operator delete[](v5);
    return a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_9607C;
    v7 = sub_48C58(a4);
    v8 = (void *)sub_2C848(v7 - 0xCD, 1);
    v9 = v8;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v8);
    }
    return (int)v9;
  }
}
// 48C58: using guessed type int __cdecl sub_48C58(_DWORD);
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 9607C: using guessed type int (*off_9607C[5])();

//----- (0004DA5C) --------------------------------------------------------
int __fastcall sub_4DA5C(int result)
{
  if ( dword_96ACC )
  {
    *(_DWORD *)(result + 0xB7) = 0x4C;
    dword_96ACC = 0;
  }
  return result;
}
// 96ACC: using guessed type int dword_96ACC;

//----- (0004DA7C) --------------------------------------------------------
int __fastcall sub_4DA7C(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v6; // [esp+8h] [ebp-10h]

  sub_4DA5C(a1);
  *(_DWORD *)(a1 + 0xAB) = a2;
  *(_DWORD *)(a1 + 0xC9) = a3;
  if ( a3 == 0xFFFFFFFF )
  {
    v6 = *(_DWORD *)(a1 + 0xAB);
    *(_DWORD *)(a1 + 0xCD) = *(_DWORD *)v6;
    *(_DWORD *)(a1 + 0xD1) = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(a1 + 0xD5) = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(a1 + 0xD9) = *(_DWORD *)(v6 + 0xC);
    *(_DWORD *)(a1 + 0xDD) = *(_DWORD *)(v6 + 0x10);
    *(_DWORD *)(a1 + 0xE1) = *(_DWORD *)(v6 + 0x14);
    *(_DWORD *)(a1 + 0xE5) = *(_DWORD *)(v6 + 0x18);
    *(_DWORD *)(a1 + 0xE9) = *(_DWORD *)(v6 + 0x1C);
    *(_DWORD *)(a1 + 0xED) = *(_DWORD *)(v6 + 0x20);
    *(_DWORD *)(a1 + 0xF1) = *(_DWORD *)(v6 + 0x24);
    *(_DWORD *)(a1 + 0xF5) = *(_DWORD *)(v6 + 0x28);
    *(_DWORD *)(a1 + 0xF9) = *(_DWORD *)(v6 + 0x2C);
    *(_DWORD *)(a1 + 0xFD) = *(_DWORD *)(v6 + 0x30);
    qmemcpy((void *)(a1 + 0x101), (const void *)(v6 + 0x34), 0x29u);
    *(_DWORD *)(a1 + 0x126) = *(_DWORD *)(v6 + 0x59);
    *(_DWORD *)(a1 + 0x126) = *(_DWORD *)(v6 + 0x59);
    *(_BYTE *)(a1 + 0x12A) = *(_BYTE *)(v6 + 0x5D);
    *(_DWORD *)(a1 + 0x12B) = *(_DWORD *)(v6 + 0x5E);
    *(_BYTE *)(a1 + 0x12F) = *(_BYTE *)(v6 + 0x62);
    *(_DWORD *)(a1 + 0x130) = *(_DWORD *)(v6 + 0x63);
    *(_BYTE *)(a1 + 0x134) = *(_BYTE *)(v6 + 0x67);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x135) = *(_DWORD *)(v6 + 0x68);
    *(_DWORD *)(a1 + 0x139) = *(_DWORD *)(v6 + 0x6C);
    *(_DWORD *)(a1 + 0x13D) = *(_DWORD *)(v6 + 0x70);
    *(_DWORD *)(a1 + 0x141) = *(_DWORD *)(v6 + 0x74);
    *(float *)(a1 + 0x145) = *(float *)(v6 + 0x78);
    *(_DWORD *)(a1 + 0x149) = *(_DWORD *)(v6 + 0x7C);
    *(float *)(a1 + 0x14D) = *(float *)(v6 + 0x80);
    *(_DWORD *)(a1 + 0x151) = *(_DWORD *)(v6 + 0x84);
    *(_DWORD *)(a1 + 0x155) = *(_DWORD *)(v6 + 0x88);
    *(_DWORD *)(a1 + 0x159) = *(_DWORD *)(v6 + 0x8C);
    *(_DWORD *)(a1 + 0x15D) = *(_DWORD *)(v6 + 0x90);
    *(_DWORD *)(a1 + 0x161) = *(_DWORD *)(v6 + 0x94);
    *(_DWORD *)(a1 + 0x165) = *(_DWORD *)(v6 + 0x98);
    *(_WORD *)(a1 + 0x169) = *(_WORD *)(v6 + 0x9C);
    *(float *)(a1 + 0x16B) = *(float *)(v6 + 0x9E);
    *(_DWORD *)(a1 + 0x16F) = *(_DWORD *)(v6 + 0xA2);
    *(float *)(a1 + 0x173) = *(float *)(v6 + 0xA6);
    *(_BYTE *)(a1 + 0x177) = *(_BYTE *)(v6 + 0xAA);
    _wcpp_2_assign_array_(sub_4B780);
    *(_DWORD *)(a1 + 0x227) = *(_DWORD *)(v6 + 0x15A);
    *(_DWORD *)(a1 + 0x22B) = *(_DWORD *)(v6 + 0x15E);
  }
  result = a4;
  *(_DWORD *)(a1 + 0x233) = a4;
  return result;
}
// 78B30: using guessed type _DWORD __stdcall _wcpp_2_assign_array_(_DWORD);

//----- (0004DD14) --------------------------------------------------------
char __fastcall sub_4DD14(int a1)
{
  int v2; // eax
  int v3; // edi
  int v4; // ebp
  int v5; // eax
  int v6; // edx
  unsigned __int16 v7; // ax

  LOBYTE(v2) = sub_2ED4C(*(_DWORD *)(a1 + 0xC5));
  v3 = 0;
  if ( *(int *)(a1 + 0xB7) > 0 )
  {
    v4 = 0;
    do
    {
      LOBYTE(v2) = byte_107052[v4];
      if ( (_BYTE)v2 == *(_BYTE *)(a1 + 0xBC) )
      {
        v5 = (unsigned __int8)byte_107055[v4];
        if ( v5 == 0xFF
          || (v6 = *(int *)((char *)&dword_10529F + 0x4B * v5) >> 0x18,
              v2 = 1 << byte_104BEA,
              ((1 << byte_104BEA) & v6) != 0) )
        {
          v7 = sub_2EA8C(*(_DWORD *)(a1 + 0xC5), (const char *)a1, 0xFFFFFFFF, 0);
          LOBYTE(v2) = sub_2EC50(*(_DWORD *)(a1 + 0xC5), v7, v3);
        }
      }
      ++v3;
      v4 += 0x6A;
    }
    while ( v3 < *(_DWORD *)(a1 + 0xB7) );
  }
  return v2;
}
// 10529F: using guessed type int dword_10529F;

//----- (0004DDB0) --------------------------------------------------------
unsigned int __fastcall sub_4DDB0(int a1, __int16 a2, int a3, int a4)
{
  char v5; // al
  int v6; // ebx
  int v7; // ebx
  unsigned int result; // eax
  int v9; // eax
  int v10; // ecx
  double v11; // st7
  double v12; // st7
  int i; // esi
  int v14; // edi
  int v15; // edx
  int v16; // ebx
  int v17; // edx
  int v18; // ebx

  if ( (unsigned __int16)a2 < 0x32u )
  {
    if ( (unsigned __int16)a2 >= 5u )
    {
      if ( (unsigned __int16)a2 <= 5u )
      {
        if ( *(_DWORD *)(a1 + 0x35)
          && a3 >= *(_DWORD *)(a1 + 8)
          && a3 <= *(_DWORD *)(a1 + 0x10)
          && a4 >= *(_DWORD *)(a1 + 0xC)
          && a4 <= *(_DWORD *)(a1 + 0x14) )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          if ( dword_96AD0 >= 0 )
          {
            if ( !*(_DWORD *)(a1 + 0xAB) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x1D8);
            }
            if ( sub_492F8(*(_DWORD **)(a1 + 0xAB), dword_96AD0) )
            {
              v17 = *(__int16 *)(a1 + 0x59);
              if ( v17 != 0xFFFFFFFF )
              {
                sub_4FB90((int)&unk_10914C, v17);
              }
              *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
              v18 = *(_DWORD *)(a1 + 0xA7);
              *(_DWORD *)(a1 + 0x22F) = 0xFFFFFFFF;
              (*(void (**)(void))(v18 + 0xC))();
            }
          }
          return 0xFFFFFFFF;
        }
      }
      else
      {
        if ( (unsigned __int16)a2 < 7u )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          sub_567BC((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 8);
          if ( *(_DWORD *)(a1 + 0x39) && *(_DWORD *)(a1 + 0x35) && (dword_96AD0 >= 0 || *(_DWORD *)(a1 + 0x3D)) )
          {
            dword_96AD0 = 0xFFFFFFFF;
            (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          }
          else
          {
            dword_96AD0 = 0xFFFFFFFF;
          }
          return 0xFFFFFFFF;
        }
        if ( (unsigned __int16)a2 <= 7u )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          sub_56728((int)&V_Type3_stru_10AE70, *(_DWORD *)(a1 + 0x41), 4, 8, 0, 0);
          if ( (*(_DWORD *)(a1 + 0x3D) & *(_DWORD *)(a1 + 0x35) & *(_DWORD *)(a1 + 0x39)) == 0xFFFFFFFF )
          {
            (*(void (**)(void))(*(_DWORD *)(a1 + 0xA7) + 0x10))();
          }
          return 0xFFFFFFFF;
        }
        if ( a2 != 8 )
        {
          return sub_2F424(a1, a2, a3, a4);
        }
        if ( *(_DWORD *)(a1 + 0x233) != 0xFFFFFFFF )
        {
          if ( !*(_DWORD *)(a1 + 0xAB) )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x13D);
          }
          dword_96AD0 = sub_4D7A8(a3, a4, *(char *)(*(_DWORD *)(a1 + 0xAB) + 0xAA));
          (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          return 0;
        }
      }
      return 0;
    }
    if ( (unsigned __int16)a2 < 2u )
    {
      if ( a2 == 1 )
      {
        if ( *(_DWORD *)(a1 + 0xAB) )
        {
          sub_4DA5C(a1);
        }
        else
        {
          *(_DWORD *)(a1 + 0xAB) = &dword_108FE8;
        }
        *(_DWORD *)(a1 + 0xC1) = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x22F) = 0;
        v9 = sub_56DA8((int)&V_Type3_stru_10AE70, "GIZLIST", 0);
        *(_DWORD *)(a1 + 0xC5) = v9;
        if ( !v9 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x153);
        }
        *(_DWORD *)(*(_DWORD *)(a1 + 0xC5) + 0xAB) = 0;
        sub_2F1C8(*(_DWORD *)(a1 + 0xC5), (int)sub_4D724);
        *(_WORD *)(*(_DWORD *)(a1 + 0xC5) + 0x8C9) = 0x40;
        sub_2E9CC(*(_DWORD *)(a1 + 0xC5), 0);
        *(_BYTE *)(*(_DWORD *)(a1 + 0xC5) + 0xC6) = 0xF2;
        if ( *(_BYTE *)(a1 + 0xBB) == 0xFF )
        {
          sub_4E644(a1, 4, 0, a4);
        }
        else
        {
          sub_4DD14(a1);
        }
        *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x39) = 0xFFFFFFFF;
        *(_DWORD *)(a1 + 0x35) = 0xFFFFFFFF;
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
        sub_2D258(a1, a2);
        return 0;
      }
    }
    else
    {
      if ( (unsigned __int16)a2 <= 2u )
      {
        *(_DWORD *)(a1 + 0x39) = 0;
        *(_DWORD *)(a1 + 0x35) = 0;
        v10 = *(_DWORD *)(a1 + 0xAB);
        dword_96AD0 = 0xFFFFFFFF;
        if ( &dword_108FE8 != (int *)v10 )
        {
          dword_108FE8 = *(_DWORD *)v10;
          dword_108FEC = *(_DWORD *)(v10 + 4);
          dword_108FF0 = *(_DWORD *)(v10 + 8);
          dword_108FF4 = *(_DWORD *)(v10 + 0xC);
          dword_108FF8 = *(_DWORD *)(v10 + 0x10);
          dword_108FFC = *(_DWORD *)(v10 + 0x14);
          dword_109000 = *(_DWORD *)(v10 + 0x18);
          dword_109004 = *(_DWORD *)(v10 + 0x1C);
          dword_109008 = *(_DWORD *)(v10 + 0x20);
          dword_10900C = *(_DWORD *)(v10 + 0x24);
          dword_109010 = *(_DWORD *)(v10 + 0x28);
          dword_109014 = *(_DWORD *)(v10 + 0x2C);
          dword_109018 = *(_DWORD *)(v10 + 0x30);
          qmemcpy(&unk_10901C, (const void *)(v10 + 0x34), 0x1Eu);
          dword_10903A = *(_DWORD *)(v10 + 0x52);
          word_10903E = *(_WORD *)(v10 + 0x56);
          byte_109040 = *(_BYTE *)(v10 + 0x58);
          dword_109041 = *(_DWORD *)(v10 + 0x59);
          dword_109041 = *(_DWORD *)(v10 + 0x59);
          dword_109041 = *(_DWORD *)(v10 + 0x59);
          byte_109045 = *(_BYTE *)(v10 + 0x5D);
          dword_109046 = *(_DWORD *)(v10 + 0x5E);
          byte_10904A = *(_BYTE *)(v10 + 0x62);
          dword_10904B = *(_DWORD *)(v10 + 0x63);
          byte_10904F = *(_BYTE *)(v10 + 0x67);
          dword_109050 = *(_DWORD *)(v10 + 0x68);
          dword_109050 = *(_DWORD *)(v10 + 0x68);
          dword_109050 = *(_DWORD *)(v10 + 0x68);
          dword_109050 = *(_DWORD *)(v10 + 0x68);
          flt_109054 = *(float *)(v10 + 0x6C);
          dword_109058 = *(_DWORD *)(v10 + 0x70);
          flt_10905C = *(float *)(v10 + 0x74);
          flt_109060 = *(float *)(v10 + 0x78);
          dword_109064 = *(_DWORD *)(v10 + 0x7C);
          v11 = *(float *)(v10 + 0x80);
          dword_10906C = *(_DWORD *)(v10 + 0x84);
          dword_109070 = *(_DWORD *)(v10 + 0x88);
          dword_109074 = *(_DWORD *)(v10 + 0x8C);
          dword_109078 = *(_DWORD *)(v10 + 0x90);
          dword_10907C = *(_DWORD *)(v10 + 0x94);
          dword_109080 = *(_DWORD *)(v10 + 0x98);
          word_109084 = *(_WORD *)(v10 + 0x9C);
          flt_109068 = v11;
          flt_109086 = *(float *)(v10 + 0x9E);
          dword_10908A = *(_DWORD *)(v10 + 0xA2);
          v12 = *(float *)(v10 + 0xA6);
          byte_109092 = *(_BYTE *)(v10 + 0xAA);
          flt_10908E = v12;
          _wcpp_2_assign_array_(sub_4B780);
          dword_109142 = *(_DWORD *)(v10 + 0x15A);
          dword_109146 = *(_DWORD *)(v10 + 0x15E);
        }
        for ( i = 0; (__int16)i < *(__int16 *)(a1 + 0x6B); ++i )
        {
          v14 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4 * (__int16)i) + 0xA7);
          (*(void (**)(void))(v14 + 8))();
        }
        if ( !*(_DWORD *)(a1 + 0x22F) )
        {
          *(_DWORD *)(a1 + 0xAB) = 0;
          return 0;
        }
        return 0;
      }
      if ( a2 == 4 )
      {
        result = *(_DWORD *)(a1 + 0x35);
        if ( !result )
        {
          return result;
        }
        if ( a3 >= *(_DWORD *)(a1 + 8)
          && a3 <= *(_DWORD *)(a1 + 0x10)
          && a4 >= *(_DWORD *)(a1 + 0xC)
          && a4 <= *(_DWORD *)(a1 + 0x14) )
        {
          if ( *(_DWORD *)(a1 + 0x233) == 0xFFFFFFFF )
          {
            return 0xFFFFFFFF;
          }
          if ( dword_96AD0 >= 0 )
          {
            if ( !*(_DWORD *)(a1 + 0xAB) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x1B2);
            }
            if ( sub_492AC(*(_DWORD **)(a1 + 0xAB), *(_BYTE *)(a1 + 0xBB), dword_96AD0) )
            {
              v15 = *(__int16 *)(a1 + 0x59);
              if ( v15 != 0xFFFFFFFF )
              {
                sub_4FB90((int)&unk_10914C, v15);
              }
              *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
              v16 = *(_DWORD *)(a1 + 0xA7);
              *(_DWORD *)(a1 + 0x22F) = 0xFFFFFFFF;
              (*(void (**)(void))(v16 + 0xC))();
            }
          }
          return 0xFFFFFFFF;
        }
        return 0;
      }
    }
    return sub_2F424(a1, a2, a3, a4);
  }
  if ( (unsigned __int16)a2 <= 0x32u )
  {
    if ( *(_DWORD *)(a1 + 0x233) != 0xFFFFFFFF )
    {
      if ( sub_4E69C(a1) )
      {
        *(_DWORD *)(a1 + 0xC1) = 0xFFFFFFFF;
      }
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      return 0;
    }
    return 0;
  }
  if ( (unsigned __int16)a2 >= 0x36u )
  {
    if ( (unsigned __int16)a2 <= 0x36u )
    {
      sub_4E644(a1, 2, a3, a4);
      return 0;
    }
    if ( (unsigned __int16)a2 < 0x39u )
    {
      if ( a2 == 0x37 )
      {
        sub_4E644(a1, 4, a3, a4);
        return 0;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 <= 0x39u )
    {
      sub_4E644(a1, 5, a3, a4);
      return 0;
    }
    if ( (unsigned __int16)a2 < 0x1C01u )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( (unsigned __int16)a2 > 0x1C01u )
    {
      if ( a2 == 0x1C02 )
      {
        v7 = (char)sub_2ECA4(*(_DWORD *)(a1 + 0xC5), a3);
        sub_56B60((int)&V_Type3_stru_10AE70, 5, v7, 4);
        return 0xFFFFFFFF;
      }
      return sub_2F424(a1, a2, a3, a4);
    }
    v5 = sub_2ECA4(*(_DWORD *)(a1 + 0xC5), a3);
    if ( v5 != *(_BYTE *)(a1 + 0xBB) )
    {
      v6 = *(_DWORD *)(a1 + 0xA7);
      *(_BYTE *)(a1 + 0xBB) = v5;
      (*(void (__fastcall **)(int, _DWORD))(v6 + 0xC))(a1, 0);
    }
    return 0;
  }
  if ( (unsigned __int16)a2 < 0x34u )
  {
    sub_4E644(a1, 0, a3, a4);
    return 0;
  }
  else
  {
    if ( (unsigned __int16)a2 <= 0x34u )
    {
      sub_4E644(a1, 1, a3, a4);
    }
    else
    {
      sub_4E644(a1, 3, a3, a4);
    }
    return 0;
  }
}
// 78B30: using guessed type _DWORD __stdcall _wcpp_2_assign_array_(_DWORD);
// 96AD0: using guessed type int dword_96AD0;
// 108FE8: using guessed type int dword_108FE8;
// 108FEC: using guessed type int dword_108FEC;
// 108FF0: using guessed type int dword_108FF0;
// 108FF4: using guessed type int dword_108FF4;
// 108FF8: using guessed type int dword_108FF8;
// 108FFC: using guessed type int dword_108FFC;
// 109000: using guessed type int dword_109000;
// 109004: using guessed type int dword_109004;
// 109008: using guessed type int dword_109008;
// 10900C: using guessed type int dword_10900C;
// 109010: using guessed type int dword_109010;
// 109014: using guessed type int dword_109014;
// 109018: using guessed type int dword_109018;
// 10903A: using guessed type int dword_10903A;
// 10903E: using guessed type __int16 word_10903E;
// 109040: using guessed type char byte_109040;
// 109041: using guessed type int dword_109041;
// 109045: using guessed type char byte_109045;
// 109046: using guessed type int dword_109046;
// 10904A: using guessed type char byte_10904A;
// 10904B: using guessed type int dword_10904B;
// 10904F: using guessed type char byte_10904F;
// 109050: using guessed type int dword_109050;
// 109054: using guessed type float flt_109054;
// 109058: using guessed type int dword_109058;
// 10905C: using guessed type float flt_10905C;
// 109060: using guessed type float flt_109060;
// 109064: using guessed type int dword_109064;
// 109068: using guessed type float flt_109068;
// 10906C: using guessed type int dword_10906C;
// 109070: using guessed type int dword_109070;
// 109074: using guessed type int dword_109074;
// 109078: using guessed type int dword_109078;
// 10907C: using guessed type int dword_10907C;
// 109080: using guessed type int dword_109080;
// 109084: using guessed type __int16 word_109084;
// 109086: using guessed type float flt_109086;
// 10908A: using guessed type int dword_10908A;
// 10908E: using guessed type float flt_10908E;
// 109092: using guessed type char byte_109092;
// 109142: using guessed type int dword_109142;
// 109146: using guessed type int dword_109146;

//----- (0004E644) --------------------------------------------------------
int __fastcall sub_4E644(int result, char a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // eax

  v4 = result;
  if ( a2 >= 0 && a2 < 6 && a2 != *(_BYTE *)(result + 0xBC) )
  {
    *(_BYTE *)(result + 0xBC) = a2;
    sub_4DD14(result);
    v5 = *(_DWORD *)(v4 + 0xC5);
    *(_BYTE *)(v4 + 0xBB) = 0xFF;
    if ( *(_WORD *)(v5 + 0x8C7) )
    {
      *(_BYTE *)(v4 + 0xBB) = sub_2ECA4(v5, 0);
    }
    return (*(int (__cdecl **)(int))(*(_DWORD *)(v4 + 0xA7) + 0xC))(a4);
  }
  return result;
}

//----- (0004E69C) --------------------------------------------------------
unsigned int __fastcall sub_4E69C(int a1)
{
  unsigned int v2; // ebp
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // eax
  int v6; // eax

  v2 = 0;
  v3 = *(char *)(*(_DWORD *)(a1 + 0xAB) + 0xAA);
  v4 = 0;
  if ( !*(_DWORD *)(a1 + 0xC9) )
  {
    while ( !v4 )
    {
      if ( ++v3 >= 4 )
      {
        v3 = 0;
      }
      if ( (v3 != 2 || ((1 << byte_104BEA) & SHIBYTE(dword_105830)) != 0)
        && (v3 != 3 || ((1 << byte_104BEA) & SHIBYTE(dword_105BB4)) != 0) )
      {
        v5 = *(_DWORD *)(a1 + 0xAB);
        if ( v3 == *(char *)(v5 + 0xAA) )
        {
          v4 = 0xFFFFFFFF;
          v2 = 0;
        }
        else
        {
          sub_493BC(v5, v3);
          if ( v6 )
          {
            v4 = 0xFFFFFFFF;
            v2 = 0xFFFFFFFF;
            *(_DWORD *)(a1 + 0xBD) = 0xFFFFFFFF;
          }
        }
      }
    }
  }
  return v2;
}
// 4E739: variable 'v6' is possibly undefined
// 105830: using guessed type int dword_105830;
// 105BB4: using guessed type int dword_105BB4;

//----- (0004E758) --------------------------------------------------------
void __fastcall sub_4E758(_DWORD *a1)
{
  int v1; // esi
  LONG v2; // eax
  int v3; // edi
  int v4; // esi
  int v5; // eax
  unsigned __int16 v6; // dx
  unsigned __int16 v7; // ax
  char v8; // bh
  void *v9; // eax
  void *v10; // eax
  void *v11; // ecx
  _DWORD *v12; // ebx
  int v13; // edx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  char *sub_1CEA8; // eax
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // edi
  int v22; // esi
  LONG v23; // [esp-Ch] [ebp-7Eh]
  LONG v24; // [esp-Ch] [ebp-7Eh]
  __int16 v25; // [esp-Ch] [ebp-7Eh]
  LONG v26; // [esp-8h] [ebp-7Ah]
  int v27; // [esp-8h] [ebp-7Ah]
  LONG v28; // [esp-8h] [ebp-7Ah]
  LONG v29; // [esp-4h] [ebp-76h]
  char s[52]; // [esp+0h] [ebp-72h] BYREF
  char v31[52]; // [esp+34h] [ebp-3Eh] BYREF
  PANE pane; // [esp+68h] [ebp-Ah] BYREF
  PANE v33; // [esp+7Ch] [ebp+Ah] BYREF
  int v34[5]; // [esp+90h] [ebp+1Eh]
  T_Type5 a2; // [esp+A4h] [ebp+32h] BYREF
  _DWORD *v36; // [esp+B8h] [ebp+46h]
  int v37; // [esp+BCh] [ebp+4Ah]
  int v38; // [esp+C0h] [ebp+4Eh]
  int v39; // [esp+C4h] [ebp+52h]
  LONG v40; // [esp+C8h] [ebp+56h]
  int v41; // [esp+CCh] [ebp+5Ah]
  unsigned int v42; // [esp+D0h] [ebp+5Eh]
  int i; // [esp+D4h] [ebp+62h]
  void *shape_table; // [esp+D8h] [ebp+66h]
  LONG shape_number; // [esp+DCh] [ebp+6Ah]
  int v46; // [esp+E0h] [ebp+6Eh]
  int v47; // [esp+E4h] [ebp+72h]
  LONG hotY; // [esp+E8h] [ebp+76h]
  LONG v49; // [esp+ECh] [ebp+7Ah]
  unsigned __int8 v50; // [esp+F0h] [ebp+7Eh]

  v36 = a1;
  if ( !*(_DWORD *)((char *)a1 + 0xAB) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x24A);
  }
  v1 = *(char *)(*(_DWORD *)((char *)v36 + 0xAB) + 0xAA);
  pane.window = (WINDOW *)&V_Type6_stru_D8654;
  pane.x0 = 0x14A;
  pane.y0 = 0x72;
  pane.x1 = 0x1DC;
  pane.y1 = 0x1D8;
  v41 = v1;
  VFX_pane_wipe(&pane, 0);
  pane.y1 = 0x1D8;
  pane.x1 = 0x149;
  pane.x0 = 7;
  pane.y0 = 0x159;
  v2 = VFX_pane_wipe(&pane, 0);
  LOWORD(v2) = word_FFED8;
  v38 = 0;
  v49 = v2;
  for ( i = 0; i < 0xE; ++i )
  {
    v3 = 0x12 * (i + (unsigned __int8)byte_969A8[i]) + 0xA6;
    v4 = 0x24 * ((unsigned __int8)byte_969A8[i] - i) + 0x193;
    v5 = (unsigned __int8)byte_969B8[i];
    v50 = 1;
    v47 = v5;
    v37 = 0;
    if ( v5 > 0 )
    {
      v46 = v41;
      v39 = 7 * v38;
      while ( (v50 & (unsigned __int8)byte_106FE0[v46]) == 0 )
      {
LABEL_12:
        v50 *= 2;
        v4 += 0x24;
        v3 += 0x12;
        if ( ++v37 >= v47 )
        {
          goto LABEL_4;
        }
      }
      if ( dword_96AD0 >= 0 && dword_96AD0 == v38 )
      {
        if ( *((_BYTE *)v36 + 0xBB) != 0xFF )
        {
          v29 = v3;
          v26 = v4;
          v23 = *((char *)v36 + 0xBB);
          v6 = v49;
LABEL_23:
          v9 = (void *)sub_1B084((unsigned int)dword_12FC20, v6);
          VFX_shape_draw(&V_Type6_stru_D8654.pane, v9, v23, v26, v29);
          v39 += 7;
          ++v38;
          goto LABEL_12;
        }
        v29 = v3;
        v26 = v4;
        v7 = *((_WORD *)v36 + 0xC);
        v23 = 1;
      }
      else
      {
        if ( !*(_DWORD *)((char *)v36 + 0xAB) )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x28D);
        }
        v8 = *(_BYTE *)(v39 + *(_DWORD *)((char *)v36 + 0xAB) + 0xAB);
        if ( v8 != (char)0xFF )
        {
          if ( v8 >= 0x4C )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x291);
          }
          v29 = v3;
          v26 = v4;
          v23 = *(char *)(v39 + *(_DWORD *)((char *)v36 + 0xAB) + 0xAB);
          v6 = v49;
          goto LABEL_23;
        }
        v29 = v3;
        v26 = v4;
        v7 = *((_WORD *)v36 + 0xC);
        v23 = 0;
      }
      v6 = v7;
      goto LABEL_23;
    }
LABEL_4:
    v41 += 4;
  }
  sub_55274(&V_Type3_stru_10AE70, v36[2], v36[3], v36[4], v36[5]);
  if ( *((_BYTE *)v36 + 0xBB) != 0xFF )
  {
    a2.a = &V_Type6_stru_D8654;
    a2.rect.y2 = 105;
    a2.rect.x1 = 315;
    a2.rect.y1 = 7;
    a2.rect.x2 = 476;
    VFX_pane_wipe((PANE *)&a2, 0xF2);
    v27 = (a2.rect.x2 - a2.rect.x1) >> 1;
    v24 = *((char *)v36 + 0xBB);
    v10 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v49);
    VFX_shape_draw((PANE *)&a2, v10, v24, v27, 0x3A);
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x302E] = a2;
    sprintf(s, "%s", (const char *)&unk_107020 + 0x6A * *((char *)v36 + 0xBB));
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 3, 3, s, 0x42, 0xF3, 0xFF, 0);
    sub_552CC(&V_Type3_stru_10AE70, &a2);
  }
  if ( *(_DWORD *)((char *)v36 + 0xC1) )
  {
    pane.window = (WINDOW *)&V_Type6_stru_D8654;
    pane.x1 = 321;
    pane.x0 = 7;
    pane.y0 = 114;
    pane.y1 = 336;
    VFX_pane_wipe(&pane, 0);
    v11 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFECA[(unsigned __int8)byte_104BEA]);
    if ( !v11 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\shipwin.cpp", 0x2CB);
    }
    VFX_shape_draw(&pane, v11, *(char *)(*(_DWORD *)((char *)v36 + 0xAB) + 0xAA), 0, 0);
    *(_DWORD *)((char *)v36 + 0xC1) = 0;
  }
  if ( *(_DWORD *)((char *)v36 + 0xBD) )
  {
    pane.window = (WINDOW *)&V_Type6_stru_D8654;
    pane.x1 = 304;
    pane.x0 = 7;
    pane.y0 = 7;
    pane.y1 = 102;
    VFX_pane_wipe(&pane, 0);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)&pane);
    sub_53E38((P_Type5)&pane, 3, 3, (unsigned __int8)byte_104BEA);
    qmemcpy(v31, &unk_96AD4, 0x32u);
    if ( *(int **)((char *)v36 + 0xAB) != &dword_108FE8 && *(_DWORD *)((char *)v36 + 0x22F) == 0xFFFFFFFF )
    {
      v12 = v36;
      v13 = dword_D3664;
      v14 = sub_4A18C(*(_DWORD *)((char *)v36 + 0xAB));
      if ( *(_DWORD *)((char *)v12 + 0xC9) == 0xFFFFFFFF )
      {
        v14 = sub_4EE00((int)v12);
      }
      v15 = sub_46C20(v14, *(unsigned __int16 *)(v13 + 0x50), *(unsigned __int16 *)(v13 + 0x44));
      if ( v15 != 0xFFFF )
      {
        if ( v15 == 1 )
        {
          v16 = 0x1C;                                  // 28: ""
        }
        else
        {
          v16 = 0x1D;                                  // 29: "s"
        }
        Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v16);
        sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x87);// 135: " (%d Day%s)"
        sprintf(v31, sub_1CEA8);
      }
    }
    sprintf(
      s,
      "%s \"%s\"%s",
      &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)],
      (const char *)(*(_DWORD *)((char *)v36 + 0xAB) + 0x34),
      v31);
    v25 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 3, s, 2, v25, 0xFFFFFFFF, 0);
    shape_table = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE6);
    v34[0] = **(_DWORD **)((char *)v36 + 0xAB);
    v34[1] = *(_DWORD *)(*(_DWORD *)((char *)v36 + 0xAB) + 4);
    v34[2] = *(_DWORD *)(*(_DWORD *)((char *)v36 + 0xAB) + 0x10);
    v34[3] = *(_DWORD *)(*(_DWORD *)((char *)v36 + 0xAB) + 0x20);
    v18 = *(_DWORD *)((char *)v36 + 0xAB);
    v40 = 7;
    v19 = *(_DWORD *)(v18 + 0x18);
    v33 = pane;
    v34[4] = v19;
    hotY = 0x14;
    v42 = 0;
    do
    {
      v33.x1 = v33.x0 + 0x27;
      v20 = v34[v42 / 4];
      v21 = 0x28;
      if ( v20 > 0 )
      {
        v33.x1 += (0xE * v20 - (__CFSHL__((0xE * v20) >> 0x1F, 2) + 4 * ((0xE * v20) >> 0x1F))) >> 2;
      }
      v22 = 0;
      shape_number = v40;
      do
      {
        v28 = v21;
        ++v22;
        v21 += 0xE;
        VFX_shape_draw(&v33, shape_table, shape_number, v28, hotY);
      }
      while ( v22 < 0xF );
      hotY += 0xE;
      v42 += 4;
      ++v40;
    }
    while ( v42 != 0x14 );
    *(_DWORD *)((char *)v36 + 0xBD) = 0;
  }
  sub_2D218(v36);
}
// 96AD0: using guessed type int dword_96AD0;
// FFECA: using guessed type __int16 word_FFECA[7];
// FFED8: using guessed type __int16 word_FFED8;
// FFEE6: using guessed type __int16 word_FFEE6;
// 108FE8: using guessed type int dword_108FE8;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0004EE00) --------------------------------------------------------
int __fastcall sub_4EE00(int a1)
{
  int v2; // ebx
  int v3; // ecx
  int v4; // ecx

  v2 = 0x2710;
  if ( *(_DWORD *)(a1 + 0xC9) == 0xFFFFFFFF )
  {
    if ( *(_DWORD *)(a1 + 0xAB) )
    {
      v3 = sub_4A144(*(_DWORD *)(a1 + 0xAB));
      v4 = v3 - sub_4A144(a1 + 0xCD);
      v2 = 0x1E;
      if ( v4 > 0 )
      {
        return v4 + 0x1E;
      }
    }
  }
  return v2;
}

//----- (0004EE50) --------------------------------------------------------
char *sub_4EE50()
{
  char *result; // eax

  _wcpp_2_mod_register_(&unk_96B08);
  result = sub_4EE74((int)&unk_10914C);
  dword_96B10 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96B10: using guessed type int dword_96B10;

//----- (0004EE74) --------------------------------------------------------
char *__fastcall sub_4EE74(int a1)
{
  int v1; // eax
  int v2; // ecx
  char *result; // eax

  Q_InitFileInfo_sub_1BB78((P_Type1)(a1 + 0x240));
  v2 = v1 - 0x240;
  *(_DWORD *)(v2 + 0x207) = 0;
  *(_DWORD *)(v2 + 0x20B) = 0;
  *(_DWORD *)(v2 + 0x20F) = 0;
  *(_DWORD *)(v2 + 0x213) = 0;
  *(_DWORD *)(v2 + 0x217) = 0;
  *(_DWORD *)(v2 + 0x223) = 0;
  *(_DWORD *)(v2 + 0x227) = 0;
  *(_DWORD *)(v2 + 0x22B) = 0xFFFFFFFF;
  *(_BYTE *)v2 = 0;
  *(_BYTE *)(v2 + 0xFF) = 0;
  *(_BYTE *)(v2 + 0x1FE) = 0;
  *(_DWORD *)(v2 + 0x21B) = 0;
  *(_DWORD *)(v2 + 0x21F) = 0;
  *(_DWORD *)(v2 + 0x238) = 0;
  *(_DWORD *)(v2 + 0x23C) = 0;
  *(_WORD *)(v1 - 0x240 + 0x378) = 0;
  *(_WORD *)(v1 - 0x240 + 0xCA8) = 0;
  *(_WORD *)(v1 - 0x240 + 0xCAA) = 0;
  memset((void *)(v1 - 0x240 + 0xBB4), 0, 0x84u);
  memset((void *)(v2 + 0xC68), 0, 0x40u);
  memset((void *)(v2 + 0x37A), 0, 0x380u);
  *(_WORD *)(v2 + 0x6FA) = 0;
  *(_BYTE *)(v2 + 0x6FE) = 0x64;
  *(_BYTE *)(v2 + 0x6FF) = 0x7F;
  *(_WORD *)(v2 + 0x700) = 0;
  result = (char *)v2;
  *(_WORD *)(v2 + 0xBB2) = 0;
  return result;
}
// 4EE83: variable 'v1' is possibly undefined

//----- (0004EF94) --------------------------------------------------------
int __fastcall sub_4EF94(int a1)
{
  int v2; // eax

  sub_4FE8C(a1);
  Q_CloseFileAndDelete_sub_1BBC8((P_Type1)(a1 + 0x240));
  return v2 - 0x240;
}
// 4EFA9: variable 'v2' is possibly undefined

//----- (0004EFB0) --------------------------------------------------------
LONG __fastcall Q_StartSoundSystem_sub_4EFB0(int a1, int aDIG, int aMID)
{
  LONG result; // eax

  AIL_startup();
  *(_DWORD *)(a1 + 0x20F) = 0xFFFFFFFF;
  if ( aDIG == TRUE )
  {
    result = AIL_install_DIG_INI();
    *(_DWORD *)(a1 + 0x21F) = result;
    if ( !result )
    {
      return result;
    }
    sub_4F5E8(a1, 8);
    sub_4FF94((_DWORD *)a1);
    *(_DWORD *)(a1 + 0x20B) = TRUE;
  }
  if ( aMID == TRUE )
  {
    result = AIL_install_MDI_INI();
    *(_DWORD *)(a1 + 0x21B) = result;
    if ( !result )
    {
      return result;
    }
    sub_4F184(a1, 8);
    *(_DWORD *)(a1 + 0x207) = TRUE;
  }
  return 0xFFFFFFFF;
}

//----- (0004F088) --------------------------------------------------------
HMDIDRIVER __fastcall sub_4F088(char *path, char *a2, char *a3, char *a4)
{
  char *v7; // edi
  char v8; // al
  char v9; // al
  const char *v10; // esi
  char *v11; // edi
  char v12; // al
  char v13; // al
  char *v15; // edi
  char v16; // al
  char v17; // al
  char *v18; // esi
  char *v19; // edi
  char v20; // al
  char v21; // al
  HMDIDRIVER result; // eax
  IO_PARMS v24; // [esp+0h] [ebp-24h] BYREF

  v7 = path;
  do
  {
    v8 = *a2;
    *v7 = *a2;
    if ( !v8 )
    {
      break;
    }
    v9 = a2[1];
    a2 += 2;
    v7[1] = v9;
    v7 += 2;
  }
  while ( v9 );
  v10 = "\\";
  v11 = &path[strlen(path)];
  do
  {
    v12 = *v10;
    *v11 = *v10;
    if ( !v12 )
    {
      break;
    }
    v13 = v10[1];
    v10 += 2;
    v11[1] = v13;
    v11 += 2;
  }
  while ( v13 );
  v15 = &path[strlen(path)];
  do
  {
    v16 = *a3;
    *v15 = *a3;
    if ( !v16 )
    {
      break;
    }
    v17 = a3[1];
    a3 += 2;
    v15[1] = v17;
    v15 += 2;
  }
  while ( v17 );
  v18 = a4;
  v19 = path + 0x1FE;
  do
  {
    v20 = *v18;
    *v19 = *v18;
    if ( !v20 )
    {
      break;
    }
    v21 = v18[1];
    v18 += 2;
    v19[1] = v21;
    v19 += 2;
  }
  while ( v21 );
  AIL_set_GTL_filename_prefix(path + 0x1FE);
  memset(&v24, 0, sizeof(v24));
  v24.IO = 0x240;
  v24.IRQ = 9;
  result = AIL_install_MDI_driver_file(path, &v24);
  *(_DWORD *)(path + 0x21B) = result;
  if ( result )
  {
    sub_4F184((int)path, 8);
    result = (HMDIDRIVER)0xFFFFFFFF;
    *(_DWORD *)(path + 0x207) = 0xFFFFFFFF;
  }
  return result;
}

//----- (0004F184) --------------------------------------------------------
int __fastcall sub_4F184(int a1, int a2)
{
  __int16 i; // si
  HSEQUENCE sequence_handle; // edx
  int v6; // eax

  if ( *(_WORD *)(a1 + 0xCA8) )
  {
    return 0;
  }
  if ( a2 > 8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0xDA);
  }
  for ( i = 0; i < a2; ++i )
  {
    sequence_handle = AIL_allocate_sequence_handle(*(HMDIDRIVER *)(a1 + 0x21B));
    v6 = a1 + 8 * i;
    *(_DWORD *)(v6 + 0xC68) = sequence_handle;
    if ( !sequence_handle )
    {
      break;
    }
    *(_DWORD *)(v6 + 0xC6C) = 0;
  }
  *(_WORD *)(a1 + 0xCA8) = i;
  return *(__int16 *)(a1 + 0xCA8);
}

//----- (0004F32C) --------------------------------------------------------
void __fastcall sub_4F32C(int a1, __int16 a2, int a3)
{
  int v4; // [esp+0h] [ebp-14h]

  if ( *(_DWORD *)(a1 + 0x217) != 0xFFFFFFFF && *(_DWORD *)(a1 + 0x207) )
  {
    if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xCA8) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x12A);
    }
    if ( !*(_DWORD *)(a1 + 8 * a2 + 0xC6C) )
    {
      sprintf("Thank you for playing Ascendancy.", "Attempt play Sequence Track %d with NULL data.\n\n", a2);
      Q_debugbreak_exit_sub_2624C();
    }
    v4 = a1 + 8 * a2;
    if ( AIL_sequence_status(*(HSEQUENCE *)(v4 + 0xC68)) == 4 )
    {
      if ( a3 != 0xFFFFFFFF )
      {
        return;
      }
      AIL_stop_sequence(*(HSEQUENCE *)(v4 + 0xC68));
    }
    AIL_start_sequence(*(HSEQUENCE *)(a1 + 8 * a2 + 0xC68));
  }
}
// 4F3A4: conditional instruction was optimized away because ecx.4!=0

//----- (0004F45C) --------------------------------------------------------
void __fastcall sub_4F45C(int a1, __int16 a2)
{
  int v2; // esi

  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xCA8) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x152);
  }
  v2 = 8 * a2 + a1;
  if ( *(_DWORD *)(v2 + 0xC6C) )
  {
    AIL_end_sequence(*(HSEQUENCE *)(v2 + 0xC68));
  }
}

//----- (0004F4D4) --------------------------------------------------------
void __fastcall sub_4F4D4(int a1, __int16 a2)
{
  int v2; // esi

  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0xCA8) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x166);
  }
  v2 = a1 + 8 * a2;
  if ( *(_DWORD *)(v2 + 0xC6C) )
  {
    AIL_end_sequence(*(HSEQUENCE *)(v2 + 0xC68));
    if ( *(_DWORD *)(v2 + 0xC6C) )
    {
      MEM_free(*(void **)(v2 + 0xC6C));
    }
  }
}

//----- (0004F534) --------------------------------------------------------
HDIGDRIVER __fastcall sub_4F534(_DWORD *a1, char *a2, char *a3)
{
  BYTE *v5; // edx
  char *v6; // edi
  char v7; // al
  char v8; // al
  const char *v9; // esi
  char *v10; // edi
  char v11; // al
  char v12; // al
  char *v14; // edi
  char v15; // al
  char v16; // al
  HDIGDRIVER result; // eax
  const char *v18; // [esp-4h] [ebp-14h]

  v5 = (char *)a1 + 0xFF;
  v6 = (char *)a1 + 0xFF;
  v18 = (char *)a1 + 0xFF;
  do
  {
    v7 = *a2;
    *v6 = *a2;
    if ( !v7 )
    {
      break;
    }
    v8 = a2[1];
    a2 += 2;
    v6[1] = v8;
    v6 += 2;
  }
  while ( v8 );
  v9 = "\\";
  v10 = (char *)&v18[strlen(v18)];
  do
  {
    v11 = *v9;
    *v10 = *v9;
    if ( !v11 )
    {
      break;
    }
    v12 = v9[1];
    v9 += 2;
    v10[1] = v12;
    v10 += 2;
  }
  while ( v12 );
  v14 = (char *)&v18[strlen(v18)];
  do
  {
    v15 = *a3;
    *v14 = *a3;
    if ( !v15 )
    {
      break;
    }
    v16 = a3[1];
    a3 += 2;
    v14[1] = v16;
    v14 += 2;
  }
  while ( v16 );
  result = AIL_install_DIG_driver_file(v5, 0);
  *(_DWORD *)((char *)a1 + 0x21F) = result;
  if ( result )
  {
    sub_4F5E8((int)a1, 8);
    sub_4FF94(a1);
    result = (HDIGDRIVER)0xFFFFFFFF;
    *(_DWORD *)((char *)a1 + 0x20B) = 0xFFFFFFFF;
  }
  return result;
}

//----- (0004F5E8) --------------------------------------------------------
int __fastcall sub_4F5E8(int a1, int a2)
{
  __int16 i; // si
  HSAMPLE sample_handle; // eax

  if ( *(_WORD *)(a1 + 0x378) )
  {
    return 0;
  }
  if ( a2 > 8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x199);
  }
  for ( i = 0; i < a2; ++i )
  {
    sample_handle = AIL_allocate_sample_handle(*(HDIGDRIVER *)(a1 + 0x21F));
    *(_DWORD *)(a1 + 4 * i + 0x358) = sample_handle;
    if ( !sample_handle )
    {
      break;
    }
  }
  *(_WORD *)(a1 + 0x378) = i;
  return *(__int16 *)(a1 + 0x378);
}

//----- (0004F65C) --------------------------------------------------------
int __fastcall sub_4F65C(int a1, const char *a2)
{
  SAMPLE *v5; // esi
  char *v6; // eax
  int v7; // edx
  int v8; // ebx
  __int16 v9; // si
  int v10; // ecx
  int v11; // eax
  DIG_DRIVER *v12; // [esp-Ch] [ebp-80h]
  char v13[80]; // [esp+0h] [ebp-74h] BYREF
  int v14; // [esp+50h] [ebp-24h] BYREF
  int v15; // [esp+54h] [ebp-20h]
  int v16; // [esp+58h] [ebp-1Ch]
  FILE *fp; // [esp+5Ch] [ebp-18h]

  if ( *(_DWORD *)(a1 + 0x20B) != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1B4);
  }
  if ( *(__int16 *)(a1 + 0x378) <= 0 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1B5);
  }
  if ( !*(_DWORD *)(a1 + 0x20B) || *(__int16 *)(a1 + 0x378) < 8 )
  {
    return 0;
  }
  if ( *(_DWORD *)(a1 + 0x223) == 0xFFFFFFFF )
  {
    return 0xFFFFFFFF;
  }
  v5 = *(SAMPLE **)(a1 + 0x358);
  AIL_init_sample(v5);
  AIL_set_sample_type(v5, DIG_F_MONO_8, 0);
  AIL_set_sample_playback_rate(v5, 22050);
  v12 = *(DIG_DRIVER **)(a1 + 0x21F);
  v15 = 0xC800;
  if ( AIL_minimum_sample_buffer_size(v12, 22050, DIG_F_MONO_8) >= 0xC800 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1C9);
  }
  v6 = (char *)sub_2628C(2 * v15, 4, "DigitalMusicBuf");
  v7 = v15;
  *(_DWORD *)(a1 + 0x238) = v6;
  v8 = *(_DWORD *)(a1 + 0x238);
  *(_DWORD *)(a1 + 0x23C) = &v6[v7];
  if ( !v8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1D0);
  }
  if ( !*(_DWORD *)(a1 + 0x238) )
  {
    return 0;
  }
  if ( a2 )
  {
    fp = sub_1BB10(a2, 0);
    if ( !fp )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1DB);
    }
    fscanf(fp, "%d", &v14);
    if ( v14 > 0x20 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1E2);
    }
    v9 = 0;
    v16 = a1 + 0x37A;
    while ( v9 < v14 )
    {
      fscanf(fp, "%s", v13);
      if ( strlen(v13) >= 0x18 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x1E8);
      }
      v10 = 0x1C * v9;
      strncpy((char *)(v10 + v16), v13, 0x18u);
      *(_BYTE *)(v10 + a1 + 0x391) = 0;
      ++v9;
      *(_DWORD *)(v10 + a1 + 0x392) = 0;
    }
    *(_WORD *)(a1 + 0x6FA) = v14;
    fclose(fp);
  }
  *(_DWORD *)(a1 + 0x223) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x22B) = 0;
  *(_DWORD *)(a1 + 0x233) = 0;
  v11 = v15;
  *(_BYTE *)(a1 + 0x237) = 0;
  *(_DWORD *)(a1 + 0x22F) = v11;
  return 0xFFFFFFFF;
}
// 4F738: conditional instruction was optimized away because eax.4<C800

//----- (0004F8CC) --------------------------------------------------------
unsigned int __fastcall sub_4F8CC(int a1, __int16 a2, int a3)
{
  unsigned int result; // eax
  SAMPLE *v5; // ebp

  if ( *(_DWORD *)(a1 + 0x22B) == 0xFFFFFFFF || !*(_DWORD *)(a1 + 0x20B) )
  {
    return 0;
  }
  if ( a2 < 0 || a2 >= *(__int16 *)(a1 + 0x6FA) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x200);
  }
  if ( *(__int16 *)(a1 + 0x6FC) != 0xFFFFFFFF )
  {
    *(_DWORD *)(a1 + 0x1C * *(__int16 *)(a1 + 0x6FC) + 0x392) = sub_1BEA0((int *)(a1 + 0x240));
  }
  sub_4FA1C(a1);
  v5 = *(SAMPLE **)(a1 + 0x358);
  AIL_init_sample(v5);
  AIL_set_sample_type(v5, 0, 0);
  AIL_set_sample_playback_rate(v5, 0x5622);
  sub_4FF4C(a1, *(_BYTE *)(a1 + 0x6FE));
  if ( Q_CfilePreload_sub_1BBFC((P_Type1)(a1 + 0x240), (const char *)(0x1C * a2 + a1 + 0x37A), 0x200, 0) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x214);
  }
  if ( a3 == 0xFFFFFFFF )
  {
    sub_1BF0C((int *)(a1 + 0x240), *(_DWORD *)(a1 + 0x1C * a2 + 0x392));
  }
  *(_DWORD *)(a1 + 0x227) = 0xFFFFFFFF;
  result = 0xFFFFFFFF;
  *(_WORD *)(a1 + 0x6FC) = a2;
  return result;
}

//----- (0004FA1C) --------------------------------------------------------
int __fastcall sub_4FA1C(int result)
{
  int v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // ebx
  SAMPLE *v5; // [esp-10h] [ebp-14h]

  v1 = result;
  if ( *(_DWORD *)(result + 0x227) == 0xFFFFFFFF )
  {
    v5 = *(SAMPLE **)(result + 0x358);
    *(_DWORD *)(result + 0x227) = 0;
    AIL_stop_sample(v5);
    v2 = sub_1BEA0((int *)(v1 + 0x240));
    v3 = *(__int16 *)(v1 + 0x6FC);
    v4 = v2;
    result = 7 * v3;
    *(_DWORD *)(v1 + 0x1C * v3 + 0x392) = v4;
  }
  return result;
}

//----- (0004FAB4) --------------------------------------------------------
void __fastcall sub_4FAB4(int a1)
{
  SAMPLE *v2; // edi
  LONG v3; // eax
  signed int v4; // ebx
  int v5; // eax
  ULONG v6; // edx

  if ( *(_DWORD *)(a1 + 0x22B) != 0xFFFFFFFF && *(_DWORD *)(a1 + 0x20B) )
  {
    v2 = *(SAMPLE **)(a1 + 0x358);
    v3 = AIL_sample_buffer_ready(v2);
    if ( v3 != 0xFFFFFFFF )
    {
      *(_DWORD *)(a1 + 0x233) = 0;
      *(_BYTE *)(a1 + 0x237) = v3;
    }
    v4 = *(_DWORD *)(a1 + 0x22F) - *(_DWORD *)(a1 + 0x233);
    if ( v4 > 0x1400 )
    {
      v4 = 0x1400;
    }
    if ( v4 )
    {
      v5 = sub_1BF94(
             (P_Type1)(a1 + 0x240),
             (void *)(*(_DWORD *)(a1 + 0x233) + *(_DWORD *)(a1 + 4 * *(char *)(a1 + 0x237) + 0x238)),
             v4);
      v6 = v5 + *(_DWORD *)(a1 + 0x233);
      *(_DWORD *)(a1 + 0x233) = v6;
      if ( v5 )
      {
        AIL_load_sample_buffer(v2, *(char *)(a1 + 0x237), *(void **)(a1 + 4 * *(char *)(a1 + 0x237) + 0x238), v6);
      }
      else
      {
        sub_1BECC((int *)(a1 + 0x240), 0, 0);
        sub_4FA1C(a1);
      }
    }
  }
}

//----- (0004FB90) --------------------------------------------------------
int __fastcall sub_4FB90(int result, __int16 a2)
{
  int v2; // ebp
  int i; // edi
  SAMPLE *v4; // esi
  int v5; // edx
  int v6; // [esp+0h] [ebp-1Ch]
  int v7; // [esp+4h] [ebp-18h]

  v7 = result;
  if ( *(_DWORD *)(result + 0x213) != 0xFFFFFFFF )
  {
    if ( *(_DWORD *)(result + 0x20B) )
    {
      result = sub_50140(result, a2);
      v6 = result;
      if ( result )
      {
        v2 = 1;
        for ( i = v7 + 4; ; i += 4 )
        {
          result = *(__int16 *)(v7 + 0x378);
          if ( v2 >= result )
          {
            break;
          }
          v4 = *(SAMPLE **)(i + 0x358);
          if ( AIL_sample_status(v4) != 4 )
          {
            AIL_init_sample(v4);
            AIL_set_sample_type(v4, *(__int16 *)(v6 + 0x10), 0);
            AIL_set_sample_address(v4, *(void **)(v6 + 8), *(_DWORD *)(v6 + 0xC));
            AIL_set_sample_playback_rate(v4, *(__int16 *)(v6 + 0x12));
            AIL_set_sample_volume(v4, *(char *)(v7 + 0x6FF));
            AIL_set_sample_loop_count(v4, 1);
            AIL_start_sample(v4);
            v5 = 0;
            *(_DWORD *)v6 = v4;
            result = v7 + 0xBB4;
            do
            {
              if ( result != v6 && v4 == *(SAMPLE **)result )
              {
                *(_DWORD *)result = 0;
              }
              ++v5;
              result += 0x16;
            }
            while ( v5 < 6 );
            return result;
          }
          ++v2;
        }
      }
    }
  }
  return result;
}

//----- (0004FE8C) --------------------------------------------------------
void __fastcall sub_4FE8C(int result)
{
  __int16 i; // bx
  int v3; // edi
  int j; // ebp
  SAMPLE *v5; // [esp-4h] [ebp-1Ch]

  if ( *(_DWORD *)(result + 0x20F) == 0xFFFFFFFF )
  {
    for ( i = 0; i < *(__int16 *)(result + 0xCA8); ++i )
    {
      sub_4F4D4(result, i);
    }
    v3 = result;
    for ( j = 0; j < *(__int16 *)(result + 0x378); ++j )
    {
      v5 = *(SAMPLE **)(v3 + 0x358);
      v3 += 4;
      AIL_stop_sample(v5);
    }
    sub_262CC(*(void **)(result + 0xBB8));
    AIL_shutdown();
    *(_DWORD *)(result + 0x20F) = 0;
  }
}

//----- (0004FF08) --------------------------------------------------------
void __fastcall __spoils<> sub_4FF08(int a1)
{
  sub_4FF1C(a1);
  sub_4FF28(a1);
}

//----- (0004FF1C) --------------------------------------------------------
void __fastcall __spoils<> sub_4FF1C(int result)
{
  *(_DWORD *)(result + 0x217) = 0xFFFFFFFF;
}

//----- (0004FF28) --------------------------------------------------------
void __fastcall __spoils<> sub_4FF28(int result)
{
  *(_DWORD *)(result + 0x213) = 0xFFFFFFFF;
}

//----- (0004FF4C) --------------------------------------------------------
void __fastcall sub_4FF4C(int a1, char a2)
{
  if ( a2 >= 0 )
  {
    *(_BYTE *)(a1 + 0x6FE) = a2;
  }
  AIL_set_sample_volume(*(HSAMPLE *)(a1 + 0x358), *(char *)(a1 + 0x6FE));
}

//----- (0004FF94) --------------------------------------------------------
int __fastcall sub_4FF94(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int v2; // esi
  int v3; // edi
  FILE *v4; // ebp
  char *v5; // eax
  _DWORD *v6; // edx
  char *v7; // ecx
  int v8; // ebx
  _DWORD *v9; // edi
  _DWORD *v10; // eax
  _DWORD *v11; // edx
  _DWORD *v12; // ecx
  _DWORD *v13; // esi
  int v14; // edx
  char *v15; // ebx
  char *v17; // [esp-4h] [ebp-2Ch]
  int v18; // [esp+0h] [ebp-28h] BYREF
  int v19; // [esp+4h] [ebp-24h] BYREF
  _DWORD *v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]

  v20 = a1;
  v1 = a1;
  v2 = 0;
  v3 = 0;
  v4 = sub_1BB10("soundfx.txt", 0);
  v21 = 0;
  do
  {
    fscanf(v4, "%d %d", &v18, &v19);
    v1[0x314] = v2;
    v1[0x317] = v2 + v18 - 1;
    v1[0x311] = v19;
    v21 += v19 * v18;
    if ( v3 > 0 && v1[0x311] < v1[0x310] )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x347);
    }
    ++v1;
    ++v3;
    v2 += v18;
  }
  while ( v3 < 3 );
  if ( v2 != 6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x34D);
  }
  v5 = (char *)sub_2628C(v21, 1, "SFX CACHE");
  v6 = v20;
  v7 = v5;
  v8 = 0;
  v9 = v20;
  v10 = v20 + 0x2ED;
  do
  {
    *v10 = 0;
    *((_WORD *)v10 + 8) = 0;
    *((_WORD *)v10 + 9) = 0x5622;
    *((_WORD *)v10 + 0xA) = 0xFFFF;
    if ( v8 > v6[0x317] )
    {
      ++v6;
    }
    v9[0x2EE] = v7;
    v9 = (_DWORD *)((char *)v9 + 0x16);
    ++v8;
    v10 = (_DWORD *)((char *)v10 + 0x16);
    v7 += v6[0x311];
  }
  while ( v8 < 6 );
  fscanf(v4, "%d", &v18);
  v11 = v20;
  *((_WORD *)v20 + 0x380) = v18;
  if ( *((unsigned __int16 *)v11 + 0x380) >= 0x64u )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x369);
  }
  v12 = v20;
  v13 = v20;
  v14 = 0;
  v15 = (char *)v20 + 0x702;
  while ( v14 < *((unsigned __int16 *)v13 + 0x380) )
  {
    v17 = v15;
    v12 = (_DWORD *)((char *)v12 + 2);
    ++v14;
    v15 += 0xA;
    fscanf(v4, "%s", v17);
    *((_WORD *)v12 + 0x574) = 0xFFFF;
  }
  return fclose(v4);
}

//----- (00050140) --------------------------------------------------------
int __fastcall sub_50140(int a1, __int16 a2)
{
  int v4; // edx
  int v5; // ecx
  int k; // eax
  int m; // ecx
  int v8; // edi
  int v9; // ecx
  int v10; // eax
  unsigned int v11; // edx
  int v12; // edx
  int v13; // ecx
  int v14; // ebp
  int v15; // eax
  int v16; // ebp
  int v17; // edi
  int v18; // eax
  int v19; // ebp
  int v20; // ecx
  int i; // eax
  int j; // ecx
  unsigned __int16 v23; // di
  int v24; // edx
  T_Type1 v25; // [esp+0h] [ebp-178h] BYREF
  char s[52]; // [esp+118h] [ebp-60h] BYREF
  int v27; // [esp+14Ch] [ebp-2Ch]
  int v28; // [esp+150h] [ebp-28h]
  int v29; // [esp+154h] [ebp-24h]
  int v30; // [esp+158h] [ebp-20h]
  int v31; // [esp+15Ch] [ebp-1Ch]
  int v32; // [esp+160h] [ebp-18h]

  LOWORD(v32) = a2;
  if ( *(_DWORD *)(a1 + 0x213) == 0xFFFFFFFF || !*(_DWORD *)(a1 + 0x20B) )
  {
    return 0;
  }
  if ( (v32 & 0x8000u) != 0 || (__int16)v32 >= (int)*(unsigned __int16 *)(a1 + 0x700) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x37B);
  }
  v28 = 0;
  if ( (v32 & 0x8000u) != 0 || (__int16)v32 >= (int)*(unsigned __int16 *)(a1 + 0x700) )
  {
    return v28;
  }
  v4 = *(__int16 *)(a1 + 2 * (__int16)v32 + 0xAEA);
  if ( v4 == 0xFFFFFFFF )
  {
    sprintf(s, "data\\%s.voc", (const char *)(a1 + 0x702 + 0xA * (__int16)v32));
    Q_InitFileInfo_sub_1BB78(&v25);
    Q_CfilePreload_sub_1BBFC(&v25, s, 0x200, 0);
    v11 = 0;
    v30 = sub_1BE28(&v25);
    v9 = 0;
    v10 = a1;
    while ( v30 >= *(_DWORD *)(v10 + 0xC44) )
    {
      ++v9;
      v10 += 4;
      if ( v9 >= 3 )
      {
        goto LABEL_23;
      }
    }
    v11 = 0xFFFFFFFF;
LABEL_23:
    if ( v11 != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\ssystem.cpp", 0x3AD);
    }
    v12 = v9;
    v13 = *(_DWORD *)(a1 + 4 * v9 + 0xC50);
    v27 = 0xFFFFFFFF;
    v14 = a1 + 4 * v12;
    v15 = a1 + 0x16 * v13;
    if ( v13 <= *(_DWORD *)(v14 + 0xC5C) )
    {
      while ( *(__int16 *)(v15 + 0xBC8) != 0xFFFFFFFF )
      {
        ++v13;
        v15 += 0x16;
        if ( v13 > *(_DWORD *)(v14 + 0xC5C) )
        {
          goto LABEL_30;
        }
      }
      v27 = v13;
    }
LABEL_30:
    if ( v27 == 0xFFFFFFFF )
    {
      v31 = a1;
      v16 = 0;
      v29 = 4 * v12;
      while ( v16 < *(unsigned __int16 *)(a1 + 0xBB2) )
      {
        v17 = *(__int16 *)(a1 + 2 * *(unsigned __int16 *)(v31 + 0xC38) + 0xAEA);
        if ( v17 >= *(_DWORD *)(a1 + v29 + 0xC50) && v17 <= *(_DWORD *)(a1 + v29 + 0xC5C) )
        {
          v18 = a1 + 0x16 * v17;
          if ( !*(_DWORD *)(v18 + 0xBB4) || AIL_sample_status(*(HSAMPLE *)(v18 + 0xBB4)) != 4 )
          {
            v27 = v17;
            break;
          }
        }
        ++v16;
        v31 += 2;
      }
    }
    if ( v27 != 0xFFFFFFFF )
    {
      v19 = *(__int16 *)(0x16 * v27 + a1 + 0xBB4 + 0x14);
      v28 = 0x16 * v27 + a1 + 0xBB4;
      if ( v19 != 0xFFFFFFFF )
      {
        v20 = a1;
        for ( i = 0; i < *(unsigned __int16 *)(a1 + 0xBB2) && *(unsigned __int16 *)(v20 + 0xC38) != v19; ++i )
        {
          v20 += 2;
        }
        for ( j = a1 + 2 * i; ; *(_WORD *)(j + 0xC36) = *(_WORD *)(j + 0xC38) )
        {
          v23 = *(_WORD *)(a1 + 0xBB2);
          if ( i >= v23 )
          {
            break;
          }
          j += 2;
          ++i;
        }
        *(_WORD *)(a1 + 0xBB2) = v23 - 1;
        *(_WORD *)(a1 + 2 * v19 + 0xAEA) = 0xFFFF;
      }
      Q_CfileLoad_sub_1BF1C(&v25, *(void **)(v28 + 4));
      v24 = v28;
      *(_DWORD *)(v28 + 8) = *(_DWORD *)(v28 + 4) + 0x2A;
      *(_DWORD *)(v24 + 0xC) = v30 - 0x2B;
      *(_WORD *)(v24 + 0x14) = v32;
      *(_WORD *)(a1 + 2 * (__int16)v32 + 0xAEA) = v27;
      LOWORD(v24) = *(_WORD *)(a1 + 0xBB2);
      *(_WORD *)(a1 + 0xBB2) = v24 + 1;
      *(_WORD *)(a1 + 2 * (unsigned __int16)v24 + 0xC38) = v32;
    }
    Q_CloseFileAndDelete_sub_1BBC8(&v25);
    return v28;
  }
  v5 = a1;
  v28 = 0x16 * v4 + a1 + 0xBB4;
  for ( k = 0; k < *(unsigned __int16 *)(a1 + 0xBB2) && *(unsigned __int16 *)(v5 + 0xC38) != (__int16)v32; ++k )
  {
    v5 += 2;
  }
  for ( m = a1 + 2 * k; ; *(_WORD *)(m + 0xC36) = *(_WORD *)(m + 0xC38) )
  {
    v8 = *(unsigned __int16 *)(a1 + 0xBB2);
    if ( k >= (unsigned __int16)v8 )
    {
      break;
    }
    m += 2;
    ++k;
  }
  *(_WORD *)(a1 + 2 * v8 + 0xC36) = v32;
  return v28;
}

//----- (00050530) --------------------------------------------------------
unsigned __int16 __fastcall sub_50530(T_Type5 *a1, int a2, int a3, int a4)
{
  __int16 *v6; // esi
  void *v7; // eax
  void *v8; // ecx
  int v9; // edi
  const char *v10; // ecx
  __int16 v11; // ax
  LONG *p_x0; // esi
  LONG *v13; // esi
  int v14; // edx
  char *sub_1CEA8; // eax
  LONG *v16; // esi
  int v17; // ebx
  PANE *v18; // esi
  __int16 v19; // cx
  char *v20; // eax
  unsigned int v21; // edx
  char *v22; // edi
  char *v23; // esi
  char v24; // al
  char v25; // al
  int v26; // eax
  char *v27; // eax
  char *v28; // eax
  char *v29; // edi
  char *v30; // esi
  char v31; // al
  char v32; // al
  char *v33; // esi
  char *v34; // edi
  char v35; // al
  char v36; // al
  int v37; // ebx
  LONG *v38; // esi
  int v39; // esi
  unsigned __int16 v40; // di
  int v41; // eax
  void *v42; // eax
  void *v43; // eax
  int v44; // eax
  void *v45; // eax
  LONG v46; // eax
  void *v47; // eax
  LONG v48; // edi
  int v49; // eax
  int i; // esi
  unsigned __int16 result; // ax
  void *v52; // eax
  LONG v53; // [esp-10h] [ebp-F4h]
  LONG v54; // [esp-10h] [ebp-F4h]
  LONG v55; // [esp-10h] [ebp-F4h]
  LONG v56; // [esp-10h] [ebp-F4h]
  LONG v57; // [esp-8h] [ebp-ECh]
  __int16 x_4; // [esp+4h] [ebp-E0h]
  __int16 x_4a; // [esp+4h] [ebp-E0h]
  __int16 x_4b; // [esp+4h] [ebp-E0h]
  LONG x_4c; // [esp+4h] [ebp-E0h]
  __int64 v62; // [esp+8h] [ebp-DCh]
  unsigned __int64 v63; // [esp+8h] [ebp-DCh]
  __int64 v64; // [esp+8h] [ebp-DCh]
  LONG v65; // [esp+Ch] [ebp-D8h]
  char s[100]; // [esp+10h] [ebp-D4h] BYREF
  char v67[60]; // [esp+74h] [ebp-70h] BYREF
  LONG v68; // [esp+B0h] [ebp-34h]
  LONG hotY; // [esp+B4h] [ebp-30h]
  int v70; // [esp+B8h] [ebp-2Ch]
  int v71; // [esp+BCh] [ebp-28h]
  PANE *pane; // [esp+C0h] [ebp-24h]
  int v73; // [esp+C4h] [ebp-20h]
  char *string; // [esp+C8h] [ebp-1Ch]
  int v75; // [esp+CCh] [ebp-18h]
  int v76; // [esp+D0h] [ebp-14h]
  LONG shape_number; // [esp+D4h] [ebp-10h]

  pane = (PANE *)a1;
  v6 = &word_A3D21[0x30 * *(__int16 *)(a2 + 0xC)];
  v7 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B2A);
  if ( !v7 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x41);
  }
  VFX_shape_draw(pane, v7, *(_DWORD *)v6, 0x4B, 0x4B);
  v8 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B2C);
  if ( !v8 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x45);
  }
  VFX_shape_draw(pane, v8, *(unsigned __int16 *)(a2 + 0x14) + 5 * *(unsigned __int16 *)(a2 + 0x16), 0xC8, 0x4B);
  v73 = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  v70 = v73;
  if ( a4 )
  {
    if ( new_x >= 0x96 )
    {
      v73 = 0xF3;
    }
    else
    {
      v70 = 0xF3;
    }
  }
  v9 = *((unsigned __int8 *)v6 + 0x14);
  if ( v9 == 1 << byte_104BEA
    || v6 == *(__int16 **)((char *)&dword_A2F79 + 0x1EE * (unsigned __int8)byte_104BEA)
    && ((1 << byte_104BEA) & v9) != 0 )
  {
    sub_53E38((P_Type5)pane, 4, 0xA, (unsigned __int8)byte_104BEA);
  }
  v10 = (const char *)&word_A3D21[0x30 * *(__int16 *)(a2 + 0xC) + 0xE];
  v11 = v70;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = pane->window;
  p_x0 = &pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = *++p_x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = *++p_x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = p_x0[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x78, 0x12, v10, 0, v11, 0xFF, 0);
  string = (char *)(a2 + 0x24);
  x_4 = v73;
  v71 = (__int16)v73;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = pane->window;
  v13 = &pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *++v13;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *++v13;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v13[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x113, 0xF, (const char *)(a2 + 0x24), 0, x_4, 0xFF, 0);
  v14 = sub_2B4F4(&V_Type3_stru_10AE70.z1[0x3046], string) + 0x127;
  HIDWORD(v62) = dword_10469C[*(unsigned __int16 *)(a2 + 0x16)];
  LODWORD(v62) = dword_104688[*(unsigned __int16 *)(a2 + 0x14)];
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x88);// 136: "(%s %s Planet)"
  sprintf(s, sub_1CEA8, v62);
  x_4a = v71;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = pane->window;
  v16 = &pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = *++v16;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = *++v16;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v16[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], v14, 0x10, s, 0, x_4a, 0xFF, 0);
  v17 = *(_DWORD *)(a2 + 0x5A);
  v68 = 0x1E;
  if ( v17 == 0xFFFFFFFF )
  {
    v18 = pane;
    v19 = v71;
    v20 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x89);    // 137: "Self-Managed"
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = v18->window;
    v18 = (PANE *)((char *)v18 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = v18->window;
    v18 = (PANE *)((char *)v18 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = v18->window;
    v18 = (PANE *)((char *)v18 + 4);
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = v18->window;
    *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v18->x0;
    v68 = 0x27;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x113, 0x1E, v20, 0, v19, 0xFF, 0);
  }
  if ( *(_BYTE *)(a2 + 0x54) == 0xFF )
  {
    v29 = s;
    v30 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8D);    // 141: "No Project"
    do
    {
      v31 = *v30;
      *v29 = *v30;
      if ( !v31 )
      {
        break;
      }
      v32 = v30[1];
      v30 += 2;
      v29[1] = v32;
      v29 += 2;
    }
    while ( v32 );
    if ( *(_WORD *)(a2 + 0x42) == *(_WORD *)(a2 + 0x4C) )
    {
      v33 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8E);  // 142: "   (No Free Population)"
      v34 = &s[strlen(s)];
      do
      {
        v35 = *v33;
        *v34 = *v33;
        if ( !v35 )
        {
          break;
        }
        v36 = v33[1];
        v33 += 2;
        v34[1] = v36;
        v34 += 2;
      }
      while ( v36 );
    }
    v73 = 0xF3;
  }
  else
  {
    qmemcpy(v67, &unk_96B30, sizeof(v67));
    if ( (word_103FA2[0x14 * *(unsigned __int8 *)(a2 + 0x54)] & 2) == 0 )
    {
      v21 = (unsigned __int16)sub_358BC(a2);
      if ( (unsigned __int16)v21 == 0xFFFF )
      {
        v22 = v67;
        v23 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8A);// 138: " - No Progress"
        do
        {
          v24 = *v23;
          *v22 = *v23;
          if ( !v24 )
          {
            break;
          }
          v25 = v23[1];
          v23 += 2;
          v22[1] = v25;
          v22 += 2;
        }
        while ( v25 );
      }
      else
      {
        if ( v21 == 1 )
        {
          v26 = 0x1C;                                  // 28: ""
        }
        else
        {
          v26 = 0x1D;                                  // 29: "s"
        }
        v63 = __PAIR64__((unsigned int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v26), v21);
        v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8B);// 139: " - %d day%s until completion"
        sprintf(v67, v27, v63);
      }
    }
    HIDWORD(v64) = v67;
    LODWORD(v64) = &dword_103F9A[0xA * *(unsigned __int8 *)(a2 + 0x54) + 3];
    v28 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8C);    // 140: "Building %s%s"
    sprintf(s, v28, v64);
  }
  v37 = v68;
  x_4b = v73;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = pane->window;
  v38 = &pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = pane->x0;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = *++v38;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = *++v38;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = v38[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x113, v37, s, 0, x_4b, 0xFF, 0);
  v39 = 0;
  v68 = 0x19;
  v40 = word_FFEDC;
  v75 = (unsigned __int16)word_96B6C;
  do
  {
    v41 = (unsigned __int16)sub_35930(a2, *((_BYTE *)&v75 + v39));
    if ( v41 != 0xFFFF )
    {
      v41 = *(_WORD *)(*(_DWORD *)(a2 + 0x10) + 4 * v41 + 2) & 1;
      if ( v41 )
      {
        v57 = v68;
        v53 = *((unsigned __int8 *)&v75 + v39);
        v42 = (void *)sub_1B084((unsigned int)dword_12FC20, v40);
        VFX_shape_transform(pane, v42, v53, 0xF5, v57, buffer, 0, 0x4000, 0x4000, 0);
        v68 += 0x19;
      }
    }
    ++v39;
  }
  while ( v39 < 2 );
  LOWORD(v41) = word_FFEEC;
  v76 = v41;
  string = (char *)*(unsigned __int16 *)(a2 + 0x46);
  string = (char *)(int)pow((double)(int)string, 0.75);
  shape_number = (LONG)string;
  if ( (unsigned __int16)string > 0x14u )
  {
    shape_number = 0x14;
  }
  v54 = (unsigned __int16)shape_number;
  v43 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
  VFX_shape_transform(pane, v43, v54, 0x118, 0x3C, buffer, 0, 0x8000, 0x8000, 0);
  LOWORD(v44) = word_FFEEE;
  v76 = v44;
  string = (char *)*(unsigned __int16 *)(a2 + 0x44);
  string = (char *)(int)pow((double)(int)string, 0.75);
  shape_number = (LONG)string;
  if ( (unsigned __int16)string > 0x14u )
  {
    shape_number = 0x14;
  }
  v55 = (unsigned __int16)shape_number;
  v45 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
  VFX_shape_transform(pane, v45, v55, 0x15E, 0x3C, buffer, 0, 0x8000, 0x8000, 0);
  LOWORD(v46) = word_FFEF0;
  v76 = v46;
  LOWORD(v46) = *(_WORD *)(a2 + 0x48);
  shape_number = v46;
  if ( (unsigned __int16)v46 > 0x14u )
  {
    shape_number = 0x14;
  }
  v56 = (unsigned __int16)shape_number;
  v47 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
  v48 = 0x1EA;
  VFX_shape_transform(pane, v47, v56, 0x1A4, 0x3C, buffer, 0, 0x8000, 0x8000, 0);
  LOWORD(v49) = word_FFEF8;
  hotY = 0x3C;
  v76 = v49;
  shape_number = 6;
  for ( i = 0; ; ++i )
  {
    result = *(_WORD *)(a2 + 0x4A);
    if ( i >= result )
    {
      break;
    }
    if ( i == *(unsigned __int16 *)(a2 + 0x4C) )
    {
      shape_number = 7;
    }
    if ( i == *(unsigned __int16 *)(a2 + 0x42) )
    {
      shape_number = 8;
    }
    v65 = hotY;
    x_4c = (unsigned __int16)shape_number;
    v52 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v76);
    VFX_shape_draw(pane, v52, x_4c, v48, v65);
    v48 += 5;
    if ( i % 0xA == 9 )
    {
      v48 = 0x1EA;
      hotY += 5;
    }
  }
  return result;
}
// 50A78: variable 'v41' is possibly undefined
// 50B38: variable 'v44' is possibly undefined
// 50BF8: variable 'v46' is possibly undefined
// 50C99: variable 'v49' is possibly undefined
// 96B2A: using guessed type __int16 word_96B2A;
// 96B2C: using guessed type __int16 word_96B2C;
// 96B6C: using guessed type __int16 word_96B6C;
// A2F79: using guessed type int dword_A2F79;
// A3D21: using guessed type __int16 word_A3D21[];
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEDC: using guessed type __int16 word_FFEDC;
// FFEEC: using guessed type __int16 word_FFEEC;
// FFEEE: using guessed type __int16 word_FFEEE;
// FFEF0: using guessed type __int16 word_FFEF0;
// FFEF8: using guessed type __int16 word_FFEF8;
// 103F9A: using guessed type int dword_103F9A[];
// 103FA2: using guessed type __int16 word_103FA2[];
// 104688: using guessed type int dword_104688[4];
// 10469C: using guessed type int dword_10469C[10];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 50530: using guessed type char s[100];

//----- (00050D70) --------------------------------------------------------
LONG __fastcall sub_50D70(_DWORD *a1, int a2, int a3, int a4)
{
  void *v5; // eax
  int v6; // esi
  char *v7; // eax
  void *v8; // eax
  LONG *v9; // ecx
  char *v10; // eax
  void *v11; // eax
  int v12; // edx
  float *v13; // esi
  float *v14; // eax
  int v15; // ebx
  double v16; // st7
  char v17; // ah
  char *v18; // edi
  unsigned int v19; // esi
  float *v20; // eax
  int v21; // eax
  char *v22; // eax
  int v23; // esi
  char *sub_1CEA8; // eax
  void *v25; // eax
  int v26; // esi
  char *v27; // eax
  void *v28; // eax
  char v29; // bh
  int v30; // edx
  char *v31; // eax
  char *v32; // esi
  char *v33; // edi
  char v34; // al
  char v35; // al
  int v36; // edi
  int v37; // esi
  int v38; // eax
  int v39; // ecx
  int v40; // eax
  int v41; // edi
  int v42; // esi
  int v43; // edi
  void *v44; // eax
  LONG v45; // edi
  int v46; // eax
  int v47; // ebx
  __int16 v48; // si
  void *v49; // eax
  LONG result; // eax
  int v51; // [esp-4h] [ebp-174h]
  __int16 v52; // [esp-4h] [ebp-174h]
  LONG v53; // [esp-4h] [ebp-174h]
  LONG v54; // [esp-4h] [ebp-174h]
  unsigned __int64 x; // [esp+0h] [ebp-170h]
  LONG xa; // [esp+0h] [ebp-170h]
  __int16 x_4; // [esp+4h] [ebp-16Ch]
  LONG x_4a; // [esp+4h] [ebp-16Ch]
  LONG x_4b; // [esp+4h] [ebp-16Ch]
  char s[200]; // [esp+8h] [ebp-168h] BYREF
  PANE pane; // [esp+D0h] [ebp-A0h] BYREF
  int v62[5]; // [esp+E4h] [ebp-8Ch]
  int v63[3]; // [esp+F8h] [ebp-78h] BYREF
  float v64; // [esp+104h] [ebp-6Ch]
  float v65; // [esp+108h] [ebp-68h]
  float v66; // [esp+10Ch] [ebp-64h]
  LONG v67[2]; // [esp+110h] [ebp-60h]
  int v68[2]; // [esp+118h] [ebp-58h]
  int v69[3]; // [esp+120h] [ebp-50h]
  int v70; // [esp+12Ch] [ebp-44h]
  float v71; // [esp+130h] [ebp-40h]
  float v72; // [esp+134h] [ebp-3Ch]
  int v73; // [esp+138h] [ebp-38h]
  int v74; // [esp+13Ch] [ebp-34h]
  LONG v75; // [esp+140h] [ebp-30h]
  int *v76; // [esp+144h] [ebp-2Ch]
  unsigned int v77; // [esp+148h] [ebp-28h]
  unsigned int v78; // [esp+14Ch] [ebp-24h]
  LONG shape_number; // [esp+150h] [ebp-20h]
  LONG hotY; // [esp+154h] [ebp-1Ch]
  __int64 v81; // [esp+158h] [ebp-18h]
  int v82; // [esp+160h] [ebp-10h]

  v74 = a2;
  v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B6E);
  VFX_shape_draw((PANE *)a1, v5, *(char *)(a2 + 0xAA), 0x41, 0x32);
  HIDWORD(v81) = 4 * (unsigned __int8)byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA] + 0x13;
  if ( a4 )
  {
    HIDWORD(v81) = 0xF3;
  }
  switch ( *(_BYTE *)(v74 + 0x58) )
  {
    case 1:
      v23 = *(_DWORD *)(v74 + 0x59);
      sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x93);// 147: "Under Construction at %s"
      sprintf(s, sub_1CEA8, v23 + 0x24);
      v25 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B72);
      VFX_shape_draw(
        (PANE *)a1,
        v25,
        *(unsigned __int16 *)(v23 + 0x14) + 5 * *(unsigned __int16 *)(v23 + 0x16),
        0x24E,
        0x31);
      break;
    case 2:
      v26 = *(_DWORD *)(v74 + 0x59);
      v27 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x94);  // 148: "Being Refitted at %s"
      sprintf(s, v27, v26 + 0x24);
      v28 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B72);
      VFX_shape_draw(
        (PANE *)a1,
        v28,
        5 * *(unsigned __int16 *)(v26 + 0x16) + *(unsigned __int16 *)(v26 + 0x14),
        0x24E,
        0x31);
      break;
    case 3:
      v6 = *(_DWORD *)(v74 + 0x59);
      v7 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x8F);   // 143: "Orbiting %s"
      sprintf(s, v7, v6 + 0x24);
      v8 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B72);
      VFX_shape_draw(
        (PANE *)a1,
        v8,
        *(unsigned __int16 *)(v6 + 0x14) + 5 * *(unsigned __int16 *)(v6 + 0x16),
        0x24E,
        0x31);
      break;
    case 4:
      v9 = *(LONG **)(v74 + 0x59);
      v10 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x90);  // 144: "in %s System"
      sprintf(s, v10, v9 + 7);
      v11 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_96B70);
      VFX_shape_draw((PANE *)a1, v11, *v9, 0x24E, 0x31);
      break;
    case 5:
      v12 = *(_DWORD *)(v74 + 0x59);
      v13 = *(float **)(v12 + 4);
      v14 = *(float **)v12;
      v69[2] = (int)v63;
      v64 = 0.0;
      v65 = 0.0;
      v66 = 0.0;
      v64 = v14[2] - v13[2];
      v65 = v14[3] - v13[3];
      v66 = v14[4] - v13[4];
      *(float *)v63 = v64;
      *(float *)&v63[1] = v65;
      *(float *)&v63[2] = v66;
      v15 = v74;
      v16 = sqrt(v65 * v65 + v64 * v64 + v66 * v66);
      v70 = *(_DWORD *)(v15 + 0xC) + *(_DWORD *)(v74 + 8);
      v71 = v16;
      v17 = *(_BYTE *)(v12 + 0x23);
      v72 = (float)v70;
      if ( (v17 & 1) != 0 )
      {
        v72 = v72 * flt_92C3A;
      }
      if ( byte_A310F[0x1EE * *(__int16 *)(v74 + 0x56)] == 0x12 )
      {
        if ( v72 < 1.0 )
        {
          v72 = 1.0;
        }
        v72 = v72 * flt_92C3E;
      }
      v70 = (int)((v71 - *(float *)(v74 + 0x9E)) / v72);
      v18 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x91);  // 145: "Unknown"
      if ( (*(_DWORD *)(v74 + 0xA2) & 0x7FFFFFFF) != 0 )
      {
        v20 = *(float **)(v12 + 4);
      }
      else
      {
        v20 = *(float **)v12;
      }
      if ( ((1 << byte_104BEA) & *((unsigned __int8 *)v20 + 0x17)) != 0 )
      {
        v18 = (char *)(v20 + 7);
      }
      if ( v70 )
      {
        v21 = 0x1D;                                    // 29: "s"
      }
      else
      {
        v21 = 0x1C;                                    // 28: ""
      }
      v19 = v70 + 1;
      x = __PAIR64__((unsigned int)Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v21), v19);
      v22 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x92);  // 146: "In Starlane to %s System\nETA - %d Day%s"
      sprintf(s, v22, v18, x);
      break;
    default:
      sprintf(s, "Bad m_LocationType");
      break;
  }
  v29 = *(_BYTE *)(v74 + 0x5D);
  if ( v29 && v29 != 7 && *(_BYTE *)(v74 + 0x58) == 4 )
  {
    v30 = v74;
    v31 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x95);    // 149: "\nMoving to Planet"
    if ( *(_BYTE *)(v30 + 0x5D) == 1 )
    {
      v31 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x96);  // 150: "\nMoving to Starlane"
    }
    v32 = v31;
    v33 = &s[strlen(s)];
    do
    {
      v34 = *v32;
      *v33 = *v32;
      if ( !v34 )
      {
        break;
      }
      v35 = v32[1];
      v32 += 2;
      v33[1] = v35;
      v33 += 2;
    }
    while ( v35 );
  }
  v51 = *(int *)((char *)&v81 + 2) >> 0x10;
  v70 = *(int *)((char *)&v81 + 2) >> 0x10;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x302E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3032] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3036] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x303E] = a1[4];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0x17C, 5, s, 0, v51, 0xFF, 0x8E);
  sprintf(s, "%s", (const char *)(v74 + 0x34));
  v52 = v70;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  v36 = 0x103;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x96, 5, s, 0, v52, 0xFF, 0);
  v37 = 0;
  v73 = sub_4A8CC(v74);
  do
  {
    if ( v37 >= v73 )
    {
      break;
    }
    x_4 = *(_WORD *)(v74 + 0x56);
    v39 = v36;
    ++v37;
    v40 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE6);
    v36 += 9;
    sub_53EB8((P_Type5)a1, v40, 6, v39, 6, x_4);
  }
  while ( v37 < 9 );
  v62[0] = *(_DWORD *)v74;
  v62[1] = *(_DWORD *)(v74 + 4);
  v62[2] = *(_DWORD *)(v74 + 0x10);
  v62[3] = *(_DWORD *)(v74 + 0x20);
  v38 = *(_DWORD *)(v74 + 0x18);
  hotY = 0x19;
  v62[4] = v38;
  v77 = 0;
  pane = *(PANE *)a1;
  LOWORD(v38) = word_FFEE6;
  v82 = v38;
  v75 = 7;
  do
  {
    pane.x1 = pane.x0 + 0x95;
    v41 = v62[v77 / 4];
    v42 = 0x96;
    if ( v41 > 0 )
    {
      pane.x1 += (0xE * v41 - (__CFSHL__((0xE * v41) >> 0x1F, 2) + 4 * ((0xE * v41) >> 0x1F))) >> 2;
    }
    v43 = 0;
    shape_number = v75;
    do
    {
      x_4a = hotY;
      xa = v42;
      v53 = shape_number;
      v44 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v82);
      ++v43;
      v42 += 0xE;
      VFX_shape_draw(&pane, v44, v53, xa, x_4a);
    }
    while ( v43 < 0xE );
    hotY += 0xE;
    v77 += 4;
    ++v75;
  }
  while ( v77 != 0x14 );
  v69[0] = *(_DWORD *)(v74 + 0x8C);
  v45 = 0x15E;
  v69[1] = *(_DWORD *)(v74 + 0x88);
  v46 = *(_DWORD *)(v74 + 0x98);
  v78 = 0;
  v68[0] = v46;
  v76 = (int *)0x16B;
  v68[1] = sub_4A8FC(v74);
  v67[1] = 0xB;
  v67[0] = 8;
  do
  {
    result = v78;
    if ( v68[v78 / 4] > 0 )
    {
      if ( v69[v78 / 4] >= 0 )
      {
        v47 = v68[v78 / 4];
        if ( v69[v78 / 4] > v47 )
        {
          v69[v78 / 4] = v47;
        }
      }
      else
      {
        v69[v78 / 4] = 0;
      }
      v48 = 0;
      LODWORD(v81) = v78;
      while ( v48 < 7 )
      {
        x_4b = 0xE * v48 + 5;
        v54 = *(LONG *)((char *)v67 + v81);
        v49 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)v82);
        ++v48;
        VFX_shape_draw((PANE *)a1, v49, v54, v45, x_4b);
      }
      result = sub_2BB74(
                 (int **)a1,
                 (int *)v45,
                 (int *)4,
                 v76,
                 (int *)(0x66 - 0x62 * *(int *)((char *)v69 + v81) / *(int *)((char *)v68 + v81)),
                 0,
                 0xFFFFFFFF);
    }
    v45 += 0xE;
    v76 = (int *)((char *)v76 + 0xE);
    v78 += 4;
  }
  while ( v78 != 8 );
  return result;
}
// 92C3A: using guessed type float flt_92C3A;
// 92C3E: using guessed type float flt_92C3E;
// 96B6E: using guessed type __int16 word_96B6E;
// 96B70: using guessed type __int16 word_96B70;
// 96B72: using guessed type __int16 word_96B72;
// FFEE6: using guessed type __int16 word_FFEE6;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 50D70: using guessed type char s[200];

//----- (00051610) --------------------------------------------------------
void __fastcall sub_51610(T_Type5 *a1, LONG a2, int a3, int a4)
{
  void *v5; // eax
  void *v6; // eax

  if ( a4 == 0xFFFFFFFF )
  {
    VFX_pane_wipe((PANE *)a1, 0x96);
  }
  v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
  VFX_shape_draw((PANE *)a1, v5, a2, 0x38, 0x37);
  v6 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE2);
  VFX_shape_draw((PANE *)a1, v6, 7, 0x38, 0x37);
}
// FFEE2: using guessed type __int16 word_FFEE2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00051674) --------------------------------------------------------
T_TypeA2 *__fastcall sub_51674(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_96128;
  sub_516D4((int)a1);
  return a1;
}
// 96128: using guessed type int (*off_96128[5])();

//----- (00051690) --------------------------------------------------------
void *__fastcall sub_51690(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_960E4);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_96128;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 96128: using guessed type int (*off_96128[5])();

//----- (000516D4) --------------------------------------------------------
int __fastcall sub_516D4(int result)
{
  *(_DWORD *)(result + 0xAB) = 0;
  return result;
}

//----- (000516E0) --------------------------------------------------------
void __fastcall sub_516E0(_DWORD *a1)
{
  __int16 *v1; // eax
  int v2; // ebx
  int i; // edx
  int v4; // eax
  int v5; // eax
  char *v6; // eax
  unsigned __int8 v7; // al
  _DWORD *v8; // esi
  char *v9; // [esp-14h] [ebp-6Ch]
  int v10; // [esp-10h] [ebp-68h]
  char *v11; // [esp-Ch] [ebp-64h]
  char *sub_1CEA8; // [esp-4h] [ebp-5Ch]
  char s[80]; // [esp+0h] [ebp-58h] BYREF
  P_Type5 p_rect; // [esp+50h] [ebp-8h]
  _DWORD *v15; // [esp+54h] [ebp-4h]

  v15 = a1;
  v1 = word_A3D21;
  v2 = 0;
  for ( i = 0; (__int16)i < word_A62A1; v1 += 0x30 )
  {
    if ( *((unsigned __int8 *)v1 + 0x14) == 1 << byte_104BEA
      && v1 != *(__int16 **)((char *)&dword_A2F79 + 0x1EE * (unsigned __int8)byte_104BEA) )
    {
      ++v2;
    }
    ++i;
  }
  if ( ((1 << byte_104BEA) & *(unsigned __int8 *)(*(int *)((char *)&dword_A2F79 + 0x1EE * (unsigned __int8)byte_104BEA)
                                                + 0x14)) != 0 )
  {
    ++v2;
  }
  if ( v2 == 1 )
  {
    v4 = 0x1C;
  }
  else
  {
    v4 = 0x1D;
  }
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v4);
  if ( *(_WORD *)(*(_DWORD *)((char *)v15 + 0xAB) + 0x8C7) == 1 )
  {
    v5 = 0x1C;
  }
  else
  {
    v5 = 0x1D;
  }
  v11 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v5);
  v10 = *(unsigned __int16 *)(*(_DWORD *)((char *)v15 + 0xAB) + 0x8C7);
  v9 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
  v6 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x97);
  sprintf(s, v6, v9, v10, v11, v2, sub_1CEA8);
  v7 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  p_rect = (P_Type5)&CONTAINING_RECORD(v15, T_Type5, a)->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v15[1];
  v8 = v15 + 2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v15[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *++v8;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *++v8;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v8[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x19, 9, s, 2, 4 * v7 + 0x13, 0xFF, 0);
  sub_53E38(p_rect, 3, 3, (unsigned __int8)byte_104BEA);
  sub_2D218(v15);
}
// A2F79: using guessed type int dword_A2F79;
// A3D21: using guessed type __int16 word_A3D21[];
// A62A1: using guessed type __int16 word_A62A1;

//----- (00051894) --------------------------------------------------------
unsigned int __fastcall sub_51894(int a1, __int16 a2, __int16 a3, int a4)
{
  int v6; // eax
  __int16 i; // di
  char *v8; // esi
  unsigned __int16 v9; // ax
  int v10; // eax

  if ( (unsigned __int16)a2 < 2u )
  {
    if ( a2 != 1 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    if ( !*(_DWORD *)(a1 + 0xAB) )
    {
      v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "STATPLANLST", 0);
      *(_DWORD *)(a1 + 0xAB) = v6;
      if ( !v6 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x1CB);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x8D;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_50530);
      sub_2F1D8(*(_DWORD *)(a1 + 0xAB), (int)sub_10A14);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC5) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xBB) = 0xFFFFFFFF;
    }
    if ( (unsigned __int16)word_96B2C == 0xFFFF )
    {
      word_96B2C = sub_1B270((int)dword_12FC20, "DATA\\planets.shp", 0);
      if ( (unsigned __int16)word_96B2C == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x1D9);
      }
    }
    if ( (unsigned __int16)word_96B2A == 0xFFFF )
    {
      word_96B2A = sub_1B270((int)dword_12FC20, "DATA\\suns.shp", 0);
      if ( (unsigned __int16)word_96B2A == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x1E0);
      }
    }
    sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
    for ( i = 0; i < SHIWORD(dword_CA1ED); ++i )
    {
      v8 = (char *)&unk_BB1B3 + 0x7B * i;
      if ( v8[0x57] == (_BYTE)byte_104BEA )
      {
        v9 = sub_2EA8C(*(_DWORD *)(a1 + 0xAB), v8, 0x96, 0);
        sub_2EC50(*(_DWORD *)(a1 + 0xAB), v9, *(_DWORD *)(v8 + 0x67));
      }
    }
    sub_2F1E0(*(_DWORD *)(a1 + 0xAB));
    sub_2ECDC(*(_DWORD *)(a1 + 0xAB), *(_WORD *)(a1 + 0xAF));
    return sub_2F424(a1, a2, a3, a4);
  }
  else if ( (unsigned __int16)a2 <= 2u )
  {
    *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
    return sub_2F424(a1, a2, a3, a4);
  }
  else
  {
    if ( a2 != 0x1C01 )
    {
      return sub_2F424(a1, a2, a3, a4);
    }
    v10 = sub_2ED14(*(_DWORD *)(a1 + 0xAB), a3);
    if ( new_x <= 0x96 )
    {
      dword_D3660 = (int)&word_A3D21[0x30 * *(__int16 *)(v10 + 0xC)];
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 1);
    }
    else
    {
      dword_D3664 = v10;
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
    }
    *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
    return 0;
  }
}
// 96B2A: using guessed type __int16 word_96B2A;
// 96B2C: using guessed type __int16 word_96B2C;
// A3D21: using guessed type __int16 word_A3D21[];
// CA1ED: using guessed type int dword_CA1ED;
// D3660: using guessed type int dword_D3660;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00051B64) --------------------------------------------------------
T_TypeA2 *__fastcall sub_51B64(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_96110;
  sub_516D4((int)a1);
  return a1;
}
// 96110: using guessed type int (*off_96110[5])();

//----- (00051B80) --------------------------------------------------------
void *__fastcall sub_51B80(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_960D0);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_96110;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 96110: using guessed type int (*off_96110[5])();

//----- (00051BC4) --------------------------------------------------------
void __fastcall sub_51BC4(_DWORD *a1)
{
  signed int v1; // eax
  int v2; // edx
  const char *v3; // eax
  char *sub_1CEA8; // eax
  unsigned __int8 v5; // al
  _DWORD *v6; // esi
  char *v7; // [esp-10h] [ebp-68h]
  int v8; // [esp-Ch] [ebp-64h]
  const char *v9; // [esp-8h] [ebp-60h]
  char s[80]; // [esp+0h] [ebp-58h] BYREF
  _DWORD *v11; // [esp+50h] [ebp-8h]
  P_Type5 p_rect; // [esp+54h] [ebp-4h]

  v11 = a1;
  v1 = sub_3EFE0((int)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
  v2 = v1;
  if ( v1 >= 0 )
  {
    if ( v1 > 0x64 )
    {
      v2 = 0x64;
    }
  }
  else
  {
    v2 = 0;
  }
  if ( *(_WORD *)(*(_DWORD *)((char *)v11 + 0xAB) + 0x8C7) == 1 )
  {
    v3 = (const char *)&unk_92C97;
  }
  else
  {
    v3 = "s";
  }
  v9 = v3;
  v8 = *(unsigned __int16 *)(*(_DWORD *)((char *)v11 + 0xAB) + 0x8C7);
  v7 = &byte_1050A4[0x14 * *((unsigned __int8 *)&byte_A2F73 + 0x1EE * (unsigned __int8)byte_104BEA)];
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x98);// Static text 152
  sprintf(s, sub_1CEA8, v7, v8, v9, v2);
  v5 = byte_A2F74[0x1EE * (unsigned __int8)byte_104BEA];
  p_rect = (P_Type5)&CONTAINING_RECORD(v11, T_Type5, a)->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = v11[1];
  v6 = v11 + 2;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = v11[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = *++v6;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = *++v6;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = v6[1];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x19, 9, s, 2, 4 * v5 + 0x13, 0xFF, 0);
  sub_53E38(p_rect, 3, 3, (unsigned __int8)byte_104BEA);
  sub_2D218(v11);
}

//----- (00051D24) --------------------------------------------------------
unsigned int __fastcall sub_51D24(int a1, __int16 a2, int a3, int a4)
{
  unsigned int result; // eax
  int v6; // eax
  signed int v7; // ebp
  int v8; // esi
  unsigned __int16 v9; // ax
  int v10; // ecx
  int v11; // ebx
  __int16 v12; // dx
  int v13; // eax
  int v14; // esi
  int v15; // eax
  int v16[107]; // [esp+0h] [ebp-1C8h] BYREF
  int v17; // [esp+1ACh] [ebp-1Ch]
  int v18; // [esp+1B0h] [ebp-18h]
  __int16 v19; // [esp+1B4h] [ebp-14h]
  __int16 i; // [esp+1B8h] [ebp-10h]

  v19 = a2;
  v18 = a3;
  v17 = a4;
  if ( (unsigned __int16)a2 < 2u )
  {
    if ( a2 != 1 )
    {
      return sub_2F424(a1, v19, v18, v17);
    }
    if ( !*(_DWORD *)(a1 + 0xAB) )
    {
      v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "STATSHIPLST", 0);
      *(_DWORD *)(a1 + 0xAB) = v6;
      if ( !v6 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x259);
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x6A;
      sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_50D70);
      sub_2F1D8(*(_DWORD *)(a1 + 0xAB), (int)sub_10A14);
      *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC5) = 0;
    }
    word_96B6E = word_FFEBC[(unsigned __int8)byte_104BEA];
    if ( (unsigned __int16)word_96B72 == 0xFFFF )
    {
      word_96B72 = sub_1B270((int)dword_12FC20, "DATA\\planets.shp", 0);
      if ( (unsigned __int16)word_96B72 == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x269);
      }
    }
    if ( (unsigned __int16)word_96B70 == 0xFFFF )
    {
      word_96B70 = sub_1B270((int)dword_12FC20, "DATA\\suns.shp", 0);
      if ( (unsigned __int16)word_96B70 == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x270);
      }
    }
    sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
    v7 = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], v16, 0);
    for ( i = 0; i < v7; ++i )
    {
      v8 = v16[i];
      v9 = sub_2EA8C(*(_DWORD *)(a1 + 0xAB), (const char *)v8, 0x64, 0);
      sub_2EC50(*(_DWORD *)(a1 + 0xAB), v9, *(_DWORD *)(v8 + 0x52));
    }
    v10 = v17;
    sub_2F1E0(*(_DWORD *)(a1 + 0xAB));
    v11 = v18;
    sub_2ECDC(*(_DWORD *)(a1 + 0xAB), *(_WORD *)(a1 + 0xAF));
    return sub_2F424(a1, v19, v11, v10);
  }
  else if ( (unsigned __int16)a2 <= 2u )
  {
    v12 = v19;
    *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
    return sub_2F424(a1, v12, a3, a4);
  }
  else
  {
    if ( a2 != 0x1C01 )
    {
      return sub_2F424(a1, v19, v18, v17);
    }
    v13 = sub_2ED14(*(_DWORD *)(a1 + 0xAB), v18);
    v14 = v13;
    if ( a4 == 5 )
    {
      v15 = sub_56DA8((int)&V_Type3_stru_10AE70, "SHIPDESSCREEN", 0);
      sub_4DA7C(v15, v14, 0, 0xFFFFFFFF);
      sub_56B60((int)&V_Type3_stru_10AE70, 1, 8, 1);
      *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
      return 0xFFFFFFFF;
    }
    else
    {
      switch ( *(_BYTE *)(v13 + 0x58) )
      {
        case 1:
        case 2:
        case 3:
          dword_D3664 = *(_DWORD *)(v13 + 0x59);
          sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x11, 1);
          *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
          result = 0xFFFFFFFF;
          break;
        case 4:
          dword_D3660 = *(_DWORD *)(v13 + 0x59);
          sub_56B60((int)&V_Type3_stru_10AE70, 1, 0x10, 1);
          *(_WORD *)(a1 + 0xAF) = *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8CD);
          result = 0xFFFFFFFF;
          break;
        case 5:
          sub_56B60((int)&V_Type3_stru_10AE70, 3, 0, 0);
          result = 0xFFFFFFFF;
          break;
        default:
          result = 0;
          break;
      }
    }
  }
  return result;
}
// 96B6E: using guessed type __int16 word_96B6E;
// 96B70: using guessed type __int16 word_96B70;
// 96B72: using guessed type __int16 word_96B72;
// D3660: using guessed type int dword_D3660;
// FFEBC: using guessed type __int16 word_FFEBC[7];
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 51D24: using guessed type int var_1C8[107];

//----- (000520EC) --------------------------------------------------------
T_TypeA2 *__fastcall sub_520EC(T_TypeA2 *a1)
{
  sub_2C830(a1);
  a1->b = (int)off_960F8;
  sub_5214C((int)a1);
  return a1;
}
// 960F8: using guessed type int (*off_960F8[5])();

//----- (00052108) --------------------------------------------------------
void *__fastcall sub_52108(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_960BC);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_960F8;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 960F8: using guessed type int (*off_960F8[5])();

//----- (0005214C) --------------------------------------------------------
int __fastcall sub_5214C(int result)
{
  *(_DWORD *)(result + 0xAF) = 0;
  *(_DWORD *)(result + 0xAB) = 0;
  *(_WORD *)(result + 0xB3) = 0;
  *(_WORD *)(result + 0xB5) = 0;
  return result;
}

//----- (00052174) --------------------------------------------------------
int __fastcall sub_52174(int a1)
{
  char *v1; // ecx
  int v2; // esi
  FILE *v3; // edi

  *(_DWORD *)(a1 + 0xAF) = &unk_109DF8;
  v1 = *(char **)(a1 + 0xAF);
  v2 = 0;
  v3 = sub_1BB10("newgame.txt", 0);
  do
  {
    fgets(v1, 0xC7, v3);
    ++v2;
    v1 += 0xC8;
  }
  while ( v2 < 0x15 );
  return fclose(v3);
}

//----- (000521C0) --------------------------------------------------------
void __fastcall sub_521C0(int a1, int edx0)
{
  char *sub_1CEA8; // eax
  int v4; // edi
  void *v5; // ecx
  void *v6; // ecx
  unsigned __int16 v7; // ax
  void *v8; // eax
  int v9; // ebx
  char *v10; // eax
  int v11; // eax
  int v12; // edx
  int i; // ebx
  char *v14; // eax
  int v15; // ebx
  int j; // edx
  char *v17; // eax
  int v18; // ebx
  int k; // edx
  char *v20; // eax
  char *v21; // eax
  __int16 m; // si
  int v23; // ebx
  void *v24; // eax
  LONG v25; // [esp-Ch] [ebp-15Ch]
  int v26; // [esp-Ch] [ebp-15Ch]
  int v27; // [esp-8h] [ebp-158h]
  int v28; // [esp-4h] [ebp-154h]
  int v29; // [esp-4h] [ebp-154h]
  char s[280]; // [esp+0h] [ebp-150h] BYREF
  T_Type5 v31; // [esp+118h] [ebp-38h] BYREF
  int a2[3]; // [esp+12Ch] [ebp-24h]
  int v33; // [esp+138h] [ebp-18h]

  v33 = edx0;
  sub_52714(a1);
  v31.a = *(P_Type6 *)(a1 + 4);
  v31.rect.x1 = 0x1F6;
  v31.rect.y1 = 7;
  v31.rect.x2 = 0x278;
  v31.rect.y2 = 0x24;
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x99);// 153: "Player Species"
  sprintf(s, sub_1CEA8);
  *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v31;
  v4 = v33;
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, s, 3, 0xF3, 0xFF, 0x6E);
  if ( !v4 )
  {
    v31 = *(T_Type5 *)(a1 + 4);
    VFX_pane_wipe((PANE *)(a1 + 4), 0);
    v31.rect.y2 = 0x23;
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v31;
    sub_2B8A8(
      (int)&V_Type3_stru_10AE70.z1[0x3046],
      0,
      0,
      &byte_1050A4[0x14 * *(__int16 *)(a1 + 0xB3)],
      3,
      (unsigned __int8)byte_96779[*(__int16 *)(a1 + 0xB5)],
      0xFF,
      0);
    v5 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
    if ( !v5 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x325);
    }
    VFX_shape_draw((PANE *)(a1 + 4), v5, *(__int16 *)(a1 + 0xB3), 0x4B, 0x55);
    v6 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE2);
    if ( !v6 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x329);
    }
    VFX_shape_draw((PANE *)(a1 + 4), v6, *(__int16 *)(a1 + 0xB5), 0x4B, 0x55);
    v7 = sub_1B270((int)dword_12FC20, "DATA\\smhome.shp", 0xFFFFFFFF);
    if ( v7 == 0xFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x334);
    }
    v25 = *(__int16 *)(a1 + 0xB3);
    v8 = (void *)sub_1B084((unsigned int)dword_12FC20, v7);
    VFX_shape_draw((PANE *)(a1 + 4), v8, v25, 0x48, 0xCD);
    sub_53E38((P_Type5)(a1 + 4), 0x6B, 0xC1, (unsigned __int8)byte_104BEA);
    if ( !*(_DWORD *)(a1 + 0xAF) )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x340);
    }
    if ( *(__int16 *)(a1 + 0xB3) >= 0x15 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x341);
    }
    v9 = *(__int16 *)(a1 + 0xB3);
    v28 = *(_DWORD *)(a1 + 0xAF) + 0xC8 * v9;
    v10 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x9A);    // 154: "The %s %s"
    sprintf(s, v10, &byte_1050A4[0x14 * v9], v28);
    v31.rect.y1 = 0x109;
    v31.rect.y2 = *(_DWORD *)(a1 + 0x14);
    v11 = *(__int16 *)(a1 + 0xB5);
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x302E] = v31;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3026], 0, 0, s, 0, (unsigned __int8)byte_96779[v11], 0xFF, 0x96);
    v12 = 0x9B;                                        // 155: "Vacuous"
    for ( i = 0; i != 0x14; *(_DWORD *)&s[i + 0xEC] = v14 )
    {
      i += 4;
      v14 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v12++);
    }
    v15 = 0xA0;                                        // 160: "Peaceful"
    for ( j = 0; j != 0xC; *(int *)((char *)&v31.rect.y2 + j) = (int)v17 )
    {
      j += 4;
      v17 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v15++);
    }
    v18 = 0xA3;                                        // 163: "Three"
    for ( k = 0; k != 0x14; *(_DWORD *)&s[k + 0x100] = v20 )
    {
      k += 4;
      v20 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(v18++);
    }
    v31.rect.x1 = 0x11;
    v31.rect.y1 = 0x145;
    v31.rect.x2 = 0x144;
    v31.rect.y2 = 0x172;
    v29 = a2[*(__int16 *)(a1 + 0xBB)];
    v27 = *(_DWORD *)&s[4 * *(__int16 *)(a1 + 0xB9) + 0xF8];
    v26 = *(_DWORD *)&s[4 * *(__int16 *)(a1 + 0xB7) + 0xF0];
    v21 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xA8);    // 168: "%s Star Cluster\n%s Species\n%s Atmosphere"
    sprintf(s, v21, v26, v27, v29);
    *(T_Type5 *)&V_Type3_stru_10AE70.z1[0x304E] = v31;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, s, 0x82, 0xFFFFFFFF, 0, 0xFA);
    sub_552CC(&V_Type3_stru_10AE70, (P_Type5)(a1 + 4));
    v31.a = (P_Type6)V_Type6_stru_D8654.pane.window;
    v31.rect.x2 = 0x18B;
    v31.rect.y2 = 0x1CF;
    v31.rect.x1 = 0x17D;
    v31.rect.y1 = 0x1B1;
    for ( m = 0; m < 7; ++m )
    {
      v23 = *(int *)(a1 + 0xB1) >> 0x10;
      v24 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE0);
      sub_53F40(&v31, v24, v23, 0, 0, m);
      if ( m == *(_WORD *)(a1 + 0xB5) )
      {
        sub_2BB74((int **)&v31, 0, 0, (int *)0xE, (int *)0x18, 0xF3u, 0);
      }
      v31.rect.x1 += 0x10;
      v31.rect.x2 += 0x10;
    }
    sub_55274(&V_Type3_stru_10AE70, 0x17B, 0x1A4, 0x1ED, 0x1D8);
  }
}
// FFEE0: using guessed type __int16 word_FFEE0;
// FFEE2: using guessed type __int16 word_FFEE2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 521C0: using guessed type int a2[3];

//----- (000526D8) --------------------------------------------------------
unsigned int sub_526D8()
{
  if ( new_x <= 0x1F6 || new_x >= 0x278 || dword_D864C <= 0x17D || dword_D864C >= 0x1D8 )
  {
    return 0;
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (00052714) --------------------------------------------------------
int __fastcall sub_52714(int a1)
{
  LONG v1; // edx
  int v2; // eax
  int v3; // edi
  int *v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  char v8; // ah
  _DWORD *v9; // ebp
  void *v10; // eax
  int v11; // eax
  char *sub_1CEA8; // eax
  LONG v14; // [esp-20h] [ebp-60h]
  PANE pane; // [esp+0h] [ebp-40h] BYREF
  int v16; // [esp+14h] [ebp-2Ch]
  int v17; // [esp+18h] [ebp-28h]
  int v18; // [esp+1Ch] [ebp-24h]
  int v19; // [esp+20h] [ebp-20h]
  int i; // [esp+24h] [ebp-1Ch]

  v16 = a1;
  pane.window = V_Type6_stru_D8654.pane.window;
  pane.x0 = 0x1F6;
  pane.y0 = 0x17D;
  pane.x1 = 0x278;
  v1 = 0xF2;
  pane.y1 = 0x1D8;
  if ( sub_526D8() == 0xFFFFFFFF )
  {
    v1 = 0x96;
  }
  VFX_pane_wipe(&pane, v1);
  sub_55274(&V_Type3_stru_10AE70, 0x1F6, 0x17D, 0x278, 0x1D8);
  v18 = sub_56E18((int)&V_Type3_stru_10AE70, "COSMOSWnd", 3, 0);
  if ( !v18 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x3BB);
  }
  HIWORD(v2) = HIWORD(v18);
  v3 = 0;
  LOWORD(v2) = *(_WORD *)(v18 + 0x572);
  v4 = (int *)(v18 + 0x172);
  for ( i = v2; (__int16)v3 < (__int16)i; ++v4 )
  {
    v7 = *v4;
    v8 = *(_BYTE *)(*v4 + 4);
    v19 = (int)(*(float *)(*v4 + 0xD) + flt_92D77);
    if ( !v8 )
    {
      v5 = 3;
      v9 = *(_DWORD **)v7;
      if ( v19 <= 0xDC )
      {
        if ( v19 <= 0 )
        {
          if ( v19 > (int)0xFFFFFF24 )
          {
            v5 = 2;
          }
        }
        else
        {
          v5 = 1;
        }
      }
      else
      {
        v5 = 0;
      }
      v6 = *(__int16 *)(v7 + 7);
      v17 = 5;
      VFX_shape_draw(&pane, *(void **)(v18 + 0xAB), 4 * *v9 + v5, *(__int16 *)(v7 + 5) / 5 + 5, v6 / 5 + 5);
    }
    ++v3;
  }
  v14 = *(__int16 *)(v16 + 0xB3);
  v10 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF4);
  VFX_shape_transform(&pane, v10, v14, 0x62, 0x24, buffer, 0, 0x8000, 0x8000, 0);
  v11 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEF2);
  sub_53EB8((P_Type5)&pane, v11, 3, 0x62, 0x24, 0);
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xA9);
  *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = pane;
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0x41, 0x50, sub_1CEA8, 0xC, 0xFFFFFFFF, 0xFF, 0);
}
// 92D77: using guessed type float flt_92D77;
// D8DA0: using guessed type UBYTE buffer[94816];
// FFEF2: using guessed type __int16 word_FFEF2;
// FFEF4: using guessed type __int16 word_FFEF4;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0005294C) --------------------------------------------------------
unsigned int __fastcall sub_5294C(int a1, __int16 dx0, int a3, int a4)
{
  int v6; // eax
  int v7; // edx
  int v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // edx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  __int16 i; // si
  int v15; // eax
  int v16; // eax
  int v17; // eax
  __int16 v18; // bx
  __int16 v19; // edx^2
  int v20; // ecx
  int v21; // ebx
  __int16 v22; // dx
  int v23; // ecx
  int v24; // ebx
  int v25; // ebx
  _WORD v26[3]; // [esp+0h] [ebp-42h]
  int v27; // [esp+6h] [ebp-3Ch]
  int v28; // [esp+Ah] [ebp-38h]
  int v29; // [esp+Eh] [ebp-34h]
  int v30; // [esp+12h] [ebp-30h]
  T_Type5 a2; // [esp+16h] [ebp-2Ch] BYREF
  int v32; // [esp+2Ah] [ebp-18h]
  int v33; // [esp+2Eh] [ebp-14h]
  __int16 v34; // [esp+32h] [ebp-10h]

  v34 = dx0;
  v33 = a3;
  v32 = a4;
  *(_DWORD *)&v26[1] = dword_96B74[0];
  v27 = dword_96B74[1];
  v28 = dword_96B74[2];
  v29 = dword_96B74[3];
  v30 = dword_96B74[4];
  if ( (unsigned __int16)dx0 < 0x1F5u )
  {
    if ( (unsigned __int16)dx0 < 2u )
    {
      if ( dx0 == 1 )
      {
        sub_54048("resume.gam", 1, a3, a4);
        dword_96BC0 = 0xFFFFFFFF;
        v12 = *(_DWORD *)(a1 + 0xAB);
        dword_12FC10 = 0;
        if ( !v12 )
        {
          v13 = sub_56DA8((int)&V_Type3_stru_10AE70, "RACELIST", 0);
          *(_DWORD *)(a1 + 0xAB) = v13;
          if ( !v13 )
          {
            Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x463);
          }
          *(_DWORD *)(*(_DWORD *)(a1 + 0xAB) + 0xAB) = 0;
          *(_WORD *)(*(_DWORD *)(a1 + 0xAB) + 0x8C9) = 0x6D;
          sub_2F1C8(*(_DWORD *)(a1 + 0xAB), (int)sub_51610);
          sub_2E9CC(*(_DWORD *)(a1 + 0xAB), 0);
          *(_BYTE *)(*(_DWORD *)(a1 + 0xAB) + 0xC6) = 0xF2;
        }
        sub_2ED4C(*(_DWORD *)(a1 + 0xAB));
        for ( i = 0; i < 0x15; ++i )
        {
          sub_2EA8C(*(_DWORD *)(a1 + 0xAB), (const char *)i, 0x73, 0);
        }
        v15 = *(_DWORD *)(a1 + 0x67);
        *(_WORD *)(a1 + 0xB7) = 2;
        *(_DWORD *)(*(_DWORD *)v15 + 0x72) = 2;
        v16 = *(_DWORD *)(a1 + 0x67);
        *(_WORD *)(a1 + 0xB9) = 5;
        *(_DWORD *)(*(_DWORD *)(v16 + 4) + 0x72) = 7;
        v17 = *(_DWORD *)(a1 + 0x67);
        *(_WORD *)(a1 + 0xBB) = 1;
        *(_DWORD *)(*(_DWORD *)(v17 + 8) + 0x72) = 0xB;
        v18 = *(_WORD *)(a1 + 0xB9);
        byte_A3D20 = 1;
        *(_WORD *)(a1 + 0xB3) = 0;
        sub_1E10C((int)dword_A2F6C, v26[2 * *(__int16 *)(a1 + 0xB7) + 1], v18, *(_WORD *)(a1 + 0xB3));
        *(_WORD *)(a1 + 0xB5) = 0;
        LOBYTE(byte_104BEA) = 0;
        LOBYTE(byte_A2F73) = 0;
        sub_1EE08((int)dword_A2F6C, *(_WORD *)(a1 + 0xB5));
        a2.a = *(P_Type6 *)(a1 + 4);
        a2.rect.y2 = 0x1D8;
        a2.rect.x1 = 0x17B;
        a2.rect.y1 = 0x1A4;
        a2.rect.x2 = 0x1ED;
        VFX_pane_wipe((PANE *)&a2, 0xF2);
        sub_552CC(&V_Type3_stru_10AE70, &a2);
        v19 = v34;
        v20 = v32;
        v21 = v33;
        sub_52174(a1);
        return sub_2F424(a1, v19, v21, v20);
      }
    }
    else
    {
      if ( (unsigned __int16)dx0 <= 2u )
      {
        return sub_2F424(a1, v34, a3, a4);
      }
      if ( (unsigned __int16)dx0 >= 4u )
      {
        if ( (unsigned __int16)dx0 <= 5u )
        {
          if ( a3 <= 0x17B || a3 >= 0x1ED || a4 <= 0x1A4 || a4 >= 0x1D8 )
          {
            if ( sub_526D8() == 0xFFFFFFFF )
            {
              sub_4FB90((int)&unk_10914C, 0);
              sub_1F404((int)dword_A2F6C);
              sub_1F038((int)dword_A2F6C);
              v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "BatModeWnd", 0);
              v7 = v6 + 0x190;
              do
              {
                v6 += 4;
                *(_DWORD *)(v6 + 0x137A) = 0;
              }
              while ( v6 != v7 );
              v8 = sub_56DA8((int)&V_Type3_stru_10AE70, "COSMOSWnd", 0);
              sub_2280C(v8, (int)"COSMOSWnd", 0, a4);
              v9 = (_DWORD *)(sub_56DA8((int)&V_Type3_stru_10AE70, "RESWIN", 0) + 0x11F);
              v9[1] = 0;
              v9[2] = 0;
              v10 = v9 + 3;
              *v9 = 0x3F800000;
              v9[3] = 0;
              v9[4] = 0x3F800000;
              v9 += 6;
              v10[2] = 0;
              *v9 = 0;
              v9[1] = 0;
              v9[2] = 0x3F800000;
              v11 = sub_56DA8((int)&V_Type3_stru_10AE70, "RACECONTROLS", 0);
              if ( !v11 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\status.cpp", 0x444);
              }
              sub_2DD70(v11);
              byte_A3D20 = *(_BYTE *)(a1 + 0xBB);
              sub_1EEA4((int)dword_A2F6C);
              dword_96BC0 = 0;
              sub_56B60((int)&V_Type3_stru_10AE70, 1, 0xC, 0);
              return 0xFFFFFFFF;
            }
            else
            {
              return 0;
            }
          }
          else
          {
            sub_4FB90((int)&unk_10914C, 0);
            *(_WORD *)(a1 + 0xB5) = (a3 - 0x17B - (__CFSHL__((a3 - 0x17B) >> 0x1F, 4) + 0x10 * ((a3 - 0x17B) >> 0x1F))) >> 4;
            sub_1EE08((int)dword_A2F6C, *(_WORD *)(a1 + 0xB5));
            (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(
              *(_DWORD *)&v26[1],
              v27,
              v28,
              v29,
              v30);
            return 0xFFFFFFFF;
          }
        }
        if ( dx0 == 0xC )
        {
          if ( a3 > 0x17B && a3 < 0x1ED && a4 > 0x1A4 && a4 < 0x1D8 )
          {
            sub_56B60((int)&V_Type3_stru_10AE70, 5, (int)"pcolor", 0);
            return 0xFFFFFFFF;
          }
          if ( sub_526D8() == 0xFFFFFFFF )
          {
            sub_56B60((int)&V_Type3_stru_10AE70, 5, (int)"beghelp", 0);
            return 0xFFFFFFFF;
          }
        }
      }
    }
    return sub_2F424(a1, v34, v33, v32);
  }
  if ( (unsigned __int16)dx0 <= 0x1F5u )
  {
    if ( ++*(_WORD *)(a1 + 0xB7) == 5 )
    {
      *(_WORD *)(a1 + 0xB7) = 0;
    }
    v23 = *(__int16 *)(a1 + 0xB3);
    v24 = *(__int16 *)(a1 + 0xB9);
    sub_1E10C((int)dword_A2F6C, v26[2 * *(__int16 *)(a1 + 0xB7) + 1], v24, v23);
    sub_24D30(*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC), dword_96BAC, v24, v23);
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    *(_DWORD *)(**(_DWORD **)(a1 + 0x67) + 0x72) = *(__int16 *)(a1 + 0xB7);
    (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(**(_DWORD **)(a1 + 0x67) + 0xA7) + 0xC))(
      *(_DWORD *)&v26[1],
      v27,
      v28,
      v29,
      v30);
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)dx0 < 0x1F9u )
  {
    if ( dx0 == 0x1F7 )
    {
      if ( ++*(_WORD *)(a1 + 0xB9) == 8 )
      {
        *(_WORD *)(a1 + 0xB9) = 3;
      }
      v25 = *(__int16 *)(a1 + 0xB3);
      sub_1E70C((int)dword_A2F6C, *(_WORD *)(a1 + 0xB9), v25);
      sub_24D30(*(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * dword_96BAC), dword_96BAC, v25, a4);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4) + 0x72) = *(__int16 *)(a1 + 0xB9) + 2;
      (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 4) + 0xA7) + 0xC))(
        *(_DWORD *)&v26[1],
        v27,
        v28,
        v29,
        v30);
      return 0xFFFFFFFF;
    }
    return sub_2F424(a1, v34, v33, v32);
  }
  if ( (unsigned __int16)dx0 <= 0x1F9u )
  {
    if ( ++*(_WORD *)(a1 + 0xBB) == 3 )
    {
      *(_WORD *)(a1 + 0xBB) = 0;
    }
    (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 8) + 0x72) = *(__int16 *)(a1 + 0xBB) + 0xA;
    (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 0x67) + 8) + 0xA7) + 0xC))(
      *(_DWORD *)&v26[1],
      v27,
      v28,
      v29,
      v30);
    return 0xFFFFFFFF;
  }
  else
  {
    if ( (unsigned __int16)dx0 <= 0x1FAu || dx0 != 0x1C01 )
    {
      return sub_2F424(a1, v34, v33, v32);
    }
    if ( *(__int16 *)(a1 + 0xB3) != a3 )
    {
      v22 = *(_WORD *)(a1 + 0xB9);
      *(_WORD *)(a1 + 0xB3) = v33;
      sub_1E70C((int)dword_A2F6C, v22, *(_WORD *)(a1 + 0xB3));
      (*(void (__cdecl **)(_DWORD, int, int, int, int))(*(_DWORD *)(a1 + 0xA7) + 0xC))(
        *(_DWORD *)&v26[1],
        v27,
        v28,
        v29,
        v30);
    }
    return 0xFFFFFFFF;
  }
}
// 96B74: using guessed type _DWORD dword_96B74[5];
// 96BAC: using guessed type int dword_96BAC;
// 96BC0: using guessed type int dword_96BC0;
// A2F6C: using guessed type int dword_A2F6C[];
// A3D20: using guessed type char byte_A3D20;
// 12FC10: using guessed type int dword_12FC10;

//----- (00053000) --------------------------------------------------------
void __fastcall sub_53000(float *a1)
{
  double v2; // st7
  float v3; // [esp+Ch] [ebp-8h]

  v3 = sqrt(a1[1] * a1[1] + *a1 * *a1 + a1[2] * a1[2]);
  if ( v3 > 0.0 )
  {
    v2 = 1.0 / v3;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = v2 * a1[2];
  }
}

//----- (00053054) --------------------------------------------------------
void __fastcall sub_53054(float *a1, float a2)
{
  sub_53000(a1);
  *a1 = *a1 * a2;
  a1[1] = a1[1] * a2;
  a1[2] = a2 * a1[2];
}

//----- (00053078) --------------------------------------------------------
unsigned int __fastcall sub_53078(_DWORD *a1)
{
  if ( (*a1 & 0x7FFFFFFF) != 0 || (a1[1] & 0x7FFFFFFF) != 0 || (a1[2] & 0x7FFFFFFF) != 0 )
  {
    return 0;
  }
  else
  {
    return 0xFFFFFFFF;
  }
}

//----- (0005309C) --------------------------------------------------------
double __fastcall sub_5309C(float *a1, float *a2)
{
  double x; // st7
  float v4; // [esp+8h] [ebp-4h]
  float v5; // [esp+8h] [ebp-4h]

  v4 = a1[1] * a2[1] + *a1 * *a2 + a1[2] * a2[2];
  v5 = v4 / sqrt(a1[1] * a1[1] + *a1 * *a1 + a1[2] * a1[2]);
  x = v5 / sqrt(a2[1] * a2[1] + *a2 * *a2 + a2[2] * a2[2]);
  return acos(x) * flt_96144;
}
// 96144: using guessed type float flt_96144;

//----- (00053114) --------------------------------------------------------
float *__fastcall sub_53114(float *result, float *a2)
{
  float v2; // [esp+0h] [ebp-1Ch]
  float v3; // [esp+4h] [ebp-18h]
  float v4; // [esp+8h] [ebp-14h]

  v2 = *result;
  v3 = result[1];
  v4 = result[2];
  *result = v3 * a2[1] + *result * *a2 + v4 * a2[2];
  result[1] = v3 * a2[4] + v2 * a2[3] + v4 * a2[5];
  result[2] = v3 * a2[7] + v2 * a2[6] + v4 * a2[8];
  return result;
}

//----- (0005323C) --------------------------------------------------------
int __fastcall sub_5323C(int result, float a2)
{
  int v5; // edx
  double v6; // st7
  double x; // [esp+0h] [ebp-20h]
  float v8; // [esp+Ch] [ebp-14h]

  v5 = result;
  if ( (LODWORD(a2) & 0x7FFFFFFF) != 0 )
  {
    x = a2 * flt_96140;
    v8 = cos(x);
    v6 = sin(x);
    result = *(int *)(v5 + 4);
    *(float *)(v5 + 4) = *(float *)&result * v8 - *(float *)(v5 + 8) * v6;
    *(float *)(v5 + 8) = v6 * *(float *)&result + *(float *)(v5 + 8) * v8;
  }
  return result;
}
// 96140: using guessed type float flt_96140;

//----- (000532AC) --------------------------------------------------------
float *__fastcall sub_532AC(float *result, float a2)
{
  float *v5; // edx
  double v6; // st7
  double x; // [esp+0h] [ebp-20h]
  float v8; // [esp+8h] [ebp-18h]
  float v9; // [esp+Ch] [ebp-14h]

  v5 = result;
  if ( (LODWORD(a2) & 0x7FFFFFFF) != 0 )
  {
    x = a2 * flt_96140;
    v9 = cos(x);
    v6 = sin(x);
    result = *(float **)v5;
    v8 = *v5;
    *v5 = v5[2] * v6 + *v5 * v9;
    v5[2] = v5[2] * v9 - v6 * v8;
  }
  return result;
}
// 96140: using guessed type float flt_96140;

//----- (00053318) --------------------------------------------------------
float *__fastcall sub_53318(float *result, float a2)
{
  float *v5; // edx
  double v6; // st7
  double x; // [esp+0h] [ebp-20h]
  float v8; // [esp+8h] [ebp-18h]
  float v9; // [esp+Ch] [ebp-14h]

  v5 = result;
  if ( (LODWORD(a2) & 0x7FFFFFFF) != 0 )
  {
    x = a2 * flt_96140;
    v9 = cos(x);
    v6 = sin(x);
    result = *(float **)v5;
    v8 = *v5;
    *v5 = *v5 * v9 - v5[1] * v6;
    v5[1] = v6 * v8 + v5[1] * v9;
  }
  return result;
}
// 96140: using guessed type float flt_96140;

//----- (00053384) --------------------------------------------------------
float *__fastcall sub_53384(float *result, float *a2, float *a3)
{
  *a3 = a2[1] * result[1] + *a2 * *result + a2[2] * result[2] + a2[3];
  a3[1] = a2[5] * result[1] + a2[4] * *result + a2[6] * result[2] + a2[7];
  a3[2] = a2[9] * result[1] + a2[8] * *result + a2[0xA] * result[2] + a2[0xB];
  return result;
}

//----- (000533D4) --------------------------------------------------------
int __fastcall sub_533D4(float *a1, float a2, int a3, int a4, int a5, int a6)
{
  double v9; // st5
  double v10; // st7
  int result; // eax

  v9 = 1.0 / a1[2];
  v10 = a2 * a1[1] * v9 + dbl_92DD4;
  *(_WORD *)a5 = (int)(*a1 * a2 * v9 + dbl_92DD4);
  *(_WORD *)a6 = (int)v10;
  *(_WORD *)a5 += a3;
  result = a4;
  *(_WORD *)a6 += a4;
  return result;
}
// 92DD4: using guessed type double dbl_92DD4;

//----- (00053440) --------------------------------------------------------
int __fastcall sub_53440(float *a1)
{
  int v1; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // ett
  int v6; // edx
  int v7; // eax
  int v8; // ett
  int v9; // edx
  int v10; // eax
  int result; // eax
  int v12; // ett

  v1 = dword_96B88;
  if ( *a1 < 0.0 )
  {
    v3 = -dword_96B88;
    v4 = -dword_96B88;
  }
  else
  {
    v3 = dword_96B88;
    v4 = dword_96B88;
  }
  v5 = (int)((double)((v4 - (v3 >> 0x1F)) >> 1) + *a1);
  *a1 = (float)(dword_96B88 * (v5 / dword_96B88));
  if ( a1[1] < 0.0 )
  {
    v6 = -v1;
    v7 = -v1;
  }
  else
  {
    v6 = v1;
    v7 = v1;
  }
  v8 = (int)((double)((v7 - (v6 >> 0x1F)) >> 1) + a1[1]);
  a1[1] = (float)(v1 * (v8 / v1));
  if ( a1[2] < 0.0 )
  {
    v9 = -v1;
    v10 = -v1;
  }
  else
  {
    v9 = v1;
    v10 = v1;
  }
  v12 = (int)((double)((v10 - (v9 >> 0x1F)) >> 1) + a1[2]);
  result = v12 / v1;
  a1[2] = (float)(v1 * (v12 / v1));
  dword_96B88 = v1;
  return result;
}
// 96B88: using guessed type int dword_96B88;

//----- (0005353C) --------------------------------------------------------
void __fastcall sub_5353C(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_5323C((int)(a1 + 6), *(float *)&a5);
    sub_53644(a1, (int)a1, a5, a4);
  }
}

//----- (00053564) --------------------------------------------------------
void __fastcall sub_53564(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_532AC(a1 + 6, *(float *)&a5);
    sub_53754(a1, (int)a1, a5, a4);
  }
}

//----- (0005358C) --------------------------------------------------------
void __fastcall sub_5358C(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_53318(a1 + 3, *(float *)&a5);
    sub_53864(a1, (int)a1, a5, a4);
  }
}

//----- (000535B4) --------------------------------------------------------
void __fastcall sub_535B4(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_5323C((int)(a1 + 6), *(float *)&a5);
    sub_5323C((int)(a1 + 3), *(float *)&a5);
    sub_53864(a1, (int)a1, a5, a4);
  }
}

//----- (000535E4) --------------------------------------------------------
void __fastcall sub_535E4(float *a1, int a2, int a3, int a4, int a5)
{
  if ( (a5 & 0x7FFFFFFF) != 0 )
  {
    sub_532AC(a1 + 6, *(float *)&a5);
    sub_532AC(a1 + 3, *(float *)&a5);
    sub_53864(a1, (int)a1, a5, a4);
  }
}

//----- (00053644) --------------------------------------------------------
void __fastcall sub_53644(float *a1, int a2, int a3, int a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6
  float v9; // [esp+0h] [ebp-48h]
  float v10; // [esp+4h] [ebp-44h]
  float v11; // [esp+8h] [ebp-40h]
  float v12; // [esp+Ch] [ebp-3Ch] BYREF
  float v13; // [esp+10h] [ebp-38h]
  float v14; // [esp+14h] [ebp-34h]
  float v15; // [esp+18h] [ebp-30h]
  float v16; // [esp+1Ch] [ebp-2Ch]
  float v17; // [esp+20h] [ebp-28h]
  float v18; // [esp+24h] [ebp-24h] BYREF
  float v19; // [esp+28h] [ebp-20h]
  float v20; // [esp+2Ch] [ebp-1Ch]
  float *v21; // [esp+30h] [ebp-18h]
  float *v22; // [esp+34h] [ebp-14h]
  int v23; // [esp+3Ch] [ebp-Ch]
  int v24; // [esp+40h] [ebp-8h]

  v24 = a4;
  v23 = a2;
  sub_53000(a1);
  v21 = &v12;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v15 = a1[7] * a1[2] - a1[8] * a1[1];
  v16 = a1[8] * *a1 - a1[6] * a1[2];
  v5 = a1[6] * a1[1];
  v6 = a1[7] * *a1;
  v12 = v15;
  v17 = v5 - v6;
  v13 = v16;
  v14 = v17;
  a1[3] = v15;
  a1[4] = v13;
  a1[5] = v14;
  sub_53000(a1 + 3);
  v22 = &v18;
  v9 = a1[1] * a1[5] - a1[2] * a1[4];
  v10 = a1[2] * a1[3] - *a1 * a1[5];
  v7 = *a1 * a1[4];
  v8 = a1[1] * a1[3];
  v18 = v9;
  v11 = v7 - v8;
  v19 = v10;
  v20 = v11;
  a1[6] = v9;
  a1[7] = v19;
  a1[8] = v20;
  sub_53000(a1 + 6);
}

//----- (00053754) --------------------------------------------------------
void __fastcall sub_53754(float *a1, int a2, int a3, int a4)
{
  float *v5; // edx
  double v6; // st7
  double v7; // st6
  double v8; // st7
  double v9; // st6
  float v10; // [esp+0h] [ebp-48h]
  float v11; // [esp+4h] [ebp-44h]
  float v12; // [esp+8h] [ebp-40h]
  float v13; // [esp+Ch] [ebp-3Ch] BYREF
  float v14; // [esp+10h] [ebp-38h]
  float v15; // [esp+14h] [ebp-34h]
  float v16; // [esp+18h] [ebp-30h]
  float v17; // [esp+1Ch] [ebp-2Ch]
  float v18; // [esp+20h] [ebp-28h]
  float v19; // [esp+24h] [ebp-24h] BYREF
  float v20; // [esp+28h] [ebp-20h]
  float v21; // [esp+2Ch] [ebp-1Ch]
  float *v22; // [esp+30h] [ebp-18h]
  float *v23; // [esp+34h] [ebp-14h]
  int v24; // [esp+3Ch] [ebp-Ch]
  int v25; // [esp+40h] [ebp-8h]

  v25 = a4;
  v24 = a2;
  v5 = a1 + 3;
  sub_53000(a1 + 3);
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  v22 = &v13;
  v16 = v5[1] * a1[8] - v5[2] * a1[7];
  v17 = v5[2] * a1[6] - *v5 * a1[8];
  v6 = *v5 * a1[7];
  v7 = v5[1] * a1[6];
  v13 = v16;
  v18 = v6 - v7;
  v14 = v17;
  v15 = v18;
  *a1 = v16;
  a1[1] = v14;
  a1[2] = v15;
  sub_53000(a1);
  v23 = &v19;
  v10 = a1[1] * v5[2] - a1[2] * v5[1];
  v11 = a1[2] * *v5 - *a1 * v5[2];
  v8 = *a1 * v5[1];
  v9 = a1[1] * *v5;
  v19 = v10;
  v12 = v8 - v9;
  v20 = v11;
  v21 = v12;
  a1[6] = v10;
  a1[7] = v20;
  a1[8] = v21;
  sub_53000(a1 + 6);
}

//----- (00053864) --------------------------------------------------------
void __fastcall sub_53864(float *a1, int a2, int a3, int a4)
{
  float *v5; // edx
  float *v6; // ecx
  double v7; // st7
  double v8; // st6
  double v9; // st7
  double v10; // st6
  float v11; // [esp+0h] [ebp-48h]
  float v12; // [esp+4h] [ebp-44h]
  float v13; // [esp+8h] [ebp-40h]
  float v14; // [esp+Ch] [ebp-3Ch] BYREF
  float v15; // [esp+10h] [ebp-38h]
  float v16; // [esp+14h] [ebp-34h]
  float v17; // [esp+18h] [ebp-30h]
  float v18; // [esp+1Ch] [ebp-2Ch]
  float v19; // [esp+20h] [ebp-28h]
  float v20; // [esp+24h] [ebp-24h] BYREF
  float v21; // [esp+28h] [ebp-20h]
  float v22; // [esp+2Ch] [ebp-1Ch]
  float *v23; // [esp+30h] [ebp-18h]
  float *v24; // [esp+34h] [ebp-14h]
  int v25; // [esp+3Ch] [ebp-Ch]
  int v26; // [esp+40h] [ebp-8h]

  v26 = a4;
  v25 = a2;
  v5 = a1 + 6;
  v6 = a1 + 3;
  sub_53000(a1 + 6);
  v17 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v23 = &v14;
  v17 = v6[1] * v5[2] - v6[2] * v5[1];
  v18 = v6[2] * *v5 - *v6 * v5[2];
  v7 = *v6 * v5[1];
  v8 = v6[1] * *v5;
  v14 = v17;
  v19 = v7 - v8;
  v15 = v18;
  v16 = v19;
  *a1 = v17;
  a1[1] = v15;
  a1[2] = v16;
  sub_53000(a1);
  v24 = &v20;
  v11 = v5[1] * a1[2] - v5[2] * a1[1];
  v12 = v5[2] * *a1 - *v5 * a1[2];
  v9 = *v5 * a1[1];
  v10 = v5[1] * *a1;
  v20 = v11;
  v13 = v9 - v10;
  v21 = v12;
  v22 = v13;
  *v6 = v11;
  v6[1] = v21;
  v6[2] = v22;
  sub_53000(v6);
}

//----- (00053B08) --------------------------------------------------------
float *__fastcall sub_53B08(float *result, float *a2, float *a3, float *a4)
{
  *result = a3[1] * a2[1] + *a3 * *a2 + a3[2] * a2[2];
  result[1] = a3[4] * a2[1] + a3[3] * *a2 + a3[5] * a2[2];
  result[2] = a3[7] * a2[1] + a3[6] * *a2 + a3[8] * a2[2];
  result[4] = a3[1] * a2[4] + *a3 * a2[3] + a3[2] * a2[5];
  result[5] = a3[3] * a2[3] + a3[4] * a2[4] + a3[5] * a2[5];
  result[6] = a3[6] * a2[3] + a3[7] * a2[4] + a3[8] * a2[5];
  result[8] = a3[1] * a2[7] + *a3 * a2[6] + a3[2] * a2[8];
  result[9] = a3[3] * a2[6] + a3[4] * a2[7] + a3[5] * a2[8];
  result[0xA] = a3[6] * a2[6] + a3[7] * a2[7] + a3[8] * a2[8];
  result[3] = a4[1] * a2[1] + *a4 * *a2 + a4[2] * a2[2];
  result[7] = a4[1] * a2[4] + *a4 * a2[3] + a4[2] * a2[5];
  result[0xB] = a4[1] * a2[7] + *a4 * a2[6] + a4[2] * a2[8];
  return result;
}

//----- (00053D22) --------------------------------------------------------
int __cdecl sub_53D22(int a1)
{
  int v5; // edx
  unsigned int v6; // kr00_4
  int result; // eax
  __int16 v8; // [esp-Ah] [ebp-16h]
  void *retaddr; // [esp+10h] [ebp+4h]

  v6 = __readeflags();
  _disable();
  __asm { int     31h; DPMI Services   ax=func xxxxh }
  DMPI_selector_dword_53D1C = v5;
  DMPI_real_mode_segment_base_word_53D0C = 0x100;
  word_53CEA = 0;
  word_53D06 = 0x4F01;
  word_53D02 = a1;
  word_53D0E = 0;
  __asm { pushfw }
  word_53D0A = v8;
  __asm
  {
    int     31h; DPMI Services   ax=func xxxxh
    int     31h; DPMI Services   ax=func xxxxh
  }
  result = 0;
  _ZF = (BYTE1(retaddr) & 2) == 0;
  _disable();
  if ( !_ZF )
  {
    _enable();
  }
  __writeeflags(v6);
  return result;
}
// 53D37: variable 'v5' is possibly undefined
// 53D6D: variable 'v8' is possibly undefined
// 53CEA: using guessed type __int16 word_53CEA;
// 53D02: using guessed type __int16 word_53D02;
// 53D06: using guessed type __int16 word_53D06;
// 53D0A: using guessed type __int16 word_53D0A;
// 53D0C: using guessed type __int16 DMPI_real_mode_segment_base_word_53D0C;
// 53D0E: using guessed type __int16 word_53D0E;
// 53D1C: using guessed type int DMPI_selector_dword_53D1C;

//----- (00053DC0) --------------------------------------------------------
int __fastcall sub_53DC0(int a1, int a2, int a3)
{
  int result; // eax

  _wcpp_2_mod_register_(&unk_96B8C);
  result = sub_54344((int)&V_Type3_stru_10AE70, 1, a3);
  dword_96B94 = 1;
  return result;
}
// 786DA: using guessed type int __fastcall _wcpp_2_mod_register_(_DWORD);
// 96B94: using guessed type int dword_96B94;

//----- (00053DE4) --------------------------------------------------------
void __cdecl Q_Timer_sub_53DE4()
{
  ++V_Timer_dword_132B58;
}
// 132B58: using guessed type int V_Timer_dword_132B58;

//----- (00053DEC) --------------------------------------------------------
int Q_CheckFreeMemory_sub_53DEC()
{
  int v0; // edx
  int v1; // ecx
  unsigned int v2; // edi
  void *v3; // eax

  v0 = 0x2000000;
  v1 = 0;
  v2 = 0;
  do
  {
    v3 = malloc(v1 + v0);
    if ( v3 )
    {
      v1 += v0;
    }
    if ( v1 == 0x2000000 || v0 < 0x1000 )
    {
      v2 = 0xFFFFFFFF;
    }
    free(v3);
    v0 >>= 1;
  }
  while ( !v2 );
  return v1;
}

//----- (00053E38) --------------------------------------------------------
void __fastcall sub_53E38(P_Type5 a1, int a2, int a3, __int16 a4)
{
  int v5; // ebp

  if ( a4 >= SHIWORD(dword_A3CF2) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD0);
  }
  v5 = sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEE0);
  if ( !v5 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD5);
  }
  sub_53EB8(a1, v5, *((unsigned __int8 *)&byte_A2F73 + 0x1EE * a4), a2, a3, a4);
}
// A3CF2: using guessed type int dword_A3CF2;
// FFEE0: using guessed type __int16 word_FFEE0;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00053EB8) --------------------------------------------------------
void __fastcall sub_53EB8(P_Type5 a1, int a2, int a3, int a4, int a5, __int16 a6)
{
  __int16 v9; // ax
  char v10; // dl
  int v11; // ecx

  v9 = 0;
  v10 = 4 * byte_A2F74[0x1EE * a6] + 0x13;
  while ( v9 < 4 )
  {
    v11 = 0x13 - v9++;
    *(_BYTE *)(v11 + *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3022]) = v10--;
  }
  VFX_shape_lookaside(*(UBYTE **)&V_Type3_stru_10AE70.z1[0x3022]);
  VFX_shape_translate_draw((PANE *)a1, (void *)a2, a3, a4, a5);
}

//----- (00053F40) --------------------------------------------------------
void __fastcall sub_53F40(T_Type5 *a1, void *a2, LONG a3, LONG a4, int a5, char a6)
{
  __int16 v8; // ax
  char v9; // dl
  int v10; // ecx

  v8 = 0;
  v9 = 4 * a6 + 0x13;
  while ( v8 < 4 )
  {
    v10 = 0x13 - v8++;
    *(_BYTE *)(v10 + *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3022]) = v9--;
  }
  VFX_shape_lookaside(*(UBYTE **)&V_Type3_stru_10AE70.z1[0x3022]);
  VFX_shape_translate_draw((PANE *)a1, a2, a3, a4, a5);
}

//----- (00053FB0) --------------------------------------------------------
void __fastcall sub_53FB0(const char *a1, int a2, int a3, int a4)
{
  char *sub_1CEA8; // eax
  T_Type1 v6; // [esp-118h] [ebp-198h] BYREF
  char v7[120]; // [esp+0h] [ebp-80h] BYREF
  int v8; // [esp+78h] [ebp-8h]

  v8 = a4;
  Q_InitFileInfo_sub_1BB78(&v6);
  if ( Q_CfilePreload_sub_1BBFC(&v6, a1, 0x200, 0) )
  {
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAA);
    sub_556CC((unsigned int)&V_Type3_stru_10AE70, (int)sub_1CEA8);
  }
  else
  {
    sub_1BF94(&v6, v7, 0x74u);
    sub_21AA0((int)dword_A2F6C, (unsigned int)&v6);
    sub_56BE8((int)&V_Type3_stru_10AE70, 0xD, 0, 0, 0);
    sub_5A294(&V_Type3_stru_10AE70);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v6);
}
// A2F6C: using guessed type int dword_A2F6C[];
// 53FB0: using guessed type char var_80[120];

//----- (00054048) --------------------------------------------------------
void __fastcall sub_54048(const char *a1, int a2, int a3, int a4)
{
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // ebx
  int v11; // eax
  int v12; // edx
  int v13; // ebx
  char *sub_1CEA8; // eax
  T_Type1 v15; // [esp-118h] [ebp-198h] BYREF
  int v16[2]; // [esp+0h] [ebp-80h] BYREF
  int v17[30]; // [esp+8h] [ebp-78h]

  v17[0x1C] = a4;
  v17[0x1B] = a2;
  Q_InitFileInfo_sub_1BB78(&v15);
  if ( sub_1BCA8(&v15, a1) )
  {
    sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0xAA);
    sub_556CC((unsigned int)&V_Type3_stru_10AE70, (int)sub_1CEA8);
    Q_CloseFileAndDelete_sub_1BBC8(&v15);
  }
  else
  {
    v16[0] = dword_A2F6C[0];
    v16[1] = SHIWORD(dword_A3CF2);
    v5 = 0;
    v6 = 0;
    v17[0] = (unsigned __int8)byte_104BEA;
    v7 = 0;
    while ( v5 < SHIWORD(dword_A3CF2) )
    {
      v7 += 0x1EE;
      ++v6;
      ++v5;
      v17[v6] = (unsigned __int8)V_StaticStrings_dword_A0D04.buffer[v7 + 0x1D61];
    }
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while ( v8 < SHIWORD(dword_A3CF2) )
    {
      v10 += 0x1EE;
      ++v9;
      ++v8;
      v17[v9 + 7] = (unsigned __int8)V_StaticStrings_dword_A0D04.buffer[v10 + 0x1D62];
    }
    v11 = 0;
    v12 = 0;
    while ( v11 < SHIWORD(dword_A3CF2) )
    {
      v13 = *(_DWORD *)((char *)&unk_A312F + 0x1EE * (unsigned __int8)byte_104BEA + v11);
      ++v12;
      ++v11;
      v17[v12 + 0xE] = v13 >> 0x18;
    }
    v17[0x16] = sub_40224((unsigned __int8 *)&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], 0, 0);
    v17[0x17] = sub_402E0(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
    v17[0x18] = sub_40664(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA]);
    sub_1C098((unsigned int)&v15, (int)v16, 0x74u);
    sub_21374((int)dword_A2F6C, (unsigned int)&v15);
    sub_5A294(&V_Type3_stru_10AE70);
    Q_CloseFileAndDelete_sub_1BBC8(&v15);
  }
}
// A2F6C: using guessed type int dword_A2F6C[];
// A3CF2: using guessed type int dword_A3CF2;

//----- (00054208) --------------------------------------------------------
LONG __fastcall __spoils<> sub_54208(PANE *a1, int a2, int a3, int a4)
{
  LONG result; // eax
  UBYTE *v5; // [esp+0h] [ebp-3Ch] BYREF
  LONG v6; // [esp+4h] [ebp-38h]
  LONG v7; // [esp+8h] [ebp-34h]
  int v8; // [esp+Ch] [ebp-30h]
  int v9; // [esp+10h] [ebp-2Ch]
  PANE target; // [esp+14h] [ebp-28h] BYREF
  int v11; // [esp+34h] [ebp-8h]

  v11 = a4;
  v5 = buffer;
  v6 = a1->x1 - a1->x0;
  v7 = a1->y1 - a1->y0;
  v8 = 0;
  v9 = 0;
  if ( v7 * v6 >= (int)&loc_27100 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x13E);
  }
  target.x1 = v6;
  target.y1 = v7;
  target.window = (WINDOW *)&v5;
  target.x0 = 0;
  target.y0 = 0;
  result = VFX_pane_copy(a1, 0, 0, &target, 0, 0, 0xFFFFFFFF);
  if ( result )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x147);
  }
  return result;
}
// D8DA0: using guessed type UBYTE buffer[94816];

//----- (000542B0) --------------------------------------------------------
LONG __fastcall sub_542B0(_DWORD *a1, int a2, int a3, int *a4)
{
  UBYTE *v5; // [esp+0h] [ebp-3Ch] BYREF
  LONG v6; // [esp+4h] [ebp-38h]
  LONG v7; // [esp+8h] [ebp-34h]
  int v8; // [esp+Ch] [ebp-30h]
  int v9; // [esp+10h] [ebp-2Ch]
  PANE source; // [esp+14h] [ebp-28h] BYREF
  int *v11; // [esp+34h] [ebp-8h]

  v11 = a4;
  v5 = buffer;
  v6 = a1[3] - a1[1];
  v7 = a1[4] - a1[2];
  v8 = 0;
  v9 = 0;
  if ( v7 * v6 >= (int)&loc_27100 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x158);
  }
  source.x1 = v6;
  source.y1 = v7;
  source.window = (WINDOW *)&v5;
  source.x0 = 0;
  source.y0 = 0;
  return VFX_pane_copy(&source, 0, 0, (PANE *)a1, 0, 0, 0xFFFFFFFF);
}
// D8DA0: using guessed type UBYTE buffer[94816];

//----- (00054344) --------------------------------------------------------
int __fastcall sub_54344(int a1, int a2, int a3)
{
  _DWORD *v4; // eax
  int v5; // edx

  v4 = (_DWORD *)(a1 + 0x3026);
  sub_2B2C0(v4);
  v4 += 8;
  sub_2B2C0(v4);
  v5 = sub_1ACC0((int)v4 + 0x21D6A, a1, a3) - 0x24DB0;
  sub_54448(v5);
  return v5;
}

//----- (00054374) --------------------------------------------------------
char *__fastcall sub_54374(T_Type3 *a1)
{
  __int16 i; // cx
  void **v3; // eax
  int v4; // eax
  __int16 j; // dx
  char *v6; // eax
  int v7; // edx
  T_Type3 *v8; // eax
  int v9; // eax
  void **v10; // eax

  for ( i = 0; i < 0x400; ++i )
  {
    v3 = (void **)((char *)a1 + 0xC * i);
    if ( v3[1] )
    {
      sub_2627C(v3[1]);
    }
    v4 = *(_DWORD *)&a1->z1[0xC * i + 4];
    if ( v4 )
    {
      (**(void (***)(void))(v4 + 0xA7))();
    }
  }
  for ( j = 0; j < 6; ++j )
  {
    v6 = &a1->z1[4 * j];
    if ( *(_DWORD *)(v6 + 0x300E) )
    {
      sub_2627C(*(void **)(v6 + 0x300E));
    }
    operator delete[](*(void **)&a1->z1[4 * j + 0x300E]);
  }
  if ( a1->aaa == 0xFFFFFFFF )
  {
    v7 = 0xFFFFFFFF;
    v8 = a1;
LABEL_17:
    sub_59934(v8, v7, (int)a1);
    goto LABEL_18;
  }
  if ( a1->bbb == 0xFFFFFFFF )
  {
    v8 = a1;
    v7 = 0;
    goto LABEL_17;
  }
LABEL_18:
  sub_54664((int)a1);
  v9 = sub_1ACF4((int)&a1[1].z1[8]);
  v10 = sub_2B2E0((void **)(v9 - 0x21D6A));
  return (char *)sub_2B2E0(v10 + 0xFFFFFFF8) + 0xFFFFCFDA;
}
// 76D5C: using guessed type void __fastcall operator delete[](void *);

//----- (00054448) --------------------------------------------------------
void *__fastcall sub_54448(int a1)
{
  int v2; // eax
  __int16 i; // ax
  int v4; // edx

  v2 = a1 + 0x3066;
  *(_WORD *)(v2 + 0x11C0) = 0;
  *(_WORD *)(v2 - 0x66) = 0;
  *(_WORD *)(v2 + 0x11C2) = 0xFFFF;
  *(_WORD *)(v2 + 0x16F0) = 0;
  *(_WORD *)(v2 + 0x16F2) = 0;
  *(_WORD *)(v2 + 0x1446) = 0;
  *(_WORD *)(v2 + 0x15A8) = 0;
  *(_WORD *)(v2 + 0x16CA) = 0;
  *(_DWORD *)(v2 - 0x64) = 0xFFFFFFFF;
  *(_DWORD *)(v2 + 0x16CC) = 0xFFFFFFFF;
  *(_WORD *)(v2 + 0x16F4) = 0;
  *(_WORD *)(v2 + 0x16F6) = 0;
  *(_DWORD *)((char *)&loc_21D46 + v2) = 0x3F800000;
  V_Timer_dword_132B58 = 0;
  memset((void *)v2, 0, 0x11C0u);
  memset((void *)a1, 0, 0x3000u);
  memset((void *)(a1 + 0x44AE), 0, 0x160u);
  memset((void *)(a1 + 0x4610), 0, 0x120u);
  memset((void *)(a1 + 0x300E), 0, 0x18u);
  memset((void *)(a1 + 0x4736), 0xFFFFFFFF, 0x20u);
  for ( i = 0; i < 0x20; ++i )
  {
    v4 = 0x8E * i;
    *(_WORD *)(a1 + v4 + 0x3066) = 0xFFFF;
    *(_WORD *)(a1 + v4 + 0x30EA) = 0xFFFF;
  }
  *(_DWORD *)(a1 + 0x489E) = 0;
  *(_DWORD *)(a1 + 0x48A2) = 0;
  *(_DWORD *)(a1 + 0x24D9C) = 0;
  *(_DWORD *)(a1 + 0x24DA0) = 0;
  *(_DWORD *)((char *)&loc_24DA4 + a1) = 0;
  *(_DWORD *)(a1 + 0x24DA8) = 0xFFFFFFFF;
  *(_DWORD *)(a1 + 0x48A6) = 0;
  *(_DWORD *)(a1 + 0x48AA) = 0;
  *(_DWORD *)(a1 + 0x48AE) = 0;
  memset((void *)(a1 + 0x21D82), 0x10, 0);
  *(_DWORD *)(a1 + 0x21D82) = 0x3C;
  *(_WORD *)(a1 + 0x24D96) = 0;
  return memset((char *)&loc_21D96 + a1, 0, 0x3000u);
}
// 132B58: using guessed type int V_Timer_dword_132B58;

//----- (000545EC) --------------------------------------------------------
unsigned int __fastcall sub_545EC(P_Type3 a1)
{
  int v2; // ebx
  HTIMER v3; // eax
  HTIMER v4; // edi

  v2 = *(_DWORD *)&a1->z2[0x122];
  V_Timer_dword_132B58 = 0;
  if ( v2 == 0xFFFFFFFF )
  {
    v3 = AIL_register_timer((AILTIMERCB)Q_Timer_sub_53DE4);
    *(_DWORD *)&a1->z2[0x122] = v3;
    if ( v3 == 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x1E5);
    }
    v4 = *(_DWORD *)&a1->z2[0x122];
    if ( v4 == 0xFFFFFFFF )
    {
      return 0;
    }
    AIL_set_timer_frequency(v4, 0x64u);
    AIL_start_timer(*(_DWORD *)&a1->z2[0x122]);
  }
  return 0xFFFFFFFF;
}
// 132B58: using guessed type int V_Timer_dword_132B58;

//----- (00054664) --------------------------------------------------------
void __fastcall sub_54664(int a1)
{
  if ( *(_DWORD *)(a1 + 0x4732) != 0xFFFFFFFF )
  {
    AIL_stop_timer(*(_DWORD *)(a1 + 0x4732));
    AIL_release_timer_handle(*(_DWORD *)(a1 + 0x4732));
    *(_DWORD *)(a1 + 0x4732) = 0xFFFFFFFF;
  }
}

//----- (0005469C) --------------------------------------------------------
int __fastcall sub_5469C(P_Type3 a1, int a2, int a3, int a4)
{
  int v5; // edi
  unsigned int v6; // eax
  _DWORD *v7; // ecx
  int v8; // eax
  unsigned int v9; // eax
  int v10; // ebx
  __int16 v11; // ax
  int v12; // eax
  int aaa; // edx
  int v14; // eax
  unsigned int v15; // esi
  int v16; // ebx
  char v17; // dl
  int result; // eax
  int v19; // [esp-4h] [ebp-30h]
  char s[44]; // [esp+0h] [ebp-2Ch] BYREF

  if ( a1->aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    ++*(_DWORD *)&a1->z3[8];
  }
  v5 = ::a3;
  *(_DWORD *)&a1->z3[4] = 0xFFFFFFFF;
  if ( !v5 || *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) || *(_DWORD *)&a1->z2[0x28E] )
  {
    if ( *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) )
    {
      a3 = ::a3;
      if ( !::a3 )
      {
        a3 = 0;
        a2 = 0;
        *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) = 0;
        Q_GSYSTEM_CPP_sub_2C7D0(&V_Type6_stru_D8654, 0, 0);
        a4 = *(_DWORD *)&a1->z1[0x3002];
        if ( a4 != 0xFFFFFFFF )
        {
          sub_56D30((int)a1, a4, 6, 0, 0);
          a3 = 7;
          a2 = *(_DWORD *)&a1->z1[0x3002];
          a4 = 0;
          sub_56D30((int)a1, a2, 7, 0, 0);
        }
      }
    }
  }
  else
  {
    a2 = 1;
    a3 = 0;
    *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) = 0xFFFFFFFF;
    Q_GSYSTEM_CPP_sub_2C7D0(&V_Type6_stru_D8654, 1, 0);
  }
  v6 = 0xFFFFFFFF;
  if ( !*(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) && !*(_DWORD *)&a1->z2[0x28E] )
  {
    a2 = *(__int16 *)&a1->z1[0x4228];
    if ( *(_WORD *)&a1->z1[0x4228] )
    {
      a2 = dword_D864C;
      if ( dword_D864C )
      {
        if ( dword_D864C == 0x1DF )
        {
          a4 = new_x;
          if ( new_x )
          {
            if ( new_x == 0x27F )
            {
              v6 = 3;
            }
          }
          else
          {
            a4 = 0;
            v6 = 2;
          }
        }
      }
      else
      {
        a2 = 0;
        if ( new_x )
        {
          if ( new_x == 0x27F )
          {
            v6 = 1;
          }
        }
        else
        {
          v6 = 0;
        }
      }
    }
  }
  if ( v6 != *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] )
  {
    a2 = 0;
    *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] = v6;
    if ( v6 != 0xFFFFFFFF )
    {
      a2 = v6 + 4;
    }
    a4 = 0;
    a3 = 0;
    sub_5A270(a1, a2, 0, 0);
  }
  if ( dword_D8644 == 0xFFFFFFFF )
  {
    if ( dword_D8644 == a1->aaa && *(_DWORD *)&a1->z3[4] )
    {
      a4 = 0;
      a2 = 0;
      a3 = 1;
      sub_59C80(a1, 0, 1, 0, new_x, dword_D864C, 0);
      *(_DWORD *)&a1->z3[4] = 0;
    }
    sub_5691C((int)a1);
  }
  if ( !*(_DWORD *)&a1->z2[0x28E] )
  {
    if ( *(_WORD *)&a1->z2[0x120] )
    {
      sub_56824((int)a1);
    }
    if ( a1->counter1 )
    {
      sub_56694((int)a1);
    }
  }
  if ( dword_D85FC == 0xFFFFFFFF )
  {
    if ( dword_D85FC == a1->aaa && (!dword_D8600 || word_D8620 != 0x13 && word_D8620 != 0x19) )
    {
      a3 = 3;
      a4 = SHIWORD(dword_D8622);
      a2 = 0;
      sub_59C80(
        a1,
        0,
        3,
        SHIWORD(dword_D8622),
        (unsigned __int16)word_D8620,
        (unsigned __int16)dword_D8622,
        dword_D8600);
    }
    if ( a1->bbb == 0xFFFFFFFF && dword_D8604 && word_D8620 == 0x19 )
    {
      v19 = dword_132B1C;
      a1->bbb = 0;
      sprintf(s, "info%02d", v19);
      v7 = (_DWORD *)sub_56DA8((int)a1, "HELPWINDOW", 0);
      sub_2FCB0(v7, byte_132B20, s);
      a2 = (int)v7;
      a3 = 0;
      sub_552F8((unsigned int)a1, (int)v7, 0);
      dword_D8600 = 0;
      dword_132B14 = dword_D862C;
      v8 = dword_D8630;
      a1->bbb = 0xFFFFFFFF;
      dword_132B18 = v8;
      a4 = 0;
      word_D8620 = 0;
      ++dword_132B1C;
    }
    v9 = 0xFFFFFFFF;
    if ( dword_D8600 == 0xFFFFFFFF || (a2 = (unsigned __int16)word_D8620, word_D8620 == 1) )
    {
      v9 = sub_54D64((unsigned int)a1, a2, a3);
    }
    if ( v9 == 0xFFFFFFFF )
    {
      a4 = (unsigned __int16)word_D8620;
      sub_56BE8((int)a1, 3, (unsigned __int16)dword_D8622, (unsigned __int16)word_D8620, 0);
    }
  }
  v10 = dword_D8638;
  if ( dword_D8638 == 0xFFFFFFFF )
  {
    if ( dword_D8638 == a1->aaa && !dword_D8600 )
    {
      v11 = 0;
      if ( dword_D862C && ::a3 )
      {
        v11 = 1;
      }
      a4 = v11;
      v10 = 2;
      sub_59C80(a1, 0, 2, v11, 0, dword_D862C, 0);
    }
    if ( dword_D862C )
    {
      if ( *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] == 0xFFFFFFFF )
      {
        if ( dword_D8600 == 0xFFFFFFFF )
        {
          v10 = dword_D864C;
          a4 = new_x;
          dword_132B10 = VFX_pixel_read(&V_Type6_stru_D8654.pane, new_x, dword_D864C);
          v12 = *(_DWORD *)&a1->z1[(_DWORD)&loc_21D90 + 2];
          if ( *(_DWORD *)(v12 + 0x39) )
          {
            a4 = 0;
            v10 = 0;
            (*(void (**)(void))(*(_DWORD *)(v12 + 0xA7) + 8))();
          }
        }
        else if ( *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) != 0xFFFFFFFF || *(_DWORD *)&a1->z2[0x28E] )
        {
          a4 = dword_D864C;
          v10 = new_x;
          sub_56BE8((int)a1, 4, new_x, dword_D864C, 0);
        }
        else
        {
          a4 = dword_D864C;
          v10 = new_x;
          sub_56BE8((int)a1, 0xC, new_x, dword_D864C, 0);
        }
      }
      else if ( *(_DWORD *)&a1->z2[0x28E] )
      {
        *(_DWORD *)&a1->z2[0x28E] = 0;
        *(_DWORD *)&a1->z2[0x292] = 0xFFFFFFFF;
      }
      else
      {
        sub_4FB90((int)&unk_10914C, 0);
        a4 = 0;
        v10 = 0;
        sub_5A270(a1, 0, 0, 0);
        *(_DWORD *)&a1->z1[(_DWORD)&loc_24DA4 + 4] = 0xFFFFFFFF;
        sub_570AC((int)a1, 0xFFFFFFFF);
      }
    }
  }
  if ( dword_D863C == 0xFFFFFFFF )
  {
    aaa = a1->aaa;
    if ( aaa == dword_D863C )
    {
      a4 = 0;
      aaa ^= dword_D863C;
      v10 = 2;
      sub_59C80(a1, aaa, 2, 0, 1, dword_D8630, 0);
    }
    if ( dword_D8630 )
    {
      if ( *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) == 0xFFFFFFFF )
      {
        *(_DWORD *)((char *)&loc_24DA4 + (_DWORD)a1) = 0;
        Q_GSYSTEM_CPP_PreloadMouseShp_sub_2C744(&V_Type6_stru_D8654, (char *)aaa, v10, a4);
      }
      else
      {
        sub_56BE8((int)a1, 5, new_x, dword_D864C, 0);
      }
    }
  }
  while ( *(__int16 *)&a1->z1[0x44AC] > 0 )
  {
    sub_55E80((int)a1);
  }
  if ( *(_WORD *)&a1->z2[0x14A] && *(_WORD *)&a1->z1[0x4228] == 1 && !*(_DWORD *)&a1->z2[0x28E] )
  {
    sub_55B74((int)a1);
  }
  if ( *(_DWORD *)&a1->z1[(_DWORD)&loc_24D9B + 1] == 0xFFFFFFFF
    && !*(_WORD *)&a1->z2[0x14A]
    && !*(_DWORD *)&a1->z2[0x28E] )
  {
    sub_56B60((int)a1, 7, 0, 0);
  }
  if ( dword_10936F == 0xFFFFFFFF && !dword_109377 )
  {
    if ( !dword_109373 )
    {
      v14 = *(__int16 *)&a1->z1[0x4228];
      if ( v14 != 7 && v14 != 0xD && v14 != 6 )
      {
        LOWORD(v15) = 0xFFFF;
        v16 = 0;
        if ( word_96BB0 != 0xFFFFFFFF && dword_1094DE[7 * word_96BB0] )
        {
          v16 = 0xFFFFFFFF;
          LOWORD(v15) = word_96BB0;
          dword_96BB4 = 0;
        }
        if ( (__int16)v15 == 0xFFFFFFFF )
        {
          if ( word_96BB0 == 0xFFFFFFFF )
          {
            LOWORD(v15) = 0;
          }
          else
          {
            v15 = (new_x + V_Timer_dword_132B58) % 5u;
            if ( (_WORD)v15 == word_96BB0 )
            {
              v15 = (word_96BB0 + 1) % 5;
            }
          }
        }
        sub_4F8CC((int)&unk_10914C, v15, v16);
        word_96BB0 = v15;
      }
    }
    if ( dword_96BB4 != 0xFFFFFFFF )
    {
      v17 = dword_96BB4++;
      sub_4FF4C((int)&unk_10914C, v17);
      if ( dword_96BB4 == 0x64 )
      {
        dword_96BB4 = 0xFFFFFFFF;
      }
    }
  }
  do
  {
    if ( dword_10936F == 0xFFFFFFFF && dword_10936F == dword_109373 )
    {
      if ( dword_109373 == dword_109377 )
      {
        sub_4FA1C((int)&unk_10914C);
      }
      else
      {
        sub_4FAB4((int)&unk_10914C);
      }
    }
  }
  while ( (unsigned int)(V_Timer_dword_132B58 - dword_132B34) < 3 );
  result = V_Timer_dword_132B58;
  dword_132B34 = V_Timer_dword_132B58;
  return result;
}
// 96BB0: using guessed type __int16 word_96BB0;
// 96BB4: using guessed type int dword_96BB4;
// D85FC: using guessed type int dword_D85FC;
// D8600: using guessed type int dword_D8600;
// D8604: using guessed type int dword_D8604;
// D8620: using guessed type __int16 word_D8620;
// D8622: using guessed type int dword_D8622;
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// 10936F: using guessed type int dword_10936F;
// 109373: using guessed type int dword_109373;
// 109377: using guessed type int dword_109377;
// 1094DE: using guessed type int dword_1094DE[218];
// 132B10: using guessed type int dword_132B10;
// 132B14: using guessed type int dword_132B14;
// 132B18: using guessed type int dword_132B18;
// 132B1C: using guessed type int dword_132B1C;
// 132B34: using guessed type int dword_132B34;
// 132B58: using guessed type int V_Timer_dword_132B58;

//----- (00054D64) --------------------------------------------------------
unsigned int __fastcall sub_54D64(unsigned int a1, int a2, int a3)
{
  if ( (unsigned __int16)word_D8620 >= 0x20u )
  {
    if ( (unsigned __int16)word_D8620 <= 0x20u )
    {
      if ( dword_A0CFC == 0xFFFFFFFF )
      {
        dword_132B5C = ~dword_132B5C;
      }
    }
    else
    {
      if ( (unsigned __int16)word_D8620 >= 0x26u )
      {
        if ( (unsigned __int16)word_D8620 <= 0x26u )
        {
          if ( !*(_DWORD *)(a1 + 0x489E) && *(_WORD *)(a1 + 0x4228) != 8 )
          {
            sub_56E9C((P_Type3)a1, 4, 0xFFFFFFFF);
            return 0;
          }
        }
        else
        {
          if ( (unsigned __int16)word_D8620 >= 0x31u )
          {
            if ( (unsigned __int16)word_D8620 <= 0x31u )
            {
              dword_10935F = ~dword_10935F;
              return 0;
            }
            if ( word_D8620 == 0x32 )
            {
              dword_109377 = ~dword_109377;
              return 0;
            }
            return 0xFFFFFFFF;
          }
          if ( word_D8620 != 0x2D )
          {
            return 0xFFFFFFFF;
          }
          if ( !*(_DWORD *)(a1 + 0x489E) )
          {
            dword_96774 = 0;
            return 0;
          }
        }
        return 0;
      }
      if ( (unsigned __int16)word_D8620 > 0x21u )
      {
        if ( word_D8620 != 0x22 )
        {
          return 0xFFFFFFFF;
        }
        sub_1B4D0((char *)&loc_24DAD + a1 + 3);
        sub_31C18(*(_DWORD *)((char *)&loc_27C93 + a1 + 1), *(_DWORD *)((char *)&loc_27C93 + a1 + 5));
        sub_1ACE8((int)&loc_24DAD + a1 + 3);
        return 0;
      }
      if ( dword_A0CFC == 0xFFFFFFFF )
      {
        if ( dword_A0CFC == *(_DWORD *)((char *)&loc_24D98 + a1) )
        {
          *(_DWORD *)((char *)&loc_24D98 + a1) = 0;
        }
        else
        {
          *(_DWORD *)((char *)&loc_24D98 + a1) = dword_A0CFC;
        }
        return 0;
      }
    }
    return 0;
  }
  if ( (unsigned __int16)word_D8620 < 0x12u )
  {
    if ( word_D8620 )
    {
      if ( (unsigned __int16)word_D8620 > 1u )
      {
        if ( word_D8620 != 0x11 )
        {
          return 0xFFFFFFFF;
        }
        if ( dword_A0CFC == 0xFFFFFFFF )
        {
          sub_552F8(a1, *(_DWORD *)((char *)&loc_21D90 + a1 + 2), 0);
          return 0;
        }
        return 0;
      }
      if ( *(_DWORD *)(a1 + 0x489E) )
      {
        *(_DWORD *)(a1 + 0x489E) = 0;
        *(_DWORD *)(a1 + 0x48A2) = 0;
        return 0;
      }
      if ( *(_WORD *)(a1 + 0x4228) != 0x11 )
      {
        sub_570AC(a1, 0xFFFFFFFF);
        return 0;
      }
    }
    return 0xFFFFFFFF;
  }
  if ( (unsigned __int16)word_D8620 <= 0x12u )
  {
    if ( dword_A0CFC == 0xFFFFFFFF )
    {
      *(_DWORD *)((char *)&loc_24D9E + a1 + 2) = ~*(_DWORD *)((char *)&loc_24D9E + a1 + 2);
      return 0;
    }
    return 0;
  }
  if ( (unsigned __int16)word_D8620 < 0x19u )
  {
    if ( word_D8620 != 0x13 )
    {
      return 0xFFFFFFFF;
    }
    if ( *(_DWORD *)(a1 + 0x48AA) || dword_A0CFC != 0xFFFFFFFF )
    {
      return 0;
    }
    if ( *(_DWORD *)(a1 + 0x48A6) )
    {
      sub_59934((T_Type3 *)a1, dword_A0CFC, dword_A0CFC);
    }
    else
    {
      srand(0);
      *(_DWORD *)((char *)&loc_24DAA + a1 + 2) = 0x3F800000;
      sub_59908(a1);
    }
    return 0;
  }
  else
  {
    if ( (unsigned __int16)word_D8620 > 0x19u )
    {
      if ( word_D8620 != 0x1F )
      {
        return 0xFFFFFFFF;
      }
      if ( !*(_DWORD *)(a1 + 0x489E) && *(_WORD *)(a1 + 0x4228) != 8 )
      {
        sub_56E9C((P_Type3)a1, 2, 0xFFFFFFFF);
      }
      return 0;
    }
    if ( *(_DWORD *)(a1 + 0x48A6) || dword_A0CFC != 0xFFFFFFFF )
    {
      return 0;
    }
    if ( *(_DWORD *)(a1 + 0x48AA) )
    {
      sub_59934((T_Type3 *)a1, 0, a3);
    }
    else
    {
      sub_59988((P_Type3)a1, "WINEVENT.BIN", 0);
    }
    return 0;
  }
}
// 96774: using guessed type int dword_96774;
// A0CFC: using guessed type int dword_A0CFC;
// D8620: using guessed type __int16 word_D8620;
// 10935F: using guessed type int dword_10935F;
// 109377: using guessed type int dword_109377;
// 132B5C: using guessed type int dword_132B5C;

//----- (0005508C) --------------------------------------------------------
unsigned int __fastcall sub_5508C(P_Type3 a1)
{
  int v1; // esi
  unsigned int v2; // ebx
  int v3; // ebx
  unsigned int result; // eax
  char s[40]; // [esp+0h] [ebp-2Ch] BYREF
  P_Type3 v6; // [esp+28h] [ebp-4h]

  v6 = a1;
  if ( *(_DWORD *)((char *)&loc_24D98 + (_DWORD)a1) == 0xFFFFFFFF )
  {
    if ( ++dword_10AE60 == 0xA )
    {
      v1 = dword_10AE68;
      dword_10AE64 = V_Timer_dword_132B58;
      dword_10AE68 = V_Timer_dword_132B58;
      v2 = V_Timer_dword_132B58 - v1;
      dword_10AE60 = 0;
      if ( V_Timer_dword_132B58 == v1 )
      {
        v2 = 1;
      }
      sprintf("FPS DUDE", "FPS %lu  %lu", 0x3E8 / v2, v2);
    }
    sub_2B3E0(&V_Type3_stru_10AE70.z1[0x3046], 0x19, 0xA, 0x96, 0x1E);
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, 0, "FPS DUDE", 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
  }
  if ( dword_132B5C )
  {
    v3 = 0;
    if ( dword_D864C < 0xF0 )
    {
      v3 = 0x1CC;
    }
    sprintf(s, "(%d,%d)", new_x, dword_D864C);
    *(PANE *)&V_Type3_stru_10AE70.z1[0x304E] = V_Type6_stru_D8654.pane;
    sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 0, v3, s, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
  }
  if ( dword_D8628 == 1 )
  {
    MOUSE_pane_list_refresh(*(PANE_LIST **)&v6->z1[0x3006]);
  }
  else
  {
    sub_5BA38(*(_DWORD **)&v6->z1[0x3006]);
  }
  result = sub_5B71C(*(_DWORD *)&v6->z1[0x3006]);
  if ( dword_132B60 == 0xFFFFFFFF )
  {
    result = sub_2C5E4((int)&V_Type6_stru_D8654, dword_132B64);
    if ( ++dword_132B64 > 0x40 )
    {
      dword_132B64 = 0;
      dword_132B60 = 0;
    }
  }
  return result;
}
// D8628: using guessed type int dword_D8628;
// 10AE60: using guessed type int dword_10AE60;
// 10AE64: using guessed type int dword_10AE64;
// 10AE68: using guessed type int dword_10AE68;
// 132B58: using guessed type int V_Timer_dword_132B58;
// 132B5C: using guessed type int dword_132B5C;
// 132B60: using guessed type int dword_132B60;
// 132B64: using guessed type int dword_132B64;

//----- (00055214) --------------------------------------------------------
void __fastcall sub_55214(int eax0, LONG a2, LONG a3, LONG a4, int a5)
{
  PANE pane; // [esp+0h] [ebp-24h] BYREF
  P_Type3 a1; // [esp+14h] [ebp-10h]

  a1 = (P_Type3)eax0;
  pane.x0 = a2;
  pane.y1 = a5;
  pane.y0 = a3;
  pane.x1 = a4;
  pane.window = *(WINDOW **)(eax0 + 0x300A);
  VFX_pane_wipe(&pane, 0);
  sub_55274(a1, a2, a3, a4, a5);
}

//----- (00055274) --------------------------------------------------------
void __fastcall sub_55274(P_Type3 a1, int x1, int y1, int x2, int y2)
{
  if ( sub_5B7C2(*(_DWORD **)&a1->z1[0x3006], *(_DWORD *)&a1->z1[0x300A], x1, y1, x2, y2) == 0xFFFFFFFF )
  {
    sub_5B71C(*(_DWORD *)&a1->z1[0x3006]);
    sub_5B7C2(*(_DWORD **)&a1->z1[0x3006], *(_DWORD *)&a1->z1[0x300A], 0, 0, 639, 479);
  }
}

//----- (000552CC) --------------------------------------------------------
void __fastcall sub_552CC(P_Type3 a1, P_Type5 a2)
{
  if ( a2 )
  {
    sub_55274(a1, a2->rect.x1, a2->rect.y1, a2->rect.x2, a2->rect.y2);
  }
  else
  {
    sub_55274(a1, 0, 0, 639, 479);
  }
}

//----- (000552F8) --------------------------------------------------------
int __fastcall sub_552F8(unsigned int a1, int a2, int *a3)
{
  int v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // ecx
  __int16 v8; // di
  __int16 i; // cx
  __int16 j; // si
  int v11; // edx
  int *v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // edi
  int result; // eax
  _DWORD v17[5]; // [esp+0h] [ebp-30h] BYREF
  int v18; // [esp+14h] [ebp-1Ch]
  int *v19; // [esp+18h] [ebp-18h]
  int v20; // [esp+1Ch] [ebp-14h]

  v20 = a2;
  v19 = a3;
  if ( *(_DWORD *)(a1 + 0x489E) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x4CC);
  }
  v4 = dword_A0D00;
  v18 = *(_DWORD *)((char *)&loc_24D9B + a1 + 1);
  *(_DWORD *)((char *)&loc_24D9B + a1 + 1) = 0;
  if ( !v4 )
  {
    v5 = sub_56DA8(a1, "NEXTTURNCONT", 0);
    v6 = *(_DWORD *)(v5 + 0xA7);
    *(_DWORD *)(v5 + 0xAB) = 0;
    (*(void (**)(void))(v6 + 0xC))();
  }
  v7 = *(_DWORD *)(a1 + 0x3002);
  if ( v7 != 0xFFFFFFFF )
  {
    sub_56D30(a1, v7, 6, 0, 0);
  }
  *(_DWORD *)(a1 + 0x3002) = 0xFFFFFFFF;
  memset(byte_132B38, 1, sizeof(byte_132B38));
  sub_56BE8(a1, 0xF, 0, 0, 0xFFFFFFFF);
  if ( dword_96BB8 == 0xFFFFFFFF )
  {
    sub_54208((PANE *)(v20 + 4), 0xF, 0, 0);
  }
  if ( sub_57220(a1, *(_DWORD *)(v20 + 0x41), *(_WORD *)(a1 + 0x4228)) != 0xFFFFFFFF )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x4EE);
  }
  v8 = *(_WORD *)(v20 + 0x6B);
  for ( i = 0; i < v8; ++i )
  {
    if ( sub_57220(a1, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v20 + 0x67) + 4 * i) + 0x41), *(_WORD *)(a1 + 0x4228)) != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x4F4);
    }
  }
  (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(v20 + 0xA7) + 8))(v20, 0xC8, 0, 0);
  (*(void (__fastcall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)(v20 + 0xA7) + 8))(v20, 1, 0, 0);
  sub_55618(a1, 2);
  (*(void (__fastcall **)(int))(*(_DWORD *)(v20 + 0xA7) + 8))(v20);
  for ( j = 0; j < v8; ++j )
  {
    v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v20 + 0x67) + 4 * j) + 0x41);
    sub_57310(a1, v11, *(_WORD *)(a1 + 0x4228), (int)v19);
  }
  v12 = v19;
  v17[0] = *(_DWORD *)(v20 + 4);
  v17[1] = *(_DWORD *)(v20 + 8);
  v17[2] = *(_DWORD *)(v20 + 0xC);
  v17[3] = *(_DWORD *)(v20 + 0x10);
  v17[4] = *(_DWORD *)(v20 + 0x14);
  v13 = *(__int16 *)(a1 + 0x4228);
  v14 = *(_DWORD *)(v20 + 0x41);
  sub_57310(a1, v14, v13, (int)v19);
  v15 = dword_96BB8;
  *(_DWORD *)(a1 + 0x3002) = 0xFFFFFFFF;
  if ( v15 == 0xFFFFFFFF )
  {
    sub_542B0(v17, v14, v13, v12);
  }
  sub_56BE8(a1, 0xE, 0, 0, 0xFFFFFFFF);
  sub_552CC((P_Type3)a1, 0);
  if ( dword_A0D00 == 0xFFFFFFFF )
  {
    *(_DWORD *)((char *)&loc_24D9B + a1 + 1) = v18;
  }
  result = *(_DWORD *)(a1 + 0x48A2);
  dword_96BB8 = 0xFFFFFFFF;
  return result;
}
// 96BB8: using guessed type int dword_96BB8;
// A0D00: using guessed type int dword_A0D00;

//----- (00055618) --------------------------------------------------------
unsigned int __fastcall sub_55618(unsigned int result, int a2)
{
  int v2; // ecx
  int v3; // ebx

  v2 = result;
  if ( *(_DWORD *)(result + 0x489E) )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x57E);
  }
  *(_DWORD *)(result + 0x489E) = 0xFFFFFFFF;
  v3 = dword_96774;
  *(_DWORD *)(result + 0x48A2) = 0;
  if ( v3 == 0xFFFFFFFF )
  {
    do
    {
      if ( *(_DWORD *)(v2 + 0x489E) != 0xFFFFFFFF )
      {
        break;
      }
      if ( V_Type3_stru_10AE70.bbb == 0xFFFFFFFF )
      {
        sub_59B80((int)&V_Type3_stru_10AE70);
      }
      else
      {
        sub_2656C((__int16)&unk_D85F8);
      }
      sub_5469C(&V_Type3_stru_10AE70, a2, v3, v2);
      result = sub_5508C(&V_Type3_stru_10AE70);
      if ( V_Type3_stru_10AE70.bbb )
      {
        result = sub_59A54((int)&V_Type3_stru_10AE70);
      }
    }
    while ( dword_96774 == 0xFFFFFFFF );
  }
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D85FC = 0;
  return result;
}
// 96774: using guessed type int dword_96774;
// D85FC: using guessed type int dword_D85FC;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;

//----- (000556CC) --------------------------------------------------------
int __fastcall sub_556CC(unsigned int a1, int a2)
{
  T_TypeA3 *v4; // eax
  T_TypeA3 *v5; // edx
  int v6; // ecx
  T_TypeA2 *v7; // eax
  int v8; // edx
  char *v9; // edi
  char *sub_1CEA8; // esi
  char v11; // al
  char v12; // al
  int v13; // eax

  v4 = (T_TypeA3 *)operator new(0xB3u);
  if ( v4 )
  {
    sub_2FA18(v4);
  }
  sub_2625C(v4, 2, "MSGBOX");
  v5 = v4;
  v6 = (int)v4;
  sub_2C978(&v4->a.a);
  v5->a.a.k = 0;
  *(_DWORD *)&v5->a.a.c[4] = 0x32;
  *(_DWORD *)&v5->a.a.c[0xC] = 0x12C;
  v5->c = a2;
  *(_DWORD *)v5->a.a.c = *(_DWORD *)&v5->a.a.c[4];
  *(_DWORD *)&v5->a.a.c[8] = *(_DWORD *)&v5->a.a.c[0xC];
  v5->a.a.b = *(_DWORD *)(a1 + 0x300A);
  v7 = (T_TypeA2 *)operator new(0xABu);
  if ( v7 )
  {
    sub_2C830(v7);
  }
  sub_2625C(v7, 2, "MSGBOXBUTTON");
  v8 = (int)v7;
  sub_2C978(&v7->a);
  v9 = (char *)(v8 + 0x20);
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);// 30: "OK"
  do
  {
    v11 = *sub_1CEA8;
    *v9 = *sub_1CEA8;
    if ( !v11 )
    {
      break;
    }
    v12 = sub_1CEA8[1];
    sub_1CEA8 += 2;
    v9[1] = v12;
    v9 += 2;
  }
  while ( v12 );
  *(_DWORD *)(v8 + 0xC) = 0x104;
  *(_DWORD *)(v8 + 0x14) = 0x122;
  *(_DWORD *)(v8 + 8) = *(_DWORD *)(v8 + 0xC);
  *(_DWORD *)(v8 + 0x10) = *(_DWORD *)(v8 + 0x14);
  v13 = *(_DWORD *)(a1 + 0x300A);
  *(_DWORD *)(v8 + 0x3D) = 0xFFFFFFFF;
  *(_WORD *)(v8 + 0x45) = 0xC9;
  *(_DWORD *)(v8 + 4) = v13;
  *(_DWORD *)(v8 + 0x63) = *(_DWORD *)(v6 + 0x41);
  sub_2C990(v6, v8);
  return sub_552F8(a1, v6, 0xFFFFFFFF);
}

//----- (000557D4) --------------------------------------------------------
const char *__fastcall sub_557D4(T_Type3 *eax0, char *s2, const char *a3, __int16 a4)
{
  T_TypeA2 *v5; // eax
  T_TypeA2 *v6; // ecx
  int v7; // ebp
  int v8; // ebx
  int v9; // eax
  P_Type3 v10; // eax
  T_TypeA2 *v11; // eax
  int v12; // ebx
  char *v13; // edi
  char *sub_1CEA8; // esi
  char v15; // al
  char v16; // al
  char *v17; // eax
  int v18; // eax
  T_TypeA2 *v19; // eax
  P_TypeA1 p_a; // edx
  P_TypeA1 v21; // edx
  int v22; // eax
  LONG v23; // ebx
  int v24; // ebx
  int v25; // eax
  void *v26; // eax
  PANE pane; // [esp+0h] [ebp-3Ch] BYREF
  T_TypeA2 *v29; // [esp+14h] [ebp-28h]
  int v30; // [esp+18h] [ebp-24h]
  const char *v31; // [esp+1Ch] [ebp-20h]
  LONG v32; // [esp+20h] [ebp-1Ch]
  P_Type3 a1; // [esp+24h] [ebp-18h]
  T_TypeA2 *v34; // [esp+28h] [ebp-14h]
  __int16 v35; // [esp+2Ch] [ebp-10h]

  a1 = eax0;
  v31 = a3;
  v35 = a4;
  v32 = sub_2B594((int *)&V_Type3_stru_10AE70.z1[0x3046]);
  v30 = 5 * v32 + 5;
  v5 = (T_TypeA2 *)operator new(0xABu);
  if ( v5 )
  {
    sub_2C830(v5);
  }
  sub_2625C(v5, 2, "INPUTBOX");
  v6 = v5;
  v7 = (int)v5;
  sub_2C978(&v5->a);
  strncpy(&v6->a.g, s2, 0x13u);
  v8 = v30;
  *(_DWORD *)v6->a.c = 0xF2;
  *(_DWORD *)&v6->a.c[8] = 0x18D;
  v9 = (0x1E0 - v8) / 2;
  v6->a.h[0x12] = 0;
  v6->a.s = 0xFFFF;
  *(_DWORD *)&v6->a.c[4] = v9;
  *(_DWORD *)&v6->a.c[0xC] = v8 + v9;
  v10 = a1;
  v6->a.t = 5;
  v6->a.b = *(_DWORD *)&v10->z1[0x300A];
  v11 = (T_TypeA2 *)operator new(0xABu);
  if ( v11 )
  {
    sub_2C830(v11);
  }
  sub_2625C(v11, 2, "MSGBOXBUTTON");
  v12 = (int)v11;
  v29 = v11;
  sub_2C978(&v11->a);
  v13 = (char *)(v12 + 0x20);
  sub_1CEA8 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
  do
  {
    v15 = *sub_1CEA8;
    *v13 = *sub_1CEA8;
    if ( !v15 )
    {
      break;
    }
    v16 = sub_1CEA8[1];
    sub_1CEA8 += 2;
    v13[1] = v16;
    v13 += 2;
  }
  while ( v16 );
  *(_WORD *)(v12 + 0x5B) = 0xFFFF;
  *(_WORD *)(v12 + 0x5D) = 2;
  v17 = Q_CORN_CPP_StaticTxtRead_sub_1CEA8(0x1E);
  *(_DWORD *)(v12 + 8) = *(_DWORD *)(v7 + 0x10) - sub_2B4F4(&V_Type3_stru_10AE70.z1[0x3046], v17) - 0xA;
  *(_DWORD *)(v12 + 0x10) = *(_DWORD *)(v7 + 0x10) - 3;
  *(_DWORD *)(v12 + 0xC) = *(_DWORD *)(v7 + 0x14) - v32 - 5;
  *(_DWORD *)(v12 + 0x14) = *(_DWORD *)(v7 + 0x14) - 2;
  v18 = *(_DWORD *)&a1->z1[0x300A];
  *(_DWORD *)(v12 + 0x3D) = 0xFFFFFFFF;
  *(_DWORD *)(v12 + 0x5F) = 0xFFFFFFFF;
  *(_WORD *)(v12 + 0x45) = 0xC9;
  *(_DWORD *)(v12 + 4) = v18;
  *(_DWORD *)(v12 + 0x63) = *(_DWORD *)(v7 + 0x41);
  sub_2C990(v7, v12);
  v19 = (T_TypeA2 *)operator new(0xC1u);
  if ( v19 )
  {
    v19 = sub_2F48C(v19);
  }
  sub_2625C(v19, 2, "EDITWND");
  v34 = v19;
  if ( !v19 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x5F7);
  }
  sub_2C978(&v34->a);
  p_a = &v34->a;
  *(_DWORD *)v34->a.c = *(_DWORD *)(v7 + 8) + 0xF;
  *(_DWORD *)&p_a->c[8] = *(_DWORD *)(v7 + 0x10) - 0xF;
  v21 = &v34->a;
  v22 = v32 + *(_DWORD *)(v7 + 0xC) + 8;
  v23 = v32;
  *(_DWORD *)&v34->a.c[4] = v22;
  *(_DWORD *)&v21->c[0xC] = v23 + v22 + 8;
  v21->b = *(_DWORD *)&a1->z1[0x300A];
  v24 = v35;
  v25 = *(_DWORD *)(v7 + 0x41);
  v21->m = 0;
  v21->v = v25;
  sub_2F9A4((int)v21, v31, v24);
  sub_2C990(v7, (int)v34);
  pane = *(PANE *)(v7 + 4);
  dword_96BB8 = 0;
  pane.x0 -= 8;
  pane.x1 += 8;
  pane.y0 -= 8;
  pane.y1 += 7;
  sub_54208(&pane, (int)&pane, v24, 0);
  sub_552CC(a1, (P_Type5)&pane);
  v26 = (void *)sub_1B084((unsigned int)dword_12FC20, (unsigned __int16)word_FFEEA);
  VFX_shape_draw(&pane, v26, 1, 0, 0);
  sub_552F8((unsigned int)a1, v7, 0);
  sub_542B0(&pane, (int)&pane, 0, 0);
  sub_552CC(a1, (P_Type5)&pane);
  sub_57530((int)a1, v29->a.l, 0);
  sub_57530((int)a1, v34->a.l, 0);
  sub_57530((int)a1, *(_DWORD *)(v7 + 0x41), 0);
  return v31;
}
// 96BB8: using guessed type int dword_96BB8;
// FFEEA: using guessed type __int16 word_FFEEA;
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (00055AEC) --------------------------------------------------------
unsigned int __fastcall sub_55AEC(int a1, __int16 a2, int a3, int a4)
{
  int v6; // edx

  if ( dword_A0D00 == 0xFFFFFFFF )
  {
    return 0;
  }
  v6 = *(__int16 *)(a1 + 0x475A);
  if ( v6 == 0x20 )
  {
    return 0;
  }
  *(_WORD *)(a1 + 0xA * v6 + 0x475E) = a2;
  *(_DWORD *)(a1 + 0xA * *(__int16 *)(a1 + 0x475A) + 0x4760) = a3;
  *(_DWORD *)(a1 + 0xA * (__int16)(*(_WORD *)(a1 + 0x475A))++ + 0x4764) = a4;
  return 0xFFFFFFFF;
}
// A0D00: using guessed type int dword_A0D00;

//----- (00055B74) --------------------------------------------------------
char __fastcall sub_55B74(int a1)
{
  __int16 *v1; // esi
  int v2; // eax
  int v3; // ebp
  __int16 v4; // di
  int v5; // ebp
  __int16 *v6; // ebp
  __int16 *v7; // ebp
  unsigned int v8; // ecx
  bool v9; // zf
  __int16 v10; // dx
  __int16 v11; // bx
  int v13; // [esp+8h] [ebp-20h]
  int v14; // [esp+Ch] [ebp-1Ch]

  v1 = (__int16 *)a1;
  if ( dword_10AE6C == 0xFFFFFFFF )
  {
    return a1;
  }
  a1 = *(__int16 *)(a1 + 0x475A);
  if ( !a1 )
  {
    return a1;
  }
  a1 = v1[0x2114];
  if ( a1 != 1 )
  {
    return a1;
  }
  v2 = sub_56DA8((int)v1, "EVENTWIN", 0);
  v3 = v2;
  if ( !v2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x63B);
  }
  sub_26874(v2, &v1[5 * v1[0x23AE] + 0x23AF]);
  dword_10AE6C = 0xFFFFFFFF;
  v13 = 0;
  if ( !dword_A0D00 )
  {
    v13 = sub_552F8((unsigned int)v1, v3, 0);
  }
  v4 = 0;
  dword_10AE6C = 0;
  if ( !v13 )
  {
    LOBYTE(a1) = 0;
    goto LABEL_47;
  }
  v7 = &v1[5 * v1[0x23AE]];
  v8 = v7[0x23AF];
  a1 = *((_DWORD *)v7 + 0x11D8);
  v14 = *((_DWORD *)v7 + 0x11D9);
  if ( v8 < 9 )
  {
    if ( v8 >= 3 )
    {
      goto LABEL_16;
    }
    if ( !v7[0x23AF] )
    {
      v9 = 1;
      goto LABEL_45;
    }
    if ( v8 > 1 )
    {
      v4 = 0xD;
      byte_968DD = *((_DWORD *)v7 + 0x11D8);
      goto LABEL_47;
    }
    goto LABEL_10;
  }
  if ( v8 <= 9 )
  {
    goto LABEL_16;
  }
  if ( v8 >= 0x14 )
  {
    if ( v8 > 0x14 )
    {
      if ( v8 < 0x17 )
      {
        v9 = v8 == 0x16;
      }
      else
      {
        if ( v8 <= 0x17 )
        {
          LOBYTE(a1) = *((_DWORD *)v7 + 0x11D9);
          v4 = 0xD;
          byte_968DD = a1;
          goto LABEL_47;
        }
        v9 = v8 == 0x19;
      }
LABEL_45:
      if ( v9 )
      {
        v4 = 0x14;
      }
      goto LABEL_47;
    }
LABEL_16:
    v5 = *((_DWORD *)v7 + 0x11D8);
    if ( *(_BYTE *)(a1 + 0x58) != 4 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x6A8);
    }
    LOBYTE(a1) = v14;
    v6 = *(__int16 **)(v5 + 0x59);
    if ( (v8 == 4 || v8 == 8) && v13 != 2 )
    {
      v4 = 0xD;
      if ( sub_45958((unsigned __int8 *)&byte_A2F72[0x1EE * v14], 2, v6, 0) )
      {
        byte_A315B[0x1EE * v14] = 1;
        *(int *)((char *)&dword_A315C + 0x1EE * v14) = (int)v6;
      }
      else
      {
        byte_A315B[0x1EE * v14] = 0;
      }
      LOBYTE(a1) = v14;
      byte_968DD = v14;
    }
    else
    {
      v4 = 0x10;
      dword_D3660 = (int)v6;
    }
    goto LABEL_47;
  }
  if ( v8 >= 0x10 )
  {
    if ( v8 <= 0x12 )
    {
      v4 = 0x11;
      dword_D3664 = *((_DWORD *)v7 + 0x11D9);
    }
    else if ( v13 == 1 )
    {
      v4 = 0x10;
      dword_D3660 = *((_DWORD *)v7 + 0x11D8);
    }
    else if ( v14 == 7 )
    {
      LOBYTE(a1) = sub_56B60((int)v1, 7, 0, 0);
    }
    else
    {
      *(_DWORD *)((char *)v1 + (_DWORD)&loc_24D9B + 1) = 0xFFFFFFFF;
    }
    goto LABEL_47;
  }
  if ( v8 == 0xF )
  {
LABEL_10:
    v4 = 0x11;
    dword_D3664 = *((_DWORD *)v7 + 0x11D8);
  }
LABEL_47:
  v10 = v1[0x23AE] + 1;
  v11 = v1[0x23AD];
  v1[0x23AE] = v10;
  if ( v10 == v11 )
  {
    v1[0x23AE] = 0;
    v1[0x23AD] = 0;
  }
  if ( v4 )
  {
    LOBYTE(a1) = sub_56B60((int)v1, 1, v4, 1);
  }
  return a1;
}
// 968DD: using guessed type char byte_968DD;
// A0D00: using guessed type int dword_A0D00;
// A315C: using guessed type int dword_A315C;
// D3660: using guessed type int dword_D3660;
// 10AE6C: using guessed type int dword_10AE6C;

//----- (00055E80) --------------------------------------------------------
__int16 __fastcall sub_55E80(int a1)
{
  int v1; // ebp
  char *v2; // edx
  int v3; // ecx
  int v4; // ebx
  int v5; // ecx
  __int16 i; // si
  _DWORD *v7; // ecx
  int v8; // esi
  char v9; // bl
  char *v10; // edi
  char *v11; // esi
  char v12; // al
  char v13; // al
  int v14; // esi
  char v15; // dl
  char *v16; // edi
  char *v17; // esi
  char v18; // al
  char v19; // al
  __int16 v20; // ax
  char format[600]; // [esp+0h] [ebp-53Ch] BYREF
  char v23[600]; // [esp+258h] [ebp-2E4h] BYREF
  char s[28]; // [esp+4B0h] [ebp-8Ch] BYREF
  char v25[28]; // [esp+4CCh] [ebp-70h] BYREF
  char v26[28]; // [esp+4E8h] [ebp-54h] BYREF
  int v27; // [esp+504h] [ebp-38h]
  int v28; // [esp+508h] [ebp-34h]
  int v29; // [esp+50Ch] [ebp-30h]
  int v30; // [esp+510h] [ebp-2Ch]
  int v31; // [esp+514h] [ebp-28h]
  _DWORD *v32; // [esp+518h] [ebp-24h]
  int v33; // [esp+51Ch] [ebp-20h]
  int v34; // [esp+520h] [ebp-1Ch]

  v1 = a1;
  HIWORD(v2) = 0;
  qmemcpy((void *)(a1 + 0x436C), (const void *)(a1 + 0x422C), 0x140u);
  LOWORD(a1) = *(_WORD *)(a1 + 0x44AC);
  LOWORD(v34) = 0;
  v33 = (unsigned __int16)a1;
  *(_WORD *)(v1 + 0x44AC) = 0;
  if ( (__int16)a1 > 0 )
  {
    do
    {
      a1 = 0xA * (__int16)v34;
      LOWORD(v2) = *(_WORD *)(a1 + v1 + 0x436C);
      v3 = *(_DWORD *)(a1 + v1 + 0x436E);
      v31 = *(_DWORD *)(a1 + v1 + 0x4372);
      LOWORD(a1) = (_WORD)v2;
      switch ( (__int16)v2 )
      {
        case 0:
          break;
        case 1:
          v2 = (char *)(__int16)v3;
          LOWORD(a1) = (unsigned __int16)sub_56E9C((P_Type3)v1, v3, (v31 == 0) - 1);
          break;
        case 2:
          HIWORD(v2) = 0;
          dword_96774 = 0;
          break;
        case 3:
          HIWORD(v2) = 0xFFFF;
          LOWORD(a1) = sub_570AC(v1, 0xFFFFFFFF);
          break;
        case 4:
          if ( !*(_DWORD *)(v1 + 0x48A6) && !*(_DWORD *)(v1 + 0x48AA) )
          {
            v2 = "WINEVENT.BIN";
            LOWORD(a1) = sub_59988((P_Type3)v1, "WINEVENT.BIN", 0xFFFFFFFF);
          }
          break;
        case 5:
          switch ( v31 )
          {
            case 1:
              v2 = "ABILITYWIN";
              v32 = (_DWORD *)sub_56DA8(v1, "ABILITYWIN", 0);
              LOWORD(a1) = sub_33884(v32, (int)"ABILITYWIN", 0, v3);
              break;
            case 2:
              v7 = (_DWORD *)sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = v7;
              sprintf(s, "STATE%02d", *(__int16 *)(v1 + 0x4228));
              v2 = "help.txt";
              LOWORD(a1) = sub_2FCB0(v7, "help.txt", s);
              break;
            case 3:
              v2 = "help.txt";
              v32 = (_DWORD *)sub_56DA8(v1, "HELPWINDOW", 0);
              LOWORD(a1) = sub_2FCB0(v32, "help.txt", "NOINTRO");
              break;
            case 4:
              sprintf(v25, "gizmo%02d", v3);
              v2 = "gizhelp.txt";
              v8 = sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = (_DWORD *)v8;
              sub_2FCB0((_DWORD *)v8, "gizhelp.txt", v25);
              v9 = *(_BYTE *)(v8 + 0xC95);
              v30 = v8 + 0xC95;
              v27 = v8 + 0xCB0;
              if ( v9 != 1 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x784);
              }
              if ( *(_BYTE *)v27 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x785);
              }
              v10 = format;
              v11 = *(char **)(v30 + 5);
              do
              {
                v12 = *v11;
                *v10 = *v11;
                if ( !v12 )
                {
                  break;
                }
                v13 = v11[1];
                v11 += 2;
                v10[1] = v13;
                v10 += 2;
              }
              while ( v13 );
              sprintf(*(char **)(v30 + 5), format, (char *)&unk_107020 + 0x6A * v3);
              a1 = v27;
              *(_WORD *)(v27 + 1) = 0x1C;
              *(_WORD *)(a1 + 3) = v3;
              break;
            case 5:
              sprintf(v26, "plitem%02d", v3);
              v14 = sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = (_DWORD *)v14;
              sub_2FCB0((_DWORD *)v14, "planhelp.txt", v26);
              v15 = *(_BYTE *)(v14 + 0xC95);
              v29 = v14 + 0xC95;
              v28 = v14 + 0xCB0;
              if ( v15 != 1 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x79F);
              }
              if ( *(_BYTE *)v28 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x7A0);
              }
              v16 = v23;
              v17 = *(char **)(v29 + 5);
              do
              {
                v18 = *v17;
                *v16 = *v17;
                if ( !v18 )
                {
                  break;
                }
                v19 = v17[1];
                v17 += 2;
                v16[1] = v19;
                v16 += 2;
              }
              while ( v19 );
              v2 = *(char **)(v29 + 5);
              sprintf(v2, v23, &dword_103F9A[0xA * v3 + 3]);
              if ( v3 == 0x17 )
              {
                v2 = (char *)v28;
                v20 = (unsigned __int8)byte_104BEA;
                *(_WORD *)(v28 + 3) = 0;
                LOWORD(a1) = v20 + 0xE;
                *(_WORD *)(v2 + 1) = a1;
              }
              else
              {
                a1 = v28;
                *(_WORD *)(v28 + 1) = 0x1E;
                *(_WORD *)(a1 + 3) = v3;
              }
              break;
            default:
              v2 = "HELPWINDOW";
              a1 = sub_56DA8(v1, "HELPWINDOW", 0);
              v32 = (_DWORD *)a1;
              if ( v3 )
              {
                v2 = "help.txt";
                LOWORD(a1) = sub_2FCB0((_DWORD *)a1, "help.txt", (char *)v3);
              }
              break;
          }
          if ( !*(_DWORD *)(v1 + 0x489E) )
          {
            HIWORD(v2) = HIWORD(v32);
            LOWORD(a1) = sub_552F8(v1, (int)v32, 0);
          }
          if ( v31 == 1 )
          {
            v2 = *(char **)(sub_56DA8(v1, "COSMOSWnd", 0) + 0x41);
            LOWORD(a1) = sub_56D30(v1, (int)v2, 0xD, 0, 0);
          }
          break;
        case 6:
          *(_DWORD *)(v1 + 0x489E) = 0;
          *(_DWORD *)(v1 + 0x48A2) = v3;
          break;
        case 7:
          v4 = sub_20B3C((int)dword_A2F6C);
          if ( v4 )
          {
            v5 = 7;
            if ( *(_DWORD *)((char *)&loc_24D9B + v1 + 1) == 0xFFFFFFFF )
            {
              v5 = 8;
            }
            HIWORD(v2) = 0;
            LOWORD(a1) = sub_55AEC(v1, 0x13, v4, v5);
          }
          else
          {
            sub_20C94((int)dword_A2F6C, (int)v2, 0, v3);
            if ( *(_DWORD *)((char *)&loc_24D9E + v1 + 2) == 0xFFFFFFFF )
            {
              for ( i = 0; i < SHIWORD(dword_A3CF2); ++i )
              {
                if ( i != (unsigned __int8)byte_104BEA )
                {
                  sub_46130(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], i, 0xFFFFFFFF);
                  sub_45F60(&byte_A2F72[0x1EE * (unsigned __int8)byte_104BEA], i, 0xFFFFFFFF);
                }
              }
            }
            HIWORD(v2) = 0;
            sub_56BE8(v1, 0xD, 0, 0, 0);
            LOWORD(a1) = sub_5508C((P_Type3)v1);
          }
          break;
        case 8:
          a1 = sub_20B3C((int)dword_A2F6C);
          if ( !a1 || dword_A0D00 )
          {
            *(_DWORD *)((char *)&loc_24D9B + v1 + 1) = ~*(_DWORD *)((char *)&loc_24D9B + v1 + 1);
          }
          else
          {
            HIWORD(v2) = 0;
            LOWORD(a1) = sub_55AEC(v1, 0x13, a1, (__int16)v2);
          }
          break;
        default:
          Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x7D7);
      }
      LOWORD(v34) = v34 + 1;
    }
    while ( (__int16)v34 < (__int16)v33 );
  }
  return a1;
}
// 96774: using guessed type int dword_96774;
// A0D00: using guessed type int dword_A0D00;
// A2F6C: using guessed type int dword_A2F6C[];
// A3CF2: using guessed type int dword_A3CF2;
// 103F9A: using guessed type int dword_103F9A[];

//----- (00056400) --------------------------------------------------------
void __fastcall sub_56400(T_Type3 *a1, int a2, __int16 a3, int a4, int a5, int a6)
{
  __int16 i; // kr00_2
  int v9; // eax

  if ( a1->counter1 == 0x10 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x7ED);
  }
  if ( a1->aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    a6 = 0;
  }
  for ( i = 0; i < 0x10; ++i )
  {
    if ( !a1->b1[i].a )
    {
      a1->b1[i].a = a2;
      a1->b1[i].c = a4;
      a1->b1[i].b = a3;
      a1->b1[i].d = a5;
      v9 = V_Timer_dword_132B58;
      a1->b1[i].e = a6;
      a1->b1[i].f = a6 + v9;
      ++a1->counter1;
      break;
    }
  }
  sub_59C80(a1, a2, 4, a3, a4, a5, 0);
}
// 132B58: using guessed type int V_Timer_dword_132B58;

//----- (000564C0) --------------------------------------------------------
void __fastcall sub_564C0(T_Type3 *a1, int a2, __int16 a3)
{
  __int16 i; // dx
  char *v6; // ebx

  for ( i = 0; i < 0x10; ++i )
  {
    v6 = &a1->z1[0x16 * i];
    if ( a2 == *(_DWORD *)(v6 + 0x44AE) && (a3 == 0xFFFFFFFF || a3 == *((_WORD *)v6 + 0x2259)) )
    {
      a1->b1[i].a = 0;
      --a1->counter1;
    }
  }
  sub_59C80(a1, a2, 5, a3, 0, 0, 0);
}

//----- (00056528) --------------------------------------------------------
int __fastcall sub_56528(int a1, int a2, __int16 a3)
{
  __int16 i; // ax
  int v6; // edx

  for ( i = 0; i < 0x10; ++i )
  {
    v6 = a1 + 0x16 * i;
    if ( a2 == *(_DWORD *)(v6 + 0x44AE) && a3 == *(_WORD *)(v6 + 0x44B2) )
    {
      return *(_DWORD *)(v6 + 0x44BC);
    }
  }
  return 0xFFFF;
}

//----- (00056564) --------------------------------------------------------
unsigned int __fastcall sub_56564(int a1, int a2, __int16 a3, int a4)
{
  __int16 i; // dx
  int v7; // eax

  for ( i = 0; i < 0x10; ++i )
  {
    v7 = a1 + 0x16 * i;
    if ( a2 == *(_DWORD *)(v7 + 0x44AE) && a3 == *(_WORD *)(v7 + 0x44B2) )
    {
      *(_DWORD *)(v7 + 0x44BC) = a4;
      return 0xFFFFFFFF;
    }
  }
  return 0;
}

//----- (00056694) --------------------------------------------------------
int __fastcall sub_56694(int a1)
{
  int v2; // eax
  __int16 v3; // di
  int result; // eax
  int v5; // esi
  void (__fastcall *v6)(_DWORD, _DWORD); // edx
  int v7; // [esp+4h] [ebp-20h]
  __int16 v8; // [esp+8h] [ebp-1Ch]

  v2 = a1 + 0x44AE;
  v3 = *(_WORD *)(v2 + 0x160);
  v8 = 0;
  v7 = v2;
  while ( 1 )
  {
    result = v8;
    if ( v8 >= 0x10 || v3 <= 0 )
    {
      break;
    }
    v5 = 0x16 * v8 + v7;
    v6 = *(void (__fastcall **)(_DWORD, _DWORD))v5;
    if ( *(_DWORD *)v5 )
    {
      if ( (unsigned int)V_Timer_dword_132B58 >= *(_DWORD *)(v5 + 0x12) )
      {
        if ( *(_WORD *)(v5 + 4) == 0x29A )
        {
          v6(*(_DWORD *)(v5 + 6), *(_DWORD *)(v5 + 0xA));
        }
        else
        {
          sub_56D30(a1, (int)v6, *(__int16 *)(v5 + 4), *(_DWORD *)(v5 + 6), *(_DWORD *)(v5 + 0xA));
        }
        *(_DWORD *)(v5 + 0x12) += *(_DWORD *)(v5 + 0xE);
      }
      --v3;
    }
    ++v8;
  }
  return result;
}
// 132B58: using guessed type int V_Timer_dword_132B58;

//----- (00056728) --------------------------------------------------------
void __fastcall sub_56728(int a1, int a2, int a3, __int16 a4, int a5, int a6)
{
  __int16 i; // kr00_2

  if ( *(_WORD *)(a1 + 0x4730) == 0x10 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x8C6);
  }
  for ( i = 0; i < 0x10; ++i )
  {
    if ( !*(_DWORD *)(a1 + 0x12 * i + 0x4610) )
    {
      *(_DWORD *)(a1 + 0x12 * i + 0x4610) = a2;
      *(_DWORD *)(a1 + 0x12 * i + 0x4614) = a3;
      *(_WORD *)(a1 + 0x12 * i + 0x4618) = a4;
      *(_DWORD *)(a1 + 0x12 * i + 0x461A) = a5;
      *(_DWORD *)(a1 + 0x12 * i + 0x461E) = a6;
      ++*(_WORD *)(a1 + 0x4730);
      break;
    }
  }
  sub_59C80((T_Type3 *)a1, a2, 6, a4, a5, a6, a3);
}

//----- (000567BC) --------------------------------------------------------
void __fastcall sub_567BC(int a1, int a2, __int16 a3)
{
  __int16 i; // dx
  int v6; // ebx

  for ( i = 0; i < 0x10; ++i )
  {
    v6 = a1 + 0x12 * i;
    if ( a2 == *(_DWORD *)(v6 + 0x4610) && (a3 == 0xFFFFFFFF || a3 == *(_WORD *)(v6 + 0x4618)) )
    {
      *(_DWORD *)(0x12 * i + a1 + 0x4610) = 0;
      --*(_WORD *)(a1 + 0x4730);
    }
  }
  sub_59C80((T_Type3 *)a1, a2, 7, a3, 0, 0, 0);
}

//----- (00056824) --------------------------------------------------------
void __fastcall sub_56824(int a1)
{
  int v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // [esp+0h] [ebp-28h]
  int v6; // [esp+4h] [ebp-24h]
  __int16 i; // [esp+8h] [ebp-20h]
  __int16 v8; // [esp+Ch] [ebp-1Ch]

  v8 = *(_WORD *)(a1 + 0x4730);
  v6 = 0;
  v5 = 0;
  if ( dword_D8638 == 0xFFFFFFFF )
  {
    v6 = 1;
  }
  if ( dword_D863C == 0xFFFFFFFF )
  {
    LOBYTE(v6) = v6 | 2;
  }
  if ( dword_D8644 == 0xFFFFFFFF )
  {
    LOBYTE(v5) = 4;
  }
  for ( i = 0; i < 0x10 && v8 > 0; ++i )
  {
    v2 = a1 + 0x12 * i;
    v3 = *(_DWORD *)(v2 + 0x4610);
    if ( v3 )
    {
      if ( (v6 & *(_DWORD *)(v2 + 0x4614)) != 0 )
      {
        sub_56D30(
          a1,
          *(_DWORD *)(v2 + 0x4610),
          *(__int16 *)(v2 + 0x4618),
          *(_DWORD *)(v2 + 0x461A),
          *(_DWORD *)(v2 + 0x461E));
      }
      v4 = a1 + 0x12 * i;
      if ( (v5 & *(_DWORD *)(v4 + 0x4614)) != 0 )
      {
        sub_56D30(a1, v3, *(__int16 *)(v4 + 0x4618), new_x, dword_D864C);
      }
      --v8;
    }
  }
  JUMPOUT(0x55E3D);
}
// 5688A: control flows out of bounds to 55E3D
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;

//----- (0005691C) --------------------------------------------------------
int __fastcall sub_5691C(int result)
{
  int v1; // esi
  LONG v2; // edi
  int v3; // edx
  LONG v4; // ebp
  int v5; // ecx
  __int16 v6; // dx
  LONG v7; // ebx
  int v8; // edx
  __int16 v9; // cx
  int v10; // eax
  _DWORD *v11; // edx
  unsigned int v12; // [esp+4h] [ebp-28h]
  int v13; // [esp+8h] [ebp-24h]
  int v14; // [esp+Ch] [ebp-20h]
  __int16 v15; // [esp+10h] [ebp-1Ch]

  v1 = result;
  v2 = new_x;
  v3 = *(_DWORD *)(result + 0x3002);
  v4 = dword_D864C;
  if ( v3 == 0xFFFFFFFF )
  {
    goto LABEL_17;
  }
  v5 = *(_DWORD *)(result + 0xC * v3 + 4);
  if ( new_x > *(_DWORD *)(v5 + 0x10)
    || new_x < *(_DWORD *)(v5 + 8)
    || dword_D864C > *(_DWORD *)(v5 + 0x14)
    || dword_D864C < *(_DWORD *)(v5 + 0xC) )
  {
    sub_56D30(result, *(_DWORD *)(result + 0x3002), 8, new_x, dword_D864C);
    result = sub_56D30(v1, *(_DWORD *)(v1 + 0x3002), 6, 0, 0);
    *(_DWORD *)(v1 + 0x3002) = 0xFFFFFFFF;
LABEL_17:
    v8 = *(__int16 *)(v1 + 0x4228);
    if ( v8 >= 0 )
    {
      v9 = 0x1F;
      v12 = 0;
      v15 = *(_WORD *)(v1 + 0x8E * v8 + 0x3068);
      while ( 1 )
      {
        result = v15;
        if ( v15 <= 0 || v12 )
        {
          break;
        }
        if ( v9 < 0 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x992);
        }
        v10 = *(_DWORD *)(v1 + 0x8E * *(__int16 *)(v1 + 0x4228) + 4 * v9 + 0x306A);
        v13 = v10;
        if ( v10 )
        {
          v11 = *(_DWORD **)(v1 + 0xC * v10 + 4);
          if ( *(_DWORD *)((char *)v11 + 0xA3) == 0xFFFFFFFF
            && v2 <= v11[4]
            && v2 >= v11[2]
            && v4 <= v11[5]
            && v4 >= v11[3]
            && *(_DWORD *)((char *)v11 + 0x35) == 0xFFFFFFFF )
          {
            v12 = 0xFFFFFFFF;
          }
          --v15;
        }
        --v9;
      }
      if ( v12 == 0xFFFFFFFF )
      {
        *(_DWORD *)(v1 + 0x3002) = v13;
        return sub_56D30(v1, v13, 7, 0, 0);
      }
    }
    return result;
  }
  result = *(__int16 *)(v5 + 0x6B);
  if ( *(_WORD *)(v5 + 0x6B) )
  {
    v6 = 0;
    if ( *(__int16 *)(v5 + 0x6B) > 0 )
    {
      while ( 1 )
      {
        result = *(_DWORD *)(*(_DWORD *)(v5 + 0x67) + 4 * v6);
        v14 = result;
        if ( *(_DWORD *)(result + 0x35) )
        {
          v7 = *(_DWORD *)(result + 0x10);
          result += 4;
          if ( new_x <= v7
            && new_x >= *(_DWORD *)(result + 4)
            && dword_D864C <= *(_DWORD *)(result + 0x10)
            && dword_D864C >= *(_DWORD *)(result + 8) )
          {
            break;
          }
        }
        if ( ++v6 >= *(__int16 *)(v5 + 0x6B) )
        {
          return result;
        }
      }
      sub_56D30(v1, *(_DWORD *)(v1 + 0x3002), 8, new_x, dword_D864C);
      sub_56D30(v1, *(_DWORD *)(v1 + 0x3002), 6, 0, 0);
      sub_56D30(v1, *(_DWORD *)(v14 + 0x41), 7, 0, 0);
      result = *(_DWORD *)(v14 + 0x41);
      *(_DWORD *)(v1 + 0x3002) = result;
    }
  }
  return result;
}
// 56B46: variable 'v13' is possibly undefined

//----- (00056B60) --------------------------------------------------------
int __fastcall sub_56B60(int a1, __int16 a2, int a3, int a4)
{
  int v5; // edx
  int result; // eax

  if ( *(_WORD *)(a1 + 0x44AC) == 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x9B5);
  }
  *(_WORD *)(a1 + 0xA * *(__int16 *)(a1 + 0x44AC) + 0x422C) = a2;
  *(_DWORD *)(a1 + 0xA * *(__int16 *)(a1 + 0x44AC) + 0x422E) = a3;
  v5 = *(__int16 *)(a1 + 0x44AC);
  result = 5 * v5;
  *(_DWORD *)(a1 + 0xA * v5 + 0x4232) = a4;
  ++*(_WORD *)(a1 + 0x44AC);
  return result;
}

//----- (00056BE8) --------------------------------------------------------
int __fastcall sub_56BE8(int result, __int16 a2, int a3, int a4, int a5)
{
  int v5; // edi
  int v6; // edx
  __int16 v7; // si
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  unsigned int v11; // edx
  __int16 v13; // [esp+Ch] [ebp-10h]

  v5 = result;
  v6 = *(__int16 *)(result + 0x4228);
  if ( v6 >= 0 )
  {
    v7 = 0x1F;
    v8 = 0;
    v13 = *(_WORD *)(result + 0x8E * v6 + 0x3068);
    while ( 1 )
    {
      result = v13;
      if ( v13 <= 0 || v8 )
      {
        break;
      }
      v8 = 0;
      if ( v7 < 0 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x9EA);
      }
      v9 = *(_DWORD *)(v5 + 0x8E * *(__int16 *)(v5 + 0x4228) + 4 * v7 + 0x306A);
      if ( v9 )
      {
        v10 = *(_DWORD *)(v5 + 0xC * v9 + 4);
        if ( !a5 || byte_132B38[v7] )
        {
          if ( (*(_DWORD *)(v10 + 0x35) || a2 == 1 || a2 == 0xE) && (!*(_DWORD *)(v10 + 0x63) || a2 > 2) )
          {
            v11 = 0xFFFFFFFF;
          }
          else
          {
            v11 = 0;
          }
          if ( v11 )
          {
            if ( a5 )
            {
              byte_132B38[v7] = 1;
            }
            v8 = (*(int (**)(void))(*(_DWORD *)(v10 + 0xA7) + 8))();
          }
          else if ( a5 )
          {
            byte_132B38[v7] = 0;
          }
        }
        --v13;
      }
      --v7;
    }
  }
  return result;
}

//----- (00056D30) --------------------------------------------------------
int __fastcall sub_56D30(int a1, int a2, int a3, int a4, int a5)
{
  if ( *(__int16 *)(a1 + 0x4228) >= 0 )
  {
    return (*(int (**)(void))(*(_DWORD *)(*(_DWORD *)(a1 + 0xC * a2 + 4) + 0xA7) + 8))();
  }
  else
  {
    return 0;
  }
}

//----- (00056D70) --------------------------------------------------------
int __fastcall sub_56D70(int a1, char *a2, __int16 a3, int a4, int a5)
{
  int result; // eax
  int v7; // [esp+0h] [ebp-Eh] BYREF

  result = sub_56DA8(a1, a2, (_WORD *)&v7 + 1);
  if ( result )
  {
    sub_56D30(a1, SHIWORD(v7), a3, a4, a5);
    return 0xFFFFFFFF;
  }
  return result;
}

//----- (00056DA8) --------------------------------------------------------
int __fastcall sub_56DA8(int a1, char *s1, _WORD *a3)
{
  __int16 v5; // si
  __int16 i; // cx
  int v7; // edx

  v5 = 0;
  for ( i = 0; ; ++i )
  {
    if ( i >= 0x400 || v5 > *(__int16 *)(a1 + 0x3000) )
    {
      return 0;
    }
    v7 = *(_DWORD *)(a1 + 0xC * i + 4);
    if ( v7 )
    {
      ++v5;
      if ( !strncmp(s1, (const char *)(v7 + 0x20), 0xAu) )
      {
        break;
      }
    }
  }
  if ( a3 )
  {
    *a3 = i;
  }
  return *(_DWORD *)(a1 + 0xC * i + 4);
}

//----- (00056E18) --------------------------------------------------------
int __fastcall sub_56E18(int a1, char *s1, __int16 a3, _WORD *a4)
{
  __int16 i; // cx
  int v7; // eax
  int v8; // edi
  int v9; // edx

  if ( a3 < *(__int16 *)(a1 + 0x4226) )
  {
    for ( i = 0; ; ++i )
    {
      v7 = a1 + 0x8E * a3;
      if ( i >= *(__int16 *)(v7 + 0x3068) )
      {
        break;
      }
      v8 = *(_DWORD *)(v7 + 4 * i + 0x306A);
      v9 = *(_DWORD *)(a1 + 0xC * v8 + 4);
      if ( v9 && !strncmp(s1, (const char *)(v9 + 0x20), 0xAu) )
      {
        if ( a4 )
        {
          *a4 = v8;
        }
        return *(_DWORD *)(a1 + 0xC * v8 + 4);
      }
    }
  }
  return 0;
}

//----- (00056E9C) --------------------------------------------------------
P_Type3 __fastcall sub_56E9C(P_Type3 a1, __int16 a2, int a3)
{
  P_Type3 v3; // esi
  int v5; // ebx
  int v6; // edx
  int v7; // edx
  int v8; // ebx
  int v9; // eax
  __int16 v10; // ax
  int v11; // eax
  int v12; // eax

  v3 = a1;
  if ( a2 != *(_WORD *)&a1->z1[0x4228] )
  {
    if ( a2 < 0 || a2 >= 0x20 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xA9B);
    }
    v5 = *(__int16 *)&a1->z1[0x4228];
    if ( v5 >= 0 )
    {
      v6 = *(__int16 *)&a1->z1[0x8E * v5 + 0x3066];
      if ( v6 != 0xFFFFFFFF )
      {
        sub_4F45C((int)&unk_10914C, v6);
      }
    }
    v7 = *(__int16 *)&v3->z1[0x8E * a2 + 0x3066];
    if ( v7 != 0xFFFFFFFF )
    {
      sub_4F32C((int)&unk_10914C, v7, 0);
    }
    v8 = *(__int16 *)&v3->z1[0x4228];
    if ( v8 >= 0 && *(_DWORD *)&v3->z1[0x8E * v8 + 0x30F0] )
    {
      (*(void (__fastcall **)(_DWORD, char *))&v3->z1[0x8E * v8 + 0x30F0])(
        *(__int16 *)&v3->z1[0x4228],
        &v3->z1[0x8E * v8 + 0x3066]);
    }
    v9 = *(_DWORD *)&v3->z1[0x3002];
    if ( v9 != 0xFFFFFFFF )
    {
      sub_56D30((int)v3, v9, 6, 0, 0);
    }
    sub_56BE8((int)v3, 2, 0, 0, 0);
    if ( a3 == 0xFFFFFFFF && *(__int16 *)&v3->z1[0x4228] >= 0 )
    {
      v10 = *(_WORD *)&v3->z2[0x148];
      *(_WORD *)&v3->z2[0x148] = v10 + 1;
      *(_WORD *)&v3->z2[2 * v10 + 0x126] = *(_WORD *)&v3->z1[0x4228];
      if ( *(_WORD *)&v3->z2[0x148] == 0x10 )
      {
        *(_WORD *)&v3->z2[0x148] = 0;
      }
      ++*(_WORD *)&v3->z2[0x146];
    }
    *(_WORD *)&v3->z1[0x4228] = a2;
    if ( !*(_WORD *)&v3->z1[0x4228] && dword_96BC0 == 0xFFFFFFFF && !access("resume.gam", 0) )
    {
      sub_53FB0("resume.gam", 0, 0, 0);
    }
    v11 = *(_DWORD *)&v3->z1[0x3006];
    dword_96BC0 = 0;
    sub_5B71C(v11);
    sub_55214((int)v3, 0, 0, 0x27F, 0x1DF);
    v12 = 0x8E * a2;
    if ( *(_DWORD *)&v3->z1[v12 + 0x30EC] )
    {
      (*(void (__fastcall **)(_DWORD, char *))&v3->z1[v12 + 0x30EC])(a2, &v3->z1[v12 + 0x3066]);
    }
    sub_56BE8((int)v3, 1, 0, 0, 0);
    *(_DWORD *)&v3->z1[0x3002] = 0xFFFFFFFF;
    return (P_Type3)sub_5691C((int)v3);
  }
  return a1;
}
// 96BC0: using guessed type int dword_96BC0;

//----- (000570AC) --------------------------------------------------------
int __fastcall sub_570AC(int a1, int a2)
{
  __int16 v4; // dx
  int v5; // ecx

  if ( !*(_WORD *)(a1 + 0x4756) )
  {
    return 0;
  }
  if ( *(_WORD *)(a1 + 0x4758) )
  {
    v4 = *(_WORD *)(a1 + 0x4758) - 1;
  }
  else
  {
    v4 = 0xF;
  }
  v5 = v4;
  LOWORD(v5) = *(_WORD *)(a1 + 2 * v4 + 0x4736);
  if ( a2 == 0xFFFFFFFF )
  {
    *(_WORD *)(a1 + 0x4758) = v4;
    *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 0x4758) + 0x4736) = 0xFFFF;
    --*(_WORD *)(a1 + 0x4756);
    sub_56E9C((P_Type3)a1, v5, 0);
  }
  return v5;
}

//----- (000571B8) --------------------------------------------------------
int __fastcall sub_571B8(P_Type3 a1, P_TypeA1 a2)
{
  __int16 i; // dx
  int result; // eax
  char *v6; // ebx

  if ( !a2 || *(_WORD *)&a1->z1[0x3000] == 1023 )
  {
    return 0;
  }
  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= 0x400 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB37);
    }
    v6 = &a1->z1[0xC * i];
    if ( !*(_DWORD *)v6 )
    {
      break;
    }
  }
  *(_DWORD *)v6 = 1;
  *((_DWORD *)v6 + 1) = a2;
  ++*(_WORD *)&a1->z1[0x3000];
  *(_DWORD *)a2->a = 0x12345678;
  return result;
}

//----- (00057220) --------------------------------------------------------
unsigned int __fastcall sub_57220(int a1, int a2, __int16 a3)
{
  int v6; // edx
  __int16 v8; // ax
  int v9; // ebx
  int v10; // edx

  if ( a3 < 0 || a3 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB42);
  }
  if ( a2 >= 0x400 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB43);
  }
  if ( !a2 )
  {
    return 0;
  }
  v6 = a1 + 0x8E * a3;
  if ( *(_WORD *)(v6 + 0x3068) == 0x20 )
  {
    return 0;
  }
  v8 = 0;
  if ( *(_WORD *)(v6 + 0x3068) )
  {
    while ( v8 < 0x20 )
    {
      v9 = a1 + 0x8E * a3;
      v10 = v9 + 4 * v8;
      if ( !*(_DWORD *)(v10 + 0x306A) )
      {
        *(_DWORD *)(v10 + 0x306A) = a2;
        ++*(_WORD *)(v9 + 0x3068);
        break;
      }
      ++v8;
    }
  }
  else
  {
    ++*(_WORD *)(a1 + 0x4226);
    *(_WORD *)(v6 + 0x3068) = 1;
    *(_DWORD *)(v6 + 0x306A) = a2;
  }
  ++*(_DWORD *)(0xC * a2 + a1);
  if ( v8 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB65);
  }
  return 0xFFFFFFFF;
}

//----- (00057310) --------------------------------------------------------
unsigned int __fastcall sub_57310(int a1, int a2, __int16 a3, int a4)
{
  __int16 i; // cx
  int v9; // edx
  int v10; // eax
  int v11; // ebx

  if ( a3 < 0 || a3 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB75);
  }
  if ( a2 >= 0x400 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xB76);
  }
  if ( !a2 || !*(_WORD *)(a1 + 0x8E * a3 + 0x3068) )
  {
    return 0;
  }
  for ( i = 0; i < 0x20; ++i )
  {
    v9 = a1 + 0x8E * a3;
    v10 = v9 + 4 * i;
    v11 = *(_DWORD *)(v10 + 0x306A);
    if ( a2 == v11 )
    {
      *(_DWORD *)(v10 + 0x306A) = 0;
      --*(_WORD *)(v9 + 0x3068);
      --*(_DWORD *)(a1 + 0xC * v11);
      if ( a4 )
      {
        sub_57530(a1, a2, 0);
      }
      break;
    }
  }
  if ( i < 0x20 )
  {
    return 0xFFFFFFFF;
  }
  else
  {
    return 0;
  }
}

//----- (0005748C) --------------------------------------------------------
unsigned int __fastcall sub_5748C(int a1, __int16 a2, __int16 a3)
{
  int v3; // esi
  unsigned int result; // eax

  if ( a2 < 0 || a2 >= 0x20 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xBA8);
  }
  v3 = 0x8E * a2 + a1;
  if ( *(unsigned __int16 *)(v3 + 0x30EA) != 0xFFFF )
  {
    return 0;
  }
  result = 0xFFFFFFFF;
  *(_WORD *)(v3 + 0x30EA) = a3;
  return result;
}

//----- (000574F0) --------------------------------------------------------
int __fastcall sub_574F0(P_Type3 a1, __int16 a2, int a3)
{
  int result; // eax

  result = 0x47 * a2;
  *(_DWORD *)&a1->z1[0x8E * a2 + 0x30EC] = a3;
  return result;
}

//----- (00057510) --------------------------------------------------------
int __fastcall sub_57510(int a1, __int16 a2, int a3)
{
  int result; // eax

  result = 0x47 * a2;
  *(_DWORD *)(a1 + 0x8E * a2 + 0x30F0) = a3;
  return result;
}

//----- (00057530) --------------------------------------------------------
int __fastcall sub_57530(int result, int a2, int a3)
{
  int v3; // esi
  int v5; // edx
  int v6; // edx
  int v7; // eax

  v3 = result;
  if ( a2 >= 0x400 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xBDB);
  }
  if ( a2 )
  {
    result = 3 * a2;
    v5 = *(_DWORD *)(v3 + 0xC * a2) - 1;
    *(_DWORD *)(v3 + 0xC * a2) = v5;
    if ( !v5 || a3 )
    {
      v6 = v3 + 0xC * a2;
      sub_2627C(*(void **)(v6 + 4));
      v7 = *(_DWORD *)(v6 + 4);
      if ( v7 )
      {
        (**(void (***)(void))(v7 + 0xA7))();
      }
      result = 3 * a2;
      *(_DWORD *)(v3 + 4 * result + 4) = 0;
      *(_DWORD *)(v3 + 4 * result) = 0;
      --*(_WORD *)(v3 + 0x3000);
    }
  }
  return result;
}

//----- (000575BC) --------------------------------------------------------
FILE *__fastcall sub_575BC(P_Type3 a1)
{
  void *v2; // eax
  _BYTE *v3; // ecx
  _BYTE *v4; // edx
  int i; // eax
  void *v6; // eax
  void *v7; // ecx
  _BYTE *v8; // edx
  int j; // eax

  v2 = operator new[](0x100u);
  sub_2625C(v2, 1, "WMGR MAPFOCUS");
  v3 = v2;
  if ( !v2 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xBF7);
  }
  v4 = v2;
  for ( i = 0; i < 0x100; ++i )
  {
    *v4++ = i;
  }
  v3[0xF2] = 0x96;
  *(_DWORD *)&a1->z1[0x3012] = v3;
  v6 = operator new[](0x100u);
  sub_2625C(v6, 1, "WMGR MAPRACES");
  v7 = v6;
  if ( !v6 )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xC01);
  }
  v8 = v6;
  for ( j = 0; j < 0x100; ++j )
  {
    *v8++ = j;
  }
  *(_DWORD *)&a1->z1[0x3022] = v7;
  *(_DWORD *)&a1->z1[0x3006] = sub_5B617(0x80u);
  return Q_WINMGR_CPP_sub_57670(a1, "windows.txt");
}

//----- (00057670) --------------------------------------------------------
FILE *__fastcall Q_WINMGR_CPP_sub_57670(P_Type3 a1, const char *a2)
{
  FILE *result; // eax
  FILE *v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  _DWORD *v8; // eax
  char *v9; // ebx
  void *v10; // eax
  int v11; // edx
  char *v12; // ecx
  int v13; // edx
  _BYTE *v14; // ebp
  int v15; // ecx
  P_TypeA1 v16; // edx
  __int16 kk; // cx
  P_TypeA1 v18; // edx
  __int16 v19; // ax
  P_TypeA1 v20; // edx
  P_TypeA1 v21; // edx
  int y; // ecx
  _BYTE *v23; // ebp
  int v24; // ebx
  T_TypeA9 *v25; // eax
  int v26; // ebp
  _BYTE *p_g; // edx
  int v28; // eax
  int i; // ecx
  unsigned int v30; // ebx
  int j; // ecx
  int v32; // eax
  __int16 v33; // dx
  int v34; // eax
  __int16 v35; // bx
  char v36; // dh
  T_TypeA1 *v37; // eax
  int v38; // ebp
  _BYTE *v39; // edx
  int v40; // eax
  __int16 k; // cx
  __int16 v42; // ax
  T_TypeA2 *v43; // eax
  int v44; // ebp
  _BYTE *v45; // edx
  int v46; // eax
  int n; // ecx
  int v48; // eax
  __int16 ii; // cx
  __int16 v50; // ax
  T_TypeA2 *v51; // eax
  int v52; // ebp
  _BYTE *v53; // edx
  int v54; // eax
  int jj; // ecx
  __int16 v56; // ax
  signed __int16 v57; // cx
  unsigned __int16 v58; // bx
  T_TypeA2 *v59; // eax
  T_TypeA2 *v60; // ecx
  int v61; // eax
  T_TypeA1 *v62; // eax
  int v63; // ebp
  _BYTE *v64; // edx
  int v65; // eax
  T_TypeA1 *v66; // eax
  _BYTE *v67; // edx
  int v68; // ebp
  int v69; // eax
  int v70; // [esp-Ch] [ebp-3DCh]
  int v71; // [esp-Ch] [ebp-3DCh]
  int v72; // [esp-4h] [ebp-3D4h]
  int v73; // [esp-4h] [ebp-3D4h]
  char v74[128]; // [esp+0h] [ebp-3D0h] BYREF
  char v75[128]; // [esp+80h] [ebp-350h] BYREF
  char v76[128]; // [esp+100h] [ebp-2D0h] BYREF
  char v77[128]; // [esp+180h] [ebp-250h] BYREF
  char v78[128]; // [esp+200h] [ebp-1D0h] BYREF
  char v79[128]; // [esp+280h] [ebp-150h] BYREF
  char v80[52]; // [esp+300h] [ebp-D0h] BYREF
  char s1[52]; // [esp+334h] [ebp-9Ch] BYREF
  __int16 v82[8]; // [esp+368h] [ebp-68h] BYREF
  unsigned int v83; // [esp+378h] [ebp-58h] BYREF
  P_TypeA1 v84; // [esp+37Ch] [ebp-54h]
  int v85; // [esp+380h] [ebp-50h]
  int v86; // [esp+384h] [ebp-4Ch]
  int v87; // [esp+388h] [ebp-48h]
  void **v88; // [esp+38Ch] [ebp-44h]
  void **v89; // [esp+390h] [ebp-40h]
  _BYTE *v90; // [esp+394h] [ebp-3Ch]
  _BYTE *v91; // [esp+398h] [ebp-38h]
  int m; // [esp+39Ch] [ebp-34h]
  int v93; // [esp+3A0h] [ebp-30h] BYREF
  char v94; // [esp+3A4h] [ebp-2Ch] BYREF
  __int16 v95; // [esp+3A8h] [ebp-28h]
  unsigned int v96; // [esp+3ACh] [ebp-24h]
  int v97; // [esp+3B0h] [ebp-20h]
  int v98; // [esp+3B4h] [ebp-1Ch] BYREF
  int v99; // [esp+3B8h] [ebp-18h]

  result = sub_1BB10(a2, 0);
  v4 = result;
  if ( result )
  {
    fscanf(result, "%s %d", s1, &v83);
    v5 = Q_CheckFreeMemory_sub_53DEC();
    v6 = v5;
    if ( v5 <= (int)v83 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xC27);
    }
    v7 = v5 - 200000;
    v8 = sub_1AD1C((int)&a1[1].z1[8], v5 - 200000);
    sub_2D2CC((int)v8, v7, (int)&a1[1].z1[8], v6);
    v86 = (int)&a1[1].z1[8];
    v89 = (void **)&a1->z1[0x3046];
    v87 = (int)&a1[1].z1[8];
    v88 = (void **)&a1->z1[0x3026];
    while ( 1 )
    {
      fscanf(v4, "%s %d", s1, &v83);
      if ( v83 == 0xFFFFFFFF )
      {
        return (FILE *)fclose(v4);
      }
      v95 = v83;
      if ( v83 < 9 )
      {
        if ( v83 < 3 )
        {
          if ( !v83 )
          {
            goto LABEL_16;
          }
          if ( v83 <= 1 )
          {
            v25 = (T_TypeA9 *)operator new(0xA09u);
            if ( v25 )
            {
              sub_2AE80(v25);
            }
            sub_2625C(v25, 2, "FLIC");
            v26 = (int)v25;
            p_g = &v25->a.a.g;
            sub_2C978(&v25->a.a);
            fscanf(v4, "%s %s", s1, p_g);
            fscanf(v4, "%s", s1);
            fscanf(v4, "%s", s1);
            if ( strcmp(s1, "NONE") )
            {
              v28 = sub_56DA8((int)a1, s1, 0);
              if ( !v28 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xCF8);
              }
              *(_DWORD *)(v26 + 0x63) = *(_DWORD *)(v28 + 0x41);
              sub_2C990(v28, v26);
            }
            fscanf(v4, "%s %d", s1, &v93);
            for ( i = 0; (__int16)i < (__int16)v93; ++i )
            {
              fscanf(v4, "%d", &v83);
              if ( !sub_57220((int)a1, *(_DWORD *)(v26 + 0x41), v83) )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xD02);
              }
            }
            fscanf(v4, "%s %d", s1, v26 + 8);
            fscanf(v4, "%s %d", s1, v26 + 0xC);
            fscanf(v4, "%s %d", s1, v26 + 0x10);
            fscanf(v4, "%s %d", s1, v26 + 0x14);
            fscanf(v4, "%s %s", s1, v79);
            sub_2AF04(v26, v79);
            fscanf(v4, "%s %d", s1, &v83);
            *(_WORD *)(v26 + 0xA01) = v83;
            fscanf(v4, "%s %d", s1, &v83);
            *(_WORD *)(v26 + 0xA03) = v83;
            fscanf(v4, "%s %d", s1, &v83);
            *(_WORD *)(v26 + 0xA05) = v83;
            fscanf(v4, "%s %d", s1, &v83);
            *(_WORD *)(v26 + 0xA07) = v83;
            fscanf(v4, "%s %d", s1, &v83);
            v30 = v83;
            if ( v83 != 0xFFFFFFFF )
            {
              *(_DWORD *)(v26 + 0x9E5) = 0xFFFFFFFF;
              *(_DWORD *)(v26 + 0x9E9) = v30;
            }
            fscanf(v4, "%s %d", s1, v26 + 0x45);
            fscanf(v4, "%s %d", s1, v26 + 0x47);
            fscanf(v4, "%s %d", s1, v26 + 0x4B);
            fscanf(v4, "%s %s", s1, v26 + 0x4F);
            fscanf(v4, "%s %d", s1, &v83);
            *(_WORD *)(v26 + 0x9F5) = v83;
            fscanf(v4, "%s %d", s1, &v83);
            if ( v83 )
            {
              *(_DWORD *)(v26 + 0x9F1) = 0xFFFFFFFF;
            }
            *(_DWORD *)(v26 + 4) = *(_DWORD *)&a1->z1[0x300A];
          }
          else
          {
            v66 = (T_TypeA1 *)operator new(0x596u);
            if ( v66 )
            {
              v66 = (T_TypeA1 *)sub_224A4((int)v66);
            }
            sub_2625C(v66, 2, "COSW");
            v67 = &v66->g;
            v68 = (int)v66;
            sub_2C978(v66);
            dword_96BAC = *(_DWORD *)(v67 + 0x21);
            fscanf(v4, "%s %s", s1, v67);
            fscanf(v4, "%s", s1);
            fscanf(v4, "%s", s1);
            if ( strcmp(s1, "NONE") )
            {
              v69 = sub_56DA8((int)a1, s1, 0);
              if ( !v69 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD41);
              }
              *(_DWORD *)(v68 + 0x63) = *(_DWORD *)(v69 + 0x41);
              sub_2C990(v69, v68);
            }
            fscanf(v4, "%s %d", s1, &v93);
            for ( j = 0; (__int16)j < (__int16)v93; ++j )
            {
              fscanf(v4, "%d", &v83);
              if ( !sub_57220((int)a1, *(_DWORD *)(v68 + 0x41), v83) )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xD4B);
              }
            }
            fscanf(v4, "%s %d", s1, v68 + 8);
            fscanf(v4, "%s %d", s1, v68 + 0xC);
            fscanf(v4, "%s %d", s1, v68 + 0x10);
            fscanf(v4, "%s %d", s1, v68 + 0x14);
            fscanf(v4, "%s %d", s1, &v83);
            *(_BYTE *)(v68 + 0xBF) = v83;
            fscanf(v4, "%s %s", s1, v74);
            fscanf(v4, "%s %s", s1, v75);
            Q_COSWND_CPP_sub_22644(v68, v74, v75);
            fscanf(v4, "%s %d", s1, &v83);
            fscanf(v4, "%s %d", s1, &v94);
            fscanf(v4, "%s %d", s1, &v83);
            fscanf(v4, "%s %d", s1, &v83);
            fscanf(v4, "%s %d", s1, &v83);
            fscanf(v4, "%s %d", s1, &v83);
            fscanf(v4, "%s %d", s1, &v83);
            *(_DWORD *)(v68 + 0x57E) = v83;
            fscanf(v4, "%s %d", s1, v68 + 0x45);
            fscanf(v4, "%s %d", s1, v68 + 0x47);
            fscanf(v4, "%s %d", s1, v68 + 0x4B);
            fscanf(v4, "%s %s", s1, v68 + 0x4F);
            v32 = *(_DWORD *)&a1->z1[0x300A];
            *(_WORD *)(v68 + 0x18) = 0xFFFF;
            *(_DWORD *)(v68 + 0x1A) = 0;
            v33 = HIWORD(dword_A3CF2);
            *(_BYTE *)(v68 + 0xD9) = 0;
            *(_DWORD *)(v68 + 4) = v32;
            v34 = 0;
            if ( v33 > 0 )
            {
              do
              {
                v35 = HIWORD(dword_A3CF2);
                v36 = (1 << v34++) | *(_BYTE *)(v68 + 0xD9);
                *(_BYTE *)(v68 + 0xD9) = v36;
              }
              while ( (__int16)v34 < v35 );
            }
          }
        }
        else if ( v83 <= 3 )
        {
          v37 = (T_TypeA1 *)operator new(0xB3u);
          if ( v37 )
          {
            v37 = (T_TypeA1 *)sub_2D9C4((int)v37);
          }
          sub_2625C(v37, 2, "CTW");
          v38 = (int)v37;
          v39 = &v37->g;
          sub_2DA68(v37);
          fscanf(v4, "%s %s", s1, v39);
          fscanf(v4, "%s", s1);
          fscanf(v4, "%s", s1);
          if ( strcmp(s1, "NONE") )
          {
            v40 = sub_56DA8((int)a1, s1, 0);
            if ( !v40 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xD8D);
            }
            *(_DWORD *)(v38 + 0x63) = *(_DWORD *)(v40 + 0x41);
            sub_2C990(v40, v38);
          }
          fscanf(v4, "%s %d", s1, &v93);
          for ( k = 0; k < (__int16)v93; ++k )
          {
            fscanf(v4, "%d", &v83);
            if ( !sub_57220((int)a1, *(_DWORD *)(v38 + 0x41), v83) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xD97);
            }
            if ( !k )
            {
              v42 = *(_WORD *)&a1->z1[0x8E * v83 + 0x30EA];
              *(_DWORD *)(v38 + 0x1A) = 0;
              *(_WORD *)(v38 + 0x18) = v42;
            }
          }
          fscanf(v4, "%s %d", s1, v38 + 8);
          fscanf(v4, "%s %d", s1, v38 + 0xC);
          fscanf(v4, "%s %d", s1, v38 + 0x10);
          fscanf(v4, "%s %d", s1, v38 + 0x14);
          fscanf(v4, "%s %d", s1, &v83);
          *(_WORD *)(v38 + 0x1E) = v83;
          *(_WORD *)(v38 + 0x59) = 0;
          fscanf(v4, "%s %d", s1, v38 + 0x45);
          fscanf(v4, "%s %d", s1, v38 + 0x47);
          fscanf(v4, "%s %d", s1, v38 + 0x4B);
          fscanf(v4, "%s %s", s1, v38 + 0x4F);
          *(_DWORD *)(v38 + 4) = *(_DWORD *)&a1->z1[0x300A];
          fscanf(v4, "%s %d", s1, &v98);
          if ( !sub_2DA80(v38, v98) )
          {
            Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xDB9);
          }
          for ( m = 0; (__int16)m < (__int16)v98; ++m )
          {
            fscanf(v4, "%s %d", s1, &v83);
            v82[0] = v83;
            fscanf(v4, "%d", &v83);
            v82[1] = v83;
            fscanf(v4, "%d", &v83);
            v82[3] = v83;
            fscanf(v4, "%d", &v83);
            v82[2] = v83;
            fscanf(v4, "%d", &v83);
            v82[4] = v83;
            fscanf(v4, "%d", &v83);
            v82[5] = v83;
            fscanf(v4, "%d", &v83);
            v82[6] = v83;
            if ( !sub_2DAC8(v38, 0, 0, (int)v82) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xDD4);
            }
          }
          LOWORD(v99) = 0;
          if ( SHIWORD(dword_A3CF2) > 0 )
          {
            do
            {
              sub_2DAC8(v38, 1 << v99, 1, 0);
              LOWORD(v99) = v99 + 1;
            }
            while ( (__int16)v99 < SHIWORD(dword_A3CF2) );
          }
        }
        else if ( v83 < 5 )
        {
          v43 = (T_TypeA2 *)operator new(0x504Eu);
          if ( v43 )
          {
            v43 = (T_TypeA2 *)sub_15ED4(v43);
          }
          sub_2625C(v43, 2, "BM");
          v44 = (int)v43;
          v45 = &v43->a.g;
          sub_2C978(&v43->a);
          fscanf(v4, "%s %s", s1, v45);
          fscanf(v4, "%s", s1);
          fscanf(v4, "%s", s1);
          if ( strcmp(s1, "NONE") )
          {
            v46 = sub_56DA8((int)a1, s1, 0);
            if ( !v46 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xDE9);
            }
            *(_DWORD *)(v44 + 0x63) = *(_DWORD *)(v46 + 0x41);
            sub_2C990(v46, v44);
          }
          fscanf(v4, "%s %d", s1, &v93);
          for ( n = 0; (__int16)n < (__int16)v93; ++n )
          {
            fscanf(v4, "%d", &v83);
            if ( !sub_57220((int)a1, *(_DWORD *)(v44 + 0x41), v83) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xDF3);
            }
          }
          fscanf(v4, "%s %d", s1, v44 + 8);
          fscanf(v4, "%s %d", s1, v44 + 0xC);
          fscanf(v4, "%s %d", s1, v44 + 0x10);
          fscanf(v4, "%s %d", s1, v44 + 0x14);
          fscanf(v4, "%s %d", s1, &v83);
          *(_BYTE *)(v44 + 0x4F2E) = v83;
          fscanf(v4, "%s %d", s1, &v83);
          *(_DWORD *)(v44 + 0xB8) = v83;
          sub_18370(v44);
          fscanf(v4, "%s %d", s1, v44 + 0x45);
          fscanf(v4, "%s %d", s1, v44 + 0x47);
          fscanf(v4, "%s %d", s1, v44 + 0x4B);
          fscanf(v4, "%s %s", s1, v44 + 0x4F);
          v48 = *(_DWORD *)&a1->z1[0x300A];
          *(_WORD *)(v44 + 0x18) = 0xFFFF;
          *(_DWORD *)(v44 + 0x1A) = 0;
          *(_DWORD *)(v44 + 4) = v48;
        }
        else
        {
          if ( v83 <= 7 )
          {
            goto LABEL_16;
          }
          v62 = (T_TypeA1 *)operator new(0x237u);
          if ( v62 )
          {
            v62 = (T_TypeA1 *)sub_4D92C((int)v62);
          }
          sub_2625C(v62, 2, "SW");
          v63 = (int)v62;
          v64 = &v62->g;
          sub_2C978(v62);
          fscanf(v4, "%s %s", s1, v64);
          fscanf(v4, "%s", s1);
          fscanf(v4, "%s", s1);
          if ( strcmp(s1, "NONE") )
          {
            v65 = sub_56DA8((int)a1, s1, 0);
            if ( !v65 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xE21);
            }
            *(_DWORD *)(v63 + 0x63) = *(_DWORD *)(v65 + 0x41);
            sub_2C990(v65, v63);
          }
          fscanf(v4, "%s %d", s1, &v93);
          for ( ii = 0; ii < (__int16)v93; ++ii )
          {
            fscanf(v4, "%d", &v83);
            if ( !sub_57220((int)a1, *(_DWORD *)(v63 + 0x41), v83) )
            {
              Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xE2B);
            }
            if ( !ii )
            {
              v50 = *(_WORD *)&a1->z1[0x8E * v83 + 0x30EA];
              *(_DWORD *)(v63 + 0x1A) = 0;
              *(_WORD *)(v63 + 0x18) = v50;
            }
          }
          fscanf(v4, "%s %d", s1, &v83);
          if ( v83 )
          {
            *(_DWORD *)(v63 + 0x3D) = 0xFFFFFFFF;
          }
          fscanf(v4, "%s %d", s1, v63 + 8);
          fscanf(v4, "%s %d", s1, v63 + 0xC);
          fscanf(v4, "%s %d", s1, v63 + 0x10);
          fscanf(v4, "%s %d", s1, v63 + 0x14);
          fscanf(v4, "%s %d", s1, &v83);
          *(_WORD *)(v63 + 0x59) = v83;
          fscanf(v4, "%s %d", s1, v63 + 0x45);
          fscanf(v4, "%s %d", s1, v63 + 0x47);
          fscanf(v4, "%s %d", s1, v63 + 0x4B);
          fscanf(v4, "%s %s", s1, v63 + 0x4F);
          *(_DWORD *)(v63 + 4) = *(_DWORD *)&a1->z1[0x300A];
        }
      }
      else
      {
        if ( v83 <= 9 )
        {
          goto LABEL_16;
        }
        if ( v83 < 0xE )
        {
          if ( v83 < 0xB )
          {
            v51 = (T_TypeA2 *)operator new(0x902u);
            if ( v51 )
            {
              v51 = sub_2E248(v51);
            }
            sub_2625C(v51, 2, "LB");
            v52 = (int)v51;
            v53 = &v51->a.g;
            sub_2E3BC(&v51->a);
            fscanf(v4, "%s %s", s1, v53);
            fscanf(v4, "%s", s1);
            fscanf(v4, "%s", s1);
            if ( strcmp(s1, "NONE") )
            {
              v54 = sub_56DA8((int)a1, s1, 0);
              if ( !v54 )
              {
                Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xE5E);
              }
              *(_DWORD *)(v52 + 0x63) = *(_DWORD *)(v54 + 0x41);
              sub_2C990(v54, v52);
            }
            fscanf(v4, "%s %d", s1, &v93);
            for ( jj = 0; (__int16)jj < (__int16)v93; ++jj )
            {
              fscanf(v4, "%d", &v83);
              if ( !sub_57220((int)a1, *(_DWORD *)(v52 + 0x41), v83) )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xE68);
              }
            }
            fscanf(v4, "%s %d", s1, &v83);
            if ( v83 )
            {
              *(_DWORD *)(v52 + 0x3D) = 0xFFFFFFFF;
            }
            fscanf(v4, "%s %d", s1, v52 + 8);
            fscanf(v4, "%s %d", s1, v52 + 0xC);
            fscanf(v4, "%s %d", s1, v52 + 0x10);
            fscanf(v4, "%s %d", s1, v52 + 0x14);
            fscanf(v4, "%s %d", s1, &v83);
            *(_WORD *)(v52 + 0x1E) = v83;
            fscanf(v4, "%s %d", s1, &v83);
            *(_WORD *)(v52 + 0x59) = v83;
            fscanf(v4, "%s %d", s1, v52 + 0x45);
            fscanf(v4, "%s %d", s1, v52 + 0x47);
            fscanf(v4, "%s %d", s1, v52 + 0x4B);
            fscanf(v4, "%s %s", s1, v52 + 0x4F);
            *(_DWORD *)(v52 + 4) = *(_DWORD *)&a1->z1[0x300A];
          }
          else
          {
            if ( v83 <= 0xC )
            {
              goto LABEL_16;
            }
            v59 = (T_TypeA2 *)operator new(0xC0u);
            if ( v59 )
            {
              v59 = sub_5A594(v59);
            }
            sub_2625C(v59, 2, "DBGWND");
            v60 = v59;
            if ( !v59 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xE8E);
            }
            sub_5A5F4(&v59->a);
            *(_DWORD *)&a1->z3[0x1D4E4] = v60;
            fscanf(v4, "%s %s", s1, &v60->a.g);
            fscanf(v4, "%s %d", s1, v60->a.c);
            fscanf(v4, "%s %d", s1, &v60->a.c[4]);
            fscanf(v4, "%s %d", s1, &v60->a.c[8]);
            fscanf(v4, "%s %d", s1, &v60->a.c[0xC]);
            fscanf(v4, "%s %d", s1, &v60[1].a.b);
            fscanf(v4, "%s %d", s1, v60[1].a.c);
            fscanf(v4, "%s %d", s1, &v60[1].a.c[4]);
            fscanf(v4, "%s %d", s1, &v60[1].a.c[8]);
            fscanf(v4, "%s %s", s1, v80);
            v60->a.d = sub_1ADAC(v86, v80);
            v61 = *(_DWORD *)&a1->z1[0x300A];
            v60->a.b = v61;
            *(_DWORD *)v60[1].a.a = v61;
          }
        }
        else
        {
          if ( v83 <= 0x1B )
          {
            goto LABEL_16;
          }
          if ( v83 < 0x64 )
          {
            if ( v83 < 0x1D || v83 > 0x20 )
            {
LABEL_262:
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xEF2);
            }
LABEL_16:
            if ( v83 )
            {
              switch ( v83 )
              {
                case 5u:
                  v9 = "RW";
                  v10 = operator new(0xABu);
                  if ( v10 )
                  {
                    sub_25BF8((P_TypeA2)v10);
                  }
                  v11 = 2;
                  break;
                case 6u:
                  v9 = "RSW";
                  v10 = operator new(0xB1u);
                  if ( v10 )
                  {
                    v10 = (void *)sub_25CB8((int)v10);
                  }
                  v11 = 2;
                  break;
                case 7u:
                  v9 = "PW";
                  v10 = operator new(0x18Cu);
                  if ( v10 )
                  {
                    v10 = sub_372B0((T_TypeA2 *)v10, (int)v10, (int)"PW", 2);
                  }
                  v11 = 2;
                  break;
                case 0xBu:
                  v9 = "LW";
                  v10 = operator new(0xFE0u);
                  if ( v10 )
                  {
                    v10 = sub_31200((T_TypeA2 *)v10);
                  }
                  v11 = 2;
                  break;
                case 0xCu:
                  v9 = "IW";
                  v10 = operator new(0xAFu);
                  if ( v10 )
                  {
                    sub_33598((P_TypeA4)v10);
                  }
                  v11 = 2;
                  break;
                case 9u:
                  v10 = operator new(0x9DDu);
                  v85 = 2;
                  if ( v10 )
                  {
                    sub_2C830((P_TypeA2)v10);
                    v12 = (char *)sub_1B4F0((char *)v10 + 0xAB) + 0xFFFFFF55 + 0x143;
                    v13 = _wcpp_2_ctor_array_(v12, 0x64, &unk_959D8) - 0x143;
                    *(_DWORD *)(v13 + 0xA7) = off_96018;
                    sub_46CAC(v13, v13, (int)&unk_959D8, (int)v12);
                    v10 = (void *)v13;
                  }
                  v11 = v85;
                  v9 = "RW";
                  break;
                case 0xEu:
                  v9 = "PSW";
                  v10 = operator new(0xADu);
                  if ( v10 )
                  {
                    v10 = sub_39D80((T_TypeA2 *)v10);
                  }
                  v11 = 2;
                  break;
                case 0xFu:
                  v9 = "NT";
                  v10 = operator new(0xAFu);
                  if ( v10 )
                  {
                    v10 = sub_2F2F4((T_TypeA2 *)v10);
                  }
                  v11 = 2;
                  break;
                case 0x10u:
                  v9 = "SW";
                  v10 = operator new(0xB1u);
                  if ( v10 )
                  {
                    v10 = sub_51674((T_TypeA2 *)v10);
                  }
                  v11 = 2;
                  break;
                case 0x11u:
                  v9 = "FW";
                  v10 = operator new(0xB1u);
                  if ( v10 )
                  {
                    v10 = sub_51B64((T_TypeA2 *)v10);
                  }
                  v11 = 2;
                  break;
                case 0x12u:
                  v9 = "NG";
                  v10 = operator new(0xBDu);
                  if ( v10 )
                  {
                    v10 = sub_520EC((T_TypeA2 *)v10);
                  }
                  v11 = 2;
                  break;
                case 0x13u:
                  v11 = 2;
                  v10 = operator new(0x108u);
                  if ( v10 )
                  {
                    sub_10A3C((P_TypeA8)v10);
                  }
                  v9 = "BC";
                  break;
                case 0x14u:
                  v9 = "HW";
                  v10 = operator new(0xDAFu);
                  if ( v10 )
                  {
                    sub_2FC50((P_TypeA2)v10);
                  }
                  v11 = 2;
                  break;
                case 0x15u:
                  v11 = 2;
                  v10 = operator new(0xC3u);
                  if ( v10 )
                  {
                    sub_3201C((P_TypeA7)v10);
                  }
                  v9 = "NW";
                  break;
                case 0x16u:
                  v9 = "AW";
                  v10 = operator new(0xDAFu);
                  if ( v10 )
                  {
                    sub_33830((P_TypeA6)v10);
                  }
                  v11 = 2;
                  break;
                case 0x17u:
                  v9 = "EW";
                  v10 = operator new(0xDB3u);
                  if ( v10 )
                  {
                    sub_267A0((P_TypeA5)v10);
                  }
                  v11 = 2;
                  break;
                case 0x18u:
                  v9 = "EW";
                  v10 = operator new(0xABu);
                  if ( v10 )
                  {
                    sub_27BF8((P_TypeA2)v10);
                  }
                  v11 = 2;
                  break;
                case 0x19u:
                  v9 = "TW";
                  v10 = operator new(0xAFu);
                  if ( v10 )
                  {
                    sub_2D464((P_TypeA4)v10);
                  }
                  v11 = 2;
                  break;
                case 0x1Au:
                  v9 = "MW";
                  v10 = operator new(0xB3u);
                  if ( v10 )
                  {
                    sub_2FA18((P_TypeA3)v10);
                  }
                  v11 = 2;
                  break;
                case 0x1Du:
                  v9 = "GSW";
                  v10 = operator new(0xABu);
                  if ( v10 )
                  {
                    sub_395EC((P_TypeA2)v10);
                  }
                  v11 = 2;
                  break;
                case 0x1Eu:
                  v9 = "EW";
                  v10 = operator new(0xABu);
                  if ( v10 )
                  {
                    sub_2712C((T_TypeA2 *)v10);
                  }
                  v11 = 2;
                  break;
                case 0x1Fu:
                  v9 = "pcw";
                  v11 = 2;
                  v10 = operator new(0xABu);
                  if ( v10 )
                  {
                    sub_2C830((P_TypeA2)v10);
                    *(_DWORD *)((char *)v10 + 0xA7) = off_961DC;
                  }
                  break;
                case 0x20u:
                  v9 = "miw";
                  v11 = 2;
                  v10 = operator new(0xABu);
                  if ( v10 )
                  {
                    sub_2C830((P_TypeA2)v10);
                    *(_DWORD *)((char *)v10 + 0xA7) = off_961C4;
                  }
                  break;
                default:
                  goto LABEL_111;
              }
            }
            else
            {
              v9 = "GW";
              v10 = operator new(0xABu);
              if ( v10 )
              {
                sub_2C830((P_TypeA2)v10);
              }
              v11 = 2;
            }
            sub_2625C(v10, v11, v9);
            v84 = (P_TypeA1)v10;
LABEL_111:
            v14 = &v84->g;
            sub_2C978(v84);
            fscanf(v4, "%s %s", s1, v14);
            fscanf(v4, "%s", s1);
            fscanf(v4, "%s", s1);
            if ( strcmp(s1, "NONE") )
            {
              v15 = sub_56DA8((int)a1, s1, 0);
              if ( !v15 )
              {
                sub_2620C("%s bad parent", (char)v14);
                sub_261B8(0, "..\\winmgr.cpp", 0xC8D);
              }
              v16 = v84;
              v84->v = *(_DWORD *)(v15 + 0x41);
              sub_2C990(v15, (int)v16);
            }
            fscanf(v4, "%s %d", s1, &v93);
            for ( kk = 0; kk < (__int16)v93; ++kk )
            {
              fscanf(v4, "%d", &v83);
              if ( !sub_57220((int)a1, v84->l, v83) )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xC97);
              }
              if ( !kk )
              {
                v18 = v84;
                v19 = *(_WORD *)&a1->z1[0x8E * v83 + 0x30EA];
                v84->e = 0;
                v18->d = v19;
              }
            }
            fscanf(v4, "%s %d", s1, &v83);
            if ( v83 )
            {
              v84->k = 0xFFFFFFFF;
            }
            if ( v95 == 0x19 )
            {
              fscanf(v4, "%s %d", s1, &v83);
              if ( v83 )
              {
                v84[1].b = 0xFFFFFFFF;
              }
            }
            fscanf(v4, "%s %d", s1, v84->c);
            fscanf(v4, "%s %d", s1, &v84->c[4]);
            fscanf(v4, "%s %d", s1, &v84->c[8]);
            fscanf(v4, "%s %d", s1, &v84->c[0xC]);
            fscanf(v4, "%s %d", s1, &v83);
            v20 = v84;
            v84->f = v83;
            if ( v95 == 0xF )
            {
              fscanf(v4, "%s %d", s1, &v83);
              v20[1].b = v83;
            }
            fscanf(v4, "%s %d", s1, &v83);
            v21 = v84;
            v84->r = v83;
            fscanf(v4, "%s %d", s1, &v21->m);
            fscanf(v4, "%s %d", s1, &v21->n);
            fscanf(v4, "%s %d", s1, &v21->o);
            fscanf(v4, "%s %s", s1, &v21->p);
            fscanf(v4, "%s %d", s1, &v83);
            y = (int)v21->y;
            v97 = 0;
            v96 = v83;
            if ( (__int16)v83 > 0 )
            {
              v23 = &v21->y[9];
              v90 = &v21->y[0xB];
              v91 = &v21->y[5];
              do
              {
                fscanf(v4, "%s %d", s1, &v83);
                if ( v83 )
                {
                  if ( v83 != 1 )
                  {
                    Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xCE1);
                  }
                  v73 = (int)v90;
                  v71 = (int)v91;
                  *(_BYTE *)y = 1;
                  fscanf(v4, "%s %d %d %d", s1, v71, v23, v73);
                  *(_DWORD *)(y + 1) = (unsigned __int16)sub_1B270((int)dword_12FC20, s1, 0xFFFFFFFF);
                }
                else
                {
                  v72 = (int)v90;
                  v70 = (int)v91;
                  *(_BYTE *)y = 0;
                  fscanf(v4, "%s %d %d %d", s1, v70, v23, v72);
                  *(_DWORD *)(y + 1) = sub_2D334(s1);
                }
                v24 = (int)v90;
                sub_2D400((int)v84, y);
                v23 += 0xD;
                y += 0xD;
                v90 = (_BYTE *)(v24 + 0xD);
                ++v97;
                v91 += 0xD;
              }
              while ( (__int16)v97 < (__int16)v96 );
            }
            v84->b = *(_DWORD *)&a1->z1[0x300A];
          }
          else if ( v83 <= 0x64 )
          {
            fscanf(v4, "%s %d", s1, &v83);
            fscanf(v4, "%s %s", s1, v77);
            v56 = sub_1ADAC(v87, v77);
            if ( !sub_5748C((int)a1, v83, v56) )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0xECA);
            }
          }
          else
          {
            if ( v83 < 0xC8 )
            {
              goto LABEL_262;
            }
            if ( v83 <= 0xC8 )
            {
              fscanf(v4, "%s %d", s1, &v83);
              v57 = 0;
              sub_2C08C((int)&V_Type6_stru_D8654, v83);
              while ( v57 < (int)v83 )
              {
                v58 = v57;
                fscanf(v4, "%s %s", s1, v76);
                ++v57;
                sub_2C0C0((int)&V_Type6_stru_D8654, v76, v58);
              }
            }
            else
            {
              if ( v83 != 0x12C )
              {
                goto LABEL_262;
              }
              fscanf(v4, "%s %s", s1, v78);
              if ( sub_2B360(v88, v78) != 0xFFFFFFFF )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xEE6);
              }
              *(_DWORD *)&a1->z1[0x3042] = 0;
              fscanf(v4, "%s %s", s1, v78);
              if ( sub_2B360(v89, v78) != 0xFFFFFFFF )
              {
                Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0xEEB);
              }
              *(_DWORD *)&a1->z1[0x3062] = 0;
            }
          }
        }
      }
    }
  }
  return result;
}
// 77394: using guessed type int __fastcall _wcpp_2_ctor_array_(_DWORD, _DWORD, _DWORD);
// 96018: using guessed type int (*off_96018[5])();
// 961C4: using guessed type int (*off_961C4[5])();
// 961DC: using guessed type int (*off_961DC[5])();
// 96BAC: using guessed type int dword_96BAC;
// A3CF2: using guessed type int dword_A3CF2;
// 12FC20: using guessed type _DWORD dword_12FC20[248];
// 57670: using guessed type char var_150[128];
// 57670: using guessed type char var_350[128];
// 57670: using guessed type char var_250[128];
// 57670: using guessed type char var_2D0[128];
// 57670: using guessed type char var_D0[52];
// 57670: using guessed type char anonymous_0[128];

//----- (00059828) --------------------------------------------------------
void __fastcall sub_59828(int a1, int a2, int a3, int a4)
{
  T_Type1 v5; // [esp-124h] [ebp-128h] BYREF
  int v6; // [esp-4h] [ebp-8h]

  v6 = a4;
  Q_InitFileInfo_sub_1BB78(&v5);
  if ( !Q_CfilePreload_sub_1BBFC(&v5, "ascend.cfg", 0x200, 0) )
  {
    sub_1BF94(&v5, &dword_10935F, 4u);
    sub_1BF94(&v5, &dword_109377, 4u);
    sub_1BF94(&v5, (char *)&loc_24DAA + a1 + 2, 4u);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v5);
}
// 10935F: using guessed type int dword_10935F;
// 109377: using guessed type int dword_109377;

//----- (0005989C) --------------------------------------------------------
void __fastcall sub_5989C(P_Type3 a1, int a2, int a3, int a4)
{
  T_Type1 v5; // [esp-120h] [ebp-124h] BYREF
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]

  v7 = a4;
  v6 = a2;
  Q_InitFileInfo_sub_1BB78(&v5);
  if ( !sub_1BCA8(&v5, "ascend.cfg") )
  {
    sub_1C098((unsigned int)&v5, (int)&dword_10935F, 4u);
    sub_1C098((unsigned int)&v5, (int)&dword_109377, 4u);
    sub_1C098((unsigned int)&v5, (int)&a1->z1[(_DWORD)&loc_24DAA + 2], 4u);
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v5);
}
// 10935F: using guessed type int dword_10935F;
// 109377: using guessed type int dword_109377;

//----- (00059908) --------------------------------------------------------
int __fastcall sub_59908(int result)
{
  if ( !*(_DWORD *)(result + 0x48A6) && !*(_DWORD *)(result + 0x48AA) )
  {
    *(_DWORD *)(result + 0x48A6) = 0xFFFFFFFF;
    *(_DWORD *)(result + 0x48BA) = 0;
    *(_DWORD *)(result + 0x48B6) = 0;
  }
  return result;
}

//----- (00059934) --------------------------------------------------------
void __fastcall sub_59934(T_Type3 *a1, int a2, int a3)
{
  if ( a1->aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    if ( a1->aaa == 0xFFFFFFFF )
    {
      a1->aaa = 0;
      sub_59DE0((int)a1, a2, a3, (int)a1);
      if ( a2 )
      {
        sub_59E88(a1, "WINEVENT.BIN", "WINEVENT.TXT");
      }
    }
    a1->bbb = 0;
  }
}

//----- (00059988) --------------------------------------------------------
unsigned int __fastcall sub_59988(P_Type3 a1, char *a2, int a3)
{
  char *v4; // edi
  char v6; // al
  char v7; // al
  const char *v8; // esi
  char *v9; // edi
  char v10; // al
  char v11; // al
  int aaa; // ecx
  unsigned int result; // eax

  v4 = byte_132B20;
  do
  {
    v6 = *a2;
    *v4 = *a2;
    if ( !v6 )
    {
      break;
    }
    v7 = a2[1];
    a2 += 2;
    v4[1] = v7;
    v4 += 2;
  }
  while ( v7 );
  v8 = ".txt";
  v9 = &byte_132B20[strlen(byte_132B20) - 4];
  do
  {
    v10 = *v8;
    *v9 = *v8;
    if ( !v10 )
    {
      break;
    }
    v11 = v8[1];
    v8 += 2;
    v9[1] = v11;
    v9 += 2;
  }
  while ( v11 );
  dword_132B14 = dword_D862C;
  aaa = a1->aaa;
  dword_132B18 = dword_D8630;
  if ( aaa == 0xFFFFFFFF || a1->bbb == 0xFFFFFFFF )
  {
    return 0;
  }
  result = sub_59CFC((int)a1, a2);
  if ( result )
  {
    a1->bbb = 0xFFFFFFFF;
    *(_DWORD *)&a1->z3[8] = 0;
    result = 0xFFFFFFFF;
    *(_DWORD *)&a1->z3[0x10] = 0;
    *(_DWORD *)a1->z3 = a3;
    dword_132B1C = 0;
  }
  return result;
}
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// 132B14: using guessed type int dword_132B14;
// 132B18: using guessed type int dword_132B18;
// 132B1C: using guessed type int dword_132B1C;

//----- (00059A54) --------------------------------------------------------
int __fastcall sub_59A54(int result)
{
  int v1; // ecx
  unsigned int v2; // edi
  LONG v3; // ebp
  LONG v4; // eax
  int v5; // eax
  _DWORD *v6; // esi
  unsigned int v7; // eax
  LONG v8; // [esp+0h] [ebp-1Ch]

  v1 = result;
  if ( *(_DWORD *)(result + 0x48AA) )
  {
    v8 = new_x;
    dword_D862C = dword_132B14;
    v2 = 0xFFFFFFFF;
    dword_D8630 = dword_132B18;
    v3 = dword_D864C;
    sub_2656C((__int16)&unk_D85F8);
    if ( dword_D85FC == 0xFFFFFFFF
      || dword_D8638 == 0xFFFFFFFF && dword_D862C
      || dword_D863C == 0xFFFFFFFF && dword_D8630 )
    {
      v4 = new_x;
      *(_DWORD *)(v1 + 0x48AA) = 0;
      v3 = dword_D864C;
      v8 = v4;
      v5 = 0;
      if ( !*(_DWORD *)(v1 + 0x489E) )
      {
        v6 = (_DWORD *)sub_56DA8(v1, "HELPWINDOW", 0);
        sub_2FCB0(v6, "help.txt", "endtut");
        v5 = sub_552F8(v1, (int)v6, 0);
      }
      if ( v5 )
      {
        v7 = time(0);
        srand(v7);
        v2 = 0;
        *(_DWORD *)((char *)&loc_24DAA + v1 + 2) = dword_96BBC;
      }
      else
      {
        *(_DWORD *)(v1 + 0x48AA) = 0xFFFFFFFF;
      }
    }
    if ( v2 )
    {
      dword_D864C = v3;
      dword_D8644 = 0;
      new_x = v8;
    }
    dword_132B14 = dword_D862C;
    result = dword_D8630;
    dword_132B18 = dword_D8630;
  }
  return result;
}
// 96BBC: using guessed type int dword_96BBC;
// D85FC: using guessed type int dword_D85FC;
// D862C: using guessed type int dword_D862C;
// D8630: using guessed type int dword_D8630;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;
// 132B14: using guessed type int dword_132B14;
// 132B18: using guessed type int dword_132B18;

//----- (00059B80) --------------------------------------------------------
void __fastcall sub_59B80(int a1)
{
  int v2; // esi
  int v3; // eax
  int v4; // eax
  unsigned __int16 v5; // dx
  int v6; // edx
  int v7; // ebx

  v2 = a1 + 0x48C2;
  dword_D8638 = 0;
  dword_D863C = 0;
  dword_D8644 = 0;
  dword_D85FC = 0;
  while ( 1 )
  {
    v3 = 0x18 * *(_DWORD *)(a1 + 0x48BE);
    if ( *(_DWORD *)(a1 + 0x48B6) < *(_DWORD *)(a1 + v3 + 0x48C2) )
    {
      break;
    }
    v4 = v2 + v3;
    v5 = *(_WORD *)(v4 + 8);
    if ( !v5 )
    {
      goto LABEL_5;
    }
    if ( v5 <= 3u )
    {
      sub_265A8(v4);
    }
    else if ( v5 > 7u )
    {
LABEL_5:
      sprintf(
        "Thank you for playing Ascendancy.",
        "\nBad Trace Event: %d of %d\n\nEVENT[%d] HWND[%0d] MSG[%d] P1[%d] P2[%d]\n",
        *(_DWORD *)(a1 + 0x48BE),
        *(_DWORD *)(a1 + 0x48BA),
        *(__int16 *)(v4 + 8),
        *(_DWORD *)(v4 + 4),
        *(__int16 *)(v4 + 0xA),
        *(_DWORD *)(v4 + 0xC),
        *(_DWORD *)(v4 + 0x10));
      Q_debugbreak_exit_sub_2624C();
    }
    v6 = *(_DWORD *)(a1 + 0x48BE) + 1;
    v7 = *(_DWORD *)(a1 + 0x48BA);
    *(_DWORD *)(a1 + 0x48BE) = v6;
    if ( v6 >= v7 )
    {
      if ( *(_DWORD *)(a1 + 0x48AE) != 0xFFFFFFFF )
      {
        sub_59934((T_Type3 *)a1, 0, v7);
        return;
      }
      *(_DWORD *)(a1 + 0x48BE) = 0;
      *(_DWORD *)(a1 + 0x48B6) = 0;
    }
  }
}
// D85FC: using guessed type int dword_D85FC;
// D8638: using guessed type int dword_D8638;
// D863C: using guessed type int dword_D863C;
// D8644: using guessed type int dword_D8644;

//----- (00059C80) --------------------------------------------------------
void __fastcall sub_59C80(T_Type3 *a1, int a2, __int16 a3, __int16 a4, int a5, int a6, int a7)
{
  char *v8; // edx
  int v9; // edi

  if ( a1->aaa == 0xFFFFFFFF && !a1->bbb )
  {
    v8 = &a1->z3[0x18 * *(_DWORD *)&a1->z3[0xC] + 0x14];
    *(_DWORD *)v8 = *(_DWORD *)&a1->z3[8];
    *((_DWORD *)v8 + 1) = a2;
    *((_WORD *)v8 + 4) = a3;
    *((_WORD *)v8 + 5) = a4;
    *((_DWORD *)v8 + 3) = a5;
    *((_DWORD *)v8 + 4) = a6;
    *((_DWORD *)v8 + 5) = a7;
    v9 = *(_DWORD *)&a1->z3[0xC] + 1;
    *(_DWORD *)&a1->z3[0xC] = v9;
    if ( v9 == 0x1388 )
    {
      sub_59934(a1, 0, a3);
    }
  }
}

//----- (00059CFC) --------------------------------------------------------
unsigned int __fastcall sub_59CFC(int a1, const char *a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // eax
  T_Type1 v6; // [esp+0h] [ebp-124h] BYREF

  Q_InitFileInfo_sub_1BB78(&v6);
  if ( *(_DWORD *)(a1 + 0x48A6) == 0xFFFFFFFF )
  {
    Q_CloseFileAndDelete_sub_1BBC8(&v6);
    return 0;
  }
  else
  {
    if ( Q_CfilePreload_sub_1BBFC(&v6, a2, 0x200, 0) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x104F);
    }
    if ( (unsigned int)sub_1BE28(&v6) > 0x1D4D0 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1052);
    }
    sub_1BF94(&v6, (void *)(a1 + 0x21D82), 0x10u);
    v4 = sub_1BF94(&v6, (void *)(a1 + 0x48C2), 0x1D4C0u);
    *(_DWORD *)(a1 + 0x48BA) = v4 / 0x18;
    if ( v4 % 0x18 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x1059);
    }
    v3 = 0xFFFFFFFF;
    *(_DWORD *)(a1 + 0x48BE) = 0;
    Q_CloseFileAndDelete_sub_1BBC8(&v6);
  }
  return v3;
}

//----- (00059DE0) --------------------------------------------------------
void __fastcall sub_59DE0(int a1, int a2, int a3, int a4)
{
  T_Type1 v5; // [esp-124h] [ebp-128h] BYREF
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]

  v7 = a4;
  v6 = a2;
  Q_InitFileInfo_sub_1BB78(&v5);
  if ( *(_DWORD *)(a1 + 0x48A6) != 0xFFFFFFFF )
  {
    if ( Q_CfilePreload_sub_1BBFC(&v5, "WINEVENT.BIN", 0x21, 0) )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x106C);
    }
    sub_1C098((unsigned int)&v5, a1 + 0x21D82, 0x10u);
    sub_1C098((unsigned int)&v5, a1 + 0x48C2, 0x18 * *(_DWORD *)(a1 + 0x48BA));
  }
  Q_CloseFileAndDelete_sub_1BBC8(&v5);
}

//----- (00059E88) --------------------------------------------------------
char *__fastcall sub_59E88(T_Type3 *a1, char *a2, char *filename)
{
  char *result; // eax
  FILE *v5; // ecx
  __int16 i; // bx
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  char *v11; // edx
  const char *v12; // [esp-4h] [ebp-8h]

  result = filename;
  if ( !a1->aaa && !a1->bbb )
  {
    v5 = fopen(filename, "w");
    if ( !v5 )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x107D);
    }
    if ( sub_59CFC((int)a1, a2) != 0xFFFFFFFF )
    {
      Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x1080);
    }
    for ( i = 0; i < *(_DWORD *)&a1->z3[0xC]; ++i )
    {
      v11 = &a1->z3[0x18 * i + 0x14];
      switch ( *((_WORD *)v11 + 4) )
      {
        case 1:
          fprintf(v5, " TIME[%05lu]  EVT_MOUSE_POS    : ", *(_DWORD *)v11);
          fprintf(v5, " Moved to (%03d,%03d)\n", *((_DWORD *)v11 + 3), *((_DWORD *)v11 + 4));
          break;
        case 2:
          fprintf(v5, " TIME[%05lu]  EVT_MOUSE_BUTTON :  ", *(_DWORD *)v11);
          if ( *((_DWORD *)v11 + 4) )
          {
            v7 = "DOWN";
          }
          else
          {
            v7 = "UP";
          }
          v12 = v7;
          if ( *((_DWORD *)v11 + 3) )
          {
            v8 = "Right";
          }
          else
          {
            v8 = "Left";
          }
          fprintf(v5, "%s Button %s\n", v8, v12);
          break;
        case 3:
          fprintf(v5, " TIME[%05lu]  EVT_KEYBOARD     : ", *(_DWORD *)v11);
          fprintf(v5, " '%c'  (%04d)\n", v11[0x10], *((_DWORD *)v11 + 3));
          break;
        case 4:
        case 5:
          if ( *((_WORD *)v11 + 4) == 4 )
          {
            v9 = "EVT_REQ_CONT";
          }
          else
          {
            v9 = "EVT_CAN_CONT";
          }
          fprintf(v5, " TIME[%05lu]  %-15s: ", *(_DWORD *)v11, v9);
          fprintf(
            v5,
            " HWND[%04d] MSG[%04d] P1[%04d] P2[%04d]\n",
            *((_DWORD *)v11 + 1),
            *((__int16 *)v11 + 5),
            *((_DWORD *)v11 + 3),
            *((_DWORD *)v11 + 4));
          break;
        case 6:
        case 7:
          if ( *((_WORD *)v11 + 4) == 6 )
          {
            v10 = "EVT_REQ_CHANGE";
          }
          else
          {
            v10 = "EVT_CAN_CHANGE";
          }
          fprintf(v5, " TIME[%05lu]  %-15s: ", *(_DWORD *)v11, v10);
          fprintf(
            v5,
            " HWND[%04d] MSG[%04d] P1[%04d] P2[%04d] F[%04d]\n",
            *((_DWORD *)v11 + 1),
            *((__int16 *)v11 + 5),
            *((_DWORD *)v11 + 3),
            *((_DWORD *)v11 + 4),
            *((_DWORD *)v11 + 5));
          break;
        default:
          fprintf(v5, " *** Unrecognized event type : %d\n", *((__int16 *)v11 + 4));
          break;
      }
    }
    return (char *)fclose(v5);
  }
  return result;
}

//----- (0005A094) --------------------------------------------------------
void __fastcall Q_WINMGR_CPP_sub_5A094(P_Type3 a1, void *aData, int a3, char *a4)
{
  __int16 i; // kr00_2
  char *text; // edi

  if ( a1->counter2 == 0x180 )
  {
    Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x10CB);
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= 384 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x10DD);
    }
    if ( !a1->c[i].pData )
    {
      break;
    }
  }
  a1->c[i].pData = aData;
  a1->c[i].a = a3;
  text = a1->c[i].text;
  strncpy(text, a4, 19u);
  a1->c[i].text[19] = 0;
  strupr(text);
  a1->c[i].time = V_Timer_dword_132B58;
  ++a1->counter2;
}
// 132B58: using guessed type int V_Timer_dword_132B58;

//----- (0005A144) --------------------------------------------------------
void __fastcall Q_WINMGR_CPP_sub_5A144(P_Type3 a1, void *a2)
{
  __int16 i; // kr00_2

  if ( a2 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= 0x180 )
      {
        Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x10F1);
      }
      if ( a2 == a1->c[i].pData )
      {
        break;
      }
    }
    a1->c[i].pData = 0;
    --a1->counter2;
  }
}

//----- (0005A194) --------------------------------------------------------
char *__fastcall sub_5A194(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  __int16 v6; // dx
  __int16 v7; // ax
  int v8; // edx

  v6 = *(_WORD *)(a1 + 0x24D96);
  v7 = 0;
  if ( v6 <= 0 )
  {
    return 0;
  }
  while ( 1 )
  {
    v8 = a1 + 0x20 * v7;
    if ( a2 == *(_DWORD *)((char *)&loc_21DB2 + v8) )
    {
      break;
    }
    if ( ++v7 >= *(__int16 *)(a1 + 0x24D96) )
    {
      return 0;
    }
  }
  if ( a3 )
  {
    *a3 = *(_DWORD *)((char *)&loc_21D96 + v8);
  }
  if ( a4 )
  {
    *a4 = *(_DWORD *)(0x20 * v7 + a1 + 0x21D9A);
  }
  return (char *)&loc_21D96 + 0x20 * v7 + a1 + 8;
}

//----- (0005A270) --------------------------------------------------------
void __fastcall sub_5A270(T_Type3 *a1, int a2, int a3, int a4)
{
  if ( !a1->h || a4 == 0xFFFFFFFF )
  {
    Q_GSYSTEM_CPP_sub_2C7D0(&V_Type6_stru_D8654, a2, a3);
  }
}

//----- (0005A294) --------------------------------------------------------
void __fastcall sub_5A294(_DWORD *a1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // [esp+0h] [ebp-14h]

  v1 = a1;
  v2 = a1 + 0xC00;
  while ( 1 )
  {
    if ( *v1 )
    {
      (*(void (**)(void))(*(_DWORD *)(v1[1] + 0xA7) + 0x14))();
    }
    v1 += 3;
    if ( v1 == v2 )
    {
      JUMPOUT(0x56E0E);
    }
  }
}
// 5A2B3: control flows out of bounds to 56E0E

//----- (0005A320) --------------------------------------------------------
void __fastcall sub_5A320(__int16 a1)
{
  unsigned __int16 v1; // cx
  void *v2; // eax

  switch ( a1 )
  {
    case 1:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\1starmap.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 2:
    case 4:
    case 0xA:
    case 0xE:
    case 0xF:
    case 0x12:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\10status.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 3:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\3cfgnew.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 7:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\7racesel.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 8:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\8shipdes.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 9:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\9ENDGAME.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0xC:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\12start.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0xD:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\13negot.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0x10:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\16battle.tmp", 0xFFFFFFFF);
      goto LABEL_12;
    case 0x14:
      v1 = sub_1B270((int)dword_12FC20, "DATA\\20res.tmp", 0xFFFFFFFF);
LABEL_12:
      if ( v1 == 0xFFFF )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1168);
      }
      v2 = (void *)sub_1B084((unsigned int)dword_12FC20, v1);
      VFX_shape_draw(&V_Type6_stru_D8654.pane, v2, 0, 0, 0);
      break;
    default:
      return;
  }
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0005A47C) --------------------------------------------------------
int __fastcall sub_5A47C(T_Type5 *a1, const char *a2, int a3, int a4)
{
  __int16 v5; // ax
  T_Rect *p_rect; // esi
  __int16 v8; // [esp+2h] [ebp-10h]

  v5 = 0xF2;
  v8 = word_96BC4[a3];
  if ( a4 == 0xFFFFFFFF )
  {
    v5 = 0x96;
  }
  VFX_pane_wipe((PANE *)a1, v5);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = a1->a;
  p_rect = &a1->rect;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = p_rect->x1;
  p_rect = (T_Rect *)((char *)p_rect + 4);
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = p_rect->x1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = p_rect->y1;
  return sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 1, 1, a2, 0x40, v8, 0xFF, 0);
}
// 96BC4: using guessed type __int16 word_96BC4[8];

//----- (0005A4E4) --------------------------------------------------------
LONG __fastcall sub_5A4E4(_DWORD *a1, LONG a2, int a3, int a4)
{
  __int16 v5; // bx
  __int16 v6; // ax
  PANE v8; // [esp+0h] [ebp-30h] BYREF
  char s[12]; // [esp+14h] [ebp-1Ch] BYREF
  LONG color; // [esp+20h] [ebp-10h]

  v5 = 0xF3;
  color = a2;
  sprintf(s, "%03d", a2);
  v6 = 0xF2;
  if ( a2 == dword_132B10 )
  {
    v6 = 0xFE;
    v5 = 0;
  }
  if ( a4 )
  {
    v6 = 0xF1;
  }
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x304E] = *a1;
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3052] = a1[1];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x3056] = a1[2];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305A] = a1[3];
  *(_DWORD *)&V_Type3_stru_10AE70.z1[0x305E] = a1[4];
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 1, 1, s, 0x40, v5, v6, 0);
  v8 = *(PANE *)a1;
  v8.x0 += 0x23;
  --v8.y1;
  ++v8.y0;
  return VFX_pane_wipe(&v8, color);
}
// 132B10: using guessed type int dword_132B10;

//----- (0005A594) --------------------------------------------------------
T_TypeA2 *__fastcall sub_5A594(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_961AC;
  return result;
}
// 961AC: using guessed type int (*off_961AC[5])();

//----- (0005A5AC) --------------------------------------------------------
void *__fastcall sub_5A5AC(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_9615C);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    *(_DWORD *)(a1 + 0xA7) = off_961AC;
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);
// 961AC: using guessed type int (*off_961AC[5])();

//----- (0005A5F4) --------------------------------------------------------
int __fastcall sub_5A5F4(T_TypeA1 *a1)
{
  int result; // eax

  result = sub_571B8(&V_Type3_stru_10AE70, a1);
  a1->l = result;
  return result;
}

//----- (0005A60C) --------------------------------------------------------
unsigned int __fastcall sub_5A60C(int a1, __int16 a2, __int16 a3, int a4)
{
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  char v16; // ah
  int v17; // eax
  int v18; // eax
  int v19; // ecx

  if ( (unsigned __int16)a2 < 0x3EBu )
  {
    if ( (unsigned __int16)a2 < 0xC8u )
    {
      if ( a2 && ((unsigned __int16)a2 <= 2u || (unsigned __int16)a2 >= 6u && (unsigned __int16)a2 <= 7u) )
      {
        return sub_2F424(a1, a2, a3, a4);
      }
      return 0;
    }
    if ( (unsigned __int16)a2 <= 0xC8u )
    {
      *(_BYTE *)(a1 + 0xBF) = 0;
      v6 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
      v7 = v6;
      if ( !v6 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x11D1);
      }
      sub_2ED4C(v6);
      *(_DWORD *)(v7 + 0xAB) = 0xFFFFFFFF;
      sub_2F1C8(v7, (int)sub_5A47C);
      if ( !*(_DWORD *)(v7 + 0x8E6) && !sub_2F228(v7, 0x2000u, 0) )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x11D9);
      }
      sub_5AE68(a1, v7);
      return 0;
    }
    else if ( (unsigned __int16)a2 <= 0xCAu )
    {
      sub_56B60((int)&V_Type3_stru_10AE70, 6, a2, 0);
      return 0xFFFFFFFF;
    }
    else if ( a2 == 0x3EA )
    {
      if ( *(_BYTE *)(a1 + 0xBF) )
      {
        *(_BYTE *)(a1 + 0xBF) = 0;
        v8 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
        v9 = v8;
        if ( !v8 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x11F0);
        }
        *(_DWORD *)(v8 + 0xAB) = 0xFFFFFFFF;
        sub_2F1C8(v8, (int)sub_5A47C);
        sub_2ED4C(v9);
        sub_5AE68(a1, v9);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
    else
    {
      return 0;
    }
  }
  else if ( (unsigned __int16)a2 <= 0x3EBu )
  {
    if ( *(_BYTE *)(a1 + 0xBF) != 1 )
    {
      *(_BYTE *)(a1 + 0xBF) = 1;
      v10 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
      v11 = v10;
      if ( !v10 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1204);
      }
      *(_DWORD *)(v10 + 0xAB) = 0xFFFFFFFF;
      sub_2F1C8(v10, (int)sub_5A47C);
      sub_2ED4C(v11);
      sub_5AB2C(a1, v11);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
  else if ( (unsigned __int16)a2 < 0x3EEu )
  {
    if ( (unsigned __int16)a2 <= 0x3ECu )
    {
      if ( *(_BYTE *)(a1 + 0xBF) != 2 )
      {
        *(_BYTE *)(a1 + 0xBF) = 2;
        v12 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
        v13 = v12;
        if ( !v12 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1218);
        }
        *(_DWORD *)(v12 + 0xAB) = 0xFFFFFFFF;
        sub_2F1C8(v12, (int)sub_5A47C);
        sub_2ED4C(v13);
        sub_5AF30(a1, v13);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
    else
    {
      if ( *(_BYTE *)(a1 + 0xBF) != 3 )
      {
        *(_BYTE *)(a1 + 0xBF) = 3;
        v18 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
        v19 = v18;
        if ( !v18 )
        {
          Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x122B);
        }
        *(_DWORD *)(v18 + 0xAB) = 0;
        sub_2F1C8(v18, (int)sub_5A4E4);
        sub_2ED4C(v19);
        sub_5B200(a1, v19);
        (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
      }
      return 0xFFFFFFFF;
    }
  }
  else
  {
    if ( (unsigned __int16)a2 > 0x3EEu )
    {
      if ( (unsigned __int16)a2 >= 0x3F1u )
      {
        if ( (unsigned __int16)a2 <= 0x3F1u )
        {
          if ( *(_BYTE *)(a1 + 0xBF) == 3 )
          {
            v17 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
            if ( !v17 )
            {
              Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x1262);
            }
            sub_2ECDC(v17, dword_132B10);
            (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
          }
          return 0xFFFFFFFF;
        }
        else if ( a2 == 0x1C01 )
        {
          v16 = *(_BYTE *)(a1 + 0xBF);
          if ( v16 == 3 )
          {
            if ( a4 == 5 )
            {
              *(_BYTE *)(*(_DWORD *)&V_Type3_stru_10AE70.z1[0x3012] + 0xF2) = a3;
            }
          }
          else if ( v16 == 4 )
          {
            sub_4F8CC((int)&unk_10914C, a3, 0);
          }
          return 0xFFFFFFFF;
        }
        else
        {
          return 0;
        }
      }
      return 0;
    }
    if ( *(_BYTE *)(a1 + 0xBF) != 4 )
    {
      *(_BYTE *)(a1 + 0xBF) = 4;
      v14 = sub_56DA8((int)&V_Type3_stru_10AE70, "DBGWNDLIST", 0);
      v15 = v14;
      if ( !v14 )
      {
        Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x123E);
      }
      *(_DWORD *)(v14 + 0xAB) = 0xFFFFFFFF;
      sub_2F1C8(v14, (int)sub_5A47C);
      sub_2ED4C(v15);
      sub_5B244(a1, v15);
      (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)(a1 + 0xA7) + 0xC))(a1, 0);
    }
    return 0xFFFFFFFF;
  }
}
// 132B10: using guessed type int dword_132B10;

//----- (0005AA08) --------------------------------------------------------
void __fastcall sub_5AA08(int a1)
{
  void *v1; // eax
  char v2; // dl
  const char *v3; // esi
  char *v4; // edi
  char v5; // al
  char v6; // al
  char v7[20]; // [esp+0h] [ebp-18h] BYREF
  _DWORD *v8; // [esp+14h] [ebp-4h]

  v8 = (_DWORD *)a1;
  v1 = (void *)sub_1B084((unsigned int)dword_12FC20, *(unsigned __int16 *)(a1 + 0x18));
  VFX_shape_draw((PANE *)(v8 + 1), v1, 0, 0, 0);
  VFX_pane_wipe((PANE *)((char *)v8 + 0xAB), 0xF2);
  v2 = *((_BYTE *)v8 + 0xBF);
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      v3 = "MEMORY    ";
    }
    else if ( v2 == 2 )
    {
      v3 = "CACHE     ";
    }
    else
    {
      v3 = "PALETTE   ";
    }
  }
  else
  {
    v3 = "WINDOWS   ";
  }
  v4 = v7;
  do
  {
    v5 = *v3;
    *v4 = *v3;
    if ( !v5 )
    {
      break;
    }
    v6 = v3[1];
    v3 += 2;
    v4[1] = v6;
    v4 += 2;
  }
  while ( v6 );
  sub_2B3E0(
    &V_Type3_stru_10AE70.z1[0x3046],
    *(_DWORD *)((char *)v8 + 0xAF),
    *(_DWORD *)((char *)v8 + 0xB3),
    *(_DWORD *)((char *)v8 + 0xB7),
    *(_DWORD *)((char *)v8 + 0xB3) + 0x32);
  sub_2B8A8((int)&V_Type3_stru_10AE70.z1[0x3046], 1, 1, v7, 0, 0xFFFFFFFF, 0xFFFFFFFF, 0);
  sub_2D218(v8);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0005AB04) --------------------------------------------------------
int __fastcall sub_5AB04(const char **a1, const char **a2)
{
  return strncmp(*a1, *a2, 6u);
}

//----- (0005AB2C) --------------------------------------------------------
void __fastcall sub_5AB2C(int a1, int a2)
{
  int v2; // ebp
  int v3; // edi
  char *v4; // eax
  unsigned __int16 v5; // ax
  __int16 v6; // cx
  unsigned __int16 v7; // ax
  int v8; // edi
  unsigned __int16 v9; // ax
  unsigned __int16 v10; // ax
  int v11; // ecx
  unsigned __int16 v12; // ax
  int v13; // edi
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // ax
  unsigned __int16 v16; // ax
  char s[80]; // [esp+0h] [ebp-98h] BYREF
  struct _heapinfo v18; // [esp+50h] [ebp-48h] BYREF
  int v19; // [esp+60h] [ebp-38h] BYREF
  int v20; // [esp+64h] [ebp-34h] BYREF
  int v21; // [esp+68h] [ebp-30h]
  int v22; // [esp+6Ch] [ebp-2Ch]
  int v23; // [esp+70h] [ebp-28h]
  int v24; // [esp+74h] [ebp-24h]
  int v25; // [esp+78h] [ebp-20h]
  int v26; // [esp+7Ch] [ebp-1Ch]
  __int16 v27; // [esp+80h] [ebp-18h]

  *(_BYTE *)(a1 + 0xBF) = 1;
  v2 = 0;
  v22 = 0;
  v21 = 0;
  v23 = 0;
  LOWORD(v25) = 0;
  LOWORD(v26) = 0;
  v27 = 0;
  LOWORD(v24) = 0;
  if ( heapchk() )
  {
    Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x12A9);
  }
  HIWORD(v18._pentry) = 0;
  LODWORD(v18._pentry) = 0;
  while ( !heapwalk(&v18) )
  {
    if ( v18._useflag )
    {
      v2 += v18._size;
    }
    else
    {
      v3 = LODWORD(v18._pentry) + 4;
      v4 = sub_5A194((int)&V_Type3_stru_10AE70, LODWORD(v18._pentry) + 4, &v19, &v20);
      if ( v4 )
      {
        switch ( v19 )
        {
          case 1:
          case 4:
          case 5:
            sprintf(s, "%06lu S%07lu %s", v20, v18._size, v4);
            v9 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
            sub_2EC50(a2, v9, v19);
            break;
          case 2:
            sprintf(s, "%06lu S%07lu WND[%s]", v20, v18._size, (const char *)(v3 + 0x20));
            v5 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
            v6 = v24;
            sub_2EC50(a2, v5, v19);
            LOWORD(v24) = v6 + 1;
            v21 += v18._size;
            break;
          case 3:
            sprintf(s, "%06lu S%07lu %s", v20, v18._size, v4);
            v7 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
            v8 = v23;
            sub_2EC50(a2, v7, v19);
            v23 = v18._size + v8;
            LOWORD(v25) = v25 + 1;
            break;
          default:
            Q_AssertLogBreakExit_sub_261A8(0, "..\\winmgr.cpp", 0x12E3);
        }
      }
      else
      {
        ++v27;
      }
      v22 += v18._size;
      LOWORD(v26) = v26 + 1;
    }
  }
  sprintf(s, "** %d WNDS USING %lu BYTES", (__int16)v24, v21);
  v10 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  v11 = v23;
  sub_2EC50(a2, v10, 0);
  sprintf(s, "** %d SHAPES USING %lu BYTES", (__int16)v25, v11);
  v12 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  v13 = v22;
  sub_2EC50(a2, v12, 0);
  sprintf(s, "** %d ITEMS IN HEAP USE %lu BYTES", (__int16)v26, v13);
  v14 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v14, 0);
  sprintf(s, "** %d ITEMS ARE UNIDENTIFIED", v27);
  v15 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v15, 0);
  sprintf(s, "** TOTAL FREE IN HEAP %lu BYTES", v2);
  v16 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v16, 0);
  sub_2F1D8(a2, (int)sub_5AB04);
  sub_2F1E0(a2);
}

//----- (0005AE68) --------------------------------------------------------
int __fastcall sub_5AE68(int a1, int a2)
{
  int v3; // edx
  __int16 v4; // si
  __int16 v5; // di
  int result; // eax
  int v7; // eax
  int v8; // edx
  char v9; // bl
  char s[72]; // [esp+0h] [ebp-48h] BYREF

  v3 = *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228];
  *(_BYTE *)(a1 + 0xBF) = 0;
  v4 = 0x1F;
  v5 = *(_WORD *)&V_Type3_stru_10AE70.z1[0x8E * v3 + 0x3068];
  while ( 1 )
  {
    result = v5;
    if ( v5 <= 0 )
    {
      break;
    }
    if ( v4 < 0 )
    {
      Q_AssertLogBreakExit_sub_26198(0, "..\\winmgr.cpp", 0x131E);
    }
    v7 = *(_DWORD *)&V_Type3_stru_10AE70.z1[0x8E * *(__int16 *)&V_Type3_stru_10AE70.z1[0x4228] + 0x306A + 4 * v4];
    if ( v7 )
    {
      v8 = *(&V_Type3_stru_10AE70.b1[0xFFFFFCE1].a + 3 * v7);
      if ( *(_DWORD *)(v8 + 0x63) )
      {
        v9 = 0x43;
      }
      else
      {
        v9 = 0x20;
      }
      sprintf(s, "%c HWND%03d %s", v9, v7, (const char *)(v8 + 0x20));
      --v5;
      sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
    }
    --v4;
  }
  return result;
}

//----- (0005AF30) --------------------------------------------------------
unsigned int __fastcall sub_5AF30(int a1, int a2)
{
  int v3; // edi
  _DWORD *v4; // ebp
  int v5; // edx
  unsigned __int16 v6; // ax
  int v7; // ecx
  int v8; // ebp
  int v9; // edx
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // ax
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // ax
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // dx
  char s[100]; // [esp+0h] [ebp-94h] BYREF
  _DWORD *v18; // [esp+64h] [ebp-30h]
  const char *v19; // [esp+68h] [ebp-2Ch]
  const char *v20; // [esp+6Ch] [ebp-28h]
  _DWORD *v21; // [esp+70h] [ebp-24h]
  _DWORD *v22; // [esp+74h] [ebp-20h]
  _DWORD *v23; // [esp+78h] [ebp-1Ch]
  int v24; // [esp+7Ch] [ebp-18h]

  v3 = 0;
  v21 = dword_12FC20;
  v24 = 0;
  v19 = (const char *)&dword_12FC20[0x1F4];
  v22 = dword_12FC20;
  v4 = dword_12FC20;
  while ( *((__int16 *)v21 + 0x1771) > v24 )
  {
    sprintf(
      s,
      "%07d %s",
      dword_12FC20[*((unsigned __int16 *)v4 + 0x320) + 0xC8],
      &v19[0x32 * *((unsigned __int16 *)v4 + 0x320)]);
    v5 = v22[0xC8];
    strupr(s);
    v3 += v5;
    v4 = (_DWORD *)((char *)v4 + 2);
    v6 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
    v7 = v24;
    sub_2EC50(a2, v6, 1);
    v24 = v7 + 1;
    ++v22;
  }
  sub_2EA8C(a2, " ", 0xFFFFFFFF, 0);
  v20 = (const char *)(v21 + 0x1F4);
  v8 = 0;
  v18 = v21;
  v23 = v21;
  do
  {
    if ( *((_BYTE *)v18 + 0x7D0) )
    {
      sprintf(s, "%s", &v20[0x32 * v8]);
      v9 = v23[0xC8];
      strupr(s);
      v3 += v9;
      v10 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
      sub_2EC50(a2, v10, 0);
    }
    ++v8;
    v18 = (_DWORD *)((char *)v18 + 0x32);
    ++v23;
  }
  while ( v8 < 0xC8 );
  sub_2EA8C(a2, " ", 0xFFFFFFFF, 0);
  sprintf(s, "%03d ITEMS IN CACHE", *((__int16 *)v21 + 0x1770));
  v11 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v11, 0);
  sprintf(s, "%03d ITEMS LOADED", *((__int16 *)v21 + 0x1771));
  v12 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v12, 0);
  sub_2EA8C(a2, " ", 0xFFFFFFFF, 0);
  sprintf(s, "%07d TOTAL CACHE SIZE", v21[0xBBA]);
  v13 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v13, 0);
  sprintf(s, "%07d USED", v3);
  v14 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  sub_2EC50(a2, v14, 0);
  sprintf(s, "%07d FREE", v21[0xBBA] - v3);
  v15 = sub_2EA8C(a2, s, 0xFFFFFFFF, 0);
  return sub_2EC50(a2, v15, 0);
}
// 12FC20: using guessed type _DWORD dword_12FC20[248];

//----- (0005B200) --------------------------------------------------------
int __fastcall sub_5B200(int a1, int a2)
{
  __int16 i; // si
  int result; // eax

  *(_BYTE *)(a1 + 0xBF) = 3;
  for ( i = 0; i < 0x100; result = sub_2EA8C(a2, (const char *)i++, 0xFFFFFFFF, 0) )
  {
    ;
  }
  return result;
}

//----- (0005B244) --------------------------------------------------------
int __fastcall sub_5B244(int result, int a2)
{
  int i; // esi
  char s[96]; // [esp+0h] [ebp-60h] BYREF

  *(_BYTE *)(result + 0xBF) = 4;
  for ( i = 0; (__int16)i < word_109846; result = sub_2EA8C(a2, s, 0xFFFFFFFF, 0) )
  {
    sprintf(
      s,
      "%02d. %-24s (%d)",
      (__int16)i,
      (const char *)&unk_1094C6 + 0x1C * (__int16)i,
      *((_DWORD *)&unk_1094C6 + 7 * (__int16)i + 6));
    ++i;
  }
  return result;
}
// 109846: using guessed type __int16 word_109846;

//----- (0005B2B0) --------------------------------------------------------
void *__fastcall sub_5B2B0(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96184);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0005B2F0) --------------------------------------------------------
T_TypeA2 *__fastcall sub_5B2F0(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_961C4;
  return result;
}
// 961C4: using guessed type int (*off_961C4[5])();

//----- (0005B300) --------------------------------------------------------
void *__fastcall sub_5B300(int a1, char a2)
{
  void *v3; // eax
  void *v5; // eax
  void *v6; // ebx

  if ( (a2 & 4) != 0 )
  {
    v3 = (void *)_wcpp_2_dtor_array_store_(a1, &unk_96198);
    operator delete[](v3);
    return (void *)a1;
  }
  else
  {
    v5 = (void *)sub_2C848(a1, 1);
    v6 = v5;
    if ( (a2 & 2) != 0 )
    {
      operator delete(v5);
    }
    return v6;
  }
}
// 76D3C: using guessed type int __fastcall _wcpp_2_dtor_array_store_(_DWORD, _DWORD);
// 76D5C: using guessed type void __fastcall operator delete[](void *);
// 76D64: using guessed type void __fastcall operator delete(void *);

//----- (0005B340) --------------------------------------------------------
T_TypeA2 *__fastcall sub_5B340(T_TypeA2 *result)
{
  sub_2C830(result);
  result->b = (int)off_961DC;
  return result;
}
// 961DC: using guessed type int (*off_961DC[5])();

//----- (0005B50C) --------------------------------------------------------
BOOL __fastcall sub_5B50C(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 != *a2 )
  {
    return 0;
  }
  if ( a1[4] < a2[2] )
  {
    return 0;
  }
  if ( a1[2] > a2[4] )
  {
    return 0;
  }
  if ( a1[3] < a2[1] )
  {
    return 0;
  }
  if ( a1[1] > a2[3] )
  {
    return 0;
  }
  if ( a1[1] < a2[1] )
  {
    return 0;
  }
  if ( a1[3] > a2[3] )
  {
    return 0;
  }
  if ( a1[2] >= a2[2] )
  {
    return a1[4] <= a2[4];
  }
  return 0;
}

//----- (0005B617) --------------------------------------------------------
_DWORD *__fastcall sub_5B617(size_t a1)
{
  _DWORD *ptr; // [esp+8h] [ebp-4h]

  ptr = malloc(0xCu);
  if ( !ptr )
  {
    return 0;
  }
  ptr[1] = calloc(a1, 4u);
  if ( ptr[1] )
  {
    *ptr = calloc(a1, 0x14u);
    if ( *ptr )
    {
      ptr[2] = a1;
      sub_5B71C((int)ptr);
      return ptr;
    }
    else
    {
      free((void *)ptr[1]);
      free(ptr);
      return 0;
    }
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (0005B71C) --------------------------------------------------------
unsigned int __fastcall sub_5B71C(int a1)
{
  unsigned int result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 8) )
    {
      break;
    }
    *(_DWORD *)(4 * i + *(_DWORD *)(a1 + 4)) = 0;
  }
  return result;
}

//----- (0005B7C2) --------------------------------------------------------
unsigned int __fastcall sub_5B7C2(_DWORD *a1, int a2, int x1, int y1, int x2, int y2)
{
  int *v9; // [esp+14h] [ebp-10h]
  int *v10; // [esp+18h] [ebp-Ch]
  unsigned int v11; // [esp+1Ch] [ebp-8h]
  unsigned int i; // [esp+20h] [ebp-4h]

  for ( i = 0; i < a1[2] && *(_DWORD *)(4 * i + a1[1]); ++i )
  {
    ;
  }
  if ( i == a1[2] )
  {
    return 0xFFFFFFFF;
  }
  *(_DWORD *)(4 * i + a1[1]) = 1;
  v10 = (int *)(0x14 * i + *a1);
  *v10 = a2;
  v10[1] = x1;
  v10[2] = y1;
  v10[3] = x2;
  v10[4] = y2;
  v11 = 0;
  v9 = (int *)*a1;
  while ( v11 < a1[2] )
  {
    if ( *(_DWORD *)(4 * v11 + a1[1]) && v10 != v9 && sub_5B50C(v10, v9) )
    {
      *(_DWORD *)(4 * i + a1[1]) = 2;
      return i;
    }
    ++v11;
    v9 += 5;
  }
  return i;
}

//----- (0005BA38) --------------------------------------------------------
unsigned int __fastcall sub_5BA38(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1[2] )
    {
      break;
    }
    if ( *(_DWORD *)(4 * i + a1[1]) == 1 )
    {
      VFX_pane_refresh(
        (PANE *)(0x14 * i + *a1),
        *(_DWORD *)(0x14 * i + *a1 + 4),
        *(_DWORD *)(0x14 * i + *a1 + 8),
        *(_DWORD *)(0x14 * i + *a1 + 0xC),
        *(_DWORD *)(0x14 * i + *a1 + 0x10));
    }
  }
  return result;
}

//----- (0005BAC0) --------------------------------------------------------
int __fastcall sub_5BAC0(_DWORD *a1, int a2)
{
  unsigned __int8 *v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  unsigned int m; // [esp+1Ch] [ebp-1Ch]
  BOOL v6; // [esp+20h] [ebp-18h]
  unsigned int k; // [esp+24h] [ebp-14h]
  unsigned int i; // [esp+28h] [ebp-10h]
  unsigned int j; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  unsigned int v11; // [esp+34h] [ebp-4h]

  v11 = a1[1] + 1;
  v10 = a1[2] + 1;
  v4 = 4 * v10;
  for ( i = 0; i < v10; ++i )
  {
    v3 = (unsigned __int8 *)(i * v11 + *a1);
    for ( j = 0; j < v11; j = k )
    {
      v6 = *v3 == a2;
      for ( k = j + 1; k < v11; ++k )
      {
        if ( (*++v3 == a2) != v6 )
        {
          break;
        }
      }
      for ( m = k - j; m > 0x7F; m -= 0x7F )
      {
        ++v4;
      }
      ++v4;
    }
  }
  return v4;
}

//----- (0005BBE4) --------------------------------------------------------
char *__fastcall sub_5BBE4(void **a1, char *a2, int a3)
{
  int v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *s2; // [esp+Ch] [ebp-34h]
  _DWORD *ptr; // [esp+18h] [ebp-28h]
  char *v11; // [esp+1Ch] [ebp-24h]
  unsigned __int8 *v12; // [esp+20h] [ebp-20h]
  unsigned int m; // [esp+24h] [ebp-1Ch]
  BOOL v14; // [esp+28h] [ebp-18h]
  bool v15; // [esp+28h] [ebp-18h]
  unsigned int k; // [esp+2Ch] [ebp-14h]
  unsigned int i; // [esp+30h] [ebp-10h]
  unsigned int j; // [esp+34h] [ebp-Ch]
  unsigned int v19; // [esp+38h] [ebp-8h]
  unsigned int v20; // [esp+3Ch] [ebp-4h]

  s2 = a2;
  v20 = (unsigned int)a1[1] + 1;
  v19 = (unsigned int)a1[2] + 1;
  if ( a2 == *a1 )
  {
    if ( sub_5BAC0(a1, a3) > v19 * v20 )
    {
      return 0;
    }
  }
  else if ( !a2 )
  {
    v3 = sub_5BAC0(a1, a3);
    s2 = (char *)malloc(v3);
    if ( !s2 )
    {
      return 0;
    }
  }
  ptr = malloc(4 * v19);
  if ( !ptr )
  {
    return 0;
  }
  v11 = s2;
  for ( i = 0; i < v19; ++i )
  {
    v12 = (unsigned __int8 *)*a1 + i * v20;
    ptr[i] = v11 - s2 + 4 * v19;
    for ( j = 0; j < v20; j = k )
    {
      v14 = *v12 == a3;
      for ( k = j + 1; k < v20; ++k )
      {
        if ( (*++v12 == a3) != v14 )
        {
          break;
        }
      }
      v15 = v14 << 7;
      for ( m = k - j; m > 0x7F; m -= 0x7F )
      {
        v4 = v11++;
        *v4 = v15 | 0x7F;
      }
      v5 = v11++;
      *v5 = m | v15;
    }
  }
  memmove(&s2[4 * v19], s2, v11 - s2);
  memmove(s2, ptr, 4 * v19);
  free(ptr);
  return s2;
}

//----- (0005BDDC) --------------------------------------------------------
void __fastcall sub_5BDDC(void *a1)
{
  free(a1);
}

// nfuncs=1959 queued=809 decompiled=809 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 809 function(s)"
